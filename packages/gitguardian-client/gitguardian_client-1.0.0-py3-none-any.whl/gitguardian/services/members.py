# This file was generated by liblab | https://liblab.com/

from typing import List
from .utils.validator import Validator
from .utils.base_service import BaseService
from ..net.transport.serializer import Serializer
from ..models.validity_enum import ValidityEnum
from ..models.utils.cast_models import cast_models
from ..models.team_membership import TeamMembership
from ..models.team import Team
from ..models.status_enum import StatusEnum
from ..models.severity_enum import SeverityEnum
from ..models.resource_type import ResourceType
from ..models.resource_member_access import ResourceMemberAccess
from ..models.member_access_level_enum import MemberAccessLevelEnum
from ..models.member import Member
from ..models.list_members_ordering import ListMembersOrdering
from ..models.list_member_secret_incident_access_ordering import (
    ListMemberSecretIncidentAccessOrdering,
)
from ..models.incident_without_occurrences import IncidentWithoutOccurrences


class MembersService(BaseService):

    @cast_models
    def list_members(
        self,
        cursor: str = None,
        page: int = None,
        per_page: int = None,
        role: MemberAccessLevelEnum = None,
        access_level: MemberAccessLevelEnum = None,
        search: str = None,
        ordering: ListMembersOrdering = None,
    ) -> List[Member]:
        """List members of the workspace.

        :param cursor: Pagination cursor., defaults to None
        :type cursor: str, optional
        :param page: Page number., defaults to None
        :type page: int, optional
        :param per_page: Number of items to list per page., defaults to None
        :type per_page: int, optional
        :param role: role, defaults to None
        :type role: MemberAccessLevelEnum, optional
        :param access_level: access_level, defaults to None
        :type access_level: MemberAccessLevelEnum, optional
        :param search: search, defaults to None
        :type search: str, optional
        :param ordering: Sort the results by their field value. The default sort is ASC, DESC if the
        field is preceded by a '-'., defaults to None
        :type ordering: ListMembersOrdering, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: List members
        :rtype: List[Member]
        """

        Validator(str).is_optional().validate(cursor)
        Validator(int).is_optional().min(0).validate(page)
        Validator(int).is_optional().min(1).max(100).validate(per_page)
        Validator(MemberAccessLevelEnum).is_optional().validate(role)
        Validator(MemberAccessLevelEnum).is_optional().validate(access_level)
        Validator(str).is_optional().validate(search)
        Validator(ListMembersOrdering).is_optional().validate(ordering)

        serialized_request = (
            Serializer(f"{self.base_url}/v1/members", self.get_default_headers())
            .add_query("cursor", cursor)
            .add_query("page", page)
            .add_query("per_page", per_page)
            .add_query("role", role)
            .add_query("access_level", access_level)
            .add_query("search", search)
            .add_query("ordering", ordering)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return [Member._unmap(item) for item in response]

    @cast_models
    def retrieve_member(self, member_id: int) -> Member:
        """Retrieve an existing workspace member.

        If you are using a personal access token, you need to have an access level greater or equal to `member`.

        :param member_id: The id of the workspace member
        :type member_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Workspace member details
        :rtype: Member
        """

        Validator(int).validate(member_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/members/{{member_id}}", self.get_default_headers()
            )
            .add_path("member_id", member_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return Member._unmap(response)

    @cast_models
    def update_member(self, member_id: int, request_body: Member = None) -> Member:
        """Update an existing workspace member.

        If you are using a personal access token, you need to have an access level greater or equal to `manager`.

        :param request_body: The request body., defaults to None
        :type request_body: Member, optional
        :param member_id: The id of the workspace member
        :type member_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Workspace member details
        :rtype: Member
        """

        Validator(Member).is_optional().validate(request_body)
        Validator(int).validate(member_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/members/{{member_id}}", self.get_default_headers()
            )
            .add_path("member_id", member_id)
            .serialize()
            .set_method("PATCH")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return Member._unmap(response)

    @cast_models
    def delete_member(self, member_id: int):
        """Delete an existing workspace member.

        If you are using a personal access token, you need to have an access level greater or equal to `manager`.

        :param member_id: The id of the workspace member
        :type member_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(int).validate(member_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/members/{{member_id}}", self.get_default_headers()
            )
            .add_path("member_id", member_id)
            .serialize()
            .set_method("DELETE")
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def list_member_teams(
        self,
        member_id: int,
        cursor: str = None,
        per_page: int = None,
        search: str = None,
        is_global: bool = None,
    ) -> List[Team]:
        """List teams of a workspace member.
        The response contains the list of teams and a pagination cursor to retrieve the next page.

        The teams are sorted by id.

        If you are using a personal access token, you need to have an access level superior or equal to `manager` except if the requested member is yourself.

        :param member_id: The id of the workspace member
        :type member_id: int
        :param cursor: Pagination cursor., defaults to None
        :type cursor: str, optional
        :param per_page: Number of items to list per page., defaults to None
        :type per_page: int, optional
        :param search: search, defaults to None
        :type search: str, optional
        :param is_global: is_global, defaults to None
        :type is_global: bool, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: List teams
        :rtype: List[Team]
        """

        Validator(int).validate(member_id)
        Validator(str).is_optional().validate(cursor)
        Validator(int).is_optional().min(1).max(100).validate(per_page)
        Validator(str).is_optional().validate(search)
        Validator(bool).is_optional().validate(is_global)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/members/{{member_id}}/teams",
                self.get_default_headers(),
            )
            .add_path("member_id", member_id)
            .add_query("cursor", cursor)
            .add_query("per_page", per_page)
            .add_query("search", search)
            .add_query("is_global", is_global)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return [Team._unmap(item) for item in response]

    @cast_models
    def get_member_resource_access(
        self, member_id: int, resource_type: ResourceType, resource_id: int
    ) -> ResourceMemberAccess:
        """Return the permission a member has on a resource.

        The permission is the higher value between the different accesses the member can
        have (direct access, member's teams accesses, and administrator access).

        :param member_id: The id of the workspace member
        :type member_id: int
        :param resource_type: The kind of resource of the access
        :type resource_type: ResourceType
        :param resource_id: The id of the resource of the access
        :type resource_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Member resource access details
        :rtype: ResourceMemberAccess
        """

        Validator(int).validate(member_id)
        Validator(ResourceType).validate(resource_type)
        Validator(int).validate(resource_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/members/{{member_id}}/{{resource_type}}/{{resource_id}}",
                self.get_default_headers(),
            )
            .add_path("member_id", member_id)
            .add_path("resource_type", resource_type)
            .add_path("resource_id", resource_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return ResourceMemberAccess._unmap(response)

    @cast_models
    def set_member_resource_access(
        self,
        request_body: ResourceMemberAccess,
        member_id: int,
        resource_type: ResourceType,
        resource_id: int,
    ) -> ResourceMemberAccess:
        """This will create or update a direct access for the member on the resource.

        If the member has higher permission from another source, they will take precedence
        over those you have given.

        :param request_body: The request body.
        :type request_body: ResourceMemberAccess
        :param member_id: The id of the workspace member
        :type member_id: int
        :param resource_type: The kind of resource of the access
        :type resource_type: ResourceType
        :param resource_id: The id of the resource of the access
        :type resource_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The access was updated successfully.
        :rtype: ResourceMemberAccess
        """

        Validator(ResourceMemberAccess).validate(request_body)
        Validator(int).validate(member_id)
        Validator(ResourceType).validate(resource_type)
        Validator(int).validate(resource_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/members/{{member_id}}/{{resource_type}}/{{resource_id}}",
                self.get_default_headers(),
            )
            .add_path("member_id", member_id)
            .add_path("resource_type", resource_type)
            .add_path("resource_id", resource_id)
            .serialize()
            .set_method("PUT")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return ResourceMemberAccess._unmap(response)

    @cast_models
    def revoke_member_resource_access(
        self,
        request_body: ResourceMemberAccess,
        member_id: int,
        resource_type: ResourceType,
        resource_id: int,
    ):
        """Revoke a member access to a resource.

        This only works for direct accesses. If the member has only indirect access, a 404
        is returned.

        :param request_body: The request body.
        :type request_body: ResourceMemberAccess
        :param member_id: The id of the workspace member
        :type member_id: int
        :param resource_type: The kind of resource of the access
        :type resource_type: ResourceType
        :param resource_id: The id of the resource of the access
        :type resource_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(ResourceMemberAccess).validate(request_body)
        Validator(int).validate(member_id)
        Validator(ResourceType).validate(resource_type)
        Validator(int).validate(resource_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/members/{{member_id}}/{{resource_type}}/{{resource_id}}",
                self.get_default_headers(),
            )
            .add_path("member_id", member_id)
            .add_path("resource_type", resource_type)
            .add_path("resource_id", resource_id)
            .serialize()
            .set_method("DELETE")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def list_member_secret_incident_access(
        self,
        member_id: int,
        cursor: str = None,
        page: int = None,
        per_page: int = None,
        date_before: str = None,
        date_after: str = None,
        assignee_email: str = None,
        assignee_id: int = None,
        status: StatusEnum = None,
        severity: SeverityEnum = None,
        validity: ValidityEnum = None,
        tags: any = None,
        ordering: ListMemberSecretIncidentAccessOrdering = None,
        detector_group_name: str = None,
        ignorer_id: int = None,
        ignorer_api_token_id: str = None,
        resolver_id: int = None,
        resolver_api_token_id: str = None,
    ) -> List[IncidentWithoutOccurrences]:
        """List secret incidents that a member has access to.

        :param member_id: The id of the workspace member
        :type member_id: int
        :param cursor: Pagination cursor., defaults to None
        :type cursor: str, optional
        :param page: Page number., defaults to None
        :type page: int, optional
        :param per_page: Number of items to list per page., defaults to None
        :type per_page: int, optional
        :param date_before: date_before, defaults to None
        :type date_before: str, optional
        :param date_after: date_after, defaults to None
        :type date_after: str, optional
        :param assignee_email: assignee_email, defaults to None
        :type assignee_email: str, optional
        :param assignee_id: assignee_id, defaults to None
        :type assignee_id: int, optional
        :param status: status, defaults to None
        :type status: StatusEnum, optional
        :param severity: severity, defaults to None
        :type severity: SeverityEnum, optional
        :param validity: validity, defaults to None
        :type validity: ValidityEnum, optional
        :param tags: tags, defaults to None
        :type tags: any, optional
        :param ordering: Sort the results by their field value. The default sort is ASC, DESC if the
        field is preceded by a '-'., defaults to None
        :type ordering: ListMemberSecretIncidentAccessOrdering, optional
        :param detector_group_name: detector_group_name, defaults to None
        :type detector_group_name: str, optional
        :param ignorer_id: ignorer_id, defaults to None
        :type ignorer_id: int, optional
        :param ignorer_api_token_id: ignorer_api_token_id, defaults to None
        :type ignorer_api_token_id: str, optional
        :param resolver_id: resolver_id, defaults to None
        :type resolver_id: int, optional
        :param resolver_api_token_id: resolver_api_token_id, defaults to None
        :type resolver_api_token_id: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Secret Incident List
        :rtype: List[IncidentWithoutOccurrences]
        """

        Validator(int).validate(member_id)
        Validator(str).is_optional().validate(cursor)
        Validator(int).is_optional().min(0).validate(page)
        Validator(int).is_optional().min(1).max(100).validate(per_page)
        Validator(str).is_optional().validate(date_before)
        Validator(str).is_optional().validate(date_after)
        Validator(str).is_optional().validate(assignee_email)
        Validator(int).is_optional().validate(assignee_id)
        Validator(StatusEnum).is_optional().validate(status)
        Validator(SeverityEnum).is_optional().validate(severity)
        Validator(ValidityEnum).is_optional().validate(validity)
        Validator(any).is_optional().validate(tags)
        Validator(ListMemberSecretIncidentAccessOrdering).is_optional().validate(
            ordering
        )
        Validator(str).is_optional().validate(detector_group_name)
        Validator(int).is_optional().validate(ignorer_id)
        Validator(str).is_optional().validate(ignorer_api_token_id)
        Validator(int).is_optional().validate(resolver_id)
        Validator(str).is_optional().validate(resolver_api_token_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/members/{{member_id}}/secret-incidents",
                self.get_default_headers(),
            )
            .add_path("member_id", member_id)
            .add_query("cursor", cursor)
            .add_query("page", page)
            .add_query("per_page", per_page)
            .add_query("date_before", date_before)
            .add_query("date_after", date_after)
            .add_query("assignee_email", assignee_email)
            .add_query("assignee_id", assignee_id)
            .add_query("status", status)
            .add_query("severity", severity)
            .add_query("validity", validity)
            .add_query("tags", tags)
            .add_query("ordering", ordering)
            .add_query("detector_group_name", detector_group_name)
            .add_query("ignorer_id", ignorer_id)
            .add_query("ignorer_api_token_id", ignorer_api_token_id)
            .add_query("resolver_id", resolver_id)
            .add_query("resolver_api_token_id", resolver_api_token_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return [IncidentWithoutOccurrences._unmap(item) for item in response]

    @cast_models
    def list_member_team_memberships(
        self,
        member_id: int,
        cursor: str = None,
        per_page: int = None,
        team_id: int = None,
    ) -> List[TeamMembership]:
        """List team memberships of a workspace member.
        The response contains the list of team memberships and a pagination cursor to retrieve the next page.

        The team memberships are sorted by id.

        If you are using a personal access token, you need to have an access level superior or equal to `manager` except if the requested member is yourself.

        :param member_id: The id of the workspace member
        :type member_id: int
        :param cursor: Pagination cursor., defaults to None
        :type cursor: str, optional
        :param per_page: Number of items to list per page., defaults to None
        :type per_page: int, optional
        :param team_id: The id of a team to filter on, defaults to None
        :type team_id: int, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Team membership list
        :rtype: List[TeamMembership]
        """

        Validator(int).validate(member_id)
        Validator(str).is_optional().validate(cursor)
        Validator(int).is_optional().min(1).max(100).validate(per_page)
        Validator(int).is_optional().validate(team_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/members/{{member_id}}/team_memberships",
                self.get_default_headers(),
            )
            .add_path("member_id", member_id)
            .add_query("cursor", cursor)
            .add_query("per_page", per_page)
            .add_query("team_id", team_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return [TeamMembership._unmap(item) for item in response]
