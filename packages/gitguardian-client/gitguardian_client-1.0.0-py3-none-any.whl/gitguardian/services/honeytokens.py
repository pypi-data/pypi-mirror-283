# This file was generated by liblab | https://liblab.com/

from typing import List
from .utils.validator import Validator
from .utils.base_service import BaseService
from ..net.transport.serializer import Serializer
from ..models.utils.cast_models import cast_models
from ..models.update_honeytoken_request import UpdateHoneytokenRequest
from ..models.list_honeytoken_type import ListHoneytokenType
from ..models.list_honeytoken_status import ListHoneytokenStatus
from ..models.list_honeytoken_ordering import ListHoneytokenOrdering
from ..models.honeytoken import Honeytoken
from ..models.honey_token_with_context import HoneyTokenWithContext
from ..models.create_honeytoken_with_context_request import (
    CreateHoneytokenWithContextRequest,
)
from ..models.create_honeytoken_request import CreateHoneytokenRequest


class HoneytokensService(BaseService):

    @cast_models
    def list_honeytoken(
        self,
        cursor: str = None,
        per_page: int = None,
        status: ListHoneytokenStatus = None,
        type_: ListHoneytokenType = None,
        search: str = None,
        creator_id: float = None,
        revoker_id: float = None,
        creator_api_token_id: str = None,
        revoker_api_token_id: str = None,
        tags: str = None,
        ordering: ListHoneytokenOrdering = None,
        show_token: bool = None,
    ) -> List[Honeytoken]:
        """This endpoint allows you to list all the honeytokens of your workspace.

        The response contains the list of honeytokens and a pagination cursor to retrieve the next page.

        The honeytokens are sorted by id.

        If you are using a personal access token, you need to have an access level superior or equal to `manager`.

        :param cursor: Pagination cursor., defaults to None
        :type cursor: str, optional
        :param per_page: Number of items to list per page., defaults to None
        :type per_page: int, optional
        :param status: status, defaults to None
        :type status: ListHoneytokenStatus, optional
        :param type_: type_, defaults to None
        :type type_: ListHoneytokenType, optional
        :param search: search, defaults to None
        :type search: str, optional
        :param creator_id: creator_id, defaults to None
        :type creator_id: float, optional
        :param revoker_id: revoker_id, defaults to None
        :type revoker_id: float, optional
        :param creator_api_token_id: creator_api_token_id, defaults to None
        :type creator_api_token_id: str, optional
        :param revoker_api_token_id: revoker_api_token_id, defaults to None
        :type revoker_api_token_id: str, optional
        :param tags: tags, defaults to None
        :type tags: str, optional
        :param ordering: Sort the results by their field value. The default sort is ASC, DESC if the
        field is preceded by a '-'., defaults to None
        :type ordering: ListHoneytokenOrdering, optional
        :param show_token: show_token, defaults to None
        :type show_token: bool, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: List honeytokens
        :rtype: List[Honeytoken]
        """

        Validator(str).is_optional().validate(cursor)
        Validator(int).is_optional().min(1).max(100).validate(per_page)
        Validator(ListHoneytokenStatus).is_optional().validate(status)
        Validator(ListHoneytokenType).is_optional().validate(type_)
        Validator(str).is_optional().validate(search)
        Validator(float).is_optional().validate(creator_id)
        Validator(float).is_optional().validate(revoker_id)
        Validator(str).is_optional().validate(creator_api_token_id)
        Validator(str).is_optional().validate(revoker_api_token_id)
        Validator(str).is_optional().validate(tags)
        Validator(ListHoneytokenOrdering).is_optional().validate(ordering)
        Validator(bool).is_optional().validate(show_token)

        serialized_request = (
            Serializer(f"{self.base_url}/v1/honeytokens", self.get_default_headers())
            .add_query("cursor", cursor)
            .add_query("per_page", per_page)
            .add_query("status", status)
            .add_query("type", type_)
            .add_query("search", search)
            .add_query("creator_id", creator_id)
            .add_query("revoker_id", revoker_id)
            .add_query("creator_api_token_id", creator_api_token_id)
            .add_query("revoker_api_token_id", revoker_api_token_id)
            .add_query("tags", tags)
            .add_query("ordering", ordering)
            .add_query("show_token", show_token)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return [Honeytoken._unmap(item) for item in response]

    @cast_models
    def create_honeytoken(
        self, request_body: CreateHoneytokenRequest = None
    ) -> Honeytoken:
        """This endpoint allows you to create a honeytoken of a type.

        If you are using a personal access token, you need to have an access level superior or equal to `manager`.

        :param request_body: The request body., defaults to None
        :type request_body: CreateHoneytokenRequest, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Honeytoken created
        :rtype: Honeytoken
        """

        Validator(CreateHoneytokenRequest).is_optional().validate(request_body)

        serialized_request = (
            Serializer(f"{self.base_url}/v1/honeytokens", self.get_default_headers())
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return Honeytoken._unmap(response)

    @cast_models
    def create_honeytoken_with_context(
        self, request_body: CreateHoneytokenWithContextRequest = None
    ) -> HoneyTokenWithContext:
        """This endpoint allows you to create a honeytoken of a given type within
        a context. The context is a realistic file in which your honeytoken is inserted.

        If `language`, `project_extensions` and `filename` are not provided, a random context will be generated.

        :param request_body: The request body., defaults to None
        :type request_body: CreateHoneytokenWithContextRequest, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Honeytoken within a context created
        :rtype: HoneyTokenWithContext
        """

        Validator(CreateHoneytokenWithContextRequest).is_optional().validate(
            request_body
        )

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/honeytokens/with-context",
                self.get_default_headers(),
            )
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return HoneyTokenWithContext._unmap(response)

    @cast_models
    def retrieve_honeytoken(
        self, honeytoken_id: str, show_token: bool = None
    ) -> Honeytoken:
        """Retrieve an existing honeytoken.

        If you are using a personal access token, you need to have an access level greater or equal to `manager`.

        :param honeytoken_id: The id of the honeytoken to retrieve
        :type honeytoken_id: str
        :param show_token: show_token, defaults to None
        :type show_token: bool, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Honeytoken details
        :rtype: Honeytoken
        """

        Validator(str).validate(honeytoken_id)
        Validator(bool).is_optional().validate(show_token)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/honeytokens/{{honeytoken_id}}",
                self.get_default_headers(),
            )
            .add_path("honeytoken_id", honeytoken_id)
            .add_query("show_token", show_token)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return Honeytoken._unmap(response)

    @cast_models
    def update_honeytoken(
        self, honeytoken_id: str, request_body: UpdateHoneytokenRequest = None
    ) -> Honeytoken:
        """Update a name or descriptions of an existing honeytoken.

        :param request_body: The request body., defaults to None
        :type request_body: UpdateHoneytokenRequest, optional
        :param honeytoken_id: The id of the honeytoken to retrieve
        :type honeytoken_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The honeytoken was updated successfully.
        :rtype: Honeytoken
        """

        Validator(UpdateHoneytokenRequest).is_optional().validate(request_body)
        Validator(str).validate(honeytoken_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/honeytokens/{{honeytoken_id}}",
                self.get_default_headers(),
            )
            .add_path("honeytoken_id", honeytoken_id)
            .serialize()
            .set_method("PATCH")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return Honeytoken._unmap(response)

    @cast_models
    def reset_honeytoken(self, honeytoken_id: str) -> Honeytoken:
        """Resets a triggered honeytoken. All the associated events will be closed.

        :param honeytoken_id: The id of the honeytoken to retrieve
        :type honeytoken_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Honeytoken was successfully revoked.
        :rtype: Honeytoken
        """

        Validator(str).validate(honeytoken_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/honeytokens/{{honeytoken_id}}/reset",
                self.get_default_headers(),
            )
            .add_path("honeytoken_id", honeytoken_id)
            .serialize()
            .set_method("POST")
        )

        response = self.send_request(serialized_request)

        return Honeytoken._unmap(response)

    @cast_models
    def revoke_honeytoken(self, honeytoken_id: str) -> Honeytoken:
        """Revokes an active or triggered honeytoken. All the associated events will be closed.

        :param honeytoken_id: The id of the honeytoken to retrieve
        :type honeytoken_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Honeytoken was successfully revoked.
        :rtype: Honeytoken
        """

        Validator(str).validate(honeytoken_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/honeytokens/{{honeytoken_id}}/revoke",
                self.get_default_headers(),
            )
            .add_path("honeytoken_id", honeytoken_id)
            .serialize()
            .set_method("POST")
        )

        response = self.send_request(serialized_request)

        return Honeytoken._unmap(response)
