# This file was generated by liblab | https://liblab.com/

from typing import List
from .utils.validator import Validator
from .utils.base_service import BaseService
from ..net.transport.serializer import Serializer
from ..models.validity_enum import ValidityEnum
from ..models.utils.cast_models import cast_models
from ..models.team import Team
from ..models.status_enum import StatusEnum
from ..models.share_incident_request import ShareIncidentRequest
from ..models.severity_enum import SeverityEnum
from ..models.revoke_access_incident_request import RevokeAccessIncidentRequest
from ..models.retrieve_incidents_leaks_ok_response import (
    RetrieveIncidentsLeaksOkResponse,
)
from ..models.resolve_incident_request import ResolveIncidentRequest
from ..models.member_access_level_enum import MemberAccessLevelEnum
from ..models.member import Member
from ..models.list_team_incidents_ordering import ListTeamIncidentsOrdering
from ..models.list_sources_incidents_ordering import ListSourcesIncidentsOrdering
from ..models.list_secret_incident_member_access_ordering import (
    ListSecretIncidentMemberAccessOrdering,
)
from ..models.list_secret_incident_invitation_access_ordering import (
    ListSecretIncidentInvitationAccessOrdering,
)
from ..models.list_incidents_ordering import ListIncidentsOrdering
from ..models.invitation import Invitation
from ..models.incident_without_occurrences import IncidentWithoutOccurrences
from ..models.incident_token import IncidentToken
from ..models.incident_team import IncidentTeam
from ..models.incident_permission_enum import IncidentPermissionEnum
from ..models.incident_member import IncidentMember
from ..models.incident_invitation import IncidentInvitation
from ..models.incident import Incident
from ..models.ignore_incident_request import IgnoreIncidentRequest
from ..models.grant_access_incident_request import GrantAccessIncidentRequest
from ..models.assign_incident_request import AssignIncidentRequest


class SecretIncidentsService(BaseService):

    @cast_models
    def list_incidents(
        self,
        cursor: str = None,
        page: int = None,
        per_page: int = None,
        date_before: str = None,
        date_after: str = None,
        assignee_email: str = None,
        assignee_id: int = None,
        status: StatusEnum = None,
        severity: SeverityEnum = None,
        validity: ValidityEnum = None,
        tags: any = None,
        ordering: ListIncidentsOrdering = None,
        detector_group_name: str = None,
        ignorer_id: int = None,
        ignorer_api_token_id: str = None,
        resolver_id: int = None,
        resolver_api_token_id: str = None,
    ) -> List[IncidentWithoutOccurrences]:
        """List secret incidents detected by the GitGuardian dashboard.
        Occurrences are not returned in this route.

        :param cursor: Pagination cursor., defaults to None
        :type cursor: str, optional
        :param page: Page number., defaults to None
        :type page: int, optional
        :param per_page: Number of items to list per page., defaults to None
        :type per_page: int, optional
        :param date_before: date_before, defaults to None
        :type date_before: str, optional
        :param date_after: date_after, defaults to None
        :type date_after: str, optional
        :param assignee_email: assignee_email, defaults to None
        :type assignee_email: str, optional
        :param assignee_id: assignee_id, defaults to None
        :type assignee_id: int, optional
        :param status: status, defaults to None
        :type status: StatusEnum, optional
        :param severity: severity, defaults to None
        :type severity: SeverityEnum, optional
        :param validity: validity, defaults to None
        :type validity: ValidityEnum, optional
        :param tags: tags, defaults to None
        :type tags: any, optional
        :param ordering: Sort the results by their field value. The default sort is ASC, DESC if the
        field is preceded by a '-'., defaults to None
        :type ordering: ListIncidentsOrdering, optional
        :param detector_group_name: detector_group_name, defaults to None
        :type detector_group_name: str, optional
        :param ignorer_id: ignorer_id, defaults to None
        :type ignorer_id: int, optional
        :param ignorer_api_token_id: ignorer_api_token_id, defaults to None
        :type ignorer_api_token_id: str, optional
        :param resolver_id: resolver_id, defaults to None
        :type resolver_id: int, optional
        :param resolver_api_token_id: resolver_api_token_id, defaults to None
        :type resolver_api_token_id: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Secret Incident List
        :rtype: List[IncidentWithoutOccurrences]
        """

        Validator(str).is_optional().validate(cursor)
        Validator(int).is_optional().min(0).validate(page)
        Validator(int).is_optional().min(1).max(100).validate(per_page)
        Validator(str).is_optional().validate(date_before)
        Validator(str).is_optional().validate(date_after)
        Validator(str).is_optional().validate(assignee_email)
        Validator(int).is_optional().validate(assignee_id)
        Validator(StatusEnum).is_optional().validate(status)
        Validator(SeverityEnum).is_optional().validate(severity)
        Validator(ValidityEnum).is_optional().validate(validity)
        Validator(any).is_optional().validate(tags)
        Validator(ListIncidentsOrdering).is_optional().validate(ordering)
        Validator(str).is_optional().validate(detector_group_name)
        Validator(int).is_optional().validate(ignorer_id)
        Validator(str).is_optional().validate(ignorer_api_token_id)
        Validator(int).is_optional().validate(resolver_id)
        Validator(str).is_optional().validate(resolver_api_token_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/incidents/secrets", self.get_default_headers()
            )
            .add_query("cursor", cursor)
            .add_query("page", page)
            .add_query("per_page", per_page)
            .add_query("date_before", date_before)
            .add_query("date_after", date_after)
            .add_query("assignee_email", assignee_email)
            .add_query("assignee_id", assignee_id)
            .add_query("status", status)
            .add_query("severity", severity)
            .add_query("validity", validity)
            .add_query("tags", tags)
            .add_query("ordering", ordering)
            .add_query("detector_group_name", detector_group_name)
            .add_query("ignorer_id", ignorer_id)
            .add_query("ignorer_api_token_id", ignorer_api_token_id)
            .add_query("resolver_id", resolver_id)
            .add_query("resolver_api_token_id", resolver_api_token_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return [IncidentWithoutOccurrences._unmap(item) for item in response]

    @cast_models
    def retrieve_incidents(
        self, incident_id: int, with_occurrences: int = None
    ) -> Incident:
        """Retrieve secret incident detected by the GitGuardian dashboard with
        its occurrences.

        :param incident_id: The id of the incident to retrieve
        :type incident_id: int
        :param with_occurrences: Retrieve a number of occurrences of this incident., defaults to None
        :type with_occurrences: int, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Secret Incident Details
        :rtype: Incident
        """

        Validator(int).validate(incident_id)
        Validator(int).is_optional().min(0).max(100).validate(with_occurrences)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/incidents/secrets/{{incident_id}}",
                self.get_default_headers(),
            )
            .add_path("incident_id", incident_id)
            .add_query("with_occurrences", with_occurrences)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return Incident._unmap(response)

    @cast_models
    def update_secret_incident(
        self, incident_id: int, request_body: IncidentWithoutOccurrences = None
    ) -> IncidentWithoutOccurrences:
        """Update a secret incident

        :param request_body: The request body., defaults to None
        :type request_body: IncidentWithoutOccurrences, optional
        :param incident_id: The id of the incident to retrieve
        :type incident_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Secret Incident Details without occurrences.
        :rtype: IncidentWithoutOccurrences
        """

        Validator(IncidentWithoutOccurrences).is_optional().validate(request_body)
        Validator(int).validate(incident_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/incidents/secrets/{{incident_id}}",
                self.get_default_headers(),
            )
            .add_path("incident_id", incident_id)
            .serialize()
            .set_method("PATCH")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return IncidentWithoutOccurrences._unmap(response)

    @cast_models
    def retrieve_incidents_leaks(
        self, incident_id: int
    ) -> List[RetrieveIncidentsLeaksOkResponse]:
        """Retrieve where a secret has been publicly leaked.

        :param incident_id: The id of the incident to retrieve
        :type incident_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: List of the leaks of the incident
        :rtype: List[RetrieveIncidentsLeaksOkResponse]
        """

        Validator(int).validate(incident_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/incidents/secrets/{{incident_id}}/leaks",
                self.get_default_headers(),
            )
            .add_path("incident_id", incident_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return [RetrieveIncidentsLeaksOkResponse._unmap(item) for item in response]

    @cast_models
    def assign_incident(
        self, incident_id: int, request_body: AssignIncidentRequest = None
    ) -> IncidentWithoutOccurrences:
        """Assign secret incident detected by the GitGuardian dashboard to a workspace member
        by email.

        :param request_body: The request body., defaults to None
        :type request_body: AssignIncidentRequest, optional
        :param incident_id: The id of the incident to retrieve
        :type incident_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Secret Incident Details without occurrences.
        :rtype: IncidentWithoutOccurrences
        """

        Validator(AssignIncidentRequest).is_optional().validate(request_body)
        Validator(int).validate(incident_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/incidents/secrets/{{incident_id}}/assign",
                self.get_default_headers(),
            )
            .add_path("incident_id", incident_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return IncidentWithoutOccurrences._unmap(response)

    @cast_models
    def unassign_incident(self, incident_id: int) -> IncidentWithoutOccurrences:
        """Unassign secret incident from a workspace member by email.

        :param incident_id: The id of the incident to retrieve
        :type incident_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Secret Incident Details without occurrences.
        :rtype: IncidentWithoutOccurrences
        """

        Validator(int).validate(incident_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/incidents/secrets/{{incident_id}}/unassign",
                self.get_default_headers(),
            )
            .add_path("incident_id", incident_id)
            .serialize()
            .set_method("POST")
        )

        response = self.send_request(serialized_request)

        return IncidentWithoutOccurrences._unmap(response)

    @cast_models
    def resolve_incident(
        self, incident_id: int, request_body: ResolveIncidentRequest = None
    ) -> IncidentWithoutOccurrences:
        """Resolve a secret incident detected by the GitGuardian dashboard.

        :param request_body: The request body., defaults to None
        :type request_body: ResolveIncidentRequest, optional
        :param incident_id: The id of the incident to retrieve
        :type incident_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Secret Incident Details without occurrences.
        :rtype: IncidentWithoutOccurrences
        """

        Validator(ResolveIncidentRequest).is_optional().validate(request_body)
        Validator(int).validate(incident_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/incidents/secrets/{{incident_id}}/resolve",
                self.get_default_headers(),
            )
            .add_path("incident_id", incident_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return IncidentWithoutOccurrences._unmap(response)

    @cast_models
    def ignore_incident(
        self, incident_id: int, request_body: IgnoreIncidentRequest = None
    ) -> IncidentWithoutOccurrences:
        """Ignore a secret incident detected by the GitGuardian dashboard.

        :param request_body: The request body., defaults to None
        :type request_body: IgnoreIncidentRequest, optional
        :param incident_id: The id of the incident to retrieve
        :type incident_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Secret Incident Details without occurrences.
        :rtype: IncidentWithoutOccurrences
        """

        Validator(IgnoreIncidentRequest).is_optional().validate(request_body)
        Validator(int).validate(incident_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/incidents/secrets/{{incident_id}}/ignore",
                self.get_default_headers(),
            )
            .add_path("incident_id", incident_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return IncidentWithoutOccurrences._unmap(response)

    @cast_models
    def reopen_incident(self, incident_id: int) -> IncidentWithoutOccurrences:
        """Unresolve or unignore a secret incident detected by the GitGuardian dashboard.

        :param incident_id: The id of the incident to retrieve
        :type incident_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Secret Incident Details without occurrences.
        :rtype: IncidentWithoutOccurrences
        """

        Validator(int).validate(incident_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/incidents/secrets/{{incident_id}}/reopen",
                self.get_default_headers(),
            )
            .add_path("incident_id", incident_id)
            .serialize()
            .set_method("POST")
        )

        response = self.send_request(serialized_request)

        return IncidentWithoutOccurrences._unmap(response)

    @cast_models
    def share_incident(
        self, incident_id: int, request_body: ShareIncidentRequest = None
    ) -> IncidentToken:
        """Share a secret incident by creating a public link.

        :param request_body: The request body., defaults to None
        :type request_body: ShareIncidentRequest, optional
        :param incident_id: The id of the incident to retrieve
        :type incident_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Incident Sharing Details
        :rtype: IncidentToken
        """

        Validator(ShareIncidentRequest).is_optional().validate(request_body)
        Validator(int).validate(incident_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/incidents/secrets/{{incident_id}}/share",
                self.get_default_headers(),
            )
            .add_path("incident_id", incident_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return IncidentToken._unmap(response)

    @cast_models
    def unshare_incident(self, incident_id: int):
        """Unshare a secret incident by revoking its public link.

        :param incident_id: The id of the incident to retrieve
        :type incident_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(int).validate(incident_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/incidents/secrets/{{incident_id}}/unshare",
                self.get_default_headers(),
            )
            .add_path("incident_id", incident_id)
            .serialize()
            .set_method("POST")
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def grant_access_incident(
        self, incident_id: int, request_body: GrantAccessIncidentRequest = None
    ):
        """Grant a user, an existing invitee or a team access to a secret incident.

        DEPRECATED: This endpoint has been replaced by [this one](#tag/Members/operation/set-member-resource-access) for members, [this one](#tag/Teams/operation/set-team-resource-access) for teams, and [this one](#tag/Invitations/operation/set-invitation-resource-access) for invitations.

        :param request_body: The request body., defaults to None
        :type request_body: GrantAccessIncidentRequest, optional
        :param incident_id: The id of the incident to retrieve
        :type incident_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(GrantAccessIncidentRequest).is_optional().validate(request_body)
        Validator(int).validate(incident_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/incidents/secrets/{{incident_id}}/grant_access",
                self.get_default_headers(),
            )
            .add_path("incident_id", incident_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def revoke_access_incident(
        self, incident_id: int, request_body: RevokeAccessIncidentRequest = None
    ):
        """Revoke access of a user, an existing invitee or a team to a secret incident.

        DEPRECATED: This endpoint has been replaced by [this one](#tag/Members/operation/revoke-member-resource-access) for members, [this one](#tag/Teams/operation/revoke-team-resource-access) for teams, and [this one](#tag/Invitations/operation/revoke-invitation-resource-access) for invitations.

        :param request_body: The request body., defaults to None
        :type request_body: RevokeAccessIncidentRequest, optional
        :param incident_id: The id of the incident to retrieve
        :type incident_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(RevokeAccessIncidentRequest).is_optional().validate(request_body)
        Validator(int).validate(incident_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/incidents/secrets/{{incident_id}}/revoke_access",
                self.get_default_headers(),
            )
            .add_path("incident_id", incident_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def list_incident_members(
        self,
        incident_id: int,
        cursor: str = None,
        page: int = None,
        per_page: int = None,
        member_id: float = None,
        incident_permission: IncidentPermissionEnum = None,
        role: MemberAccessLevelEnum = None,
        search: str = None,
    ) -> List[IncidentMember]:
        """List all the members having access to a secret incident.

        DEPRECATED: This endpoint has been replaced by [/v1/secret-incidents/{incident_id}/members](#tag/Secret-Incidents/operation/list-secret-incident-member-access)

        :param incident_id: The id of the incident to retrieve
        :type incident_id: int
        :param cursor: Pagination cursor., defaults to None
        :type cursor: str, optional
        :param page: Page number., defaults to None
        :type page: int, optional
        :param per_page: Number of items to list per page., defaults to None
        :type per_page: int, optional
        :param member_id: member_id, defaults to None
        :type member_id: float, optional
        :param incident_permission: incident_permission, defaults to None
        :type incident_permission: IncidentPermissionEnum, optional
        :param role: role, defaults to None
        :type role: MemberAccessLevelEnum, optional
        :param search: search, defaults to None
        :type search: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: List of members
        :rtype: List[IncidentMember]
        """

        Validator(int).validate(incident_id)
        Validator(str).is_optional().validate(cursor)
        Validator(int).is_optional().min(0).validate(page)
        Validator(int).is_optional().min(1).max(100).validate(per_page)
        Validator(float).is_optional().validate(member_id)
        Validator(IncidentPermissionEnum).is_optional().validate(incident_permission)
        Validator(MemberAccessLevelEnum).is_optional().validate(role)
        Validator(str).is_optional().validate(search)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/incidents/secrets/{{incident_id}}/members",
                self.get_default_headers(),
            )
            .add_path("incident_id", incident_id)
            .add_query("cursor", cursor)
            .add_query("page", page)
            .add_query("per_page", per_page)
            .add_query("member_id", member_id)
            .add_query("incident_permission", incident_permission)
            .add_query("role", role)
            .add_query("search", search)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return [IncidentMember._unmap(item) for item in response]

    @cast_models
    def list_incident_teams(
        self,
        incident_id: int,
        cursor: str = None,
        team_id: float = None,
        incident_permission: IncidentPermissionEnum = None,
    ) -> List[IncidentTeam]:
        """List all the teams having access to a secret incident.

        DEPRECATED: This endpoint has been replaced by [/v1/secret-incidents/{incident_id}/teams](#tag/Secret-Incidents/operation/list-secret-incident-team-access)

        :param incident_id: The id of the incident to retrieve
        :type incident_id: int
        :param cursor: Pagination cursor., defaults to None
        :type cursor: str, optional
        :param team_id: team_id, defaults to None
        :type team_id: float, optional
        :param incident_permission: incident_permission, defaults to None
        :type incident_permission: IncidentPermissionEnum, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: List of team accesses
        :rtype: List[IncidentTeam]
        """

        Validator(int).validate(incident_id)
        Validator(str).is_optional().validate(cursor)
        Validator(float).is_optional().validate(team_id)
        Validator(IncidentPermissionEnum).is_optional().validate(incident_permission)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/incidents/secrets/{{incident_id}}/teams",
                self.get_default_headers(),
            )
            .add_path("incident_id", incident_id)
            .add_query("cursor", cursor)
            .add_query("team_id", team_id)
            .add_query("incident_permission", incident_permission)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return [IncidentTeam._unmap(item) for item in response]

    @cast_models
    def list_incident_invitations(
        self,
        incident_id: int,
        cursor: str = None,
        invitation_id: float = None,
        incident_permission: IncidentPermissionEnum = None,
    ) -> List[IncidentInvitation]:
        """List all the invitations having access to a Secret Incident.

        DEPRECATED: This endpoint has been replaced by [/v1/secret-incidents/{incident_id}/invitations](#tag/Secret-Incidents/operation/list-secret-incident-invitation-access)

        :param incident_id: The id of the incident to retrieve
        :type incident_id: int
        :param cursor: Pagination cursor., defaults to None
        :type cursor: str, optional
        :param invitation_id: invitation_id, defaults to None
        :type invitation_id: float, optional
        :param incident_permission: filter accesses with a specific permission., defaults to None
        :type incident_permission: IncidentPermissionEnum, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: List of invitation accesses
        :rtype: List[IncidentInvitation]
        """

        Validator(int).validate(incident_id)
        Validator(str).is_optional().validate(cursor)
        Validator(float).is_optional().validate(invitation_id)
        Validator(IncidentPermissionEnum).is_optional().validate(incident_permission)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/incidents/secrets/{{incident_id}}/invitations",
                self.get_default_headers(),
            )
            .add_path("incident_id", incident_id)
            .add_query("cursor", cursor)
            .add_query("invitation_id", invitation_id)
            .add_query("incident_permission", incident_permission)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return [IncidentInvitation._unmap(item) for item in response]

    @cast_models
    def list_secret_incident_member_access(
        self,
        incident_id: int,
        cursor: str = None,
        per_page: int = None,
        role: MemberAccessLevelEnum = None,
        access_level: MemberAccessLevelEnum = None,
        search: str = None,
        ordering: ListSecretIncidentMemberAccessOrdering = None,
        direct_access: bool = None,
    ) -> List[Member]:
        """List members that have access to a secret incident.

        :param incident_id: The id of the incident to retrieve
        :type incident_id: int
        :param cursor: Pagination cursor., defaults to None
        :type cursor: str, optional
        :param per_page: Number of items to list per page., defaults to None
        :type per_page: int, optional
        :param role: role, defaults to None
        :type role: MemberAccessLevelEnum, optional
        :param access_level: access_level, defaults to None
        :type access_level: MemberAccessLevelEnum, optional
        :param search: search, defaults to None
        :type search: str, optional
        :param ordering: Sort the results by their field value. The default sort is ASC, DESC if the
        field is preceded by a '-'., defaults to None
        :type ordering: ListSecretIncidentMemberAccessOrdering, optional
        :param direct_access: Filter on direct or indirect accesses., defaults to None
        :type direct_access: bool, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: List members
        :rtype: List[Member]
        """

        Validator(int).validate(incident_id)
        Validator(str).is_optional().validate(cursor)
        Validator(int).is_optional().min(1).max(100).validate(per_page)
        Validator(MemberAccessLevelEnum).is_optional().validate(role)
        Validator(MemberAccessLevelEnum).is_optional().validate(access_level)
        Validator(str).is_optional().validate(search)
        Validator(ListSecretIncidentMemberAccessOrdering).is_optional().validate(
            ordering
        )
        Validator(bool).is_optional().validate(direct_access)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/secret-incidents/{{incident_id}}/members",
                self.get_default_headers(),
            )
            .add_path("incident_id", incident_id)
            .add_query("cursor", cursor)
            .add_query("per_page", per_page)
            .add_query("role", role)
            .add_query("access_level", access_level)
            .add_query("search", search)
            .add_query("ordering", ordering)
            .add_query("direct_access", direct_access)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return [Member._unmap(item) for item in response]

    @cast_models
    def list_secret_incident_team_access(
        self,
        incident_id: int,
        cursor: str = None,
        per_page: int = None,
        search: str = None,
        direct_access: bool = None,
    ) -> List[Team]:
        """List teams that have access to a secret incident.

        :param incident_id: The id of the incident to retrieve
        :type incident_id: int
        :param cursor: Pagination cursor., defaults to None
        :type cursor: str, optional
        :param per_page: Number of items to list per page., defaults to None
        :type per_page: int, optional
        :param search: search, defaults to None
        :type search: str, optional
        :param direct_access: Filter on direct or indirect accesses., defaults to None
        :type direct_access: bool, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: List teams
        :rtype: List[Team]
        """

        Validator(int).validate(incident_id)
        Validator(str).is_optional().validate(cursor)
        Validator(int).is_optional().min(1).max(100).validate(per_page)
        Validator(str).is_optional().validate(search)
        Validator(bool).is_optional().validate(direct_access)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/secret-incidents/{{incident_id}}/teams",
                self.get_default_headers(),
            )
            .add_path("incident_id", incident_id)
            .add_query("cursor", cursor)
            .add_query("per_page", per_page)
            .add_query("search", search)
            .add_query("direct_access", direct_access)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return [Team._unmap(item) for item in response]

    @cast_models
    def list_secret_incident_invitation_access(
        self,
        incident_id: int,
        cursor: str = None,
        per_page: int = None,
        search: str = None,
        ordering: ListSecretIncidentInvitationAccessOrdering = None,
        direct_access: bool = None,
    ) -> List[Invitation]:
        """List invitations that have access to a secret incident.

        :param incident_id: The id of the incident to retrieve
        :type incident_id: int
        :param cursor: Pagination cursor., defaults to None
        :type cursor: str, optional
        :param per_page: Number of items to list per page., defaults to None
        :type per_page: int, optional
        :param search: search, defaults to None
        :type search: str, optional
        :param ordering: Sort the results by their field value. The default sort is ASC, DESC if the
        field is preceded by a '-'., defaults to None
        :type ordering: ListSecretIncidentInvitationAccessOrdering, optional
        :param direct_access: Filter on direct or indirect accesses., defaults to None
        :type direct_access: bool, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: List invitations
        :rtype: List[Invitation]
        """

        Validator(int).validate(incident_id)
        Validator(str).is_optional().validate(cursor)
        Validator(int).is_optional().min(1).max(100).validate(per_page)
        Validator(str).is_optional().validate(search)
        Validator(ListSecretIncidentInvitationAccessOrdering).is_optional().validate(
            ordering
        )
        Validator(bool).is_optional().validate(direct_access)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/secret-incidents/{{incident_id}}/invitations",
                self.get_default_headers(),
            )
            .add_path("incident_id", incident_id)
            .add_query("cursor", cursor)
            .add_query("per_page", per_page)
            .add_query("search", search)
            .add_query("ordering", ordering)
            .add_query("direct_access", direct_access)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return [Invitation._unmap(item) for item in response]

    @cast_models
    def list_sources_incidents(
        self,
        source_id: int,
        cursor: str = None,
        per_page: int = None,
        date_before: str = None,
        date_after: str = None,
        assignee_email: str = None,
        assignee_id: int = None,
        status: StatusEnum = None,
        severity: SeverityEnum = None,
        validity: ValidityEnum = None,
        tags: any = None,
        ordering: ListSourcesIncidentsOrdering = None,
        detector_group_name: str = None,
        ignorer_id: int = None,
        ignorer_api_token_id: str = None,
        resolver_id: int = None,
        resolver_api_token_id: str = None,
    ) -> List[IncidentWithoutOccurrences]:
        """List secret incidents linked to a source.
        Occurrences are not returned in this route.

        :param source_id: The id of the source to filter on.
        :type source_id: int
        :param cursor: Pagination cursor., defaults to None
        :type cursor: str, optional
        :param per_page: Number of items to list per page., defaults to None
        :type per_page: int, optional
        :param date_before: date_before, defaults to None
        :type date_before: str, optional
        :param date_after: date_after, defaults to None
        :type date_after: str, optional
        :param assignee_email: assignee_email, defaults to None
        :type assignee_email: str, optional
        :param assignee_id: assignee_id, defaults to None
        :type assignee_id: int, optional
        :param status: status, defaults to None
        :type status: StatusEnum, optional
        :param severity: severity, defaults to None
        :type severity: SeverityEnum, optional
        :param validity: validity, defaults to None
        :type validity: ValidityEnum, optional
        :param tags: tags, defaults to None
        :type tags: any, optional
        :param ordering: Sort the results by their field value. The default sort is ASC, DESC if the
        field is preceded by a '-'., defaults to None
        :type ordering: ListSourcesIncidentsOrdering, optional
        :param detector_group_name: detector_group_name, defaults to None
        :type detector_group_name: str, optional
        :param ignorer_id: ignorer_id, defaults to None
        :type ignorer_id: int, optional
        :param ignorer_api_token_id: ignorer_api_token_id, defaults to None
        :type ignorer_api_token_id: str, optional
        :param resolver_id: resolver_id, defaults to None
        :type resolver_id: int, optional
        :param resolver_api_token_id: resolver_api_token_id, defaults to None
        :type resolver_api_token_id: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Secret Incident List
        :rtype: List[IncidentWithoutOccurrences]
        """

        Validator(int).validate(source_id)
        Validator(str).is_optional().validate(cursor)
        Validator(int).is_optional().min(1).max(100).validate(per_page)
        Validator(str).is_optional().validate(date_before)
        Validator(str).is_optional().validate(date_after)
        Validator(str).is_optional().validate(assignee_email)
        Validator(int).is_optional().validate(assignee_id)
        Validator(StatusEnum).is_optional().validate(status)
        Validator(SeverityEnum).is_optional().validate(severity)
        Validator(ValidityEnum).is_optional().validate(validity)
        Validator(any).is_optional().validate(tags)
        Validator(ListSourcesIncidentsOrdering).is_optional().validate(ordering)
        Validator(str).is_optional().validate(detector_group_name)
        Validator(int).is_optional().validate(ignorer_id)
        Validator(str).is_optional().validate(ignorer_api_token_id)
        Validator(int).is_optional().validate(resolver_id)
        Validator(str).is_optional().validate(resolver_api_token_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/sources/{{source_id}}/incidents/secrets",
                self.get_default_headers(),
            )
            .add_path("source_id", source_id)
            .add_query("cursor", cursor)
            .add_query("per_page", per_page)
            .add_query("date_before", date_before)
            .add_query("date_after", date_after)
            .add_query("assignee_email", assignee_email)
            .add_query("assignee_id", assignee_id)
            .add_query("status", status)
            .add_query("severity", severity)
            .add_query("validity", validity)
            .add_query("tags", tags)
            .add_query("ordering", ordering)
            .add_query("detector_group_name", detector_group_name)
            .add_query("ignorer_id", ignorer_id)
            .add_query("ignorer_api_token_id", ignorer_api_token_id)
            .add_query("resolver_id", resolver_id)
            .add_query("resolver_api_token_id", resolver_api_token_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return [IncidentWithoutOccurrences._unmap(item) for item in response]

    @cast_models
    def list_team_incidents(
        self,
        team_id: int,
        cursor: str = None,
        per_page: int = None,
        date_before: str = None,
        date_after: str = None,
        assignee_email: str = None,
        assignee_id: int = None,
        status: StatusEnum = None,
        severity: SeverityEnum = None,
        validity: ValidityEnum = None,
        tags: any = None,
        ordering: ListTeamIncidentsOrdering = None,
        detector_group_name: str = None,
        ignorer_id: int = None,
        ignorer_api_token_id: str = None,
        resolver_id: int = None,
        resolver_api_token_id: str = None,
    ) -> List[IncidentWithoutOccurrences]:
        """List secret incidents of a particular team.
        Occurrences are not returned in this route.

        DEPRECATED: THis endpoint has been replaced by [/v1/teams/{team_id}/secret-incidents](#tag/Teams/operation/list-team-secret-incident-access)

        :param team_id: The id of the team
        :type team_id: int
        :param cursor: Pagination cursor., defaults to None
        :type cursor: str, optional
        :param per_page: Number of items to list per page., defaults to None
        :type per_page: int, optional
        :param date_before: date_before, defaults to None
        :type date_before: str, optional
        :param date_after: date_after, defaults to None
        :type date_after: str, optional
        :param assignee_email: assignee_email, defaults to None
        :type assignee_email: str, optional
        :param assignee_id: assignee_id, defaults to None
        :type assignee_id: int, optional
        :param status: status, defaults to None
        :type status: StatusEnum, optional
        :param severity: severity, defaults to None
        :type severity: SeverityEnum, optional
        :param validity: validity, defaults to None
        :type validity: ValidityEnum, optional
        :param tags: tags, defaults to None
        :type tags: any, optional
        :param ordering: Sort the results by their field value. The default sort is ASC, DESC if the
        field is preceded by a '-'., defaults to None
        :type ordering: ListTeamIncidentsOrdering, optional
        :param detector_group_name: detector_group_name, defaults to None
        :type detector_group_name: str, optional
        :param ignorer_id: ignorer_id, defaults to None
        :type ignorer_id: int, optional
        :param ignorer_api_token_id: ignorer_api_token_id, defaults to None
        :type ignorer_api_token_id: str, optional
        :param resolver_id: resolver_id, defaults to None
        :type resolver_id: int, optional
        :param resolver_api_token_id: resolver_api_token_id, defaults to None
        :type resolver_api_token_id: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Secret Incident List
        :rtype: List[IncidentWithoutOccurrences]
        """

        Validator(int).validate(team_id)
        Validator(str).is_optional().validate(cursor)
        Validator(int).is_optional().min(1).max(100).validate(per_page)
        Validator(str).is_optional().validate(date_before)
        Validator(str).is_optional().validate(date_after)
        Validator(str).is_optional().validate(assignee_email)
        Validator(int).is_optional().validate(assignee_id)
        Validator(StatusEnum).is_optional().validate(status)
        Validator(SeverityEnum).is_optional().validate(severity)
        Validator(ValidityEnum).is_optional().validate(validity)
        Validator(any).is_optional().validate(tags)
        Validator(ListTeamIncidentsOrdering).is_optional().validate(ordering)
        Validator(str).is_optional().validate(detector_group_name)
        Validator(int).is_optional().validate(ignorer_id)
        Validator(str).is_optional().validate(ignorer_api_token_id)
        Validator(int).is_optional().validate(resolver_id)
        Validator(str).is_optional().validate(resolver_api_token_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/teams/{{team_id}}/incidents/secrets",
                self.get_default_headers(),
            )
            .add_path("team_id", team_id)
            .add_query("cursor", cursor)
            .add_query("per_page", per_page)
            .add_query("date_before", date_before)
            .add_query("date_after", date_after)
            .add_query("assignee_email", assignee_email)
            .add_query("assignee_id", assignee_id)
            .add_query("status", status)
            .add_query("severity", severity)
            .add_query("validity", validity)
            .add_query("tags", tags)
            .add_query("ordering", ordering)
            .add_query("detector_group_name", detector_group_name)
            .add_query("ignorer_id", ignorer_id)
            .add_query("ignorer_api_token_id", ignorer_api_token_id)
            .add_query("resolver_id", resolver_id)
            .add_query("resolver_api_token_id", resolver_api_token_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return [IncidentWithoutOccurrences._unmap(item) for item in response]
