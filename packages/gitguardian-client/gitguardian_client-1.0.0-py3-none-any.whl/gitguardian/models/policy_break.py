# This file was generated by liblab | https://liblab.com/

from enum import Enum
from typing import List
from .utils.json_map import JsonMap
from .base import BaseModel


class Validity(Enum):
    """An enumeration representing different categories.

    :cvar NO_CHECKER: "no_checker"
    :vartype NO_CHECKER: str
    :cvar VALID: "valid"
    :vartype VALID: str
    :cvar INVALID: "invalid"
    :vartype INVALID: str
    :cvar FAILED_TO_CHECK: "failed_to_check"
    :vartype FAILED_TO_CHECK: str
    :cvar UNKNOWN: "unknown"
    :vartype UNKNOWN: str
    """

    NO_CHECKER = "no_checker"
    VALID = "valid"
    INVALID = "invalid"
    FAILED_TO_CHECK = "failed_to_check"
    UNKNOWN = "unknown"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, Validity._member_map_.values()))


@JsonMap({"type_": "type"})
class Matches(BaseModel):
    """Matches

    :param type_: Type of match
    :type type_: str
    :param match: Matched string of failure
    :type match: str
    :param line_start: start line number of match (index origin = 1), defaults to None
    :type line_start: int, optional
    :param line_end: end line number of match (index origin = 1), defaults to None
    :type line_end: int, optional
    :param index_start: start index of match in file as an array (index origin = 0), defaults to None
    :type index_start: int, optional
    :param index_end: end index of match in file as an array (index origin = 0), defaults to None
    :type index_end: int, optional
    """

    def __init__(
        self,
        type_: str,
        match: str,
        line_start: int = None,
        line_end: int = None,
        index_start: int = None,
        index_end: int = None,
    ):
        self.type_ = type_
        self.match = match
        if line_start is not None:
            self.line_start = line_start
        if line_end is not None:
            self.line_end = line_end
        if index_start is not None:
            self.index_start = index_start
        if index_end is not None:
            self.index_end = index_end


@JsonMap({"type_": "type"})
class PolicyBreak(BaseModel):
    """Issue found in your Document

    :param type_: Type of detected policy.
    :type type_: str
    :param policy: Name of failing policy.
    :type policy: str
    :param validity: Validity of the found secret., defaults to None
    :type validity: Validity, optional
    :param matches: List of secret matches.
    :type matches: List[Matches]
    :param known_secret: Indicates whether the secret is known by your GitGuardian dashboard.<br>, defaults to None
    :type known_secret: bool, optional
    :param incident_url: The incident's URL on your GitGuardian dashboard, if it is a known secret, or<br>an empty string otherwise.<br>, defaults to None
    :type incident_url: str, optional
    """

    def __init__(
        self,
        type_: str,
        policy: str,
        matches: List[Matches],
        validity: Validity = None,
        known_secret: bool = None,
        incident_url: str = None,
    ):
        self.type_ = type_
        self.policy = policy
        if validity is not None:
            self.validity = self._enum_matching(validity, Validity.list(), "validity")
        self.matches = self._define_list(matches, Matches)
        if known_secret is not None:
            self.known_secret = known_secret
        if incident_url is not None:
            self.incident_url = incident_url
