# This file was generated by liblab | https://liblab.com/

from typing import List
from .utils.validator import Validator
from .utils.base_service import BaseService
from ..net.transport.serializer import Serializer
from ..models.validity_enum import ValidityEnum
from ..models.utils.cast_models import cast_models
from ..models.status_enum import StatusEnum
from ..models.severity_enum import SeverityEnum
from ..models.resource_type import ResourceType
from ..models.resource_invitation_access import ResourceInvitationAccess
from ..models.resend_invitation_ok_response import ResendInvitationOkResponse
from ..models.list_invitations_ordering import ListInvitationsOrdering
from ..models.list_invitation_secret_incident_access_ordering import (
    ListInvitationSecretIncidentAccessOrdering,
)
from ..models.invitation import Invitation
from ..models.incident_without_occurrences import IncidentWithoutOccurrences
from ..models.create_invitations_request import CreateInvitationsRequest


class InvitationsService(BaseService):

    @cast_models
    def list_invitations(
        self,
        cursor: str = None,
        per_page: int = None,
        search: str = None,
        ordering: ListInvitationsOrdering = None,
    ) -> List[Invitation]:
        """This endpoint allows you to list all pending invitations.

        The response contains the list of invitations and a pagination cursor to retrieve the next page.

        The invitations are sorted by id.

        If you are using a personal access token, you need to have an access level superior or equal to `member`.

        :param cursor: Pagination cursor., defaults to None
        :type cursor: str, optional
        :param per_page: Number of items to list per page., defaults to None
        :type per_page: int, optional
        :param search: search, defaults to None
        :type search: str, optional
        :param ordering: Sort the results by their field value. The default sort is ASC, DESC if the
        field is preceded by a '-'., defaults to None
        :type ordering: ListInvitationsOrdering, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: List invitations
        :rtype: List[Invitation]
        """

        Validator(str).is_optional().validate(cursor)
        Validator(int).is_optional().min(1).max(100).validate(per_page)
        Validator(str).is_optional().validate(search)
        Validator(ListInvitationsOrdering).is_optional().validate(ordering)

        serialized_request = (
            Serializer(f"{self.base_url}/v1/invitations", self.get_default_headers())
            .add_query("cursor", cursor)
            .add_query("per_page", per_page)
            .add_query("search", search)
            .add_query("ordering", ordering)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return [Invitation._unmap(item) for item in response]

    @cast_models
    def create_invitations(
        self, request_body: CreateInvitationsRequest = None
    ) -> Invitation:
        """This endpoint allows you to send an invitation to a user.

        If you are using a personal access token, you need to have an access level superior or equal to `member`.

        :param request_body: The request body., defaults to None
        :type request_body: CreateInvitationsRequest, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Invitation sent
        :rtype: Invitation
        """

        Validator(CreateInvitationsRequest).is_optional().validate(request_body)

        serialized_request = (
            Serializer(f"{self.base_url}/v1/invitations", self.get_default_headers())
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return Invitation._unmap(response)

    @cast_models
    def delete_invitation(self, invitation_id: int):
        """Delete an existing invitation.

        If you are using a personal access token, you need to have an access level superior or equal to `manager`.

        :param invitation_id: The id of the invitation to retrieve
        :type invitation_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(int).validate(invitation_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/invitations/{{invitation_id}}",
                self.get_default_headers(),
            )
            .add_path("invitation_id", invitation_id)
            .serialize()
            .set_method("DELETE")
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def resend_invitation(
        self, invitation_id: int, request_body: dict = None
    ) -> ResendInvitationOkResponse:
        """Resend an existing invitation.

        If you are using a personal access token, you need to have an access level superior or equal to `manager`.

        :param request_body: The request body., defaults to None
        :type request_body: dict, optional
        :param invitation_id: The id of the invitation to retrieve
        :type invitation_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Invitation sent
        :rtype: ResendInvitationOkResponse
        """

        Validator(dict).is_optional().validate(request_body)
        Validator(int).validate(invitation_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/invitations/{{invitation_id}}/resend",
                self.get_default_headers(),
            )
            .add_path("invitation_id", invitation_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return ResendInvitationOkResponse._unmap(response)

    @cast_models
    def get_invitation_resource_access(
        self, invitation_id: int, resource_type: ResourceType, resource_id: int
    ) -> ResourceInvitationAccess:
        """Return the permission an invitation has on a resource.

        If the invitation has an admin access level, it will be the highest possible value.

        :param invitation_id: The id of the invitation to retrieve
        :type invitation_id: int
        :param resource_type: The kind of resource of the access
        :type resource_type: ResourceType
        :param resource_id: The id of the resource of the access
        :type resource_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Invitation Resource access details
        :rtype: ResourceInvitationAccess
        """

        Validator(int).validate(invitation_id)
        Validator(ResourceType).validate(resource_type)
        Validator(int).validate(resource_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/invitations/{{invitation_id}}/{{resource_type}}/{{resource_id}}",
                self.get_default_headers(),
            )
            .add_path("invitation_id", invitation_id)
            .add_path("resource_type", resource_type)
            .add_path("resource_id", resource_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return ResourceInvitationAccess._unmap(response)

    @cast_models
    def set_invitation_resource_access(
        self,
        request_body: ResourceInvitationAccess,
        invitation_id: int,
        resource_type: ResourceType,
        resource_id: int,
    ) -> ResourceInvitationAccess:
        """This will create or update a direct access for the invitation on the resource.

        If the invitation has an administrator access level, it will take precedence over the
        permission you have given.

        :param request_body: The request body.
        :type request_body: ResourceInvitationAccess
        :param invitation_id: The id of the invitation to retrieve
        :type invitation_id: int
        :param resource_type: The kind of resource of the access
        :type resource_type: ResourceType
        :param resource_id: The id of the resource of the access
        :type resource_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The access was updated successfully.
        :rtype: ResourceInvitationAccess
        """

        Validator(ResourceInvitationAccess).validate(request_body)
        Validator(int).validate(invitation_id)
        Validator(ResourceType).validate(resource_type)
        Validator(int).validate(resource_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/invitations/{{invitation_id}}/{{resource_type}}/{{resource_id}}",
                self.get_default_headers(),
            )
            .add_path("invitation_id", invitation_id)
            .add_path("resource_type", resource_type)
            .add_path("resource_id", resource_id)
            .serialize()
            .set_method("PUT")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return ResourceInvitationAccess._unmap(response)

    @cast_models
    def revoke_invitation_resource_access(
        self,
        request_body: ResourceInvitationAccess,
        invitation_id: int,
        resource_type: ResourceType,
        resource_id: int,
    ):
        """Revoke an invitation access to a resource.

        This only works for direct accesses. If the access is from the administrator access level of
        the invitation, a 404 is returned.

        :param request_body: The request body.
        :type request_body: ResourceInvitationAccess
        :param invitation_id: The id of the invitation to retrieve
        :type invitation_id: int
        :param resource_type: The kind of resource of the access
        :type resource_type: ResourceType
        :param resource_id: The id of the resource of the access
        :type resource_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(ResourceInvitationAccess).validate(request_body)
        Validator(int).validate(invitation_id)
        Validator(ResourceType).validate(resource_type)
        Validator(int).validate(resource_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/invitations/{{invitation_id}}/{{resource_type}}/{{resource_id}}",
                self.get_default_headers(),
            )
            .add_path("invitation_id", invitation_id)
            .add_path("resource_type", resource_type)
            .add_path("resource_id", resource_id)
            .serialize()
            .set_method("DELETE")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def list_invitation_secret_incident_access(
        self,
        invitation_id: int,
        cursor: str = None,
        page: int = None,
        per_page: int = None,
        date_before: str = None,
        date_after: str = None,
        assignee_email: str = None,
        assignee_id: int = None,
        status: StatusEnum = None,
        severity: SeverityEnum = None,
        validity: ValidityEnum = None,
        tags: any = None,
        ordering: ListInvitationSecretIncidentAccessOrdering = None,
        detector_group_name: str = None,
        ignorer_id: int = None,
        ignorer_api_token_id: str = None,
        resolver_id: int = None,
        resolver_api_token_id: str = None,
    ) -> List[IncidentWithoutOccurrences]:
        """List secret incidents that an invitation has access to.

        :param invitation_id: The id of the invitation to retrieve
        :type invitation_id: int
        :param cursor: Pagination cursor., defaults to None
        :type cursor: str, optional
        :param page: Page number., defaults to None
        :type page: int, optional
        :param per_page: Number of items to list per page., defaults to None
        :type per_page: int, optional
        :param date_before: date_before, defaults to None
        :type date_before: str, optional
        :param date_after: date_after, defaults to None
        :type date_after: str, optional
        :param assignee_email: assignee_email, defaults to None
        :type assignee_email: str, optional
        :param assignee_id: assignee_id, defaults to None
        :type assignee_id: int, optional
        :param status: status, defaults to None
        :type status: StatusEnum, optional
        :param severity: severity, defaults to None
        :type severity: SeverityEnum, optional
        :param validity: validity, defaults to None
        :type validity: ValidityEnum, optional
        :param tags: tags, defaults to None
        :type tags: any, optional
        :param ordering: Sort the results by their field value. The default sort is ASC, DESC if the
        field is preceded by a '-'., defaults to None
        :type ordering: ListInvitationSecretIncidentAccessOrdering, optional
        :param detector_group_name: detector_group_name, defaults to None
        :type detector_group_name: str, optional
        :param ignorer_id: ignorer_id, defaults to None
        :type ignorer_id: int, optional
        :param ignorer_api_token_id: ignorer_api_token_id, defaults to None
        :type ignorer_api_token_id: str, optional
        :param resolver_id: resolver_id, defaults to None
        :type resolver_id: int, optional
        :param resolver_api_token_id: resolver_api_token_id, defaults to None
        :type resolver_api_token_id: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Secret Incident List
        :rtype: List[IncidentWithoutOccurrences]
        """

        Validator(int).validate(invitation_id)
        Validator(str).is_optional().validate(cursor)
        Validator(int).is_optional().min(0).validate(page)
        Validator(int).is_optional().min(1).max(100).validate(per_page)
        Validator(str).is_optional().validate(date_before)
        Validator(str).is_optional().validate(date_after)
        Validator(str).is_optional().validate(assignee_email)
        Validator(int).is_optional().validate(assignee_id)
        Validator(StatusEnum).is_optional().validate(status)
        Validator(SeverityEnum).is_optional().validate(severity)
        Validator(ValidityEnum).is_optional().validate(validity)
        Validator(any).is_optional().validate(tags)
        Validator(ListInvitationSecretIncidentAccessOrdering).is_optional().validate(
            ordering
        )
        Validator(str).is_optional().validate(detector_group_name)
        Validator(int).is_optional().validate(ignorer_id)
        Validator(str).is_optional().validate(ignorer_api_token_id)
        Validator(int).is_optional().validate(resolver_id)
        Validator(str).is_optional().validate(resolver_api_token_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/invitations/{{invitation_id}}/secret-incidents",
                self.get_default_headers(),
            )
            .add_path("invitation_id", invitation_id)
            .add_query("cursor", cursor)
            .add_query("page", page)
            .add_query("per_page", per_page)
            .add_query("date_before", date_before)
            .add_query("date_after", date_after)
            .add_query("assignee_email", assignee_email)
            .add_query("assignee_id", assignee_id)
            .add_query("status", status)
            .add_query("severity", severity)
            .add_query("validity", validity)
            .add_query("tags", tags)
            .add_query("ordering", ordering)
            .add_query("detector_group_name", detector_group_name)
            .add_query("ignorer_id", ignorer_id)
            .add_query("ignorer_api_token_id", ignorer_api_token_id)
            .add_query("resolver_id", resolver_id)
            .add_query("resolver_api_token_id", resolver_api_token_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return [IncidentWithoutOccurrences._unmap(item) for item in response]
