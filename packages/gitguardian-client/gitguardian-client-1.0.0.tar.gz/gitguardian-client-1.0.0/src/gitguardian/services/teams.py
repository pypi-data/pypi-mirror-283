# This file was generated by liblab | https://liblab.com/

from typing import List
from .utils.validator import Validator
from .utils.base_service import BaseService
from ..net.transport.serializer import Serializer
from ..models.validity_enum import ValidityEnum
from ..models.utils.cast_models import cast_models
from ..models.team import Team
from ..models.status_enum import StatusEnum
from ..models.severity_enum import SeverityEnum
from ..models.resource_type import ResourceType
from ..models.resource_team_access import ResourceTeamAccess
from ..models.list_team_secret_incident_access_ordering import (
    ListTeamSecretIncidentAccessOrdering,
)
from ..models.incident_without_occurrences import IncidentWithoutOccurrences
from ..models.create_teams_request import CreateTeamsRequest


class TeamsService(BaseService):

    @cast_models
    def list_teams(
        self,
        cursor: str = None,
        per_page: int = None,
        is_global: bool = None,
        search: str = None,
    ) -> List[Team]:
        """This endpoint allows you to list all the teams of your workspace.

        The response contains the list of teams and a pagination cursor to retrieve the next page.

        The teams are sorted by id.

        If you are using a personal access token, you need to have an access level superior or equal to `member`.

        :param cursor: Pagination cursor., defaults to None
        :type cursor: str, optional
        :param per_page: Number of items to list per page., defaults to None
        :type per_page: int, optional
        :param is_global: is_global, defaults to None
        :type is_global: bool, optional
        :param search: search, defaults to None
        :type search: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: List teams
        :rtype: List[Team]
        """

        Validator(str).is_optional().validate(cursor)
        Validator(int).is_optional().min(1).max(100).validate(per_page)
        Validator(bool).is_optional().validate(is_global)
        Validator(str).is_optional().validate(search)

        serialized_request = (
            Serializer(f"{self.base_url}/v1/teams", self.get_default_headers())
            .add_query("cursor", cursor)
            .add_query("per_page", per_page)
            .add_query("is_global", is_global)
            .add_query("search", search)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return [Team._unmap(item) for item in response]

    @cast_models
    def create_teams(self, request_body: CreateTeamsRequest = None) -> Team:
        """This endpoint allows you to create a team.

        If you are using a personal access token, you need to have an access level superior or equal to `manager`.

        If a personal access token is being used, the member is automatically added to the created team with permissions `can_manage` and `full_access`

        :param request_body: The request body., defaults to None
        :type request_body: CreateTeamsRequest, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Team created
        :rtype: Team
        """

        Validator(CreateTeamsRequest).is_optional().validate(request_body)

        serialized_request = (
            Serializer(f"{self.base_url}/v1/teams", self.get_default_headers())
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return Team._unmap(response)

    @cast_models
    def retrieve_team(self, team_id: int) -> Team:
        """Retrieve an existing team.

        If you are using a personal access token, you need to have an access level greater or equal to `member`.

        :param team_id: The id of the team
        :type team_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Team details
        :rtype: Team
        """

        Validator(int).validate(team_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/teams/{{team_id}}", self.get_default_headers()
            )
            .add_path("team_id", team_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return Team._unmap(response)

    @cast_models
    def update_team(self, team_id: int, request_body: Team = None) -> Team:
        """Update a team's name and/or its description.

        If you are using a personal access token, you must have "can manage" permission on the team or be a workspace manager.

        The "All-incidents" team (is_global=true) cannot be updated.

        :param request_body: The request body., defaults to None
        :type request_body: Team, optional
        :param team_id: The id of the team
        :type team_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The team was updated successfully.
        :rtype: Team
        """

        Validator(Team).is_optional().validate(request_body)
        Validator(int).validate(team_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/teams/{{team_id}}", self.get_default_headers()
            )
            .add_path("team_id", team_id)
            .serialize()
            .set_method("PATCH")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return Team._unmap(response)

    @cast_models
    def delete_team(self, team_id: int):
        """Delete an existing team.

        If you are using a personal access token, you must have "can manage" permission on the team or be a workspace manager.

        The "All-incidents" team (is_global=true) cannot be deleted.

        :param team_id: The id of the team
        :type team_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(int).validate(team_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/teams/{{team_id}}", self.get_default_headers()
            )
            .add_path("team_id", team_id)
            .serialize()
            .set_method("DELETE")
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def get_team_resource_access(
        self, team_id: int, resource_type: ResourceType, resource_id: int
    ) -> ResourceTeamAccess:
        """Return the permission a team has on a resource.

        For the global team, it will always be the highest possible permission.

        :param team_id: The id of the team
        :type team_id: int
        :param resource_type: The kind of resource of the access
        :type resource_type: ResourceType
        :param resource_id: The id of the resource of the access
        :type resource_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Team Secret resource access details
        :rtype: ResourceTeamAccess
        """

        Validator(int).validate(team_id)
        Validator(ResourceType).validate(resource_type)
        Validator(int).validate(resource_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/teams/{{team_id}}/{{resource_type}}/{{resource_id}}",
                self.get_default_headers(),
            )
            .add_path("team_id", team_id)
            .add_path("resource_type", resource_type)
            .add_path("resource_id", resource_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return ResourceTeamAccess._unmap(response)

    @cast_models
    def set_team_resource_access(
        self,
        request_body: ResourceTeamAccess,
        team_id: int,
        resource_type: ResourceType,
        resource_id: int,
    ) -> ResourceTeamAccess:
        """This will create or update a direct access for the team on the resource. If the
        access to the resource is already given by the team's perimeter, an error is raised.

        This endpoint is not allowed for the global team.

        :param request_body: The request body.
        :type request_body: ResourceTeamAccess
        :param team_id: The id of the team
        :type team_id: int
        :param resource_type: The kind of resource of the access
        :type resource_type: ResourceType
        :param resource_id: The id of the resource of the access
        :type resource_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The access was updated successfully.
        :rtype: ResourceTeamAccess
        """

        Validator(ResourceTeamAccess).validate(request_body)
        Validator(int).validate(team_id)
        Validator(ResourceType).validate(resource_type)
        Validator(int).validate(resource_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/teams/{{team_id}}/{{resource_type}}/{{resource_id}}",
                self.get_default_headers(),
            )
            .add_path("team_id", team_id)
            .add_path("resource_type", resource_type)
            .add_path("resource_id", resource_id)
            .serialize()
            .set_method("PUT")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return ResourceTeamAccess._unmap(response)

    @cast_models
    def revoke_team_resource_access(
        self,
        request_body: ResourceTeamAccess,
        team_id: int,
        resource_type: ResourceType,
        resource_id: int,
    ):
        """Revoke the access a team has to a resource.

        This only works for direct accesses. If the access to the resource is given by the
        team's perimeter, an error is raised.

        This endpoint is not allowed for the global team.

        :param request_body: The request body.
        :type request_body: ResourceTeamAccess
        :param team_id: The id of the team
        :type team_id: int
        :param resource_type: The kind of resource of the access
        :type resource_type: ResourceType
        :param resource_id: The id of the resource of the access
        :type resource_id: int
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(ResourceTeamAccess).validate(request_body)
        Validator(int).validate(team_id)
        Validator(ResourceType).validate(resource_type)
        Validator(int).validate(resource_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/teams/{{team_id}}/{{resource_type}}/{{resource_id}}",
                self.get_default_headers(),
            )
            .add_path("team_id", team_id)
            .add_path("resource_type", resource_type)
            .add_path("resource_id", resource_id)
            .serialize()
            .set_method("DELETE")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def list_team_secret_incident_access(
        self,
        team_id: int,
        cursor: str = None,
        page: int = None,
        per_page: int = None,
        date_before: str = None,
        date_after: str = None,
        assignee_email: str = None,
        assignee_id: int = None,
        status: StatusEnum = None,
        severity: SeverityEnum = None,
        validity: ValidityEnum = None,
        tags: any = None,
        ordering: ListTeamSecretIncidentAccessOrdering = None,
        detector_group_name: str = None,
        ignorer_id: int = None,
        ignorer_api_token_id: str = None,
        resolver_id: int = None,
        resolver_api_token_id: str = None,
    ) -> List[IncidentWithoutOccurrences]:
        """List secret incidents that a team has access to.

        :param team_id: The id of the team
        :type team_id: int
        :param cursor: Pagination cursor., defaults to None
        :type cursor: str, optional
        :param page: Page number., defaults to None
        :type page: int, optional
        :param per_page: Number of items to list per page., defaults to None
        :type per_page: int, optional
        :param date_before: date_before, defaults to None
        :type date_before: str, optional
        :param date_after: date_after, defaults to None
        :type date_after: str, optional
        :param assignee_email: assignee_email, defaults to None
        :type assignee_email: str, optional
        :param assignee_id: assignee_id, defaults to None
        :type assignee_id: int, optional
        :param status: status, defaults to None
        :type status: StatusEnum, optional
        :param severity: severity, defaults to None
        :type severity: SeverityEnum, optional
        :param validity: validity, defaults to None
        :type validity: ValidityEnum, optional
        :param tags: tags, defaults to None
        :type tags: any, optional
        :param ordering: Sort the results by their field value. The default sort is ASC, DESC if the
        field is preceded by a '-'., defaults to None
        :type ordering: ListTeamSecretIncidentAccessOrdering, optional
        :param detector_group_name: detector_group_name, defaults to None
        :type detector_group_name: str, optional
        :param ignorer_id: ignorer_id, defaults to None
        :type ignorer_id: int, optional
        :param ignorer_api_token_id: ignorer_api_token_id, defaults to None
        :type ignorer_api_token_id: str, optional
        :param resolver_id: resolver_id, defaults to None
        :type resolver_id: int, optional
        :param resolver_api_token_id: resolver_api_token_id, defaults to None
        :type resolver_api_token_id: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Secret Incident List
        :rtype: List[IncidentWithoutOccurrences]
        """

        Validator(int).validate(team_id)
        Validator(str).is_optional().validate(cursor)
        Validator(int).is_optional().min(0).validate(page)
        Validator(int).is_optional().min(1).max(100).validate(per_page)
        Validator(str).is_optional().validate(date_before)
        Validator(str).is_optional().validate(date_after)
        Validator(str).is_optional().validate(assignee_email)
        Validator(int).is_optional().validate(assignee_id)
        Validator(StatusEnum).is_optional().validate(status)
        Validator(SeverityEnum).is_optional().validate(severity)
        Validator(ValidityEnum).is_optional().validate(validity)
        Validator(any).is_optional().validate(tags)
        Validator(ListTeamSecretIncidentAccessOrdering).is_optional().validate(ordering)
        Validator(str).is_optional().validate(detector_group_name)
        Validator(int).is_optional().validate(ignorer_id)
        Validator(str).is_optional().validate(ignorer_api_token_id)
        Validator(int).is_optional().validate(resolver_id)
        Validator(str).is_optional().validate(resolver_api_token_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/v1/teams/{{team_id}}/secret-incidents",
                self.get_default_headers(),
            )
            .add_path("team_id", team_id)
            .add_query("cursor", cursor)
            .add_query("page", page)
            .add_query("per_page", per_page)
            .add_query("date_before", date_before)
            .add_query("date_after", date_after)
            .add_query("assignee_email", assignee_email)
            .add_query("assignee_id", assignee_id)
            .add_query("status", status)
            .add_query("severity", severity)
            .add_query("validity", validity)
            .add_query("tags", tags)
            .add_query("ordering", ordering)
            .add_query("detector_group_name", detector_group_name)
            .add_query("ignorer_id", ignorer_id)
            .add_query("ignorer_api_token_id", ignorer_api_token_id)
            .add_query("resolver_id", resolver_id)
            .add_query("resolver_api_token_id", resolver_api_token_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return [IncidentWithoutOccurrences._unmap(item) for item in response]
