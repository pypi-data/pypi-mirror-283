# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import Dict, List


class ActivateMediaWorkflowRequest(TeaModel):
    def __init__(
        self,
        media_workflow_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.media_workflow_id = media_workflow_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ActivateMediaWorkflowResponseBodyMediaWorkflow(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        media_workflow_id: str = None,
        name: str = None,
        state: str = None,
        topology: str = None,
    ):
        self.creation_time = creation_time
        self.media_workflow_id = media_workflow_id
        self.name = name
        self.state = state
        self.topology = topology

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.topology is not None:
            result['Topology'] = self.topology
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Topology') is not None:
            self.topology = m.get('Topology')
        return self


class ActivateMediaWorkflowResponseBody(TeaModel):
    def __init__(
        self,
        media_workflow: ActivateMediaWorkflowResponseBodyMediaWorkflow = None,
        request_id: str = None,
    ):
        self.media_workflow = media_workflow
        self.request_id = request_id

    def validate(self):
        if self.media_workflow:
            self.media_workflow.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow is not None:
            result['MediaWorkflow'] = self.media_workflow.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflow') is not None:
            temp_model = ActivateMediaWorkflowResponseBodyMediaWorkflow()
            self.media_workflow = temp_model.from_map(m['MediaWorkflow'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ActivateMediaWorkflowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ActivateMediaWorkflowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ActivateMediaWorkflowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddCategoryRequest(TeaModel):
    def __init__(
        self,
        cate_name: str = None,
        owner_account: str = None,
        owner_id: int = None,
        parent_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.cate_name = cate_name
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.parent_id = parent_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_name is not None:
            result['CateName'] = self.cate_name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CateName') is not None:
            self.cate_name = m.get('CateName')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class AddCategoryResponseBodyCategory(TeaModel):
    def __init__(
        self,
        cate_id: str = None,
        cate_name: str = None,
        level: str = None,
        parent_id: str = None,
    ):
        self.cate_id = cate_id
        self.cate_name = cate_name
        self.level = level
        self.parent_id = parent_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.cate_name is not None:
            result['CateName'] = self.cate_name
        if self.level is not None:
            result['Level'] = self.level
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CateName') is not None:
            self.cate_name = m.get('CateName')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        return self


class AddCategoryResponseBody(TeaModel):
    def __init__(
        self,
        category: AddCategoryResponseBodyCategory = None,
        request_id: str = None,
    ):
        self.category = category
        self.request_id = request_id

    def validate(self):
        if self.category:
            self.category.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            temp_model = AddCategoryResponseBodyCategory()
            self.category = temp_model.from_map(m['Category'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddCategoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddCategoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddCategoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddMediaRequest(TeaModel):
    def __init__(
        self,
        cate_id: int = None,
        cover_url: str = None,
        description: str = None,
        file_url: str = None,
        input_unbind: bool = None,
        media_workflow_id: str = None,
        media_workflow_user_data: str = None,
        override_params: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        tags: str = None,
        title: str = None,
    ):
        self.cate_id = cate_id
        self.cover_url = cover_url
        self.description = description
        # This parameter is required.
        self.file_url = file_url
        self.input_unbind = input_unbind
        self.media_workflow_id = media_workflow_id
        self.media_workflow_user_data = media_workflow_user_data
        self.override_params = override_params
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        self.tags = tags
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.description is not None:
            result['Description'] = self.description
        if self.file_url is not None:
            result['FileURL'] = self.file_url
        if self.input_unbind is not None:
            result['InputUnbind'] = self.input_unbind
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.media_workflow_user_data is not None:
            result['MediaWorkflowUserData'] = self.media_workflow_user_data
        if self.override_params is not None:
            result['OverrideParams'] = self.override_params
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FileURL') is not None:
            self.file_url = m.get('FileURL')
        if m.get('InputUnbind') is not None:
            self.input_unbind = m.get('InputUnbind')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('MediaWorkflowUserData') is not None:
            self.media_workflow_user_data = m.get('MediaWorkflowUserData')
        if m.get('OverrideParams') is not None:
            self.override_params = m.get('OverrideParams')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class AddMediaResponseBodyMediaFile(TeaModel):
    def __init__(
        self,
        state: str = None,
        url: str = None,
    ):
        self.state = state
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['State'] = self.state
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class AddMediaResponseBodyMediaRunIdList(TeaModel):
    def __init__(
        self,
        run_id: List[str] = None,
    ):
        self.run_id = run_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.run_id is not None:
            result['RunId'] = self.run_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RunId') is not None:
            self.run_id = m.get('RunId')
        return self


class AddMediaResponseBodyMediaTags(TeaModel):
    def __init__(
        self,
        tag: List[str] = None,
    ):
        self.tag = tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class AddMediaResponseBodyMedia(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        cate_id: int = None,
        censor_state: str = None,
        cover_url: str = None,
        creation_time: str = None,
        description: str = None,
        duration: str = None,
        file: AddMediaResponseBodyMediaFile = None,
        format: str = None,
        fps: str = None,
        height: str = None,
        media_id: str = None,
        publish_state: str = None,
        run_id_list: AddMediaResponseBodyMediaRunIdList = None,
        size: str = None,
        tags: AddMediaResponseBodyMediaTags = None,
        title: str = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.cate_id = cate_id
        self.censor_state = censor_state
        self.cover_url = cover_url
        self.creation_time = creation_time
        self.description = description
        self.duration = duration
        self.file = file
        self.format = format
        self.fps = fps
        self.height = height
        self.media_id = media_id
        self.publish_state = publish_state
        self.run_id_list = run_id_list
        self.size = size
        self.tags = tags
        self.title = title
        self.width = width

    def validate(self):
        if self.file:
            self.file.validate()
        if self.run_id_list:
            self.run_id_list.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.censor_state is not None:
            result['CensorState'] = self.censor_state
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.publish_state is not None:
            result['PublishState'] = self.publish_state
        if self.run_id_list is not None:
            result['RunIdList'] = self.run_id_list.to_map()
        if self.size is not None:
            result['Size'] = self.size
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.title is not None:
            result['Title'] = self.title
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CensorState') is not None:
            self.censor_state = m.get('CensorState')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('File') is not None:
            temp_model = AddMediaResponseBodyMediaFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('PublishState') is not None:
            self.publish_state = m.get('PublishState')
        if m.get('RunIdList') is not None:
            temp_model = AddMediaResponseBodyMediaRunIdList()
            self.run_id_list = temp_model.from_map(m['RunIdList'])
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Tags') is not None:
            temp_model = AddMediaResponseBodyMediaTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class AddMediaResponseBody(TeaModel):
    def __init__(
        self,
        media: AddMediaResponseBodyMedia = None,
        request_id: str = None,
    ):
        self.media = media
        self.request_id = request_id

    def validate(self):
        if self.media:
            self.media.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            temp_model = AddMediaResponseBodyMedia()
            self.media = temp_model.from_map(m['Media'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddMediaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddMediaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddMediaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddMediaTagRequest(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        tag: str = None,
    ):
        # This parameter is required.
        self.media_id = media_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        self.tag = tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class AddMediaTagResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddMediaTagResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddMediaTagResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddMediaTagResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddMediaWorkflowRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        topology: str = None,
        trigger_mode: str = None,
    ):
        # This parameter is required.
        self.name = name
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # This parameter is required.
        self.topology = topology
        self.trigger_mode = trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.topology is not None:
            result['Topology'] = self.topology
        if self.trigger_mode is not None:
            result['TriggerMode'] = self.trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Topology') is not None:
            self.topology = m.get('Topology')
        if m.get('TriggerMode') is not None:
            self.trigger_mode = m.get('TriggerMode')
        return self


class AddMediaWorkflowResponseBodyMediaWorkflow(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        media_workflow_id: str = None,
        name: str = None,
        state: str = None,
        topology: str = None,
        trigger_mode: str = None,
    ):
        self.creation_time = creation_time
        self.media_workflow_id = media_workflow_id
        self.name = name
        self.state = state
        self.topology = topology
        self.trigger_mode = trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.topology is not None:
            result['Topology'] = self.topology
        if self.trigger_mode is not None:
            result['TriggerMode'] = self.trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Topology') is not None:
            self.topology = m.get('Topology')
        if m.get('TriggerMode') is not None:
            self.trigger_mode = m.get('TriggerMode')
        return self


class AddMediaWorkflowResponseBody(TeaModel):
    def __init__(
        self,
        media_workflow: AddMediaWorkflowResponseBodyMediaWorkflow = None,
        request_id: str = None,
    ):
        self.media_workflow = media_workflow
        self.request_id = request_id

    def validate(self):
        if self.media_workflow:
            self.media_workflow.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow is not None:
            result['MediaWorkflow'] = self.media_workflow.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflow') is not None:
            temp_model = AddMediaWorkflowResponseBodyMediaWorkflow()
            self.media_workflow = temp_model.from_map(m['MediaWorkflow'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddMediaWorkflowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddMediaWorkflowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddMediaWorkflowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddPipelineRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        notify_config: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        role: str = None,
        speed: str = None,
        speed_level: int = None,
    ):
        # This parameter is required.
        self.name = name
        self.notify_config = notify_config
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        self.role = role
        self.speed = speed
        self.speed_level = speed_level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.notify_config is not None:
            result['NotifyConfig'] = self.notify_config
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.role is not None:
            result['Role'] = self.role
        if self.speed is not None:
            result['Speed'] = self.speed
        if self.speed_level is not None:
            result['SpeedLevel'] = self.speed_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotifyConfig') is not None:
            self.notify_config = m.get('NotifyConfig')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        if m.get('SpeedLevel') is not None:
            self.speed_level = m.get('SpeedLevel')
        return self


class AddPipelineResponseBodyPipelineNotifyConfig(TeaModel):
    def __init__(
        self,
        queue_name: str = None,
        topic: str = None,
    ):
        self.queue_name = queue_name
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.queue_name is not None:
            result['QueueName'] = self.queue_name
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('QueueName') is not None:
            self.queue_name = m.get('QueueName')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class AddPipelineResponseBodyPipeline(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        notify_config: AddPipelineResponseBodyPipelineNotifyConfig = None,
        role: str = None,
        speed: str = None,
        speed_level: int = None,
        state: str = None,
    ):
        self.id = id
        self.name = name
        self.notify_config = notify_config
        self.role = role
        self.speed = speed
        self.speed_level = speed_level
        self.state = state

    def validate(self):
        if self.notify_config:
            self.notify_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notify_config is not None:
            result['NotifyConfig'] = self.notify_config.to_map()
        if self.role is not None:
            result['Role'] = self.role
        if self.speed is not None:
            result['Speed'] = self.speed
        if self.speed_level is not None:
            result['SpeedLevel'] = self.speed_level
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotifyConfig') is not None:
            temp_model = AddPipelineResponseBodyPipelineNotifyConfig()
            self.notify_config = temp_model.from_map(m['NotifyConfig'])
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        if m.get('SpeedLevel') is not None:
            self.speed_level = m.get('SpeedLevel')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class AddPipelineResponseBody(TeaModel):
    def __init__(
        self,
        pipeline: AddPipelineResponseBodyPipeline = None,
        request_id: str = None,
    ):
        self.pipeline = pipeline
        self.request_id = request_id

    def validate(self):
        if self.pipeline:
            self.pipeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline is not None:
            result['Pipeline'] = self.pipeline.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pipeline') is not None:
            temp_model = AddPipelineResponseBodyPipeline()
            self.pipeline = temp_model.from_map(m['Pipeline'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddPipelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddPipelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddPipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddTemplateRequest(TeaModel):
    def __init__(
        self,
        audio: str = None,
        container: str = None,
        mux_config: str = None,
        name: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        trans_config: str = None,
        video: str = None,
    ):
        self.audio = audio
        self.container = container
        self.mux_config = mux_config
        # This parameter is required.
        self.name = name
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        self.trans_config = trans_config
        self.video = video

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio
        if self.container is not None:
            result['Container'] = self.container
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config
        if self.video is not None:
            result['Video'] = self.video
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            self.audio = m.get('Audio')
        if m.get('Container') is not None:
            self.container = m.get('Container')
        if m.get('MuxConfig') is not None:
            self.mux_config = m.get('MuxConfig')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TransConfig') is not None:
            self.trans_config = m.get('TransConfig')
        if m.get('Video') is not None:
            self.video = m.get('Video')
        return self


class AddTemplateResponseBodyTemplateAudioVolume(TeaModel):
    def __init__(
        self,
        level: str = None,
        method: str = None,
    ):
        self.level = level
        self.method = method

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.level is not None:
            result['Level'] = self.level
        if self.method is not None:
            result['Method'] = self.method
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        return self


class AddTemplateResponseBodyTemplateAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        qscale: str = None,
        remove: str = None,
        samplerate: str = None,
        volume: AddTemplateResponseBodyTemplateAudioVolume = None,
    ):
        self.bitrate = bitrate
        self.channels = channels
        self.codec = codec
        self.profile = profile
        self.qscale = qscale
        self.remove = remove
        self.samplerate = samplerate
        self.volume = volume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = AddTemplateResponseBodyTemplateAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class AddTemplateResponseBodyTemplateContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class AddTemplateResponseBodyTemplateMuxConfigGif(TeaModel):
    def __init__(
        self,
        dither_mode: str = None,
        final_delay: str = None,
        is_custom_palette: str = None,
        loop: str = None,
    ):
        self.dither_mode = dither_mode
        self.final_delay = final_delay
        self.is_custom_palette = is_custom_palette
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dither_mode is not None:
            result['DitherMode'] = self.dither_mode
        if self.final_delay is not None:
            result['FinalDelay'] = self.final_delay
        if self.is_custom_palette is not None:
            result['IsCustomPalette'] = self.is_custom_palette
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DitherMode') is not None:
            self.dither_mode = m.get('DitherMode')
        if m.get('FinalDelay') is not None:
            self.final_delay = m.get('FinalDelay')
        if m.get('IsCustomPalette') is not None:
            self.is_custom_palette = m.get('IsCustomPalette')
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class AddTemplateResponseBodyTemplateMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
    ):
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class AddTemplateResponseBodyTemplateMuxConfigWebp(TeaModel):
    def __init__(
        self,
        loop: str = None,
    ):
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class AddTemplateResponseBodyTemplateMuxConfig(TeaModel):
    def __init__(
        self,
        gif: AddTemplateResponseBodyTemplateMuxConfigGif = None,
        segment: AddTemplateResponseBodyTemplateMuxConfigSegment = None,
        webp: AddTemplateResponseBodyTemplateMuxConfigWebp = None,
    ):
        self.gif = gif
        self.segment = segment
        self.webp = webp

    def validate(self):
        if self.gif:
            self.gif.validate()
        if self.segment:
            self.segment.validate()
        if self.webp:
            self.webp.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gif is not None:
            result['Gif'] = self.gif.to_map()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        if self.webp is not None:
            result['Webp'] = self.webp.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gif') is not None:
            temp_model = AddTemplateResponseBodyTemplateMuxConfigGif()
            self.gif = temp_model.from_map(m['Gif'])
        if m.get('Segment') is not None:
            temp_model = AddTemplateResponseBodyTemplateMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        if m.get('Webp') is not None:
            temp_model = AddTemplateResponseBodyTemplateMuxConfigWebp()
            self.webp = temp_model.from_map(m['Webp'])
        return self


class AddTemplateResponseBodyTemplateTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        is_check_audio_bitrate: str = None,
        is_check_audio_bitrate_fail: str = None,
        is_check_reso: str = None,
        is_check_reso_fail: str = None,
        is_check_video_bitrate: str = None,
        is_check_video_bitrate_fail: str = None,
        trans_mode: str = None,
    ):
        self.adj_dar_method = adj_dar_method
        self.is_check_audio_bitrate = is_check_audio_bitrate
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        self.is_check_reso = is_check_reso
        self.is_check_reso_fail = is_check_reso_fail
        self.is_check_video_bitrate = is_check_video_bitrate
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class AddTemplateResponseBodyTemplateVideoBitrateBnd(TeaModel):
    def __init__(
        self,
        max: str = None,
        min: str = None,
    ):
        self.max = max
        self.min = min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        return self


class AddTemplateResponseBodyTemplateVideo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        bitrate_bnd: AddTemplateResponseBodyTemplateVideoBitrateBnd = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        degrain: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        max_fps: str = None,
        maxrate: str = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        qscale: str = None,
        remove: str = None,
        reso_priority: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.bitrate_bnd = bitrate_bnd
        self.bufsize = bufsize
        self.codec = codec
        self.crf = crf
        self.crop = crop
        self.degrain = degrain
        self.fps = fps
        self.gop = gop
        self.height = height
        self.max_fps = max_fps
        self.maxrate = maxrate
        self.pad = pad
        self.pix_fmt = pix_fmt
        self.preset = preset
        self.profile = profile
        self.qscale = qscale
        self.remove = remove
        self.reso_priority = reso_priority
        self.scan_mode = scan_mode
        self.width = width

    def validate(self):
        if self.bitrate_bnd:
            self.bitrate_bnd.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bitrate_bnd is not None:
            result['BitrateBnd'] = self.bitrate_bnd.to_map()
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.degrain is not None:
            result['Degrain'] = self.degrain
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.max_fps is not None:
            result['MaxFps'] = self.max_fps
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.reso_priority is not None:
            result['ResoPriority'] = self.reso_priority
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BitrateBnd') is not None:
            temp_model = AddTemplateResponseBodyTemplateVideoBitrateBnd()
            self.bitrate_bnd = temp_model.from_map(m['BitrateBnd'])
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Degrain') is not None:
            self.degrain = m.get('Degrain')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MaxFps') is not None:
            self.max_fps = m.get('MaxFps')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('ResoPriority') is not None:
            self.reso_priority = m.get('ResoPriority')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class AddTemplateResponseBodyTemplate(TeaModel):
    def __init__(
        self,
        audio: AddTemplateResponseBodyTemplateAudio = None,
        container: AddTemplateResponseBodyTemplateContainer = None,
        id: str = None,
        mux_config: AddTemplateResponseBodyTemplateMuxConfig = None,
        name: str = None,
        state: str = None,
        trans_config: AddTemplateResponseBodyTemplateTransConfig = None,
        video: AddTemplateResponseBodyTemplateVideo = None,
    ):
        self.audio = audio
        self.container = container
        self.id = id
        self.mux_config = mux_config
        self.name = name
        self.state = state
        self.trans_config = trans_config
        self.video = video

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = AddTemplateResponseBodyTemplateAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = AddTemplateResponseBodyTemplateContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MuxConfig') is not None:
            temp_model = AddTemplateResponseBodyTemplateMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TransConfig') is not None:
            temp_model = AddTemplateResponseBodyTemplateTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('Video') is not None:
            temp_model = AddTemplateResponseBodyTemplateVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class AddTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template: AddTemplateResponseBodyTemplate = None,
    ):
        self.request_id = request_id
        self.template = template

    def validate(self):
        if self.template:
            self.template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template is not None:
            result['Template'] = self.template.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Template') is not None:
            temp_model = AddTemplateResponseBodyTemplate()
            self.template = temp_model.from_map(m['Template'])
        return self


class AddTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddWaterMarkTemplateRequest(TeaModel):
    def __init__(
        self,
        config: str = None,
        name: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.config = config
        # This parameter is required.
        self.name = name
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        width: str = None,
    ):
        self.dx = dx
        self.dy = dy
        self.height = height
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline(TeaModel):
    def __init__(
        self,
        duration: str = None,
        start: str = None,
    ):
        self.duration = duration
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class AddWaterMarkTemplateResponseBodyWaterMarkTemplate(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        id: str = None,
        name: str = None,
        ratio_refer: AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer = None,
        refer_pos: str = None,
        state: str = None,
        timeline: AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline = None,
        type: str = None,
        width: str = None,
    ):
        self.dx = dx
        self.dy = dy
        self.height = height
        self.id = id
        self.name = name
        self.ratio_refer = ratio_refer
        self.refer_pos = refer_pos
        self.state = state
        self.timeline = timeline
        self.type = type
        self.width = width

    def validate(self):
        if self.ratio_refer:
            self.ratio_refer.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.ratio_refer is not None:
            result['RatioRefer'] = self.ratio_refer.to_map()
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.state is not None:
            result['State'] = self.state
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RatioRefer') is not None:
            temp_model = AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer()
            self.ratio_refer = temp_model.from_map(m['RatioRefer'])
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Timeline') is not None:
            temp_model = AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class AddWaterMarkTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        water_mark_template: AddWaterMarkTemplateResponseBodyWaterMarkTemplate = None,
    ):
        self.request_id = request_id
        self.water_mark_template = water_mark_template

    def validate(self):
        if self.water_mark_template:
            self.water_mark_template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.water_mark_template is not None:
            result['WaterMarkTemplate'] = self.water_mark_template.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('WaterMarkTemplate') is not None:
            temp_model = AddWaterMarkTemplateResponseBodyWaterMarkTemplate()
            self.water_mark_template = temp_model.from_map(m['WaterMarkTemplate'])
        return self


class AddWaterMarkTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddWaterMarkTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddWaterMarkTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindInputBucketRequest(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        role_arn: str = None,
    ):
        # This parameter is required.
        self.bucket = bucket
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class BindInputBucketResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class BindInputBucketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BindInputBucketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindInputBucketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindOutputBucketRequest(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        role_arn: str = None,
    ):
        # This parameter is required.
        self.bucket = bucket
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class BindOutputBucketResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class BindOutputBucketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BindOutputBucketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindOutputBucketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.job_id = job_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class CancelJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        self.job_id = job_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CancelJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CancelJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CategoryTreeRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class CategoryTreeResponseBody(TeaModel):
    def __init__(
        self,
        category_tree: str = None,
        request_id: str = None,
    ):
        self.category_tree = category_tree
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_tree is not None:
            result['CategoryTree'] = self.category_tree
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryTree') is not None:
            self.category_tree = m.get('CategoryTree')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CategoryTreeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CategoryTreeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CategoryTreeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeactivateMediaWorkflowRequest(TeaModel):
    def __init__(
        self,
        media_workflow_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.media_workflow_id = media_workflow_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeactivateMediaWorkflowResponseBodyMediaWorkflow(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        media_workflow_id: str = None,
        name: str = None,
        state: str = None,
        topology: str = None,
    ):
        self.creation_time = creation_time
        self.media_workflow_id = media_workflow_id
        self.name = name
        self.state = state
        self.topology = topology

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.topology is not None:
            result['Topology'] = self.topology
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Topology') is not None:
            self.topology = m.get('Topology')
        return self


class DeactivateMediaWorkflowResponseBody(TeaModel):
    def __init__(
        self,
        media_workflow: DeactivateMediaWorkflowResponseBodyMediaWorkflow = None,
        request_id: str = None,
    ):
        self.media_workflow = media_workflow
        self.request_id = request_id

    def validate(self):
        if self.media_workflow:
            self.media_workflow.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow is not None:
            result['MediaWorkflow'] = self.media_workflow.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflow') is not None:
            temp_model = DeactivateMediaWorkflowResponseBodyMediaWorkflow()
            self.media_workflow = temp_model.from_map(m['MediaWorkflow'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeactivateMediaWorkflowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeactivateMediaWorkflowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeactivateMediaWorkflowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCategoryRequest(TeaModel):
    def __init__(
        self,
        cate_id: int = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.cate_id = cate_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteCategoryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCategoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCategoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCategoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMediaRequest(TeaModel):
    def __init__(
        self,
        media_ids: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.media_ids = media_ids
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_ids is not None:
            result['MediaIds'] = self.media_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaIds') is not None:
            self.media_ids = m.get('MediaIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteMediaResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteMediaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMediaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMediaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMediaTagRequest(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        tag: str = None,
    ):
        # This parameter is required.
        self.media_id = media_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        self.tag = tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class DeleteMediaTagResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteMediaTagResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMediaTagResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMediaTagResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMediaWorkflowRequest(TeaModel):
    def __init__(
        self,
        media_workflow_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.media_workflow_id = media_workflow_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteMediaWorkflowResponseBodyMediaWorkflow(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        media_workflow_id: str = None,
        name: str = None,
        state: str = None,
        topology: str = None,
    ):
        self.creation_time = creation_time
        self.media_workflow_id = media_workflow_id
        self.name = name
        self.state = state
        self.topology = topology

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.topology is not None:
            result['Topology'] = self.topology
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Topology') is not None:
            self.topology = m.get('Topology')
        return self


class DeleteMediaWorkflowResponseBody(TeaModel):
    def __init__(
        self,
        media_workflow: DeleteMediaWorkflowResponseBodyMediaWorkflow = None,
        request_id: str = None,
    ):
        self.media_workflow = media_workflow
        self.request_id = request_id

    def validate(self):
        if self.media_workflow:
            self.media_workflow.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow is not None:
            result['MediaWorkflow'] = self.media_workflow.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflow') is not None:
            temp_model = DeleteMediaWorkflowResponseBodyMediaWorkflow()
            self.media_workflow = temp_model.from_map(m['MediaWorkflow'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteMediaWorkflowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMediaWorkflowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMediaWorkflowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePipelineRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        # This parameter is required.
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeletePipelineResponseBody(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
        request_id: str = None,
    ):
        self.pipeline_id = pipeline_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeletePipelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeletePipelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTemplateRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        template_id: str = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DeleteTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template_id: str = None,
    ):
        self.request_id = request_id
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DeleteTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteWaterMarkTemplateRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        water_mark_template_id: str = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # This parameter is required.
        self.water_mark_template_id = water_mark_template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.water_mark_template_id is not None:
            result['WaterMarkTemplateId'] = self.water_mark_template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('WaterMarkTemplateId') is not None:
            self.water_mark_template_id = m.get('WaterMarkTemplateId')
        return self


class DeleteWaterMarkTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        water_mark_template_id: str = None,
    ):
        self.request_id = request_id
        self.water_mark_template_id = water_mark_template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.water_mark_template_id is not None:
            result['WaterMarkTemplateId'] = self.water_mark_template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('WaterMarkTemplateId') is not None:
            self.water_mark_template_id = m.get('WaterMarkTemplateId')
        return self


class DeleteWaterMarkTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteWaterMarkTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteWaterMarkTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMtsUserResourcePackageRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        security_token: str = None,
    ):
        self.owner_id = owner_id
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo(TeaModel):
    def __init__(
        self,
        commodity_code: str = None,
        curr_capacity: str = None,
        display_name: str = None,
        init_capacity: str = None,
        instance_id: str = None,
        status: str = None,
    ):
        self.commodity_code = commodity_code
        self.curr_capacity = curr_capacity
        self.display_name = display_name
        self.init_capacity = init_capacity
        self.instance_id = instance_id
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.curr_capacity is not None:
            result['CurrCapacity'] = self.curr_capacity
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.init_capacity is not None:
            result['InitCapacity'] = self.init_capacity
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('CurrCapacity') is not None:
            self.curr_capacity = m.get('CurrCapacity')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('InitCapacity') is not None:
            self.init_capacity = m.get('InitCapacity')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeMtsUserResourcePackageResponseBodyResourcePackageInfos(TeaModel):
    def __init__(
        self,
        resource_package_info: List[DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo] = None,
    ):
        self.resource_package_info = resource_package_info

    def validate(self):
        if self.resource_package_info:
            for k in self.resource_package_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ResourcePackageInfo'] = []
        if self.resource_package_info is not None:
            for k in self.resource_package_info:
                result['ResourcePackageInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.resource_package_info = []
        if m.get('ResourcePackageInfo') is not None:
            for k in m.get('ResourcePackageInfo'):
                temp_model = DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo()
                self.resource_package_info.append(temp_model.from_map(k))
        return self


class DescribeMtsUserResourcePackageResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        resource_package_infos: DescribeMtsUserResourcePackageResponseBodyResourcePackageInfos = None,
    ):
        self.request_id = request_id
        self.resource_package_infos = resource_package_infos

    def validate(self):
        if self.resource_package_infos:
            self.resource_package_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource_package_infos is not None:
            result['ResourcePackageInfos'] = self.resource_package_infos.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResourcePackageInfos') is not None:
            temp_model = DescribeMtsUserResourcePackageResponseBodyResourcePackageInfos()
            self.resource_package_infos = temp_model.from_map(m['ResourcePackageInfos'])
        return self


class DescribeMtsUserResourcePackageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeMtsUserResourcePackageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMtsUserResourcePackageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAllCategoryRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ListAllCategoryResponseBodyCategoryListCategory(TeaModel):
    def __init__(
        self,
        cate_id: str = None,
        cate_name: str = None,
        level: str = None,
        parent_id: str = None,
    ):
        self.cate_id = cate_id
        self.cate_name = cate_name
        self.level = level
        self.parent_id = parent_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.cate_name is not None:
            result['CateName'] = self.cate_name
        if self.level is not None:
            result['Level'] = self.level
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CateName') is not None:
            self.cate_name = m.get('CateName')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        return self


class ListAllCategoryResponseBodyCategoryList(TeaModel):
    def __init__(
        self,
        category: List[ListAllCategoryResponseBodyCategoryListCategory] = None,
    ):
        self.category = category

    def validate(self):
        if self.category:
            for k in self.category:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Category'] = []
        if self.category is not None:
            for k in self.category:
                result['Category'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.category = []
        if m.get('Category') is not None:
            for k in m.get('Category'):
                temp_model = ListAllCategoryResponseBodyCategoryListCategory()
                self.category.append(temp_model.from_map(k))
        return self


class ListAllCategoryResponseBody(TeaModel):
    def __init__(
        self,
        category_list: ListAllCategoryResponseBodyCategoryList = None,
        request_id: str = None,
    ):
        self.category_list = category_list
        self.request_id = request_id

    def validate(self):
        if self.category_list:
            self.category_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_list is not None:
            result['CategoryList'] = self.category_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryList') is not None:
            temp_model = ListAllCategoryResponseBodyCategoryList()
            self.category_list = temp_model.from_map(m['CategoryList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListAllCategoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAllCategoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAllCategoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAllMediaBucketRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ListAllMediaBucketResponseBodyMediaBucketListMediaBucket(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        type: str = None,
    ):
        self.bucket = bucket
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListAllMediaBucketResponseBodyMediaBucketList(TeaModel):
    def __init__(
        self,
        media_bucket: List[ListAllMediaBucketResponseBodyMediaBucketListMediaBucket] = None,
    ):
        self.media_bucket = media_bucket

    def validate(self):
        if self.media_bucket:
            for k in self.media_bucket:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MediaBucket'] = []
        if self.media_bucket is not None:
            for k in self.media_bucket:
                result['MediaBucket'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.media_bucket = []
        if m.get('MediaBucket') is not None:
            for k in m.get('MediaBucket'):
                temp_model = ListAllMediaBucketResponseBodyMediaBucketListMediaBucket()
                self.media_bucket.append(temp_model.from_map(k))
        return self


class ListAllMediaBucketResponseBody(TeaModel):
    def __init__(
        self,
        media_bucket_list: ListAllMediaBucketResponseBodyMediaBucketList = None,
        request_id: str = None,
    ):
        self.media_bucket_list = media_bucket_list
        self.request_id = request_id

    def validate(self):
        if self.media_bucket_list:
            self.media_bucket_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_bucket_list is not None:
            result['MediaBucketList'] = self.media_bucket_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaBucketList') is not None:
            temp_model = ListAllMediaBucketResponseBodyMediaBucketList()
            self.media_bucket_list = temp_model.from_map(m['MediaBucketList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListAllMediaBucketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAllMediaBucketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAllMediaBucketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListJobRequest(TeaModel):
    def __init__(
        self,
        end_of_job_created_time_range: str = None,
        maximum_page_size: int = None,
        next_page_token: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        start_of_job_created_time_range: str = None,
        state: str = None,
    ):
        self.end_of_job_created_time_range = end_of_job_created_time_range
        self.maximum_page_size = maximum_page_size
        self.next_page_token = next_page_token
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        self.start_of_job_created_time_range = start_of_job_created_time_range
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_of_job_created_time_range is not None:
            result['EndOfJobCreatedTimeRange'] = self.end_of_job_created_time_range
        if self.maximum_page_size is not None:
            result['MaximumPageSize'] = self.maximum_page_size
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_of_job_created_time_range is not None:
            result['StartOfJobCreatedTimeRange'] = self.start_of_job_created_time_range
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndOfJobCreatedTimeRange') is not None:
            self.end_of_job_created_time_range = m.get('EndOfJobCreatedTimeRange')
        if m.get('MaximumPageSize') is not None:
            self.maximum_page_size = m.get('MaximumPageSize')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartOfJobCreatedTimeRange') is not None:
            self.start_of_job_created_time_range = m.get('StartOfJobCreatedTimeRange')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListJobResponseBodyJobListJobInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class ListJobResponseBodyJobListJobMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class ListJobResponseBodyJobListJobOutputAmixListAmix(TeaModel):
    def __init__(
        self,
        amix_url: str = None,
        duration: str = None,
        map: str = None,
        mix_dur_mode: str = None,
        start: str = None,
    ):
        self.amix_url = amix_url
        self.duration = duration
        self.map = map
        self.mix_dur_mode = mix_dur_mode
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amix_url is not None:
            result['AmixURL'] = self.amix_url
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.map is not None:
            result['Map'] = self.map
        if self.mix_dur_mode is not None:
            result['MixDurMode'] = self.mix_dur_mode
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AmixURL') is not None:
            self.amix_url = m.get('AmixURL')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Map') is not None:
            self.map = m.get('Map')
        if m.get('MixDurMode') is not None:
            self.mix_dur_mode = m.get('MixDurMode')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class ListJobResponseBodyJobListJobOutputAmixList(TeaModel):
    def __init__(
        self,
        amix: List[ListJobResponseBodyJobListJobOutputAmixListAmix] = None,
    ):
        self.amix = amix

    def validate(self):
        if self.amix:
            for k in self.amix:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Amix'] = []
        if self.amix is not None:
            for k in self.amix:
                result['Amix'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.amix = []
        if m.get('Amix') is not None:
            for k in m.get('Amix'):
                temp_model = ListJobResponseBodyJobListJobOutputAmixListAmix()
                self.amix.append(temp_model.from_map(k))
        return self


class ListJobResponseBodyJobListJobOutputAudioVolume(TeaModel):
    def __init__(
        self,
        level: str = None,
        method: str = None,
    ):
        self.level = level
        self.method = method

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.level is not None:
            result['Level'] = self.level
        if self.method is not None:
            result['Method'] = self.method
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        return self


class ListJobResponseBodyJobListJobOutputAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        qscale: str = None,
        samplerate: str = None,
        volume: ListJobResponseBodyJobListJobOutputAudioVolume = None,
    ):
        self.bitrate = bitrate
        self.channels = channels
        self.codec = codec
        self.profile = profile
        self.qscale = qscale
        self.samplerate = samplerate
        self.volume = volume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class ListJobResponseBodyJobListJobOutputClipTimeSpan(TeaModel):
    def __init__(
        self,
        duration: str = None,
        seek: str = None,
    ):
        self.duration = duration
        self.seek = seek

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.seek is not None:
            result['Seek'] = self.seek
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Seek') is not None:
            self.seek = m.get('Seek')
        return self


class ListJobResponseBodyJobListJobOutputClip(TeaModel):
    def __init__(
        self,
        time_span: ListJobResponseBodyJobListJobOutputClipTimeSpan = None,
    ):
        self.time_span = time_span

    def validate(self):
        if self.time_span:
            self.time_span.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time_span is not None:
            result['TimeSpan'] = self.time_span.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeSpan') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputClipTimeSpan()
            self.time_span = temp_model.from_map(m['TimeSpan'])
        return self


class ListJobResponseBodyJobListJobOutputContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class ListJobResponseBodyJobListJobOutputEncryption(TeaModel):
    def __init__(
        self,
        id: str = None,
        key: str = None,
        key_type: str = None,
        key_uri: str = None,
        skip_cnt: str = None,
        type: str = None,
    ):
        self.id = id
        self.key = key
        self.key_type = key_type
        self.key_uri = key_uri
        self.skip_cnt = skip_cnt
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.key is not None:
            result['Key'] = self.key
        if self.key_type is not None:
            result['KeyType'] = self.key_type
        if self.key_uri is not None:
            result['KeyUri'] = self.key_uri
        if self.skip_cnt is not None:
            result['SkipCnt'] = self.skip_cnt
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('KeyType') is not None:
            self.key_type = m.get('KeyType')
        if m.get('KeyUri') is not None:
            self.key_uri = m.get('KeyUri')
        if m.get('SkipCnt') is not None:
            self.skip_cnt = m.get('SkipCnt')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS(TeaModel):
    def __init__(
        self,
        md_5support: bool = None,
        size_support: bool = None,
    ):
        self.md_5support = md_5support
        self.size_support = size_support

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.md_5support is not None:
            result['Md5Support'] = self.md_5support
        if self.size_support is not None:
            result['SizeSupport'] = self.size_support
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Md5Support') is not None:
            self.md_5support = m.get('Md5Support')
        if m.get('SizeSupport') is not None:
            self.size_support = m.get('SizeSupport')
        return self


class ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport(TeaModel):
    def __init__(
        self,
        ts: ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS = None,
    ):
        self.ts = ts

    def validate(self):
        if self.ts:
            self.ts.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ts is not None:
            result['TS'] = self.ts.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TS') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS()
            self.ts = temp_model.from_map(m['TS'])
        return self


class ListJobResponseBodyJobListJobOutputMergeListMerge(TeaModel):
    def __init__(
        self,
        duration: str = None,
        merge_url: str = None,
        role_arn: str = None,
        start: str = None,
    ):
        self.duration = duration
        self.merge_url = merge_url
        self.role_arn = role_arn
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.merge_url is not None:
            result['MergeURL'] = self.merge_url
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('MergeURL') is not None:
            self.merge_url = m.get('MergeURL')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class ListJobResponseBodyJobListJobOutputMergeList(TeaModel):
    def __init__(
        self,
        merge: List[ListJobResponseBodyJobListJobOutputMergeListMerge] = None,
    ):
        self.merge = merge

    def validate(self):
        if self.merge:
            for k in self.merge:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Merge'] = []
        if self.merge is not None:
            for k in self.merge:
                result['Merge'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.merge = []
        if m.get('Merge') is not None:
            for k in m.get('Merge'):
                temp_model = ListJobResponseBodyJobListJobOutputMergeListMerge()
                self.merge.append(temp_model.from_map(k))
        return self


class ListJobResponseBodyJobListJobOutputMuxConfigGif(TeaModel):
    def __init__(
        self,
        dither_mode: str = None,
        final_delay: str = None,
        is_custom_palette: str = None,
        loop: str = None,
    ):
        self.dither_mode = dither_mode
        self.final_delay = final_delay
        self.is_custom_palette = is_custom_palette
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dither_mode is not None:
            result['DitherMode'] = self.dither_mode
        if self.final_delay is not None:
            result['FinalDelay'] = self.final_delay
        if self.is_custom_palette is not None:
            result['IsCustomPalette'] = self.is_custom_palette
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DitherMode') is not None:
            self.dither_mode = m.get('DitherMode')
        if m.get('FinalDelay') is not None:
            self.final_delay = m.get('FinalDelay')
        if m.get('IsCustomPalette') is not None:
            self.is_custom_palette = m.get('IsCustomPalette')
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class ListJobResponseBodyJobListJobOutputMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
    ):
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class ListJobResponseBodyJobListJobOutputMuxConfigWebp(TeaModel):
    def __init__(
        self,
        loop: str = None,
    ):
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class ListJobResponseBodyJobListJobOutputMuxConfig(TeaModel):
    def __init__(
        self,
        gif: ListJobResponseBodyJobListJobOutputMuxConfigGif = None,
        segment: ListJobResponseBodyJobListJobOutputMuxConfigSegment = None,
        webp: ListJobResponseBodyJobListJobOutputMuxConfigWebp = None,
    ):
        self.gif = gif
        self.segment = segment
        self.webp = webp

    def validate(self):
        if self.gif:
            self.gif.validate()
        if self.segment:
            self.segment.validate()
        if self.webp:
            self.webp.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gif is not None:
            result['Gif'] = self.gif.to_map()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        if self.webp is not None:
            result['Webp'] = self.webp.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gif') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputMuxConfigGif()
            self.gif = temp_model.from_map(m['Gif'])
        if m.get('Segment') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        if m.get('Webp') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputMuxConfigWebp()
            self.webp = temp_model.from_map(m['Webp'])
        return self


class ListJobResponseBodyJobListJobOutputOpeningListOpening(TeaModel):
    def __init__(
        self,
        height: str = None,
        start: str = None,
        width: str = None,
        open_url: str = None,
    ):
        self.height = height
        self.start = start
        self.width = width
        self.open_url = open_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.start is not None:
            result['Start'] = self.start
        if self.width is not None:
            result['Width'] = self.width
        if self.open_url is not None:
            result['openUrl'] = self.open_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('openUrl') is not None:
            self.open_url = m.get('openUrl')
        return self


class ListJobResponseBodyJobListJobOutputOpeningList(TeaModel):
    def __init__(
        self,
        opening: List[ListJobResponseBodyJobListJobOutputOpeningListOpening] = None,
    ):
        self.opening = opening

    def validate(self):
        if self.opening:
            for k in self.opening:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Opening'] = []
        if self.opening is not None:
            for k in self.opening:
                result['Opening'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.opening = []
        if m.get('Opening') is not None:
            for k in m.get('Opening'):
                temp_model = ListJobResponseBodyJobListJobOutputOpeningListOpening()
                self.opening.append(temp_model.from_map(k))
        return self


class ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle(TeaModel):
    def __init__(
        self,
        map: str = None,
        message: str = None,
        out_subtitle_file: ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile = None,
        success: bool = None,
    ):
        self.map = map
        self.message = message
        self.out_subtitle_file = out_subtitle_file
        self.success = success

    def validate(self):
        if self.out_subtitle_file:
            self.out_subtitle_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.map is not None:
            result['Map'] = self.map
        if self.message is not None:
            result['Message'] = self.message
        if self.out_subtitle_file is not None:
            result['OutSubtitleFile'] = self.out_subtitle_file.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Map') is not None:
            self.map = m.get('Map')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('OutSubtitleFile') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile()
            self.out_subtitle_file = temp_model.from_map(m['OutSubtitleFile'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListJobResponseBodyJobListJobOutputOutSubtitleList(TeaModel):
    def __init__(
        self,
        out_subtitle: List[ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle] = None,
    ):
        self.out_subtitle = out_subtitle

    def validate(self):
        if self.out_subtitle:
            for k in self.out_subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OutSubtitle'] = []
        if self.out_subtitle is not None:
            for k in self.out_subtitle:
                result['OutSubtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.out_subtitle = []
        if m.get('OutSubtitle') is not None:
            for k in m.get('OutSubtitle'):
                temp_model = ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle()
                self.out_subtitle.append(temp_model.from_map(k))
        return self


class ListJobResponseBodyJobListJobOutputOutputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class ListJobResponseBodyJobListJobOutputPropertiesFormat(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        format_long_name: str = None,
        format_name: str = None,
        num_programs: str = None,
        num_streams: str = None,
        size: str = None,
        start_time: str = None,
    ):
        self.bitrate = bitrate
        self.duration = duration
        self.format_long_name = format_long_name
        self.format_name = format_name
        self.num_programs = num_programs
        self.num_streams = num_streams
        self.size = size
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.format_long_name is not None:
            result['FormatLongName'] = self.format_long_name
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.num_programs is not None:
            result['NumPrograms'] = self.num_programs
        if self.num_streams is not None:
            result['NumStreams'] = self.num_streams
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FormatLongName') is not None:
            self.format_long_name = m.get('FormatLongName')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('NumPrograms') is not None:
            self.num_programs = m.get('NumPrograms')
        if m.get('NumStreams') is not None:
            self.num_streams = m.get('NumStreams')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        num_frames: str = None,
        sample_fmt: str = None,
        samplerate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        self.bitrate = bitrate
        self.channel_layout = channel_layout
        self.channels = channels
        self.codec_long_name = codec_long_name
        self.codec_name = codec_name
        self.codec_tag = codec_tag
        self.codec_tag_string = codec_tag_string
        self.codec_time_base = codec_time_base
        self.duration = duration
        self.index = index
        self.lang = lang
        self.num_frames = num_frames
        self.sample_fmt = sample_fmt
        self.samplerate = samplerate
        self.start_time = start_time
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList(TeaModel):
    def __init__(
        self,
        audio_stream: List[ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream] = None,
    ):
        self.audio_stream = audio_stream

    def validate(self):
        if self.audio_stream:
            for k in self.audio_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStream'] = []
        if self.audio_stream is not None:
            for k in self.audio_stream:
                result['AudioStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream = []
        if m.get('AudioStream') is not None:
            for k in m.get('AudioStream'):
                temp_model = ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream()
                self.audio_stream.append(temp_model.from_map(k))
        return self


class ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream(TeaModel):
    def __init__(
        self,
        index: str = None,
        lang: str = None,
    ):
        self.index = index
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList(TeaModel):
    def __init__(
        self,
        subtitle_stream: List[ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream] = None,
    ):
        self.subtitle_stream = subtitle_stream

    def validate(self):
        if self.subtitle_stream:
            for k in self.subtitle_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubtitleStream'] = []
        if self.subtitle_stream is not None:
            for k in self.subtitle_stream:
                result['SubtitleStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle_stream = []
        if m.get('SubtitleStream') is not None:
            for k in m.get('SubtitleStream'):
                temp_model = ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream()
                self.subtitle_stream.append(temp_model.from_map(k))
        return self


class ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost(TeaModel):
    def __init__(
        self,
        avg_bitrate: str = None,
        cost_bandwidth: str = None,
        preload_time: str = None,
    ):
        self.avg_bitrate = avg_bitrate
        self.cost_bandwidth = cost_bandwidth
        self.preload_time = preload_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_bitrate is not None:
            result['AvgBitrate'] = self.avg_bitrate
        if self.cost_bandwidth is not None:
            result['CostBandwidth'] = self.cost_bandwidth
        if self.preload_time is not None:
            result['PreloadTime'] = self.preload_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgBitrate') is not None:
            self.avg_bitrate = m.get('AvgBitrate')
        if m.get('CostBandwidth') is not None:
            self.cost_bandwidth = m.get('CostBandwidth')
        if m.get('PreloadTime') is not None:
            self.preload_time = m.get('PreloadTime')
        return self


class ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bitrate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        network_cost: ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        sar: str = None,
        start_time: str = None,
        timebase: str = None,
        width: str = None,
    ):
        self.avg_fps = avg_fps
        self.bitrate = bitrate
        self.codec_long_name = codec_long_name
        self.codec_name = codec_name
        self.codec_tag = codec_tag
        self.codec_tag_string = codec_tag_string
        self.codec_time_base = codec_time_base
        self.dar = dar
        self.duration = duration
        self.fps = fps
        self.has_bframes = has_bframes
        self.height = height
        self.index = index
        self.lang = lang
        self.level = level
        self.network_cost = network_cost
        self.num_frames = num_frames
        self.pix_fmt = pix_fmt
        self.profile = profile
        self.sar = sar
        self.start_time = start_time
        self.timebase = timebase
        self.width = width

    def validate(self):
        if self.network_cost:
            self.network_cost.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['AvgFPS'] = self.avg_fps
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['HasBFrames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.network_cost is not None:
            result['NetworkCost'] = self.network_cost.to_map()
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgFPS') is not None:
            self.avg_fps = m.get('AvgFPS')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HasBFrames') is not None:
            self.has_bframes = m.get('HasBFrames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NetworkCost') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost()
            self.network_cost = temp_model.from_map(m['NetworkCost'])
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList(TeaModel):
    def __init__(
        self,
        video_stream: List[ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream] = None,
    ):
        self.video_stream = video_stream

    def validate(self):
        if self.video_stream:
            for k in self.video_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoStream'] = []
        if self.video_stream is not None:
            for k in self.video_stream:
                result['VideoStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_stream = []
        if m.get('VideoStream') is not None:
            for k in m.get('VideoStream'):
                temp_model = ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream()
                self.video_stream.append(temp_model.from_map(k))
        return self


class ListJobResponseBodyJobListJobOutputPropertiesStreams(TeaModel):
    def __init__(
        self,
        audio_stream_list: ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList = None,
        subtitle_stream_list: ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList = None,
        video_stream_list: ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList = None,
    ):
        self.audio_stream_list = audio_stream_list
        self.subtitle_stream_list = subtitle_stream_list
        self.video_stream_list = video_stream_list

    def validate(self):
        if self.audio_stream_list:
            self.audio_stream_list.validate()
        if self.subtitle_stream_list:
            self.subtitle_stream_list.validate()
        if self.video_stream_list:
            self.video_stream_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_stream_list is not None:
            result['AudioStreamList'] = self.audio_stream_list.to_map()
        if self.subtitle_stream_list is not None:
            result['SubtitleStreamList'] = self.subtitle_stream_list.to_map()
        if self.video_stream_list is not None:
            result['VideoStreamList'] = self.video_stream_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioStreamList') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList()
            self.audio_stream_list = temp_model.from_map(m['AudioStreamList'])
        if m.get('SubtitleStreamList') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList()
            self.subtitle_stream_list = temp_model.from_map(m['SubtitleStreamList'])
        if m.get('VideoStreamList') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList()
            self.video_stream_list = temp_model.from_map(m['VideoStreamList'])
        return self


class ListJobResponseBodyJobListJobOutputProperties(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_format: str = None,
        file_size: str = None,
        format: ListJobResponseBodyJobListJobOutputPropertiesFormat = None,
        fps: str = None,
        height: str = None,
        streams: ListJobResponseBodyJobListJobOutputPropertiesStreams = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.duration = duration
        self.file_format = file_format
        self.file_size = file_size
        self.format = format
        self.fps = fps
        self.height = height
        self.streams = streams
        self.width = width

    def validate(self):
        if self.format:
            self.format.validate()
        if self.streams:
            self.streams.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_format is not None:
            result['FileFormat'] = self.file_format
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.format is not None:
            result['Format'] = self.format.to_map()
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.streams is not None:
            result['Streams'] = self.streams.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileFormat') is not None:
            self.file_format = m.get('FileFormat')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('Format') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputPropertiesFormat()
            self.format = temp_model.from_map(m['Format'])
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Streams') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputPropertiesStreams()
            self.streams = temp_model.from_map(m['Streams'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle(TeaModel):
    def __init__(
        self,
        char_enc: str = None,
        font_name: str = None,
        input: ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput = None,
    ):
        self.char_enc = char_enc
        self.font_name = font_name
        self.input = input

    def validate(self):
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.char_enc is not None:
            result['CharEnc'] = self.char_enc
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.input is not None:
            result['Input'] = self.input.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CharEnc') is not None:
            self.char_enc = m.get('CharEnc')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('Input') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput()
            self.input = temp_model.from_map(m['Input'])
        return self


class ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList(TeaModel):
    def __init__(
        self,
        ext_subtitle: List[ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle] = None,
    ):
        self.ext_subtitle = ext_subtitle

    def validate(self):
        if self.ext_subtitle:
            for k in self.ext_subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ExtSubtitle'] = []
        if self.ext_subtitle is not None:
            for k in self.ext_subtitle:
                result['ExtSubtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ext_subtitle = []
        if m.get('ExtSubtitle') is not None:
            for k in m.get('ExtSubtitle'):
                temp_model = ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle()
                self.ext_subtitle.append(temp_model.from_map(k))
        return self


class ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle(TeaModel):
    def __init__(
        self,
        map: str = None,
    ):
        self.map = map

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.map is not None:
            result['Map'] = self.map
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Map') is not None:
            self.map = m.get('Map')
        return self


class ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList(TeaModel):
    def __init__(
        self,
        subtitle: List[ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle] = None,
    ):
        self.subtitle = subtitle

    def validate(self):
        if self.subtitle:
            for k in self.subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Subtitle'] = []
        if self.subtitle is not None:
            for k in self.subtitle:
                result['Subtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle = []
        if m.get('Subtitle') is not None:
            for k in m.get('Subtitle'):
                temp_model = ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle()
                self.subtitle.append(temp_model.from_map(k))
        return self


class ListJobResponseBodyJobListJobOutputSubtitleConfig(TeaModel):
    def __init__(
        self,
        ext_subtitle_list: ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList = None,
        subtitle_list: ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList = None,
    ):
        self.ext_subtitle_list = ext_subtitle_list
        self.subtitle_list = subtitle_list

    def validate(self):
        if self.ext_subtitle_list:
            self.ext_subtitle_list.validate()
        if self.subtitle_list:
            self.subtitle_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ext_subtitle_list is not None:
            result['ExtSubtitleList'] = self.ext_subtitle_list.to_map()
        if self.subtitle_list is not None:
            result['SubtitleList'] = self.subtitle_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExtSubtitleList') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList()
            self.ext_subtitle_list = temp_model.from_map(m['ExtSubtitleList'])
        if m.get('SubtitleList') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList()
            self.subtitle_list = temp_model.from_map(m['SubtitleList'])
        return self


class ListJobResponseBodyJobListJobOutputSuperReso(TeaModel):
    def __init__(
        self,
        is_half_sample: str = None,
    ):
        self.is_half_sample = is_half_sample

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_half_sample is not None:
            result['IsHalfSample'] = self.is_half_sample
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsHalfSample') is not None:
            self.is_half_sample = m.get('IsHalfSample')
        return self


class ListJobResponseBodyJobListJobOutputTailSlateListTailSlate(TeaModel):
    def __init__(
        self,
        bg_color: str = None,
        blend_duration: str = None,
        height: str = None,
        is_merge_audio: bool = None,
        start: str = None,
        tail_url: str = None,
        width: str = None,
    ):
        self.bg_color = bg_color
        self.blend_duration = blend_duration
        self.height = height
        self.is_merge_audio = is_merge_audio
        self.start = start
        self.tail_url = tail_url
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bg_color is not None:
            result['BgColor'] = self.bg_color
        if self.blend_duration is not None:
            result['BlendDuration'] = self.blend_duration
        if self.height is not None:
            result['Height'] = self.height
        if self.is_merge_audio is not None:
            result['IsMergeAudio'] = self.is_merge_audio
        if self.start is not None:
            result['Start'] = self.start
        if self.tail_url is not None:
            result['TailUrl'] = self.tail_url
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BgColor') is not None:
            self.bg_color = m.get('BgColor')
        if m.get('BlendDuration') is not None:
            self.blend_duration = m.get('BlendDuration')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('IsMergeAudio') is not None:
            self.is_merge_audio = m.get('IsMergeAudio')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('TailUrl') is not None:
            self.tail_url = m.get('TailUrl')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListJobResponseBodyJobListJobOutputTailSlateList(TeaModel):
    def __init__(
        self,
        tail_slate: List[ListJobResponseBodyJobListJobOutputTailSlateListTailSlate] = None,
    ):
        self.tail_slate = tail_slate

    def validate(self):
        if self.tail_slate:
            for k in self.tail_slate:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TailSlate'] = []
        if self.tail_slate is not None:
            for k in self.tail_slate:
                result['TailSlate'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tail_slate = []
        if m.get('TailSlate') is not None:
            for k in m.get('TailSlate'):
                temp_model = ListJobResponseBodyJobListJobOutputTailSlateListTailSlate()
                self.tail_slate.append(temp_model.from_map(k))
        return self


class ListJobResponseBodyJobListJobOutputTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        is_check_audio_bitrate: str = None,
        is_check_audio_bitrate_fail: str = None,
        is_check_reso: str = None,
        is_check_reso_fail: str = None,
        is_check_video_bitrate: str = None,
        is_check_video_bitrate_fail: str = None,
        trans_mode: str = None,
    ):
        self.adj_dar_method = adj_dar_method
        self.is_check_audio_bitrate = is_check_audio_bitrate
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        self.is_check_reso = is_check_reso
        self.is_check_reso_fail = is_check_reso_fail
        self.is_check_video_bitrate = is_check_video_bitrate
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class ListJobResponseBodyJobListJobOutputVideoBitrateBnd(TeaModel):
    def __init__(
        self,
        max: str = None,
        min: str = None,
    ):
        self.max = max
        self.min = min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        return self


class ListJobResponseBodyJobListJobOutputVideo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        bitrate_bnd: ListJobResponseBodyJobListJobOutputVideoBitrateBnd = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        degrain: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        max_fps: str = None,
        maxrate: str = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        qscale: str = None,
        reso_priority: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.bitrate_bnd = bitrate_bnd
        self.bufsize = bufsize
        self.codec = codec
        self.crf = crf
        self.crop = crop
        self.degrain = degrain
        self.fps = fps
        self.gop = gop
        self.height = height
        self.max_fps = max_fps
        self.maxrate = maxrate
        self.pad = pad
        self.pix_fmt = pix_fmt
        self.preset = preset
        self.profile = profile
        self.qscale = qscale
        self.reso_priority = reso_priority
        self.scan_mode = scan_mode
        self.width = width

    def validate(self):
        if self.bitrate_bnd:
            self.bitrate_bnd.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bitrate_bnd is not None:
            result['BitrateBnd'] = self.bitrate_bnd.to_map()
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.degrain is not None:
            result['Degrain'] = self.degrain
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.max_fps is not None:
            result['MaxFps'] = self.max_fps
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.reso_priority is not None:
            result['ResoPriority'] = self.reso_priority
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BitrateBnd') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputVideoBitrateBnd()
            self.bitrate_bnd = temp_model.from_map(m['BitrateBnd'])
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Degrain') is not None:
            self.degrain = m.get('Degrain')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MaxFps') is not None:
            self.max_fps = m.get('MaxFps')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('ResoPriority') is not None:
            self.reso_priority = m.get('ResoPriority')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        input_file: ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile = None,
        refer_pos: str = None,
        type: str = None,
        water_mark_template_id: str = None,
        width: str = None,
    ):
        self.dx = dx
        self.dy = dy
        self.height = height
        self.input_file = input_file
        self.refer_pos = refer_pos
        self.type = type
        self.water_mark_template_id = water_mark_template_id
        self.width = width

    def validate(self):
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.type is not None:
            result['Type'] = self.type
        if self.water_mark_template_id is not None:
            result['WaterMarkTemplateId'] = self.water_mark_template_id
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('InputFile') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WaterMarkTemplateId') is not None:
            self.water_mark_template_id = m.get('WaterMarkTemplateId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListJobResponseBodyJobListJobOutputWaterMarkList(TeaModel):
    def __init__(
        self,
        water_mark: List[ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark] = None,
    ):
        self.water_mark = water_mark

    def validate(self):
        if self.water_mark:
            for k in self.water_mark:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WaterMark'] = []
        if self.water_mark is not None:
            for k in self.water_mark:
                result['WaterMark'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.water_mark = []
        if m.get('WaterMark') is not None:
            for k in m.get('WaterMark'):
                temp_model = ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark()
                self.water_mark.append(temp_model.from_map(k))
        return self


class ListJobResponseBodyJobListJobOutput(TeaModel):
    def __init__(
        self,
        amix_list: ListJobResponseBodyJobListJobOutputAmixList = None,
        audio: ListJobResponseBodyJobListJobOutputAudio = None,
        audio_stream_map: str = None,
        clip: ListJobResponseBodyJobListJobOutputClip = None,
        container: ListJobResponseBodyJobListJobOutputContainer = None,
        de_watermark: str = None,
        encryption: ListJobResponseBodyJobListJobOutputEncryption = None,
        m_3u8non_standard_support: ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport = None,
        merge_config_url: str = None,
        merge_list: ListJobResponseBodyJobListJobOutputMergeList = None,
        mux_config: ListJobResponseBodyJobListJobOutputMuxConfig = None,
        opening_list: ListJobResponseBodyJobListJobOutputOpeningList = None,
        out_subtitle_list: ListJobResponseBodyJobListJobOutputOutSubtitleList = None,
        output_file: ListJobResponseBodyJobListJobOutputOutputFile = None,
        priority: str = None,
        properties: ListJobResponseBodyJobListJobOutputProperties = None,
        rotate: str = None,
        subtitle_config: ListJobResponseBodyJobListJobOutputSubtitleConfig = None,
        super_reso: ListJobResponseBodyJobListJobOutputSuperReso = None,
        tail_slate_list: ListJobResponseBodyJobListJobOutputTailSlateList = None,
        template_id: str = None,
        trans_config: ListJobResponseBodyJobListJobOutputTransConfig = None,
        user_data: str = None,
        video: ListJobResponseBodyJobListJobOutputVideo = None,
        video_stream_map: str = None,
        water_mark_config_url: str = None,
        water_mark_list: ListJobResponseBodyJobListJobOutputWaterMarkList = None,
    ):
        self.amix_list = amix_list
        self.audio = audio
        self.audio_stream_map = audio_stream_map
        self.clip = clip
        self.container = container
        self.de_watermark = de_watermark
        self.encryption = encryption
        self.m_3u8non_standard_support = m_3u8non_standard_support
        self.merge_config_url = merge_config_url
        self.merge_list = merge_list
        self.mux_config = mux_config
        self.opening_list = opening_list
        self.out_subtitle_list = out_subtitle_list
        self.output_file = output_file
        self.priority = priority
        self.properties = properties
        self.rotate = rotate
        self.subtitle_config = subtitle_config
        self.super_reso = super_reso
        self.tail_slate_list = tail_slate_list
        self.template_id = template_id
        self.trans_config = trans_config
        self.user_data = user_data
        self.video = video
        self.video_stream_map = video_stream_map
        self.water_mark_config_url = water_mark_config_url
        self.water_mark_list = water_mark_list

    def validate(self):
        if self.amix_list:
            self.amix_list.validate()
        if self.audio:
            self.audio.validate()
        if self.clip:
            self.clip.validate()
        if self.container:
            self.container.validate()
        if self.encryption:
            self.encryption.validate()
        if self.m_3u8non_standard_support:
            self.m_3u8non_standard_support.validate()
        if self.merge_list:
            self.merge_list.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.opening_list:
            self.opening_list.validate()
        if self.out_subtitle_list:
            self.out_subtitle_list.validate()
        if self.output_file:
            self.output_file.validate()
        if self.properties:
            self.properties.validate()
        if self.subtitle_config:
            self.subtitle_config.validate()
        if self.super_reso:
            self.super_reso.validate()
        if self.tail_slate_list:
            self.tail_slate_list.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()
        if self.water_mark_list:
            self.water_mark_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amix_list is not None:
            result['AmixList'] = self.amix_list.to_map()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.audio_stream_map is not None:
            result['AudioStreamMap'] = self.audio_stream_map
        if self.clip is not None:
            result['Clip'] = self.clip.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.de_watermark is not None:
            result['DeWatermark'] = self.de_watermark
        if self.encryption is not None:
            result['Encryption'] = self.encryption.to_map()
        if self.m_3u8non_standard_support is not None:
            result['M3U8NonStandardSupport'] = self.m_3u8non_standard_support.to_map()
        if self.merge_config_url is not None:
            result['MergeConfigUrl'] = self.merge_config_url
        if self.merge_list is not None:
            result['MergeList'] = self.merge_list.to_map()
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.opening_list is not None:
            result['OpeningList'] = self.opening_list.to_map()
        if self.out_subtitle_list is not None:
            result['OutSubtitleList'] = self.out_subtitle_list.to_map()
        if self.output_file is not None:
            result['OutputFile'] = self.output_file.to_map()
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.properties is not None:
            result['Properties'] = self.properties.to_map()
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.subtitle_config is not None:
            result['SubtitleConfig'] = self.subtitle_config.to_map()
        if self.super_reso is not None:
            result['SuperReso'] = self.super_reso.to_map()
        if self.tail_slate_list is not None:
            result['TailSlateList'] = self.tail_slate_list.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.video is not None:
            result['Video'] = self.video.to_map()
        if self.video_stream_map is not None:
            result['VideoStreamMap'] = self.video_stream_map
        if self.water_mark_config_url is not None:
            result['WaterMarkConfigUrl'] = self.water_mark_config_url
        if self.water_mark_list is not None:
            result['WaterMarkList'] = self.water_mark_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AmixList') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputAmixList()
            self.amix_list = temp_model.from_map(m['AmixList'])
        if m.get('Audio') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('AudioStreamMap') is not None:
            self.audio_stream_map = m.get('AudioStreamMap')
        if m.get('Clip') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputClip()
            self.clip = temp_model.from_map(m['Clip'])
        if m.get('Container') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('DeWatermark') is not None:
            self.de_watermark = m.get('DeWatermark')
        if m.get('Encryption') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputEncryption()
            self.encryption = temp_model.from_map(m['Encryption'])
        if m.get('M3U8NonStandardSupport') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport()
            self.m_3u8non_standard_support = temp_model.from_map(m['M3U8NonStandardSupport'])
        if m.get('MergeConfigUrl') is not None:
            self.merge_config_url = m.get('MergeConfigUrl')
        if m.get('MergeList') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputMergeList()
            self.merge_list = temp_model.from_map(m['MergeList'])
        if m.get('MuxConfig') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('OpeningList') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputOpeningList()
            self.opening_list = temp_model.from_map(m['OpeningList'])
        if m.get('OutSubtitleList') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputOutSubtitleList()
            self.out_subtitle_list = temp_model.from_map(m['OutSubtitleList'])
        if m.get('OutputFile') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputOutputFile()
            self.output_file = temp_model.from_map(m['OutputFile'])
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Properties') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputProperties()
            self.properties = temp_model.from_map(m['Properties'])
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('SubtitleConfig') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputSubtitleConfig()
            self.subtitle_config = temp_model.from_map(m['SubtitleConfig'])
        if m.get('SuperReso') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputSuperReso()
            self.super_reso = temp_model.from_map(m['SuperReso'])
        if m.get('TailSlateList') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputTailSlateList()
            self.tail_slate_list = temp_model.from_map(m['TailSlateList'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TransConfig') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('Video') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputVideo()
            self.video = temp_model.from_map(m['Video'])
        if m.get('VideoStreamMap') is not None:
            self.video_stream_map = m.get('VideoStreamMap')
        if m.get('WaterMarkConfigUrl') is not None:
            self.water_mark_config_url = m.get('WaterMarkConfigUrl')
        if m.get('WaterMarkList') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputWaterMarkList()
            self.water_mark_list = temp_model.from_map(m['WaterMarkList'])
        return self


class ListJobResponseBodyJobListJob(TeaModel):
    def __init__(
        self,
        code: str = None,
        creation_time: str = None,
        finish_time: str = None,
        input: ListJobResponseBodyJobListJobInput = None,
        job_id: str = None,
        mnsmessage_result: ListJobResponseBodyJobListJobMNSMessageResult = None,
        message: str = None,
        output: ListJobResponseBodyJobListJobOutput = None,
        percent: int = None,
        pipeline_id: str = None,
        state: str = None,
    ):
        self.code = code
        self.creation_time = creation_time
        self.finish_time = finish_time
        self.input = input
        self.job_id = job_id
        self.mnsmessage_result = mnsmessage_result
        self.message = message
        self.output = output
        self.percent = percent
        self.pipeline_id = pipeline_id
        self.state = state

    def validate(self):
        if self.input:
            self.input.validate()
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = ListJobResponseBodyJobListJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MNSMessageResult') is not None:
            temp_model = ListJobResponseBodyJobListJobMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Output') is not None:
            temp_model = ListJobResponseBodyJobListJobOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListJobResponseBodyJobList(TeaModel):
    def __init__(
        self,
        job: List[ListJobResponseBodyJobListJob] = None,
    ):
        self.job = job

    def validate(self):
        if self.job:
            for k in self.job:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Job'] = []
        if self.job is not None:
            for k in self.job:
                result['Job'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.job = []
        if m.get('Job') is not None:
            for k in m.get('Job'):
                temp_model = ListJobResponseBodyJobListJob()
                self.job.append(temp_model.from_map(k))
        return self


class ListJobResponseBody(TeaModel):
    def __init__(
        self,
        job_list: ListJobResponseBodyJobList = None,
        next_page_token: str = None,
        request_id: str = None,
    ):
        self.job_list = job_list
        self.next_page_token = next_page_token
        self.request_id = request_id

    def validate(self):
        if self.job_list:
            self.job_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_list is not None:
            result['JobList'] = self.job_list.to_map()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobList') is not None:
            temp_model = ListJobResponseBodyJobList()
            self.job_list = temp_model.from_map(m['JobList'])
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMediaRequest(TeaModel):
    def __init__(
        self,
        from_: str = None,
        maximum_page_size: int = None,
        next_page_token: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        to: str = None,
    ):
        self.from_ = from_
        self.maximum_page_size = maximum_page_size
        self.next_page_token = next_page_token
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        self.to = to

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.maximum_page_size is not None:
            result['MaximumPageSize'] = self.maximum_page_size
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.to is not None:
            result['To'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('MaximumPageSize') is not None:
            self.maximum_page_size = m.get('MaximumPageSize')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('To') is not None:
            self.to = m.get('To')
        return self


class ListMediaResponseBodyMediaListMediaFile(TeaModel):
    def __init__(
        self,
        state: str = None,
        url: str = None,
    ):
        self.state = state
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['State'] = self.state
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class ListMediaResponseBodyMediaListMediaRunIdList(TeaModel):
    def __init__(
        self,
        run_id: List[str] = None,
    ):
        self.run_id = run_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.run_id is not None:
            result['RunId'] = self.run_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RunId') is not None:
            self.run_id = m.get('RunId')
        return self


class ListMediaResponseBodyMediaListMediaTags(TeaModel):
    def __init__(
        self,
        tag: List[str] = None,
    ):
        self.tag = tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class ListMediaResponseBodyMediaListMedia(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        cate_id: int = None,
        censor_state: str = None,
        cover_url: str = None,
        creation_time: str = None,
        description: str = None,
        duration: str = None,
        file: ListMediaResponseBodyMediaListMediaFile = None,
        format: str = None,
        fps: str = None,
        height: str = None,
        media_id: str = None,
        publish_state: str = None,
        run_id_list: ListMediaResponseBodyMediaListMediaRunIdList = None,
        size: str = None,
        tags: ListMediaResponseBodyMediaListMediaTags = None,
        title: str = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.cate_id = cate_id
        self.censor_state = censor_state
        self.cover_url = cover_url
        self.creation_time = creation_time
        self.description = description
        self.duration = duration
        self.file = file
        self.format = format
        self.fps = fps
        self.height = height
        self.media_id = media_id
        self.publish_state = publish_state
        self.run_id_list = run_id_list
        self.size = size
        self.tags = tags
        self.title = title
        self.width = width

    def validate(self):
        if self.file:
            self.file.validate()
        if self.run_id_list:
            self.run_id_list.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.censor_state is not None:
            result['CensorState'] = self.censor_state
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.publish_state is not None:
            result['PublishState'] = self.publish_state
        if self.run_id_list is not None:
            result['RunIdList'] = self.run_id_list.to_map()
        if self.size is not None:
            result['Size'] = self.size
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.title is not None:
            result['Title'] = self.title
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CensorState') is not None:
            self.censor_state = m.get('CensorState')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('File') is not None:
            temp_model = ListMediaResponseBodyMediaListMediaFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('PublishState') is not None:
            self.publish_state = m.get('PublishState')
        if m.get('RunIdList') is not None:
            temp_model = ListMediaResponseBodyMediaListMediaRunIdList()
            self.run_id_list = temp_model.from_map(m['RunIdList'])
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Tags') is not None:
            temp_model = ListMediaResponseBodyMediaListMediaTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListMediaResponseBodyMediaList(TeaModel):
    def __init__(
        self,
        media: List[ListMediaResponseBodyMediaListMedia] = None,
    ):
        self.media = media

    def validate(self):
        if self.media:
            for k in self.media:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Media'] = []
        if self.media is not None:
            for k in self.media:
                result['Media'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.media = []
        if m.get('Media') is not None:
            for k in m.get('Media'):
                temp_model = ListMediaResponseBodyMediaListMedia()
                self.media.append(temp_model.from_map(k))
        return self


class ListMediaResponseBody(TeaModel):
    def __init__(
        self,
        media_list: ListMediaResponseBodyMediaList = None,
        next_page_token: str = None,
        request_id: str = None,
    ):
        self.media_list = media_list
        self.next_page_token = next_page_token
        self.request_id = request_id

    def validate(self):
        if self.media_list:
            self.media_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_list is not None:
            result['MediaList'] = self.media_list.to_map()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaList') is not None:
            temp_model = ListMediaResponseBodyMediaList()
            self.media_list = temp_model.from_map(m['MediaList'])
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListMediaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMediaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMediaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMediaWorkflowExecutionsRequest(TeaModel):
    def __init__(
        self,
        input_file_url: str = None,
        maximum_page_size: int = None,
        media_workflow_id: str = None,
        media_workflow_name: str = None,
        next_page_token: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        self.input_file_url = input_file_url
        self.maximum_page_size = maximum_page_size
        self.media_workflow_id = media_workflow_id
        self.media_workflow_name = media_workflow_name
        self.next_page_token = next_page_token
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_file_url is not None:
            result['InputFileURL'] = self.input_file_url
        if self.maximum_page_size is not None:
            result['MaximumPageSize'] = self.maximum_page_size
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.media_workflow_name is not None:
            result['MediaWorkflowName'] = self.media_workflow_name
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputFileURL') is not None:
            self.input_file_url = m.get('InputFileURL')
        if m.get('MaximumPageSize') is not None:
            self.maximum_page_size = m.get('MaximumPageSize')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('MediaWorkflowName') is not None:
            self.media_workflow_name = m.get('MediaWorkflowName')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity(TeaModel):
    def __init__(
        self,
        code: str = None,
        end_time: str = None,
        job_id: str = None,
        mnsmessage_result: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult = None,
        message: str = None,
        name: str = None,
        start_time: str = None,
        state: str = None,
        type: str = None,
    ):
        self.code = code
        self.end_time = end_time
        self.job_id = job_id
        self.mnsmessage_result = mnsmessage_result
        self.message = message
        self.name = name
        self.start_time = start_time
        self.state = state
        self.type = type

    def validate(self):
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.name is not None:
            result['Name'] = self.name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.state is not None:
            result['State'] = self.state
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MNSMessageResult') is not None:
            temp_model = ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList(TeaModel):
    def __init__(
        self,
        activity: List[ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity] = None,
    ):
        self.activity = activity

    def validate(self):
        if self.activity:
            for k in self.activity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Activity'] = []
        if self.activity is not None:
            for k in self.activity:
                result['Activity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.activity = []
        if m.get('Activity') is not None:
            for k in m.get('Activity'):
                temp_model = ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity()
                self.activity.append(temp_model.from_map(k))
        return self


class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput(TeaModel):
    def __init__(
        self,
        input_file: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile = None,
        user_data: str = None,
    ):
        self.input_file = input_file
        self.user_data = user_data

    def validate(self):
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputFile') is not None:
            temp_model = ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution(TeaModel):
    def __init__(
        self,
        activity_list: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList = None,
        creation_time: str = None,
        input: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput = None,
        media_id: str = None,
        media_workflow_id: str = None,
        name: str = None,
        run_id: str = None,
        state: str = None,
    ):
        self.activity_list = activity_list
        self.creation_time = creation_time
        self.input = input
        self.media_id = media_id
        self.media_workflow_id = media_workflow_id
        self.name = name
        self.run_id = run_id
        self.state = state

    def validate(self):
        if self.activity_list:
            self.activity_list.validate()
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_list is not None:
            result['ActivityList'] = self.activity_list.to_map()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.name is not None:
            result['Name'] = self.name
        if self.run_id is not None:
            result['RunId'] = self.run_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityList') is not None:
            temp_model = ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList()
            self.activity_list = temp_model.from_map(m['ActivityList'])
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Input') is not None:
            temp_model = ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RunId') is not None:
            self.run_id = m.get('RunId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList(TeaModel):
    def __init__(
        self,
        media_workflow_execution: List[ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution] = None,
    ):
        self.media_workflow_execution = media_workflow_execution

    def validate(self):
        if self.media_workflow_execution:
            for k in self.media_workflow_execution:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MediaWorkflowExecution'] = []
        if self.media_workflow_execution is not None:
            for k in self.media_workflow_execution:
                result['MediaWorkflowExecution'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.media_workflow_execution = []
        if m.get('MediaWorkflowExecution') is not None:
            for k in m.get('MediaWorkflowExecution'):
                temp_model = ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution()
                self.media_workflow_execution.append(temp_model.from_map(k))
        return self


class ListMediaWorkflowExecutionsResponseBody(TeaModel):
    def __init__(
        self,
        media_workflow_execution_list: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList = None,
        next_page_token: str = None,
        request_id: str = None,
    ):
        self.media_workflow_execution_list = media_workflow_execution_list
        self.next_page_token = next_page_token
        self.request_id = request_id

    def validate(self):
        if self.media_workflow_execution_list:
            self.media_workflow_execution_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_execution_list is not None:
            result['MediaWorkflowExecutionList'] = self.media_workflow_execution_list.to_map()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowExecutionList') is not None:
            temp_model = ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList()
            self.media_workflow_execution_list = temp_model.from_map(m['MediaWorkflowExecutionList'])
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListMediaWorkflowExecutionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMediaWorkflowExecutionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMediaWorkflowExecutionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryAnalysisJobListRequest(TeaModel):
    def __init__(
        self,
        analysis_job_ids: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.analysis_job_ids = analysis_job_ids
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis_job_ids is not None:
            result['AnalysisJobIds'] = self.analysis_job_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnalysisJobIds') is not None:
            self.analysis_job_ids = m.get('AnalysisJobIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop(TeaModel):
    def __init__(
        self,
        height: str = None,
        left: str = None,
        mode: str = None,
        top: str = None,
        width: str = None,
    ):
        self.height = height
        self.left = left
        self.mode = mode
        self.top = top
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.left is not None:
            result['Left'] = self.left
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.top is not None:
            result['Top'] = self.top
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Left') is not None:
            self.left = m.get('Left')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('Top') is not None:
            self.top = m.get('Top')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl(TeaModel):
    def __init__(
        self,
        crop: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop = None,
        deinterlace: str = None,
    ):
        self.crop = crop
        self.deinterlace = deinterlace

    def validate(self):
        if self.crop:
            self.crop.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.crop is not None:
            result['Crop'] = self.crop.to_map()
        if self.deinterlace is not None:
            result['Deinterlace'] = self.deinterlace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Crop') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop()
            self.crop = temp_model.from_map(m['Crop'])
        if m.get('Deinterlace') is not None:
            self.deinterlace = m.get('Deinterlace')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl(TeaModel):
    def __init__(
        self,
        method_streaming: str = None,
        rate_quality: str = None,
    ):
        self.method_streaming = method_streaming
        self.rate_quality = rate_quality

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.method_streaming is not None:
            result['MethodStreaming'] = self.method_streaming
        if self.rate_quality is not None:
            result['RateQuality'] = self.rate_quality
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MethodStreaming') is not None:
            self.method_streaming = m.get('MethodStreaming')
        if m.get('RateQuality') is not None:
            self.rate_quality = m.get('RateQuality')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig(TeaModel):
    def __init__(
        self,
        properties_control: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl = None,
        quality_control: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl = None,
    ):
        self.properties_control = properties_control
        self.quality_control = quality_control

    def validate(self):
        if self.properties_control:
            self.properties_control.validate()
        if self.quality_control:
            self.quality_control.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.properties_control is not None:
            result['PropertiesControl'] = self.properties_control.to_map()
        if self.quality_control is not None:
            result['QualityControl'] = self.quality_control.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PropertiesControl') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl()
            self.properties_control = temp_model.from_map(m['PropertiesControl'])
        if m.get('QualityControl') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl()
            self.quality_control = temp_model.from_map(m['QualityControl'])
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        qscale: str = None,
        samplerate: str = None,
    ):
        self.bitrate = bitrate
        self.channels = channels
        self.codec = codec
        self.profile = profile
        self.qscale = qscale
        self.samplerate = samplerate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif(TeaModel):
    def __init__(
        self,
        final_delay: str = None,
        loop: str = None,
    ):
        self.final_delay = final_delay
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.final_delay is not None:
            result['FinalDelay'] = self.final_delay
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FinalDelay') is not None:
            self.final_delay = m.get('FinalDelay')
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
    ):
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig(TeaModel):
    def __init__(
        self,
        gif: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif = None,
        segment: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment = None,
    ):
        self.gif = gif
        self.segment = segment

    def validate(self):
        if self.gif:
            self.gif.validate()
        if self.segment:
            self.segment.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gif is not None:
            result['Gif'] = self.gif.to_map()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gif') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif()
            self.gif = temp_model.from_map(m['Gif'])
        if m.get('Segment') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig(TeaModel):
    def __init__(
        self,
        trans_mode: str = None,
    ):
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd(TeaModel):
    def __init__(
        self,
        max: str = None,
        min: str = None,
    ):
        self.max = max
        self.min = min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        bitrate_bnd: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        degrain: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        maxrate: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        qscale: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.bitrate_bnd = bitrate_bnd
        self.bufsize = bufsize
        self.codec = codec
        self.crf = crf
        self.degrain = degrain
        self.fps = fps
        self.gop = gop
        self.height = height
        self.maxrate = maxrate
        self.pix_fmt = pix_fmt
        self.preset = preset
        self.profile = profile
        self.qscale = qscale
        self.scan_mode = scan_mode
        self.width = width

    def validate(self):
        if self.bitrate_bnd:
            self.bitrate_bnd.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bitrate_bnd is not None:
            result['BitrateBnd'] = self.bitrate_bnd.to_map()
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.degrain is not None:
            result['Degrain'] = self.degrain
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BitrateBnd') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd()
            self.bitrate_bnd = temp_model.from_map(m['BitrateBnd'])
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Degrain') is not None:
            self.degrain = m.get('Degrain')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate(TeaModel):
    def __init__(
        self,
        audio: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio = None,
        container: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer = None,
        id: str = None,
        mux_config: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig = None,
        name: str = None,
        state: str = None,
        trans_config: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig = None,
        video: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo = None,
    ):
        self.audio = audio
        self.container = container
        self.id = id
        self.mux_config = mux_config
        self.name = name
        self.state = state
        self.trans_config = trans_config
        self.video = video

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MuxConfig') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TransConfig') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('Video') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList(TeaModel):
    def __init__(
        self,
        template: List[QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate] = None,
    ):
        self.template = template

    def validate(self):
        if self.template:
            for k in self.template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Template'] = []
        if self.template is not None:
            for k in self.template:
                result['Template'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.template = []
        if m.get('Template') is not None:
            for k in m.get('Template'):
                temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate()
                self.template.append(temp_model.from_map(k))
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob(TeaModel):
    def __init__(
        self,
        analysis_config: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig = None,
        code: str = None,
        creation_time: str = None,
        id: str = None,
        input_file: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile = None,
        mnsmessage_result: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult = None,
        message: str = None,
        percent: int = None,
        pipeline_id: str = None,
        priority: str = None,
        state: str = None,
        template_list: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList = None,
        user_data: str = None,
    ):
        self.analysis_config = analysis_config
        self.code = code
        self.creation_time = creation_time
        self.id = id
        self.input_file = input_file
        self.mnsmessage_result = mnsmessage_result
        self.message = message
        self.percent = percent
        self.pipeline_id = pipeline_id
        self.priority = priority
        self.state = state
        self.template_list = template_list
        self.user_data = user_data

    def validate(self):
        if self.analysis_config:
            self.analysis_config.validate()
        if self.input_file:
            self.input_file.validate()
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()
        if self.template_list:
            self.template_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis_config is not None:
            result['AnalysisConfig'] = self.analysis_config.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.id is not None:
            result['Id'] = self.id
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.state is not None:
            result['State'] = self.state
        if self.template_list is not None:
            result['TemplateList'] = self.template_list.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnalysisConfig') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig()
            self.analysis_config = temp_model.from_map(m['AnalysisConfig'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InputFile') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('MNSMessageResult') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TemplateList') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList()
            self.template_list = temp_model.from_map(m['TemplateList'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobList(TeaModel):
    def __init__(
        self,
        analysis_job: List[QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob] = None,
    ):
        self.analysis_job = analysis_job

    def validate(self):
        if self.analysis_job:
            for k in self.analysis_job:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AnalysisJob'] = []
        if self.analysis_job is not None:
            for k in self.analysis_job:
                result['AnalysisJob'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.analysis_job = []
        if m.get('AnalysisJob') is not None:
            for k in m.get('AnalysisJob'):
                temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob()
                self.analysis_job.append(temp_model.from_map(k))
        return self


class QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds(TeaModel):
    def __init__(
        self,
        string: List[str] = None,
    ):
        self.string = string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class QueryAnalysisJobListResponseBody(TeaModel):
    def __init__(
        self,
        analysis_job_list: QueryAnalysisJobListResponseBodyAnalysisJobList = None,
        non_exist_analysis_job_ids: QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds = None,
        request_id: str = None,
    ):
        self.analysis_job_list = analysis_job_list
        self.non_exist_analysis_job_ids = non_exist_analysis_job_ids
        self.request_id = request_id

    def validate(self):
        if self.analysis_job_list:
            self.analysis_job_list.validate()
        if self.non_exist_analysis_job_ids:
            self.non_exist_analysis_job_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis_job_list is not None:
            result['AnalysisJobList'] = self.analysis_job_list.to_map()
        if self.non_exist_analysis_job_ids is not None:
            result['NonExistAnalysisJobIds'] = self.non_exist_analysis_job_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnalysisJobList') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobList()
            self.analysis_job_list = temp_model.from_map(m['AnalysisJobList'])
        if m.get('NonExistAnalysisJobIds') is not None:
            temp_model = QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds()
            self.non_exist_analysis_job_ids = temp_model.from_map(m['NonExistAnalysisJobIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryAnalysisJobListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryAnalysisJobListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryAnalysisJobListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryEditingJobListRequest(TeaModel):
    def __init__(
        self,
        job_ids: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        self.job_ids = job_ids
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_ids is not None:
            result['JobIds'] = self.job_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobIds') is not None:
            self.job_ids = m.get('JobIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigAudioVolume(TeaModel):
    def __init__(
        self,
        level: str = None,
        method: str = None,
    ):
        self.level = level
        self.method = method

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.level is not None:
            result['Level'] = self.level
        if self.method is not None:
            result['Method'] = self.method
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        qscale: str = None,
        samplerate: str = None,
        volume: QueryEditingJobListResponseBodyJobListJobEditingConfigAudioVolume = None,
    ):
        self.bitrate = bitrate
        self.channels = channels
        self.codec = codec
        self.profile = profile
        self.qscale = qscale
        self.samplerate = samplerate
        self.volume = volume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigClipTimeSpan(TeaModel):
    def __init__(
        self,
        duration: str = None,
        seek: str = None,
    ):
        self.duration = duration
        self.seek = seek

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.seek is not None:
            result['Seek'] = self.seek
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Seek') is not None:
            self.seek = m.get('Seek')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigClip(TeaModel):
    def __init__(
        self,
        time_span: QueryEditingJobListResponseBodyJobListJobEditingConfigClipTimeSpan = None,
    ):
        self.time_span = time_span

    def validate(self):
        if self.time_span:
            self.time_span.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time_span is not None:
            result['TimeSpan'] = self.time_span.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeSpan') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigClipTimeSpan()
            self.time_span = temp_model.from_map(m['TimeSpan'])
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMarkInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMark(TeaModel):
    def __init__(
        self,
        alpha: str = None,
        input_file: QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMarkInputFile = None,
        type: str = None,
    ):
        self.alpha = alpha
        self.input_file = input_file
        self.type = type

    def validate(self):
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('InputFile') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMarkInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect(TeaModel):
    def __init__(
        self,
        effect: str = None,
        effect_config: str = None,
    ):
        self.effect = effect
        self.effect_config = effect_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.effect is not None:
            result['Effect'] = self.effect
        if self.effect_config is not None:
            result['EffectConfig'] = self.effect_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Effect') is not None:
            self.effect = m.get('Effect')
        if m.get('EffectConfig') is not None:
            self.effect_config = m.get('EffectConfig')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffects(TeaModel):
    def __init__(
        self,
        effect: List[QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect] = None,
    ):
        self.effect = effect

    def validate(self):
        if self.effect:
            for k in self.effect:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Effect'] = []
        if self.effect is not None:
            for k in self.effect:
                result['Effect'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.effect = []
        if m.get('Effect') is not None:
            for k in m.get('Effect'):
                temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect()
                self.effect.append(temp_model.from_map(k))
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip(TeaModel):
    def __init__(
        self,
        effects: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffects = None,
        id: str = None,
        in_: str = None,
        out: str = None,
        source_id: str = None,
        source_strm_map: str = None,
        source_type: str = None,
        type: str = None,
    ):
        self.effects = effects
        self.id = id
        self.in_ = in_
        self.out = out
        self.source_id = source_id
        self.source_strm_map = source_strm_map
        self.source_type = source_type
        self.type = type

    def validate(self):
        if self.effects:
            self.effects.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.effects is not None:
            result['Effects'] = self.effects.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.in_ is not None:
            result['In'] = self.in_
        if self.out is not None:
            result['Out'] = self.out
        if self.source_id is not None:
            result['SourceID'] = self.source_id
        if self.source_strm_map is not None:
            result['SourceStrmMap'] = self.source_strm_map
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Effects') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffects()
            self.effects = temp_model.from_map(m['Effects'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('In') is not None:
            self.in_ = m.get('In')
        if m.get('Out') is not None:
            self.out = m.get('Out')
        if m.get('SourceID') is not None:
            self.source_id = m.get('SourceID')
        if m.get('SourceStrmMap') is not None:
            self.source_strm_map = m.get('SourceStrmMap')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipList(TeaModel):
    def __init__(
        self,
        clip: List[QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip] = None,
    ):
        self.clip = clip

    def validate(self):
        if self.clip:
            for k in self.clip:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Clip'] = []
        if self.clip is not None:
            for k in self.clip:
                result['Clip'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.clip = []
        if m.get('Clip') is not None:
            for k in m.get('Clip'):
                temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip()
                self.clip.append(temp_model.from_map(k))
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio(TeaModel):
    def __init__(
        self,
        channel_layout: str = None,
        channels: str = None,
        samplerate: str = None,
    ):
        self.channel_layout = channel_layout
        self.channels = channels
        self.samplerate = samplerate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo(TeaModel):
    def __init__(
        self,
        bg_color: str = None,
        fps: str = None,
        height: str = None,
        is_gpu_data: str = None,
        is_one_track_data: str = None,
        reclose_prec: str = None,
        render_ratio: str = None,
        width: str = None,
    ):
        self.bg_color = bg_color
        self.fps = fps
        self.height = height
        self.is_gpu_data = is_gpu_data
        self.is_one_track_data = is_one_track_data
        self.reclose_prec = reclose_prec
        self.render_ratio = render_ratio
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bg_color is not None:
            result['BgColor'] = self.bg_color
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.is_gpu_data is not None:
            result['IsGpuData'] = self.is_gpu_data
        if self.is_one_track_data is not None:
            result['IsOneTrackData'] = self.is_one_track_data
        if self.reclose_prec is not None:
            result['ReclosePrec'] = self.reclose_prec
        if self.render_ratio is not None:
            result['RenderRatio'] = self.render_ratio
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BgColor') is not None:
            self.bg_color = m.get('BgColor')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('IsGpuData') is not None:
            self.is_gpu_data = m.get('IsGpuData')
        if m.get('IsOneTrackData') is not None:
            self.is_one_track_data = m.get('IsOneTrackData')
        if m.get('ReclosePrec') is not None:
            self.reclose_prec = m.get('ReclosePrec')
        if m.get('RenderRatio') is not None:
            self.render_ratio = m.get('RenderRatio')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfig(TeaModel):
    def __init__(
        self,
        timeline_config_audio: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio = None,
        timeline_config_video: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo = None,
    ):
        self.timeline_config_audio = timeline_config_audio
        self.timeline_config_video = timeline_config_video

    def validate(self):
        if self.timeline_config_audio:
            self.timeline_config_audio.validate()
        if self.timeline_config_video:
            self.timeline_config_video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.timeline_config_audio is not None:
            result['TimelineConfigAudio'] = self.timeline_config_audio.to_map()
        if self.timeline_config_video is not None:
            result['TimelineConfigVideo'] = self.timeline_config_video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimelineConfigAudio') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio()
            self.timeline_config_audio = temp_model.from_map(m['TimelineConfigAudio'])
        if m.get('TimelineConfigVideo') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo()
            self.timeline_config_video = temp_model.from_map(m['TimelineConfigVideo'])
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo(TeaModel):
    def __init__(
        self,
        l: str = None,
        t: str = None,
    ):
        self.l = l
        self.t = t

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.l is not None:
            result['L'] = self.l
        if self.t is not None:
            result['T'] = self.t
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('L') is not None:
            self.l = m.get('L')
        if m.get('T') is not None:
            self.t = m.get('T')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig(TeaModel):
    def __init__(
        self,
        clips_config_video: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo = None,
    ):
        self.clips_config_video = clips_config_video

    def validate(self):
        if self.clips_config_video:
            self.clips_config_video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clips_config_video is not None:
            result['ClipsConfigVideo'] = self.clips_config_video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClipsConfigVideo') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo()
            self.clips_config_video = temp_model.from_map(m['ClipsConfigVideo'])
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip(TeaModel):
    def __init__(
        self,
        clips_config: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig = None,
        in_: str = None,
        out: str = None,
        clip_id: str = None,
    ):
        self.clips_config = clips_config
        self.in_ = in_
        self.out = out
        self.clip_id = clip_id

    def validate(self):
        if self.clips_config:
            self.clips_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clips_config is not None:
            result['ClipsConfig'] = self.clips_config.to_map()
        if self.in_ is not None:
            result['In'] = self.in_
        if self.out is not None:
            result['Out'] = self.out
        if self.clip_id is not None:
            result['clipID'] = self.clip_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClipsConfig') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig()
            self.clips_config = temp_model.from_map(m['ClipsConfig'])
        if m.get('In') is not None:
            self.in_ = m.get('In')
        if m.get('Out') is not None:
            self.out = m.get('Out')
        if m.get('clipID') is not None:
            self.clip_id = m.get('clipID')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClips(TeaModel):
    def __init__(
        self,
        clip: List[QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip] = None,
    ):
        self.clip = clip

    def validate(self):
        if self.clip:
            for k in self.clip:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Clip'] = []
        if self.clip is not None:
            for k in self.clip:
                result['Clip'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.clip = []
        if m.get('Clip') is not None:
            for k in m.get('Clip'):
                temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip()
                self.clip.append(temp_model.from_map(k))
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack(TeaModel):
    def __init__(
        self,
        clips: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClips = None,
        id: str = None,
        order: str = None,
        type: str = None,
    ):
        self.clips = clips
        self.id = id
        self.order = order
        self.type = type

    def validate(self):
        if self.clips:
            self.clips.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clips is not None:
            result['Clips'] = self.clips.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.order is not None:
            result['Order'] = self.order
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Clips') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClips()
            self.clips = temp_model.from_map(m['Clips'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackList(TeaModel):
    def __init__(
        self,
        track: List[QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack] = None,
    ):
        self.track = track

    def validate(self):
        if self.track:
            for k in self.track:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Track'] = []
        if self.track is not None:
            for k in self.track:
                result['Track'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.track = []
        if m.get('Track') is not None:
            for k in m.get('Track'):
                temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack()
                self.track.append(temp_model.from_map(k))
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimeline(TeaModel):
    def __init__(
        self,
        timeline_config: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfig = None,
        track_list: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackList = None,
    ):
        self.timeline_config = timeline_config
        self.track_list = track_list

    def validate(self):
        if self.timeline_config:
            self.timeline_config.validate()
        if self.track_list:
            self.track_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.timeline_config is not None:
            result['TimelineConfig'] = self.timeline_config.to_map()
        if self.track_list is not None:
            result['TrackList'] = self.track_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimelineConfig') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfig()
            self.timeline_config = temp_model.from_map(m['TimelineConfig'])
        if m.get('TrackList') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackList()
            self.track_list = temp_model.from_map(m['TrackList'])
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigEditing(TeaModel):
    def __init__(
        self,
        clip_list: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipList = None,
        timeline: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimeline = None,
    ):
        self.clip_list = clip_list
        self.timeline = timeline

    def validate(self):
        if self.clip_list:
            self.clip_list.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clip_list is not None:
            result['ClipList'] = self.clip_list.to_map()
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClipList') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipList()
            self.clip_list = temp_model.from_map(m['ClipList'])
        if m.get('Timeline') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigEncryption(TeaModel):
    def __init__(
        self,
        id: str = None,
        key: str = None,
        key_type: str = None,
        key_uri: str = None,
        skip_cnt: str = None,
        type: str = None,
    ):
        self.id = id
        self.key = key
        self.key_type = key_type
        self.key_uri = key_uri
        self.skip_cnt = skip_cnt
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.key is not None:
            result['Key'] = self.key
        if self.key_type is not None:
            result['KeyType'] = self.key_type
        if self.key_uri is not None:
            result['KeyUri'] = self.key_uri
        if self.skip_cnt is not None:
            result['SkipCnt'] = self.skip_cnt
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('KeyType') is not None:
            self.key_type = m.get('KeyType')
        if m.get('KeyUri') is not None:
            self.key_uri = m.get('KeyUri')
        if m.get('SkipCnt') is not None:
            self.skip_cnt = m.get('SkipCnt')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupportTS(TeaModel):
    def __init__(
        self,
        md_5support: bool = None,
        size_support: bool = None,
    ):
        self.md_5support = md_5support
        self.size_support = size_support

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.md_5support is not None:
            result['Md5Support'] = self.md_5support
        if self.size_support is not None:
            result['SizeSupport'] = self.size_support
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Md5Support') is not None:
            self.md_5support = m.get('Md5Support')
        if m.get('SizeSupport') is not None:
            self.size_support = m.get('SizeSupport')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupport(TeaModel):
    def __init__(
        self,
        ts: QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupportTS = None,
    ):
        self.ts = ts

    def validate(self):
        if self.ts:
            self.ts.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ts is not None:
            result['TS'] = self.ts.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TS') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupportTS()
            self.ts = temp_model.from_map(m['TS'])
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge(TeaModel):
    def __init__(
        self,
        duration: str = None,
        merge_url: str = None,
        role_arn: str = None,
        start: str = None,
    ):
        self.duration = duration
        self.merge_url = merge_url
        self.role_arn = role_arn
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.merge_url is not None:
            result['MergeURL'] = self.merge_url
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('MergeURL') is not None:
            self.merge_url = m.get('MergeURL')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigMergeList(TeaModel):
    def __init__(
        self,
        merge: List[QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge] = None,
    ):
        self.merge = merge

    def validate(self):
        if self.merge:
            for k in self.merge:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Merge'] = []
        if self.merge is not None:
            for k in self.merge:
                result['Merge'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.merge = []
        if m.get('Merge') is not None:
            for k in m.get('Merge'):
                temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge()
                self.merge.append(temp_model.from_map(k))
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigGif(TeaModel):
    def __init__(
        self,
        dither_mode: str = None,
        final_delay: str = None,
        is_custom_palette: str = None,
        loop: str = None,
    ):
        self.dither_mode = dither_mode
        self.final_delay = final_delay
        self.is_custom_palette = is_custom_palette
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dither_mode is not None:
            result['DitherMode'] = self.dither_mode
        if self.final_delay is not None:
            result['FinalDelay'] = self.final_delay
        if self.is_custom_palette is not None:
            result['IsCustomPalette'] = self.is_custom_palette
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DitherMode') is not None:
            self.dither_mode = m.get('DitherMode')
        if m.get('FinalDelay') is not None:
            self.final_delay = m.get('FinalDelay')
        if m.get('IsCustomPalette') is not None:
            self.is_custom_palette = m.get('IsCustomPalette')
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
    ):
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfig(TeaModel):
    def __init__(
        self,
        gif: QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigGif = None,
        segment: QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigSegment = None,
    ):
        self.gif = gif
        self.segment = segment

    def validate(self):
        if self.gif:
            self.gif.validate()
        if self.segment:
            self.segment.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gif is not None:
            result['Gif'] = self.gif.to_map()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gif') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigGif()
            self.gif = temp_model.from_map(m['Gif'])
        if m.get('Segment') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigOutputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesFormat(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        format_long_name: str = None,
        format_name: str = None,
        num_programs: str = None,
        num_streams: str = None,
        size: str = None,
        start_time: str = None,
    ):
        self.bitrate = bitrate
        self.duration = duration
        self.format_long_name = format_long_name
        self.format_name = format_name
        self.num_programs = num_programs
        self.num_streams = num_streams
        self.size = size
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.format_long_name is not None:
            result['FormatLongName'] = self.format_long_name
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.num_programs is not None:
            result['NumPrograms'] = self.num_programs
        if self.num_streams is not None:
            result['NumStreams'] = self.num_streams
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FormatLongName') is not None:
            self.format_long_name = m.get('FormatLongName')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('NumPrograms') is not None:
            self.num_programs = m.get('NumPrograms')
        if m.get('NumStreams') is not None:
            self.num_streams = m.get('NumStreams')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        num_frames: str = None,
        sample_fmt: str = None,
        samplerate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        self.bitrate = bitrate
        self.channel_layout = channel_layout
        self.channels = channels
        self.codec_long_name = codec_long_name
        self.codec_name = codec_name
        self.codec_tag = codec_tag
        self.codec_tag_string = codec_tag_string
        self.codec_time_base = codec_time_base
        self.duration = duration
        self.index = index
        self.lang = lang
        self.num_frames = num_frames
        self.sample_fmt = sample_fmt
        self.samplerate = samplerate
        self.start_time = start_time
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamList(TeaModel):
    def __init__(
        self,
        audio_stream: List[QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream] = None,
    ):
        self.audio_stream = audio_stream

    def validate(self):
        if self.audio_stream:
            for k in self.audio_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStream'] = []
        if self.audio_stream is not None:
            for k in self.audio_stream:
                result['AudioStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream = []
        if m.get('AudioStream') is not None:
            for k in m.get('AudioStream'):
                temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream()
                self.audio_stream.append(temp_model.from_map(k))
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream(TeaModel):
    def __init__(
        self,
        index: str = None,
        lang: str = None,
    ):
        self.index = index
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamList(TeaModel):
    def __init__(
        self,
        subtitle_stream: List[QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream] = None,
    ):
        self.subtitle_stream = subtitle_stream

    def validate(self):
        if self.subtitle_stream:
            for k in self.subtitle_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubtitleStream'] = []
        if self.subtitle_stream is not None:
            for k in self.subtitle_stream:
                result['SubtitleStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle_stream = []
        if m.get('SubtitleStream') is not None:
            for k in m.get('SubtitleStream'):
                temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream()
                self.subtitle_stream.append(temp_model.from_map(k))
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost(TeaModel):
    def __init__(
        self,
        avg_bitrate: str = None,
        cost_bandwidth: str = None,
        preload_time: str = None,
    ):
        self.avg_bitrate = avg_bitrate
        self.cost_bandwidth = cost_bandwidth
        self.preload_time = preload_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_bitrate is not None:
            result['AvgBitrate'] = self.avg_bitrate
        if self.cost_bandwidth is not None:
            result['CostBandwidth'] = self.cost_bandwidth
        if self.preload_time is not None:
            result['PreloadTime'] = self.preload_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgBitrate') is not None:
            self.avg_bitrate = m.get('AvgBitrate')
        if m.get('CostBandwidth') is not None:
            self.cost_bandwidth = m.get('CostBandwidth')
        if m.get('PreloadTime') is not None:
            self.preload_time = m.get('PreloadTime')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bitrate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        network_cost: QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        sar: str = None,
        start_time: str = None,
        timebase: str = None,
        width: str = None,
    ):
        self.avg_fps = avg_fps
        self.bitrate = bitrate
        self.codec_long_name = codec_long_name
        self.codec_name = codec_name
        self.codec_tag = codec_tag
        self.codec_tag_string = codec_tag_string
        self.codec_time_base = codec_time_base
        self.dar = dar
        self.duration = duration
        self.fps = fps
        self.has_bframes = has_bframes
        self.height = height
        self.index = index
        self.lang = lang
        self.level = level
        self.network_cost = network_cost
        self.num_frames = num_frames
        self.pix_fmt = pix_fmt
        self.profile = profile
        self.sar = sar
        self.start_time = start_time
        self.timebase = timebase
        self.width = width

    def validate(self):
        if self.network_cost:
            self.network_cost.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['AvgFPS'] = self.avg_fps
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['HasBFrames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.network_cost is not None:
            result['NetworkCost'] = self.network_cost.to_map()
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgFPS') is not None:
            self.avg_fps = m.get('AvgFPS')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HasBFrames') is not None:
            self.has_bframes = m.get('HasBFrames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NetworkCost') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost()
            self.network_cost = temp_model.from_map(m['NetworkCost'])
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamList(TeaModel):
    def __init__(
        self,
        video_stream: List[QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream] = None,
    ):
        self.video_stream = video_stream

    def validate(self):
        if self.video_stream:
            for k in self.video_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoStream'] = []
        if self.video_stream is not None:
            for k in self.video_stream:
                result['VideoStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_stream = []
        if m.get('VideoStream') is not None:
            for k in m.get('VideoStream'):
                temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream()
                self.video_stream.append(temp_model.from_map(k))
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreams(TeaModel):
    def __init__(
        self,
        audio_stream_list: QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamList = None,
        subtitle_stream_list: QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamList = None,
        video_stream_list: QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamList = None,
    ):
        self.audio_stream_list = audio_stream_list
        self.subtitle_stream_list = subtitle_stream_list
        self.video_stream_list = video_stream_list

    def validate(self):
        if self.audio_stream_list:
            self.audio_stream_list.validate()
        if self.subtitle_stream_list:
            self.subtitle_stream_list.validate()
        if self.video_stream_list:
            self.video_stream_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_stream_list is not None:
            result['AudioStreamList'] = self.audio_stream_list.to_map()
        if self.subtitle_stream_list is not None:
            result['SubtitleStreamList'] = self.subtitle_stream_list.to_map()
        if self.video_stream_list is not None:
            result['VideoStreamList'] = self.video_stream_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioStreamList') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamList()
            self.audio_stream_list = temp_model.from_map(m['AudioStreamList'])
        if m.get('SubtitleStreamList') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamList()
            self.subtitle_stream_list = temp_model.from_map(m['SubtitleStreamList'])
        if m.get('VideoStreamList') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamList()
            self.video_stream_list = temp_model.from_map(m['VideoStreamList'])
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigProperties(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_format: str = None,
        file_size: str = None,
        format: QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesFormat = None,
        fps: str = None,
        height: str = None,
        streams: QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreams = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.duration = duration
        self.file_format = file_format
        self.file_size = file_size
        self.format = format
        self.fps = fps
        self.height = height
        self.streams = streams
        self.width = width

    def validate(self):
        if self.format:
            self.format.validate()
        if self.streams:
            self.streams.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_format is not None:
            result['FileFormat'] = self.file_format
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.format is not None:
            result['Format'] = self.format.to_map()
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.streams is not None:
            result['Streams'] = self.streams.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileFormat') is not None:
            self.file_format = m.get('FileFormat')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('Format') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesFormat()
            self.format = temp_model.from_map(m['Format'])
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Streams') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreams()
            self.streams = temp_model.from_map(m['Streams'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle(TeaModel):
    def __init__(
        self,
        char_enc: str = None,
        font_name: str = None,
        input: QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput = None,
    ):
        self.char_enc = char_enc
        self.font_name = font_name
        self.input = input

    def validate(self):
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.char_enc is not None:
            result['CharEnc'] = self.char_enc
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.input is not None:
            result['Input'] = self.input.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CharEnc') is not None:
            self.char_enc = m.get('CharEnc')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('Input') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput()
            self.input = temp_model.from_map(m['Input'])
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleList(TeaModel):
    def __init__(
        self,
        ext_subtitle: List[QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle] = None,
    ):
        self.ext_subtitle = ext_subtitle

    def validate(self):
        if self.ext_subtitle:
            for k in self.ext_subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ExtSubtitle'] = []
        if self.ext_subtitle is not None:
            for k in self.ext_subtitle:
                result['ExtSubtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ext_subtitle = []
        if m.get('ExtSubtitle') is not None:
            for k in m.get('ExtSubtitle'):
                temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle()
                self.ext_subtitle.append(temp_model.from_map(k))
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle(TeaModel):
    def __init__(
        self,
        map: str = None,
    ):
        self.map = map

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.map is not None:
            result['Map'] = self.map
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Map') is not None:
            self.map = m.get('Map')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleList(TeaModel):
    def __init__(
        self,
        subtitle: List[QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle] = None,
    ):
        self.subtitle = subtitle

    def validate(self):
        if self.subtitle:
            for k in self.subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Subtitle'] = []
        if self.subtitle is not None:
            for k in self.subtitle:
                result['Subtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle = []
        if m.get('Subtitle') is not None:
            for k in m.get('Subtitle'):
                temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle()
                self.subtitle.append(temp_model.from_map(k))
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfig(TeaModel):
    def __init__(
        self,
        ext_subtitle_list: QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleList = None,
        subtitle_list: QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleList = None,
    ):
        self.ext_subtitle_list = ext_subtitle_list
        self.subtitle_list = subtitle_list

    def validate(self):
        if self.ext_subtitle_list:
            self.ext_subtitle_list.validate()
        if self.subtitle_list:
            self.subtitle_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ext_subtitle_list is not None:
            result['ExtSubtitleList'] = self.ext_subtitle_list.to_map()
        if self.subtitle_list is not None:
            result['SubtitleList'] = self.subtitle_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExtSubtitleList') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleList()
            self.ext_subtitle_list = temp_model.from_map(m['ExtSubtitleList'])
        if m.get('SubtitleList') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleList()
            self.subtitle_list = temp_model.from_map(m['SubtitleList'])
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigSuperReso(TeaModel):
    def __init__(
        self,
        is_half_sample: str = None,
    ):
        self.is_half_sample = is_half_sample

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_half_sample is not None:
            result['IsHalfSample'] = self.is_half_sample
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsHalfSample') is not None:
            self.is_half_sample = m.get('IsHalfSample')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        duration: str = None,
        is_check_audio_bitrate: str = None,
        is_check_audio_bitrate_fail: str = None,
        is_check_reso: str = None,
        is_check_reso_fail: str = None,
        is_check_video_bitrate: str = None,
        is_check_video_bitrate_fail: str = None,
        trans_mode: str = None,
    ):
        self.adj_dar_method = adj_dar_method
        self.duration = duration
        self.is_check_audio_bitrate = is_check_audio_bitrate
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        self.is_check_reso = is_check_reso
        self.is_check_reso_fail = is_check_reso_fail
        self.is_check_video_bitrate = is_check_video_bitrate
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigVideoBitrateBnd(TeaModel):
    def __init__(
        self,
        max: str = None,
        min: str = None,
    ):
        self.max = max
        self.min = min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigVideo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        bitrate_bnd: QueryEditingJobListResponseBodyJobListJobEditingConfigVideoBitrateBnd = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        degrain: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        max_fps: str = None,
        maxrate: str = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        qscale: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.bitrate_bnd = bitrate_bnd
        self.bufsize = bufsize
        self.codec = codec
        self.crf = crf
        self.crop = crop
        self.degrain = degrain
        self.fps = fps
        self.gop = gop
        self.height = height
        self.max_fps = max_fps
        self.maxrate = maxrate
        self.pad = pad
        self.pix_fmt = pix_fmt
        self.preset = preset
        self.profile = profile
        self.qscale = qscale
        self.scan_mode = scan_mode
        self.width = width

    def validate(self):
        if self.bitrate_bnd:
            self.bitrate_bnd.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bitrate_bnd is not None:
            result['BitrateBnd'] = self.bitrate_bnd.to_map()
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.degrain is not None:
            result['Degrain'] = self.degrain
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.max_fps is not None:
            result['MaxFps'] = self.max_fps
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BitrateBnd') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigVideoBitrateBnd()
            self.bitrate_bnd = temp_model.from_map(m['BitrateBnd'])
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Degrain') is not None:
            self.degrain = m.get('Degrain')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MaxFps') is not None:
            self.max_fps = m.get('MaxFps')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMarkInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        input_file: QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMarkInputFile = None,
        refer_pos: str = None,
        type: str = None,
        water_mark_template_id: str = None,
        width: str = None,
    ):
        self.dx = dx
        self.dy = dy
        self.height = height
        self.input_file = input_file
        self.refer_pos = refer_pos
        self.type = type
        self.water_mark_template_id = water_mark_template_id
        self.width = width

    def validate(self):
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.type is not None:
            result['Type'] = self.type
        if self.water_mark_template_id is not None:
            result['WaterMarkTemplateId'] = self.water_mark_template_id
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('InputFile') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMarkInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WaterMarkTemplateId') is not None:
            self.water_mark_template_id = m.get('WaterMarkTemplateId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkList(TeaModel):
    def __init__(
        self,
        water_mark: List[QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark] = None,
    ):
        self.water_mark = water_mark

    def validate(self):
        if self.water_mark:
            for k in self.water_mark:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WaterMark'] = []
        if self.water_mark is not None:
            for k in self.water_mark:
                result['WaterMark'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.water_mark = []
        if m.get('WaterMark') is not None:
            for k in m.get('WaterMark'):
                temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark()
                self.water_mark.append(temp_model.from_map(k))
        return self


class QueryEditingJobListResponseBodyJobListJobEditingConfig(TeaModel):
    def __init__(
        self,
        audio: QueryEditingJobListResponseBodyJobListJobEditingConfigAudio = None,
        audio_stream_map: str = None,
        clip: QueryEditingJobListResponseBodyJobListJobEditingConfigClip = None,
        container: QueryEditingJobListResponseBodyJobListJobEditingConfigContainer = None,
        de_watermark: str = None,
        digi_water_mark: QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMark = None,
        editing: QueryEditingJobListResponseBodyJobListJobEditingConfigEditing = None,
        encryption: QueryEditingJobListResponseBodyJobListJobEditingConfigEncryption = None,
        m_3u8non_standard_support: QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupport = None,
        merge_config_url: str = None,
        merge_list: QueryEditingJobListResponseBodyJobListJobEditingConfigMergeList = None,
        mux_config: QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfig = None,
        output_file: QueryEditingJobListResponseBodyJobListJobEditingConfigOutputFile = None,
        priority: str = None,
        properties: QueryEditingJobListResponseBodyJobListJobEditingConfigProperties = None,
        rotate: str = None,
        subtitle_config: QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfig = None,
        super_reso: QueryEditingJobListResponseBodyJobListJobEditingConfigSuperReso = None,
        template_id: str = None,
        trans_config: QueryEditingJobListResponseBodyJobListJobEditingConfigTransConfig = None,
        user_data: str = None,
        video: QueryEditingJobListResponseBodyJobListJobEditingConfigVideo = None,
        video_stream_map: str = None,
        water_mark_config_url: str = None,
        water_mark_list: QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkList = None,
    ):
        self.audio = audio
        self.audio_stream_map = audio_stream_map
        self.clip = clip
        self.container = container
        self.de_watermark = de_watermark
        self.digi_water_mark = digi_water_mark
        self.editing = editing
        self.encryption = encryption
        self.m_3u8non_standard_support = m_3u8non_standard_support
        self.merge_config_url = merge_config_url
        self.merge_list = merge_list
        self.mux_config = mux_config
        self.output_file = output_file
        self.priority = priority
        self.properties = properties
        self.rotate = rotate
        self.subtitle_config = subtitle_config
        self.super_reso = super_reso
        self.template_id = template_id
        self.trans_config = trans_config
        self.user_data = user_data
        self.video = video
        self.video_stream_map = video_stream_map
        self.water_mark_config_url = water_mark_config_url
        self.water_mark_list = water_mark_list

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.clip:
            self.clip.validate()
        if self.container:
            self.container.validate()
        if self.digi_water_mark:
            self.digi_water_mark.validate()
        if self.editing:
            self.editing.validate()
        if self.encryption:
            self.encryption.validate()
        if self.m_3u8non_standard_support:
            self.m_3u8non_standard_support.validate()
        if self.merge_list:
            self.merge_list.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.output_file:
            self.output_file.validate()
        if self.properties:
            self.properties.validate()
        if self.subtitle_config:
            self.subtitle_config.validate()
        if self.super_reso:
            self.super_reso.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()
        if self.water_mark_list:
            self.water_mark_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.audio_stream_map is not None:
            result['AudioStreamMap'] = self.audio_stream_map
        if self.clip is not None:
            result['Clip'] = self.clip.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.de_watermark is not None:
            result['DeWatermark'] = self.de_watermark
        if self.digi_water_mark is not None:
            result['DigiWaterMark'] = self.digi_water_mark.to_map()
        if self.editing is not None:
            result['Editing'] = self.editing.to_map()
        if self.encryption is not None:
            result['Encryption'] = self.encryption.to_map()
        if self.m_3u8non_standard_support is not None:
            result['M3U8NonStandardSupport'] = self.m_3u8non_standard_support.to_map()
        if self.merge_config_url is not None:
            result['MergeConfigUrl'] = self.merge_config_url
        if self.merge_list is not None:
            result['MergeList'] = self.merge_list.to_map()
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.output_file is not None:
            result['OutputFile'] = self.output_file.to_map()
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.properties is not None:
            result['Properties'] = self.properties.to_map()
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.subtitle_config is not None:
            result['SubtitleConfig'] = self.subtitle_config.to_map()
        if self.super_reso is not None:
            result['SuperReso'] = self.super_reso.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.video is not None:
            result['Video'] = self.video.to_map()
        if self.video_stream_map is not None:
            result['VideoStreamMap'] = self.video_stream_map
        if self.water_mark_config_url is not None:
            result['WaterMarkConfigUrl'] = self.water_mark_config_url
        if self.water_mark_list is not None:
            result['WaterMarkList'] = self.water_mark_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('AudioStreamMap') is not None:
            self.audio_stream_map = m.get('AudioStreamMap')
        if m.get('Clip') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigClip()
            self.clip = temp_model.from_map(m['Clip'])
        if m.get('Container') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('DeWatermark') is not None:
            self.de_watermark = m.get('DeWatermark')
        if m.get('DigiWaterMark') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMark()
            self.digi_water_mark = temp_model.from_map(m['DigiWaterMark'])
        if m.get('Editing') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigEditing()
            self.editing = temp_model.from_map(m['Editing'])
        if m.get('Encryption') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigEncryption()
            self.encryption = temp_model.from_map(m['Encryption'])
        if m.get('M3U8NonStandardSupport') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupport()
            self.m_3u8non_standard_support = temp_model.from_map(m['M3U8NonStandardSupport'])
        if m.get('MergeConfigUrl') is not None:
            self.merge_config_url = m.get('MergeConfigUrl')
        if m.get('MergeList') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigMergeList()
            self.merge_list = temp_model.from_map(m['MergeList'])
        if m.get('MuxConfig') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('OutputFile') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigOutputFile()
            self.output_file = temp_model.from_map(m['OutputFile'])
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Properties') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigProperties()
            self.properties = temp_model.from_map(m['Properties'])
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('SubtitleConfig') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfig()
            self.subtitle_config = temp_model.from_map(m['SubtitleConfig'])
        if m.get('SuperReso') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigSuperReso()
            self.super_reso = temp_model.from_map(m['SuperReso'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TransConfig') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('Video') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigVideo()
            self.video = temp_model.from_map(m['Video'])
        if m.get('VideoStreamMap') is not None:
            self.video_stream_map = m.get('VideoStreamMap')
        if m.get('WaterMarkConfigUrl') is not None:
            self.water_mark_config_url = m.get('WaterMarkConfigUrl')
        if m.get('WaterMarkList') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkList()
            self.water_mark_list = temp_model.from_map(m['WaterMarkList'])
        return self


class QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputConfig(TeaModel):
    def __init__(
        self,
        deinterlace_method: str = None,
        is_normal_sar: str = None,
    ):
        self.deinterlace_method = deinterlace_method
        self.is_normal_sar = is_normal_sar

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deinterlace_method is not None:
            result['DeinterlaceMethod'] = self.deinterlace_method
        if self.is_normal_sar is not None:
            result['IsNormalSar'] = self.is_normal_sar
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeinterlaceMethod') is not None:
            self.deinterlace_method = m.get('DeinterlaceMethod')
        if m.get('IsNormalSar') is not None:
            self.is_normal_sar = m.get('IsNormalSar')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput(TeaModel):
    def __init__(
        self,
        id: str = None,
        input_config: QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputConfig = None,
        input_file: QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputFile = None,
    ):
        self.id = id
        self.input_config = input_config
        self.input_file = input_file

    def validate(self):
        if self.input_config:
            self.input_config.validate()
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.input_config is not None:
            result['InputConfig'] = self.input_config.to_map()
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InputConfig') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputConfig()
            self.input_config = temp_model.from_map(m['InputConfig'])
        if m.get('InputFile') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        return self


class QueryEditingJobListResponseBodyJobListJobEditingInputs(TeaModel):
    def __init__(
        self,
        editing_input: List[QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput] = None,
    ):
        self.editing_input = editing_input

    def validate(self):
        if self.editing_input:
            for k in self.editing_input:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EditingInput'] = []
        if self.editing_input is not None:
            for k in self.editing_input:
                result['EditingInput'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.editing_input = []
        if m.get('EditingInput') is not None:
            for k in m.get('EditingInput'):
                temp_model = QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput()
                self.editing_input.append(temp_model.from_map(k))
        return self


class QueryEditingJobListResponseBodyJobListJobMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class QueryEditingJobListResponseBodyJobListJob(TeaModel):
    def __init__(
        self,
        code: str = None,
        creation_time: str = None,
        editing_config: QueryEditingJobListResponseBodyJobListJobEditingConfig = None,
        editing_inputs: QueryEditingJobListResponseBodyJobListJobEditingInputs = None,
        finish_time: str = None,
        job_id: str = None,
        mnsmessage_result: QueryEditingJobListResponseBodyJobListJobMNSMessageResult = None,
        message: str = None,
        percent: int = None,
        pipeline_id: str = None,
        state: str = None,
    ):
        self.code = code
        self.creation_time = creation_time
        self.editing_config = editing_config
        self.editing_inputs = editing_inputs
        self.finish_time = finish_time
        self.job_id = job_id
        self.mnsmessage_result = mnsmessage_result
        self.message = message
        self.percent = percent
        self.pipeline_id = pipeline_id
        self.state = state

    def validate(self):
        if self.editing_config:
            self.editing_config.validate()
        if self.editing_inputs:
            self.editing_inputs.validate()
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.editing_config is not None:
            result['EditingConfig'] = self.editing_config.to_map()
        if self.editing_inputs is not None:
            result['EditingInputs'] = self.editing_inputs.to_map()
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('EditingConfig') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingConfig()
            self.editing_config = temp_model.from_map(m['EditingConfig'])
        if m.get('EditingInputs') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobEditingInputs()
            self.editing_inputs = temp_model.from_map(m['EditingInputs'])
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MNSMessageResult') is not None:
            temp_model = QueryEditingJobListResponseBodyJobListJobMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class QueryEditingJobListResponseBodyJobList(TeaModel):
    def __init__(
        self,
        job: List[QueryEditingJobListResponseBodyJobListJob] = None,
    ):
        self.job = job

    def validate(self):
        if self.job:
            for k in self.job:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Job'] = []
        if self.job is not None:
            for k in self.job:
                result['Job'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.job = []
        if m.get('Job') is not None:
            for k in m.get('Job'):
                temp_model = QueryEditingJobListResponseBodyJobListJob()
                self.job.append(temp_model.from_map(k))
        return self


class QueryEditingJobListResponseBodyNonExistJobIds(TeaModel):
    def __init__(
        self,
        string: List[str] = None,
    ):
        self.string = string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class QueryEditingJobListResponseBody(TeaModel):
    def __init__(
        self,
        job_list: QueryEditingJobListResponseBodyJobList = None,
        non_exist_job_ids: QueryEditingJobListResponseBodyNonExistJobIds = None,
        request_id: str = None,
    ):
        self.job_list = job_list
        self.non_exist_job_ids = non_exist_job_ids
        self.request_id = request_id

    def validate(self):
        if self.job_list:
            self.job_list.validate()
        if self.non_exist_job_ids:
            self.non_exist_job_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_list is not None:
            result['JobList'] = self.job_list.to_map()
        if self.non_exist_job_ids is not None:
            result['NonExistJobIds'] = self.non_exist_job_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobList') is not None:
            temp_model = QueryEditingJobListResponseBodyJobList()
            self.job_list = temp_model.from_map(m['JobList'])
        if m.get('NonExistJobIds') is not None:
            temp_model = QueryEditingJobListResponseBodyNonExistJobIds()
            self.non_exist_job_ids = temp_model.from_map(m['NonExistJobIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryEditingJobListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryEditingJobListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryEditingJobListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryJobListRequest(TeaModel):
    def __init__(
        self,
        job_ids: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        self.job_ids = job_ids
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_ids is not None:
            result['JobIds'] = self.job_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobIds') is not None:
            self.job_ids = m.get('JobIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryJobListResponseBodyJobListJobInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryJobListResponseBodyJobListJobMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class QueryJobListResponseBodyJobListJobOutputAmixListAmix(TeaModel):
    def __init__(
        self,
        amix_url: str = None,
        duration: str = None,
        map: str = None,
        mix_dur_mode: str = None,
        start: str = None,
    ):
        self.amix_url = amix_url
        self.duration = duration
        self.map = map
        self.mix_dur_mode = mix_dur_mode
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amix_url is not None:
            result['AmixURL'] = self.amix_url
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.map is not None:
            result['Map'] = self.map
        if self.mix_dur_mode is not None:
            result['MixDurMode'] = self.mix_dur_mode
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AmixURL') is not None:
            self.amix_url = m.get('AmixURL')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Map') is not None:
            self.map = m.get('Map')
        if m.get('MixDurMode') is not None:
            self.mix_dur_mode = m.get('MixDurMode')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class QueryJobListResponseBodyJobListJobOutputAmixList(TeaModel):
    def __init__(
        self,
        amix: List[QueryJobListResponseBodyJobListJobOutputAmixListAmix] = None,
    ):
        self.amix = amix

    def validate(self):
        if self.amix:
            for k in self.amix:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Amix'] = []
        if self.amix is not None:
            for k in self.amix:
                result['Amix'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.amix = []
        if m.get('Amix') is not None:
            for k in m.get('Amix'):
                temp_model = QueryJobListResponseBodyJobListJobOutputAmixListAmix()
                self.amix.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutputAudioVolume(TeaModel):
    def __init__(
        self,
        level: str = None,
        method: str = None,
    ):
        self.level = level
        self.method = method

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.level is not None:
            result['Level'] = self.level
        if self.method is not None:
            result['Method'] = self.method
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        return self


class QueryJobListResponseBodyJobListJobOutputAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        qscale: str = None,
        samplerate: str = None,
        volume: QueryJobListResponseBodyJobListJobOutputAudioVolume = None,
    ):
        self.bitrate = bitrate
        self.channels = channels
        self.codec = codec
        self.profile = profile
        self.qscale = qscale
        self.samplerate = samplerate
        self.volume = volume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class QueryJobListResponseBodyJobListJobOutputClipTimeSpan(TeaModel):
    def __init__(
        self,
        duration: str = None,
        seek: str = None,
    ):
        self.duration = duration
        self.seek = seek

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.seek is not None:
            result['Seek'] = self.seek
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Seek') is not None:
            self.seek = m.get('Seek')
        return self


class QueryJobListResponseBodyJobListJobOutputClip(TeaModel):
    def __init__(
        self,
        time_span: QueryJobListResponseBodyJobListJobOutputClipTimeSpan = None,
    ):
        self.time_span = time_span

    def validate(self):
        if self.time_span:
            self.time_span.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time_span is not None:
            result['TimeSpan'] = self.time_span.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeSpan') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputClipTimeSpan()
            self.time_span = temp_model.from_map(m['TimeSpan'])
        return self


class QueryJobListResponseBodyJobListJobOutputContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class QueryJobListResponseBodyJobListJobOutputEncryption(TeaModel):
    def __init__(
        self,
        id: str = None,
        key: str = None,
        key_type: str = None,
        key_uri: str = None,
        skip_cnt: str = None,
        type: str = None,
    ):
        self.id = id
        self.key = key
        self.key_type = key_type
        self.key_uri = key_uri
        self.skip_cnt = skip_cnt
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.key is not None:
            result['Key'] = self.key
        if self.key_type is not None:
            result['KeyType'] = self.key_type
        if self.key_uri is not None:
            result['KeyUri'] = self.key_uri
        if self.skip_cnt is not None:
            result['SkipCnt'] = self.skip_cnt
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('KeyType') is not None:
            self.key_type = m.get('KeyType')
        if m.get('KeyUri') is not None:
            self.key_uri = m.get('KeyUri')
        if m.get('SkipCnt') is not None:
            self.skip_cnt = m.get('SkipCnt')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS(TeaModel):
    def __init__(
        self,
        md_5support: bool = None,
        size_support: bool = None,
    ):
        self.md_5support = md_5support
        self.size_support = size_support

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.md_5support is not None:
            result['Md5Support'] = self.md_5support
        if self.size_support is not None:
            result['SizeSupport'] = self.size_support
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Md5Support') is not None:
            self.md_5support = m.get('Md5Support')
        if m.get('SizeSupport') is not None:
            self.size_support = m.get('SizeSupport')
        return self


class QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport(TeaModel):
    def __init__(
        self,
        ts: QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS = None,
    ):
        self.ts = ts

    def validate(self):
        if self.ts:
            self.ts.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ts is not None:
            result['TS'] = self.ts.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TS') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS()
            self.ts = temp_model.from_map(m['TS'])
        return self


class QueryJobListResponseBodyJobListJobOutputMergeListMerge(TeaModel):
    def __init__(
        self,
        duration: str = None,
        merge_url: str = None,
        role_arn: str = None,
        start: str = None,
    ):
        self.duration = duration
        self.merge_url = merge_url
        self.role_arn = role_arn
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.merge_url is not None:
            result['MergeURL'] = self.merge_url
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('MergeURL') is not None:
            self.merge_url = m.get('MergeURL')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class QueryJobListResponseBodyJobListJobOutputMergeList(TeaModel):
    def __init__(
        self,
        merge: List[QueryJobListResponseBodyJobListJobOutputMergeListMerge] = None,
    ):
        self.merge = merge

    def validate(self):
        if self.merge:
            for k in self.merge:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Merge'] = []
        if self.merge is not None:
            for k in self.merge:
                result['Merge'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.merge = []
        if m.get('Merge') is not None:
            for k in m.get('Merge'):
                temp_model = QueryJobListResponseBodyJobListJobOutputMergeListMerge()
                self.merge.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutputMuxConfigGif(TeaModel):
    def __init__(
        self,
        dither_mode: str = None,
        final_delay: str = None,
        is_custom_palette: str = None,
        loop: str = None,
    ):
        self.dither_mode = dither_mode
        self.final_delay = final_delay
        self.is_custom_palette = is_custom_palette
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dither_mode is not None:
            result['DitherMode'] = self.dither_mode
        if self.final_delay is not None:
            result['FinalDelay'] = self.final_delay
        if self.is_custom_palette is not None:
            result['IsCustomPalette'] = self.is_custom_palette
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DitherMode') is not None:
            self.dither_mode = m.get('DitherMode')
        if m.get('FinalDelay') is not None:
            self.final_delay = m.get('FinalDelay')
        if m.get('IsCustomPalette') is not None:
            self.is_custom_palette = m.get('IsCustomPalette')
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class QueryJobListResponseBodyJobListJobOutputMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
    ):
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class QueryJobListResponseBodyJobListJobOutputMuxConfigWebp(TeaModel):
    def __init__(
        self,
        loop: str = None,
    ):
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class QueryJobListResponseBodyJobListJobOutputMuxConfig(TeaModel):
    def __init__(
        self,
        gif: QueryJobListResponseBodyJobListJobOutputMuxConfigGif = None,
        segment: QueryJobListResponseBodyJobListJobOutputMuxConfigSegment = None,
        webp: QueryJobListResponseBodyJobListJobOutputMuxConfigWebp = None,
    ):
        self.gif = gif
        self.segment = segment
        self.webp = webp

    def validate(self):
        if self.gif:
            self.gif.validate()
        if self.segment:
            self.segment.validate()
        if self.webp:
            self.webp.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gif is not None:
            result['Gif'] = self.gif.to_map()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        if self.webp is not None:
            result['Webp'] = self.webp.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gif') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputMuxConfigGif()
            self.gif = temp_model.from_map(m['Gif'])
        if m.get('Segment') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        if m.get('Webp') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputMuxConfigWebp()
            self.webp = temp_model.from_map(m['Webp'])
        return self


class QueryJobListResponseBodyJobListJobOutputOpeningListOpening(TeaModel):
    def __init__(
        self,
        height: str = None,
        start: str = None,
        width: str = None,
        open_url: str = None,
    ):
        self.height = height
        self.start = start
        self.width = width
        self.open_url = open_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.start is not None:
            result['Start'] = self.start
        if self.width is not None:
            result['Width'] = self.width
        if self.open_url is not None:
            result['openUrl'] = self.open_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('openUrl') is not None:
            self.open_url = m.get('openUrl')
        return self


class QueryJobListResponseBodyJobListJobOutputOpeningList(TeaModel):
    def __init__(
        self,
        opening: List[QueryJobListResponseBodyJobListJobOutputOpeningListOpening] = None,
    ):
        self.opening = opening

    def validate(self):
        if self.opening:
            for k in self.opening:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Opening'] = []
        if self.opening is not None:
            for k in self.opening:
                result['Opening'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.opening = []
        if m.get('Opening') is not None:
            for k in m.get('Opening'):
                temp_model = QueryJobListResponseBodyJobListJobOutputOpeningListOpening()
                self.opening.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle(TeaModel):
    def __init__(
        self,
        map: str = None,
        message: str = None,
        out_subtitle_file: QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile = None,
        success: bool = None,
    ):
        self.map = map
        self.message = message
        self.out_subtitle_file = out_subtitle_file
        self.success = success

    def validate(self):
        if self.out_subtitle_file:
            self.out_subtitle_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.map is not None:
            result['Map'] = self.map
        if self.message is not None:
            result['Message'] = self.message
        if self.out_subtitle_file is not None:
            result['OutSubtitleFile'] = self.out_subtitle_file.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Map') is not None:
            self.map = m.get('Map')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('OutSubtitleFile') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile()
            self.out_subtitle_file = temp_model.from_map(m['OutSubtitleFile'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryJobListResponseBodyJobListJobOutputOutSubtitleList(TeaModel):
    def __init__(
        self,
        out_subtitle: List[QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle] = None,
    ):
        self.out_subtitle = out_subtitle

    def validate(self):
        if self.out_subtitle:
            for k in self.out_subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OutSubtitle'] = []
        if self.out_subtitle is not None:
            for k in self.out_subtitle:
                result['OutSubtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.out_subtitle = []
        if m.get('OutSubtitle') is not None:
            for k in m.get('OutSubtitle'):
                temp_model = QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle()
                self.out_subtitle.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutputOutputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesFormat(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        format_long_name: str = None,
        format_name: str = None,
        num_programs: str = None,
        num_streams: str = None,
        size: str = None,
        start_time: str = None,
    ):
        self.bitrate = bitrate
        self.duration = duration
        self.format_long_name = format_long_name
        self.format_name = format_name
        self.num_programs = num_programs
        self.num_streams = num_streams
        self.size = size
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.format_long_name is not None:
            result['FormatLongName'] = self.format_long_name
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.num_programs is not None:
            result['NumPrograms'] = self.num_programs
        if self.num_streams is not None:
            result['NumStreams'] = self.num_streams
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FormatLongName') is not None:
            self.format_long_name = m.get('FormatLongName')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('NumPrograms') is not None:
            self.num_programs = m.get('NumPrograms')
        if m.get('NumStreams') is not None:
            self.num_streams = m.get('NumStreams')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo(TeaModel):
    def __init__(
        self,
        source: str = None,
    ):
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source is not None:
            result['Source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Source') is not None:
            self.source = m.get('Source')
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos(TeaModel):
    def __init__(
        self,
        source_logo: List[QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo] = None,
    ):
        self.source_logo = source_logo

    def validate(self):
        if self.source_logo:
            for k in self.source_logo:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SourceLogo'] = []
        if self.source_logo is not None:
            for k in self.source_logo:
                result['SourceLogo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.source_logo = []
        if m.get('SourceLogo') is not None:
            for k in m.get('SourceLogo'):
                temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo()
                self.source_logo.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        num_frames: str = None,
        sample_fmt: str = None,
        samplerate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        self.bitrate = bitrate
        self.channel_layout = channel_layout
        self.channels = channels
        self.codec_long_name = codec_long_name
        self.codec_name = codec_name
        self.codec_tag = codec_tag
        self.codec_tag_string = codec_tag_string
        self.codec_time_base = codec_time_base
        self.duration = duration
        self.index = index
        self.lang = lang
        self.num_frames = num_frames
        self.sample_fmt = sample_fmt
        self.samplerate = samplerate
        self.start_time = start_time
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList(TeaModel):
    def __init__(
        self,
        audio_stream: List[QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream] = None,
    ):
        self.audio_stream = audio_stream

    def validate(self):
        if self.audio_stream:
            for k in self.audio_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStream'] = []
        if self.audio_stream is not None:
            for k in self.audio_stream:
                result['AudioStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream = []
        if m.get('AudioStream') is not None:
            for k in m.get('AudioStream'):
                temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream()
                self.audio_stream.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream(TeaModel):
    def __init__(
        self,
        index: str = None,
        lang: str = None,
    ):
        self.index = index
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList(TeaModel):
    def __init__(
        self,
        subtitle_stream: List[QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream] = None,
    ):
        self.subtitle_stream = subtitle_stream

    def validate(self):
        if self.subtitle_stream:
            for k in self.subtitle_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubtitleStream'] = []
        if self.subtitle_stream is not None:
            for k in self.subtitle_stream:
                result['SubtitleStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle_stream = []
        if m.get('SubtitleStream') is not None:
            for k in m.get('SubtitleStream'):
                temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream()
                self.subtitle_stream.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost(TeaModel):
    def __init__(
        self,
        avg_bitrate: str = None,
        cost_bandwidth: str = None,
        preload_time: str = None,
    ):
        self.avg_bitrate = avg_bitrate
        self.cost_bandwidth = cost_bandwidth
        self.preload_time = preload_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_bitrate is not None:
            result['AvgBitrate'] = self.avg_bitrate
        if self.cost_bandwidth is not None:
            result['CostBandwidth'] = self.cost_bandwidth
        if self.preload_time is not None:
            result['PreloadTime'] = self.preload_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgBitrate') is not None:
            self.avg_bitrate = m.get('AvgBitrate')
        if m.get('CostBandwidth') is not None:
            self.cost_bandwidth = m.get('CostBandwidth')
        if m.get('PreloadTime') is not None:
            self.preload_time = m.get('PreloadTime')
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bitrate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        network_cost: QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        sar: str = None,
        start_time: str = None,
        timebase: str = None,
        width: str = None,
    ):
        self.avg_fps = avg_fps
        self.bitrate = bitrate
        self.codec_long_name = codec_long_name
        self.codec_name = codec_name
        self.codec_tag = codec_tag
        self.codec_tag_string = codec_tag_string
        self.codec_time_base = codec_time_base
        self.dar = dar
        self.duration = duration
        self.fps = fps
        self.has_bframes = has_bframes
        self.height = height
        self.index = index
        self.lang = lang
        self.level = level
        self.network_cost = network_cost
        self.num_frames = num_frames
        self.pix_fmt = pix_fmt
        self.profile = profile
        self.sar = sar
        self.start_time = start_time
        self.timebase = timebase
        self.width = width

    def validate(self):
        if self.network_cost:
            self.network_cost.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['AvgFPS'] = self.avg_fps
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['HasBFrames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.network_cost is not None:
            result['NetworkCost'] = self.network_cost.to_map()
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgFPS') is not None:
            self.avg_fps = m.get('AvgFPS')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HasBFrames') is not None:
            self.has_bframes = m.get('HasBFrames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NetworkCost') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost()
            self.network_cost = temp_model.from_map(m['NetworkCost'])
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList(TeaModel):
    def __init__(
        self,
        video_stream: List[QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream] = None,
    ):
        self.video_stream = video_stream

    def validate(self):
        if self.video_stream:
            for k in self.video_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoStream'] = []
        if self.video_stream is not None:
            for k in self.video_stream:
                result['VideoStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_stream = []
        if m.get('VideoStream') is not None:
            for k in m.get('VideoStream'):
                temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream()
                self.video_stream.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesStreams(TeaModel):
    def __init__(
        self,
        audio_stream_list: QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList = None,
        subtitle_stream_list: QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList = None,
        video_stream_list: QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList = None,
    ):
        self.audio_stream_list = audio_stream_list
        self.subtitle_stream_list = subtitle_stream_list
        self.video_stream_list = video_stream_list

    def validate(self):
        if self.audio_stream_list:
            self.audio_stream_list.validate()
        if self.subtitle_stream_list:
            self.subtitle_stream_list.validate()
        if self.video_stream_list:
            self.video_stream_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_stream_list is not None:
            result['AudioStreamList'] = self.audio_stream_list.to_map()
        if self.subtitle_stream_list is not None:
            result['SubtitleStreamList'] = self.subtitle_stream_list.to_map()
        if self.video_stream_list is not None:
            result['VideoStreamList'] = self.video_stream_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioStreamList') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList()
            self.audio_stream_list = temp_model.from_map(m['AudioStreamList'])
        if m.get('SubtitleStreamList') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList()
            self.subtitle_stream_list = temp_model.from_map(m['SubtitleStreamList'])
        if m.get('VideoStreamList') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList()
            self.video_stream_list = temp_model.from_map(m['VideoStreamList'])
        return self


class QueryJobListResponseBodyJobListJobOutputProperties(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_format: str = None,
        file_size: str = None,
        format: QueryJobListResponseBodyJobListJobOutputPropertiesFormat = None,
        fps: str = None,
        height: str = None,
        source_logos: QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos = None,
        streams: QueryJobListResponseBodyJobListJobOutputPropertiesStreams = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.duration = duration
        self.file_format = file_format
        self.file_size = file_size
        self.format = format
        self.fps = fps
        self.height = height
        self.source_logos = source_logos
        self.streams = streams
        self.width = width

    def validate(self):
        if self.format:
            self.format.validate()
        if self.source_logos:
            self.source_logos.validate()
        if self.streams:
            self.streams.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_format is not None:
            result['FileFormat'] = self.file_format
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.format is not None:
            result['Format'] = self.format.to_map()
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.source_logos is not None:
            result['SourceLogos'] = self.source_logos.to_map()
        if self.streams is not None:
            result['Streams'] = self.streams.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileFormat') is not None:
            self.file_format = m.get('FileFormat')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('Format') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesFormat()
            self.format = temp_model.from_map(m['Format'])
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('SourceLogos') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos()
            self.source_logos = temp_model.from_map(m['SourceLogos'])
        if m.get('Streams') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesStreams()
            self.streams = temp_model.from_map(m['Streams'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle(TeaModel):
    def __init__(
        self,
        char_enc: str = None,
        font_name: str = None,
        input: QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput = None,
    ):
        self.char_enc = char_enc
        self.font_name = font_name
        self.input = input

    def validate(self):
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.char_enc is not None:
            result['CharEnc'] = self.char_enc
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.input is not None:
            result['Input'] = self.input.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CharEnc') is not None:
            self.char_enc = m.get('CharEnc')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('Input') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput()
            self.input = temp_model.from_map(m['Input'])
        return self


class QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList(TeaModel):
    def __init__(
        self,
        ext_subtitle: List[QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle] = None,
    ):
        self.ext_subtitle = ext_subtitle

    def validate(self):
        if self.ext_subtitle:
            for k in self.ext_subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ExtSubtitle'] = []
        if self.ext_subtitle is not None:
            for k in self.ext_subtitle:
                result['ExtSubtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ext_subtitle = []
        if m.get('ExtSubtitle') is not None:
            for k in m.get('ExtSubtitle'):
                temp_model = QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle()
                self.ext_subtitle.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle(TeaModel):
    def __init__(
        self,
        map: str = None,
    ):
        self.map = map

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.map is not None:
            result['Map'] = self.map
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Map') is not None:
            self.map = m.get('Map')
        return self


class QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList(TeaModel):
    def __init__(
        self,
        subtitle: List[QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle] = None,
    ):
        self.subtitle = subtitle

    def validate(self):
        if self.subtitle:
            for k in self.subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Subtitle'] = []
        if self.subtitle is not None:
            for k in self.subtitle:
                result['Subtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle = []
        if m.get('Subtitle') is not None:
            for k in m.get('Subtitle'):
                temp_model = QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle()
                self.subtitle.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutputSubtitleConfig(TeaModel):
    def __init__(
        self,
        ext_subtitle_list: QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList = None,
        subtitle_list: QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList = None,
    ):
        self.ext_subtitle_list = ext_subtitle_list
        self.subtitle_list = subtitle_list

    def validate(self):
        if self.ext_subtitle_list:
            self.ext_subtitle_list.validate()
        if self.subtitle_list:
            self.subtitle_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ext_subtitle_list is not None:
            result['ExtSubtitleList'] = self.ext_subtitle_list.to_map()
        if self.subtitle_list is not None:
            result['SubtitleList'] = self.subtitle_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExtSubtitleList') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList()
            self.ext_subtitle_list = temp_model.from_map(m['ExtSubtitleList'])
        if m.get('SubtitleList') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList()
            self.subtitle_list = temp_model.from_map(m['SubtitleList'])
        return self


class QueryJobListResponseBodyJobListJobOutputSuperReso(TeaModel):
    def __init__(
        self,
        is_half_sample: str = None,
    ):
        self.is_half_sample = is_half_sample

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_half_sample is not None:
            result['IsHalfSample'] = self.is_half_sample
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsHalfSample') is not None:
            self.is_half_sample = m.get('IsHalfSample')
        return self


class QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate(TeaModel):
    def __init__(
        self,
        bg_color: str = None,
        blend_duration: str = None,
        height: str = None,
        is_merge_audio: bool = None,
        start: str = None,
        tail_url: str = None,
        width: str = None,
    ):
        self.bg_color = bg_color
        self.blend_duration = blend_duration
        self.height = height
        self.is_merge_audio = is_merge_audio
        self.start = start
        self.tail_url = tail_url
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bg_color is not None:
            result['BgColor'] = self.bg_color
        if self.blend_duration is not None:
            result['BlendDuration'] = self.blend_duration
        if self.height is not None:
            result['Height'] = self.height
        if self.is_merge_audio is not None:
            result['IsMergeAudio'] = self.is_merge_audio
        if self.start is not None:
            result['Start'] = self.start
        if self.tail_url is not None:
            result['TailUrl'] = self.tail_url
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BgColor') is not None:
            self.bg_color = m.get('BgColor')
        if m.get('BlendDuration') is not None:
            self.blend_duration = m.get('BlendDuration')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('IsMergeAudio') is not None:
            self.is_merge_audio = m.get('IsMergeAudio')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('TailUrl') is not None:
            self.tail_url = m.get('TailUrl')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryJobListResponseBodyJobListJobOutputTailSlateList(TeaModel):
    def __init__(
        self,
        tail_slate: List[QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate] = None,
    ):
        self.tail_slate = tail_slate

    def validate(self):
        if self.tail_slate:
            for k in self.tail_slate:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TailSlate'] = []
        if self.tail_slate is not None:
            for k in self.tail_slate:
                result['TailSlate'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tail_slate = []
        if m.get('TailSlate') is not None:
            for k in m.get('TailSlate'):
                temp_model = QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate()
                self.tail_slate.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutputTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        is_check_audio_bitrate: str = None,
        is_check_audio_bitrate_fail: str = None,
        is_check_reso: str = None,
        is_check_reso_fail: str = None,
        is_check_video_bitrate: str = None,
        is_check_video_bitrate_fail: str = None,
        trans_mode: str = None,
    ):
        self.adj_dar_method = adj_dar_method
        self.is_check_audio_bitrate = is_check_audio_bitrate
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        self.is_check_reso = is_check_reso
        self.is_check_reso_fail = is_check_reso_fail
        self.is_check_video_bitrate = is_check_video_bitrate
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd(TeaModel):
    def __init__(
        self,
        max: str = None,
        min: str = None,
    ):
        self.max = max
        self.min = min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        return self


class QueryJobListResponseBodyJobListJobOutputVideo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        bitrate_bnd: QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        degrain: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        max_fps: str = None,
        maxrate: str = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        qscale: str = None,
        reso_priority: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.bitrate_bnd = bitrate_bnd
        self.bufsize = bufsize
        self.codec = codec
        self.crf = crf
        self.crop = crop
        self.degrain = degrain
        self.fps = fps
        self.gop = gop
        self.height = height
        self.max_fps = max_fps
        self.maxrate = maxrate
        self.pad = pad
        self.pix_fmt = pix_fmt
        self.preset = preset
        self.profile = profile
        self.qscale = qscale
        self.reso_priority = reso_priority
        self.scan_mode = scan_mode
        self.width = width

    def validate(self):
        if self.bitrate_bnd:
            self.bitrate_bnd.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bitrate_bnd is not None:
            result['BitrateBnd'] = self.bitrate_bnd.to_map()
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.degrain is not None:
            result['Degrain'] = self.degrain
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.max_fps is not None:
            result['MaxFps'] = self.max_fps
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.reso_priority is not None:
            result['ResoPriority'] = self.reso_priority
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BitrateBnd') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd()
            self.bitrate_bnd = temp_model.from_map(m['BitrateBnd'])
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Degrain') is not None:
            self.degrain = m.get('Degrain')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MaxFps') is not None:
            self.max_fps = m.get('MaxFps')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('ResoPriority') is not None:
            self.reso_priority = m.get('ResoPriority')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        input_file: QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile = None,
        refer_pos: str = None,
        type: str = None,
        water_mark_template_id: str = None,
        width: str = None,
    ):
        self.dx = dx
        self.dy = dy
        self.height = height
        self.input_file = input_file
        self.refer_pos = refer_pos
        self.type = type
        self.water_mark_template_id = water_mark_template_id
        self.width = width

    def validate(self):
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.type is not None:
            result['Type'] = self.type
        if self.water_mark_template_id is not None:
            result['WaterMarkTemplateId'] = self.water_mark_template_id
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('InputFile') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WaterMarkTemplateId') is not None:
            self.water_mark_template_id = m.get('WaterMarkTemplateId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryJobListResponseBodyJobListJobOutputWaterMarkList(TeaModel):
    def __init__(
        self,
        water_mark: List[QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark] = None,
    ):
        self.water_mark = water_mark

    def validate(self):
        if self.water_mark:
            for k in self.water_mark:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WaterMark'] = []
        if self.water_mark is not None:
            for k in self.water_mark:
                result['WaterMark'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.water_mark = []
        if m.get('WaterMark') is not None:
            for k in m.get('WaterMark'):
                temp_model = QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark()
                self.water_mark.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutput(TeaModel):
    def __init__(
        self,
        amix_list: QueryJobListResponseBodyJobListJobOutputAmixList = None,
        audio: QueryJobListResponseBodyJobListJobOutputAudio = None,
        audio_stream_map: str = None,
        clip: QueryJobListResponseBodyJobListJobOutputClip = None,
        container: QueryJobListResponseBodyJobListJobOutputContainer = None,
        de_watermark: str = None,
        encryption: QueryJobListResponseBodyJobListJobOutputEncryption = None,
        m_3u8non_standard_support: QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport = None,
        merge_config_url: str = None,
        merge_list: QueryJobListResponseBodyJobListJobOutputMergeList = None,
        mux_config: QueryJobListResponseBodyJobListJobOutputMuxConfig = None,
        opening_list: QueryJobListResponseBodyJobListJobOutputOpeningList = None,
        out_subtitle_list: QueryJobListResponseBodyJobListJobOutputOutSubtitleList = None,
        output_file: QueryJobListResponseBodyJobListJobOutputOutputFile = None,
        priority: str = None,
        properties: QueryJobListResponseBodyJobListJobOutputProperties = None,
        rotate: str = None,
        subtitle_config: QueryJobListResponseBodyJobListJobOutputSubtitleConfig = None,
        super_reso: QueryJobListResponseBodyJobListJobOutputSuperReso = None,
        tail_slate_list: QueryJobListResponseBodyJobListJobOutputTailSlateList = None,
        template_id: str = None,
        trans_config: QueryJobListResponseBodyJobListJobOutputTransConfig = None,
        user_data: str = None,
        video: QueryJobListResponseBodyJobListJobOutputVideo = None,
        video_stream_map: str = None,
        water_mark_config_url: str = None,
        water_mark_list: QueryJobListResponseBodyJobListJobOutputWaterMarkList = None,
    ):
        self.amix_list = amix_list
        self.audio = audio
        self.audio_stream_map = audio_stream_map
        self.clip = clip
        self.container = container
        self.de_watermark = de_watermark
        self.encryption = encryption
        self.m_3u8non_standard_support = m_3u8non_standard_support
        self.merge_config_url = merge_config_url
        self.merge_list = merge_list
        self.mux_config = mux_config
        self.opening_list = opening_list
        self.out_subtitle_list = out_subtitle_list
        self.output_file = output_file
        self.priority = priority
        self.properties = properties
        self.rotate = rotate
        self.subtitle_config = subtitle_config
        self.super_reso = super_reso
        self.tail_slate_list = tail_slate_list
        self.template_id = template_id
        self.trans_config = trans_config
        self.user_data = user_data
        self.video = video
        self.video_stream_map = video_stream_map
        self.water_mark_config_url = water_mark_config_url
        self.water_mark_list = water_mark_list

    def validate(self):
        if self.amix_list:
            self.amix_list.validate()
        if self.audio:
            self.audio.validate()
        if self.clip:
            self.clip.validate()
        if self.container:
            self.container.validate()
        if self.encryption:
            self.encryption.validate()
        if self.m_3u8non_standard_support:
            self.m_3u8non_standard_support.validate()
        if self.merge_list:
            self.merge_list.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.opening_list:
            self.opening_list.validate()
        if self.out_subtitle_list:
            self.out_subtitle_list.validate()
        if self.output_file:
            self.output_file.validate()
        if self.properties:
            self.properties.validate()
        if self.subtitle_config:
            self.subtitle_config.validate()
        if self.super_reso:
            self.super_reso.validate()
        if self.tail_slate_list:
            self.tail_slate_list.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()
        if self.water_mark_list:
            self.water_mark_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amix_list is not None:
            result['AmixList'] = self.amix_list.to_map()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.audio_stream_map is not None:
            result['AudioStreamMap'] = self.audio_stream_map
        if self.clip is not None:
            result['Clip'] = self.clip.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.de_watermark is not None:
            result['DeWatermark'] = self.de_watermark
        if self.encryption is not None:
            result['Encryption'] = self.encryption.to_map()
        if self.m_3u8non_standard_support is not None:
            result['M3U8NonStandardSupport'] = self.m_3u8non_standard_support.to_map()
        if self.merge_config_url is not None:
            result['MergeConfigUrl'] = self.merge_config_url
        if self.merge_list is not None:
            result['MergeList'] = self.merge_list.to_map()
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.opening_list is not None:
            result['OpeningList'] = self.opening_list.to_map()
        if self.out_subtitle_list is not None:
            result['OutSubtitleList'] = self.out_subtitle_list.to_map()
        if self.output_file is not None:
            result['OutputFile'] = self.output_file.to_map()
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.properties is not None:
            result['Properties'] = self.properties.to_map()
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.subtitle_config is not None:
            result['SubtitleConfig'] = self.subtitle_config.to_map()
        if self.super_reso is not None:
            result['SuperReso'] = self.super_reso.to_map()
        if self.tail_slate_list is not None:
            result['TailSlateList'] = self.tail_slate_list.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.video is not None:
            result['Video'] = self.video.to_map()
        if self.video_stream_map is not None:
            result['VideoStreamMap'] = self.video_stream_map
        if self.water_mark_config_url is not None:
            result['WaterMarkConfigUrl'] = self.water_mark_config_url
        if self.water_mark_list is not None:
            result['WaterMarkList'] = self.water_mark_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AmixList') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputAmixList()
            self.amix_list = temp_model.from_map(m['AmixList'])
        if m.get('Audio') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('AudioStreamMap') is not None:
            self.audio_stream_map = m.get('AudioStreamMap')
        if m.get('Clip') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputClip()
            self.clip = temp_model.from_map(m['Clip'])
        if m.get('Container') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('DeWatermark') is not None:
            self.de_watermark = m.get('DeWatermark')
        if m.get('Encryption') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputEncryption()
            self.encryption = temp_model.from_map(m['Encryption'])
        if m.get('M3U8NonStandardSupport') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport()
            self.m_3u8non_standard_support = temp_model.from_map(m['M3U8NonStandardSupport'])
        if m.get('MergeConfigUrl') is not None:
            self.merge_config_url = m.get('MergeConfigUrl')
        if m.get('MergeList') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputMergeList()
            self.merge_list = temp_model.from_map(m['MergeList'])
        if m.get('MuxConfig') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('OpeningList') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputOpeningList()
            self.opening_list = temp_model.from_map(m['OpeningList'])
        if m.get('OutSubtitleList') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputOutSubtitleList()
            self.out_subtitle_list = temp_model.from_map(m['OutSubtitleList'])
        if m.get('OutputFile') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputOutputFile()
            self.output_file = temp_model.from_map(m['OutputFile'])
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Properties') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputProperties()
            self.properties = temp_model.from_map(m['Properties'])
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('SubtitleConfig') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputSubtitleConfig()
            self.subtitle_config = temp_model.from_map(m['SubtitleConfig'])
        if m.get('SuperReso') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputSuperReso()
            self.super_reso = temp_model.from_map(m['SuperReso'])
        if m.get('TailSlateList') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputTailSlateList()
            self.tail_slate_list = temp_model.from_map(m['TailSlateList'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TransConfig') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('Video') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputVideo()
            self.video = temp_model.from_map(m['Video'])
        if m.get('VideoStreamMap') is not None:
            self.video_stream_map = m.get('VideoStreamMap')
        if m.get('WaterMarkConfigUrl') is not None:
            self.water_mark_config_url = m.get('WaterMarkConfigUrl')
        if m.get('WaterMarkList') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputWaterMarkList()
            self.water_mark_list = temp_model.from_map(m['WaterMarkList'])
        return self


class QueryJobListResponseBodyJobListJob(TeaModel):
    def __init__(
        self,
        code: str = None,
        creation_time: str = None,
        finish_time: str = None,
        input: QueryJobListResponseBodyJobListJobInput = None,
        job_id: str = None,
        mnsmessage_result: QueryJobListResponseBodyJobListJobMNSMessageResult = None,
        message: str = None,
        output: QueryJobListResponseBodyJobListJobOutput = None,
        percent: int = None,
        pipeline_id: str = None,
        state: str = None,
    ):
        self.code = code
        self.creation_time = creation_time
        self.finish_time = finish_time
        self.input = input
        self.job_id = job_id
        self.mnsmessage_result = mnsmessage_result
        self.message = message
        self.output = output
        self.percent = percent
        self.pipeline_id = pipeline_id
        self.state = state

    def validate(self):
        if self.input:
            self.input.validate()
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = QueryJobListResponseBodyJobListJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MNSMessageResult') is not None:
            temp_model = QueryJobListResponseBodyJobListJobMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Output') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class QueryJobListResponseBodyJobList(TeaModel):
    def __init__(
        self,
        job: List[QueryJobListResponseBodyJobListJob] = None,
    ):
        self.job = job

    def validate(self):
        if self.job:
            for k in self.job:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Job'] = []
        if self.job is not None:
            for k in self.job:
                result['Job'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.job = []
        if m.get('Job') is not None:
            for k in m.get('Job'):
                temp_model = QueryJobListResponseBodyJobListJob()
                self.job.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyNonExistJobIds(TeaModel):
    def __init__(
        self,
        string: List[str] = None,
    ):
        self.string = string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class QueryJobListResponseBody(TeaModel):
    def __init__(
        self,
        job_list: QueryJobListResponseBodyJobList = None,
        non_exist_job_ids: QueryJobListResponseBodyNonExistJobIds = None,
        request_id: str = None,
    ):
        self.job_list = job_list
        self.non_exist_job_ids = non_exist_job_ids
        self.request_id = request_id

    def validate(self):
        if self.job_list:
            self.job_list.validate()
        if self.non_exist_job_ids:
            self.non_exist_job_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_list is not None:
            result['JobList'] = self.job_list.to_map()
        if self.non_exist_job_ids is not None:
            result['NonExistJobIds'] = self.non_exist_job_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobList') is not None:
            temp_model = QueryJobListResponseBodyJobList()
            self.job_list = temp_model.from_map(m['JobList'])
        if m.get('NonExistJobIds') is not None:
            temp_model = QueryJobListResponseBodyNonExistJobIds()
            self.non_exist_job_ids = temp_model.from_map(m['NonExistJobIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryJobListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryJobListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryJobListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMediaInfoJobListRequest(TeaModel):
    def __init__(
        self,
        media_info_job_ids: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.media_info_job_ids = media_info_job_ids
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_info_job_ids is not None:
            result['MediaInfoJobIds'] = self.media_info_job_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaInfoJobIds') is not None:
            self.media_info_job_ids = m.get('MediaInfoJobIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        format_long_name: str = None,
        format_name: str = None,
        num_programs: str = None,
        num_streams: str = None,
        size: str = None,
        start_time: str = None,
    ):
        self.bitrate = bitrate
        self.duration = duration
        self.format_long_name = format_long_name
        self.format_name = format_name
        self.num_programs = num_programs
        self.num_streams = num_streams
        self.size = size
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.format_long_name is not None:
            result['FormatLongName'] = self.format_long_name
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.num_programs is not None:
            result['NumPrograms'] = self.num_programs
        if self.num_streams is not None:
            result['NumStreams'] = self.num_streams
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FormatLongName') is not None:
            self.format_long_name = m.get('FormatLongName')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('NumPrograms') is not None:
            self.num_programs = m.get('NumPrograms')
        if m.get('NumStreams') is not None:
            self.num_streams = m.get('NumStreams')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        num_frames: str = None,
        sample_fmt: str = None,
        samplerate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        self.bitrate = bitrate
        self.channel_layout = channel_layout
        self.channels = channels
        self.codec_long_name = codec_long_name
        self.codec_name = codec_name
        self.codec_tag = codec_tag
        self.codec_tag_string = codec_tag_string
        self.codec_time_base = codec_time_base
        self.duration = duration
        self.index = index
        self.lang = lang
        self.num_frames = num_frames
        self.sample_fmt = sample_fmt
        self.samplerate = samplerate
        self.start_time = start_time
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList(TeaModel):
    def __init__(
        self,
        audio_stream: List[QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream] = None,
    ):
        self.audio_stream = audio_stream

    def validate(self):
        if self.audio_stream:
            for k in self.audio_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStream'] = []
        if self.audio_stream is not None:
            for k in self.audio_stream:
                result['AudioStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream = []
        if m.get('AudioStream') is not None:
            for k in m.get('AudioStream'):
                temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream()
                self.audio_stream.append(temp_model.from_map(k))
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream(TeaModel):
    def __init__(
        self,
        index: str = None,
        lang: str = None,
    ):
        self.index = index
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList(TeaModel):
    def __init__(
        self,
        subtitle_stream: List[QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream] = None,
    ):
        self.subtitle_stream = subtitle_stream

    def validate(self):
        if self.subtitle_stream:
            for k in self.subtitle_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubtitleStream'] = []
        if self.subtitle_stream is not None:
            for k in self.subtitle_stream:
                result['SubtitleStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle_stream = []
        if m.get('SubtitleStream') is not None:
            for k in m.get('SubtitleStream'):
                temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream()
                self.subtitle_stream.append(temp_model.from_map(k))
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost(TeaModel):
    def __init__(
        self,
        avg_bitrate: str = None,
        cost_bandwidth: str = None,
        preload_time: str = None,
    ):
        self.avg_bitrate = avg_bitrate
        self.cost_bandwidth = cost_bandwidth
        self.preload_time = preload_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_bitrate is not None:
            result['AvgBitrate'] = self.avg_bitrate
        if self.cost_bandwidth is not None:
            result['CostBandwidth'] = self.cost_bandwidth
        if self.preload_time is not None:
            result['PreloadTime'] = self.preload_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgBitrate') is not None:
            self.avg_bitrate = m.get('AvgBitrate')
        if m.get('CostBandwidth') is not None:
            self.cost_bandwidth = m.get('CostBandwidth')
        if m.get('PreloadTime') is not None:
            self.preload_time = m.get('PreloadTime')
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bitrate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        network_cost: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        rotate: str = None,
        sar: str = None,
        start_time: str = None,
        timebase: str = None,
        width: str = None,
    ):
        self.avg_fps = avg_fps
        self.bitrate = bitrate
        self.codec_long_name = codec_long_name
        self.codec_name = codec_name
        self.codec_tag = codec_tag
        self.codec_tag_string = codec_tag_string
        self.codec_time_base = codec_time_base
        self.dar = dar
        self.duration = duration
        self.fps = fps
        self.has_bframes = has_bframes
        self.height = height
        self.index = index
        self.lang = lang
        self.level = level
        self.network_cost = network_cost
        self.num_frames = num_frames
        self.pix_fmt = pix_fmt
        self.profile = profile
        self.rotate = rotate
        self.sar = sar
        self.start_time = start_time
        self.timebase = timebase
        self.width = width

    def validate(self):
        if self.network_cost:
            self.network_cost.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['AvgFPS'] = self.avg_fps
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['HasBFrames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.network_cost is not None:
            result['NetworkCost'] = self.network_cost.to_map()
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgFPS') is not None:
            self.avg_fps = m.get('AvgFPS')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HasBFrames') is not None:
            self.has_bframes = m.get('HasBFrames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NetworkCost') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost()
            self.network_cost = temp_model.from_map(m['NetworkCost'])
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList(TeaModel):
    def __init__(
        self,
        video_stream: List[QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream] = None,
    ):
        self.video_stream = video_stream

    def validate(self):
        if self.video_stream:
            for k in self.video_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoStream'] = []
        if self.video_stream is not None:
            for k in self.video_stream:
                result['VideoStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_stream = []
        if m.get('VideoStream') is not None:
            for k in m.get('VideoStream'):
                temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream()
                self.video_stream.append(temp_model.from_map(k))
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams(TeaModel):
    def __init__(
        self,
        audio_stream_list: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList = None,
        subtitle_stream_list: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList = None,
        video_stream_list: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList = None,
    ):
        self.audio_stream_list = audio_stream_list
        self.subtitle_stream_list = subtitle_stream_list
        self.video_stream_list = video_stream_list

    def validate(self):
        if self.audio_stream_list:
            self.audio_stream_list.validate()
        if self.subtitle_stream_list:
            self.subtitle_stream_list.validate()
        if self.video_stream_list:
            self.video_stream_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_stream_list is not None:
            result['AudioStreamList'] = self.audio_stream_list.to_map()
        if self.subtitle_stream_list is not None:
            result['SubtitleStreamList'] = self.subtitle_stream_list.to_map()
        if self.video_stream_list is not None:
            result['VideoStreamList'] = self.video_stream_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioStreamList') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList()
            self.audio_stream_list = temp_model.from_map(m['AudioStreamList'])
        if m.get('SubtitleStreamList') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList()
            self.subtitle_stream_list = temp_model.from_map(m['SubtitleStreamList'])
        if m.get('VideoStreamList') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList()
            self.video_stream_list = temp_model.from_map(m['VideoStreamList'])
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_format: str = None,
        file_size: str = None,
        format: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat = None,
        fps: str = None,
        height: str = None,
        streams: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.duration = duration
        self.file_format = file_format
        self.file_size = file_size
        self.format = format
        self.fps = fps
        self.height = height
        self.streams = streams
        self.width = width

    def validate(self):
        if self.format:
            self.format.validate()
        if self.streams:
            self.streams.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_format is not None:
            result['FileFormat'] = self.file_format
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.format is not None:
            result['Format'] = self.format.to_map()
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.streams is not None:
            result['Streams'] = self.streams.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileFormat') is not None:
            self.file_format = m.get('FileFormat')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('Format') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat()
            self.format = temp_model.from_map(m['Format'])
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Streams') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams()
            self.streams = temp_model.from_map(m['Streams'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob(TeaModel):
    def __init__(
        self,
        async_: bool = None,
        code: str = None,
        creation_time: str = None,
        input: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput = None,
        job_id: str = None,
        mnsmessage_result: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult = None,
        message: str = None,
        pipeline_id: str = None,
        properties: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties = None,
        state: str = None,
        user_data: str = None,
    ):
        self.async_ = async_
        self.code = code
        self.creation_time = creation_time
        self.input = input
        self.job_id = job_id
        self.mnsmessage_result = mnsmessage_result
        self.message = message
        self.pipeline_id = pipeline_id
        self.properties = properties
        self.state = state
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()
        if self.properties:
            self.properties.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_ is not None:
            result['Async'] = self.async_
        if self.code is not None:
            result['Code'] = self.code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.properties is not None:
            result['Properties'] = self.properties.to_map()
        if self.state is not None:
            result['State'] = self.state
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Async') is not None:
            self.async_ = m.get('Async')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Input') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MNSMessageResult') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Properties') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties()
            self.properties = temp_model.from_map(m['Properties'])
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobList(TeaModel):
    def __init__(
        self,
        media_info_job: List[QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob] = None,
    ):
        self.media_info_job = media_info_job

    def validate(self):
        if self.media_info_job:
            for k in self.media_info_job:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MediaInfoJob'] = []
        if self.media_info_job is not None:
            for k in self.media_info_job:
                result['MediaInfoJob'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.media_info_job = []
        if m.get('MediaInfoJob') is not None:
            for k in m.get('MediaInfoJob'):
                temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob()
                self.media_info_job.append(temp_model.from_map(k))
        return self


class QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds(TeaModel):
    def __init__(
        self,
        string: List[str] = None,
    ):
        self.string = string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class QueryMediaInfoJobListResponseBody(TeaModel):
    def __init__(
        self,
        media_info_job_list: QueryMediaInfoJobListResponseBodyMediaInfoJobList = None,
        non_exist_media_info_job_ids: QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds = None,
        request_id: str = None,
    ):
        self.media_info_job_list = media_info_job_list
        self.non_exist_media_info_job_ids = non_exist_media_info_job_ids
        self.request_id = request_id

    def validate(self):
        if self.media_info_job_list:
            self.media_info_job_list.validate()
        if self.non_exist_media_info_job_ids:
            self.non_exist_media_info_job_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_info_job_list is not None:
            result['MediaInfoJobList'] = self.media_info_job_list.to_map()
        if self.non_exist_media_info_job_ids is not None:
            result['NonExistMediaInfoJobIds'] = self.non_exist_media_info_job_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaInfoJobList') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobList()
            self.media_info_job_list = temp_model.from_map(m['MediaInfoJobList'])
        if m.get('NonExistMediaInfoJobIds') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds()
            self.non_exist_media_info_job_ids = temp_model.from_map(m['NonExistMediaInfoJobIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryMediaInfoJobListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMediaInfoJobListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMediaInfoJobListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMediaListRequest(TeaModel):
    def __init__(
        self,
        include_media_info: bool = None,
        include_play_list: bool = None,
        include_snapshot_list: bool = None,
        include_summary_list: bool = None,
        media_ids: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        self.include_media_info = include_media_info
        self.include_play_list = include_play_list
        self.include_snapshot_list = include_snapshot_list
        self.include_summary_list = include_summary_list
        # This parameter is required.
        self.media_ids = media_ids
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.include_media_info is not None:
            result['IncludeMediaInfo'] = self.include_media_info
        if self.include_play_list is not None:
            result['IncludePlayList'] = self.include_play_list
        if self.include_snapshot_list is not None:
            result['IncludeSnapshotList'] = self.include_snapshot_list
        if self.include_summary_list is not None:
            result['IncludeSummaryList'] = self.include_summary_list
        if self.media_ids is not None:
            result['MediaIds'] = self.media_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IncludeMediaInfo') is not None:
            self.include_media_info = m.get('IncludeMediaInfo')
        if m.get('IncludePlayList') is not None:
            self.include_play_list = m.get('IncludePlayList')
        if m.get('IncludeSnapshotList') is not None:
            self.include_snapshot_list = m.get('IncludeSnapshotList')
        if m.get('IncludeSummaryList') is not None:
            self.include_summary_list = m.get('IncludeSummaryList')
        if m.get('MediaIds') is not None:
            self.media_ids = m.get('MediaIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryMediaListResponseBodyMediaListMediaFile(TeaModel):
    def __init__(
        self,
        state: str = None,
        url: str = None,
    ):
        self.state = state
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['State'] = self.state
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class QueryMediaListResponseBodyMediaListMediaMediaInfoFormat(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        format_long_name: str = None,
        format_name: str = None,
        num_programs: str = None,
        num_streams: str = None,
        size: str = None,
        start_time: str = None,
    ):
        self.bitrate = bitrate
        self.duration = duration
        self.format_long_name = format_long_name
        self.format_name = format_name
        self.num_programs = num_programs
        self.num_streams = num_streams
        self.size = size
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.format_long_name is not None:
            result['FormatLongName'] = self.format_long_name
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.num_programs is not None:
            result['NumPrograms'] = self.num_programs
        if self.num_streams is not None:
            result['NumStreams'] = self.num_streams
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FormatLongName') is not None:
            self.format_long_name = m.get('FormatLongName')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('NumPrograms') is not None:
            self.num_programs = m.get('NumPrograms')
        if m.get('NumStreams') is not None:
            self.num_streams = m.get('NumStreams')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        num_frames: str = None,
        sample_fmt: str = None,
        samplerate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        self.bitrate = bitrate
        self.channel_layout = channel_layout
        self.channels = channels
        self.codec_long_name = codec_long_name
        self.codec_name = codec_name
        self.codec_tag = codec_tag
        self.codec_tag_string = codec_tag_string
        self.codec_time_base = codec_time_base
        self.duration = duration
        self.index = index
        self.lang = lang
        self.num_frames = num_frames
        self.sample_fmt = sample_fmt
        self.samplerate = samplerate
        self.start_time = start_time
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList(TeaModel):
    def __init__(
        self,
        audio_stream: List[QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream] = None,
    ):
        self.audio_stream = audio_stream

    def validate(self):
        if self.audio_stream:
            for k in self.audio_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStream'] = []
        if self.audio_stream is not None:
            for k in self.audio_stream:
                result['AudioStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream = []
        if m.get('AudioStream') is not None:
            for k in m.get('AudioStream'):
                temp_model = QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream()
                self.audio_stream.append(temp_model.from_map(k))
        return self


class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream(TeaModel):
    def __init__(
        self,
        index: str = None,
        lang: str = None,
    ):
        self.index = index
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList(TeaModel):
    def __init__(
        self,
        subtitle_stream: List[QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream] = None,
    ):
        self.subtitle_stream = subtitle_stream

    def validate(self):
        if self.subtitle_stream:
            for k in self.subtitle_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubtitleStream'] = []
        if self.subtitle_stream is not None:
            for k in self.subtitle_stream:
                result['SubtitleStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle_stream = []
        if m.get('SubtitleStream') is not None:
            for k in m.get('SubtitleStream'):
                temp_model = QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream()
                self.subtitle_stream.append(temp_model.from_map(k))
        return self


class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost(TeaModel):
    def __init__(
        self,
        avg_bitrate: str = None,
        cost_bandwidth: str = None,
        preload_time: str = None,
    ):
        self.avg_bitrate = avg_bitrate
        self.cost_bandwidth = cost_bandwidth
        self.preload_time = preload_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_bitrate is not None:
            result['AvgBitrate'] = self.avg_bitrate
        if self.cost_bandwidth is not None:
            result['CostBandwidth'] = self.cost_bandwidth
        if self.preload_time is not None:
            result['PreloadTime'] = self.preload_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgBitrate') is not None:
            self.avg_bitrate = m.get('AvgBitrate')
        if m.get('CostBandwidth') is not None:
            self.cost_bandwidth = m.get('CostBandwidth')
        if m.get('PreloadTime') is not None:
            self.preload_time = m.get('PreloadTime')
        return self


class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bitrate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        network_cost: QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        rotate: str = None,
        sar: str = None,
        start_time: str = None,
        timebase: str = None,
        width: str = None,
    ):
        self.avg_fps = avg_fps
        self.bitrate = bitrate
        self.codec_long_name = codec_long_name
        self.codec_name = codec_name
        self.codec_tag = codec_tag
        self.codec_tag_string = codec_tag_string
        self.codec_time_base = codec_time_base
        self.dar = dar
        self.duration = duration
        self.fps = fps
        self.has_bframes = has_bframes
        self.height = height
        self.index = index
        self.lang = lang
        self.level = level
        self.network_cost = network_cost
        self.num_frames = num_frames
        self.pix_fmt = pix_fmt
        self.profile = profile
        self.rotate = rotate
        self.sar = sar
        self.start_time = start_time
        self.timebase = timebase
        self.width = width

    def validate(self):
        if self.network_cost:
            self.network_cost.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['AvgFPS'] = self.avg_fps
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['HasBFrames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.network_cost is not None:
            result['NetworkCost'] = self.network_cost.to_map()
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgFPS') is not None:
            self.avg_fps = m.get('AvgFPS')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HasBFrames') is not None:
            self.has_bframes = m.get('HasBFrames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NetworkCost') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost()
            self.network_cost = temp_model.from_map(m['NetworkCost'])
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList(TeaModel):
    def __init__(
        self,
        video_stream: List[QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream] = None,
    ):
        self.video_stream = video_stream

    def validate(self):
        if self.video_stream:
            for k in self.video_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoStream'] = []
        if self.video_stream is not None:
            for k in self.video_stream:
                result['VideoStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_stream = []
        if m.get('VideoStream') is not None:
            for k in m.get('VideoStream'):
                temp_model = QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream()
                self.video_stream.append(temp_model.from_map(k))
        return self


class QueryMediaListResponseBodyMediaListMediaMediaInfoStreams(TeaModel):
    def __init__(
        self,
        audio_stream_list: QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList = None,
        subtitle_stream_list: QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList = None,
        video_stream_list: QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList = None,
    ):
        self.audio_stream_list = audio_stream_list
        self.subtitle_stream_list = subtitle_stream_list
        self.video_stream_list = video_stream_list

    def validate(self):
        if self.audio_stream_list:
            self.audio_stream_list.validate()
        if self.subtitle_stream_list:
            self.subtitle_stream_list.validate()
        if self.video_stream_list:
            self.video_stream_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_stream_list is not None:
            result['AudioStreamList'] = self.audio_stream_list.to_map()
        if self.subtitle_stream_list is not None:
            result['SubtitleStreamList'] = self.subtitle_stream_list.to_map()
        if self.video_stream_list is not None:
            result['VideoStreamList'] = self.video_stream_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioStreamList') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList()
            self.audio_stream_list = temp_model.from_map(m['AudioStreamList'])
        if m.get('SubtitleStreamList') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList()
            self.subtitle_stream_list = temp_model.from_map(m['SubtitleStreamList'])
        if m.get('VideoStreamList') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList()
            self.video_stream_list = temp_model.from_map(m['VideoStreamList'])
        return self


class QueryMediaListResponseBodyMediaListMediaMediaInfo(TeaModel):
    def __init__(
        self,
        format: QueryMediaListResponseBodyMediaListMediaMediaInfoFormat = None,
        streams: QueryMediaListResponseBodyMediaListMediaMediaInfoStreams = None,
    ):
        self.format = format
        self.streams = streams

    def validate(self):
        if self.format:
            self.format.validate()
        if self.streams:
            self.streams.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format.to_map()
        if self.streams is not None:
            result['Streams'] = self.streams.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaMediaInfoFormat()
            self.format = temp_model.from_map(m['Format'])
        if m.get('Streams') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaMediaInfoStreams()
            self.streams = temp_model.from_map(m['Streams'])
        return self


class QueryMediaListResponseBodyMediaListMediaPlayListPlayFile(TeaModel):
    def __init__(
        self,
        state: str = None,
        url: str = None,
    ):
        self.state = state
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['State'] = self.state
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class QueryMediaListResponseBodyMediaListMediaPlayListPlay(TeaModel):
    def __init__(
        self,
        activity_name: str = None,
        bitrate: str = None,
        duration: str = None,
        encryption: str = None,
        file: QueryMediaListResponseBodyMediaListMediaPlayListPlayFile = None,
        format: str = None,
        fps: str = None,
        height: str = None,
        media_workflow_id: str = None,
        media_workflow_name: str = None,
        size: str = None,
        width: str = None,
    ):
        self.activity_name = activity_name
        self.bitrate = bitrate
        self.duration = duration
        self.encryption = encryption
        self.file = file
        self.format = format
        self.fps = fps
        self.height = height
        self.media_workflow_id = media_workflow_id
        self.media_workflow_name = media_workflow_name
        self.size = size
        self.width = width

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_name is not None:
            result['ActivityName'] = self.activity_name
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.encryption is not None:
            result['Encryption'] = self.encryption
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.media_workflow_name is not None:
            result['MediaWorkflowName'] = self.media_workflow_name
        if self.size is not None:
            result['Size'] = self.size
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityName') is not None:
            self.activity_name = m.get('ActivityName')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Encryption') is not None:
            self.encryption = m.get('Encryption')
        if m.get('File') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaPlayListPlayFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('MediaWorkflowName') is not None:
            self.media_workflow_name = m.get('MediaWorkflowName')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryMediaListResponseBodyMediaListMediaPlayList(TeaModel):
    def __init__(
        self,
        play: List[QueryMediaListResponseBodyMediaListMediaPlayListPlay] = None,
    ):
        self.play = play

    def validate(self):
        if self.play:
            for k in self.play:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Play'] = []
        if self.play is not None:
            for k in self.play:
                result['Play'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.play = []
        if m.get('Play') is not None:
            for k in m.get('Play'):
                temp_model = QueryMediaListResponseBodyMediaListMediaPlayListPlay()
                self.play.append(temp_model.from_map(k))
        return self


class QueryMediaListResponseBodyMediaListMediaRunIdList(TeaModel):
    def __init__(
        self,
        run_id: List[str] = None,
    ):
        self.run_id = run_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.run_id is not None:
            result['RunId'] = self.run_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RunId') is not None:
            self.run_id = m.get('RunId')
        return self


class QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile(TeaModel):
    def __init__(
        self,
        state: str = None,
        url: str = None,
    ):
        self.state = state
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['State'] = self.state
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot(TeaModel):
    def __init__(
        self,
        activity_name: str = None,
        count: str = None,
        file: QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile = None,
        media_workflow_id: str = None,
        media_workflow_name: str = None,
        type: str = None,
    ):
        self.activity_name = activity_name
        self.count = count
        self.file = file
        self.media_workflow_id = media_workflow_id
        self.media_workflow_name = media_workflow_name
        self.type = type

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_name is not None:
            result['ActivityName'] = self.activity_name
        if self.count is not None:
            result['Count'] = self.count
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.media_workflow_name is not None:
            result['MediaWorkflowName'] = self.media_workflow_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityName') is not None:
            self.activity_name = m.get('ActivityName')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('File') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('MediaWorkflowName') is not None:
            self.media_workflow_name = m.get('MediaWorkflowName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryMediaListResponseBodyMediaListMediaSnapshotList(TeaModel):
    def __init__(
        self,
        snapshot: List[QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot] = None,
    ):
        self.snapshot = snapshot

    def validate(self):
        if self.snapshot:
            for k in self.snapshot:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Snapshot'] = []
        if self.snapshot is not None:
            for k in self.snapshot:
                result['Snapshot'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.snapshot = []
        if m.get('Snapshot') is not None:
            for k in m.get('Snapshot'):
                temp_model = QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot()
                self.snapshot.append(temp_model.from_map(k))
        return self


class QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile(TeaModel):
    def __init__(
        self,
        state: str = None,
        url: str = None,
    ):
        self.state = state
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['State'] = self.state
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class QueryMediaListResponseBodyMediaListMediaSummaryListSummary(TeaModel):
    def __init__(
        self,
        activity_name: str = None,
        file: QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile = None,
        media_workflow_id: str = None,
        media_workflow_name: str = None,
        type: str = None,
    ):
        self.activity_name = activity_name
        self.file = file
        self.media_workflow_id = media_workflow_id
        self.media_workflow_name = media_workflow_name
        self.type = type

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_name is not None:
            result['ActivityName'] = self.activity_name
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.media_workflow_name is not None:
            result['MediaWorkflowName'] = self.media_workflow_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityName') is not None:
            self.activity_name = m.get('ActivityName')
        if m.get('File') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('MediaWorkflowName') is not None:
            self.media_workflow_name = m.get('MediaWorkflowName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryMediaListResponseBodyMediaListMediaSummaryList(TeaModel):
    def __init__(
        self,
        summary: List[QueryMediaListResponseBodyMediaListMediaSummaryListSummary] = None,
    ):
        self.summary = summary

    def validate(self):
        if self.summary:
            for k in self.summary:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Summary'] = []
        if self.summary is not None:
            for k in self.summary:
                result['Summary'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.summary = []
        if m.get('Summary') is not None:
            for k in m.get('Summary'):
                temp_model = QueryMediaListResponseBodyMediaListMediaSummaryListSummary()
                self.summary.append(temp_model.from_map(k))
        return self


class QueryMediaListResponseBodyMediaListMediaTags(TeaModel):
    def __init__(
        self,
        tag: List[str] = None,
    ):
        self.tag = tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class QueryMediaListResponseBodyMediaListMedia(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        cate_id: int = None,
        censor_state: str = None,
        cover_url: str = None,
        creation_time: str = None,
        description: str = None,
        duration: str = None,
        file: QueryMediaListResponseBodyMediaListMediaFile = None,
        format: str = None,
        fps: str = None,
        height: str = None,
        media_id: str = None,
        media_info: QueryMediaListResponseBodyMediaListMediaMediaInfo = None,
        play_list: QueryMediaListResponseBodyMediaListMediaPlayList = None,
        publish_state: str = None,
        run_id_list: QueryMediaListResponseBodyMediaListMediaRunIdList = None,
        size: str = None,
        snapshot_list: QueryMediaListResponseBodyMediaListMediaSnapshotList = None,
        summary_list: QueryMediaListResponseBodyMediaListMediaSummaryList = None,
        tags: QueryMediaListResponseBodyMediaListMediaTags = None,
        title: str = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.cate_id = cate_id
        self.censor_state = censor_state
        self.cover_url = cover_url
        self.creation_time = creation_time
        self.description = description
        self.duration = duration
        self.file = file
        self.format = format
        self.fps = fps
        self.height = height
        self.media_id = media_id
        self.media_info = media_info
        self.play_list = play_list
        self.publish_state = publish_state
        self.run_id_list = run_id_list
        self.size = size
        self.snapshot_list = snapshot_list
        self.summary_list = summary_list
        self.tags = tags
        self.title = title
        self.width = width

    def validate(self):
        if self.file:
            self.file.validate()
        if self.media_info:
            self.media_info.validate()
        if self.play_list:
            self.play_list.validate()
        if self.run_id_list:
            self.run_id_list.validate()
        if self.snapshot_list:
            self.snapshot_list.validate()
        if self.summary_list:
            self.summary_list.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.censor_state is not None:
            result['CensorState'] = self.censor_state
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_info is not None:
            result['MediaInfo'] = self.media_info.to_map()
        if self.play_list is not None:
            result['PlayList'] = self.play_list.to_map()
        if self.publish_state is not None:
            result['PublishState'] = self.publish_state
        if self.run_id_list is not None:
            result['RunIdList'] = self.run_id_list.to_map()
        if self.size is not None:
            result['Size'] = self.size
        if self.snapshot_list is not None:
            result['SnapshotList'] = self.snapshot_list.to_map()
        if self.summary_list is not None:
            result['SummaryList'] = self.summary_list.to_map()
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.title is not None:
            result['Title'] = self.title
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CensorState') is not None:
            self.censor_state = m.get('CensorState')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('File') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaInfo') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaMediaInfo()
            self.media_info = temp_model.from_map(m['MediaInfo'])
        if m.get('PlayList') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaPlayList()
            self.play_list = temp_model.from_map(m['PlayList'])
        if m.get('PublishState') is not None:
            self.publish_state = m.get('PublishState')
        if m.get('RunIdList') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaRunIdList()
            self.run_id_list = temp_model.from_map(m['RunIdList'])
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SnapshotList') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaSnapshotList()
            self.snapshot_list = temp_model.from_map(m['SnapshotList'])
        if m.get('SummaryList') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaSummaryList()
            self.summary_list = temp_model.from_map(m['SummaryList'])
        if m.get('Tags') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryMediaListResponseBodyMediaList(TeaModel):
    def __init__(
        self,
        media: List[QueryMediaListResponseBodyMediaListMedia] = None,
    ):
        self.media = media

    def validate(self):
        if self.media:
            for k in self.media:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Media'] = []
        if self.media is not None:
            for k in self.media:
                result['Media'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.media = []
        if m.get('Media') is not None:
            for k in m.get('Media'):
                temp_model = QueryMediaListResponseBodyMediaListMedia()
                self.media.append(temp_model.from_map(k))
        return self


class QueryMediaListResponseBodyNonExistMediaIds(TeaModel):
    def __init__(
        self,
        media_id: List[str] = None,
    ):
        self.media_id = media_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class QueryMediaListResponseBody(TeaModel):
    def __init__(
        self,
        media_list: QueryMediaListResponseBodyMediaList = None,
        non_exist_media_ids: QueryMediaListResponseBodyNonExistMediaIds = None,
        request_id: str = None,
    ):
        self.media_list = media_list
        self.non_exist_media_ids = non_exist_media_ids
        self.request_id = request_id

    def validate(self):
        if self.media_list:
            self.media_list.validate()
        if self.non_exist_media_ids:
            self.non_exist_media_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_list is not None:
            result['MediaList'] = self.media_list.to_map()
        if self.non_exist_media_ids is not None:
            result['NonExistMediaIds'] = self.non_exist_media_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaList') is not None:
            temp_model = QueryMediaListResponseBodyMediaList()
            self.media_list = temp_model.from_map(m['MediaList'])
        if m.get('NonExistMediaIds') is not None:
            temp_model = QueryMediaListResponseBodyNonExistMediaIds()
            self.non_exist_media_ids = temp_model.from_map(m['NonExistMediaIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryMediaListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMediaListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMediaListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMediaListByURLRequest(TeaModel):
    def __init__(
        self,
        file_urls: str = None,
        include_media_info: bool = None,
        include_play_list: bool = None,
        include_snapshot_list: bool = None,
        include_summary_list: bool = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.file_urls = file_urls
        self.include_media_info = include_media_info
        self.include_play_list = include_play_list
        self.include_snapshot_list = include_snapshot_list
        self.include_summary_list = include_summary_list
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_urls is not None:
            result['FileURLs'] = self.file_urls
        if self.include_media_info is not None:
            result['IncludeMediaInfo'] = self.include_media_info
        if self.include_play_list is not None:
            result['IncludePlayList'] = self.include_play_list
        if self.include_snapshot_list is not None:
            result['IncludeSnapshotList'] = self.include_snapshot_list
        if self.include_summary_list is not None:
            result['IncludeSummaryList'] = self.include_summary_list
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileURLs') is not None:
            self.file_urls = m.get('FileURLs')
        if m.get('IncludeMediaInfo') is not None:
            self.include_media_info = m.get('IncludeMediaInfo')
        if m.get('IncludePlayList') is not None:
            self.include_play_list = m.get('IncludePlayList')
        if m.get('IncludeSnapshotList') is not None:
            self.include_snapshot_list = m.get('IncludeSnapshotList')
        if m.get('IncludeSummaryList') is not None:
            self.include_summary_list = m.get('IncludeSummaryList')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaFile(TeaModel):
    def __init__(
        self,
        state: str = None,
        url: str = None,
    ):
        self.state = state
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['State'] = self.state
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        format_long_name: str = None,
        format_name: str = None,
        num_programs: str = None,
        num_streams: str = None,
        size: str = None,
        start_time: str = None,
    ):
        self.bitrate = bitrate
        self.duration = duration
        self.format_long_name = format_long_name
        self.format_name = format_name
        self.num_programs = num_programs
        self.num_streams = num_streams
        self.size = size
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.format_long_name is not None:
            result['FormatLongName'] = self.format_long_name
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.num_programs is not None:
            result['NumPrograms'] = self.num_programs
        if self.num_streams is not None:
            result['NumStreams'] = self.num_streams
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FormatLongName') is not None:
            self.format_long_name = m.get('FormatLongName')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('NumPrograms') is not None:
            self.num_programs = m.get('NumPrograms')
        if m.get('NumStreams') is not None:
            self.num_streams = m.get('NumStreams')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        num_frames: str = None,
        sample_fmt: str = None,
        samplerate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        self.bitrate = bitrate
        self.channel_layout = channel_layout
        self.channels = channels
        self.codec_long_name = codec_long_name
        self.codec_name = codec_name
        self.codec_tag = codec_tag
        self.codec_tag_string = codec_tag_string
        self.codec_time_base = codec_time_base
        self.duration = duration
        self.index = index
        self.lang = lang
        self.num_frames = num_frames
        self.sample_fmt = sample_fmt
        self.samplerate = samplerate
        self.start_time = start_time
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList(TeaModel):
    def __init__(
        self,
        audio_stream: List[QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream] = None,
    ):
        self.audio_stream = audio_stream

    def validate(self):
        if self.audio_stream:
            for k in self.audio_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStream'] = []
        if self.audio_stream is not None:
            for k in self.audio_stream:
                result['AudioStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream = []
        if m.get('AudioStream') is not None:
            for k in m.get('AudioStream'):
                temp_model = QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream()
                self.audio_stream.append(temp_model.from_map(k))
        return self


class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream(TeaModel):
    def __init__(
        self,
        index: str = None,
        lang: str = None,
    ):
        self.index = index
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList(TeaModel):
    def __init__(
        self,
        subtitle_stream: List[QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream] = None,
    ):
        self.subtitle_stream = subtitle_stream

    def validate(self):
        if self.subtitle_stream:
            for k in self.subtitle_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubtitleStream'] = []
        if self.subtitle_stream is not None:
            for k in self.subtitle_stream:
                result['SubtitleStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle_stream = []
        if m.get('SubtitleStream') is not None:
            for k in m.get('SubtitleStream'):
                temp_model = QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream()
                self.subtitle_stream.append(temp_model.from_map(k))
        return self


class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost(TeaModel):
    def __init__(
        self,
        avg_bitrate: str = None,
        cost_bandwidth: str = None,
        preload_time: str = None,
    ):
        self.avg_bitrate = avg_bitrate
        self.cost_bandwidth = cost_bandwidth
        self.preload_time = preload_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_bitrate is not None:
            result['AvgBitrate'] = self.avg_bitrate
        if self.cost_bandwidth is not None:
            result['CostBandwidth'] = self.cost_bandwidth
        if self.preload_time is not None:
            result['PreloadTime'] = self.preload_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgBitrate') is not None:
            self.avg_bitrate = m.get('AvgBitrate')
        if m.get('CostBandwidth') is not None:
            self.cost_bandwidth = m.get('CostBandwidth')
        if m.get('PreloadTime') is not None:
            self.preload_time = m.get('PreloadTime')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bitrate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        network_cost: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        rotate: str = None,
        sar: str = None,
        start_time: str = None,
        timebase: str = None,
        width: str = None,
    ):
        self.avg_fps = avg_fps
        self.bitrate = bitrate
        self.codec_long_name = codec_long_name
        self.codec_name = codec_name
        self.codec_tag = codec_tag
        self.codec_tag_string = codec_tag_string
        self.codec_time_base = codec_time_base
        self.dar = dar
        self.duration = duration
        self.fps = fps
        self.has_bframes = has_bframes
        self.height = height
        self.index = index
        self.lang = lang
        self.level = level
        self.network_cost = network_cost
        self.num_frames = num_frames
        self.pix_fmt = pix_fmt
        self.profile = profile
        self.rotate = rotate
        self.sar = sar
        self.start_time = start_time
        self.timebase = timebase
        self.width = width

    def validate(self):
        if self.network_cost:
            self.network_cost.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['AvgFPS'] = self.avg_fps
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['HasBFrames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.network_cost is not None:
            result['NetworkCost'] = self.network_cost.to_map()
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgFPS') is not None:
            self.avg_fps = m.get('AvgFPS')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HasBFrames') is not None:
            self.has_bframes = m.get('HasBFrames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NetworkCost') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost()
            self.network_cost = temp_model.from_map(m['NetworkCost'])
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList(TeaModel):
    def __init__(
        self,
        video_stream: List[QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream] = None,
    ):
        self.video_stream = video_stream

    def validate(self):
        if self.video_stream:
            for k in self.video_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoStream'] = []
        if self.video_stream is not None:
            for k in self.video_stream:
                result['VideoStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_stream = []
        if m.get('VideoStream') is not None:
            for k in m.get('VideoStream'):
                temp_model = QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream()
                self.video_stream.append(temp_model.from_map(k))
        return self


class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams(TeaModel):
    def __init__(
        self,
        audio_stream_list: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList = None,
        subtitle_stream_list: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList = None,
        video_stream_list: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList = None,
    ):
        self.audio_stream_list = audio_stream_list
        self.subtitle_stream_list = subtitle_stream_list
        self.video_stream_list = video_stream_list

    def validate(self):
        if self.audio_stream_list:
            self.audio_stream_list.validate()
        if self.subtitle_stream_list:
            self.subtitle_stream_list.validate()
        if self.video_stream_list:
            self.video_stream_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_stream_list is not None:
            result['AudioStreamList'] = self.audio_stream_list.to_map()
        if self.subtitle_stream_list is not None:
            result['SubtitleStreamList'] = self.subtitle_stream_list.to_map()
        if self.video_stream_list is not None:
            result['VideoStreamList'] = self.video_stream_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioStreamList') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList()
            self.audio_stream_list = temp_model.from_map(m['AudioStreamList'])
        if m.get('SubtitleStreamList') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList()
            self.subtitle_stream_list = temp_model.from_map(m['SubtitleStreamList'])
        if m.get('VideoStreamList') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList()
            self.video_stream_list = temp_model.from_map(m['VideoStreamList'])
        return self


class QueryMediaListByURLResponseBodyMediaListMediaMediaInfo(TeaModel):
    def __init__(
        self,
        format: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat = None,
        streams: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams = None,
    ):
        self.format = format
        self.streams = streams

    def validate(self):
        if self.format:
            self.format.validate()
        if self.streams:
            self.streams.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format.to_map()
        if self.streams is not None:
            result['Streams'] = self.streams.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat()
            self.format = temp_model.from_map(m['Format'])
        if m.get('Streams') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams()
            self.streams = temp_model.from_map(m['Streams'])
        return self


class QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile(TeaModel):
    def __init__(
        self,
        state: str = None,
        url: str = None,
    ):
        self.state = state
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['State'] = self.state
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay(TeaModel):
    def __init__(
        self,
        activity_name: str = None,
        bitrate: str = None,
        duration: str = None,
        encryption: str = None,
        file: QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile = None,
        format: str = None,
        fps: str = None,
        height: str = None,
        media_workflow_id: str = None,
        media_workflow_name: str = None,
        size: str = None,
        width: str = None,
    ):
        self.activity_name = activity_name
        self.bitrate = bitrate
        self.duration = duration
        self.encryption = encryption
        self.file = file
        self.format = format
        self.fps = fps
        self.height = height
        self.media_workflow_id = media_workflow_id
        self.media_workflow_name = media_workflow_name
        self.size = size
        self.width = width

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_name is not None:
            result['ActivityName'] = self.activity_name
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.encryption is not None:
            result['Encryption'] = self.encryption
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.media_workflow_name is not None:
            result['MediaWorkflowName'] = self.media_workflow_name
        if self.size is not None:
            result['Size'] = self.size
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityName') is not None:
            self.activity_name = m.get('ActivityName')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Encryption') is not None:
            self.encryption = m.get('Encryption')
        if m.get('File') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('MediaWorkflowName') is not None:
            self.media_workflow_name = m.get('MediaWorkflowName')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaPlayList(TeaModel):
    def __init__(
        self,
        play: List[QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay] = None,
    ):
        self.play = play

    def validate(self):
        if self.play:
            for k in self.play:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Play'] = []
        if self.play is not None:
            for k in self.play:
                result['Play'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.play = []
        if m.get('Play') is not None:
            for k in m.get('Play'):
                temp_model = QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay()
                self.play.append(temp_model.from_map(k))
        return self


class QueryMediaListByURLResponseBodyMediaListMediaRunIdList(TeaModel):
    def __init__(
        self,
        run_id: List[str] = None,
    ):
        self.run_id = run_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.run_id is not None:
            result['RunId'] = self.run_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RunId') is not None:
            self.run_id = m.get('RunId')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile(TeaModel):
    def __init__(
        self,
        state: str = None,
        url: str = None,
    ):
        self.state = state
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['State'] = self.state
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot(TeaModel):
    def __init__(
        self,
        activity_name: str = None,
        count: str = None,
        file: QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile = None,
        media_workflow_id: str = None,
        media_workflow_name: str = None,
        type: str = None,
    ):
        self.activity_name = activity_name
        self.count = count
        self.file = file
        self.media_workflow_id = media_workflow_id
        self.media_workflow_name = media_workflow_name
        self.type = type

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_name is not None:
            result['ActivityName'] = self.activity_name
        if self.count is not None:
            result['Count'] = self.count
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.media_workflow_name is not None:
            result['MediaWorkflowName'] = self.media_workflow_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityName') is not None:
            self.activity_name = m.get('ActivityName')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('File') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('MediaWorkflowName') is not None:
            self.media_workflow_name = m.get('MediaWorkflowName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaSnapshotList(TeaModel):
    def __init__(
        self,
        snapshot: List[QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot] = None,
    ):
        self.snapshot = snapshot

    def validate(self):
        if self.snapshot:
            for k in self.snapshot:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Snapshot'] = []
        if self.snapshot is not None:
            for k in self.snapshot:
                result['Snapshot'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.snapshot = []
        if m.get('Snapshot') is not None:
            for k in m.get('Snapshot'):
                temp_model = QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot()
                self.snapshot.append(temp_model.from_map(k))
        return self


class QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile(TeaModel):
    def __init__(
        self,
        state: str = None,
        url: str = None,
    ):
        self.state = state
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['State'] = self.state
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary(TeaModel):
    def __init__(
        self,
        activity_name: str = None,
        file: QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile = None,
        media_workflow_id: str = None,
        media_workflow_name: str = None,
        type: str = None,
    ):
        self.activity_name = activity_name
        self.file = file
        self.media_workflow_id = media_workflow_id
        self.media_workflow_name = media_workflow_name
        self.type = type

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_name is not None:
            result['ActivityName'] = self.activity_name
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.media_workflow_name is not None:
            result['MediaWorkflowName'] = self.media_workflow_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityName') is not None:
            self.activity_name = m.get('ActivityName')
        if m.get('File') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('MediaWorkflowName') is not None:
            self.media_workflow_name = m.get('MediaWorkflowName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaSummaryList(TeaModel):
    def __init__(
        self,
        summary: List[QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary] = None,
    ):
        self.summary = summary

    def validate(self):
        if self.summary:
            for k in self.summary:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Summary'] = []
        if self.summary is not None:
            for k in self.summary:
                result['Summary'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.summary = []
        if m.get('Summary') is not None:
            for k in m.get('Summary'):
                temp_model = QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary()
                self.summary.append(temp_model.from_map(k))
        return self


class QueryMediaListByURLResponseBodyMediaListMediaTags(TeaModel):
    def __init__(
        self,
        tag: List[str] = None,
    ):
        self.tag = tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class QueryMediaListByURLResponseBodyMediaListMedia(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        cate_id: int = None,
        censor_state: str = None,
        cover_url: str = None,
        creation_time: str = None,
        description: str = None,
        duration: str = None,
        file: QueryMediaListByURLResponseBodyMediaListMediaFile = None,
        format: str = None,
        fps: str = None,
        height: str = None,
        media_id: str = None,
        media_info: QueryMediaListByURLResponseBodyMediaListMediaMediaInfo = None,
        play_list: QueryMediaListByURLResponseBodyMediaListMediaPlayList = None,
        publish_state: str = None,
        run_id_list: QueryMediaListByURLResponseBodyMediaListMediaRunIdList = None,
        size: str = None,
        snapshot_list: QueryMediaListByURLResponseBodyMediaListMediaSnapshotList = None,
        summary_list: QueryMediaListByURLResponseBodyMediaListMediaSummaryList = None,
        tags: QueryMediaListByURLResponseBodyMediaListMediaTags = None,
        title: str = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.cate_id = cate_id
        self.censor_state = censor_state
        self.cover_url = cover_url
        self.creation_time = creation_time
        self.description = description
        self.duration = duration
        self.file = file
        self.format = format
        self.fps = fps
        self.height = height
        self.media_id = media_id
        self.media_info = media_info
        self.play_list = play_list
        self.publish_state = publish_state
        self.run_id_list = run_id_list
        self.size = size
        self.snapshot_list = snapshot_list
        self.summary_list = summary_list
        self.tags = tags
        self.title = title
        self.width = width

    def validate(self):
        if self.file:
            self.file.validate()
        if self.media_info:
            self.media_info.validate()
        if self.play_list:
            self.play_list.validate()
        if self.run_id_list:
            self.run_id_list.validate()
        if self.snapshot_list:
            self.snapshot_list.validate()
        if self.summary_list:
            self.summary_list.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.censor_state is not None:
            result['CensorState'] = self.censor_state
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_info is not None:
            result['MediaInfo'] = self.media_info.to_map()
        if self.play_list is not None:
            result['PlayList'] = self.play_list.to_map()
        if self.publish_state is not None:
            result['PublishState'] = self.publish_state
        if self.run_id_list is not None:
            result['RunIdList'] = self.run_id_list.to_map()
        if self.size is not None:
            result['Size'] = self.size
        if self.snapshot_list is not None:
            result['SnapshotList'] = self.snapshot_list.to_map()
        if self.summary_list is not None:
            result['SummaryList'] = self.summary_list.to_map()
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.title is not None:
            result['Title'] = self.title
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CensorState') is not None:
            self.censor_state = m.get('CensorState')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('File') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaInfo') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaMediaInfo()
            self.media_info = temp_model.from_map(m['MediaInfo'])
        if m.get('PlayList') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaPlayList()
            self.play_list = temp_model.from_map(m['PlayList'])
        if m.get('PublishState') is not None:
            self.publish_state = m.get('PublishState')
        if m.get('RunIdList') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaRunIdList()
            self.run_id_list = temp_model.from_map(m['RunIdList'])
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SnapshotList') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaSnapshotList()
            self.snapshot_list = temp_model.from_map(m['SnapshotList'])
        if m.get('SummaryList') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaSummaryList()
            self.summary_list = temp_model.from_map(m['SummaryList'])
        if m.get('Tags') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryMediaListByURLResponseBodyMediaList(TeaModel):
    def __init__(
        self,
        media: List[QueryMediaListByURLResponseBodyMediaListMedia] = None,
    ):
        self.media = media

    def validate(self):
        if self.media:
            for k in self.media:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Media'] = []
        if self.media is not None:
            for k in self.media:
                result['Media'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.media = []
        if m.get('Media') is not None:
            for k in m.get('Media'):
                temp_model = QueryMediaListByURLResponseBodyMediaListMedia()
                self.media.append(temp_model.from_map(k))
        return self


class QueryMediaListByURLResponseBodyNonExistFileURLs(TeaModel):
    def __init__(
        self,
        file_url: List[str] = None,
    ):
        self.file_url = file_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileURL'] = self.file_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileURL') is not None:
            self.file_url = m.get('FileURL')
        return self


class QueryMediaListByURLResponseBody(TeaModel):
    def __init__(
        self,
        media_list: QueryMediaListByURLResponseBodyMediaList = None,
        non_exist_file_urls: QueryMediaListByURLResponseBodyNonExistFileURLs = None,
        request_id: str = None,
    ):
        self.media_list = media_list
        self.non_exist_file_urls = non_exist_file_urls
        self.request_id = request_id

    def validate(self):
        if self.media_list:
            self.media_list.validate()
        if self.non_exist_file_urls:
            self.non_exist_file_urls.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_list is not None:
            result['MediaList'] = self.media_list.to_map()
        if self.non_exist_file_urls is not None:
            result['NonExistFileURLs'] = self.non_exist_file_urls.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaList') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaList()
            self.media_list = temp_model.from_map(m['MediaList'])
        if m.get('NonExistFileURLs') is not None:
            temp_model = QueryMediaListByURLResponseBodyNonExistFileURLs()
            self.non_exist_file_urls = temp_model.from_map(m['NonExistFileURLs'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryMediaListByURLResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMediaListByURLResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMediaListByURLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMediaWorkflowExecutionListRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        run_ids: str = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # This parameter is required.
        self.run_ids = run_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.run_ids is not None:
            result['RunIds'] = self.run_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RunIds') is not None:
            self.run_ids = m.get('RunIds')
        return self


class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity(TeaModel):
    def __init__(
        self,
        code: str = None,
        end_time: str = None,
        job_id: str = None,
        mnsmessage_result: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult = None,
        message: str = None,
        name: str = None,
        start_time: str = None,
        state: str = None,
        type: str = None,
    ):
        self.code = code
        self.end_time = end_time
        self.job_id = job_id
        self.mnsmessage_result = mnsmessage_result
        self.message = message
        self.name = name
        self.start_time = start_time
        self.state = state
        self.type = type

    def validate(self):
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.name is not None:
            result['Name'] = self.name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.state is not None:
            result['State'] = self.state
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MNSMessageResult') is not None:
            temp_model = QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList(TeaModel):
    def __init__(
        self,
        activity: List[QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity] = None,
    ):
        self.activity = activity

    def validate(self):
        if self.activity:
            for k in self.activity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Activity'] = []
        if self.activity is not None:
            for k in self.activity:
                result['Activity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.activity = []
        if m.get('Activity') is not None:
            for k in m.get('Activity'):
                temp_model = QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity()
                self.activity.append(temp_model.from_map(k))
        return self


class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput(TeaModel):
    def __init__(
        self,
        input_file: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile = None,
        user_data: str = None,
    ):
        self.input_file = input_file
        self.user_data = user_data

    def validate(self):
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputFile') is not None:
            temp_model = QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution(TeaModel):
    def __init__(
        self,
        activity_list: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList = None,
        creation_time: str = None,
        input: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput = None,
        media_id: str = None,
        media_workflow_id: str = None,
        name: str = None,
        run_id: str = None,
        state: str = None,
    ):
        self.activity_list = activity_list
        self.creation_time = creation_time
        self.input = input
        self.media_id = media_id
        self.media_workflow_id = media_workflow_id
        self.name = name
        self.run_id = run_id
        self.state = state

    def validate(self):
        if self.activity_list:
            self.activity_list.validate()
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_list is not None:
            result['ActivityList'] = self.activity_list.to_map()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.name is not None:
            result['Name'] = self.name
        if self.run_id is not None:
            result['RunId'] = self.run_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityList') is not None:
            temp_model = QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList()
            self.activity_list = temp_model.from_map(m['ActivityList'])
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Input') is not None:
            temp_model = QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RunId') is not None:
            self.run_id = m.get('RunId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList(TeaModel):
    def __init__(
        self,
        media_workflow_execution: List[QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution] = None,
    ):
        self.media_workflow_execution = media_workflow_execution

    def validate(self):
        if self.media_workflow_execution:
            for k in self.media_workflow_execution:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MediaWorkflowExecution'] = []
        if self.media_workflow_execution is not None:
            for k in self.media_workflow_execution:
                result['MediaWorkflowExecution'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.media_workflow_execution = []
        if m.get('MediaWorkflowExecution') is not None:
            for k in m.get('MediaWorkflowExecution'):
                temp_model = QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution()
                self.media_workflow_execution.append(temp_model.from_map(k))
        return self


class QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds(TeaModel):
    def __init__(
        self,
        run_id: List[str] = None,
    ):
        self.run_id = run_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.run_id is not None:
            result['RunId'] = self.run_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RunId') is not None:
            self.run_id = m.get('RunId')
        return self


class QueryMediaWorkflowExecutionListResponseBody(TeaModel):
    def __init__(
        self,
        media_workflow_execution_list: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList = None,
        non_exist_run_ids: QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds = None,
        request_id: str = None,
    ):
        self.media_workflow_execution_list = media_workflow_execution_list
        self.non_exist_run_ids = non_exist_run_ids
        self.request_id = request_id

    def validate(self):
        if self.media_workflow_execution_list:
            self.media_workflow_execution_list.validate()
        if self.non_exist_run_ids:
            self.non_exist_run_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_execution_list is not None:
            result['MediaWorkflowExecutionList'] = self.media_workflow_execution_list.to_map()
        if self.non_exist_run_ids is not None:
            result['NonExistRunIds'] = self.non_exist_run_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowExecutionList') is not None:
            temp_model = QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList()
            self.media_workflow_execution_list = temp_model.from_map(m['MediaWorkflowExecutionList'])
        if m.get('NonExistRunIds') is not None:
            temp_model = QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds()
            self.non_exist_run_ids = temp_model.from_map(m['NonExistRunIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryMediaWorkflowExecutionListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMediaWorkflowExecutionListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMediaWorkflowExecutionListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMediaWorkflowListRequest(TeaModel):
    def __init__(
        self,
        media_workflow_ids: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.media_workflow_ids = media_workflow_ids
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_ids is not None:
            result['MediaWorkflowIds'] = self.media_workflow_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowIds') is not None:
            self.media_workflow_ids = m.get('MediaWorkflowIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        media_workflow_id: str = None,
        name: str = None,
        state: str = None,
        topology: str = None,
        trigger_mode: str = None,
    ):
        self.creation_time = creation_time
        self.media_workflow_id = media_workflow_id
        self.name = name
        self.state = state
        self.topology = topology
        self.trigger_mode = trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.topology is not None:
            result['Topology'] = self.topology
        if self.trigger_mode is not None:
            result['TriggerMode'] = self.trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Topology') is not None:
            self.topology = m.get('Topology')
        if m.get('TriggerMode') is not None:
            self.trigger_mode = m.get('TriggerMode')
        return self


class QueryMediaWorkflowListResponseBodyMediaWorkflowList(TeaModel):
    def __init__(
        self,
        media_workflow: List[QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow] = None,
    ):
        self.media_workflow = media_workflow

    def validate(self):
        if self.media_workflow:
            for k in self.media_workflow:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MediaWorkflow'] = []
        if self.media_workflow is not None:
            for k in self.media_workflow:
                result['MediaWorkflow'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.media_workflow = []
        if m.get('MediaWorkflow') is not None:
            for k in m.get('MediaWorkflow'):
                temp_model = QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow()
                self.media_workflow.append(temp_model.from_map(k))
        return self


class QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds(TeaModel):
    def __init__(
        self,
        media_workflow_id: List[str] = None,
    ):
        self.media_workflow_id = media_workflow_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        return self


class QueryMediaWorkflowListResponseBody(TeaModel):
    def __init__(
        self,
        media_workflow_list: QueryMediaWorkflowListResponseBodyMediaWorkflowList = None,
        non_exist_media_workflow_ids: QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds = None,
        request_id: str = None,
    ):
        self.media_workflow_list = media_workflow_list
        self.non_exist_media_workflow_ids = non_exist_media_workflow_ids
        self.request_id = request_id

    def validate(self):
        if self.media_workflow_list:
            self.media_workflow_list.validate()
        if self.non_exist_media_workflow_ids:
            self.non_exist_media_workflow_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_list is not None:
            result['MediaWorkflowList'] = self.media_workflow_list.to_map()
        if self.non_exist_media_workflow_ids is not None:
            result['NonExistMediaWorkflowIds'] = self.non_exist_media_workflow_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowList') is not None:
            temp_model = QueryMediaWorkflowListResponseBodyMediaWorkflowList()
            self.media_workflow_list = temp_model.from_map(m['MediaWorkflowList'])
        if m.get('NonExistMediaWorkflowIds') is not None:
            temp_model = QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds()
            self.non_exist_media_workflow_ids = temp_model.from_map(m['NonExistMediaWorkflowIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryMediaWorkflowListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMediaWorkflowListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMediaWorkflowListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryPipelineListRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_ids: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        # This parameter is required.
        self.pipeline_ids = pipeline_ids
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_ids is not None:
            result['PipelineIds'] = self.pipeline_ids
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineIds') is not None:
            self.pipeline_ids = m.get('PipelineIds')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryPipelineListResponseBodyNonExistPids(TeaModel):
    def __init__(
        self,
        string: List[str] = None,
    ):
        self.string = string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig(TeaModel):
    def __init__(
        self,
        queue_name: str = None,
        topic: str = None,
    ):
        self.queue_name = queue_name
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.queue_name is not None:
            result['QueueName'] = self.queue_name
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('QueueName') is not None:
            self.queue_name = m.get('QueueName')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class QueryPipelineListResponseBodyPipelineListPipeline(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        notify_config: QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig = None,
        role: str = None,
        speed: str = None,
        speed_level: int = None,
        state: str = None,
    ):
        self.id = id
        self.name = name
        self.notify_config = notify_config
        self.role = role
        self.speed = speed
        self.speed_level = speed_level
        self.state = state

    def validate(self):
        if self.notify_config:
            self.notify_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notify_config is not None:
            result['NotifyConfig'] = self.notify_config.to_map()
        if self.role is not None:
            result['Role'] = self.role
        if self.speed is not None:
            result['Speed'] = self.speed
        if self.speed_level is not None:
            result['SpeedLevel'] = self.speed_level
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotifyConfig') is not None:
            temp_model = QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig()
            self.notify_config = temp_model.from_map(m['NotifyConfig'])
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        if m.get('SpeedLevel') is not None:
            self.speed_level = m.get('SpeedLevel')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class QueryPipelineListResponseBodyPipelineList(TeaModel):
    def __init__(
        self,
        pipeline: List[QueryPipelineListResponseBodyPipelineListPipeline] = None,
    ):
        self.pipeline = pipeline

    def validate(self):
        if self.pipeline:
            for k in self.pipeline:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Pipeline'] = []
        if self.pipeline is not None:
            for k in self.pipeline:
                result['Pipeline'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.pipeline = []
        if m.get('Pipeline') is not None:
            for k in m.get('Pipeline'):
                temp_model = QueryPipelineListResponseBodyPipelineListPipeline()
                self.pipeline.append(temp_model.from_map(k))
        return self


class QueryPipelineListResponseBody(TeaModel):
    def __init__(
        self,
        non_exist_pids: QueryPipelineListResponseBodyNonExistPids = None,
        pipeline_list: QueryPipelineListResponseBodyPipelineList = None,
        request_id: str = None,
    ):
        self.non_exist_pids = non_exist_pids
        self.pipeline_list = pipeline_list
        self.request_id = request_id

    def validate(self):
        if self.non_exist_pids:
            self.non_exist_pids.validate()
        if self.pipeline_list:
            self.pipeline_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.non_exist_pids is not None:
            result['NonExistPids'] = self.non_exist_pids.to_map()
        if self.pipeline_list is not None:
            result['PipelineList'] = self.pipeline_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NonExistPids') is not None:
            temp_model = QueryPipelineListResponseBodyNonExistPids()
            self.non_exist_pids = temp_model.from_map(m['NonExistPids'])
        if m.get('PipelineList') is not None:
            temp_model = QueryPipelineListResponseBodyPipelineList()
            self.pipeline_list = temp_model.from_map(m['PipelineList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryPipelineListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryPipelineListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryPipelineListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySnapshotJobListRequest(TeaModel):
    def __init__(
        self,
        end_of_job_created_time_range: str = None,
        maximum_page_size: int = None,
        next_page_token: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        snapshot_job_ids: str = None,
        start_of_job_created_time_range: str = None,
        state: str = None,
    ):
        self.end_of_job_created_time_range = end_of_job_created_time_range
        self.maximum_page_size = maximum_page_size
        self.next_page_token = next_page_token
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        self.snapshot_job_ids = snapshot_job_ids
        self.start_of_job_created_time_range = start_of_job_created_time_range
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_of_job_created_time_range is not None:
            result['EndOfJobCreatedTimeRange'] = self.end_of_job_created_time_range
        if self.maximum_page_size is not None:
            result['MaximumPageSize'] = self.maximum_page_size
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.snapshot_job_ids is not None:
            result['SnapshotJobIds'] = self.snapshot_job_ids
        if self.start_of_job_created_time_range is not None:
            result['StartOfJobCreatedTimeRange'] = self.start_of_job_created_time_range
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndOfJobCreatedTimeRange') is not None:
            self.end_of_job_created_time_range = m.get('EndOfJobCreatedTimeRange')
        if m.get('MaximumPageSize') is not None:
            self.maximum_page_size = m.get('MaximumPageSize')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SnapshotJobIds') is not None:
            self.snapshot_job_ids = m.get('SnapshotJobIds')
        if m.get('StartOfJobCreatedTimeRange') is not None:
            self.start_of_job_created_time_range = m.get('StartOfJobCreatedTimeRange')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds(TeaModel):
    def __init__(
        self,
        string: List[str] = None,
    ):
        self.string = string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut(TeaModel):
    def __init__(
        self,
        cell_height: str = None,
        cell_sel_step: str = None,
        cell_width: str = None,
        color: str = None,
        columns: str = None,
        is_keep_cell_pic: str = None,
        lines: str = None,
        margin: str = None,
        padding: str = None,
    ):
        self.cell_height = cell_height
        self.cell_sel_step = cell_sel_step
        self.cell_width = cell_width
        self.color = color
        self.columns = columns
        self.is_keep_cell_pic = is_keep_cell_pic
        self.lines = lines
        self.margin = margin
        self.padding = padding

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cell_height is not None:
            result['CellHeight'] = self.cell_height
        if self.cell_sel_step is not None:
            result['CellSelStep'] = self.cell_sel_step
        if self.cell_width is not None:
            result['CellWidth'] = self.cell_width
        if self.color is not None:
            result['Color'] = self.color
        if self.columns is not None:
            result['Columns'] = self.columns
        if self.is_keep_cell_pic is not None:
            result['IsKeepCellPic'] = self.is_keep_cell_pic
        if self.lines is not None:
            result['Lines'] = self.lines
        if self.margin is not None:
            result['Margin'] = self.margin
        if self.padding is not None:
            result['Padding'] = self.padding
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CellHeight') is not None:
            self.cell_height = m.get('CellHeight')
        if m.get('CellSelStep') is not None:
            self.cell_sel_step = m.get('CellSelStep')
        if m.get('CellWidth') is not None:
            self.cell_width = m.get('CellWidth')
        if m.get('Color') is not None:
            self.color = m.get('Color')
        if m.get('Columns') is not None:
            self.columns = m.get('Columns')
        if m.get('IsKeepCellPic') is not None:
            self.is_keep_cell_pic = m.get('IsKeepCellPic')
        if m.get('Lines') is not None:
            self.lines = m.get('Lines')
        if m.get('Margin') is not None:
            self.margin = m.get('Margin')
        if m.get('Padding') is not None:
            self.padding = m.get('Padding')
        return self


class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig(TeaModel):
    def __init__(
        self,
        frame_type: str = None,
        height: str = None,
        interval: str = None,
        num: str = None,
        output_file: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile = None,
        tile_out: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut = None,
        tile_output_file: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile = None,
        time: str = None,
        width: str = None,
    ):
        self.frame_type = frame_type
        self.height = height
        self.interval = interval
        self.num = num
        self.output_file = output_file
        self.tile_out = tile_out
        self.tile_output_file = tile_output_file
        self.time = time
        self.width = width

    def validate(self):
        if self.output_file:
            self.output_file.validate()
        if self.tile_out:
            self.tile_out.validate()
        if self.tile_output_file:
            self.tile_output_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.frame_type is not None:
            result['FrameType'] = self.frame_type
        if self.height is not None:
            result['Height'] = self.height
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.num is not None:
            result['Num'] = self.num
        if self.output_file is not None:
            result['OutputFile'] = self.output_file.to_map()
        if self.tile_out is not None:
            result['TileOut'] = self.tile_out.to_map()
        if self.tile_output_file is not None:
            result['TileOutputFile'] = self.tile_output_file.to_map()
        if self.time is not None:
            result['Time'] = self.time
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FrameType') is not None:
            self.frame_type = m.get('FrameType')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('Num') is not None:
            self.num = m.get('Num')
        if m.get('OutputFile') is not None:
            temp_model = QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile()
            self.output_file = temp_model.from_map(m['OutputFile'])
        if m.get('TileOut') is not None:
            temp_model = QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut()
            self.tile_out = temp_model.from_map(m['TileOut'])
        if m.get('TileOutputFile') is not None:
            temp_model = QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile()
            self.tile_output_file = temp_model.from_map(m['TileOutputFile'])
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob(TeaModel):
    def __init__(
        self,
        code: str = None,
        count: str = None,
        creation_time: str = None,
        id: str = None,
        input: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput = None,
        mnsmessage_result: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult = None,
        message: str = None,
        pipeline_id: str = None,
        snapshot_config: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig = None,
        state: str = None,
        tile_count: str = None,
        user_data: str = None,
    ):
        self.code = code
        self.count = count
        self.creation_time = creation_time
        self.id = id
        self.input = input
        self.mnsmessage_result = mnsmessage_result
        self.message = message
        self.pipeline_id = pipeline_id
        self.snapshot_config = snapshot_config
        self.state = state
        self.tile_count = tile_count
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()
        if self.snapshot_config:
            self.snapshot_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.count is not None:
            result['Count'] = self.count
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.id is not None:
            result['Id'] = self.id
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.snapshot_config is not None:
            result['SnapshotConfig'] = self.snapshot_config.to_map()
        if self.state is not None:
            result['State'] = self.state
        if self.tile_count is not None:
            result['TileCount'] = self.tile_count
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Input') is not None:
            temp_model = QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('MNSMessageResult') is not None:
            temp_model = QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('SnapshotConfig') is not None:
            temp_model = QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig()
            self.snapshot_config = temp_model.from_map(m['SnapshotConfig'])
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TileCount') is not None:
            self.tile_count = m.get('TileCount')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class QuerySnapshotJobListResponseBodySnapshotJobList(TeaModel):
    def __init__(
        self,
        snapshot_job: List[QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob] = None,
    ):
        self.snapshot_job = snapshot_job

    def validate(self):
        if self.snapshot_job:
            for k in self.snapshot_job:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SnapshotJob'] = []
        if self.snapshot_job is not None:
            for k in self.snapshot_job:
                result['SnapshotJob'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.snapshot_job = []
        if m.get('SnapshotJob') is not None:
            for k in m.get('SnapshotJob'):
                temp_model = QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob()
                self.snapshot_job.append(temp_model.from_map(k))
        return self


class QuerySnapshotJobListResponseBody(TeaModel):
    def __init__(
        self,
        next_page_token: str = None,
        non_exist_snapshot_job_ids: QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds = None,
        request_id: str = None,
        snapshot_job_list: QuerySnapshotJobListResponseBodySnapshotJobList = None,
    ):
        self.next_page_token = next_page_token
        self.non_exist_snapshot_job_ids = non_exist_snapshot_job_ids
        self.request_id = request_id
        self.snapshot_job_list = snapshot_job_list

    def validate(self):
        if self.non_exist_snapshot_job_ids:
            self.non_exist_snapshot_job_ids.validate()
        if self.snapshot_job_list:
            self.snapshot_job_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.non_exist_snapshot_job_ids is not None:
            result['NonExistSnapshotJobIds'] = self.non_exist_snapshot_job_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snapshot_job_list is not None:
            result['SnapshotJobList'] = self.snapshot_job_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('NonExistSnapshotJobIds') is not None:
            temp_model = QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds()
            self.non_exist_snapshot_job_ids = temp_model.from_map(m['NonExistSnapshotJobIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnapshotJobList') is not None:
            temp_model = QuerySnapshotJobListResponseBodySnapshotJobList()
            self.snapshot_job_list = temp_model.from_map(m['SnapshotJobList'])
        return self


class QuerySnapshotJobListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySnapshotJobListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySnapshotJobListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryTemplateListRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        template_ids: str = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # This parameter is required.
        self.template_ids = template_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.template_ids is not None:
            result['TemplateIds'] = self.template_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TemplateIds') is not None:
            self.template_ids = m.get('TemplateIds')
        return self


class QueryTemplateListResponseBodyNonExistTids(TeaModel):
    def __init__(
        self,
        string: List[str] = None,
    ):
        self.string = string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class QueryTemplateListResponseBodyTemplateListTemplateAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        qscale: str = None,
        remove: str = None,
        samplerate: str = None,
    ):
        self.bitrate = bitrate
        self.channels = channels
        self.codec = codec
        self.profile = profile
        self.qscale = qscale
        self.remove = remove
        self.samplerate = samplerate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        return self


class QueryTemplateListResponseBodyTemplateListTemplateContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif(TeaModel):
    def __init__(
        self,
        dither_mode: str = None,
        final_delay: str = None,
        is_custom_palette: str = None,
        loop: str = None,
    ):
        self.dither_mode = dither_mode
        self.final_delay = final_delay
        self.is_custom_palette = is_custom_palette
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dither_mode is not None:
            result['DitherMode'] = self.dither_mode
        if self.final_delay is not None:
            result['FinalDelay'] = self.final_delay
        if self.is_custom_palette is not None:
            result['IsCustomPalette'] = self.is_custom_palette
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DitherMode') is not None:
            self.dither_mode = m.get('DitherMode')
        if m.get('FinalDelay') is not None:
            self.final_delay = m.get('FinalDelay')
        if m.get('IsCustomPalette') is not None:
            self.is_custom_palette = m.get('IsCustomPalette')
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
    ):
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp(TeaModel):
    def __init__(
        self,
        loop: str = None,
    ):
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class QueryTemplateListResponseBodyTemplateListTemplateMuxConfig(TeaModel):
    def __init__(
        self,
        gif: QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif = None,
        segment: QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment = None,
        webp: QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp = None,
    ):
        self.gif = gif
        self.segment = segment
        self.webp = webp

    def validate(self):
        if self.gif:
            self.gif.validate()
        if self.segment:
            self.segment.validate()
        if self.webp:
            self.webp.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gif is not None:
            result['Gif'] = self.gif.to_map()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        if self.webp is not None:
            result['Webp'] = self.webp.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gif') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif()
            self.gif = temp_model.from_map(m['Gif'])
        if m.get('Segment') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        if m.get('Webp') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp()
            self.webp = temp_model.from_map(m['Webp'])
        return self


class QueryTemplateListResponseBodyTemplateListTemplateTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        is_check_audio_bitrate: str = None,
        is_check_audio_bitrate_fail: str = None,
        is_check_reso: str = None,
        is_check_reso_fail: str = None,
        is_check_video_bitrate: str = None,
        is_check_video_bitrate_fail: str = None,
        trans_mode: str = None,
    ):
        self.adj_dar_method = adj_dar_method
        self.is_check_audio_bitrate = is_check_audio_bitrate
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        self.is_check_reso = is_check_reso
        self.is_check_reso_fail = is_check_reso_fail
        self.is_check_video_bitrate = is_check_video_bitrate
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd(TeaModel):
    def __init__(
        self,
        max: str = None,
        min: str = None,
    ):
        self.max = max
        self.min = min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        return self


class QueryTemplateListResponseBodyTemplateListTemplateVideo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        bitrate_bnd: QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        degrain: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        max_fps: str = None,
        maxrate: str = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        qscale: str = None,
        remove: str = None,
        reso_priority: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.bitrate_bnd = bitrate_bnd
        self.bufsize = bufsize
        self.codec = codec
        self.crf = crf
        self.crop = crop
        self.degrain = degrain
        self.fps = fps
        self.gop = gop
        self.height = height
        self.max_fps = max_fps
        self.maxrate = maxrate
        self.pad = pad
        self.pix_fmt = pix_fmt
        self.preset = preset
        self.profile = profile
        self.qscale = qscale
        self.remove = remove
        self.reso_priority = reso_priority
        self.scan_mode = scan_mode
        self.width = width

    def validate(self):
        if self.bitrate_bnd:
            self.bitrate_bnd.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bitrate_bnd is not None:
            result['BitrateBnd'] = self.bitrate_bnd.to_map()
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.degrain is not None:
            result['Degrain'] = self.degrain
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.max_fps is not None:
            result['MaxFps'] = self.max_fps
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.reso_priority is not None:
            result['ResoPriority'] = self.reso_priority
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BitrateBnd') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd()
            self.bitrate_bnd = temp_model.from_map(m['BitrateBnd'])
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Degrain') is not None:
            self.degrain = m.get('Degrain')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MaxFps') is not None:
            self.max_fps = m.get('MaxFps')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('ResoPriority') is not None:
            self.reso_priority = m.get('ResoPriority')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryTemplateListResponseBodyTemplateListTemplate(TeaModel):
    def __init__(
        self,
        audio: QueryTemplateListResponseBodyTemplateListTemplateAudio = None,
        container: QueryTemplateListResponseBodyTemplateListTemplateContainer = None,
        id: str = None,
        mux_config: QueryTemplateListResponseBodyTemplateListTemplateMuxConfig = None,
        name: str = None,
        state: str = None,
        trans_config: QueryTemplateListResponseBodyTemplateListTemplateTransConfig = None,
        video: QueryTemplateListResponseBodyTemplateListTemplateVideo = None,
    ):
        self.audio = audio
        self.container = container
        self.id = id
        self.mux_config = mux_config
        self.name = name
        self.state = state
        self.trans_config = trans_config
        self.video = video

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateListTemplateAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateListTemplateContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MuxConfig') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateListTemplateMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TransConfig') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateListTemplateTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('Video') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateListTemplateVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class QueryTemplateListResponseBodyTemplateList(TeaModel):
    def __init__(
        self,
        template: List[QueryTemplateListResponseBodyTemplateListTemplate] = None,
    ):
        self.template = template

    def validate(self):
        if self.template:
            for k in self.template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Template'] = []
        if self.template is not None:
            for k in self.template:
                result['Template'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.template = []
        if m.get('Template') is not None:
            for k in m.get('Template'):
                temp_model = QueryTemplateListResponseBodyTemplateListTemplate()
                self.template.append(temp_model.from_map(k))
        return self


class QueryTemplateListResponseBody(TeaModel):
    def __init__(
        self,
        non_exist_tids: QueryTemplateListResponseBodyNonExistTids = None,
        request_id: str = None,
        template_list: QueryTemplateListResponseBodyTemplateList = None,
    ):
        self.non_exist_tids = non_exist_tids
        self.request_id = request_id
        self.template_list = template_list

    def validate(self):
        if self.non_exist_tids:
            self.non_exist_tids.validate()
        if self.template_list:
            self.template_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.non_exist_tids is not None:
            result['NonExistTids'] = self.non_exist_tids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_list is not None:
            result['TemplateList'] = self.template_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NonExistTids') is not None:
            temp_model = QueryTemplateListResponseBodyNonExistTids()
            self.non_exist_tids = temp_model.from_map(m['NonExistTids'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateList') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateList()
            self.template_list = temp_model.from_map(m['TemplateList'])
        return self


class QueryTemplateListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryTemplateListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryTemplateListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryWaterMarkTemplateListRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        water_mark_template_ids: str = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # This parameter is required.
        self.water_mark_template_ids = water_mark_template_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.water_mark_template_ids is not None:
            result['WaterMarkTemplateIds'] = self.water_mark_template_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('WaterMarkTemplateIds') is not None:
            self.water_mark_template_ids = m.get('WaterMarkTemplateIds')
        return self


class QueryWaterMarkTemplateListResponseBodyNonExistWids(TeaModel):
    def __init__(
        self,
        string: List[str] = None,
    ):
        self.string = string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        width: str = None,
    ):
        self.dx = dx
        self.dy = dy
        self.height = height
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline(TeaModel):
    def __init__(
        self,
        duration: str = None,
        start: str = None,
    ):
        self.duration = duration
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        id: str = None,
        name: str = None,
        ratio_refer: QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer = None,
        refer_pos: str = None,
        state: str = None,
        timeline: QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline = None,
        type: str = None,
        width: str = None,
    ):
        self.dx = dx
        self.dy = dy
        self.height = height
        self.id = id
        self.name = name
        self.ratio_refer = ratio_refer
        self.refer_pos = refer_pos
        self.state = state
        self.timeline = timeline
        self.type = type
        self.width = width

    def validate(self):
        if self.ratio_refer:
            self.ratio_refer.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.ratio_refer is not None:
            result['RatioRefer'] = self.ratio_refer.to_map()
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.state is not None:
            result['State'] = self.state
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RatioRefer') is not None:
            temp_model = QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer()
            self.ratio_refer = temp_model.from_map(m['RatioRefer'])
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Timeline') is not None:
            temp_model = QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList(TeaModel):
    def __init__(
        self,
        water_mark_template: List[QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate] = None,
    ):
        self.water_mark_template = water_mark_template

    def validate(self):
        if self.water_mark_template:
            for k in self.water_mark_template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WaterMarkTemplate'] = []
        if self.water_mark_template is not None:
            for k in self.water_mark_template:
                result['WaterMarkTemplate'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.water_mark_template = []
        if m.get('WaterMarkTemplate') is not None:
            for k in m.get('WaterMarkTemplate'):
                temp_model = QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate()
                self.water_mark_template.append(temp_model.from_map(k))
        return self


class QueryWaterMarkTemplateListResponseBody(TeaModel):
    def __init__(
        self,
        non_exist_wids: QueryWaterMarkTemplateListResponseBodyNonExistWids = None,
        request_id: str = None,
        water_mark_template_list: QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList = None,
    ):
        self.non_exist_wids = non_exist_wids
        self.request_id = request_id
        self.water_mark_template_list = water_mark_template_list

    def validate(self):
        if self.non_exist_wids:
            self.non_exist_wids.validate()
        if self.water_mark_template_list:
            self.water_mark_template_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.non_exist_wids is not None:
            result['NonExistWids'] = self.non_exist_wids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.water_mark_template_list is not None:
            result['WaterMarkTemplateList'] = self.water_mark_template_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NonExistWids') is not None:
            temp_model = QueryWaterMarkTemplateListResponseBodyNonExistWids()
            self.non_exist_wids = temp_model.from_map(m['NonExistWids'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('WaterMarkTemplateList') is not None:
            temp_model = QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList()
            self.water_mark_template_list = temp_model.from_map(m['WaterMarkTemplateList'])
        return self


class QueryWaterMarkTemplateListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryWaterMarkTemplateListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryWaterMarkTemplateListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchMediaWorkflowRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        state_list: str = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.page_number = page_number
        self.page_size = page_size
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        self.state_list = state_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.state_list is not None:
            result['StateList'] = self.state_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StateList') is not None:
            self.state_list = m.get('StateList')
        return self


class SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        media_workflow_id: str = None,
        name: str = None,
        state: str = None,
        topology: str = None,
        trigger_mode: str = None,
    ):
        self.creation_time = creation_time
        self.media_workflow_id = media_workflow_id
        self.name = name
        self.state = state
        self.topology = topology
        self.trigger_mode = trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.topology is not None:
            result['Topology'] = self.topology
        if self.trigger_mode is not None:
            result['TriggerMode'] = self.trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Topology') is not None:
            self.topology = m.get('Topology')
        if m.get('TriggerMode') is not None:
            self.trigger_mode = m.get('TriggerMode')
        return self


class SearchMediaWorkflowResponseBodyMediaWorkflowList(TeaModel):
    def __init__(
        self,
        media_workflow: List[SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow] = None,
    ):
        self.media_workflow = media_workflow

    def validate(self):
        if self.media_workflow:
            for k in self.media_workflow:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MediaWorkflow'] = []
        if self.media_workflow is not None:
            for k in self.media_workflow:
                result['MediaWorkflow'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.media_workflow = []
        if m.get('MediaWorkflow') is not None:
            for k in m.get('MediaWorkflow'):
                temp_model = SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow()
                self.media_workflow.append(temp_model.from_map(k))
        return self


class SearchMediaWorkflowResponseBody(TeaModel):
    def __init__(
        self,
        media_workflow_list: SearchMediaWorkflowResponseBodyMediaWorkflowList = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.media_workflow_list = media_workflow_list
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.media_workflow_list:
            self.media_workflow_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_list is not None:
            result['MediaWorkflowList'] = self.media_workflow_list.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowList') is not None:
            temp_model = SearchMediaWorkflowResponseBodyMediaWorkflowList()
            self.media_workflow_list = temp_model.from_map(m['MediaWorkflowList'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchMediaWorkflowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchMediaWorkflowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchMediaWorkflowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchPipelineRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        state: str = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.page_number = page_number
        self.page_size = page_size
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class SearchPipelineResponseBodyPipelineListPipelineNotifyConfig(TeaModel):
    def __init__(
        self,
        queue_name: str = None,
        topic: str = None,
    ):
        self.queue_name = queue_name
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.queue_name is not None:
            result['QueueName'] = self.queue_name
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('QueueName') is not None:
            self.queue_name = m.get('QueueName')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class SearchPipelineResponseBodyPipelineListPipeline(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        notify_config: SearchPipelineResponseBodyPipelineListPipelineNotifyConfig = None,
        role: str = None,
        speed: str = None,
        speed_level: int = None,
        state: str = None,
    ):
        self.id = id
        self.name = name
        self.notify_config = notify_config
        self.role = role
        self.speed = speed
        self.speed_level = speed_level
        self.state = state

    def validate(self):
        if self.notify_config:
            self.notify_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notify_config is not None:
            result['NotifyConfig'] = self.notify_config.to_map()
        if self.role is not None:
            result['Role'] = self.role
        if self.speed is not None:
            result['Speed'] = self.speed
        if self.speed_level is not None:
            result['SpeedLevel'] = self.speed_level
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotifyConfig') is not None:
            temp_model = SearchPipelineResponseBodyPipelineListPipelineNotifyConfig()
            self.notify_config = temp_model.from_map(m['NotifyConfig'])
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        if m.get('SpeedLevel') is not None:
            self.speed_level = m.get('SpeedLevel')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class SearchPipelineResponseBodyPipelineList(TeaModel):
    def __init__(
        self,
        pipeline: List[SearchPipelineResponseBodyPipelineListPipeline] = None,
    ):
        self.pipeline = pipeline

    def validate(self):
        if self.pipeline:
            for k in self.pipeline:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Pipeline'] = []
        if self.pipeline is not None:
            for k in self.pipeline:
                result['Pipeline'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.pipeline = []
        if m.get('Pipeline') is not None:
            for k in m.get('Pipeline'):
                temp_model = SearchPipelineResponseBodyPipelineListPipeline()
                self.pipeline.append(temp_model.from_map(k))
        return self


class SearchPipelineResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        pipeline_list: SearchPipelineResponseBodyPipelineList = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.pipeline_list = pipeline_list
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.pipeline_list:
            self.pipeline_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pipeline_list is not None:
            result['PipelineList'] = self.pipeline_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PipelineList') is not None:
            temp_model = SearchPipelineResponseBodyPipelineList()
            self.pipeline_list = temp_model.from_map(m['PipelineList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchPipelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchPipelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchPipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchTemplateRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        state: str = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.page_number = page_number
        self.page_size = page_size
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class SearchTemplateResponseBodyTemplateListTemplateAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        qscale: str = None,
        remove: str = None,
        samplerate: str = None,
    ):
        self.bitrate = bitrate
        self.channels = channels
        self.codec = codec
        self.profile = profile
        self.qscale = qscale
        self.remove = remove
        self.samplerate = samplerate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        return self


class SearchTemplateResponseBodyTemplateListTemplateContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif(TeaModel):
    def __init__(
        self,
        dither_mode: str = None,
        final_delay: str = None,
        is_custom_palette: str = None,
        loop: str = None,
    ):
        self.dither_mode = dither_mode
        self.final_delay = final_delay
        self.is_custom_palette = is_custom_palette
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dither_mode is not None:
            result['DitherMode'] = self.dither_mode
        if self.final_delay is not None:
            result['FinalDelay'] = self.final_delay
        if self.is_custom_palette is not None:
            result['IsCustomPalette'] = self.is_custom_palette
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DitherMode') is not None:
            self.dither_mode = m.get('DitherMode')
        if m.get('FinalDelay') is not None:
            self.final_delay = m.get('FinalDelay')
        if m.get('IsCustomPalette') is not None:
            self.is_custom_palette = m.get('IsCustomPalette')
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
    ):
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class SearchTemplateResponseBodyTemplateListTemplateMuxConfig(TeaModel):
    def __init__(
        self,
        gif: SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif = None,
        segment: SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment = None,
    ):
        self.gif = gif
        self.segment = segment

    def validate(self):
        if self.gif:
            self.gif.validate()
        if self.segment:
            self.segment.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gif is not None:
            result['Gif'] = self.gif.to_map()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gif') is not None:
            temp_model = SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif()
            self.gif = temp_model.from_map(m['Gif'])
        if m.get('Segment') is not None:
            temp_model = SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        return self


class SearchTemplateResponseBodyTemplateListTemplateTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        is_check_audio_bitrate: str = None,
        is_check_audio_bitrate_fail: str = None,
        is_check_reso: str = None,
        is_check_reso_fail: str = None,
        is_check_video_bitrate: str = None,
        is_check_video_bitrate_fail: str = None,
        trans_mode: str = None,
    ):
        self.adj_dar_method = adj_dar_method
        self.is_check_audio_bitrate = is_check_audio_bitrate
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        self.is_check_reso = is_check_reso
        self.is_check_reso_fail = is_check_reso_fail
        self.is_check_video_bitrate = is_check_video_bitrate
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd(TeaModel):
    def __init__(
        self,
        max: str = None,
        min: str = None,
    ):
        self.max = max
        self.min = min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        return self


class SearchTemplateResponseBodyTemplateListTemplateVideo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        bitrate_bnd: SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        degrain: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        max_fps: str = None,
        maxrate: str = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        qscale: str = None,
        remove: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.bitrate_bnd = bitrate_bnd
        self.bufsize = bufsize
        self.codec = codec
        self.crf = crf
        self.crop = crop
        self.degrain = degrain
        self.fps = fps
        self.gop = gop
        self.height = height
        self.max_fps = max_fps
        self.maxrate = maxrate
        self.pad = pad
        self.pix_fmt = pix_fmt
        self.preset = preset
        self.profile = profile
        self.qscale = qscale
        self.remove = remove
        self.scan_mode = scan_mode
        self.width = width

    def validate(self):
        if self.bitrate_bnd:
            self.bitrate_bnd.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bitrate_bnd is not None:
            result['BitrateBnd'] = self.bitrate_bnd.to_map()
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.degrain is not None:
            result['Degrain'] = self.degrain
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.max_fps is not None:
            result['MaxFps'] = self.max_fps
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BitrateBnd') is not None:
            temp_model = SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd()
            self.bitrate_bnd = temp_model.from_map(m['BitrateBnd'])
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Degrain') is not None:
            self.degrain = m.get('Degrain')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MaxFps') is not None:
            self.max_fps = m.get('MaxFps')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SearchTemplateResponseBodyTemplateListTemplate(TeaModel):
    def __init__(
        self,
        audio: SearchTemplateResponseBodyTemplateListTemplateAudio = None,
        container: SearchTemplateResponseBodyTemplateListTemplateContainer = None,
        id: str = None,
        mux_config: SearchTemplateResponseBodyTemplateListTemplateMuxConfig = None,
        name: str = None,
        state: str = None,
        trans_config: SearchTemplateResponseBodyTemplateListTemplateTransConfig = None,
        video: SearchTemplateResponseBodyTemplateListTemplateVideo = None,
    ):
        self.audio = audio
        self.container = container
        self.id = id
        self.mux_config = mux_config
        self.name = name
        self.state = state
        self.trans_config = trans_config
        self.video = video

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = SearchTemplateResponseBodyTemplateListTemplateAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = SearchTemplateResponseBodyTemplateListTemplateContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MuxConfig') is not None:
            temp_model = SearchTemplateResponseBodyTemplateListTemplateMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TransConfig') is not None:
            temp_model = SearchTemplateResponseBodyTemplateListTemplateTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('Video') is not None:
            temp_model = SearchTemplateResponseBodyTemplateListTemplateVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class SearchTemplateResponseBodyTemplateList(TeaModel):
    def __init__(
        self,
        template: List[SearchTemplateResponseBodyTemplateListTemplate] = None,
    ):
        self.template = template

    def validate(self):
        if self.template:
            for k in self.template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Template'] = []
        if self.template is not None:
            for k in self.template:
                result['Template'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.template = []
        if m.get('Template') is not None:
            for k in m.get('Template'):
                temp_model = SearchTemplateResponseBodyTemplateListTemplate()
                self.template.append(temp_model.from_map(k))
        return self


class SearchTemplateResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        template_list: SearchTemplateResponseBodyTemplateList = None,
        total_count: int = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.template_list = template_list
        self.total_count = total_count

    def validate(self):
        if self.template_list:
            self.template_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_list is not None:
            result['TemplateList'] = self.template_list.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateList') is not None:
            temp_model = SearchTemplateResponseBodyTemplateList()
            self.template_list = temp_model.from_map(m['TemplateList'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchWaterMarkTemplateRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        state: str = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.page_number = page_number
        self.page_size = page_size
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        width: str = None,
    ):
        self.dx = dx
        self.dy = dy
        self.height = height
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline(TeaModel):
    def __init__(
        self,
        duration: str = None,
        start: str = None,
    ):
        self.duration = duration
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        id: str = None,
        name: str = None,
        ratio_refer: SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer = None,
        refer_pos: str = None,
        state: str = None,
        timeline: SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline = None,
        type: str = None,
        width: str = None,
    ):
        self.dx = dx
        self.dy = dy
        self.height = height
        self.id = id
        self.name = name
        self.ratio_refer = ratio_refer
        self.refer_pos = refer_pos
        self.state = state
        self.timeline = timeline
        self.type = type
        self.width = width

    def validate(self):
        if self.ratio_refer:
            self.ratio_refer.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.ratio_refer is not None:
            result['RatioRefer'] = self.ratio_refer.to_map()
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.state is not None:
            result['State'] = self.state
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RatioRefer') is not None:
            temp_model = SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer()
            self.ratio_refer = temp_model.from_map(m['RatioRefer'])
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Timeline') is not None:
            temp_model = SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList(TeaModel):
    def __init__(
        self,
        water_mark_template: List[SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate] = None,
    ):
        self.water_mark_template = water_mark_template

    def validate(self):
        if self.water_mark_template:
            for k in self.water_mark_template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WaterMarkTemplate'] = []
        if self.water_mark_template is not None:
            for k in self.water_mark_template:
                result['WaterMarkTemplate'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.water_mark_template = []
        if m.get('WaterMarkTemplate') is not None:
            for k in m.get('WaterMarkTemplate'):
                temp_model = SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate()
                self.water_mark_template.append(temp_model.from_map(k))
        return self


class SearchWaterMarkTemplateResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
        water_mark_template_list: SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total_count = total_count
        self.water_mark_template_list = water_mark_template_list

    def validate(self):
        if self.water_mark_template_list:
            self.water_mark_template_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.water_mark_template_list is not None:
            result['WaterMarkTemplateList'] = self.water_mark_template_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('WaterMarkTemplateList') is not None:
            temp_model = SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList()
            self.water_mark_template_list = temp_model.from_map(m['WaterMarkTemplateList'])
        return self


class SearchWaterMarkTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchWaterMarkTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchWaterMarkTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitAnalysisJobRequest(TeaModel):
    def __init__(
        self,
        analysis_config: str = None,
        input: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        priority: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        user_data: str = None,
    ):
        self.analysis_config = analysis_config
        # This parameter is required.
        self.input = input
        self.owner_account = owner_account
        self.owner_id = owner_id
        # This parameter is required.
        self.pipeline_id = pipeline_id
        self.priority = priority
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis_config is not None:
            result['AnalysisConfig'] = self.analysis_config
        if self.input is not None:
            result['Input'] = self.input
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnalysisConfig') is not None:
            self.analysis_config = m.get('AnalysisConfig')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop(TeaModel):
    def __init__(
        self,
        height: str = None,
        left: str = None,
        mode: str = None,
        top: str = None,
        width: str = None,
    ):
        self.height = height
        self.left = left
        self.mode = mode
        self.top = top
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.left is not None:
            result['Left'] = self.left
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.top is not None:
            result['Top'] = self.top
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Left') is not None:
            self.left = m.get('Left')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('Top') is not None:
            self.top = m.get('Top')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl(TeaModel):
    def __init__(
        self,
        crop: SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop = None,
        deinterlace: str = None,
    ):
        self.crop = crop
        self.deinterlace = deinterlace

    def validate(self):
        if self.crop:
            self.crop.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.crop is not None:
            result['Crop'] = self.crop.to_map()
        if self.deinterlace is not None:
            result['Deinterlace'] = self.deinterlace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Crop') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop()
            self.crop = temp_model.from_map(m['Crop'])
        if m.get('Deinterlace') is not None:
            self.deinterlace = m.get('Deinterlace')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl(TeaModel):
    def __init__(
        self,
        method_streaming: str = None,
        rate_quality: str = None,
    ):
        self.method_streaming = method_streaming
        self.rate_quality = rate_quality

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.method_streaming is not None:
            result['MethodStreaming'] = self.method_streaming
        if self.rate_quality is not None:
            result['RateQuality'] = self.rate_quality
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MethodStreaming') is not None:
            self.method_streaming = m.get('MethodStreaming')
        if m.get('RateQuality') is not None:
            self.rate_quality = m.get('RateQuality')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig(TeaModel):
    def __init__(
        self,
        properties_control: SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl = None,
        quality_control: SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl = None,
    ):
        self.properties_control = properties_control
        self.quality_control = quality_control

    def validate(self):
        if self.properties_control:
            self.properties_control.validate()
        if self.quality_control:
            self.quality_control.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.properties_control is not None:
            result['PropertiesControl'] = self.properties_control.to_map()
        if self.quality_control is not None:
            result['QualityControl'] = self.quality_control.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PropertiesControl') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl()
            self.properties_control = temp_model.from_map(m['PropertiesControl'])
        if m.get('QualityControl') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl()
            self.quality_control = temp_model.from_map(m['QualityControl'])
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        qscale: str = None,
        samplerate: str = None,
    ):
        self.bitrate = bitrate
        self.channels = channels
        self.codec = codec
        self.profile = profile
        self.qscale = qscale
        self.samplerate = samplerate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif(TeaModel):
    def __init__(
        self,
        final_delay: str = None,
        loop: str = None,
    ):
        self.final_delay = final_delay
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.final_delay is not None:
            result['FinalDelay'] = self.final_delay
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FinalDelay') is not None:
            self.final_delay = m.get('FinalDelay')
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
    ):
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig(TeaModel):
    def __init__(
        self,
        gif: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif = None,
        segment: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment = None,
    ):
        self.gif = gif
        self.segment = segment

    def validate(self):
        if self.gif:
            self.gif.validate()
        if self.segment:
            self.segment.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gif is not None:
            result['Gif'] = self.gif.to_map()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gif') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif()
            self.gif = temp_model.from_map(m['Gif'])
        if m.get('Segment') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig(TeaModel):
    def __init__(
        self,
        trans_mode: str = None,
    ):
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd(TeaModel):
    def __init__(
        self,
        max: str = None,
        min: str = None,
    ):
        self.max = max
        self.min = min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        bitrate_bnd: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        degrain: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        maxrate: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        qscale: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.bitrate_bnd = bitrate_bnd
        self.bufsize = bufsize
        self.codec = codec
        self.crf = crf
        self.degrain = degrain
        self.fps = fps
        self.gop = gop
        self.height = height
        self.maxrate = maxrate
        self.pix_fmt = pix_fmt
        self.preset = preset
        self.profile = profile
        self.qscale = qscale
        self.scan_mode = scan_mode
        self.width = width

    def validate(self):
        if self.bitrate_bnd:
            self.bitrate_bnd.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bitrate_bnd is not None:
            result['BitrateBnd'] = self.bitrate_bnd.to_map()
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.degrain is not None:
            result['Degrain'] = self.degrain
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BitrateBnd') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd()
            self.bitrate_bnd = temp_model.from_map(m['BitrateBnd'])
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Degrain') is not None:
            self.degrain = m.get('Degrain')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate(TeaModel):
    def __init__(
        self,
        audio: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio = None,
        container: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer = None,
        id: str = None,
        mux_config: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig = None,
        name: str = None,
        state: str = None,
        trans_config: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig = None,
        video: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo = None,
    ):
        self.audio = audio
        self.container = container
        self.id = id
        self.mux_config = mux_config
        self.name = name
        self.state = state
        self.trans_config = trans_config
        self.video = video

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MuxConfig') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TransConfig') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('Video') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobTemplateList(TeaModel):
    def __init__(
        self,
        template: List[SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate] = None,
    ):
        self.template = template

    def validate(self):
        if self.template:
            for k in self.template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Template'] = []
        if self.template is not None:
            for k in self.template:
                result['Template'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.template = []
        if m.get('Template') is not None:
            for k in m.get('Template'):
                temp_model = SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate()
                self.template.append(temp_model.from_map(k))
        return self


class SubmitAnalysisJobResponseBodyAnalysisJob(TeaModel):
    def __init__(
        self,
        analysis_config: SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig = None,
        code: str = None,
        creation_time: str = None,
        id: str = None,
        input_file: SubmitAnalysisJobResponseBodyAnalysisJobInputFile = None,
        mnsmessage_result: SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult = None,
        message: str = None,
        percent: int = None,
        pipeline_id: str = None,
        priority: str = None,
        state: str = None,
        template_list: SubmitAnalysisJobResponseBodyAnalysisJobTemplateList = None,
        user_data: str = None,
    ):
        self.analysis_config = analysis_config
        self.code = code
        self.creation_time = creation_time
        self.id = id
        self.input_file = input_file
        self.mnsmessage_result = mnsmessage_result
        self.message = message
        self.percent = percent
        self.pipeline_id = pipeline_id
        self.priority = priority
        self.state = state
        self.template_list = template_list
        self.user_data = user_data

    def validate(self):
        if self.analysis_config:
            self.analysis_config.validate()
        if self.input_file:
            self.input_file.validate()
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()
        if self.template_list:
            self.template_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis_config is not None:
            result['AnalysisConfig'] = self.analysis_config.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.id is not None:
            result['Id'] = self.id
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.state is not None:
            result['State'] = self.state
        if self.template_list is not None:
            result['TemplateList'] = self.template_list.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnalysisConfig') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig()
            self.analysis_config = temp_model.from_map(m['AnalysisConfig'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InputFile') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('MNSMessageResult') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TemplateList') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobTemplateList()
            self.template_list = temp_model.from_map(m['TemplateList'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitAnalysisJobResponseBody(TeaModel):
    def __init__(
        self,
        analysis_job: SubmitAnalysisJobResponseBodyAnalysisJob = None,
        request_id: str = None,
    ):
        self.analysis_job = analysis_job
        self.request_id = request_id

    def validate(self):
        if self.analysis_job:
            self.analysis_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis_job is not None:
            result['AnalysisJob'] = self.analysis_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnalysisJob') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJob()
            self.analysis_job = temp_model.from_map(m['AnalysisJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitAnalysisJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitAnalysisJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitAnalysisJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitEditingJobsRequest(TeaModel):
    def __init__(
        self,
        editing_inputs: str = None,
        editing_job_outputs: str = None,
        output_bucket: str = None,
        output_location: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.editing_inputs = editing_inputs
        # This parameter is required.
        self.editing_job_outputs = editing_job_outputs
        # This parameter is required.
        self.output_bucket = output_bucket
        self.output_location = output_location
        self.owner_account = owner_account
        self.owner_id = owner_id
        # This parameter is required.
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.editing_inputs is not None:
            result['EditingInputs'] = self.editing_inputs
        if self.editing_job_outputs is not None:
            result['EditingJobOutputs'] = self.editing_job_outputs
        if self.output_bucket is not None:
            result['OutputBucket'] = self.output_bucket
        if self.output_location is not None:
            result['OutputLocation'] = self.output_location
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EditingInputs') is not None:
            self.editing_inputs = m.get('EditingInputs')
        if m.get('EditingJobOutputs') is not None:
            self.editing_job_outputs = m.get('EditingJobOutputs')
        if m.get('OutputBucket') is not None:
            self.output_bucket = m.get('OutputBucket')
        if m.get('OutputLocation') is not None:
            self.output_location = m.get('OutputLocation')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudioVolume(TeaModel):
    def __init__(
        self,
        level: str = None,
        method: str = None,
    ):
        self.level = level
        self.method = method

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.level is not None:
            result['Level'] = self.level
        if self.method is not None:
            result['Method'] = self.method
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        qscale: str = None,
        samplerate: str = None,
        volume: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudioVolume = None,
    ):
        self.bitrate = bitrate
        self.channels = channels
        self.codec = codec
        self.profile = profile
        self.qscale = qscale
        self.samplerate = samplerate
        self.volume = volume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClipTimeSpan(TeaModel):
    def __init__(
        self,
        duration: str = None,
        seek: str = None,
    ):
        self.duration = duration
        self.seek = seek

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.seek is not None:
            result['Seek'] = self.seek
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Seek') is not None:
            self.seek = m.get('Seek')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClip(TeaModel):
    def __init__(
        self,
        time_span: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClipTimeSpan = None,
    ):
        self.time_span = time_span

    def validate(self):
        if self.time_span:
            self.time_span.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time_span is not None:
            result['TimeSpan'] = self.time_span.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeSpan') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClipTimeSpan()
            self.time_span = temp_model.from_map(m['TimeSpan'])
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMarkInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMark(TeaModel):
    def __init__(
        self,
        alpha: str = None,
        input_file: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMarkInputFile = None,
        type: str = None,
    ):
        self.alpha = alpha
        self.input_file = input_file
        self.type = type

    def validate(self):
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('InputFile') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMarkInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect(TeaModel):
    def __init__(
        self,
        effect: str = None,
        effect_config: str = None,
    ):
        self.effect = effect
        self.effect_config = effect_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.effect is not None:
            result['Effect'] = self.effect
        if self.effect_config is not None:
            result['EffectConfig'] = self.effect_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Effect') is not None:
            self.effect = m.get('Effect')
        if m.get('EffectConfig') is not None:
            self.effect_config = m.get('EffectConfig')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffects(TeaModel):
    def __init__(
        self,
        effect: List[SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect] = None,
    ):
        self.effect = effect

    def validate(self):
        if self.effect:
            for k in self.effect:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Effect'] = []
        if self.effect is not None:
            for k in self.effect:
                result['Effect'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.effect = []
        if m.get('Effect') is not None:
            for k in m.get('Effect'):
                temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect()
                self.effect.append(temp_model.from_map(k))
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip(TeaModel):
    def __init__(
        self,
        effects: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffects = None,
        id: str = None,
        in_: str = None,
        out: str = None,
        source_id: str = None,
        source_strm_map: str = None,
        source_type: str = None,
        type: str = None,
    ):
        self.effects = effects
        self.id = id
        self.in_ = in_
        self.out = out
        self.source_id = source_id
        self.source_strm_map = source_strm_map
        self.source_type = source_type
        self.type = type

    def validate(self):
        if self.effects:
            self.effects.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.effects is not None:
            result['Effects'] = self.effects.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.in_ is not None:
            result['In'] = self.in_
        if self.out is not None:
            result['Out'] = self.out
        if self.source_id is not None:
            result['SourceID'] = self.source_id
        if self.source_strm_map is not None:
            result['SourceStrmMap'] = self.source_strm_map
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Effects') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffects()
            self.effects = temp_model.from_map(m['Effects'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('In') is not None:
            self.in_ = m.get('In')
        if m.get('Out') is not None:
            self.out = m.get('Out')
        if m.get('SourceID') is not None:
            self.source_id = m.get('SourceID')
        if m.get('SourceStrmMap') is not None:
            self.source_strm_map = m.get('SourceStrmMap')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipList(TeaModel):
    def __init__(
        self,
        clip: List[SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip] = None,
    ):
        self.clip = clip

    def validate(self):
        if self.clip:
            for k in self.clip:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Clip'] = []
        if self.clip is not None:
            for k in self.clip:
                result['Clip'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.clip = []
        if m.get('Clip') is not None:
            for k in m.get('Clip'):
                temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip()
                self.clip.append(temp_model.from_map(k))
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio(TeaModel):
    def __init__(
        self,
        channel_layout: str = None,
        channels: str = None,
        samplerate: str = None,
    ):
        self.channel_layout = channel_layout
        self.channels = channels
        self.samplerate = samplerate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo(TeaModel):
    def __init__(
        self,
        bg_color: str = None,
        fps: str = None,
        height: str = None,
        is_gpu_data: str = None,
        is_one_track_data: str = None,
        reclose_prec: str = None,
        render_ratio: str = None,
        width: str = None,
    ):
        self.bg_color = bg_color
        self.fps = fps
        self.height = height
        self.is_gpu_data = is_gpu_data
        self.is_one_track_data = is_one_track_data
        self.reclose_prec = reclose_prec
        self.render_ratio = render_ratio
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bg_color is not None:
            result['BgColor'] = self.bg_color
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.is_gpu_data is not None:
            result['IsGpuData'] = self.is_gpu_data
        if self.is_one_track_data is not None:
            result['IsOneTrackData'] = self.is_one_track_data
        if self.reclose_prec is not None:
            result['ReclosePrec'] = self.reclose_prec
        if self.render_ratio is not None:
            result['RenderRatio'] = self.render_ratio
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BgColor') is not None:
            self.bg_color = m.get('BgColor')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('IsGpuData') is not None:
            self.is_gpu_data = m.get('IsGpuData')
        if m.get('IsOneTrackData') is not None:
            self.is_one_track_data = m.get('IsOneTrackData')
        if m.get('ReclosePrec') is not None:
            self.reclose_prec = m.get('ReclosePrec')
        if m.get('RenderRatio') is not None:
            self.render_ratio = m.get('RenderRatio')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfig(TeaModel):
    def __init__(
        self,
        timeline_config_audio: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio = None,
        timeline_config_video: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo = None,
    ):
        self.timeline_config_audio = timeline_config_audio
        self.timeline_config_video = timeline_config_video

    def validate(self):
        if self.timeline_config_audio:
            self.timeline_config_audio.validate()
        if self.timeline_config_video:
            self.timeline_config_video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.timeline_config_audio is not None:
            result['TimelineConfigAudio'] = self.timeline_config_audio.to_map()
        if self.timeline_config_video is not None:
            result['TimelineConfigVideo'] = self.timeline_config_video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimelineConfigAudio') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio()
            self.timeline_config_audio = temp_model.from_map(m['TimelineConfigAudio'])
        if m.get('TimelineConfigVideo') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo()
            self.timeline_config_video = temp_model.from_map(m['TimelineConfigVideo'])
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo(TeaModel):
    def __init__(
        self,
        l: str = None,
        t: str = None,
    ):
        self.l = l
        self.t = t

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.l is not None:
            result['L'] = self.l
        if self.t is not None:
            result['T'] = self.t
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('L') is not None:
            self.l = m.get('L')
        if m.get('T') is not None:
            self.t = m.get('T')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig(TeaModel):
    def __init__(
        self,
        clips_config_video: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo = None,
    ):
        self.clips_config_video = clips_config_video

    def validate(self):
        if self.clips_config_video:
            self.clips_config_video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clips_config_video is not None:
            result['ClipsConfigVideo'] = self.clips_config_video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClipsConfigVideo') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo()
            self.clips_config_video = temp_model.from_map(m['ClipsConfigVideo'])
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip(TeaModel):
    def __init__(
        self,
        clips_config: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig = None,
        in_: str = None,
        out: str = None,
        clip_id: str = None,
    ):
        self.clips_config = clips_config
        self.in_ = in_
        self.out = out
        self.clip_id = clip_id

    def validate(self):
        if self.clips_config:
            self.clips_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clips_config is not None:
            result['ClipsConfig'] = self.clips_config.to_map()
        if self.in_ is not None:
            result['In'] = self.in_
        if self.out is not None:
            result['Out'] = self.out
        if self.clip_id is not None:
            result['clipID'] = self.clip_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClipsConfig') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig()
            self.clips_config = temp_model.from_map(m['ClipsConfig'])
        if m.get('In') is not None:
            self.in_ = m.get('In')
        if m.get('Out') is not None:
            self.out = m.get('Out')
        if m.get('clipID') is not None:
            self.clip_id = m.get('clipID')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClips(TeaModel):
    def __init__(
        self,
        clip: List[SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip] = None,
    ):
        self.clip = clip

    def validate(self):
        if self.clip:
            for k in self.clip:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Clip'] = []
        if self.clip is not None:
            for k in self.clip:
                result['Clip'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.clip = []
        if m.get('Clip') is not None:
            for k in m.get('Clip'):
                temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip()
                self.clip.append(temp_model.from_map(k))
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack(TeaModel):
    def __init__(
        self,
        clips: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClips = None,
        id: str = None,
        order: str = None,
        type: str = None,
    ):
        self.clips = clips
        self.id = id
        self.order = order
        self.type = type

    def validate(self):
        if self.clips:
            self.clips.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clips is not None:
            result['Clips'] = self.clips.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.order is not None:
            result['Order'] = self.order
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Clips') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClips()
            self.clips = temp_model.from_map(m['Clips'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackList(TeaModel):
    def __init__(
        self,
        track: List[SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack] = None,
    ):
        self.track = track

    def validate(self):
        if self.track:
            for k in self.track:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Track'] = []
        if self.track is not None:
            for k in self.track:
                result['Track'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.track = []
        if m.get('Track') is not None:
            for k in m.get('Track'):
                temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack()
                self.track.append(temp_model.from_map(k))
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimeline(TeaModel):
    def __init__(
        self,
        timeline_config: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfig = None,
        track_list: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackList = None,
    ):
        self.timeline_config = timeline_config
        self.track_list = track_list

    def validate(self):
        if self.timeline_config:
            self.timeline_config.validate()
        if self.track_list:
            self.track_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.timeline_config is not None:
            result['TimelineConfig'] = self.timeline_config.to_map()
        if self.track_list is not None:
            result['TrackList'] = self.track_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimelineConfig') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfig()
            self.timeline_config = temp_model.from_map(m['TimelineConfig'])
        if m.get('TrackList') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackList()
            self.track_list = temp_model.from_map(m['TrackList'])
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditing(TeaModel):
    def __init__(
        self,
        clip_list: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipList = None,
        timeline: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimeline = None,
    ):
        self.clip_list = clip_list
        self.timeline = timeline

    def validate(self):
        if self.clip_list:
            self.clip_list.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clip_list is not None:
            result['ClipList'] = self.clip_list.to_map()
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClipList') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipList()
            self.clip_list = temp_model.from_map(m['ClipList'])
        if m.get('Timeline') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEncryption(TeaModel):
    def __init__(
        self,
        id: str = None,
        key: str = None,
        key_type: str = None,
        key_uri: str = None,
        skip_cnt: str = None,
        type: str = None,
    ):
        self.id = id
        self.key = key
        self.key_type = key_type
        self.key_uri = key_uri
        self.skip_cnt = skip_cnt
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.key is not None:
            result['Key'] = self.key
        if self.key_type is not None:
            result['KeyType'] = self.key_type
        if self.key_uri is not None:
            result['KeyUri'] = self.key_uri
        if self.skip_cnt is not None:
            result['SkipCnt'] = self.skip_cnt
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('KeyType') is not None:
            self.key_type = m.get('KeyType')
        if m.get('KeyUri') is not None:
            self.key_uri = m.get('KeyUri')
        if m.get('SkipCnt') is not None:
            self.skip_cnt = m.get('SkipCnt')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupportTS(TeaModel):
    def __init__(
        self,
        md_5support: bool = None,
        size_support: bool = None,
    ):
        self.md_5support = md_5support
        self.size_support = size_support

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.md_5support is not None:
            result['Md5Support'] = self.md_5support
        if self.size_support is not None:
            result['SizeSupport'] = self.size_support
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Md5Support') is not None:
            self.md_5support = m.get('Md5Support')
        if m.get('SizeSupport') is not None:
            self.size_support = m.get('SizeSupport')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupport(TeaModel):
    def __init__(
        self,
        ts: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupportTS = None,
    ):
        self.ts = ts

    def validate(self):
        if self.ts:
            self.ts.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ts is not None:
            result['TS'] = self.ts.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TS') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupportTS()
            self.ts = temp_model.from_map(m['TS'])
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge(TeaModel):
    def __init__(
        self,
        duration: str = None,
        merge_url: str = None,
        role_arn: str = None,
        start: str = None,
    ):
        self.duration = duration
        self.merge_url = merge_url
        self.role_arn = role_arn
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.merge_url is not None:
            result['MergeURL'] = self.merge_url
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('MergeURL') is not None:
            self.merge_url = m.get('MergeURL')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeList(TeaModel):
    def __init__(
        self,
        merge: List[SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge] = None,
    ):
        self.merge = merge

    def validate(self):
        if self.merge:
            for k in self.merge:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Merge'] = []
        if self.merge is not None:
            for k in self.merge:
                result['Merge'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.merge = []
        if m.get('Merge') is not None:
            for k in m.get('Merge'):
                temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge()
                self.merge.append(temp_model.from_map(k))
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigGif(TeaModel):
    def __init__(
        self,
        dither_mode: str = None,
        final_delay: str = None,
        is_custom_palette: str = None,
        loop: str = None,
    ):
        self.dither_mode = dither_mode
        self.final_delay = final_delay
        self.is_custom_palette = is_custom_palette
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dither_mode is not None:
            result['DitherMode'] = self.dither_mode
        if self.final_delay is not None:
            result['FinalDelay'] = self.final_delay
        if self.is_custom_palette is not None:
            result['IsCustomPalette'] = self.is_custom_palette
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DitherMode') is not None:
            self.dither_mode = m.get('DitherMode')
        if m.get('FinalDelay') is not None:
            self.final_delay = m.get('FinalDelay')
        if m.get('IsCustomPalette') is not None:
            self.is_custom_palette = m.get('IsCustomPalette')
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
    ):
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfig(TeaModel):
    def __init__(
        self,
        gif: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigGif = None,
        segment: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigSegment = None,
    ):
        self.gif = gif
        self.segment = segment

    def validate(self):
        if self.gif:
            self.gif.validate()
        if self.segment:
            self.segment.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gif is not None:
            result['Gif'] = self.gif.to_map()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gif') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigGif()
            self.gif = temp_model.from_map(m['Gif'])
        if m.get('Segment') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigOutputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesFormat(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        format_long_name: str = None,
        format_name: str = None,
        num_programs: str = None,
        num_streams: str = None,
        size: str = None,
        start_time: str = None,
    ):
        self.bitrate = bitrate
        self.duration = duration
        self.format_long_name = format_long_name
        self.format_name = format_name
        self.num_programs = num_programs
        self.num_streams = num_streams
        self.size = size
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.format_long_name is not None:
            result['FormatLongName'] = self.format_long_name
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.num_programs is not None:
            result['NumPrograms'] = self.num_programs
        if self.num_streams is not None:
            result['NumStreams'] = self.num_streams
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FormatLongName') is not None:
            self.format_long_name = m.get('FormatLongName')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('NumPrograms') is not None:
            self.num_programs = m.get('NumPrograms')
        if m.get('NumStreams') is not None:
            self.num_streams = m.get('NumStreams')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        num_frames: str = None,
        sample_fmt: str = None,
        samplerate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        self.bitrate = bitrate
        self.channel_layout = channel_layout
        self.channels = channels
        self.codec_long_name = codec_long_name
        self.codec_name = codec_name
        self.codec_tag = codec_tag
        self.codec_tag_string = codec_tag_string
        self.codec_time_base = codec_time_base
        self.duration = duration
        self.index = index
        self.lang = lang
        self.num_frames = num_frames
        self.sample_fmt = sample_fmt
        self.samplerate = samplerate
        self.start_time = start_time
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamList(TeaModel):
    def __init__(
        self,
        audio_stream: List[SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream] = None,
    ):
        self.audio_stream = audio_stream

    def validate(self):
        if self.audio_stream:
            for k in self.audio_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStream'] = []
        if self.audio_stream is not None:
            for k in self.audio_stream:
                result['AudioStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream = []
        if m.get('AudioStream') is not None:
            for k in m.get('AudioStream'):
                temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream()
                self.audio_stream.append(temp_model.from_map(k))
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream(TeaModel):
    def __init__(
        self,
        index: str = None,
        lang: str = None,
    ):
        self.index = index
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamList(TeaModel):
    def __init__(
        self,
        subtitle_stream: List[SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream] = None,
    ):
        self.subtitle_stream = subtitle_stream

    def validate(self):
        if self.subtitle_stream:
            for k in self.subtitle_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubtitleStream'] = []
        if self.subtitle_stream is not None:
            for k in self.subtitle_stream:
                result['SubtitleStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle_stream = []
        if m.get('SubtitleStream') is not None:
            for k in m.get('SubtitleStream'):
                temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream()
                self.subtitle_stream.append(temp_model.from_map(k))
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost(TeaModel):
    def __init__(
        self,
        avg_bitrate: str = None,
        cost_bandwidth: str = None,
        preload_time: str = None,
    ):
        self.avg_bitrate = avg_bitrate
        self.cost_bandwidth = cost_bandwidth
        self.preload_time = preload_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_bitrate is not None:
            result['AvgBitrate'] = self.avg_bitrate
        if self.cost_bandwidth is not None:
            result['CostBandwidth'] = self.cost_bandwidth
        if self.preload_time is not None:
            result['PreloadTime'] = self.preload_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgBitrate') is not None:
            self.avg_bitrate = m.get('AvgBitrate')
        if m.get('CostBandwidth') is not None:
            self.cost_bandwidth = m.get('CostBandwidth')
        if m.get('PreloadTime') is not None:
            self.preload_time = m.get('PreloadTime')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bitrate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        network_cost: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        sar: str = None,
        start_time: str = None,
        timebase: str = None,
        width: str = None,
    ):
        self.avg_fps = avg_fps
        self.bitrate = bitrate
        self.codec_long_name = codec_long_name
        self.codec_name = codec_name
        self.codec_tag = codec_tag
        self.codec_tag_string = codec_tag_string
        self.codec_time_base = codec_time_base
        self.dar = dar
        self.duration = duration
        self.fps = fps
        self.has_bframes = has_bframes
        self.height = height
        self.index = index
        self.lang = lang
        self.level = level
        self.network_cost = network_cost
        self.num_frames = num_frames
        self.pix_fmt = pix_fmt
        self.profile = profile
        self.sar = sar
        self.start_time = start_time
        self.timebase = timebase
        self.width = width

    def validate(self):
        if self.network_cost:
            self.network_cost.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['AvgFPS'] = self.avg_fps
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['HasBFrames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.network_cost is not None:
            result['NetworkCost'] = self.network_cost.to_map()
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgFPS') is not None:
            self.avg_fps = m.get('AvgFPS')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HasBFrames') is not None:
            self.has_bframes = m.get('HasBFrames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NetworkCost') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost()
            self.network_cost = temp_model.from_map(m['NetworkCost'])
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamList(TeaModel):
    def __init__(
        self,
        video_stream: List[SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream] = None,
    ):
        self.video_stream = video_stream

    def validate(self):
        if self.video_stream:
            for k in self.video_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoStream'] = []
        if self.video_stream is not None:
            for k in self.video_stream:
                result['VideoStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_stream = []
        if m.get('VideoStream') is not None:
            for k in m.get('VideoStream'):
                temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream()
                self.video_stream.append(temp_model.from_map(k))
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreams(TeaModel):
    def __init__(
        self,
        audio_stream_list: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamList = None,
        subtitle_stream_list: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamList = None,
        video_stream_list: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamList = None,
    ):
        self.audio_stream_list = audio_stream_list
        self.subtitle_stream_list = subtitle_stream_list
        self.video_stream_list = video_stream_list

    def validate(self):
        if self.audio_stream_list:
            self.audio_stream_list.validate()
        if self.subtitle_stream_list:
            self.subtitle_stream_list.validate()
        if self.video_stream_list:
            self.video_stream_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_stream_list is not None:
            result['AudioStreamList'] = self.audio_stream_list.to_map()
        if self.subtitle_stream_list is not None:
            result['SubtitleStreamList'] = self.subtitle_stream_list.to_map()
        if self.video_stream_list is not None:
            result['VideoStreamList'] = self.video_stream_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioStreamList') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamList()
            self.audio_stream_list = temp_model.from_map(m['AudioStreamList'])
        if m.get('SubtitleStreamList') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamList()
            self.subtitle_stream_list = temp_model.from_map(m['SubtitleStreamList'])
        if m.get('VideoStreamList') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamList()
            self.video_stream_list = temp_model.from_map(m['VideoStreamList'])
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigProperties(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_format: str = None,
        file_size: str = None,
        format: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesFormat = None,
        fps: str = None,
        height: str = None,
        streams: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreams = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.duration = duration
        self.file_format = file_format
        self.file_size = file_size
        self.format = format
        self.fps = fps
        self.height = height
        self.streams = streams
        self.width = width

    def validate(self):
        if self.format:
            self.format.validate()
        if self.streams:
            self.streams.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_format is not None:
            result['FileFormat'] = self.file_format
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.format is not None:
            result['Format'] = self.format.to_map()
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.streams is not None:
            result['Streams'] = self.streams.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileFormat') is not None:
            self.file_format = m.get('FileFormat')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('Format') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesFormat()
            self.format = temp_model.from_map(m['Format'])
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Streams') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreams()
            self.streams = temp_model.from_map(m['Streams'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle(TeaModel):
    def __init__(
        self,
        char_enc: str = None,
        font_name: str = None,
        input: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput = None,
    ):
        self.char_enc = char_enc
        self.font_name = font_name
        self.input = input

    def validate(self):
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.char_enc is not None:
            result['CharEnc'] = self.char_enc
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.input is not None:
            result['Input'] = self.input.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CharEnc') is not None:
            self.char_enc = m.get('CharEnc')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('Input') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput()
            self.input = temp_model.from_map(m['Input'])
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleList(TeaModel):
    def __init__(
        self,
        ext_subtitle: List[SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle] = None,
    ):
        self.ext_subtitle = ext_subtitle

    def validate(self):
        if self.ext_subtitle:
            for k in self.ext_subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ExtSubtitle'] = []
        if self.ext_subtitle is not None:
            for k in self.ext_subtitle:
                result['ExtSubtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ext_subtitle = []
        if m.get('ExtSubtitle') is not None:
            for k in m.get('ExtSubtitle'):
                temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle()
                self.ext_subtitle.append(temp_model.from_map(k))
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle(TeaModel):
    def __init__(
        self,
        map: str = None,
    ):
        self.map = map

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.map is not None:
            result['Map'] = self.map
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Map') is not None:
            self.map = m.get('Map')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleList(TeaModel):
    def __init__(
        self,
        subtitle: List[SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle] = None,
    ):
        self.subtitle = subtitle

    def validate(self):
        if self.subtitle:
            for k in self.subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Subtitle'] = []
        if self.subtitle is not None:
            for k in self.subtitle:
                result['Subtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle = []
        if m.get('Subtitle') is not None:
            for k in m.get('Subtitle'):
                temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle()
                self.subtitle.append(temp_model.from_map(k))
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfig(TeaModel):
    def __init__(
        self,
        ext_subtitle_list: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleList = None,
        subtitle_list: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleList = None,
    ):
        self.ext_subtitle_list = ext_subtitle_list
        self.subtitle_list = subtitle_list

    def validate(self):
        if self.ext_subtitle_list:
            self.ext_subtitle_list.validate()
        if self.subtitle_list:
            self.subtitle_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ext_subtitle_list is not None:
            result['ExtSubtitleList'] = self.ext_subtitle_list.to_map()
        if self.subtitle_list is not None:
            result['SubtitleList'] = self.subtitle_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExtSubtitleList') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleList()
            self.ext_subtitle_list = temp_model.from_map(m['ExtSubtitleList'])
        if m.get('SubtitleList') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleList()
            self.subtitle_list = temp_model.from_map(m['SubtitleList'])
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSuperReso(TeaModel):
    def __init__(
        self,
        is_half_sample: str = None,
    ):
        self.is_half_sample = is_half_sample

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_half_sample is not None:
            result['IsHalfSample'] = self.is_half_sample
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsHalfSample') is not None:
            self.is_half_sample = m.get('IsHalfSample')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        duration: str = None,
        is_check_audio_bitrate: str = None,
        is_check_audio_bitrate_fail: str = None,
        is_check_reso: str = None,
        is_check_reso_fail: str = None,
        is_check_video_bitrate: str = None,
        is_check_video_bitrate_fail: str = None,
        trans_mode: str = None,
    ):
        self.adj_dar_method = adj_dar_method
        self.duration = duration
        self.is_check_audio_bitrate = is_check_audio_bitrate
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        self.is_check_reso = is_check_reso
        self.is_check_reso_fail = is_check_reso_fail
        self.is_check_video_bitrate = is_check_video_bitrate
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideoBitrateBnd(TeaModel):
    def __init__(
        self,
        max: str = None,
        min: str = None,
    ):
        self.max = max
        self.min = min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        bitrate_bnd: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideoBitrateBnd = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        degrain: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        max_fps: str = None,
        maxrate: str = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        qscale: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.bitrate_bnd = bitrate_bnd
        self.bufsize = bufsize
        self.codec = codec
        self.crf = crf
        self.crop = crop
        self.degrain = degrain
        self.fps = fps
        self.gop = gop
        self.height = height
        self.max_fps = max_fps
        self.maxrate = maxrate
        self.pad = pad
        self.pix_fmt = pix_fmt
        self.preset = preset
        self.profile = profile
        self.qscale = qscale
        self.scan_mode = scan_mode
        self.width = width

    def validate(self):
        if self.bitrate_bnd:
            self.bitrate_bnd.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bitrate_bnd is not None:
            result['BitrateBnd'] = self.bitrate_bnd.to_map()
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.degrain is not None:
            result['Degrain'] = self.degrain
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.max_fps is not None:
            result['MaxFps'] = self.max_fps
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BitrateBnd') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideoBitrateBnd()
            self.bitrate_bnd = temp_model.from_map(m['BitrateBnd'])
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Degrain') is not None:
            self.degrain = m.get('Degrain')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MaxFps') is not None:
            self.max_fps = m.get('MaxFps')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMarkInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        input_file: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMarkInputFile = None,
        refer_pos: str = None,
        type: str = None,
        water_mark_template_id: str = None,
        width: str = None,
    ):
        self.dx = dx
        self.dy = dy
        self.height = height
        self.input_file = input_file
        self.refer_pos = refer_pos
        self.type = type
        self.water_mark_template_id = water_mark_template_id
        self.width = width

    def validate(self):
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.type is not None:
            result['Type'] = self.type
        if self.water_mark_template_id is not None:
            result['WaterMarkTemplateId'] = self.water_mark_template_id
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('InputFile') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMarkInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WaterMarkTemplateId') is not None:
            self.water_mark_template_id = m.get('WaterMarkTemplateId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkList(TeaModel):
    def __init__(
        self,
        water_mark: List[SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark] = None,
    ):
        self.water_mark = water_mark

    def validate(self):
        if self.water_mark:
            for k in self.water_mark:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WaterMark'] = []
        if self.water_mark is not None:
            for k in self.water_mark:
                result['WaterMark'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.water_mark = []
        if m.get('WaterMark') is not None:
            for k in m.get('WaterMark'):
                temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark()
                self.water_mark.append(temp_model.from_map(k))
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfig(TeaModel):
    def __init__(
        self,
        audio: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudio = None,
        audio_stream_map: str = None,
        clip: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClip = None,
        container: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigContainer = None,
        de_watermark: str = None,
        digi_water_mark: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMark = None,
        editing: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditing = None,
        encryption: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEncryption = None,
        m_3u8non_standard_support: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupport = None,
        merge_config_url: str = None,
        merge_list: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeList = None,
        mux_config: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfig = None,
        output_file: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigOutputFile = None,
        priority: str = None,
        properties: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigProperties = None,
        rotate: str = None,
        subtitle_config: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfig = None,
        super_reso: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSuperReso = None,
        template_id: str = None,
        trans_config: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigTransConfig = None,
        user_data: str = None,
        video: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideo = None,
        video_stream_map: str = None,
        water_mark_config_url: str = None,
        water_mark_list: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkList = None,
    ):
        self.audio = audio
        self.audio_stream_map = audio_stream_map
        self.clip = clip
        self.container = container
        self.de_watermark = de_watermark
        self.digi_water_mark = digi_water_mark
        self.editing = editing
        self.encryption = encryption
        self.m_3u8non_standard_support = m_3u8non_standard_support
        self.merge_config_url = merge_config_url
        self.merge_list = merge_list
        self.mux_config = mux_config
        self.output_file = output_file
        self.priority = priority
        self.properties = properties
        self.rotate = rotate
        self.subtitle_config = subtitle_config
        self.super_reso = super_reso
        self.template_id = template_id
        self.trans_config = trans_config
        self.user_data = user_data
        self.video = video
        self.video_stream_map = video_stream_map
        self.water_mark_config_url = water_mark_config_url
        self.water_mark_list = water_mark_list

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.clip:
            self.clip.validate()
        if self.container:
            self.container.validate()
        if self.digi_water_mark:
            self.digi_water_mark.validate()
        if self.editing:
            self.editing.validate()
        if self.encryption:
            self.encryption.validate()
        if self.m_3u8non_standard_support:
            self.m_3u8non_standard_support.validate()
        if self.merge_list:
            self.merge_list.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.output_file:
            self.output_file.validate()
        if self.properties:
            self.properties.validate()
        if self.subtitle_config:
            self.subtitle_config.validate()
        if self.super_reso:
            self.super_reso.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()
        if self.water_mark_list:
            self.water_mark_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.audio_stream_map is not None:
            result['AudioStreamMap'] = self.audio_stream_map
        if self.clip is not None:
            result['Clip'] = self.clip.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.de_watermark is not None:
            result['DeWatermark'] = self.de_watermark
        if self.digi_water_mark is not None:
            result['DigiWaterMark'] = self.digi_water_mark.to_map()
        if self.editing is not None:
            result['Editing'] = self.editing.to_map()
        if self.encryption is not None:
            result['Encryption'] = self.encryption.to_map()
        if self.m_3u8non_standard_support is not None:
            result['M3U8NonStandardSupport'] = self.m_3u8non_standard_support.to_map()
        if self.merge_config_url is not None:
            result['MergeConfigUrl'] = self.merge_config_url
        if self.merge_list is not None:
            result['MergeList'] = self.merge_list.to_map()
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.output_file is not None:
            result['OutputFile'] = self.output_file.to_map()
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.properties is not None:
            result['Properties'] = self.properties.to_map()
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.subtitle_config is not None:
            result['SubtitleConfig'] = self.subtitle_config.to_map()
        if self.super_reso is not None:
            result['SuperReso'] = self.super_reso.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.video is not None:
            result['Video'] = self.video.to_map()
        if self.video_stream_map is not None:
            result['VideoStreamMap'] = self.video_stream_map
        if self.water_mark_config_url is not None:
            result['WaterMarkConfigUrl'] = self.water_mark_config_url
        if self.water_mark_list is not None:
            result['WaterMarkList'] = self.water_mark_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('AudioStreamMap') is not None:
            self.audio_stream_map = m.get('AudioStreamMap')
        if m.get('Clip') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClip()
            self.clip = temp_model.from_map(m['Clip'])
        if m.get('Container') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('DeWatermark') is not None:
            self.de_watermark = m.get('DeWatermark')
        if m.get('DigiWaterMark') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMark()
            self.digi_water_mark = temp_model.from_map(m['DigiWaterMark'])
        if m.get('Editing') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditing()
            self.editing = temp_model.from_map(m['Editing'])
        if m.get('Encryption') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEncryption()
            self.encryption = temp_model.from_map(m['Encryption'])
        if m.get('M3U8NonStandardSupport') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupport()
            self.m_3u8non_standard_support = temp_model.from_map(m['M3U8NonStandardSupport'])
        if m.get('MergeConfigUrl') is not None:
            self.merge_config_url = m.get('MergeConfigUrl')
        if m.get('MergeList') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeList()
            self.merge_list = temp_model.from_map(m['MergeList'])
        if m.get('MuxConfig') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('OutputFile') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigOutputFile()
            self.output_file = temp_model.from_map(m['OutputFile'])
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Properties') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigProperties()
            self.properties = temp_model.from_map(m['Properties'])
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('SubtitleConfig') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfig()
            self.subtitle_config = temp_model.from_map(m['SubtitleConfig'])
        if m.get('SuperReso') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSuperReso()
            self.super_reso = temp_model.from_map(m['SuperReso'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TransConfig') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('Video') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideo()
            self.video = temp_model.from_map(m['Video'])
        if m.get('VideoStreamMap') is not None:
            self.video_stream_map = m.get('VideoStreamMap')
        if m.get('WaterMarkConfigUrl') is not None:
            self.water_mark_config_url = m.get('WaterMarkConfigUrl')
        if m.get('WaterMarkList') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkList()
            self.water_mark_list = temp_model.from_map(m['WaterMarkList'])
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputConfig(TeaModel):
    def __init__(
        self,
        deinterlace_method: str = None,
        is_normal_sar: str = None,
    ):
        self.deinterlace_method = deinterlace_method
        self.is_normal_sar = is_normal_sar

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deinterlace_method is not None:
            result['DeinterlaceMethod'] = self.deinterlace_method
        if self.is_normal_sar is not None:
            result['IsNormalSar'] = self.is_normal_sar
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeinterlaceMethod') is not None:
            self.deinterlace_method = m.get('DeinterlaceMethod')
        if m.get('IsNormalSar') is not None:
            self.is_normal_sar = m.get('IsNormalSar')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput(TeaModel):
    def __init__(
        self,
        id: str = None,
        input_config: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputConfig = None,
        input_file: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputFile = None,
    ):
        self.id = id
        self.input_config = input_config
        self.input_file = input_file

    def validate(self):
        if self.input_config:
            self.input_config.validate()
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.input_config is not None:
            result['InputConfig'] = self.input_config.to_map()
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InputConfig') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputConfig()
            self.input_config = temp_model.from_map(m['InputConfig'])
        if m.get('InputFile') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputs(TeaModel):
    def __init__(
        self,
        editing_input: List[SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput] = None,
    ):
        self.editing_input = editing_input

    def validate(self):
        if self.editing_input:
            for k in self.editing_input:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EditingInput'] = []
        if self.editing_input is not None:
            for k in self.editing_input:
                result['EditingInput'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.editing_input = []
        if m.get('EditingInput') is not None:
            for k in m.get('EditingInput'):
                temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput()
                self.editing_input.append(temp_model.from_map(k))
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJobMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResultJob(TeaModel):
    def __init__(
        self,
        code: str = None,
        creation_time: str = None,
        editing_config: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfig = None,
        editing_inputs: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputs = None,
        finish_time: str = None,
        job_id: str = None,
        mnsmessage_result: SubmitEditingJobsResponseBodyJobResultListJobResultJobMNSMessageResult = None,
        message: str = None,
        percent: int = None,
        pipeline_id: str = None,
        state: str = None,
    ):
        self.code = code
        self.creation_time = creation_time
        self.editing_config = editing_config
        self.editing_inputs = editing_inputs
        self.finish_time = finish_time
        self.job_id = job_id
        self.mnsmessage_result = mnsmessage_result
        self.message = message
        self.percent = percent
        self.pipeline_id = pipeline_id
        self.state = state

    def validate(self):
        if self.editing_config:
            self.editing_config.validate()
        if self.editing_inputs:
            self.editing_inputs.validate()
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.editing_config is not None:
            result['EditingConfig'] = self.editing_config.to_map()
        if self.editing_inputs is not None:
            result['EditingInputs'] = self.editing_inputs.to_map()
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('EditingConfig') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfig()
            self.editing_config = temp_model.from_map(m['EditingConfig'])
        if m.get('EditingInputs') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputs()
            self.editing_inputs = temp_model.from_map(m['EditingInputs'])
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MNSMessageResult') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJobMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class SubmitEditingJobsResponseBodyJobResultListJobResult(TeaModel):
    def __init__(
        self,
        code: str = None,
        job: SubmitEditingJobsResponseBodyJobResultListJobResultJob = None,
        message: str = None,
        success: bool = None,
    ):
        self.code = code
        self.job = job
        self.message = message
        self.success = success

    def validate(self):
        if self.job:
            self.job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.job is not None:
            result['Job'] = self.job.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Job') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultListJobResultJob()
            self.job = temp_model.from_map(m['Job'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitEditingJobsResponseBodyJobResultList(TeaModel):
    def __init__(
        self,
        job_result: List[SubmitEditingJobsResponseBodyJobResultListJobResult] = None,
    ):
        self.job_result = job_result

    def validate(self):
        if self.job_result:
            for k in self.job_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JobResult'] = []
        if self.job_result is not None:
            for k in self.job_result:
                result['JobResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.job_result = []
        if m.get('JobResult') is not None:
            for k in m.get('JobResult'):
                temp_model = SubmitEditingJobsResponseBodyJobResultListJobResult()
                self.job_result.append(temp_model.from_map(k))
        return self


class SubmitEditingJobsResponseBody(TeaModel):
    def __init__(
        self,
        job_result_list: SubmitEditingJobsResponseBodyJobResultList = None,
        request_id: str = None,
    ):
        self.job_result_list = job_result_list
        self.request_id = request_id

    def validate(self):
        if self.job_result_list:
            self.job_result_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_result_list is not None:
            result['JobResultList'] = self.job_result_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobResultList') is not None:
            temp_model = SubmitEditingJobsResponseBodyJobResultList()
            self.job_result_list = temp_model.from_map(m['JobResultList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitEditingJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitEditingJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitEditingJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitJobsRequest(TeaModel):
    def __init__(
        self,
        input: str = None,
        output_bucket: str = None,
        output_location: str = None,
        outputs: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.input = input
        # This parameter is required.
        self.output_bucket = output_bucket
        self.output_location = output_location
        # This parameter is required.
        self.outputs = outputs
        self.owner_account = owner_account
        self.owner_id = owner_id
        # This parameter is required.
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input is not None:
            result['Input'] = self.input
        if self.output_bucket is not None:
            result['OutputBucket'] = self.output_bucket
        if self.output_location is not None:
            result['OutputLocation'] = self.output_location
        if self.outputs is not None:
            result['Outputs'] = self.outputs
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('OutputBucket') is not None:
            self.output_bucket = m.get('OutputBucket')
        if m.get('OutputLocation') is not None:
            self.output_location = m.get('OutputLocation')
        if m.get('Outputs') is not None:
            self.outputs = m.get('Outputs')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix(TeaModel):
    def __init__(
        self,
        amix_url: str = None,
        duration: str = None,
        map: str = None,
        mix_dur_mode: str = None,
        start: str = None,
    ):
        self.amix_url = amix_url
        self.duration = duration
        self.map = map
        self.mix_dur_mode = mix_dur_mode
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amix_url is not None:
            result['AmixURL'] = self.amix_url
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.map is not None:
            result['Map'] = self.map
        if self.mix_dur_mode is not None:
            result['MixDurMode'] = self.mix_dur_mode
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AmixURL') is not None:
            self.amix_url = m.get('AmixURL')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Map') is not None:
            self.map = m.get('Map')
        if m.get('MixDurMode') is not None:
            self.mix_dur_mode = m.get('MixDurMode')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList(TeaModel):
    def __init__(
        self,
        amix: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix] = None,
    ):
        self.amix = amix

    def validate(self):
        if self.amix:
            for k in self.amix:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Amix'] = []
        if self.amix is not None:
            for k in self.amix:
                result['Amix'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.amix = []
        if m.get('Amix') is not None:
            for k in m.get('Amix'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix()
                self.amix.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume(TeaModel):
    def __init__(
        self,
        level: str = None,
        method: str = None,
    ):
        self.level = level
        self.method = method

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.level is not None:
            result['Level'] = self.level
        if self.method is not None:
            result['Method'] = self.method
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        qscale: str = None,
        samplerate: str = None,
        volume: SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume = None,
    ):
        self.bitrate = bitrate
        self.channels = channels
        self.codec = codec
        self.profile = profile
        self.qscale = qscale
        self.samplerate = samplerate
        self.volume = volume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan(TeaModel):
    def __init__(
        self,
        duration: str = None,
        seek: str = None,
    ):
        self.duration = duration
        self.seek = seek

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.seek is not None:
            result['Seek'] = self.seek
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Seek') is not None:
            self.seek = m.get('Seek')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputClip(TeaModel):
    def __init__(
        self,
        time_span: SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan = None,
    ):
        self.time_span = time_span

    def validate(self):
        if self.time_span:
            self.time_span.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time_span is not None:
            result['TimeSpan'] = self.time_span.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeSpan') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan()
            self.time_span = temp_model.from_map(m['TimeSpan'])
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark(TeaModel):
    def __init__(
        self,
        alpha: str = None,
        input_file: SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile = None,
        type: str = None,
    ):
        self.alpha = alpha
        self.input_file = input_file
        self.type = type

    def validate(self):
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('InputFile') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption(TeaModel):
    def __init__(
        self,
        id: str = None,
        key: str = None,
        key_type: str = None,
        key_uri: str = None,
        skip_cnt: str = None,
        type: str = None,
    ):
        self.id = id
        self.key = key
        self.key_type = key_type
        self.key_uri = key_uri
        self.skip_cnt = skip_cnt
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.key is not None:
            result['Key'] = self.key
        if self.key_type is not None:
            result['KeyType'] = self.key_type
        if self.key_uri is not None:
            result['KeyUri'] = self.key_uri
        if self.skip_cnt is not None:
            result['SkipCnt'] = self.skip_cnt
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('KeyType') is not None:
            self.key_type = m.get('KeyType')
        if m.get('KeyUri') is not None:
            self.key_uri = m.get('KeyUri')
        if m.get('SkipCnt') is not None:
            self.skip_cnt = m.get('SkipCnt')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS(TeaModel):
    def __init__(
        self,
        md_5support: bool = None,
        size_support: bool = None,
    ):
        self.md_5support = md_5support
        self.size_support = size_support

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.md_5support is not None:
            result['Md5Support'] = self.md_5support
        if self.size_support is not None:
            result['SizeSupport'] = self.size_support
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Md5Support') is not None:
            self.md_5support = m.get('Md5Support')
        if m.get('SizeSupport') is not None:
            self.size_support = m.get('SizeSupport')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport(TeaModel):
    def __init__(
        self,
        ts: SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS = None,
    ):
        self.ts = ts

    def validate(self):
        if self.ts:
            self.ts.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ts is not None:
            result['TS'] = self.ts.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TS') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS()
            self.ts = temp_model.from_map(m['TS'])
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge(TeaModel):
    def __init__(
        self,
        duration: str = None,
        merge_url: str = None,
        role_arn: str = None,
        start: str = None,
    ):
        self.duration = duration
        self.merge_url = merge_url
        self.role_arn = role_arn
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.merge_url is not None:
            result['MergeURL'] = self.merge_url
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('MergeURL') is not None:
            self.merge_url = m.get('MergeURL')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList(TeaModel):
    def __init__(
        self,
        merge: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge] = None,
    ):
        self.merge = merge

    def validate(self):
        if self.merge:
            for k in self.merge:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Merge'] = []
        if self.merge is not None:
            for k in self.merge:
                result['Merge'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.merge = []
        if m.get('Merge') is not None:
            for k in m.get('Merge'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge()
                self.merge.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif(TeaModel):
    def __init__(
        self,
        dither_mode: str = None,
        final_delay: str = None,
        is_custom_palette: str = None,
        loop: str = None,
    ):
        self.dither_mode = dither_mode
        self.final_delay = final_delay
        self.is_custom_palette = is_custom_palette
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dither_mode is not None:
            result['DitherMode'] = self.dither_mode
        if self.final_delay is not None:
            result['FinalDelay'] = self.final_delay
        if self.is_custom_palette is not None:
            result['IsCustomPalette'] = self.is_custom_palette
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DitherMode') is not None:
            self.dither_mode = m.get('DitherMode')
        if m.get('FinalDelay') is not None:
            self.final_delay = m.get('FinalDelay')
        if m.get('IsCustomPalette') is not None:
            self.is_custom_palette = m.get('IsCustomPalette')
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
    ):
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp(TeaModel):
    def __init__(
        self,
        loop: str = None,
    ):
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig(TeaModel):
    def __init__(
        self,
        gif: SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif = None,
        segment: SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment = None,
        webp: SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp = None,
    ):
        self.gif = gif
        self.segment = segment
        self.webp = webp

    def validate(self):
        if self.gif:
            self.gif.validate()
        if self.segment:
            self.segment.validate()
        if self.webp:
            self.webp.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gif is not None:
            result['Gif'] = self.gif.to_map()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        if self.webp is not None:
            result['Webp'] = self.webp.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gif') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif()
            self.gif = temp_model.from_map(m['Gif'])
        if m.get('Segment') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        if m.get('Webp') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp()
            self.webp = temp_model.from_map(m['Webp'])
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening(TeaModel):
    def __init__(
        self,
        height: str = None,
        start: str = None,
        width: str = None,
        open_url: str = None,
    ):
        self.height = height
        self.start = start
        self.width = width
        self.open_url = open_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.start is not None:
            result['Start'] = self.start
        if self.width is not None:
            result['Width'] = self.width
        if self.open_url is not None:
            result['openUrl'] = self.open_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('openUrl') is not None:
            self.open_url = m.get('openUrl')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList(TeaModel):
    def __init__(
        self,
        opening: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening] = None,
    ):
        self.opening = opening

    def validate(self):
        if self.opening:
            for k in self.opening:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Opening'] = []
        if self.opening is not None:
            for k in self.opening:
                result['Opening'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.opening = []
        if m.get('Opening') is not None:
            for k in m.get('Opening'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening()
                self.opening.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle(TeaModel):
    def __init__(
        self,
        map: str = None,
        message: str = None,
        out_subtitle_file: SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile = None,
        success: bool = None,
    ):
        self.map = map
        self.message = message
        self.out_subtitle_file = out_subtitle_file
        self.success = success

    def validate(self):
        if self.out_subtitle_file:
            self.out_subtitle_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.map is not None:
            result['Map'] = self.map
        if self.message is not None:
            result['Message'] = self.message
        if self.out_subtitle_file is not None:
            result['OutSubtitleFile'] = self.out_subtitle_file.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Map') is not None:
            self.map = m.get('Map')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('OutSubtitleFile') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile()
            self.out_subtitle_file = temp_model.from_map(m['OutSubtitleFile'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList(TeaModel):
    def __init__(
        self,
        out_subtitle: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle] = None,
    ):
        self.out_subtitle = out_subtitle

    def validate(self):
        if self.out_subtitle:
            for k in self.out_subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OutSubtitle'] = []
        if self.out_subtitle is not None:
            for k in self.out_subtitle:
                result['OutSubtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.out_subtitle = []
        if m.get('OutSubtitle') is not None:
            for k in m.get('OutSubtitle'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle()
                self.out_subtitle.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        format_long_name: str = None,
        format_name: str = None,
        num_programs: str = None,
        num_streams: str = None,
        size: str = None,
        start_time: str = None,
    ):
        self.bitrate = bitrate
        self.duration = duration
        self.format_long_name = format_long_name
        self.format_name = format_name
        self.num_programs = num_programs
        self.num_streams = num_streams
        self.size = size
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.format_long_name is not None:
            result['FormatLongName'] = self.format_long_name
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.num_programs is not None:
            result['NumPrograms'] = self.num_programs
        if self.num_streams is not None:
            result['NumStreams'] = self.num_streams
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FormatLongName') is not None:
            self.format_long_name = m.get('FormatLongName')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('NumPrograms') is not None:
            self.num_programs = m.get('NumPrograms')
        if m.get('NumStreams') is not None:
            self.num_streams = m.get('NumStreams')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        num_frames: str = None,
        sample_fmt: str = None,
        samplerate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        self.bitrate = bitrate
        self.channel_layout = channel_layout
        self.channels = channels
        self.codec_long_name = codec_long_name
        self.codec_name = codec_name
        self.codec_tag = codec_tag
        self.codec_tag_string = codec_tag_string
        self.codec_time_base = codec_time_base
        self.duration = duration
        self.index = index
        self.lang = lang
        self.num_frames = num_frames
        self.sample_fmt = sample_fmt
        self.samplerate = samplerate
        self.start_time = start_time
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList(TeaModel):
    def __init__(
        self,
        audio_stream: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream] = None,
    ):
        self.audio_stream = audio_stream

    def validate(self):
        if self.audio_stream:
            for k in self.audio_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStream'] = []
        if self.audio_stream is not None:
            for k in self.audio_stream:
                result['AudioStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream = []
        if m.get('AudioStream') is not None:
            for k in m.get('AudioStream'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream()
                self.audio_stream.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream(TeaModel):
    def __init__(
        self,
        index: str = None,
        lang: str = None,
    ):
        self.index = index
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList(TeaModel):
    def __init__(
        self,
        subtitle_stream: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream] = None,
    ):
        self.subtitle_stream = subtitle_stream

    def validate(self):
        if self.subtitle_stream:
            for k in self.subtitle_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubtitleStream'] = []
        if self.subtitle_stream is not None:
            for k in self.subtitle_stream:
                result['SubtitleStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle_stream = []
        if m.get('SubtitleStream') is not None:
            for k in m.get('SubtitleStream'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream()
                self.subtitle_stream.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost(TeaModel):
    def __init__(
        self,
        avg_bitrate: str = None,
        cost_bandwidth: str = None,
        preload_time: str = None,
    ):
        self.avg_bitrate = avg_bitrate
        self.cost_bandwidth = cost_bandwidth
        self.preload_time = preload_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_bitrate is not None:
            result['AvgBitrate'] = self.avg_bitrate
        if self.cost_bandwidth is not None:
            result['CostBandwidth'] = self.cost_bandwidth
        if self.preload_time is not None:
            result['PreloadTime'] = self.preload_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgBitrate') is not None:
            self.avg_bitrate = m.get('AvgBitrate')
        if m.get('CostBandwidth') is not None:
            self.cost_bandwidth = m.get('CostBandwidth')
        if m.get('PreloadTime') is not None:
            self.preload_time = m.get('PreloadTime')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bitrate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        network_cost: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        sar: str = None,
        start_time: str = None,
        timebase: str = None,
        width: str = None,
    ):
        self.avg_fps = avg_fps
        self.bitrate = bitrate
        self.codec_long_name = codec_long_name
        self.codec_name = codec_name
        self.codec_tag = codec_tag
        self.codec_tag_string = codec_tag_string
        self.codec_time_base = codec_time_base
        self.dar = dar
        self.duration = duration
        self.fps = fps
        self.has_bframes = has_bframes
        self.height = height
        self.index = index
        self.lang = lang
        self.level = level
        self.network_cost = network_cost
        self.num_frames = num_frames
        self.pix_fmt = pix_fmt
        self.profile = profile
        self.sar = sar
        self.start_time = start_time
        self.timebase = timebase
        self.width = width

    def validate(self):
        if self.network_cost:
            self.network_cost.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['AvgFPS'] = self.avg_fps
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['HasBFrames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.network_cost is not None:
            result['NetworkCost'] = self.network_cost.to_map()
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgFPS') is not None:
            self.avg_fps = m.get('AvgFPS')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HasBFrames') is not None:
            self.has_bframes = m.get('HasBFrames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NetworkCost') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost()
            self.network_cost = temp_model.from_map(m['NetworkCost'])
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList(TeaModel):
    def __init__(
        self,
        video_stream: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream] = None,
    ):
        self.video_stream = video_stream

    def validate(self):
        if self.video_stream:
            for k in self.video_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoStream'] = []
        if self.video_stream is not None:
            for k in self.video_stream:
                result['VideoStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_stream = []
        if m.get('VideoStream') is not None:
            for k in m.get('VideoStream'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream()
                self.video_stream.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams(TeaModel):
    def __init__(
        self,
        audio_stream_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList = None,
        subtitle_stream_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList = None,
        video_stream_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList = None,
    ):
        self.audio_stream_list = audio_stream_list
        self.subtitle_stream_list = subtitle_stream_list
        self.video_stream_list = video_stream_list

    def validate(self):
        if self.audio_stream_list:
            self.audio_stream_list.validate()
        if self.subtitle_stream_list:
            self.subtitle_stream_list.validate()
        if self.video_stream_list:
            self.video_stream_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_stream_list is not None:
            result['AudioStreamList'] = self.audio_stream_list.to_map()
        if self.subtitle_stream_list is not None:
            result['SubtitleStreamList'] = self.subtitle_stream_list.to_map()
        if self.video_stream_list is not None:
            result['VideoStreamList'] = self.video_stream_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioStreamList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList()
            self.audio_stream_list = temp_model.from_map(m['AudioStreamList'])
        if m.get('SubtitleStreamList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList()
            self.subtitle_stream_list = temp_model.from_map(m['SubtitleStreamList'])
        if m.get('VideoStreamList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList()
            self.video_stream_list = temp_model.from_map(m['VideoStreamList'])
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_format: str = None,
        file_size: str = None,
        format: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat = None,
        fps: str = None,
        height: str = None,
        streams: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.duration = duration
        self.file_format = file_format
        self.file_size = file_size
        self.format = format
        self.fps = fps
        self.height = height
        self.streams = streams
        self.width = width

    def validate(self):
        if self.format:
            self.format.validate()
        if self.streams:
            self.streams.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_format is not None:
            result['FileFormat'] = self.file_format
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.format is not None:
            result['Format'] = self.format.to_map()
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.streams is not None:
            result['Streams'] = self.streams.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileFormat') is not None:
            self.file_format = m.get('FileFormat')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('Format') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat()
            self.format = temp_model.from_map(m['Format'])
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Streams') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams()
            self.streams = temp_model.from_map(m['Streams'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle(TeaModel):
    def __init__(
        self,
        char_enc: str = None,
        font_name: str = None,
        input: SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput = None,
    ):
        self.char_enc = char_enc
        self.font_name = font_name
        self.input = input

    def validate(self):
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.char_enc is not None:
            result['CharEnc'] = self.char_enc
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.input is not None:
            result['Input'] = self.input.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CharEnc') is not None:
            self.char_enc = m.get('CharEnc')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('Input') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput()
            self.input = temp_model.from_map(m['Input'])
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList(TeaModel):
    def __init__(
        self,
        ext_subtitle: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle] = None,
    ):
        self.ext_subtitle = ext_subtitle

    def validate(self):
        if self.ext_subtitle:
            for k in self.ext_subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ExtSubtitle'] = []
        if self.ext_subtitle is not None:
            for k in self.ext_subtitle:
                result['ExtSubtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ext_subtitle = []
        if m.get('ExtSubtitle') is not None:
            for k in m.get('ExtSubtitle'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle()
                self.ext_subtitle.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle(TeaModel):
    def __init__(
        self,
        map: str = None,
    ):
        self.map = map

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.map is not None:
            result['Map'] = self.map
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Map') is not None:
            self.map = m.get('Map')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList(TeaModel):
    def __init__(
        self,
        subtitle: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle] = None,
    ):
        self.subtitle = subtitle

    def validate(self):
        if self.subtitle:
            for k in self.subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Subtitle'] = []
        if self.subtitle is not None:
            for k in self.subtitle:
                result['Subtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle = []
        if m.get('Subtitle') is not None:
            for k in m.get('Subtitle'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle()
                self.subtitle.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig(TeaModel):
    def __init__(
        self,
        ext_subtitle_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList = None,
        subtitle_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList = None,
    ):
        self.ext_subtitle_list = ext_subtitle_list
        self.subtitle_list = subtitle_list

    def validate(self):
        if self.ext_subtitle_list:
            self.ext_subtitle_list.validate()
        if self.subtitle_list:
            self.subtitle_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ext_subtitle_list is not None:
            result['ExtSubtitleList'] = self.ext_subtitle_list.to_map()
        if self.subtitle_list is not None:
            result['SubtitleList'] = self.subtitle_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExtSubtitleList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList()
            self.ext_subtitle_list = temp_model.from_map(m['ExtSubtitleList'])
        if m.get('SubtitleList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList()
            self.subtitle_list = temp_model.from_map(m['SubtitleList'])
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso(TeaModel):
    def __init__(
        self,
        is_half_sample: str = None,
    ):
        self.is_half_sample = is_half_sample

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_half_sample is not None:
            result['IsHalfSample'] = self.is_half_sample
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsHalfSample') is not None:
            self.is_half_sample = m.get('IsHalfSample')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate(TeaModel):
    def __init__(
        self,
        bg_color: str = None,
        blend_duration: str = None,
        height: str = None,
        is_merge_audio: bool = None,
        start: str = None,
        tail_url: str = None,
        width: str = None,
    ):
        self.bg_color = bg_color
        self.blend_duration = blend_duration
        self.height = height
        self.is_merge_audio = is_merge_audio
        self.start = start
        self.tail_url = tail_url
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bg_color is not None:
            result['BgColor'] = self.bg_color
        if self.blend_duration is not None:
            result['BlendDuration'] = self.blend_duration
        if self.height is not None:
            result['Height'] = self.height
        if self.is_merge_audio is not None:
            result['IsMergeAudio'] = self.is_merge_audio
        if self.start is not None:
            result['Start'] = self.start
        if self.tail_url is not None:
            result['TailUrl'] = self.tail_url
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BgColor') is not None:
            self.bg_color = m.get('BgColor')
        if m.get('BlendDuration') is not None:
            self.blend_duration = m.get('BlendDuration')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('IsMergeAudio') is not None:
            self.is_merge_audio = m.get('IsMergeAudio')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('TailUrl') is not None:
            self.tail_url = m.get('TailUrl')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList(TeaModel):
    def __init__(
        self,
        tail_slate: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate] = None,
    ):
        self.tail_slate = tail_slate

    def validate(self):
        if self.tail_slate:
            for k in self.tail_slate:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TailSlate'] = []
        if self.tail_slate is not None:
            for k in self.tail_slate:
                result['TailSlate'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tail_slate = []
        if m.get('TailSlate') is not None:
            for k in m.get('TailSlate'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate()
                self.tail_slate.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        is_check_audio_bitrate: str = None,
        is_check_audio_bitrate_fail: str = None,
        is_check_reso: str = None,
        is_check_reso_fail: str = None,
        is_check_video_bitrate: str = None,
        is_check_video_bitrate_fail: str = None,
        trans_mode: str = None,
    ):
        self.adj_dar_method = adj_dar_method
        self.is_check_audio_bitrate = is_check_audio_bitrate
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        self.is_check_reso = is_check_reso
        self.is_check_reso_fail = is_check_reso_fail
        self.is_check_video_bitrate = is_check_video_bitrate
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd(TeaModel):
    def __init__(
        self,
        max: str = None,
        min: str = None,
    ):
        self.max = max
        self.min = min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        bitrate_bnd: SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        degrain: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        max_fps: str = None,
        maxrate: str = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        qscale: str = None,
        reso_priority: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.bitrate_bnd = bitrate_bnd
        self.bufsize = bufsize
        self.codec = codec
        self.crf = crf
        self.crop = crop
        self.degrain = degrain
        self.fps = fps
        self.gop = gop
        self.height = height
        self.max_fps = max_fps
        self.maxrate = maxrate
        self.pad = pad
        self.pix_fmt = pix_fmt
        self.preset = preset
        self.profile = profile
        self.qscale = qscale
        self.reso_priority = reso_priority
        self.scan_mode = scan_mode
        self.width = width

    def validate(self):
        if self.bitrate_bnd:
            self.bitrate_bnd.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bitrate_bnd is not None:
            result['BitrateBnd'] = self.bitrate_bnd.to_map()
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.degrain is not None:
            result['Degrain'] = self.degrain
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.max_fps is not None:
            result['MaxFps'] = self.max_fps
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.reso_priority is not None:
            result['ResoPriority'] = self.reso_priority
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BitrateBnd') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd()
            self.bitrate_bnd = temp_model.from_map(m['BitrateBnd'])
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Degrain') is not None:
            self.degrain = m.get('Degrain')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MaxFps') is not None:
            self.max_fps = m.get('MaxFps')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('ResoPriority') is not None:
            self.reso_priority = m.get('ResoPriority')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        input_file: SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile = None,
        refer_pos: str = None,
        type: str = None,
        water_mark_template_id: str = None,
        width: str = None,
    ):
        self.dx = dx
        self.dy = dy
        self.height = height
        self.input_file = input_file
        self.refer_pos = refer_pos
        self.type = type
        self.water_mark_template_id = water_mark_template_id
        self.width = width

    def validate(self):
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.type is not None:
            result['Type'] = self.type
        if self.water_mark_template_id is not None:
            result['WaterMarkTemplateId'] = self.water_mark_template_id
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('InputFile') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WaterMarkTemplateId') is not None:
            self.water_mark_template_id = m.get('WaterMarkTemplateId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList(TeaModel):
    def __init__(
        self,
        water_mark: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark] = None,
    ):
        self.water_mark = water_mark

    def validate(self):
        if self.water_mark:
            for k in self.water_mark:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WaterMark'] = []
        if self.water_mark is not None:
            for k in self.water_mark:
                result['WaterMark'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.water_mark = []
        if m.get('WaterMark') is not None:
            for k in m.get('WaterMark'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark()
                self.water_mark.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutput(TeaModel):
    def __init__(
        self,
        amix_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList = None,
        audio: SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio = None,
        audio_stream_map: str = None,
        clip: SubmitJobsResponseBodyJobResultListJobResultJobOutputClip = None,
        container: SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer = None,
        de_watermark: str = None,
        digi_water_mark: SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark = None,
        encryption: SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption = None,
        m_3u8non_standard_support: SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport = None,
        merge_config_url: str = None,
        merge_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList = None,
        mux_config: SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig = None,
        opening_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList = None,
        out_subtitle_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList = None,
        output_file: SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile = None,
        priority: str = None,
        properties: SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties = None,
        rotate: str = None,
        subtitle_config: SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig = None,
        super_reso: SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso = None,
        tail_slate_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList = None,
        template_id: str = None,
        trans_config: SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig = None,
        user_data: str = None,
        video: SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo = None,
        video_stream_map: str = None,
        water_mark_config_url: str = None,
        water_mark_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList = None,
    ):
        self.amix_list = amix_list
        self.audio = audio
        self.audio_stream_map = audio_stream_map
        self.clip = clip
        self.container = container
        self.de_watermark = de_watermark
        self.digi_water_mark = digi_water_mark
        self.encryption = encryption
        self.m_3u8non_standard_support = m_3u8non_standard_support
        self.merge_config_url = merge_config_url
        self.merge_list = merge_list
        self.mux_config = mux_config
        self.opening_list = opening_list
        self.out_subtitle_list = out_subtitle_list
        self.output_file = output_file
        self.priority = priority
        self.properties = properties
        self.rotate = rotate
        self.subtitle_config = subtitle_config
        self.super_reso = super_reso
        self.tail_slate_list = tail_slate_list
        self.template_id = template_id
        self.trans_config = trans_config
        self.user_data = user_data
        self.video = video
        self.video_stream_map = video_stream_map
        self.water_mark_config_url = water_mark_config_url
        self.water_mark_list = water_mark_list

    def validate(self):
        if self.amix_list:
            self.amix_list.validate()
        if self.audio:
            self.audio.validate()
        if self.clip:
            self.clip.validate()
        if self.container:
            self.container.validate()
        if self.digi_water_mark:
            self.digi_water_mark.validate()
        if self.encryption:
            self.encryption.validate()
        if self.m_3u8non_standard_support:
            self.m_3u8non_standard_support.validate()
        if self.merge_list:
            self.merge_list.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.opening_list:
            self.opening_list.validate()
        if self.out_subtitle_list:
            self.out_subtitle_list.validate()
        if self.output_file:
            self.output_file.validate()
        if self.properties:
            self.properties.validate()
        if self.subtitle_config:
            self.subtitle_config.validate()
        if self.super_reso:
            self.super_reso.validate()
        if self.tail_slate_list:
            self.tail_slate_list.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()
        if self.water_mark_list:
            self.water_mark_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amix_list is not None:
            result['AmixList'] = self.amix_list.to_map()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.audio_stream_map is not None:
            result['AudioStreamMap'] = self.audio_stream_map
        if self.clip is not None:
            result['Clip'] = self.clip.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.de_watermark is not None:
            result['DeWatermark'] = self.de_watermark
        if self.digi_water_mark is not None:
            result['DigiWaterMark'] = self.digi_water_mark.to_map()
        if self.encryption is not None:
            result['Encryption'] = self.encryption.to_map()
        if self.m_3u8non_standard_support is not None:
            result['M3U8NonStandardSupport'] = self.m_3u8non_standard_support.to_map()
        if self.merge_config_url is not None:
            result['MergeConfigUrl'] = self.merge_config_url
        if self.merge_list is not None:
            result['MergeList'] = self.merge_list.to_map()
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.opening_list is not None:
            result['OpeningList'] = self.opening_list.to_map()
        if self.out_subtitle_list is not None:
            result['OutSubtitleList'] = self.out_subtitle_list.to_map()
        if self.output_file is not None:
            result['OutputFile'] = self.output_file.to_map()
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.properties is not None:
            result['Properties'] = self.properties.to_map()
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.subtitle_config is not None:
            result['SubtitleConfig'] = self.subtitle_config.to_map()
        if self.super_reso is not None:
            result['SuperReso'] = self.super_reso.to_map()
        if self.tail_slate_list is not None:
            result['TailSlateList'] = self.tail_slate_list.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.video is not None:
            result['Video'] = self.video.to_map()
        if self.video_stream_map is not None:
            result['VideoStreamMap'] = self.video_stream_map
        if self.water_mark_config_url is not None:
            result['WaterMarkConfigUrl'] = self.water_mark_config_url
        if self.water_mark_list is not None:
            result['WaterMarkList'] = self.water_mark_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AmixList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList()
            self.amix_list = temp_model.from_map(m['AmixList'])
        if m.get('Audio') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('AudioStreamMap') is not None:
            self.audio_stream_map = m.get('AudioStreamMap')
        if m.get('Clip') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputClip()
            self.clip = temp_model.from_map(m['Clip'])
        if m.get('Container') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('DeWatermark') is not None:
            self.de_watermark = m.get('DeWatermark')
        if m.get('DigiWaterMark') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark()
            self.digi_water_mark = temp_model.from_map(m['DigiWaterMark'])
        if m.get('Encryption') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption()
            self.encryption = temp_model.from_map(m['Encryption'])
        if m.get('M3U8NonStandardSupport') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport()
            self.m_3u8non_standard_support = temp_model.from_map(m['M3U8NonStandardSupport'])
        if m.get('MergeConfigUrl') is not None:
            self.merge_config_url = m.get('MergeConfigUrl')
        if m.get('MergeList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList()
            self.merge_list = temp_model.from_map(m['MergeList'])
        if m.get('MuxConfig') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('OpeningList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList()
            self.opening_list = temp_model.from_map(m['OpeningList'])
        if m.get('OutSubtitleList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList()
            self.out_subtitle_list = temp_model.from_map(m['OutSubtitleList'])
        if m.get('OutputFile') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile()
            self.output_file = temp_model.from_map(m['OutputFile'])
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Properties') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties()
            self.properties = temp_model.from_map(m['Properties'])
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('SubtitleConfig') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig()
            self.subtitle_config = temp_model.from_map(m['SubtitleConfig'])
        if m.get('SuperReso') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso()
            self.super_reso = temp_model.from_map(m['SuperReso'])
        if m.get('TailSlateList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList()
            self.tail_slate_list = temp_model.from_map(m['TailSlateList'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TransConfig') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('Video') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo()
            self.video = temp_model.from_map(m['Video'])
        if m.get('VideoStreamMap') is not None:
            self.video_stream_map = m.get('VideoStreamMap')
        if m.get('WaterMarkConfigUrl') is not None:
            self.water_mark_config_url = m.get('WaterMarkConfigUrl')
        if m.get('WaterMarkList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList()
            self.water_mark_list = temp_model.from_map(m['WaterMarkList'])
        return self


class SubmitJobsResponseBodyJobResultListJobResultJob(TeaModel):
    def __init__(
        self,
        code: str = None,
        creation_time: str = None,
        finish_time: str = None,
        input: SubmitJobsResponseBodyJobResultListJobResultJobInput = None,
        job_id: str = None,
        mnsmessage_result: SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult = None,
        message: str = None,
        output: SubmitJobsResponseBodyJobResultListJobResultJobOutput = None,
        percent: int = None,
        pipeline_id: str = None,
        state: str = None,
    ):
        self.code = code
        self.creation_time = creation_time
        self.finish_time = finish_time
        self.input = input
        self.job_id = job_id
        self.mnsmessage_result = mnsmessage_result
        self.message = message
        self.output = output
        self.percent = percent
        self.pipeline_id = pipeline_id
        self.state = state

    def validate(self):
        if self.input:
            self.input.validate()
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MNSMessageResult') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Output') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class SubmitJobsResponseBodyJobResultListJobResult(TeaModel):
    def __init__(
        self,
        code: str = None,
        job: SubmitJobsResponseBodyJobResultListJobResultJob = None,
        message: str = None,
        success: bool = None,
    ):
        self.code = code
        self.job = job
        self.message = message
        self.success = success

    def validate(self):
        if self.job:
            self.job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.job is not None:
            result['Job'] = self.job.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Job') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJob()
            self.job = temp_model.from_map(m['Job'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitJobsResponseBodyJobResultList(TeaModel):
    def __init__(
        self,
        job_result: List[SubmitJobsResponseBodyJobResultListJobResult] = None,
    ):
        self.job_result = job_result

    def validate(self):
        if self.job_result:
            for k in self.job_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JobResult'] = []
        if self.job_result is not None:
            for k in self.job_result:
                result['JobResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.job_result = []
        if m.get('JobResult') is not None:
            for k in m.get('JobResult'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResult()
                self.job_result.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBody(TeaModel):
    def __init__(
        self,
        job_result_list: SubmitJobsResponseBodyJobResultList = None,
        request_id: str = None,
    ):
        self.job_result_list = job_result_list
        self.request_id = request_id

    def validate(self):
        if self.job_result_list:
            self.job_result_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_result_list is not None:
            result['JobResultList'] = self.job_result_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobResultList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultList()
            self.job_result_list = temp_model.from_map(m['JobResultList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitMediaInfoJobRequest(TeaModel):
    def __init__(
        self,
        async_: bool = None,
        input: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        user_data: str = None,
    ):
        self.async_ = async_
        # This parameter is required.
        self.input = input
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_ is not None:
            result['Async'] = self.async_
        if self.input is not None:
            result['Input'] = self.input
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Async') is not None:
            self.async_ = m.get('Async')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        format_long_name: str = None,
        format_name: str = None,
        num_programs: str = None,
        num_streams: str = None,
        size: str = None,
        start_time: str = None,
    ):
        self.bitrate = bitrate
        self.duration = duration
        self.format_long_name = format_long_name
        self.format_name = format_name
        self.num_programs = num_programs
        self.num_streams = num_streams
        self.size = size
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.format_long_name is not None:
            result['FormatLongName'] = self.format_long_name
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.num_programs is not None:
            result['NumPrograms'] = self.num_programs
        if self.num_streams is not None:
            result['NumStreams'] = self.num_streams
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FormatLongName') is not None:
            self.format_long_name = m.get('FormatLongName')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('NumPrograms') is not None:
            self.num_programs = m.get('NumPrograms')
        if m.get('NumStreams') is not None:
            self.num_streams = m.get('NumStreams')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        num_frames: str = None,
        sample_fmt: str = None,
        samplerate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        self.bitrate = bitrate
        self.channel_layout = channel_layout
        self.channels = channels
        self.codec_long_name = codec_long_name
        self.codec_name = codec_name
        self.codec_tag = codec_tag
        self.codec_tag_string = codec_tag_string
        self.codec_time_base = codec_time_base
        self.duration = duration
        self.index = index
        self.lang = lang
        self.num_frames = num_frames
        self.sample_fmt = sample_fmt
        self.samplerate = samplerate
        self.start_time = start_time
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList(TeaModel):
    def __init__(
        self,
        audio_stream: List[SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream] = None,
    ):
        self.audio_stream = audio_stream

    def validate(self):
        if self.audio_stream:
            for k in self.audio_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStream'] = []
        if self.audio_stream is not None:
            for k in self.audio_stream:
                result['AudioStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream = []
        if m.get('AudioStream') is not None:
            for k in m.get('AudioStream'):
                temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream()
                self.audio_stream.append(temp_model.from_map(k))
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream(TeaModel):
    def __init__(
        self,
        index: str = None,
        lang: str = None,
    ):
        self.index = index
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList(TeaModel):
    def __init__(
        self,
        subtitle_stream: List[SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream] = None,
    ):
        self.subtitle_stream = subtitle_stream

    def validate(self):
        if self.subtitle_stream:
            for k in self.subtitle_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubtitleStream'] = []
        if self.subtitle_stream is not None:
            for k in self.subtitle_stream:
                result['SubtitleStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle_stream = []
        if m.get('SubtitleStream') is not None:
            for k in m.get('SubtitleStream'):
                temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream()
                self.subtitle_stream.append(temp_model.from_map(k))
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost(TeaModel):
    def __init__(
        self,
        avg_bitrate: str = None,
        cost_bandwidth: str = None,
        preload_time: str = None,
    ):
        self.avg_bitrate = avg_bitrate
        self.cost_bandwidth = cost_bandwidth
        self.preload_time = preload_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_bitrate is not None:
            result['AvgBitrate'] = self.avg_bitrate
        if self.cost_bandwidth is not None:
            result['CostBandwidth'] = self.cost_bandwidth
        if self.preload_time is not None:
            result['PreloadTime'] = self.preload_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgBitrate') is not None:
            self.avg_bitrate = m.get('AvgBitrate')
        if m.get('CostBandwidth') is not None:
            self.cost_bandwidth = m.get('CostBandwidth')
        if m.get('PreloadTime') is not None:
            self.preload_time = m.get('PreloadTime')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bitrate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        network_cost: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        rotate: str = None,
        sar: str = None,
        start_time: str = None,
        timebase: str = None,
        width: str = None,
    ):
        self.avg_fps = avg_fps
        self.bitrate = bitrate
        self.codec_long_name = codec_long_name
        self.codec_name = codec_name
        self.codec_tag = codec_tag
        self.codec_tag_string = codec_tag_string
        self.codec_time_base = codec_time_base
        self.dar = dar
        self.duration = duration
        self.fps = fps
        self.has_bframes = has_bframes
        self.height = height
        self.index = index
        self.lang = lang
        self.level = level
        self.network_cost = network_cost
        self.num_frames = num_frames
        self.pix_fmt = pix_fmt
        self.profile = profile
        self.rotate = rotate
        self.sar = sar
        self.start_time = start_time
        self.timebase = timebase
        self.width = width

    def validate(self):
        if self.network_cost:
            self.network_cost.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['AvgFPS'] = self.avg_fps
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['HasBFrames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.network_cost is not None:
            result['NetworkCost'] = self.network_cost.to_map()
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgFPS') is not None:
            self.avg_fps = m.get('AvgFPS')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HasBFrames') is not None:
            self.has_bframes = m.get('HasBFrames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NetworkCost') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost()
            self.network_cost = temp_model.from_map(m['NetworkCost'])
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList(TeaModel):
    def __init__(
        self,
        video_stream: List[SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream] = None,
    ):
        self.video_stream = video_stream

    def validate(self):
        if self.video_stream:
            for k in self.video_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoStream'] = []
        if self.video_stream is not None:
            for k in self.video_stream:
                result['VideoStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_stream = []
        if m.get('VideoStream') is not None:
            for k in m.get('VideoStream'):
                temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream()
                self.video_stream.append(temp_model.from_map(k))
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams(TeaModel):
    def __init__(
        self,
        audio_stream_list: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList = None,
        subtitle_stream_list: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList = None,
        video_stream_list: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList = None,
    ):
        self.audio_stream_list = audio_stream_list
        self.subtitle_stream_list = subtitle_stream_list
        self.video_stream_list = video_stream_list

    def validate(self):
        if self.audio_stream_list:
            self.audio_stream_list.validate()
        if self.subtitle_stream_list:
            self.subtitle_stream_list.validate()
        if self.video_stream_list:
            self.video_stream_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_stream_list is not None:
            result['AudioStreamList'] = self.audio_stream_list.to_map()
        if self.subtitle_stream_list is not None:
            result['SubtitleStreamList'] = self.subtitle_stream_list.to_map()
        if self.video_stream_list is not None:
            result['VideoStreamList'] = self.video_stream_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioStreamList') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList()
            self.audio_stream_list = temp_model.from_map(m['AudioStreamList'])
        if m.get('SubtitleStreamList') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList()
            self.subtitle_stream_list = temp_model.from_map(m['SubtitleStreamList'])
        if m.get('VideoStreamList') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList()
            self.video_stream_list = temp_model.from_map(m['VideoStreamList'])
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobProperties(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_format: str = None,
        file_size: str = None,
        format: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat = None,
        fps: str = None,
        height: str = None,
        streams: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.duration = duration
        self.file_format = file_format
        self.file_size = file_size
        self.format = format
        self.fps = fps
        self.height = height
        self.streams = streams
        self.width = width

    def validate(self):
        if self.format:
            self.format.validate()
        if self.streams:
            self.streams.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_format is not None:
            result['FileFormat'] = self.file_format
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.format is not None:
            result['Format'] = self.format.to_map()
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.streams is not None:
            result['Streams'] = self.streams.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileFormat') is not None:
            self.file_format = m.get('FileFormat')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('Format') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat()
            self.format = temp_model.from_map(m['Format'])
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Streams') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams()
            self.streams = temp_model.from_map(m['Streams'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJob(TeaModel):
    def __init__(
        self,
        async_: bool = None,
        code: str = None,
        creation_time: str = None,
        input: SubmitMediaInfoJobResponseBodyMediaInfoJobInput = None,
        job_id: str = None,
        mnsmessage_result: SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult = None,
        message: str = None,
        pipeline_id: str = None,
        properties: SubmitMediaInfoJobResponseBodyMediaInfoJobProperties = None,
        state: str = None,
        user_data: str = None,
    ):
        self.async_ = async_
        self.code = code
        self.creation_time = creation_time
        self.input = input
        self.job_id = job_id
        self.mnsmessage_result = mnsmessage_result
        self.message = message
        self.pipeline_id = pipeline_id
        self.properties = properties
        self.state = state
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()
        if self.properties:
            self.properties.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_ is not None:
            result['Async'] = self.async_
        if self.code is not None:
            result['Code'] = self.code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.properties is not None:
            result['Properties'] = self.properties.to_map()
        if self.state is not None:
            result['State'] = self.state
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Async') is not None:
            self.async_ = m.get('Async')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Input') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MNSMessageResult') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Properties') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobProperties()
            self.properties = temp_model.from_map(m['Properties'])
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitMediaInfoJobResponseBody(TeaModel):
    def __init__(
        self,
        media_info_job: SubmitMediaInfoJobResponseBodyMediaInfoJob = None,
        request_id: str = None,
    ):
        self.media_info_job = media_info_job
        self.request_id = request_id

    def validate(self):
        if self.media_info_job:
            self.media_info_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_info_job is not None:
            result['MediaInfoJob'] = self.media_info_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaInfoJob') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJob()
            self.media_info_job = temp_model.from_map(m['MediaInfoJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitMediaInfoJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitMediaInfoJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitMediaInfoJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitSnapshotJobRequest(TeaModel):
    def __init__(
        self,
        input: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        snapshot_config: str = None,
        user_data: str = None,
    ):
        # This parameter is required.
        self.input = input
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # This parameter is required.
        self.snapshot_config = snapshot_config
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input is not None:
            result['Input'] = self.input
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.snapshot_config is not None:
            result['SnapshotConfig'] = self.snapshot_config
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SnapshotConfig') is not None:
            self.snapshot_config = m.get('SnapshotConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitSnapshotJobResponseBodySnapshotJobInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut(TeaModel):
    def __init__(
        self,
        cell_height: str = None,
        cell_sel_step: str = None,
        cell_width: str = None,
        color: str = None,
        columns: str = None,
        is_keep_cell_pic: str = None,
        lines: str = None,
        margin: str = None,
        padding: str = None,
    ):
        self.cell_height = cell_height
        self.cell_sel_step = cell_sel_step
        self.cell_width = cell_width
        self.color = color
        self.columns = columns
        self.is_keep_cell_pic = is_keep_cell_pic
        self.lines = lines
        self.margin = margin
        self.padding = padding

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cell_height is not None:
            result['CellHeight'] = self.cell_height
        if self.cell_sel_step is not None:
            result['CellSelStep'] = self.cell_sel_step
        if self.cell_width is not None:
            result['CellWidth'] = self.cell_width
        if self.color is not None:
            result['Color'] = self.color
        if self.columns is not None:
            result['Columns'] = self.columns
        if self.is_keep_cell_pic is not None:
            result['IsKeepCellPic'] = self.is_keep_cell_pic
        if self.lines is not None:
            result['Lines'] = self.lines
        if self.margin is not None:
            result['Margin'] = self.margin
        if self.padding is not None:
            result['Padding'] = self.padding
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CellHeight') is not None:
            self.cell_height = m.get('CellHeight')
        if m.get('CellSelStep') is not None:
            self.cell_sel_step = m.get('CellSelStep')
        if m.get('CellWidth') is not None:
            self.cell_width = m.get('CellWidth')
        if m.get('Color') is not None:
            self.color = m.get('Color')
        if m.get('Columns') is not None:
            self.columns = m.get('Columns')
        if m.get('IsKeepCellPic') is not None:
            self.is_keep_cell_pic = m.get('IsKeepCellPic')
        if m.get('Lines') is not None:
            self.lines = m.get('Lines')
        if m.get('Margin') is not None:
            self.margin = m.get('Margin')
        if m.get('Padding') is not None:
            self.padding = m.get('Padding')
        return self


class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        self.bucket = bucket
        self.location = location
        self.object = object
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig(TeaModel):
    def __init__(
        self,
        frame_type: str = None,
        height: str = None,
        interval: str = None,
        num: str = None,
        output_file: SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile = None,
        tile_out: SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut = None,
        tile_output_file: SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile = None,
        time: str = None,
        width: str = None,
    ):
        self.frame_type = frame_type
        self.height = height
        self.interval = interval
        self.num = num
        self.output_file = output_file
        self.tile_out = tile_out
        self.tile_output_file = tile_output_file
        self.time = time
        self.width = width

    def validate(self):
        if self.output_file:
            self.output_file.validate()
        if self.tile_out:
            self.tile_out.validate()
        if self.tile_output_file:
            self.tile_output_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.frame_type is not None:
            result['FrameType'] = self.frame_type
        if self.height is not None:
            result['Height'] = self.height
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.num is not None:
            result['Num'] = self.num
        if self.output_file is not None:
            result['OutputFile'] = self.output_file.to_map()
        if self.tile_out is not None:
            result['TileOut'] = self.tile_out.to_map()
        if self.tile_output_file is not None:
            result['TileOutputFile'] = self.tile_output_file.to_map()
        if self.time is not None:
            result['Time'] = self.time
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FrameType') is not None:
            self.frame_type = m.get('FrameType')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('Num') is not None:
            self.num = m.get('Num')
        if m.get('OutputFile') is not None:
            temp_model = SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile()
            self.output_file = temp_model.from_map(m['OutputFile'])
        if m.get('TileOut') is not None:
            temp_model = SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut()
            self.tile_out = temp_model.from_map(m['TileOut'])
        if m.get('TileOutputFile') is not None:
            temp_model = SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile()
            self.tile_output_file = temp_model.from_map(m['TileOutputFile'])
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitSnapshotJobResponseBodySnapshotJob(TeaModel):
    def __init__(
        self,
        code: str = None,
        count: str = None,
        creation_time: str = None,
        id: str = None,
        input: SubmitSnapshotJobResponseBodySnapshotJobInput = None,
        mnsmessage_result: SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult = None,
        message: str = None,
        pipeline_id: str = None,
        snapshot_config: SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig = None,
        state: str = None,
        tile_count: str = None,
        user_data: str = None,
    ):
        self.code = code
        self.count = count
        self.creation_time = creation_time
        self.id = id
        self.input = input
        self.mnsmessage_result = mnsmessage_result
        self.message = message
        self.pipeline_id = pipeline_id
        self.snapshot_config = snapshot_config
        self.state = state
        self.tile_count = tile_count
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()
        if self.snapshot_config:
            self.snapshot_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.count is not None:
            result['Count'] = self.count
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.id is not None:
            result['Id'] = self.id
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.snapshot_config is not None:
            result['SnapshotConfig'] = self.snapshot_config.to_map()
        if self.state is not None:
            result['State'] = self.state
        if self.tile_count is not None:
            result['TileCount'] = self.tile_count
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Input') is not None:
            temp_model = SubmitSnapshotJobResponseBodySnapshotJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('MNSMessageResult') is not None:
            temp_model = SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('SnapshotConfig') is not None:
            temp_model = SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig()
            self.snapshot_config = temp_model.from_map(m['SnapshotConfig'])
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TileCount') is not None:
            self.tile_count = m.get('TileCount')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitSnapshotJobResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        snapshot_job: SubmitSnapshotJobResponseBodySnapshotJob = None,
    ):
        self.request_id = request_id
        self.snapshot_job = snapshot_job

    def validate(self):
        if self.snapshot_job:
            self.snapshot_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snapshot_job is not None:
            result['SnapshotJob'] = self.snapshot_job.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnapshotJob') is not None:
            temp_model = SubmitSnapshotJobResponseBodySnapshotJob()
            self.snapshot_job = temp_model.from_map(m['SnapshotJob'])
        return self


class SubmitSnapshotJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitSnapshotJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitSnapshotJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnbindInputBucketRequest(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        role_arn: str = None,
    ):
        # This parameter is required.
        self.bucket = bucket
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class UnbindInputBucketResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnbindInputBucketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnbindInputBucketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnbindInputBucketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnbindOutputBucketRequest(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.bucket = bucket
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class UnbindOutputBucketResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnbindOutputBucketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnbindOutputBucketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnbindOutputBucketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCategoryNameRequest(TeaModel):
    def __init__(
        self,
        cate_id: str = None,
        cate_name: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.cate_id = cate_id
        # This parameter is required.
        self.cate_name = cate_name
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.cate_name is not None:
            result['CateName'] = self.cate_name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CateName') is not None:
            self.cate_name = m.get('CateName')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class UpdateCategoryNameResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateCategoryNameResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCategoryNameResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCategoryNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaRequest(TeaModel):
    def __init__(
        self,
        cate_id: int = None,
        cover_url: str = None,
        description: str = None,
        media_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        tags: str = None,
        title: str = None,
    ):
        self.cate_id = cate_id
        self.cover_url = cover_url
        self.description = description
        # This parameter is required.
        self.media_id = media_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        self.tags = tags
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.description is not None:
            result['Description'] = self.description
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class UpdateMediaResponseBodyMediaFile(TeaModel):
    def __init__(
        self,
        state: str = None,
        url: str = None,
    ):
        self.state = state
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['State'] = self.state
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class UpdateMediaResponseBodyMediaRunIdList(TeaModel):
    def __init__(
        self,
        run_id: List[str] = None,
    ):
        self.run_id = run_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.run_id is not None:
            result['RunId'] = self.run_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RunId') is not None:
            self.run_id = m.get('RunId')
        return self


class UpdateMediaResponseBodyMediaTags(TeaModel):
    def __init__(
        self,
        tag: List[str] = None,
    ):
        self.tag = tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class UpdateMediaResponseBodyMedia(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        cate_id: int = None,
        censor_state: str = None,
        cover_url: str = None,
        creation_time: str = None,
        description: str = None,
        duration: str = None,
        file: UpdateMediaResponseBodyMediaFile = None,
        format: str = None,
        fps: str = None,
        height: str = None,
        media_id: str = None,
        publish_state: str = None,
        run_id_list: UpdateMediaResponseBodyMediaRunIdList = None,
        size: str = None,
        tags: UpdateMediaResponseBodyMediaTags = None,
        title: str = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.cate_id = cate_id
        self.censor_state = censor_state
        self.cover_url = cover_url
        self.creation_time = creation_time
        self.description = description
        self.duration = duration
        self.file = file
        self.format = format
        self.fps = fps
        self.height = height
        self.media_id = media_id
        self.publish_state = publish_state
        self.run_id_list = run_id_list
        self.size = size
        self.tags = tags
        self.title = title
        self.width = width

    def validate(self):
        if self.file:
            self.file.validate()
        if self.run_id_list:
            self.run_id_list.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.censor_state is not None:
            result['CensorState'] = self.censor_state
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.publish_state is not None:
            result['PublishState'] = self.publish_state
        if self.run_id_list is not None:
            result['RunIdList'] = self.run_id_list.to_map()
        if self.size is not None:
            result['Size'] = self.size
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.title is not None:
            result['Title'] = self.title
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CensorState') is not None:
            self.censor_state = m.get('CensorState')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('File') is not None:
            temp_model = UpdateMediaResponseBodyMediaFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('PublishState') is not None:
            self.publish_state = m.get('PublishState')
        if m.get('RunIdList') is not None:
            temp_model = UpdateMediaResponseBodyMediaRunIdList()
            self.run_id_list = temp_model.from_map(m['RunIdList'])
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Tags') is not None:
            temp_model = UpdateMediaResponseBodyMediaTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class UpdateMediaResponseBody(TeaModel):
    def __init__(
        self,
        media: UpdateMediaResponseBodyMedia = None,
        request_id: str = None,
    ):
        self.media = media
        self.request_id = request_id

    def validate(self):
        if self.media:
            self.media.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            temp_model = UpdateMediaResponseBodyMedia()
            self.media = temp_model.from_map(m['Media'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateMediaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMediaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaCategoryRequest(TeaModel):
    def __init__(
        self,
        cate_id: int = None,
        media_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        self.cate_id = cate_id
        # This parameter is required.
        self.media_id = media_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class UpdateMediaCategoryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateMediaCategoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMediaCategoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaCategoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaCoverRequest(TeaModel):
    def __init__(
        self,
        cover_url: str = None,
        media_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        self.cover_url = cover_url
        # This parameter is required.
        self.media_id = media_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class UpdateMediaCoverResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateMediaCoverResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMediaCoverResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaCoverResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaPublishStateRequest(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        publish: bool = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.media_id = media_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.publish = publish
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.publish is not None:
            result['Publish'] = self.publish
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Publish') is not None:
            self.publish = m.get('Publish')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class UpdateMediaPublishStateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateMediaPublishStateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMediaPublishStateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaPublishStateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaWorkflowRequest(TeaModel):
    def __init__(
        self,
        media_workflow_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        topology: str = None,
    ):
        # This parameter is required.
        self.media_workflow_id = media_workflow_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # This parameter is required.
        self.topology = topology

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.topology is not None:
            result['Topology'] = self.topology
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Topology') is not None:
            self.topology = m.get('Topology')
        return self


class UpdateMediaWorkflowResponseBodyMediaWorkflow(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        media_workflow_id: str = None,
        name: str = None,
        state: str = None,
        topology: str = None,
        trigger_mode: str = None,
    ):
        self.creation_time = creation_time
        self.media_workflow_id = media_workflow_id
        self.name = name
        self.state = state
        self.topology = topology
        self.trigger_mode = trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.topology is not None:
            result['Topology'] = self.topology
        if self.trigger_mode is not None:
            result['TriggerMode'] = self.trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Topology') is not None:
            self.topology = m.get('Topology')
        if m.get('TriggerMode') is not None:
            self.trigger_mode = m.get('TriggerMode')
        return self


class UpdateMediaWorkflowResponseBody(TeaModel):
    def __init__(
        self,
        media_workflow: UpdateMediaWorkflowResponseBodyMediaWorkflow = None,
        request_id: str = None,
    ):
        self.media_workflow = media_workflow
        self.request_id = request_id

    def validate(self):
        if self.media_workflow:
            self.media_workflow.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow is not None:
            result['MediaWorkflow'] = self.media_workflow.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflow') is not None:
            temp_model = UpdateMediaWorkflowResponseBodyMediaWorkflow()
            self.media_workflow = temp_model.from_map(m['MediaWorkflow'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateMediaWorkflowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMediaWorkflowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaWorkflowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaWorkflowTriggerModeRequest(TeaModel):
    def __init__(
        self,
        media_workflow_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        trigger_mode: str = None,
    ):
        # This parameter is required.
        self.media_workflow_id = media_workflow_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # This parameter is required.
        self.trigger_mode = trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.trigger_mode is not None:
            result['TriggerMode'] = self.trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TriggerMode') is not None:
            self.trigger_mode = m.get('TriggerMode')
        return self


class UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        media_workflow_id: str = None,
        name: str = None,
        state: str = None,
        topology: str = None,
        trigger_mode: str = None,
    ):
        self.creation_time = creation_time
        self.media_workflow_id = media_workflow_id
        self.name = name
        self.state = state
        self.topology = topology
        self.trigger_mode = trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.topology is not None:
            result['Topology'] = self.topology
        if self.trigger_mode is not None:
            result['TriggerMode'] = self.trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Topology') is not None:
            self.topology = m.get('Topology')
        if m.get('TriggerMode') is not None:
            self.trigger_mode = m.get('TriggerMode')
        return self


class UpdateMediaWorkflowTriggerModeResponseBody(TeaModel):
    def __init__(
        self,
        media_workflow: UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow = None,
        request_id: str = None,
    ):
        self.media_workflow = media_workflow
        self.request_id = request_id

    def validate(self):
        if self.media_workflow:
            self.media_workflow.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow is not None:
            result['MediaWorkflow'] = self.media_workflow.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflow') is not None:
            temp_model = UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow()
            self.media_workflow = temp_model.from_map(m['MediaWorkflow'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateMediaWorkflowTriggerModeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMediaWorkflowTriggerModeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaWorkflowTriggerModeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdatePipelineRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        notify_config: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        role: str = None,
        state: str = None,
    ):
        # This parameter is required.
        self.name = name
        self.notify_config = notify_config
        self.owner_account = owner_account
        self.owner_id = owner_id
        # This parameter is required.
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        self.role = role
        # This parameter is required.
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.notify_config is not None:
            result['NotifyConfig'] = self.notify_config
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.role is not None:
            result['Role'] = self.role
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotifyConfig') is not None:
            self.notify_config = m.get('NotifyConfig')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class UpdatePipelineResponseBodyPipelineNotifyConfig(TeaModel):
    def __init__(
        self,
        queue_name: str = None,
        topic: str = None,
    ):
        self.queue_name = queue_name
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.queue_name is not None:
            result['QueueName'] = self.queue_name
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('QueueName') is not None:
            self.queue_name = m.get('QueueName')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class UpdatePipelineResponseBodyPipeline(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        notify_config: UpdatePipelineResponseBodyPipelineNotifyConfig = None,
        role: str = None,
        speed: str = None,
        state: str = None,
    ):
        self.id = id
        self.name = name
        self.notify_config = notify_config
        self.role = role
        self.speed = speed
        self.state = state

    def validate(self):
        if self.notify_config:
            self.notify_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notify_config is not None:
            result['NotifyConfig'] = self.notify_config.to_map()
        if self.role is not None:
            result['Role'] = self.role
        if self.speed is not None:
            result['Speed'] = self.speed
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotifyConfig') is not None:
            temp_model = UpdatePipelineResponseBodyPipelineNotifyConfig()
            self.notify_config = temp_model.from_map(m['NotifyConfig'])
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class UpdatePipelineResponseBody(TeaModel):
    def __init__(
        self,
        pipeline: UpdatePipelineResponseBodyPipeline = None,
        request_id: str = None,
    ):
        self.pipeline = pipeline
        self.request_id = request_id

    def validate(self):
        if self.pipeline:
            self.pipeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline is not None:
            result['Pipeline'] = self.pipeline.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pipeline') is not None:
            temp_model = UpdatePipelineResponseBodyPipeline()
            self.pipeline = temp_model.from_map(m['Pipeline'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdatePipelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdatePipelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdatePipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTemplateRequest(TeaModel):
    def __init__(
        self,
        audio: str = None,
        container: str = None,
        mux_config: str = None,
        name: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        template_id: str = None,
        trans_config: str = None,
        video: str = None,
    ):
        self.audio = audio
        self.container = container
        self.mux_config = mux_config
        # This parameter is required.
        self.name = name
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # This parameter is required.
        self.template_id = template_id
        self.trans_config = trans_config
        self.video = video

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio
        if self.container is not None:
            result['Container'] = self.container
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config
        if self.video is not None:
            result['Video'] = self.video
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            self.audio = m.get('Audio')
        if m.get('Container') is not None:
            self.container = m.get('Container')
        if m.get('MuxConfig') is not None:
            self.mux_config = m.get('MuxConfig')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TransConfig') is not None:
            self.trans_config = m.get('TransConfig')
        if m.get('Video') is not None:
            self.video = m.get('Video')
        return self


class UpdateTemplateResponseBodyTemplateAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        qscale: str = None,
        remove: str = None,
        samplerate: str = None,
    ):
        self.bitrate = bitrate
        self.channels = channels
        self.codec = codec
        self.profile = profile
        self.qscale = qscale
        self.remove = remove
        self.samplerate = samplerate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        return self


class UpdateTemplateResponseBodyTemplateContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class UpdateTemplateResponseBodyTemplateMuxConfigGif(TeaModel):
    def __init__(
        self,
        dither_mode: str = None,
        final_delay: str = None,
        is_custom_palette: str = None,
        loop: str = None,
    ):
        self.dither_mode = dither_mode
        self.final_delay = final_delay
        self.is_custom_palette = is_custom_palette
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dither_mode is not None:
            result['DitherMode'] = self.dither_mode
        if self.final_delay is not None:
            result['FinalDelay'] = self.final_delay
        if self.is_custom_palette is not None:
            result['IsCustomPalette'] = self.is_custom_palette
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DitherMode') is not None:
            self.dither_mode = m.get('DitherMode')
        if m.get('FinalDelay') is not None:
            self.final_delay = m.get('FinalDelay')
        if m.get('IsCustomPalette') is not None:
            self.is_custom_palette = m.get('IsCustomPalette')
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class UpdateTemplateResponseBodyTemplateMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
    ):
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class UpdateTemplateResponseBodyTemplateMuxConfigWebp(TeaModel):
    def __init__(
        self,
        loop: str = None,
    ):
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class UpdateTemplateResponseBodyTemplateMuxConfig(TeaModel):
    def __init__(
        self,
        gif: UpdateTemplateResponseBodyTemplateMuxConfigGif = None,
        segment: UpdateTemplateResponseBodyTemplateMuxConfigSegment = None,
        webp: UpdateTemplateResponseBodyTemplateMuxConfigWebp = None,
    ):
        self.gif = gif
        self.segment = segment
        self.webp = webp

    def validate(self):
        if self.gif:
            self.gif.validate()
        if self.segment:
            self.segment.validate()
        if self.webp:
            self.webp.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gif is not None:
            result['Gif'] = self.gif.to_map()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        if self.webp is not None:
            result['Webp'] = self.webp.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gif') is not None:
            temp_model = UpdateTemplateResponseBodyTemplateMuxConfigGif()
            self.gif = temp_model.from_map(m['Gif'])
        if m.get('Segment') is not None:
            temp_model = UpdateTemplateResponseBodyTemplateMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        if m.get('Webp') is not None:
            temp_model = UpdateTemplateResponseBodyTemplateMuxConfigWebp()
            self.webp = temp_model.from_map(m['Webp'])
        return self


class UpdateTemplateResponseBodyTemplateTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        is_check_audio_bitrate: str = None,
        is_check_audio_bitrate_fail: str = None,
        is_check_reso: str = None,
        is_check_reso_fail: str = None,
        is_check_video_bitrate: str = None,
        is_check_video_bitrate_fail: str = None,
        trans_mode: str = None,
    ):
        self.adj_dar_method = adj_dar_method
        self.is_check_audio_bitrate = is_check_audio_bitrate
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        self.is_check_reso = is_check_reso
        self.is_check_reso_fail = is_check_reso_fail
        self.is_check_video_bitrate = is_check_video_bitrate
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class UpdateTemplateResponseBodyTemplateVideoBitrateBnd(TeaModel):
    def __init__(
        self,
        max: str = None,
        min: str = None,
    ):
        self.max = max
        self.min = min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        return self


class UpdateTemplateResponseBodyTemplateVideo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        bitrate_bnd: UpdateTemplateResponseBodyTemplateVideoBitrateBnd = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        degrain: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        max_fps: str = None,
        maxrate: str = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        qscale: str = None,
        remove: str = None,
        reso_priority: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        self.bitrate = bitrate
        self.bitrate_bnd = bitrate_bnd
        self.bufsize = bufsize
        self.codec = codec
        self.crf = crf
        self.crop = crop
        self.degrain = degrain
        self.fps = fps
        self.gop = gop
        self.height = height
        self.max_fps = max_fps
        self.maxrate = maxrate
        self.pad = pad
        self.pix_fmt = pix_fmt
        self.preset = preset
        self.profile = profile
        self.qscale = qscale
        self.remove = remove
        self.reso_priority = reso_priority
        self.scan_mode = scan_mode
        self.width = width

    def validate(self):
        if self.bitrate_bnd:
            self.bitrate_bnd.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bitrate_bnd is not None:
            result['BitrateBnd'] = self.bitrate_bnd.to_map()
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.degrain is not None:
            result['Degrain'] = self.degrain
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.max_fps is not None:
            result['MaxFps'] = self.max_fps
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.reso_priority is not None:
            result['ResoPriority'] = self.reso_priority
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BitrateBnd') is not None:
            temp_model = UpdateTemplateResponseBodyTemplateVideoBitrateBnd()
            self.bitrate_bnd = temp_model.from_map(m['BitrateBnd'])
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Degrain') is not None:
            self.degrain = m.get('Degrain')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MaxFps') is not None:
            self.max_fps = m.get('MaxFps')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('ResoPriority') is not None:
            self.reso_priority = m.get('ResoPriority')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class UpdateTemplateResponseBodyTemplate(TeaModel):
    def __init__(
        self,
        audio: UpdateTemplateResponseBodyTemplateAudio = None,
        container: UpdateTemplateResponseBodyTemplateContainer = None,
        id: str = None,
        mux_config: UpdateTemplateResponseBodyTemplateMuxConfig = None,
        name: str = None,
        state: str = None,
        trans_config: UpdateTemplateResponseBodyTemplateTransConfig = None,
        video: UpdateTemplateResponseBodyTemplateVideo = None,
    ):
        self.audio = audio
        self.container = container
        self.id = id
        self.mux_config = mux_config
        self.name = name
        self.state = state
        self.trans_config = trans_config
        self.video = video

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = UpdateTemplateResponseBodyTemplateAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = UpdateTemplateResponseBodyTemplateContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MuxConfig') is not None:
            temp_model = UpdateTemplateResponseBodyTemplateMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TransConfig') is not None:
            temp_model = UpdateTemplateResponseBodyTemplateTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('Video') is not None:
            temp_model = UpdateTemplateResponseBodyTemplateVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class UpdateTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template: UpdateTemplateResponseBodyTemplate = None,
    ):
        self.request_id = request_id
        self.template = template

    def validate(self):
        if self.template:
            self.template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template is not None:
            result['Template'] = self.template.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Template') is not None:
            temp_model = UpdateTemplateResponseBodyTemplate()
            self.template = temp_model.from_map(m['Template'])
        return self


class UpdateTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateWaterMarkTemplateRequest(TeaModel):
    def __init__(
        self,
        config: str = None,
        name: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        water_mark_template_id: str = None,
    ):
        # This parameter is required.
        self.config = config
        # This parameter is required.
        self.name = name
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # This parameter is required.
        self.water_mark_template_id = water_mark_template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.water_mark_template_id is not None:
            result['WaterMarkTemplateId'] = self.water_mark_template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('WaterMarkTemplateId') is not None:
            self.water_mark_template_id = m.get('WaterMarkTemplateId')
        return self


class UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        width: str = None,
    ):
        self.dx = dx
        self.dy = dy
        self.height = height
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline(TeaModel):
    def __init__(
        self,
        duration: str = None,
        start: str = None,
    ):
        self.duration = duration
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        id: str = None,
        name: str = None,
        ratio_refer: UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer = None,
        refer_pos: str = None,
        state: str = None,
        timeline: UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline = None,
        type: str = None,
        width: str = None,
    ):
        self.dx = dx
        self.dy = dy
        self.height = height
        self.id = id
        self.name = name
        self.ratio_refer = ratio_refer
        self.refer_pos = refer_pos
        self.state = state
        self.timeline = timeline
        self.type = type
        self.width = width

    def validate(self):
        if self.ratio_refer:
            self.ratio_refer.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.ratio_refer is not None:
            result['RatioRefer'] = self.ratio_refer.to_map()
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.state is not None:
            result['State'] = self.state
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RatioRefer') is not None:
            temp_model = UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer()
            self.ratio_refer = temp_model.from_map(m['RatioRefer'])
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Timeline') is not None:
            temp_model = UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class UpdateWaterMarkTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        water_mark_template: UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate = None,
    ):
        self.request_id = request_id
        self.water_mark_template = water_mark_template

    def validate(self):
        if self.water_mark_template:
            self.water_mark_template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.water_mark_template is not None:
            result['WaterMarkTemplate'] = self.water_mark_template.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('WaterMarkTemplate') is not None:
            temp_model = UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate()
            self.water_mark_template = temp_model.from_map(m['WaterMarkTemplate'])
        return self


class UpdateWaterMarkTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateWaterMarkTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateWaterMarkTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


