# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from ._enums import *

__all__ = [
    'ChmodOpts',
    'EtcdctlOpts',
    'HostnamectlOpts',
    'MkdirOpts',
    'MktempOpts',
    'MvOpts',
    'RmOpts',
    'SedOpts',
    'SystemctlOpts',
    'TarOpts',
    'TeeOpts',
    'WgetOpts',
]

@pulumi.output_type
class ChmodOpts(dict):
    """
    Abstraction over the `chmod` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noPreserveRoot":
            suggest = "no_preserve_root"
        elif key == "preserveRoot":
            suggest = "preserve_root"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChmodOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChmodOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChmodOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 files: Sequence[str],
                 mode: str,
                 changes: Optional[bool] = None,
                 help: Optional[bool] = None,
                 no_preserve_root: Optional[bool] = None,
                 preserve_root: Optional[bool] = None,
                 quiet: Optional[bool] = None,
                 recursive: Optional[bool] = None,
                 reference: Optional[str] = None,
                 silent: Optional[bool] = None,
                 version: Optional[bool] = None):
        """
        Abstraction over the `chmod` utility on a remote system.
        :param Sequence[str] files: Corresponds to the [FILE] argument.
        :param str mode: Modes may be absolute or symbolic. An absolute mode is an octal number...
        :param bool changes: Like verbose but report only when a change is made.
        :param bool help: Display help and exit.
        :param bool no_preserve_root: Do not treat '/' specially (the default).
        :param bool preserve_root: Fail to operate recursively on '/'.
        :param bool quiet: Suppress most error messages. Same as `silent`.
        :param bool recursive: Change files and directories recursively.
        :param str reference: Use RFILE's mode instead of specifying MODE values. RFILE is always dereferenced if a symbolic link.
        :param bool silent: Suppress most error messages. Same as `quiet`.
        :param bool version: Output version information and exit.
        """
        pulumi.set(__self__, "files", files)
        pulumi.set(__self__, "mode", mode)
        if changes is not None:
            pulumi.set(__self__, "changes", changes)
        if help is not None:
            pulumi.set(__self__, "help", help)
        if no_preserve_root is not None:
            pulumi.set(__self__, "no_preserve_root", no_preserve_root)
        if preserve_root is not None:
            pulumi.set(__self__, "preserve_root", preserve_root)
        if quiet is not None:
            pulumi.set(__self__, "quiet", quiet)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if reference is not None:
            pulumi.set(__self__, "reference", reference)
        if silent is not None:
            pulumi.set(__self__, "silent", silent)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def files(self) -> Sequence[str]:
        """
        Corresponds to the [FILE] argument.
        """
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Modes may be absolute or symbolic. An absolute mode is an octal number...
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def changes(self) -> Optional[bool]:
        """
        Like verbose but report only when a change is made.
        """
        return pulumi.get(self, "changes")

    @property
    @pulumi.getter
    def help(self) -> Optional[bool]:
        """
        Display help and exit.
        """
        return pulumi.get(self, "help")

    @property
    @pulumi.getter(name="noPreserveRoot")
    def no_preserve_root(self) -> Optional[bool]:
        """
        Do not treat '/' specially (the default).
        """
        return pulumi.get(self, "no_preserve_root")

    @property
    @pulumi.getter(name="preserveRoot")
    def preserve_root(self) -> Optional[bool]:
        """
        Fail to operate recursively on '/'.
        """
        return pulumi.get(self, "preserve_root")

    @property
    @pulumi.getter
    def quiet(self) -> Optional[bool]:
        """
        Suppress most error messages. Same as `silent`.
        """
        return pulumi.get(self, "quiet")

    @property
    @pulumi.getter
    def recursive(self) -> Optional[bool]:
        """
        Change files and directories recursively.
        """
        return pulumi.get(self, "recursive")

    @property
    @pulumi.getter
    def reference(self) -> Optional[str]:
        """
        Use RFILE's mode instead of specifying MODE values. RFILE is always dereferenced if a symbolic link.
        """
        return pulumi.get(self, "reference")

    @property
    @pulumi.getter
    def silent(self) -> Optional[bool]:
        """
        Suppress most error messages. Same as `quiet`.
        """
        return pulumi.get(self, "silent")

    @property
    @pulumi.getter
    def version(self) -> Optional[bool]:
        """
        Output version information and exit.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class EtcdctlOpts(dict):
    """
    Abstraction over the `etcdctl` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCert":
            suggest = "ca_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EtcdctlOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EtcdctlOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EtcdctlOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: 'EtcdctlCommand',
                 ca_cert: Optional[str] = None,
                 cert: Optional[str] = None,
                 endpoints: Optional[str] = None,
                 key: Optional[str] = None):
        """
        Abstraction over the `etcdctl` utility on a remote system.
        :param 'EtcdctlCommand' commands: TODO
        :param str ca_cert: TODO
        :param str cert: TODO
        :param str endpoints: TODO
        :param str key: TODO
        """
        pulumi.set(__self__, "commands", commands)
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def commands(self) -> 'EtcdctlCommand':
        """
        TODO
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[str]:
        """
        TODO
        """
        return pulumi.get(self, "ca_cert")

    @property
    @pulumi.getter
    def cert(self) -> Optional[str]:
        """
        TODO
        """
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[str]:
        """
        TODO
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        TODO
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class HostnamectlOpts(dict):
    """
    Abstraction over the `hostnamectl` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noAskPassword":
            suggest = "no_ask_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostnamectlOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostnamectlOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostnamectlOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command: 'HostnamectlCommand',
                 arg: Optional[str] = None,
                 help: Optional[bool] = None,
                 host: Optional[str] = None,
                 json: Optional['HostnamectlJsonMode'] = None,
                 machine: Optional[str] = None,
                 no_ask_password: Optional[bool] = None,
                 pretty: Optional[bool] = None,
                 static: Optional[bool] = None,
                 transient: Optional[bool] = None,
                 version: Optional[bool] = None):
        """
        Abstraction over the `hostnamectl` utility on a remote system.
        :param 'HostnamectlCommand' command: Corresponds to the {COMMAND} argument.
        :param str arg: The argument for the specified `command`.
        :param bool help: Print a short help text and exit.
        :param str host: Execute the operation remotely. Specify a hostname, or a username and hostname separated by '@', to connect to.
        :param 'HostnamectlJsonMode' json: Shows output formatted as JSON.
        :param str machine: Execute operation on a local container. Specify a container name to connect to, optionally prefixed by a user name to connect as and a separating '@' character.
        :param bool no_ask_password: Do not query the user for authentication for privileged operations.
        :param bool pretty: If status is invoked (or no explicit command is given) and one of these switches is specified, hostnamectl will print out just this selected hostname. Same as `static` and `transient`.
        :param bool static: If status is invoked (or no explicit command is given) and one of these switches is specified, hostnamectl will print out just this selected hostname. Same as `transient` and `pretty`.
        :param bool transient: If status is invoked (or no explicit command is given) and one of these switches is specified, hostnamectl will print out just this selected hostname. Same as `static` and `pretty`.
        :param bool version: Print a short version string and exit.
        """
        pulumi.set(__self__, "command", command)
        if arg is not None:
            pulumi.set(__self__, "arg", arg)
        if help is not None:
            pulumi.set(__self__, "help", help)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if machine is not None:
            pulumi.set(__self__, "machine", machine)
        if no_ask_password is not None:
            pulumi.set(__self__, "no_ask_password", no_ask_password)
        if pretty is not None:
            pulumi.set(__self__, "pretty", pretty)
        if static is not None:
            pulumi.set(__self__, "static", static)
        if transient is not None:
            pulumi.set(__self__, "transient", transient)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def command(self) -> 'HostnamectlCommand':
        """
        Corresponds to the {COMMAND} argument.
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter
    def arg(self) -> Optional[str]:
        """
        The argument for the specified `command`.
        """
        return pulumi.get(self, "arg")

    @property
    @pulumi.getter
    def help(self) -> Optional[bool]:
        """
        Print a short help text and exit.
        """
        return pulumi.get(self, "help")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Execute the operation remotely. Specify a hostname, or a username and hostname separated by '@', to connect to.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def json(self) -> Optional['HostnamectlJsonMode']:
        """
        Shows output formatted as JSON.
        """
        return pulumi.get(self, "json")

    @property
    @pulumi.getter
    def machine(self) -> Optional[str]:
        """
        Execute operation on a local container. Specify a container name to connect to, optionally prefixed by a user name to connect as and a separating '@' character.
        """
        return pulumi.get(self, "machine")

    @property
    @pulumi.getter(name="noAskPassword")
    def no_ask_password(self) -> Optional[bool]:
        """
        Do not query the user for authentication for privileged operations.
        """
        return pulumi.get(self, "no_ask_password")

    @property
    @pulumi.getter
    def pretty(self) -> Optional[bool]:
        """
        If status is invoked (or no explicit command is given) and one of these switches is specified, hostnamectl will print out just this selected hostname. Same as `static` and `transient`.
        """
        return pulumi.get(self, "pretty")

    @property
    @pulumi.getter
    def static(self) -> Optional[bool]:
        """
        If status is invoked (or no explicit command is given) and one of these switches is specified, hostnamectl will print out just this selected hostname. Same as `transient` and `pretty`.
        """
        return pulumi.get(self, "static")

    @property
    @pulumi.getter
    def transient(self) -> Optional[bool]:
        """
        If status is invoked (or no explicit command is given) and one of these switches is specified, hostnamectl will print out just this selected hostname. Same as `static` and `pretty`.
        """
        return pulumi.get(self, "transient")

    @property
    @pulumi.getter
    def version(self) -> Optional[bool]:
        """
        Print a short version string and exit.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class MkdirOpts(dict):
    """
    Abstraction over the `mkdir` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "removeOnDelete":
            suggest = "remove_on_delete"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MkdirOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MkdirOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MkdirOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 directory: str,
                 parents: Optional[bool] = None,
                 remove_on_delete: Optional[bool] = None):
        """
        Abstraction over the `mkdir` utility on a remote system.
        :param str directory: The fully qualified path of the directory on the remote system.
        :param bool parents: Corresponds to the `--parents` option.
        :param bool remove_on_delete: Remove the created directory when the `Mkdir` resource is deleted or updated.
        """
        pulumi.set(__self__, "directory", directory)
        if parents is not None:
            pulumi.set(__self__, "parents", parents)
        if remove_on_delete is not None:
            pulumi.set(__self__, "remove_on_delete", remove_on_delete)

    @property
    @pulumi.getter
    def directory(self) -> str:
        """
        The fully qualified path of the directory on the remote system.
        """
        return pulumi.get(self, "directory")

    @property
    @pulumi.getter
    def parents(self) -> Optional[bool]:
        """
        Corresponds to the `--parents` option.
        """
        return pulumi.get(self, "parents")

    @property
    @pulumi.getter(name="removeOnDelete")
    def remove_on_delete(self) -> Optional[bool]:
        """
        Remove the created directory when the `Mkdir` resource is deleted or updated.
        """
        return pulumi.get(self, "remove_on_delete")


@pulumi.output_type
class MktempOpts(dict):
    """
    Abstraction over the `mktemp` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dryRun":
            suggest = "dry_run"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MktempOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MktempOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MktempOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 directory: Optional[bool] = None,
                 dry_run: Optional[bool] = None,
                 quiet: Optional[bool] = None,
                 suffix: Optional[str] = None,
                 template: Optional[str] = None,
                 tmpdir: Optional[str] = None):
        """
        Abstraction over the `mktemp` utility on a remote system.
        :param bool directory: Corresponds to the `--directory` option.
        :param bool dry_run: Corresponds to the `--dry-run` option.
        :param bool quiet: Corresponds to the `--quiet` option.
        :param str suffix: Corresponds to the `--suffix` option.
        :param str template: Corresponds to the [TEMPLATE] argument.
        :param str tmpdir: Corresponds to the `--tmpdir` option.
        """
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if dry_run is not None:
            pulumi.set(__self__, "dry_run", dry_run)
        if quiet is not None:
            pulumi.set(__self__, "quiet", quiet)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if tmpdir is not None:
            pulumi.set(__self__, "tmpdir", tmpdir)

    @property
    @pulumi.getter
    def directory(self) -> Optional[bool]:
        """
        Corresponds to the `--directory` option.
        """
        return pulumi.get(self, "directory")

    @property
    @pulumi.getter(name="dryRun")
    def dry_run(self) -> Optional[bool]:
        """
        Corresponds to the `--dry-run` option.
        """
        return pulumi.get(self, "dry_run")

    @property
    @pulumi.getter
    def quiet(self) -> Optional[bool]:
        """
        Corresponds to the `--quiet` option.
        """
        return pulumi.get(self, "quiet")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        Corresponds to the `--suffix` option.
        """
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter
    def template(self) -> Optional[str]:
        """
        Corresponds to the [TEMPLATE] argument.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter
    def tmpdir(self) -> Optional[str]:
        """
        Corresponds to the `--tmpdir` option.
        """
        return pulumi.get(self, "tmpdir")


@pulumi.output_type
class MvOpts(dict):
    """
    Abstraction over the `mv` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noClobber":
            suggest = "no_clobber"
        elif key == "noTargetDirectory":
            suggest = "no_target_directory"
        elif key == "stripTrailingSlashes":
            suggest = "strip_trailing_slashes"
        elif key == "targetDirectory":
            suggest = "target_directory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MvOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MvOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MvOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source: Sequence[str],
                 backup: Optional[bool] = None,
                 context: Optional[bool] = None,
                 control: Optional[bool] = None,
                 dest: Optional[str] = None,
                 directory: Optional[str] = None,
                 force: Optional[bool] = None,
                 no_clobber: Optional[bool] = None,
                 no_target_directory: Optional[bool] = None,
                 strip_trailing_slashes: Optional[bool] = None,
                 suffix: Optional[str] = None,
                 target_directory: Optional[bool] = None,
                 update: Optional[bool] = None,
                 verbose: Optional[bool] = None):
        """
        Abstraction over the `mv` utility on a remote system.
        :param Sequence[str] source: Corresponds to the [SOURCE] argument.
        :param bool backup: Corresponds to the `-b` and `--backup` options depending on whether [CONTROL] is supplied.
        :param bool context: Corresponds to the `--context` option.
        :param bool control: Corresponds to the [CONTROL] argument for the `--backup` option.
        :param str dest: Corresponds to the [DEST] argument.
        :param str directory: Corresponds to the [DIRECTORY] argument.
        :param bool force: Corresponds to the `--force` option.
        :param bool no_clobber: Corresponds to the `--no-clobber` option.
        :param bool no_target_directory: Corresponds to the `--no-target-directory` option.
        :param bool strip_trailing_slashes: Corresponds to the `--strip-trailing-slashes` option.
        :param str suffix: Corresponds to the `--suffix` option.
        :param bool target_directory: Corresponds to the `--target-directory` option.
        :param bool update: Corresponds to the `--update` option.
        :param bool verbose: Corresponds to the `--verbose` option.
        """
        pulumi.set(__self__, "source", source)
        if backup is not None:
            pulumi.set(__self__, "backup", backup)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if control is not None:
            pulumi.set(__self__, "control", control)
        if dest is not None:
            pulumi.set(__self__, "dest", dest)
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if no_clobber is not None:
            pulumi.set(__self__, "no_clobber", no_clobber)
        if no_target_directory is not None:
            pulumi.set(__self__, "no_target_directory", no_target_directory)
        if strip_trailing_slashes is not None:
            pulumi.set(__self__, "strip_trailing_slashes", strip_trailing_slashes)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if target_directory is not None:
            pulumi.set(__self__, "target_directory", target_directory)
        if update is not None:
            pulumi.set(__self__, "update", update)
        if verbose is not None:
            pulumi.set(__self__, "verbose", verbose)

    @property
    @pulumi.getter
    def source(self) -> Sequence[str]:
        """
        Corresponds to the [SOURCE] argument.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def backup(self) -> Optional[bool]:
        """
        Corresponds to the `-b` and `--backup` options depending on whether [CONTROL] is supplied.
        """
        return pulumi.get(self, "backup")

    @property
    @pulumi.getter
    def context(self) -> Optional[bool]:
        """
        Corresponds to the `--context` option.
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def control(self) -> Optional[bool]:
        """
        Corresponds to the [CONTROL] argument for the `--backup` option.
        """
        return pulumi.get(self, "control")

    @property
    @pulumi.getter
    def dest(self) -> Optional[str]:
        """
        Corresponds to the [DEST] argument.
        """
        return pulumi.get(self, "dest")

    @property
    @pulumi.getter
    def directory(self) -> Optional[str]:
        """
        Corresponds to the [DIRECTORY] argument.
        """
        return pulumi.get(self, "directory")

    @property
    @pulumi.getter
    def force(self) -> Optional[bool]:
        """
        Corresponds to the `--force` option.
        """
        return pulumi.get(self, "force")

    @property
    @pulumi.getter(name="noClobber")
    def no_clobber(self) -> Optional[bool]:
        """
        Corresponds to the `--no-clobber` option.
        """
        return pulumi.get(self, "no_clobber")

    @property
    @pulumi.getter(name="noTargetDirectory")
    def no_target_directory(self) -> Optional[bool]:
        """
        Corresponds to the `--no-target-directory` option.
        """
        return pulumi.get(self, "no_target_directory")

    @property
    @pulumi.getter(name="stripTrailingSlashes")
    def strip_trailing_slashes(self) -> Optional[bool]:
        """
        Corresponds to the `--strip-trailing-slashes` option.
        """
        return pulumi.get(self, "strip_trailing_slashes")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        Corresponds to the `--suffix` option.
        """
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter(name="targetDirectory")
    def target_directory(self) -> Optional[bool]:
        """
        Corresponds to the `--target-directory` option.
        """
        return pulumi.get(self, "target_directory")

    @property
    @pulumi.getter
    def update(self) -> Optional[bool]:
        """
        Corresponds to the `--update` option.
        """
        return pulumi.get(self, "update")

    @property
    @pulumi.getter
    def verbose(self) -> Optional[bool]:
        """
        Corresponds to the `--verbose` option.
        """
        return pulumi.get(self, "verbose")


@pulumi.output_type
class RmOpts(dict):
    """
    Abstraction over the `rm` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onDelete":
            suggest = "on_delete"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RmOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RmOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RmOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 files: Sequence[str],
                 dir: Optional[bool] = None,
                 force: Optional[bool] = None,
                 on_delete: Optional[bool] = None,
                 recursive: Optional[bool] = None,
                 verbose: Optional[bool] = None):
        """
        Abstraction over the `rm` utility on a remote system.
        :param Sequence[str] files: Corresponds to the [FILE] argument.
        :param bool dir: Corresponds to the `--dir` option.
        :param bool force: Corresponds to the `--force` option.
        :param bool on_delete: Whether rm should be run when the resource is created or deleted.
        :param bool recursive: Corresponds to the `--recursive` option.
        :param bool verbose: Corresponds to the `--verbose` option.
        """
        pulumi.set(__self__, "files", files)
        if dir is not None:
            pulumi.set(__self__, "dir", dir)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if on_delete is not None:
            pulumi.set(__self__, "on_delete", on_delete)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if verbose is not None:
            pulumi.set(__self__, "verbose", verbose)

    @property
    @pulumi.getter
    def files(self) -> Sequence[str]:
        """
        Corresponds to the [FILE] argument.
        """
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def dir(self) -> Optional[bool]:
        """
        Corresponds to the `--dir` option.
        """
        return pulumi.get(self, "dir")

    @property
    @pulumi.getter
    def force(self) -> Optional[bool]:
        """
        Corresponds to the `--force` option.
        """
        return pulumi.get(self, "force")

    @property
    @pulumi.getter(name="onDelete")
    def on_delete(self) -> Optional[bool]:
        """
        Whether rm should be run when the resource is created or deleted.
        """
        return pulumi.get(self, "on_delete")

    @property
    @pulumi.getter
    def recursive(self) -> Optional[bool]:
        """
        Corresponds to the `--recursive` option.
        """
        return pulumi.get(self, "recursive")

    @property
    @pulumi.getter
    def verbose(self) -> Optional[bool]:
        """
        Corresponds to the `--verbose` option.
        """
        return pulumi.get(self, "verbose")


@pulumi.output_type
class SedOpts(dict):
    """
    Abstraction over the `sed` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "followSymlinks":
            suggest = "follow_symlinks"
        elif key == "inPlace":
            suggest = "in_place"
        elif key == "inputFiles":
            suggest = "input_files"
        elif key == "lineLength":
            suggest = "line_length"
        elif key == "nullData":
            suggest = "null_data"
        elif key == "regexpExtended":
            suggest = "regexp_extended"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SedOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SedOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SedOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 debug: Optional[bool] = None,
                 expressions: Optional[Sequence[str]] = None,
                 files: Optional[Sequence[str]] = None,
                 follow_symlinks: Optional[bool] = None,
                 help: Optional[bool] = None,
                 in_place: Optional[str] = None,
                 input_files: Optional[Sequence[str]] = None,
                 line_length: Optional[int] = None,
                 null_data: Optional[bool] = None,
                 posix: Optional[bool] = None,
                 quiet: Optional[bool] = None,
                 regexp_extended: Optional[bool] = None,
                 sandbox: Optional[bool] = None,
                 script: Optional[str] = None,
                 separate: Optional[bool] = None,
                 silent: Optional[bool] = None,
                 unbuffered: Optional[bool] = None,
                 version: Optional[bool] = None):
        """
        Abstraction over the `sed` utility on a remote system.
        :param bool debug: annotate program execution.
        :param Sequence[str] expressions: add the script to the commands to be executed.
        :param Sequence[str] files: add the contents of script-file to the commands to be executed.
        :param bool follow_symlinks: follow symlinks when processing in place
        :param bool help: display this help and exit.
        :param str in_place: edit files in place (makes backup if SUFFIX supplied)
        :param Sequence[str] input_files: corresponds to the [input-file]... argument(s).
        :param int line_length: specify the desired line-wrap length for the `l' command
        :param bool null_data: separate lines by NUL characters
        :param bool posix: disable all GNU extensions.
        :param bool quiet: suppress automatic printing of pattern space. Same as `silent`.
        :param bool regexp_extended: use extended regular expressions in the script (for portability use POSIX -E).
        :param bool sandbox: operate in sandbox mode (disable e/r/w commands).
        :param str script: script only if no other script.
        :param bool separate: consider files as separate rather than as a single, continuous long stream.
        :param bool silent: suppress automatic printing of pattern space. Same as `quiet`.
        :param bool unbuffered: load minimal amounts of data from the input files and flush the output buffers more often.
        :param bool version: output version information and exit.
        """
        if debug is not None:
            pulumi.set(__self__, "debug", debug)
        if expressions is not None:
            pulumi.set(__self__, "expressions", expressions)
        if files is not None:
            pulumi.set(__self__, "files", files)
        if follow_symlinks is not None:
            pulumi.set(__self__, "follow_symlinks", follow_symlinks)
        if help is not None:
            pulumi.set(__self__, "help", help)
        if in_place is not None:
            pulumi.set(__self__, "in_place", in_place)
        if input_files is not None:
            pulumi.set(__self__, "input_files", input_files)
        if line_length is not None:
            pulumi.set(__self__, "line_length", line_length)
        if null_data is not None:
            pulumi.set(__self__, "null_data", null_data)
        if posix is not None:
            pulumi.set(__self__, "posix", posix)
        if quiet is not None:
            pulumi.set(__self__, "quiet", quiet)
        if regexp_extended is not None:
            pulumi.set(__self__, "regexp_extended", regexp_extended)
        if sandbox is not None:
            pulumi.set(__self__, "sandbox", sandbox)
        if script is not None:
            pulumi.set(__self__, "script", script)
        if separate is not None:
            pulumi.set(__self__, "separate", separate)
        if silent is not None:
            pulumi.set(__self__, "silent", silent)
        if unbuffered is not None:
            pulumi.set(__self__, "unbuffered", unbuffered)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def debug(self) -> Optional[bool]:
        """
        annotate program execution.
        """
        return pulumi.get(self, "debug")

    @property
    @pulumi.getter
    def expressions(self) -> Optional[Sequence[str]]:
        """
        add the script to the commands to be executed.
        """
        return pulumi.get(self, "expressions")

    @property
    @pulumi.getter
    def files(self) -> Optional[Sequence[str]]:
        """
        add the contents of script-file to the commands to be executed.
        """
        return pulumi.get(self, "files")

    @property
    @pulumi.getter(name="followSymlinks")
    def follow_symlinks(self) -> Optional[bool]:
        """
        follow symlinks when processing in place
        """
        return pulumi.get(self, "follow_symlinks")

    @property
    @pulumi.getter
    def help(self) -> Optional[bool]:
        """
        display this help and exit.
        """
        return pulumi.get(self, "help")

    @property
    @pulumi.getter(name="inPlace")
    def in_place(self) -> Optional[str]:
        """
        edit files in place (makes backup if SUFFIX supplied)
        """
        return pulumi.get(self, "in_place")

    @property
    @pulumi.getter(name="inputFiles")
    def input_files(self) -> Optional[Sequence[str]]:
        """
        corresponds to the [input-file]... argument(s).
        """
        return pulumi.get(self, "input_files")

    @property
    @pulumi.getter(name="lineLength")
    def line_length(self) -> Optional[int]:
        """
        specify the desired line-wrap length for the `l' command
        """
        return pulumi.get(self, "line_length")

    @property
    @pulumi.getter(name="nullData")
    def null_data(self) -> Optional[bool]:
        """
        separate lines by NUL characters
        """
        return pulumi.get(self, "null_data")

    @property
    @pulumi.getter
    def posix(self) -> Optional[bool]:
        """
        disable all GNU extensions.
        """
        return pulumi.get(self, "posix")

    @property
    @pulumi.getter
    def quiet(self) -> Optional[bool]:
        """
        suppress automatic printing of pattern space. Same as `silent`.
        """
        return pulumi.get(self, "quiet")

    @property
    @pulumi.getter(name="regexpExtended")
    def regexp_extended(self) -> Optional[bool]:
        """
        use extended regular expressions in the script (for portability use POSIX -E).
        """
        return pulumi.get(self, "regexp_extended")

    @property
    @pulumi.getter
    def sandbox(self) -> Optional[bool]:
        """
        operate in sandbox mode (disable e/r/w commands).
        """
        return pulumi.get(self, "sandbox")

    @property
    @pulumi.getter
    def script(self) -> Optional[str]:
        """
        script only if no other script.
        """
        return pulumi.get(self, "script")

    @property
    @pulumi.getter
    def separate(self) -> Optional[bool]:
        """
        consider files as separate rather than as a single, continuous long stream.
        """
        return pulumi.get(self, "separate")

    @property
    @pulumi.getter
    def silent(self) -> Optional[bool]:
        """
        suppress automatic printing of pattern space. Same as `quiet`.
        """
        return pulumi.get(self, "silent")

    @property
    @pulumi.getter
    def unbuffered(self) -> Optional[bool]:
        """
        load minimal amounts of data from the input files and flush the output buffers more often.
        """
        return pulumi.get(self, "unbuffered")

    @property
    @pulumi.getter
    def version(self) -> Optional[bool]:
        """
        output version information and exit.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SystemctlOpts(dict):
    """
    Abstraction over the `systemctl` utility on a remote system.
    """
    def __init__(__self__, *,
                 command: 'SystemctlCommand',
                 pattern: Optional[str] = None,
                 unit: Optional[str] = None):
        """
        Abstraction over the `systemctl` utility on a remote system.
        :param 'SystemctlCommand' command: Corresponds to the COMMAND argument.
        :param str pattern: Corresponds to the [PATTERN] argument
        :param str unit: Corresponds to the [UNIT...] argument.
        """
        pulumi.set(__self__, "command", command)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter
    def command(self) -> 'SystemctlCommand':
        """
        Corresponds to the COMMAND argument.
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        """
        Corresponds to the [PATTERN] argument
        """
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        Corresponds to the [UNIT...] argument.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class TarOpts(dict):
    """
    Abstraction over the `tar` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onDelete":
            suggest = "on_delete"
        elif key == "stripComponents":
            suggest = "strip_components"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TarOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TarOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TarOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archive: str,
                 directory: Optional[str] = None,
                 extract: Optional[bool] = None,
                 files: Optional[Sequence[str]] = None,
                 gzip: Optional[bool] = None,
                 on_delete: Optional[bool] = None,
                 recursive: Optional[bool] = None,
                 strip_components: Optional[int] = None):
        """
        Abstraction over the `tar` utility on a remote system.
        :param str archive: Corresponds to the [ARCHIVE] argument.
        :param str directory: Corresponds to the `--directory` option.
        :param bool extract: Corresponds to the `--extract` option.
        :param Sequence[str] files: Corresponds to the [FILE] argument.
        :param bool gzip: Corresponds to the `--gzip` option.
        :param bool on_delete: Whether rm should be run when the resource is created or deleted.
        :param bool recursive: Corresponds to the `--recursive` option.
        :param int strip_components: Corresponds to the `--strip-components` option.
        """
        pulumi.set(__self__, "archive", archive)
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if extract is not None:
            pulumi.set(__self__, "extract", extract)
        if files is not None:
            pulumi.set(__self__, "files", files)
        if gzip is not None:
            pulumi.set(__self__, "gzip", gzip)
        if on_delete is not None:
            pulumi.set(__self__, "on_delete", on_delete)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if strip_components is not None:
            pulumi.set(__self__, "strip_components", strip_components)

    @property
    @pulumi.getter
    def archive(self) -> str:
        """
        Corresponds to the [ARCHIVE] argument.
        """
        return pulumi.get(self, "archive")

    @property
    @pulumi.getter
    def directory(self) -> Optional[str]:
        """
        Corresponds to the `--directory` option.
        """
        return pulumi.get(self, "directory")

    @property
    @pulumi.getter
    def extract(self) -> Optional[bool]:
        """
        Corresponds to the `--extract` option.
        """
        return pulumi.get(self, "extract")

    @property
    @pulumi.getter
    def files(self) -> Optional[Sequence[str]]:
        """
        Corresponds to the [FILE] argument.
        """
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def gzip(self) -> Optional[bool]:
        """
        Corresponds to the `--gzip` option.
        """
        return pulumi.get(self, "gzip")

    @property
    @pulumi.getter(name="onDelete")
    def on_delete(self) -> Optional[bool]:
        """
        Whether rm should be run when the resource is created or deleted.
        """
        return pulumi.get(self, "on_delete")

    @property
    @pulumi.getter
    def recursive(self) -> Optional[bool]:
        """
        Corresponds to the `--recursive` option.
        """
        return pulumi.get(self, "recursive")

    @property
    @pulumi.getter(name="stripComponents")
    def strip_components(self) -> Optional[int]:
        """
        Corresponds to the `--strip-components` option.
        """
        return pulumi.get(self, "strip_components")


@pulumi.output_type
class TeeOpts(dict):
    """
    Abstraction over the `rm` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreInterrupts":
            suggest = "ignore_interrupts"
        elif key == "outputError":
            suggest = "output_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeeOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeeOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeeOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 files: Sequence[str],
                 append: Optional[bool] = None,
                 ignore_interrupts: Optional[bool] = None,
                 output_error: Optional['TeeMode'] = None,
                 pipe: Optional[bool] = None,
                 version: Optional[bool] = None):
        """
        Abstraction over the `rm` utility on a remote system.
        :param Sequence[str] files: Corresponds to the [FILE] argument.
        :param bool append: Append to the given FILEs, do not overwrite
        :param bool ignore_interrupts: Ignore interrupt signals.
        :param 'TeeMode' output_error: Set behavior on write error.
        :param bool pipe: Operate in a more appropriate MODE with pipes.
        :param bool version: Output version information and exit.
        """
        pulumi.set(__self__, "files", files)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if ignore_interrupts is not None:
            pulumi.set(__self__, "ignore_interrupts", ignore_interrupts)
        if output_error is not None:
            pulumi.set(__self__, "output_error", output_error)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def files(self) -> Sequence[str]:
        """
        Corresponds to the [FILE] argument.
        """
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def append(self) -> Optional[bool]:
        """
        Append to the given FILEs, do not overwrite
        """
        return pulumi.get(self, "append")

    @property
    @pulumi.getter(name="ignoreInterrupts")
    def ignore_interrupts(self) -> Optional[bool]:
        """
        Ignore interrupt signals.
        """
        return pulumi.get(self, "ignore_interrupts")

    @property
    @pulumi.getter(name="outputError")
    def output_error(self) -> Optional['TeeMode']:
        """
        Set behavior on write error.
        """
        return pulumi.get(self, "output_error")

    @property
    @pulumi.getter
    def pipe(self) -> Optional[bool]:
        """
        Operate in a more appropriate MODE with pipes.
        """
        return pulumi.get(self, "pipe")

    @property
    @pulumi.getter
    def version(self) -> Optional[bool]:
        """
        Output version information and exit.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class WgetOpts(dict):
    """
    Abstraction over the `wget` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "directoryPrefix":
            suggest = "directory_prefix"
        elif key == "httpsOnly":
            suggest = "https_only"
        elif key == "noVerbose":
            suggest = "no_verbose"
        elif key == "outputDocument":
            suggest = "output_document"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WgetOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WgetOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WgetOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: Sequence[str],
                 directory_prefix: Optional[str] = None,
                 https_only: Optional[bool] = None,
                 no_verbose: Optional[bool] = None,
                 output_document: Optional[str] = None,
                 quiet: Optional[bool] = None,
                 timestamping: Optional[bool] = None):
        """
        Abstraction over the `wget` utility on a remote system.
        :param Sequence[str] url: Corresponds to the [URL...] argument.
        :param str directory_prefix: The  directory prefix is the directory where all other files and subdirectories will be saved to, i.e. the top of the retrieval tree.  The default is . (the current directory).
        :param bool https_only: When in recursive mode, only HTTPS links are followed.
        :param bool no_verbose: Turn off verbose without being completely quiet (use -q for that), which means that error messages and basic information still get printed.
        :param str output_document: The  documents  will  not  be  written  to the appropriate files, but all will be concatenated together and written to file.
        :param bool quiet: Turn off Wget's output.
        :param bool timestamping: Turn on time-stamping.
        """
        pulumi.set(__self__, "url", url)
        if directory_prefix is not None:
            pulumi.set(__self__, "directory_prefix", directory_prefix)
        if https_only is not None:
            pulumi.set(__self__, "https_only", https_only)
        if no_verbose is not None:
            pulumi.set(__self__, "no_verbose", no_verbose)
        if output_document is not None:
            pulumi.set(__self__, "output_document", output_document)
        if quiet is not None:
            pulumi.set(__self__, "quiet", quiet)
        if timestamping is not None:
            pulumi.set(__self__, "timestamping", timestamping)

    @property
    @pulumi.getter
    def url(self) -> Sequence[str]:
        """
        Corresponds to the [URL...] argument.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="directoryPrefix")
    def directory_prefix(self) -> Optional[str]:
        """
        The  directory prefix is the directory where all other files and subdirectories will be saved to, i.e. the top of the retrieval tree.  The default is . (the current directory).
        """
        return pulumi.get(self, "directory_prefix")

    @property
    @pulumi.getter(name="httpsOnly")
    def https_only(self) -> Optional[bool]:
        """
        When in recursive mode, only HTTPS links are followed.
        """
        return pulumi.get(self, "https_only")

    @property
    @pulumi.getter(name="noVerbose")
    def no_verbose(self) -> Optional[bool]:
        """
        Turn off verbose without being completely quiet (use -q for that), which means that error messages and basic information still get printed.
        """
        return pulumi.get(self, "no_verbose")

    @property
    @pulumi.getter(name="outputDocument")
    def output_document(self) -> Optional[str]:
        """
        The  documents  will  not  be  written  to the appropriate files, but all will be concatenated together and written to file.
        """
        return pulumi.get(self, "output_document")

    @property
    @pulumi.getter
    def quiet(self) -> Optional[bool]:
        """
        Turn off Wget's output.
        """
        return pulumi.get(self, "quiet")

    @property
    @pulumi.getter
    def timestamping(self) -> Optional[bool]:
        """
        Turn on time-stamping.
        """
        return pulumi.get(self, "timestamping")


