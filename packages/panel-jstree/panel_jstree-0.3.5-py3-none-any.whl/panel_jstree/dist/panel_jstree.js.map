{"version":3,"sources":["@@/src/panel_jstree/dist/lib/index.js","@@/src/panel_jstree/dist/lib/bokeh_extensions/index.js","@@/src/panel_jstree/dist/lib/bokeh_extensions/jstree.js","@@/src/panel_jstree/dist/lib/bokeh_extensions/layout.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"generated.js","sourceRoot":"","sourcesContent":["/* index.js */ function _(require, module, exports, __esModule, __esExport) {\n    __esModule();\n    const tslib_1 = require(\"tslib\");\n    const PaneljsTree = tslib_1.__importStar(require(\"ef403b5ad2\") /* ./bokeh_extensions/ */);\n    exports.PaneljsTree = PaneljsTree;\n    const base_1 = require(\"@bokehjs/base\");\n    (0, base_1.register_models)(PaneljsTree);\n}\n","/* bokeh_extensions/index.js */ function _(require, module, exports, __esModule, __esExport) {\n    __esModule();\n    const tslib_1 = require(\"tslib\");\n    const jsTree = tslib_1.__importStar(require(\"fd98e92f49\") /* ./jstree */);\n    exports.jsTree = jsTree;\n    const base_1 = require(\"@bokehjs/base\");\n    (0, base_1.register_models)(jsTree);\n}\n","/* bokeh_extensions/jstree.js */ function _(require, module, exports, __esModule, __esExport) {\n    __esModule();\n    var _a;\n    const dom_1 = require(\"@bokehjs/core/dom\");\n    const layout_1 = require(\"cac5f3ed28\") /* ./layout */;\n    function ID() {\n        // Math.random should be unique because of its seeding algorithm.\n        // Convert it to base 36 (numbers + letters), and grab the first 9 characters\n        // after the decimal.\n        return '_' + Math.random().toString(36).substring(2, 11);\n    }\n    class jsTreePlotView extends layout_1.HTMLBoxView {\n        initialize() {\n            super.initialize();\n            this._last_selected = [];\n        }\n        connect_signals() {\n            // console.log(\"connect\")\n            super.connect_signals();\n            this.connect(this.model.properties._data.change, () => this._update_tree_from_data());\n            this.connect(this.model.properties.value.change, () => this._update_selection_from_value());\n            this.connect(this.model.properties._new_nodes.change, () => this._update_tree_from_new_nodes());\n            this.connect(this.model.properties.checkbox.change, () => this.setCheckboxes());\n            this.connect(this.model.properties.show_icons.change, () => this._setShowIcons());\n            this.connect(this.model.properties.show_dots.change, () => this._setShowDots());\n            this.connect(this.model.properties.multiple.change, () => this._setMultiple());\n            // console.log(this.model.show_dots)\n            // console.log(this.model.show_icons)\n        }\n        render() {\n            super.render();\n            this._id = ID();\n            // console.log(this._id)\n            this._container = (0, dom_1.div)({ id: this._id, style: \"overflow: auto; minHeight: 200px; minWidth: 200px;\" });\n            (0, layout_1.set_size)(this._container, this.model);\n            this.shadow_el.appendChild(this._container);\n            // console.log(this._container)\n            if (this.model.checkbox && !this.model.plugins.includes(\"checkbox\")) {\n                this.model.plugins.push(\"checkbox\");\n            }\n            this._jstree = jQuery(this._container).jstree({ \"core\": { \"data\": this.model._data, \"check_callback\": true,\n                    \"multiple\": this.model.multiple,\n                    \"themes\": {\n                        \"dots\": this.model.show_dots,\n                        \"icons\": this.model.show_icons\n                    }\n                },\n                \"plugins\": this.model.plugins,\n                checkbox: {\n                    three_state: this.model.cascade_setting == \"\" ? this.model.cascade : false,\n                    cascade: this.model.cascade_setting == \"\" ? \"up+down+undetermined\" : this.model.cascade_setting,\n                    cascade_to_disabled: false,\n                }\n            });\n            this.init_callbacks();\n        }\n        init_callbacks() {\n            // Initialization\n            // Rendering callbacks\n            // TODO: do I need both of these?\n            this._jstree.on('refresh.jstree', ({}, {}) => this._update_selection_from_value());\n            // Sync state with model\n            this._jstree.on('model.jstree', ({}, {}) => this.onNewData());\n            this._jstree.on('activate_node.jstree', ({}, data) => this.selectNodeFromEditor({}, data));\n            this._jstree.on('before_open.jstree', (e, data) => this._listen_for_node_open(e, data));\n        }\n        onNewData() {\n            this.model._flat_tree = this._jstree.jstree(true).get_json(null, { \"flat\": true });\n            // console.log(\"Flat tree: \", this.model._flat_tree)\n        }\n        selectNodeFromEditor({}, data) {\n            // console.log(\"select pre\", this.model.value)\n            this.model.value = data.instance.get_selected();\n            // console.log(\"select post\", this.model.value)\n        }\n        _update_selection_from_value() {\n            // console.log(\"update selection from value\")\n            this._jstree.jstree(true).select_node(this.model.value);\n            // We sometimes have to fire this function more than once per value change because of\n            // calling jstree.refresh, so we check to see if model.value has really changed\n            // by comparing to last_selected\n            if (this.model.value != this._last_selected) {\n                let deselected = this._last_selected.filter(x => !this.model.value.includes(x));\n                this._jstree.jstree(true).deselect_node(deselected);\n            }\n            // We choose get_selected\n            this._last_selected = this.model.value;\n        }\n        _update_tree_from_new_nodes() {\n            // console.log(\"new nodes: \", this.model._new_nodes)\n            for (let node of this.model._new_nodes) {\n                this._jstree.jstree(true).create_node(node[\"parent\"], node, \"first\");\n            }\n            this._jstree.jstree(true).settings.core.data = this._jstree.jstree(true).get_json(null, { no_li_attr: true, no_a_attr: true, no_data: true });\n            this.model._data = this._jstree.jstree(true).settings.core.data;\n            // this._update_selection_from_value()\n        }\n        _update_tree_from_data() {\n            // console.log(\"updating data\")\n            this._jstree.jstree(true).settings.core.data = this.model._data;\n            // console.log(\"data: \", this._jstree.jstree(true).settings.core.data)\n            // console.log(\"value after data\", this.model.value)\n            // This will redraw the tree if we swap out the data with new data\n            // we set forget_state to true, so the current state is not reapplied\n            // letting whatever state is set in the new data (open or closed, etc)\n            // be the new state\n            this._jstree.jstree(true).refresh({ \"skip_loading\": false,\n                \"forget_state\": true });\n            // selected state is not preserved correctly right now, so we then\n            // deselect everything because that is better than getting it wrong\n            this._jstree.jstree(true).deselect_all({ \"supress_event\": true });\n            // console.log(\"value after refresh\", this.model.value)\n            // console.log(\"data after refresh\", this._jstree.jstree(true).settings.core.data)\n        }\n        _setShowIcons() {\n            // console.log(\"setShowIcons\")\n            if (this.model.show_icons) {\n                this._jstree.jstree(true).show_icons();\n            }\n            else {\n                this._jstree.jstree(true).hide_icons();\n            }\n        }\n        _setShowDots() {\n            // console.log(\"setShowDots\")\n            if (this.model.show_dots) {\n                this._jstree.jstree(true).show_dots();\n            }\n            else {\n                this._jstree.jstree(true).hide_dots();\n            }\n        }\n        setCheckboxes() {\n            // console.log(\"setCheckBoxes\")\n            if (this.model.checkbox) {\n                this._jstree.jstree(true).show_checkboxes();\n            }\n            else {\n                this._jstree.jstree(true).hide_checkboxes();\n            }\n        }\n        _setMultiple() {\n            // console.log(\"setMultiple\")\n            this._jstree.jstree(true).settings.core.multiple = this.model.multiple;\n        }\n        _update_tree_theme_from_model() {\n            this._jstree.jstree(true).refresh(false, true);\n        }\n        _listen_for_node_open({}, data) {\n            // console.log(\"listen for node open\")\n            data.node = this.add_node_children(data.node);\n            this.model._last_opened = data.node;\n        }\n        add_node_children(node) {\n            // console.log(\"add node children\")\n            node[\"children_nodes\"] = [];\n            for (let child of node.children) {\n                node.children_nodes.push(this._jstree.jstree(true).get_node(child));\n            }\n            return node;\n        }\n    }\n    exports.jsTreePlotView = jsTreePlotView;\n    jsTreePlotView.__name__ = \"jsTreePlotView\";\n    class jsTreePlot extends layout_1.HTMLBox {\n        constructor(attrs) {\n            super(attrs);\n        }\n    }\n    exports.jsTreePlot = jsTreePlot;\n    _a = jsTreePlot;\n    jsTreePlot.__name__ = \"jsTreePlot\";\n    jsTreePlot.__module__ = \"panel_jstree.bokeh_extensions.jstree\";\n    (() => {\n        _a.prototype.default_view = jsTreePlotView;\n        _a.define(({ Array, Any, Boolean }) => ({\n            value: [Array(Any), []],\n            _data: [Array(Any), []],\n            plugins: [Array(Any), []],\n            checkbox: [Boolean, true],\n            multiple: [Boolean, true],\n            show_icons: [Boolean, true],\n            show_dots: [Boolean, true],\n            cascade: [Boolean, true],\n            cascade_setting: [Any, \"\"],\n            _last_opened: [Any, {}],\n            _new_nodes: [Array(Any), []],\n            _flat_tree: [Array(Any), []],\n        }));\n    })();\n}\n","/* bokeh_extensions/layout.js */ function _(require, module, exports, __esModule, __esExport) {\n    __esModule();\n    const dom_1 = require(\"@bokehjs/core/dom\");\n    const types_1 = require(\"@bokehjs/core/util/types\");\n    const widget_1 = require(\"@bokehjs/models/widgets/widget\");\n    const layout_dom_1 = require(\"@bokehjs/models/layouts/layout_dom\");\n    class PanelMarkupView extends widget_1.WidgetView {\n        connect_signals() {\n            super.connect_signals();\n            const { width, height, min_height, max_height, margin, sizing_mode } = this.model.properties;\n            this.on_change([width, height, min_height, max_height, margin, sizing_mode], () => {\n                set_size(this.el, this.model);\n                set_size(this.container, this.model, false);\n            });\n        }\n        async lazy_initialize() {\n            await super.lazy_initialize();\n            if (this.provider.status == \"not_started\" || this.provider.status == \"loading\")\n                this.provider.ready.connect(() => {\n                    if (this.contains_tex_string(this.model.text))\n                        this.render();\n                });\n        }\n        watch_stylesheets() {\n            this._initialized_stylesheets = {};\n            for (const sts of this._applied_stylesheets) {\n                const style_el = sts.el;\n                if (style_el instanceof HTMLLinkElement) {\n                    this._initialized_stylesheets[style_el.href] = false;\n                    style_el.addEventListener(\"load\", () => {\n                        this._initialized_stylesheets[style_el.href] = true;\n                        if (Object.values(this._initialized_stylesheets).every(Boolean))\n                            this.style_redraw();\n                    });\n                }\n            }\n        }\n        style_redraw() {\n        }\n        has_math_disabled() {\n            return this.model.disable_math || !this.contains_tex_string(this.model.text);\n        }\n        render() {\n            super.render();\n            set_size(this.el, this.model);\n            this.container = (0, dom_1.div)();\n            set_size(this.container, this.model, false);\n            this.shadow_el.appendChild(this.container);\n            if (this.provider.status == \"failed\" || this.provider.status == \"loaded\")\n                this._has_finished = true;\n        }\n    }\n    exports.PanelMarkupView = PanelMarkupView;\n    PanelMarkupView.__name__ = \"PanelMarkupView\";\n    function set_size(el, model, adjustMargin = true) {\n        let width_policy = model.width != null ? \"fixed\" : \"fit\";\n        let height_policy = model.height != null ? \"fixed\" : \"fit\";\n        const { sizing_mode, margin } = model;\n        if (sizing_mode != null) {\n            if (sizing_mode == \"fixed\")\n                width_policy = height_policy = \"fixed\";\n            else if (sizing_mode == \"stretch_both\")\n                width_policy = height_policy = \"max\";\n            else if (sizing_mode == \"stretch_width\")\n                width_policy = \"max\";\n            else if (sizing_mode == \"stretch_height\")\n                height_policy = \"max\";\n            else {\n                switch (sizing_mode) {\n                    case \"scale_width\":\n                        width_policy = \"max\";\n                        height_policy = \"min\";\n                        break;\n                    case \"scale_height\":\n                        width_policy = \"min\";\n                        height_policy = \"max\";\n                        break;\n                    case \"scale_both\":\n                        width_policy = \"max\";\n                        height_policy = \"max\";\n                        break;\n                    default:\n                        throw new Error(\"unreachable\");\n                }\n            }\n        }\n        let wm, hm;\n        if (!adjustMargin) {\n            hm = wm = 0;\n        }\n        else if ((0, types_1.isArray)(margin)) {\n            if (margin.length === 4) {\n                hm = margin[0] + margin[2];\n                wm = margin[1] + margin[3];\n            }\n            else {\n                hm = margin[0] * 2;\n                wm = margin[1] * 2;\n            }\n        }\n        else if (margin == null) {\n            hm = wm = 0;\n        }\n        else {\n            wm = hm = margin * 2;\n        }\n        if (width_policy == \"fixed\" && model.width)\n            el.style.width = model.width + \"px\";\n        else if (width_policy == \"max\")\n            el.style.width = wm ? `calc(100% - ${wm}px)` : \"100%\";\n        if (model.min_width != null)\n            el.style.minWidth = model.min_width + \"px\";\n        if (model.max_width != null)\n            el.style.maxWidth = model.max_width + \"px\";\n        if (height_policy == \"fixed\" && model.height)\n            el.style.height = model.height + \"px\";\n        else if (height_policy == \"max\")\n            el.style.height = hm ? `calc(100% - ${hm}px)` : \"100%\";\n        if (model.min_height != null)\n            el.style.minHeight = model.min_height + \"px\";\n        if (model.max_width != null)\n            el.style.maxHeight = model.max_height + \"px\";\n    }\n    exports.set_size = set_size;\n    class HTMLBoxView extends layout_dom_1.LayoutDOMView {\n        connect_signals() {\n            super.connect_signals();\n            const { width, height, min_height, max_height, margin, sizing_mode } = this.model.properties;\n            this.on_change([width, height, min_height, max_height, margin, sizing_mode], () => {\n                set_size(this.el, this.model);\n            });\n        }\n        render() {\n            super.render();\n            set_size(this.el, this.model);\n        }\n        watch_stylesheets() {\n            this._initialized_stylesheets = {};\n            for (const sts of this._applied_stylesheets) {\n                const style_el = sts.el;\n                if (style_el instanceof HTMLLinkElement) {\n                    this._initialized_stylesheets[style_el.href] = false;\n                    style_el.addEventListener(\"load\", () => {\n                        this._initialized_stylesheets[style_el.href] = true;\n                        if (Object.values(this._initialized_stylesheets).every(Boolean))\n                            this.style_redraw();\n                    });\n                }\n            }\n        }\n        style_redraw() {\n        }\n        get child_models() {\n            return [];\n        }\n    }\n    exports.HTMLBoxView = HTMLBoxView;\n    HTMLBoxView.__name__ = \"HTMLBoxView\";\n    class HTMLBox extends layout_dom_1.LayoutDOM {\n        constructor(attrs) {\n            super(attrs);\n        }\n    }\n    exports.HTMLBox = HTMLBox;\n    HTMLBox.__name__ = \"HTMLBox\";\n}\n"]}