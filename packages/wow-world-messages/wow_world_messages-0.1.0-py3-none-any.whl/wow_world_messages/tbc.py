from __future__ import annotations
import asyncio
import dataclasses
import enum
import struct
import typing
import zlib

import wow_srp
from .util import packed_guid_size
from .util import packed_guid_write
from .util import read_packed_guid
from .util import read_sized_cstring
from .util import read_bool
from .util import read_int
from .util import read_cstring
from .util import read_float

__all__ = [
    "read_client_opcodes_unencrypted",
    "read_client_opcodes_encrypted",
    "read_server_opcodes_unencrypted",
    "read_server_opcodes_encrypted",
    "expect_client_opcode_unencrypted",
    "expect_client_opcode_encrypted",
    "expect_server_opcode_unencrypted",
    "expect_server_opcode_encrypted",
    "NamedGuid",
    "VariableItemRandomProperty",
    "AddonArray",
    "AchievementDoneArray",
    "AchievementInProgressArray",
    "AuraMask",
    "UpdateMask",
    "AccountDataType",
    "ActivateTaxiReply",
    "AiReaction",
    "Area",
    "ArenaFaction",
    "ArenaTeamCommand",
    "ArenaTeamCommandError",
    "ArenaTeamEvent",
    "ArenaTeamRole",
    "ArenaType",
    "AuctionCommandAction",
    "AuctionCommandResult",
    "AuctionCommandResultTwo",
    "AuctionHouse",
    "AuraMod",
    "AuraType",
    "BankSwapSource",
    "BankSwapStoreMode",
    "BattlefieldPortAction",
    "BattlegroundType",
    "BgTypeId",
    "Bonding",
    "BuyBankSlotResult",
    "BuyResult",
    "BuybackSlot",
    "CharterType",
    "ChatNotify",
    "ChatRestrictionType",
    "ChatType",
    "CinematicSequenceId",
    "Class",
    "CommentatorEnableOption",
    "ComplainResultWindow",
    "ComplaintStatus",
    "CorpseQueryResult",
    "CreatureFamily",
    "DeclinedNames",
    "DeclinedPetNameIncluded",
    "DispelMethod",
    "DuelWinnerReason",
    "DungeonDifficulty",
    "Emote",
    "EnvironmentalDamageType",
    "Expansion",
    "ExperienceAwardType",
    "Faction",
    "FarSightOperation",
    "FriendResult",
    "FriendStatus",
    "Gender",
    "GmTicketEscalationStatus",
    "GmTicketQueueStatus",
    "GmTicketResponse",
    "GmTicketStatus",
    "GmTicketStatusResponse",
    "GmTicketType",
    "GroupLootSetting",
    "GroupType",
    "GuildBankTabResult",
    "GuildCommand",
    "GuildCommandResult",
    "GuildEmblemResult",
    "GuildEvent",
    "GuildMemberStatus",
    "HitInfo",
    "InstanceResetFailedReason",
    "InventoryResult",
    "InventoryType",
    "ItemClass",
    "ItemClassAndSubClass",
    "ItemQuality",
    "ItemSet",
    "ItemSlot",
    "JoinArenaType",
    "Language",
    "LfgMode",
    "LfgType",
    "LfgUpdateLookingForMore",
    "LogFormat",
    "LogoutResult",
    "LogoutSpeed",
    "LootMethod",
    "LootMethodError",
    "LootSlotType",
    "MailAction",
    "MailMessageType",
    "MailResult",
    "MailResultTwo",
    "MailType",
    "Map",
    "MeetingStoneStatus",
    "MonsterMoveType",
    "MountResult",
    "NewItemChatAlert",
    "NewItemCreationType",
    "NewItemSource",
    "ObjectType",
    "PageTextMaterial",
    "PartyOperation",
    "PartyResult",
    "PartyRole",
    "PetCommandState",
    "PetEnabled",
    "PetFeedback",
    "PetNameInvalidReason",
    "PetQueryDisabledNames",
    "PetReactState",
    "PetTalkReason",
    "PetTameFailureReason",
    "PetitionResult",
    "PlayerChatTag",
    "Power",
    "PvpRank",
    "QuestCompletable",
    "QuestFailedReason",
    "QuestGiverStatus",
    "QuestPartyMessage",
    "Race",
    "RaidGroupError",
    "RaidInstanceMessage",
    "RaidTargetIndex",
    "RaidTargetUpdateType",
    "RealmSplitState",
    "ReferAFriendError",
    "RollVote",
    "SellItemResult",
    "ServerMessageType",
    "SheathState",
    "SheatheType",
    "SizeClass",
    "Skill",
    "SkillCategory",
    "SpamType",
    "SpellCastResult",
    "SpellEffect",
    "SpellMissInfo",
    "SpellSchool",
    "SpellStealAction",
    "SpellTriggerType",
    "StableResult",
    "StatusId",
    "Talent",
    "TextEmote",
    "TimerType",
    "TitleEarnStatus",
    "TradeStatus",
    "TrainerSpellState",
    "TrainingFailureReason",
    "TransferAbortReason",
    "UnitStandState",
    "UpdateType",
    "WeatherChangeType",
    "WeatherType",
    "WorldResult",
    "AllowedClass",
    "AllowedRace",
    "BagFamily",
    "BillingPlanFlags",
    "CastFlags",
    "ChannelFlags",
    "ChannelMemberFlags",
    "FactionFlag",
    "GroupMemberOnlineStatus",
    "GroupUpdateFlags",
    "ItemFlag",
    "MovementFlags",
    "RelationType",
    "SpellCastTargetFlags",
    "SplineFlag",
    "UpdateFlag",
    "Addon",
    "AddonInfo",
    "ArenaTeamMember",
    "AuctionEnchantment",
    "AuctionListItem",
    "AuctionSort",
    "Aura",
    "AuraLog",
    "BankTab",
    "BattlegroundPlayerPosition",
    "ChannelMember",
    "Vector3d",
    "MonsterMoveSpline",
    "CharacterGear",
    "Character",
    "CooldownSpell",
    "DamageInfo",
    "DispelledSpell",
    "FactionInitializer",
    "FactionStanding",
    "ForcedReaction",
    "GmSurveyQuestion",
    "GossipItem",
    "GroupListMember",
    "GuildBankRights",
    "GuildBankSocket",
    "GuildBankSlot",
    "GuildBankTab",
    "GuildLogEvent",
    "GuildMember",
    "GuildRights",
    "InitialSpell",
    "ItemDamageType",
    "ItemSocket",
    "ItemSpells",
    "ItemStat",
    "LfgData",
    "LfgPlayerMember",
    "LfgPlayer",
    "ListInventoryItem",
    "LootItem",
    "MailListItemEnchant",
    "MailListItem",
    "Mail",
    "MailItem",
    "MoneyLogItem",
    "TransportInfo",
    "MovementBlock",
    "MovementInfo",
    "NpcTextUpdateEmote",
    "NpcTextUpdate",
    "Object",
    "PetSpellCooldown",
    "PetitionShowlist",
    "PetitionSignature",
    "QuestDetailsEmote",
    "QuestGiverStatusReport",
    "QuestItem",
    "QuestItemRequirement",
    "QuestItemReward",
    "QuestObjective",
    "RaidInfo",
    "RaidTargetUpdate",
    "ReceivedMail",
    "Relation",
    "SpellCastTargets",
    "SpellCooldownStatus",
    "SpellLog",
    "SpellLogMiss",
    "SpellMiss",
    "SpellSteal",
    "StabledPet",
    "TradeSlot",
    "TrainerSpell",
    "Vector2d",
    "WhoPlayer",
    "WorldState",
    "CMSG_BOOTME",
    "CMSG_DBLOOKUP",
    "CMSG_WORLD_TELEPORT",
    "CMSG_TELEPORT_TO_UNIT",
    "CMSG_CHAR_CREATE",
    "CMSG_CHAR_ENUM",
    "CMSG_CHAR_DELETE",
    "SMSG_CHAR_CREATE",
    "SMSG_CHAR_ENUM",
    "SMSG_CHAR_DELETE",
    "CMSG_PLAYER_LOGIN",
    "SMSG_NEW_WORLD",
    "SMSG_TRANSFER_PENDING",
    "SMSG_TRANSFER_ABORTED",
    "SMSG_CHARACTER_LOGIN_FAILED",
    "SMSG_LOGIN_SETTIMESPEED",
    "CMSG_PLAYER_LOGOUT",
    "CMSG_LOGOUT_REQUEST",
    "SMSG_LOGOUT_RESPONSE",
    "SMSG_LOGOUT_COMPLETE",
    "CMSG_LOGOUT_CANCEL",
    "SMSG_LOGOUT_CANCEL_ACK",
    "CMSG_NAME_QUERY",
    "SMSG_NAME_QUERY_RESPONSE",
    "CMSG_PET_NAME_QUERY",
    "SMSG_PET_NAME_QUERY_RESPONSE",
    "CMSG_GUILD_QUERY",
    "SMSG_GUILD_QUERY_RESPONSE",
    "CMSG_ITEM_QUERY_SINGLE",
    "SMSG_ITEM_QUERY_SINGLE_RESPONSE",
    "CMSG_PAGE_TEXT_QUERY",
    "SMSG_PAGE_TEXT_QUERY_RESPONSE",
    "CMSG_QUEST_QUERY",
    "SMSG_QUEST_QUERY_RESPONSE",
    "CMSG_GAMEOBJECT_QUERY",
    "SMSG_GAMEOBJECT_QUERY_RESPONSE",
    "CMSG_CREATURE_QUERY",
    "SMSG_CREATURE_QUERY_RESPONSE",
    "CMSG_WHO",
    "SMSG_WHO",
    "CMSG_WHOIS",
    "SMSG_WHOIS",
    "CMSG_CONTACT_LIST",
    "SMSG_CONTACT_LIST",
    "SMSG_FRIEND_STATUS",
    "CMSG_ADD_FRIEND",
    "CMSG_DEL_FRIEND",
    "CMSG_SET_CONTACT_NOTES",
    "CMSG_ADD_IGNORE",
    "CMSG_DEL_IGNORE",
    "CMSG_GROUP_INVITE",
    "SMSG_GROUP_INVITE",
    "CMSG_GROUP_CANCEL",
    "CMSG_GROUP_ACCEPT",
    "CMSG_GROUP_DECLINE",
    "SMSG_GROUP_DECLINE",
    "CMSG_GROUP_UNINVITE",
    "CMSG_GROUP_UNINVITE_GUID",
    "SMSG_GROUP_UNINVITE",
    "CMSG_GROUP_SET_LEADER",
    "SMSG_GROUP_SET_LEADER",
    "CMSG_LOOT_METHOD",
    "CMSG_GROUP_DISBAND",
    "SMSG_GROUP_DESTROYED",
    "SMSG_GROUP_LIST",
    "SMSG_PARTY_MEMBER_STATS",
    "SMSG_PARTY_COMMAND_RESULT",
    "CMSG_GUILD_CREATE",
    "CMSG_GUILD_INVITE",
    "SMSG_GUILD_INVITE",
    "CMSG_GUILD_ACCEPT",
    "CMSG_GUILD_DECLINE",
    "SMSG_GUILD_DECLINE",
    "CMSG_GUILD_INFO",
    "SMSG_GUILD_INFO",
    "CMSG_GUILD_ROSTER",
    "SMSG_GUILD_ROSTER",
    "CMSG_GUILD_PROMOTE",
    "CMSG_GUILD_DEMOTE",
    "CMSG_GUILD_LEAVE",
    "CMSG_GUILD_REMOVE",
    "CMSG_GUILD_DISBAND",
    "CMSG_GUILD_LEADER",
    "CMSG_GUILD_MOTD",
    "SMSG_GUILD_EVENT",
    "SMSG_GUILD_COMMAND_RESULT",
    "CMSG_MESSAGECHAT",
    "SMSG_MESSAGECHAT",
    "CMSG_JOIN_CHANNEL",
    "CMSG_LEAVE_CHANNEL",
    "SMSG_CHANNEL_NOTIFY",
    "CMSG_CHANNEL_LIST",
    "SMSG_CHANNEL_LIST",
    "CMSG_CHANNEL_PASSWORD",
    "CMSG_CHANNEL_SET_OWNER",
    "CMSG_CHANNEL_OWNER",
    "CMSG_CHANNEL_MODERATOR",
    "CMSG_CHANNEL_UNMODERATOR",
    "CMSG_CHANNEL_MUTE",
    "CMSG_CHANNEL_UNMUTE",
    "CMSG_CHANNEL_INVITE",
    "CMSG_CHANNEL_KICK",
    "CMSG_CHANNEL_BAN",
    "CMSG_CHANNEL_UNBAN",
    "CMSG_CHANNEL_ANNOUNCEMENTS",
    "CMSG_CHANNEL_MODERATE",
    "SMSG_UPDATE_OBJECT",
    "SMSG_DESTROY_OBJECT",
    "CMSG_USE_ITEM",
    "CMSG_OPEN_ITEM",
    "CMSG_READ_ITEM",
    "SMSG_READ_ITEM_OK",
    "SMSG_READ_ITEM_FAILED",
    "SMSG_ITEM_COOLDOWN",
    "CMSG_GAMEOBJ_USE",
    "SMSG_GAMEOBJECT_CUSTOM_ANIM",
    "CMSG_AREATRIGGER",
    "MSG_MOVE_START_FORWARD_Client",
    "MSG_MOVE_START_FORWARD_Server",
    "MSG_MOVE_START_BACKWARD_Client",
    "MSG_MOVE_START_BACKWARD_Server",
    "MSG_MOVE_STOP_Client",
    "MSG_MOVE_STOP_Server",
    "MSG_MOVE_START_STRAFE_LEFT_Client",
    "MSG_MOVE_START_STRAFE_LEFT_Server",
    "MSG_MOVE_START_STRAFE_RIGHT_Client",
    "MSG_MOVE_START_STRAFE_RIGHT_Server",
    "MSG_MOVE_STOP_STRAFE_Client",
    "MSG_MOVE_STOP_STRAFE_Server",
    "MSG_MOVE_JUMP_Client",
    "MSG_MOVE_JUMP_Server",
    "MSG_MOVE_START_TURN_LEFT_Client",
    "MSG_MOVE_START_TURN_LEFT_Server",
    "MSG_MOVE_START_TURN_RIGHT_Client",
    "MSG_MOVE_START_TURN_RIGHT_Server",
    "MSG_MOVE_STOP_TURN_Client",
    "MSG_MOVE_STOP_TURN_Server",
    "MSG_MOVE_START_PITCH_UP_Client",
    "MSG_MOVE_START_PITCH_UP_Server",
    "MSG_MOVE_START_PITCH_DOWN_Client",
    "MSG_MOVE_START_PITCH_DOWN_Server",
    "MSG_MOVE_STOP_PITCH_Client",
    "MSG_MOVE_STOP_PITCH_Server",
    "MSG_MOVE_SET_RUN_MODE_Client",
    "MSG_MOVE_SET_RUN_MODE_Server",
    "MSG_MOVE_SET_WALK_MODE_Client",
    "MSG_MOVE_SET_WALK_MODE_Server",
    "MSG_MOVE_TELEPORT_Server",
    "MSG_MOVE_TELEPORT_CHEAT_Server",
    "MSG_MOVE_TELEPORT_ACK_Client",
    "MSG_MOVE_TELEPORT_ACK_Server",
    "MSG_MOVE_FALL_LAND_Client",
    "MSG_MOVE_FALL_LAND_Server",
    "MSG_MOVE_START_SWIM_Client",
    "MSG_MOVE_START_SWIM_Server",
    "MSG_MOVE_STOP_SWIM_Client",
    "MSG_MOVE_STOP_SWIM_Server",
    "MSG_MOVE_SET_FACING_Client",
    "MSG_MOVE_SET_FACING_Server",
    "MSG_MOVE_SET_PITCH_Client",
    "MSG_MOVE_SET_PITCH_Server",
    "MSG_MOVE_WORLDPORT_ACK",
    "SMSG_MONSTER_MOVE",
    "SMSG_MOVE_WATER_WALK",
    "SMSG_MOVE_LAND_WALK",
    "CMSG_MOVE_SET_RAW_POSITION",
    "SMSG_FORCE_RUN_SPEED_CHANGE",
    "CMSG_FORCE_RUN_SPEED_CHANGE_ACK",
    "SMSG_FORCE_RUN_BACK_SPEED_CHANGE",
    "CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK",
    "SMSG_FORCE_SWIM_SPEED_CHANGE",
    "CMSG_FORCE_SWIM_SPEED_CHANGE_ACK",
    "SMSG_FORCE_MOVE_ROOT",
    "CMSG_FORCE_MOVE_ROOT_ACK",
    "SMSG_FORCE_MOVE_UNROOT",
    "CMSG_FORCE_MOVE_UNROOT_ACK",
    "MSG_MOVE_ROOT_Server",
    "MSG_MOVE_UNROOT_Server",
    "MSG_MOVE_HEARTBEAT_Client",
    "MSG_MOVE_HEARTBEAT_Server",
    "SMSG_MOVE_KNOCK_BACK",
    "CMSG_MOVE_KNOCK_BACK_ACK",
    "MSG_MOVE_KNOCK_BACK_Server",
    "SMSG_MOVE_FEATHER_FALL",
    "SMSG_MOVE_NORMAL_FALL",
    "SMSG_MOVE_SET_HOVER",
    "SMSG_MOVE_UNSET_HOVER",
    "CMSG_MOVE_HOVER_ACK",
    "MSG_MOVE_HOVER",
    "SMSG_TRIGGER_CINEMATIC",
    "CMSG_NEXT_CINEMATIC_CAMERA",
    "CMSG_COMPLETE_CINEMATIC",
    "SMSG_TUTORIAL_FLAGS",
    "CMSG_TUTORIAL_FLAG",
    "CMSG_TUTORIAL_CLEAR",
    "CMSG_TUTORIAL_RESET",
    "CMSG_STANDSTATECHANGE",
    "CMSG_EMOTE",
    "SMSG_EMOTE",
    "CMSG_TEXT_EMOTE",
    "SMSG_TEXT_EMOTE",
    "CMSG_AUTOSTORE_LOOT_ITEM",
    "CMSG_AUTOEQUIP_ITEM",
    "CMSG_AUTOSTORE_BAG_ITEM",
    "CMSG_SWAP_ITEM",
    "CMSG_SWAP_INV_ITEM",
    "CMSG_SPLIT_ITEM",
    "CMSG_AUTOEQUIP_ITEM_SLOT",
    "CMSG_DESTROYITEM",
    "SMSG_INVENTORY_CHANGE_FAILURE",
    "CMSG_INSPECT",
    "CMSG_INITIATE_TRADE",
    "CMSG_BEGIN_TRADE",
    "CMSG_BUSY_TRADE",
    "CMSG_IGNORE_TRADE",
    "CMSG_ACCEPT_TRADE",
    "CMSG_UNACCEPT_TRADE",
    "CMSG_CANCEL_TRADE",
    "CMSG_SET_TRADE_ITEM",
    "CMSG_CLEAR_TRADE_ITEM",
    "CMSG_SET_TRADE_GOLD",
    "SMSG_TRADE_STATUS",
    "SMSG_TRADE_STATUS_EXTENDED",
    "SMSG_INITIALIZE_FACTIONS",
    "SMSG_SET_FACTION_VISIBLE",
    "SMSG_SET_FACTION_STANDING",
    "CMSG_SET_FACTION_ATWAR",
    "SMSG_SET_PROFICIENCY",
    "CMSG_SET_ACTION_BUTTON",
    "SMSG_ACTION_BUTTONS",
    "SMSG_INITIAL_SPELLS",
    "SMSG_LEARNED_SPELL",
    "SMSG_SUPERCEDED_SPELL",
    "CMSG_CAST_SPELL",
    "CMSG_CANCEL_CAST",
    "SMSG_CAST_FAILED",
    "SMSG_SPELL_START",
    "SMSG_SPELL_GO",
    "SMSG_SPELL_FAILURE",
    "SMSG_SPELL_COOLDOWN",
    "SMSG_COOLDOWN_EVENT",
    "CMSG_CANCEL_AURA",
    "SMSG_UPDATE_AURA_DURATION",
    "SMSG_PET_CAST_FAILED",
    "MSG_CHANNEL_START_Server",
    "MSG_CHANNEL_UPDATE_Server",
    "CMSG_CANCEL_CHANNELLING",
    "SMSG_AI_REACTION",
    "CMSG_SET_SELECTION",
    "CMSG_SET_TARGET_OBSOLETE",
    "CMSG_ATTACKSWING",
    "CMSG_ATTACKSTOP",
    "SMSG_ATTACKSTART",
    "SMSG_ATTACKSTOP",
    "SMSG_ATTACKSWING_NOTINRANGE",
    "SMSG_ATTACKSWING_BADFACING",
    "SMSG_ATTACKSWING_NOTSTANDING",
    "SMSG_ATTACKSWING_DEADTARGET",
    "SMSG_ATTACKSWING_CANT_ATTACK",
    "SMSG_ATTACKERSTATEUPDATE",
    "SMSG_CANCEL_COMBAT",
    "SMSG_SPELLHEALLOG",
    "SMSG_SPELLENERGIZELOG",
    "SMSG_BINDPOINTUPDATE",
    "SMSG_PLAYERBOUND",
    "SMSG_CLIENT_CONTROL_UPDATE",
    "CMSG_REPOP_REQUEST",
    "SMSG_RESURRECT_REQUEST",
    "CMSG_RESURRECT_RESPONSE",
    "CMSG_LOOT",
    "CMSG_LOOT_MONEY",
    "CMSG_LOOT_RELEASE",
    "SMSG_LOOT_RESPONSE",
    "SMSG_LOOT_RELEASE_RESPONSE",
    "SMSG_LOOT_REMOVED",
    "SMSG_LOOT_MONEY_NOTIFY",
    "SMSG_LOOT_CLEAR_MONEY",
    "SMSG_ITEM_PUSH_RESULT",
    "SMSG_DUEL_REQUESTED",
    "SMSG_DUEL_OUTOFBOUNDS",
    "SMSG_DUEL_INBOUNDS",
    "SMSG_DUEL_COMPLETE",
    "SMSG_DUEL_WINNER",
    "CMSG_DUEL_ACCEPTED",
    "CMSG_DUEL_CANCELLED",
    "SMSG_MOUNTRESULT",
    "CMSG_MOUNTSPECIAL_ANIM",
    "SMSG_MOUNTSPECIAL_ANIM",
    "SMSG_PET_TAME_FAILURE",
    "CMSG_PET_SET_ACTION",
    "CMSG_PET_ACTION",
    "CMSG_PET_ABANDON",
    "CMSG_PET_RENAME",
    "SMSG_PET_NAME_INVALID",
    "SMSG_PET_SPELLS",
    "SMSG_PET_MODE",
    "CMSG_GOSSIP_HELLO",
    "CMSG_GOSSIP_SELECT_OPTION",
    "SMSG_GOSSIP_MESSAGE",
    "SMSG_GOSSIP_COMPLETE",
    "CMSG_NPC_TEXT_QUERY",
    "SMSG_NPC_TEXT_UPDATE",
    "CMSG_QUESTGIVER_STATUS_QUERY",
    "SMSG_QUESTGIVER_STATUS",
    "CMSG_QUESTGIVER_HELLO",
    "SMSG_QUESTGIVER_QUEST_LIST",
    "CMSG_QUESTGIVER_QUERY_QUEST",
    "CMSG_QUESTGIVER_QUEST_AUTOLAUNCH",
    "SMSG_QUESTGIVER_QUEST_DETAILS",
    "CMSG_QUESTGIVER_ACCEPT_QUEST",
    "CMSG_QUESTGIVER_COMPLETE_QUEST",
    "SMSG_QUESTGIVER_REQUEST_ITEMS",
    "CMSG_QUESTGIVER_REQUEST_REWARD",
    "SMSG_QUESTGIVER_OFFER_REWARD",
    "CMSG_QUESTGIVER_CHOOSE_REWARD",
    "SMSG_QUESTGIVER_QUEST_INVALID",
    "CMSG_QUESTGIVER_CANCEL",
    "SMSG_QUESTGIVER_QUEST_COMPLETE",
    "SMSG_QUESTGIVER_QUEST_FAILED",
    "CMSG_QUESTLOG_SWAP_QUEST",
    "CMSG_QUESTLOG_REMOVE_QUEST",
    "SMSG_QUESTLOG_FULL",
    "SMSG_QUESTUPDATE_FAILED",
    "SMSG_QUESTUPDATE_FAILEDTIMER",
    "SMSG_QUESTUPDATE_COMPLETE",
    "SMSG_QUESTUPDATE_ADD_KILL",
    "SMSG_QUESTUPDATE_ADD_ITEM",
    "CMSG_QUEST_CONFIRM_ACCEPT",
    "SMSG_QUEST_CONFIRM_ACCEPT",
    "CMSG_PUSHQUESTTOPARTY",
    "CMSG_LIST_INVENTORY",
    "SMSG_LIST_INVENTORY",
    "CMSG_SELL_ITEM",
    "SMSG_SELL_ITEM",
    "CMSG_BUY_ITEM",
    "CMSG_BUY_ITEM_IN_SLOT",
    "SMSG_BUY_ITEM",
    "SMSG_BUY_FAILED",
    "SMSG_SHOWTAXINODES",
    "CMSG_TAXINODE_STATUS_QUERY",
    "SMSG_TAXINODE_STATUS",
    "CMSG_TAXIQUERYAVAILABLENODES",
    "CMSG_ACTIVATETAXI",
    "SMSG_ACTIVATETAXIREPLY",
    "SMSG_NEW_TAXI_PATH",
    "CMSG_TRAINER_LIST",
    "SMSG_TRAINER_LIST",
    "CMSG_TRAINER_BUY_SPELL",
    "SMSG_TRAINER_BUY_SUCCEEDED",
    "SMSG_TRAINER_BUY_FAILED",
    "CMSG_BINDER_ACTIVATE",
    "CMSG_BANKER_ACTIVATE",
    "SMSG_SHOW_BANK",
    "CMSG_BUY_BANK_SLOT",
    "SMSG_BUY_BANK_SLOT_RESULT",
    "CMSG_PETITION_SHOWLIST",
    "SMSG_PETITION_SHOWLIST",
    "CMSG_PETITION_BUY",
    "CMSG_PETITION_SHOW_SIGNATURES",
    "SMSG_PETITION_SHOW_SIGNATURES",
    "CMSG_PETITION_SIGN",
    "SMSG_PETITION_SIGN_RESULTS",
    "MSG_PETITION_DECLINE",
    "CMSG_OFFER_PETITION",
    "CMSG_TURN_IN_PETITION",
    "SMSG_TURN_IN_PETITION_RESULTS",
    "CMSG_PETITION_QUERY",
    "SMSG_PETITION_QUERY_RESPONSE",
    "SMSG_FISH_NOT_HOOKED",
    "SMSG_FISH_ESCAPED",
    "CMSG_BUG",
    "SMSG_NOTIFICATION",
    "CMSG_PLAYED_TIME",
    "SMSG_PLAYED_TIME",
    "CMSG_QUERY_TIME",
    "SMSG_QUERY_TIME_RESPONSE",
    "SMSG_LOG_XPGAIN",
    "CMSG_RECLAIM_CORPSE",
    "CMSG_WRAP_ITEM",
    "SMSG_LEVELUP_INFO",
    "MSG_MINIMAP_PING_Client",
    "MSG_MINIMAP_PING_Server",
    "SMSG_ENCHANTMENTLOG",
    "SMSG_START_MIRROR_TIMER",
    "SMSG_PAUSE_MIRROR_TIMER",
    "SMSG_STOP_MIRROR_TIMER",
    "CMSG_PING",
    "SMSG_PONG",
    "SMSG_CLEAR_COOLDOWN",
    "SMSG_GAMEOBJECT_PAGETEXT",
    "CMSG_SETSHEATHED",
    "SMSG_SPELL_DELAYED",
    "SMSG_ITEM_TIME_UPDATE",
    "SMSG_ITEM_ENCHANT_TIME_UPDATE",
    "SMSG_AUTH_CHALLENGE",
    "CMSG_AUTH_SESSION",
    "SMSG_AUTH_RESPONSE",
    "CMSG_PET_CAST_SPELL",
    "MSG_SAVE_GUILD_EMBLEM_Client",
    "MSG_SAVE_GUILD_EMBLEM_Server",
    "MSG_TABARDVENDOR_ACTIVATE",
    "SMSG_PLAY_SPELL_VISUAL",
    "CMSG_ZONEUPDATE",
    "SMSG_PARTYKILLLOG",
    "SMSG_COMPRESSED_UPDATE_OBJECT",
    "SMSG_PLAY_SPELL_IMPACT",
    "SMSG_EXPLORATION_EXPERIENCE",
    "MSG_RANDOM_ROLL_Client",
    "MSG_RANDOM_ROLL_Server",
    "SMSG_ENVIRONMENTAL_DAMAGE_LOG",
    "MSG_LOOKING_FOR_GROUP_Client",
    "MSG_LOOKING_FOR_GROUP_Server",
    "CMSG_SET_LOOKING_FOR_GROUP",
    "CMSG_UNLEARN_SKILL",
    "SMSG_REMOVED_SPELL",
    "CMSG_GMTICKET_CREATE",
    "SMSG_GMTICKET_CREATE",
    "CMSG_GMTICKET_UPDATETEXT",
    "SMSG_GMTICKET_UPDATETEXT",
    "SMSG_ACCOUNT_DATA_TIMES",
    "CMSG_REQUEST_ACCOUNT_DATA",
    "CMSG_UPDATE_ACCOUNT_DATA",
    "SMSG_UPDATE_ACCOUNT_DATA",
    "CMSG_GMTICKET_GETTICKET",
    "SMSG_GMTICKET_GETTICKET",
    "CMSG_UNLEARN_TALENTS",
    "SMSG_GAMEOBJECT_SPAWN_ANIM",
    "SMSG_GAMEOBJECT_DESPAWN_ANIM",
    "MSG_CORPSE_QUERY_Client",
    "MSG_CORPSE_QUERY_Server",
    "CMSG_GMTICKET_DELETETICKET",
    "SMSG_GMTICKET_DELETETICKET",
    "SMSG_CHAT_WRONG_FACTION",
    "CMSG_GMTICKET_SYSTEMSTATUS",
    "SMSG_GMTICKET_SYSTEMSTATUS",
    "CMSG_SPIRIT_HEALER_ACTIVATE",
    "SMSG_SET_REST_START",
    "SMSG_SPIRIT_HEALER_CONFIRM",
    "SMSG_GOSSIP_POI",
    "CMSG_CHAT_IGNORED",
    "CMSG_GUILD_RANK",
    "CMSG_GUILD_ADD_RANK",
    "CMSG_GUILD_DEL_RANK",
    "CMSG_GUILD_SET_PUBLIC_NOTE",
    "CMSG_GUILD_SET_OFFICER_NOTE",
    "SMSG_LOGIN_VERIFY_WORLD",
    "CMSG_SEND_MAIL",
    "SMSG_SEND_MAIL_RESULT",
    "CMSG_GET_MAIL_LIST",
    "SMSG_MAIL_LIST_RESULT",
    "CMSG_BATTLEFIELD_LIST",
    "SMSG_BATTLEFIELD_LIST",
    "CMSG_ITEM_TEXT_QUERY",
    "SMSG_ITEM_TEXT_QUERY_RESPONSE",
    "CMSG_MAIL_TAKE_MONEY",
    "CMSG_MAIL_TAKE_ITEM",
    "CMSG_MAIL_MARK_AS_READ",
    "CMSG_MAIL_RETURN_TO_SENDER",
    "CMSG_MAIL_DELETE",
    "CMSG_MAIL_CREATE_TEXT_ITEM",
    "SMSG_SPELLLOGMISS",
    "SMSG_SPELLLOGEXECUTE",
    "SMSG_PERIODICAURALOG",
    "SMSG_SPELLDAMAGESHIELD",
    "SMSG_SPELLNONMELEEDAMAGELOG",
    "CMSG_LEARN_TALENT",
    "SMSG_RESURRECT_FAILED",
    "CMSG_TOGGLE_PVP",
    "SMSG_ZONE_UNDER_ATTACK",
    "MSG_AUCTION_HELLO_Client",
    "MSG_AUCTION_HELLO_Server",
    "CMSG_AUCTION_SELL_ITEM",
    "CMSG_AUCTION_REMOVE_ITEM",
    "CMSG_AUCTION_LIST_ITEMS",
    "CMSG_AUCTION_LIST_OWNER_ITEMS",
    "CMSG_AUCTION_PLACE_BID",
    "SMSG_AUCTION_COMMAND_RESULT",
    "SMSG_AUCTION_LIST_RESULT",
    "SMSG_AUCTION_OWNER_LIST_RESULT",
    "SMSG_AUCTION_BIDDER_NOTIFICATION",
    "SMSG_AUCTION_OWNER_NOTIFICATION",
    "SMSG_PROCRESIST",
    "SMSG_DISPEL_FAILED",
    "SMSG_SPELLORDAMAGE_IMMUNE",
    "CMSG_AUCTION_LIST_BIDDER_ITEMS",
    "SMSG_AUCTION_BIDDER_LIST_RESULT",
    "SMSG_SET_FLAT_SPELL_MODIFIER",
    "SMSG_SET_PCT_SPELL_MODIFIER",
    "CMSG_SET_AMMO",
    "SMSG_CORPSE_RECLAIM_DELAY",
    "CMSG_SET_ACTIVE_MOVER",
    "CMSG_PET_CANCEL_AURA",
    "CMSG_CANCEL_AUTO_REPEAT_SPELL",
    "MSG_LIST_STABLED_PETS_Client",
    "MSG_LIST_STABLED_PETS_Server",
    "CMSG_STABLE_PET",
    "CMSG_UNSTABLE_PET",
    "CMSG_BUY_STABLE_SLOT",
    "SMSG_STABLE_RESULT",
    "CMSG_STABLE_SWAP_PET",
    "MSG_QUEST_PUSH_RESULT",
    "SMSG_PLAY_MUSIC",
    "SMSG_PLAY_OBJECT_SOUND",
    "CMSG_REQUEST_PET_INFO",
    "CMSG_FAR_SIGHT",
    "SMSG_SPELLDISPELLOG",
    "CMSG_GROUP_CHANGE_SUB_GROUP",
    "CMSG_REQUEST_PARTY_MEMBER_STATS",
    "CMSG_GROUP_SWAP_SUB_GROUP",
    "CMSG_AUTOSTORE_BANK_ITEM",
    "CMSG_AUTOBANK_ITEM",
    "MSG_QUERY_NEXT_MAIL_TIME_Client",
    "MSG_QUERY_NEXT_MAIL_TIME_Server",
    "SMSG_RECEIVED_MAIL",
    "SMSG_RAID_GROUP_ONLY",
    "SMSG_PVP_CREDIT",
    "SMSG_AUCTION_REMOVED_NOTIFICATION",
    "CMSG_GROUP_RAID_CONVERT",
    "CMSG_GROUP_ASSISTANT_LEADER",
    "CMSG_BUYBACK_ITEM",
    "SMSG_SERVER_MESSAGE",
    "SMSG_MEETINGSTONE_SETQUEUE",
    "CMSG_MEETINGSTONE_INFO",
    "CMSG_GMTICKETSYSTEM_TOGGLE",
    "CMSG_CANCEL_GROWTH_AURA",
    "SMSG_CANCEL_AUTO_REPEAT",
    "SMSG_STANDSTATE_UPDATE",
    "SMSG_LOOT_ALL_PASSED",
    "SMSG_LOOT_ROLL_WON",
    "CMSG_LOOT_ROLL",
    "SMSG_LOOT_START_ROLL",
    "SMSG_LOOT_ROLL",
    "CMSG_LOOT_MASTER_GIVE",
    "SMSG_LOOT_MASTER_LIST",
    "SMSG_SET_FORCED_REACTIONS",
    "SMSG_SPELL_FAILED_OTHER",
    "CMSG_REPAIR_ITEM",
    "SMSG_CHAT_PLAYER_NOT_FOUND",
    "MSG_TALENT_WIPE_CONFIRM_Client",
    "MSG_TALENT_WIPE_CONFIRM_Server",
    "SMSG_SUMMON_REQUEST",
    "CMSG_SUMMON_RESPONSE",
    "SMSG_MONSTER_MOVE_TRANSPORT",
    "SMSG_PET_BROKEN",
    "MSG_MOVE_FEATHER_FALL_Server",
    "MSG_MOVE_WATER_WALK",
    "CMSG_SELF_RES",
    "SMSG_FEIGN_DEATH_RESISTED",
    "SMSG_DUEL_COUNTDOWN",
    "SMSG_AREA_TRIGGER_MESSAGE",
    "CMSG_TOGGLE_HELM",
    "CMSG_TOGGLE_CLOAK",
    "SMSG_PLAYER_SKINNED",
    "SMSG_DURABILITY_DAMAGE_DEATH",
    "CMSG_SET_ACTIONBAR_TOGGLES",
    "MSG_PETITION_RENAME",
    "SMSG_INIT_WORLD_STATES",
    "SMSG_UPDATE_WORLD_STATE",
    "CMSG_ITEM_NAME_QUERY",
    "SMSG_ITEM_NAME_QUERY_RESPONSE",
    "SMSG_PET_ACTION_FEEDBACK",
    "CMSG_CHAR_RENAME",
    "SMSG_CHAR_RENAME",
    "CMSG_MOVE_SPLINE_DONE",
    "CMSG_MOVE_FALL_RESET",
    "SMSG_INSTANCE_SAVE_CREATED",
    "SMSG_RAID_INSTANCE_INFO",
    "CMSG_REQUEST_RAID_INFO",
    "CMSG_MOVE_TIME_SKIPPED",
    "CMSG_MOVE_FEATHER_FALL_ACK",
    "CMSG_MOVE_WATER_WALK_ACK",
    "CMSG_MOVE_NOT_ACTIVE_MOVER",
    "SMSG_PLAY_SOUND",
    "CMSG_BATTLEFIELD_STATUS",
    "SMSG_BATTLEFIELD_STATUS",
    "CMSG_BATTLEFIELD_PORT",
    "MSG_INSPECT_HONOR_STATS_Client",
    "MSG_INSPECT_HONOR_STATS_Server",
    "CMSG_BATTLEMASTER_HELLO",
    "SMSG_FORCE_WALK_SPEED_CHANGE",
    "CMSG_FORCE_WALK_SPEED_CHANGE_ACK",
    "SMSG_FORCE_SWIM_BACK_SPEED_CHANGE",
    "CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK",
    "SMSG_FORCE_TURN_RATE_CHANGE",
    "CMSG_FORCE_TURN_RATE_CHANGE_ACK",
    "MSG_PVP_LOG_DATA_Client",
    "CMSG_LEAVE_BATTLEFIELD",
    "CMSG_AREA_SPIRIT_HEALER_QUERY",
    "CMSG_AREA_SPIRIT_HEALER_QUEUE",
    "SMSG_AREA_SPIRIT_HEALER_TIME",
    "SMSG_WARDEN_DATA",
    "CMSG_WARDEN_DATA",
    "SMSG_GROUP_JOINED_BATTLEGROUND",
    "MSG_BATTLEGROUND_PLAYER_POSITIONS_Client",
    "MSG_BATTLEGROUND_PLAYER_POSITIONS_Server",
    "CMSG_PET_STOP_ATTACK",
    "SMSG_BINDER_CONFIRM",
    "SMSG_BATTLEGROUND_PLAYER_JOINED",
    "SMSG_BATTLEGROUND_PLAYER_LEFT",
    "CMSG_BATTLEMASTER_JOIN",
    "SMSG_ADDON_INFO",
    "CMSG_PET_UNLEARN",
    "SMSG_PET_UNLEARN_CONFIRM",
    "SMSG_PARTY_MEMBER_STATS_FULL",
    "CMSG_PET_SPELL_AUTOCAST",
    "SMSG_WEATHER",
    "SMSG_RAID_INSTANCE_MESSAGE",
    "CMSG_GUILD_INFO_TEXT",
    "SMSG_CHAT_RESTRICTED",
    "SMSG_SPLINE_SET_RUN_SPEED",
    "SMSG_SPLINE_SET_RUN_BACK_SPEED",
    "SMSG_SPLINE_SET_SWIM_SPEED",
    "SMSG_SPLINE_SET_WALK_SPEED",
    "SMSG_SPLINE_SET_SWIM_BACK_SPEED",
    "SMSG_SPLINE_SET_TURN_RATE",
    "SMSG_SPLINE_MOVE_UNROOT",
    "SMSG_SPLINE_MOVE_FEATHER_FALL",
    "SMSG_SPLINE_MOVE_NORMAL_FALL",
    "SMSG_SPLINE_MOVE_SET_HOVER",
    "SMSG_SPLINE_MOVE_UNSET_HOVER",
    "SMSG_SPLINE_MOVE_WATER_WALK",
    "SMSG_SPLINE_MOVE_LAND_WALK",
    "SMSG_SPLINE_MOVE_START_SWIM",
    "SMSG_SPLINE_MOVE_STOP_SWIM",
    "SMSG_SPLINE_MOVE_SET_RUN_MODE",
    "SMSG_SPLINE_MOVE_SET_WALK_MODE",
    "CMSG_ACTIVATETAXIEXPRESS",
    "CMSG_SET_FACTION_INACTIVE",
    "CMSG_SET_WATCHED_FACTION",
    "MSG_MOVE_TIME_SKIPPED_Server",
    "SMSG_SPLINE_MOVE_ROOT",
    "SMSG_INVALIDATE_PLAYER",
    "CMSG_RESET_INSTANCES",
    "SMSG_INSTANCE_RESET",
    "SMSG_INSTANCE_RESET_FAILED",
    "SMSG_UPDATE_LAST_INSTANCE",
    "MSG_RAID_TARGET_UPDATE_Client",
    "MSG_RAID_TARGET_UPDATE_Server",
    "MSG_RAID_READY_CHECK_Client",
    "MSG_RAID_READY_CHECK_Server",
    "SMSG_PET_ACTION_SOUND",
    "SMSG_PET_DISMISS_SOUND",
    "SMSG_GM_TICKET_STATUS_UPDATE",
    "MSG_SET_DUNGEON_DIFFICULTY_Client",
    "MSG_SET_DUNGEON_DIFFICULTY_Server",
    "CMSG_GMSURVEY_SUBMIT",
    "SMSG_UPDATE_INSTANCE_OWNERSHIP",
    "SMSG_CHAT_PLAYER_AMBIGUOUS",
    "SMSG_SPELLINSTAKILLLOG",
    "SMSG_SPELL_UPDATE_CHAIN_TARGETS",
    "SMSG_SPELLSTEALLOG",
    "SMSG_DEFENSE_MESSAGE",
    "SMSG_INSTANCE_DIFFICULTY",
    "SMSG_MOTD",
    "SMSG_MOVE_SET_FLIGHT",
    "SMSG_MOVE_UNSET_FLIGHT",
    "SMSG_MOVE_SET_CAN_FLY",
    "SMSG_MOVE_UNSET_CAN_FLY",
    "CMSG_MOVE_SET_CAN_FLY_ACK",
    "CMSG_MOVE_SET_FLY",
    "CMSG_SOCKET_GEMS",
    "SMSG_ARENA_TEAM_COMMAND_RESULT",
    "SMSG_ARENA_TEAM_QUERY_RESPONSE",
    "CMSG_ARENA_TEAM_ROSTER",
    "SMSG_ARENA_TEAM_ROSTER",
    "CMSG_ARENA_TEAM_INVITE",
    "SMSG_ARENA_TEAM_INVITE",
    "CMSG_ARENA_TEAM_ACCEPT",
    "CMSG_ARENA_TEAM_DECLINE",
    "CMSG_ARENA_TEAM_LEAVE",
    "CMSG_ARENA_TEAM_REMOVE",
    "CMSG_ARENA_TEAM_DISBAND",
    "CMSG_ARENA_TEAM_LEADER",
    "SMSG_ARENA_TEAM_EVENT",
    "CMSG_BATTLEMASTER_JOIN_ARENA",
    "MSG_MOVE_START_ASCEND_Client",
    "MSG_MOVE_START_ASCEND_Server",
    "MSG_MOVE_STOP_ASCEND_Client",
    "MSG_MOVE_STOP_ASCEND_Server",
    "SMSG_ARENA_TEAM_STATS",
    "CMSG_LFG_SET_AUTOJOIN",
    "CMSG_LFG_CLEAR_AUTOJOIN",
    "CMSG_LFM_SET_AUTOFILL",
    "CMSG_LFM_CLEAR_AUTOFILL",
    "CMSG_CLEAR_LOOKING_FOR_GROUP",
    "CMSG_CLEAR_LOOKING_FOR_MORE",
    "CMSG_SET_LOOKING_FOR_MORE",
    "CMSG_SET_LFG_COMMENT",
    "SMSG_LFG_LEADER_IS_LFM",
    "SMSG_LFG_UPDATE",
    "SMSG_LFG_UPDATE_LFM",
    "SMSG_LFG_UPDATE_LFG",
    "SMSG_LFG_UPDATE_QUEUED",
    "SMSG_TITLE_EARNED",
    "CMSG_SET_TITLE",
    "CMSG_CANCEL_MOUNT_AURA",
    "SMSG_ARENA_ERROR",
    "MSG_INSPECT_ARENA_TEAMS_Client",
    "MSG_INSPECT_ARENA_TEAMS_Server",
    "SMSG_DEATH_RELEASE_LOC",
    "CMSG_CANCEL_TEMP_ENCHANTMENT",
    "SMSG_FORCED_DEATH_UPDATE",
    "MSG_MOVE_SET_FLIGHT_SPEED_Server",
    "MSG_MOVE_SET_FLIGHT_BACK_SPEED",
    "SMSG_FORCE_FLIGHT_SPEED_CHANGE",
    "CMSG_FORCE_FLIGHT_SPEED_CHANGE_ACK",
    "SMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE",
    "CMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE_ACK",
    "SMSG_SPLINE_SET_FLIGHT_SPEED",
    "SMSG_SPLINE_SET_FLIGHT_BACK_SPEED",
    "SMSG_FLIGHT_SPLINE_SYNC",
    "CMSG_SET_TAXI_BENCHMARK_MODE",
    "SMSG_REALM_SPLIT",
    "CMSG_REALM_SPLIT",
    "CMSG_MOVE_CHNG_TRANSPORT",
    "MSG_PARTY_ASSIGNMENT_Client",
    "SMSG_TIME_SYNC_REQ",
    "CMSG_TIME_SYNC_RESP",
    "SMSG_RESET_FAILED_NOTIFY",
    "SMSG_LFG_DISABLED",
    "SMSG_UPDATE_COMBO_POINTS",
    "SMSG_SET_EXTRA_AURA_INFO",
    "SMSG_SET_EXTRA_AURA_INFO_NEED_UPDATE",
    "SMSG_CLEAR_EXTRA_AURA_INFO",
    "MSG_MOVE_START_DESCEND_Client",
    "MSG_MOVE_START_DESCEND_Server",
    "SMSG_DISMOUNT",
    "MSG_MOVE_UPDATE_CAN_FLY_Server",
    "MSG_RAID_READY_CHECK_CONFIRM_Client",
    "MSG_RAID_READY_CHECK_CONFIRM_Server",
    "CMSG_VOICE_SESSION_ENABLE",
    "SMSG_GM_MESSAGECHAT",
    "CMSG_COMMENTATOR_ENABLE",
    "SMSG_CLEAR_TARGET",
    "SMSG_CROSSED_INEBRIATION_THRESHOLD",
    "SMSG_KICK_REASON",
    "MSG_RAID_READY_CHECK_FINISHED_Client",
    "CMSG_COMPLAIN",
    "SMSG_COMPLAIN_RESULT",
    "SMSG_FEATURE_SYSTEM_STATUS",
    "CMSG_CHANNEL_DISPLAY_LIST",
    "CMSG_SET_ACTIVE_VOICE_CHANNEL",
    "CMSG_GET_CHANNEL_MEMBER_COUNT",
    "SMSG_CHANNEL_MEMBER_COUNT",
    "CMSG_CHANNEL_VOICE_ON",
    "CMSG_REPORT_PVP_AFK",
    "CMSG_GUILD_BANKER_ACTIVATE",
    "CMSG_GUILD_BANK_QUERY_TAB",
    "SMSG_GUILD_BANK_LIST",
    "CMSG_GUILD_BANK_SWAP_ITEMS",
    "CMSG_GUILD_BANK_BUY_TAB",
    "CMSG_GUILD_BANK_UPDATE_TAB",
    "CMSG_GUILD_BANK_DEPOSIT_MONEY",
    "CMSG_GUILD_BANK_WITHDRAW_MONEY",
    "MSG_GUILD_BANK_LOG_QUERY_Client",
    "MSG_GUILD_BANK_LOG_QUERY_Server",
    "CMSG_SET_CHANNEL_WATCH",
    "SMSG_USERLIST_ADD",
    "SMSG_USERLIST_REMOVE",
    "SMSG_USERLIST_UPDATE",
    "CMSG_CLEAR_CHANNEL_WATCH",
    "SMSG_INSPECT_TALENT",
    "CMSG_SPELLCLICK",
    "SMSG_LOOT_LIST",
    "MSG_GUILD_PERMISSIONS_Client",
    "MSG_GUILD_PERMISSIONS_Server",
    "MSG_GUILD_BANK_MONEY_WITHDRAWN_Client",
    "MSG_GUILD_BANK_MONEY_WITHDRAWN_Server",
    "MSG_GUILD_EVENT_LOG_QUERY_Client",
    "MSG_GUILD_EVENT_LOG_QUERY_Server",
    "CMSG_GET_MIRRORIMAGE_DATA",
    "SMSG_MIRRORIMAGE_DATA",
    "CMSG_KEEP_ALIVE",
    "CMSG_OPT_OUT_OF_LOOT",
    "MSG_QUERY_GUILD_BANK_TEXT_Client",
    "MSG_QUERY_GUILD_BANK_TEXT_Server",
    "CMSG_SET_GUILD_BANK_TEXT",
    "CMSG_GRANT_LEVEL",
    "SMSG_OVERRIDE_LIGHT",
    "SMSG_TOTEM_CREATED",
    "CMSG_TOTEM_DESTROYED",
    "CMSG_QUESTGIVER_STATUS_MULTIPLE_QUERY",
    "SMSG_QUESTGIVER_STATUS_MULTIPLE",
    "CMSG_SET_PLAYER_DECLINED_NAMES",
    "SMSG_SET_PLAYER_DECLINED_NAMES_RESULT",
    "SMSG_SEND_UNLEARN_SPELLS",
    "SMSG_PROPOSE_LEVEL_GRANT",
    "CMSG_ACCEPT_LEVEL_GRANT",
    "SMSG_REFER_A_FRIEND_FAILURE",
    "SMSG_SPLINE_MOVE_SET_FLYING",
    "SMSG_SPLINE_MOVE_UNSET_FLYING",
]


@dataclasses.dataclass
class NamedGuid:
    guid: int
    name: typing.Optional[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Aura:
        guid = await read_int(reader, 4)

        if guid != 0:
            name = await read_cstring(reader)

        return Aura(
            guid=guid,
            name=name,
        )

    def write(self, _fmt, _data):
        if self.guid != 0:
            _fmt += f"Q{len(self.name)}sB"
            _data.extend([self.guid, self.name, 0])
        else:
            _fmt += 'Q'
            _data.append(self.guid)

        return _fmt, _data

    def size(self) -> int:
        if guid != 0:
            return len(self.name) + 8
        else:
            return 8



@dataclasses.dataclass
class VariableItemRandomProperty:
    first: int
    second: typing.Optional[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        first = await read_int(reader, 4)

        second = None
        if first != 0:
            second = await read_int(reader, 4)

        return VariableItemRandomProperty(first=first, second=second)

    def write(self, fmt, data):
        fmt += 'I'
        data.append(first)

        if second is not None:
            fmt += 'I'
            data.append(second)

        return fmt, data

    def size(self):
        if second is not None:
            return 8
        else:
            return 4


@dataclasses.dataclass
class AddonArray:
    data: list[Addon]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        raise Exception('read for AddonArray is unimplemented. Create an issue on Github if this is relevant for you.')

    def write(self, fmt, data):
        for d in self.data:
            fmt, data = d.write(fmt, data)

        return fmt, data

    def size(self):
        size = 0
        for d in self.data:
            size += d.size()

        return size


@dataclasses.dataclass
class AchievementDoneArray:
    data: list[AchievementDone]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        data = []
        achievement = await read_int(reader, 4)

        while achievement != -1:
            time = await read_int(reader, 4)
            data.append(AchievementDone(achievement=achievement, time=time))

            achievement = await read_int(reader, 4)

        return AchievementDoneArray(data=data)

    def write(self, fmt, data):
        for d in self.data:
            fmt, data = d.write(fmt, data)

        fmt += "i"
        data.append(-1)

        return fmt, data

    def size(self):
        size = 4
        for d in self.data:
            size += d.size()
        return size


@dataclasses.dataclass
class AchievementInProgressArray:
    data: list[AchievementInProgress]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        data = []
        achievement = await read_int(reader, 4)

        while achievement != -1:
            counter = await read_packed_guid(reader)

            player = await read_packed_guid(reader)

            timed_criteria_failed = await read_bool(reader, 4)

            progress_date = await read_int(reader, 4)

            time_since_progress = await read_int(reader, 4)

            time_since_progress2 = await read_int(reader, 4)

            data.append(AchievementInProgress(
                                              achievement=achievement,
                                              counter=counter,
                                              player=player,
                                              timed_criteria_failed=timed_criteria_failed,
                                              progress_date=progress_date,
                                              time_since_progress=time_since_progress,
                                              time_since_progress2=time_since_progress2,
                                              ))

            achievement = await read_int(reader, 4)

        return AchievementInProgressArray(data=data)

    def write(self, fmt, data):
        for d in self.data:
            fmt, data = d.write(fmt, data)

        fmt += "i"
        data.append(-1)

        return fmt, data

    def size(self):
        size = 4
        for d in self.data:
            size += d.size()
        return size


@dataclasses.dataclass
class UpdateMask:
    fields: dict[int, int]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        amount_of_blocks = await read_int(reader, 1)

        blocks = []
        for _ in range(0, amount_of_blocks):
            blocks.append(await read_int(reader, 4))

        fields = {}
        for block_index, block in enumerate(blocks):
            for bit in range(0, 32):
                if block & 1 << bit:
                    value = await read_int(reader, 4)
                    key = block_index * 32 + bit
                    fields[key] = value

        return UpdateMask(fields=fields)

    def write(self, fmt, data):
        highest_key = max(self.fields, default=0)
        amount_of_blocks = highest_key // 32
        if highest_key % 32 != 0:
            amount_of_blocks += 1

        fmt += 'B'
        data.append(amount_of_blocks)

        blocks = [0] * amount_of_blocks

        for key in self.fields:
            block = key // 32
            index = key % 32
            blocks[block] |= 1 << index

        fmt += f'{len(blocks)}I'
        data.extend(blocks)

        for key in sorted(self.fields):
            if isinstance(self.fields[key], float):
                fmt += 'f'
            else:
                fmt += 'I'
            data.append(self.fields[key])

        return fmt, data

    def size(self):
        highest_key = max(self.fields, default=0)
        amount_of_blocks = highest_key // 32

        extra = highest_key % 32
        if extra != 0:
            extra = 1
        else:
            extra = 0

        return 1 + (extra + amount_of_blocks + len(self.fields)) * 4


class UpdateMaskValue(enum.IntEnum):
    OBJECT_GUID = 0
    OBJECT_TYPE = 2
    OBJECT_ENTRY = 3
    OBJECT_SCALE_X = 4
    ITEM_OWNER = 6
    ITEM_CONTAINED = 8
    ITEM_CREATOR = 10
    ITEM_GIFTCREATOR = 12
    ITEM_STACK_COUNT = 14
    ITEM_DURATION = 15
    ITEM_SPELL_CHARGES = 16
    ITEM_FLAGS = 21
    ITEM_ENCHANTMENT_1_1 = 22
    ITEM_PROPERTY_SEED = 55
    ITEM_RANDOM_PROPERTIES_ID = 56
    ITEM_ITEM_TEXT_ID = 57
    ITEM_DURABILITY = 58
    ITEM_MAXDURABILITY = 59
    CONTAINER_NUM_SLOTS = 60
    CONTAINER_SLOT_1 = 62
    UNIT_CHARM = 6
    UNIT_SUMMON = 8
    UNIT_CHARMEDBY = 10
    UNIT_SUMMONEDBY = 12
    UNIT_CREATEDBY = 14
    UNIT_TARGET = 16
    UNIT_PERSUADED = 18
    UNIT_CHANNEL_OBJECT = 20
    UNIT_HEALTH = 22
    UNIT_POWER1 = 23
    UNIT_POWER2 = 24
    UNIT_POWER3 = 25
    UNIT_POWER4 = 26
    UNIT_POWER5 = 27
    UNIT_MAXHEALTH = 28
    UNIT_MAXPOWER1 = 29
    UNIT_MAXPOWER2 = 30
    UNIT_MAXPOWER3 = 31
    UNIT_MAXPOWER4 = 32
    UNIT_MAXPOWER5 = 33
    UNIT_LEVEL = 34
    UNIT_FACTIONTEMPLATE = 35
    UNIT_BYTES_0 = 36
    UNIT_VIRTUAL_ITEM_SLOT_DISPLAY = 37
    UNIT_VIRTUAL_ITEM_INFO = 40
    UNIT_FLAGS = 46
    UNIT_FLAGS_2 = 47
    UNIT_AURA = 48
    UNIT_AURAFLAGS = 104
    UNIT_AURALEVELS = 118
    UNIT_AURAAPPLICATIONS = 132
    UNIT_AURASTATE = 146
    UNIT_BASEATTACKTIME = 147
    UNIT_RANGEDATTACKTIME = 149
    UNIT_BOUNDINGRADIUS = 150
    UNIT_COMBATREACH = 151
    UNIT_DISPLAYID = 152
    UNIT_NATIVEDISPLAYID = 153
    UNIT_MOUNTDISPLAYID = 154
    UNIT_MINDAMAGE = 155
    UNIT_MAXDAMAGE = 156
    UNIT_MINOFFHANDDAMAGE = 157
    UNIT_MAXOFFHANDDAMAGE = 158
    UNIT_BYTES_1 = 159
    UNIT_PETNUMBER = 160
    UNIT_PET_NAME_TIMESTAMP = 161
    UNIT_PETEXPERIENCE = 162
    UNIT_PETNEXTLEVELEXP = 163
    UNIT_DYNAMIC_FLAGS = 164
    UNIT_CHANNEL_SPELL = 165
    UNIT_MOD_CAST_SPEED = 166
    UNIT_CREATED_BY_SPELL = 167
    UNIT_NPC_FLAGS = 168
    UNIT_NPC_EMOTESTATE = 169
    UNIT_TRAINING_POINTS = 170
    UNIT_STRENGTH = 171
    UNIT_AGILITY = 172
    UNIT_STAMINA = 173
    UNIT_INTELLECT = 174
    UNIT_SPIRIT = 175
    PLAYER_POSSTAT0 = 176
    UNIT_POSSTAT1 = 177
    UNIT_POSSTAT2 = 178
    UNIT_POSSTAT3 = 179
    PLAYER_POSSTAT4 = 180
    PLAYER_NEGSTAT0 = 181
    UNIT_NEGSTAT1 = 182
    UNIT_NEGSTAT2 = 183
    UNIT_NEGSTAT3 = 184
    PLAYER_NEGSTAT4 = 185
    UNIT_RESISTANCES = 186
    PLAYER_RESISTANCEBUFFMODSPOSITIVE = 193
    PLAYER_RESISTANCEBUFFMODSNEGATIVE = 200
    UNIT_BASE_MANA = 207
    UNIT_BASE_HEALTH = 208
    UNIT_BYTES_2 = 209
    UNIT_ATTACK_POWER = 210
    UNIT_ATTACK_POWER_MODS = 211
    UNIT_ATTACK_POWER_MULTIPLIER = 212
    UNIT_RANGED_ATTACK_POWER = 213
    UNIT_RANGED_ATTACK_POWER_MODS = 214
    UNIT_RANGED_ATTACK_POWER_MULTIPLIER = 215
    UNIT_MINRANGEDDAMAGE = 216
    UNIT_MAXRANGEDDAMAGE = 217
    UNIT_POWER_COST_MODIFIER = 218
    UNIT_POWER_COST_MULTIPLIER = 225
    UNIT_MAXHEALTHMODIFIER = 232
    PLAYER_DUEL_ARBITER = 234
    PLAYER_FLAGS = 236
    PLAYER_GUILDID = 237
    PLAYER_GUILDRANK = 238
    PLAYER_FIELD_BYTES = 239
    PLAYER_BYTES_2 = 240
    PLAYER_BYTES_3 = 241
    PLAYER_DUEL_TEAM = 242
    PLAYER_GUILD_TIMESTAMP = 243
    PLAYER_QUEST_LOG_1_1 = 244
    PLAYER_QUEST_LOG_1_2 = 245
    PLAYER_QUEST_LOG_1_3 = 246
    PLAYER_QUEST_LOG_1_4 = 247
    PLAYER_QUEST_LOG_2_1 = 248
    PLAYER_QUEST_LOG_2_2 = 249
    PLAYER_QUEST_LOG_2_3 = 250
    PLAYER_QUEST_LOG_2_4 = 251
    PLAYER_QUEST_LOG_3_1 = 252
    PLAYER_QUEST_LOG_3_2 = 253
    PLAYER_QUEST_LOG_3_3 = 254
    PLAYER_QUEST_LOG_3_4 = 255
    PLAYER_QUEST_LOG_4_1 = 256
    PLAYER_QUEST_LOG_4_2 = 257
    PLAYER_QUEST_LOG_4_3 = 258
    PLAYER_QUEST_LOG_4_4 = 259
    PLAYER_QUEST_LOG_5_1 = 260
    PLAYER_QUEST_LOG_5_2 = 261
    PLAYER_QUEST_LOG_5_3 = 262
    PLAYER_QUEST_LOG_5_4 = 263
    PLAYER_QUEST_LOG_6_1 = 264
    PLAYER_QUEST_LOG_6_2 = 265
    PLAYER_QUEST_LOG_6_3 = 266
    PLAYER_QUEST_LOG_6_4 = 267
    PLAYER_QUEST_LOG_7_1 = 268
    PLAYER_QUEST_LOG_7_2 = 269
    PLAYER_QUEST_LOG_7_3 = 270
    PLAYER_QUEST_LOG_7_4 = 271
    PLAYER_QUEST_LOG_8_1 = 272
    PLAYER_QUEST_LOG_8_2 = 273
    PLAYER_QUEST_LOG_8_3 = 274
    PLAYER_QUEST_LOG_8_4 = 275
    PLAYER_QUEST_LOG_9_1 = 276
    PLAYER_QUEST_LOG_9_2 = 277
    PLAYER_QUEST_LOG_9_3 = 278
    PLAYER_QUEST_LOG_9_4 = 279
    PLAYER_QUEST_LOG_10_1 = 280
    PLAYER_QUEST_LOG_10_2 = 281
    PLAYER_QUEST_LOG_10_3 = 282
    PLAYER_QUEST_LOG_10_4 = 283
    PLAYER_QUEST_LOG_11_1 = 284
    PLAYER_QUEST_LOG_11_2 = 285
    PLAYER_QUEST_LOG_11_3 = 286
    PLAYER_QUEST_LOG_11_4 = 287
    PLAYER_QUEST_LOG_12_1 = 288
    PLAYER_QUEST_LOG_12_2 = 289
    PLAYER_QUEST_LOG_12_3 = 290
    PLAYER_QUEST_LOG_12_4 = 291
    PLAYER_QUEST_LOG_13_1 = 292
    PLAYER_QUEST_LOG_13_2 = 293
    PLAYER_QUEST_LOG_13_3 = 294
    PLAYER_QUEST_LOG_13_4 = 295
    PLAYER_QUEST_LOG_14_1 = 296
    PLAYER_QUEST_LOG_14_2 = 297
    PLAYER_QUEST_LOG_14_3 = 298
    PLAYER_QUEST_LOG_14_4 = 299
    PLAYER_QUEST_LOG_15_1 = 300
    PLAYER_QUEST_LOG_15_2 = 301
    PLAYER_QUEST_LOG_15_3 = 302
    PLAYER_QUEST_LOG_15_4 = 303
    PLAYER_QUEST_LOG_16_1 = 304
    PLAYER_QUEST_LOG_16_2 = 305
    PLAYER_QUEST_LOG_16_3 = 306
    PLAYER_QUEST_LOG_16_4 = 307
    PLAYER_QUEST_LOG_17_1 = 308
    PLAYER_QUEST_LOG_17_2 = 309
    PLAYER_QUEST_LOG_17_3 = 310
    PLAYER_QUEST_LOG_17_4 = 311
    PLAYER_QUEST_LOG_18_1 = 312
    PLAYER_QUEST_LOG_18_2 = 313
    PLAYER_QUEST_LOG_18_3 = 314
    PLAYER_QUEST_LOG_18_4 = 315
    PLAYER_QUEST_LOG_19_1 = 316
    PLAYER_QUEST_LOG_19_2 = 317
    PLAYER_QUEST_LOG_19_3 = 318
    PLAYER_QUEST_LOG_19_4 = 319
    PLAYER_QUEST_LOG_20_1 = 320
    PLAYER_QUEST_LOG_20_2 = 321
    PLAYER_QUEST_LOG_20_3 = 322
    PLAYER_QUEST_LOG_20_4 = 323
    PLAYER_QUEST_LOG_21_1 = 324
    PLAYER_QUEST_LOG_21_2 = 325
    PLAYER_QUEST_LOG_21_3 = 326
    PLAYER_QUEST_LOG_21_4 = 327
    PLAYER_QUEST_LOG_22_1 = 328
    PLAYER_QUEST_LOG_22_2 = 329
    PLAYER_QUEST_LOG_22_3 = 330
    PLAYER_QUEST_LOG_22_4 = 331
    PLAYER_QUEST_LOG_23_1 = 332
    PLAYER_QUEST_LOG_23_2 = 333
    PLAYER_QUEST_LOG_23_3 = 334
    PLAYER_QUEST_LOG_23_4 = 335
    PLAYER_QUEST_LOG_24_1 = 336
    PLAYER_QUEST_LOG_24_2 = 337
    PLAYER_QUEST_LOG_24_3 = 338
    PLAYER_QUEST_LOG_24_4 = 339
    PLAYER_QUEST_LOG_25_1 = 340
    PLAYER_QUEST_LOG_25_2 = 341
    PLAYER_QUEST_LOG_25_3 = 342
    PLAYER_QUEST_LOG_25_4 = 343
    PLAYER_VISIBLE_ITEM_0_CREATOR_LOW = 344
    PLAYER_VISIBLE_ITEM_0_CREATOR_HIGH = 345
    PLAYER_VISIBLE_ITEM_0_ITEM = 346
    PLAYER_VISIBLE_ITEM_0_ENCHANTS_0 = 347
    PLAYER_VISIBLE_ITEM_0_RANDOM_PROPERTY_ID = 353
    PLAYER_VISIBLE_ITEM_0_ITEM_SUFFIX_FACTOR = 354
    PLAYER_VISIBLE_ITEM_1_CREATOR_LOW = 356
    PLAYER_VISIBLE_ITEM_1_CREATOR_HIGH = 357
    PLAYER_VISIBLE_ITEM_1_ITEM = 358
    PLAYER_VISIBLE_ITEM_1_ENCHANTS_0 = 359
    PLAYER_VISIBLE_ITEM_1_RANDOM_PROPERTY_ID = 365
    PLAYER_VISIBLE_ITEM_1_ITEM_SUFFIX_FACTOR = 366
    PLAYER_VISIBLE_ITEM_2_CREATOR_LOW = 368
    PLAYER_VISIBLE_ITEM_2_CREATOR_HIGH = 369
    PLAYER_VISIBLE_ITEM_2_ITEM = 370
    PLAYER_VISIBLE_ITEM_2_ENCHANTS_0 = 371
    PLAYER_VISIBLE_ITEM_2_RANDOM_PROPERTY_ID = 377
    PLAYER_VISIBLE_ITEM_2_ITEM_SUFFIX_FACTOR = 378
    PLAYER_VISIBLE_ITEM_3_CREATOR_LOW = 380
    PLAYER_VISIBLE_ITEM_3_CREATOR_HIGH = 381
    PLAYER_VISIBLE_ITEM_3_ITEM = 382
    PLAYER_VISIBLE_ITEM_3_ENCHANTS_0 = 383
    PLAYER_VISIBLE_ITEM_3_RANDOM_PROPERTY_ID = 389
    PLAYER_VISIBLE_ITEM_3_ITEM_SUFFIX_FACTOR = 390
    PLAYER_VISIBLE_ITEM_4_CREATOR_LOW = 392
    PLAYER_VISIBLE_ITEM_4_CREATOR_HIGH = 393
    PLAYER_VISIBLE_ITEM_4_ITEM = 394
    PLAYER_VISIBLE_ITEM_4_ENCHANTS_0 = 395
    PLAYER_VISIBLE_ITEM_4_RANDOM_PROPERTY_ID = 401
    PLAYER_VISIBLE_ITEM_4_ITEM_SUFFIX_FACTOR = 402
    PLAYER_VISIBLE_ITEM_5_CREATOR_LOW = 404
    PLAYER_VISIBLE_ITEM_5_CREATOR_HIGH = 405
    PLAYER_VISIBLE_ITEM_5_ITEM = 406
    PLAYER_VISIBLE_ITEM_5_ENCHANTS_0 = 407
    PLAYER_VISIBLE_ITEM_5_RANDOM_PROPERTY_ID = 413
    PLAYER_VISIBLE_ITEM_5_ITEM_SUFFIX_FACTOR = 414
    PLAYER_VISIBLE_ITEM_6_CREATOR_LOW = 416
    PLAYER_VISIBLE_ITEM_6_CREATOR_HIGH = 417
    PLAYER_VISIBLE_ITEM_6_ITEM = 418
    PLAYER_VISIBLE_ITEM_6_ENCHANTS_0 = 419
    PLAYER_VISIBLE_ITEM_6_RANDOM_PROPERTY_ID = 425
    PLAYER_VISIBLE_ITEM_6_ITEM_SUFFIX_FACTOR = 426
    PLAYER_VISIBLE_ITEM_7_CREATOR_LOW = 428
    PLAYER_VISIBLE_ITEM_7_CREATOR_HIGH = 429
    PLAYER_VISIBLE_ITEM_7_ITEM = 430
    PLAYER_VISIBLE_ITEM_7_ENCHANTS_0 = 431
    PLAYER_VISIBLE_ITEM_7_RANDOM_PROPERTY_ID = 437
    PLAYER_VISIBLE_ITEM_7_ITEM_SUFFIX_FACTOR = 438
    PLAYER_VISIBLE_ITEM_8_CREATOR_LOW = 440
    PLAYER_VISIBLE_ITEM_8_CREATOR_HIGH = 441
    PLAYER_VISIBLE_ITEM_8_ITEM = 442
    PLAYER_VISIBLE_ITEM_8_ENCHANTS_0 = 443
    PLAYER_VISIBLE_ITEM_8_RANDOM_PROPERTY_ID = 449
    PLAYER_VISIBLE_ITEM_8_ITEM_SUFFIX_FACTOR = 450
    PLAYER_VISIBLE_ITEM_9_CREATOR_LOW = 452
    PLAYER_VISIBLE_ITEM_9_CREATOR_HIGH = 453
    PLAYER_VISIBLE_ITEM_9_ITEM = 454
    PLAYER_VISIBLE_ITEM_9_ENCHANTS_0 = 455
    PLAYER_VISIBLE_ITEM_9_RANDOM_PROPERTY_ID = 461
    PLAYER_VISIBLE_ITEM_9_ITEM_SUFFIX_FACTOR = 462
    PLAYER_VISIBLE_ITEM_10_CREATOR_LOW = 464
    PLAYER_VISIBLE_ITEM_10_CREATOR_HIGH = 465
    PLAYER_VISIBLE_ITEM_10_ITEM = 466
    PLAYER_VISIBLE_ITEM_10_ENCHANTS_0 = 467
    PLAYER_VISIBLE_ITEM_10_RANDOM_PROPERTY_ID = 473
    PLAYER_VISIBLE_ITEM_10_ITEM_SUFFIX_FACTOR = 474
    PLAYER_VISIBLE_ITEM_11_CREATOR_LOW = 476
    PLAYER_VISIBLE_ITEM_11_CREATOR_HIGH = 477
    PLAYER_VISIBLE_ITEM_11_ITEM = 478
    PLAYER_VISIBLE_ITEM_11_ENCHANTS_0 = 479
    PLAYER_VISIBLE_ITEM_11_RANDOM_PROPERTY_ID = 485
    PLAYER_VISIBLE_ITEM_11_ITEM_SUFFIX_FACTOR = 486
    PLAYER_VISIBLE_ITEM_12_CREATOR_LOW = 488
    PLAYER_VISIBLE_ITEM_12_CREATOR_HIGH = 489
    PLAYER_VISIBLE_ITEM_12_ITEM = 490
    PLAYER_VISIBLE_ITEM_12_ENCHANTS_0 = 491
    PLAYER_VISIBLE_ITEM_12_RANDOM_PROPERTY_ID = 497
    PLAYER_VISIBLE_ITEM_12_ITEM_SUFFIX_FACTOR = 498
    PLAYER_VISIBLE_ITEM_13_CREATOR_LOW = 500
    PLAYER_VISIBLE_ITEM_13_CREATOR_HIGH = 501
    PLAYER_VISIBLE_ITEM_13_ITEM = 502
    PLAYER_VISIBLE_ITEM_13_ENCHANTS_0 = 503
    PLAYER_VISIBLE_ITEM_13_RANDOM_PROPERTY_ID = 509
    PLAYER_VISIBLE_ITEM_13_ITEM_SUFFIX_FACTOR = 510
    PLAYER_VISIBLE_ITEM_14_CREATOR_LOW = 512
    PLAYER_VISIBLE_ITEM_14_CREATOR_HIGH = 513
    PLAYER_VISIBLE_ITEM_14_ITEM = 514
    PLAYER_VISIBLE_ITEM_14_ENCHANTS_0 = 515
    PLAYER_VISIBLE_ITEM_14_RANDOM_PROPERTY_ID = 521
    PLAYER_VISIBLE_ITEM_14_ITEM_SUFFIX_FACTOR = 522
    PLAYER_VISIBLE_ITEM_15_CREATOR_LOW = 524
    PLAYER_VISIBLE_ITEM_15_CREATOR_HIGH = 525
    PLAYER_VISIBLE_ITEM_15_ITEM = 526
    PLAYER_VISIBLE_ITEM_15_ENCHANTS_0 = 527
    PLAYER_VISIBLE_ITEM_15_RANDOM_PROPERTY_ID = 533
    PLAYER_VISIBLE_ITEM_15_ITEM_SUFFIX_FACTOR = 534
    PLAYER_VISIBLE_ITEM_16_CREATOR_LOW = 536
    PLAYER_VISIBLE_ITEM_16_CREATOR_HIGH = 537
    PLAYER_VISIBLE_ITEM_16_ITEM = 538
    PLAYER_VISIBLE_ITEM_16_ENCHANTS_0 = 539
    PLAYER_VISIBLE_ITEM_16_RANDOM_PROPERTY_ID = 545
    PLAYER_VISIBLE_ITEM_16_ITEM_SUFFIX_FACTOR = 546
    PLAYER_VISIBLE_ITEM_17_CREATOR_LOW = 548
    PLAYER_VISIBLE_ITEM_17_CREATOR_HIGH = 549
    PLAYER_VISIBLE_ITEM_17_ITEM = 550
    PLAYER_VISIBLE_ITEM_17_ENCHANTS_0 = 551
    PLAYER_VISIBLE_ITEM_17_RANDOM_PROPERTY_ID = 557
    PLAYER_VISIBLE_ITEM_17_ITEM_SUFFIX_FACTOR = 558
    PLAYER_VISIBLE_ITEM_18_CREATOR_LOW = 560
    PLAYER_VISIBLE_ITEM_18_CREATOR_HIGH = 561
    PLAYER_VISIBLE_ITEM_18_ITEM = 562
    PLAYER_VISIBLE_ITEM_18_ENCHANTS_0 = 563
    PLAYER_VISIBLE_ITEM_18_RANDOM_PROPERTY_ID = 569
    PLAYER_VISIBLE_ITEM_18_ITEM_SUFFIX_FACTOR = 570
    PLAYER_CHOSEN_TITLE = 648
    PLAYER_FIELD_INV_HEAD = 486
    PLAYER_FIELD_INV_NECK = 488
    PLAYER_FIELD_INV_SHOULDERS = 490
    PLAYER_FIELD_INV_SHIRT = 492
    PLAYER_FIELD_INV_CHEST = 494
    PLAYER_FIELD_INV_WAIST = 496
    PLAYER_FIELD_INV_LEGS = 498
    PLAYER_FIELD_INV_BOOTS = 500
    PLAYER_FIELD_INV_WRIST = 502
    PLAYER_FIELD_INV_HANDS = 504
    PLAYER_FIELD_INV_RING1 = 506
    PLAYER_FIELD_INV_RING2 = 508
    PLAYER_FIELD_INV_TRINKET1 = 510
    PLAYER_FIELD_INV_TRINKET2 = 512
    PLAYER_FIELD_INV_BACK = 514
    PLAYER_FIELD_INV_MAIN_HAND = 516
    PLAYER_FIELD_INV_OFF_HAND = 518
    PLAYER_FIELD_INV_RANGED_OR_RELIC = 520
    PLAYER_FIELD_INV_TABARD = 522
    PLAYER_FIELD_INV_BAG1 = 524
    PLAYER_FIELD_INV_BAG2 = 526
    PLAYER_FIELD_INV_BAG3 = 528
    PLAYER_FIELD_INV_BAG4 = 530
    PLAYER_FIELD_INV_INVENTORY_0 = 532
    PLAYER_FIELD_INV_INVENTORY_1 = 534
    PLAYER_FIELD_INV_INVENTORY_2 = 536
    PLAYER_FIELD_INV_INVENTORY_3 = 538
    PLAYER_FIELD_INV_INVENTORY_4 = 540
    PLAYER_FIELD_INV_INVENTORY_5 = 542
    PLAYER_FIELD_INV_INVENTORY_6 = 544
    PLAYER_FIELD_INV_INVENTORY_7 = 546
    PLAYER_FIELD_INV_INVENTORY_8 = 548
    PLAYER_FIELD_INV_INVENTORY_9 = 550
    PLAYER_FIELD_INV_INVENTORY_10 = 552
    PLAYER_FIELD_INV_INVENTORY_11 = 554
    PLAYER_FIELD_INV_INVENTORY_12 = 556
    PLAYER_FIELD_INV_INVENTORY_13 = 558
    PLAYER_FIELD_INV_INVENTORY_14 = 560
    PLAYER_FIELD_INV_INVENTORY_15 = 562
    PLAYER_FIELD_INV_BANK_1 = 564
    PLAYER_FIELD_INV_BANK_2 = 566
    PLAYER_FIELD_INV_BANK_3 = 568
    PLAYER_FIELD_INV_BANK_4 = 570
    PLAYER_FIELD_INV_BANK_5 = 572
    PLAYER_FIELD_INV_BANK_6 = 574
    PLAYER_FIELD_INV_BANK_7 = 576
    PLAYER_FIELD_INV_BANK_8 = 578
    PLAYER_FIELD_INV_BANK_9 = 580
    PLAYER_FIELD_INV_BANK_10 = 582
    PLAYER_FIELD_INV_BANK_11 = 584
    PLAYER_FIELD_INV_BANK_12 = 586
    PLAYER_FIELD_INV_BANK_13 = 588
    PLAYER_FIELD_INV_BANK_14 = 590
    PLAYER_FIELD_INV_BANK_15 = 592
    PLAYER_FIELD_INV_BANK_16 = 594
    PLAYER_FIELD_INV_BANK_17 = 596
    PLAYER_FIELD_INV_BANK_18 = 598
    PLAYER_FIELD_INV_BANK_19 = 600
    PLAYER_FIELD_INV_BANK_20 = 602
    PLAYER_FIELD_INV_BANK_21 = 604
    PLAYER_FIELD_INV_BANK_22 = 606
    PLAYER_FIELD_INV_BANK_23 = 608
    PLAYER_FIELD_INV_BANK_24 = 610
    PLAYER_FIELD_INV_BANK_25 = 612
    PLAYER_FIELD_INV_BANK_26 = 614
    PLAYER_FIELD_INV_BANK_27 = 616
    PLAYER_FIELD_INV_BANK_28 = 618
    PLAYER_FIELD_INV_BANK_BAG_SLOT_1 = 620
    PLAYER_FIELD_INV_BANK_BAG_SLOT_2 = 622
    PLAYER_FIELD_INV_BANK_BAG_SLOT_3 = 624
    PLAYER_FIELD_INV_BANK_BAG_SLOT_4 = 626
    PLAYER_FIELD_INV_BANK_BAG_SLOT_5 = 628
    PLAYER_FIELD_INV_BANK_BAG_SLOT_6 = 630
    PLAYER_FIELD_INV_BANK_BAG_SLOT_7 = 632
    PLAYER_FIELD_INV_VENDOR_BUYBACK_1 = 634
    PLAYER_FIELD_INV_VENDOR_BUYBACK_2 = 636
    PLAYER_FIELD_INV_VENDOR_BUYBACK_3 = 638
    PLAYER_FIELD_INV_VENDOR_BUYBACK_4 = 640
    PLAYER_FIELD_INV_VENDOR_BUYBACK_5 = 642
    PLAYER_FIELD_INV_VENDOR_BUYBACK_6 = 644
    PLAYER_FIELD_INV_VENDOR_BUYBACK_7 = 646
    PLAYER_FIELD_INV_VENDOR_BUYBACK_8 = 648
    PLAYER_FIELD_INV_VENDOR_BUYBACK_9 = 650
    PLAYER_FIELD_INV_VENDOR_BUYBACK_10 = 652
    PLAYER_FIELD_INV_VENDOR_BUYBACK_11 = 654
    PLAYER_FIELD_INV_VENDOR_BUYBACK_12 = 656
    PLAYER_FIELD_INV_KEYRING_1 = 658
    PLAYER_FIELD_INV_KEYRING_2 = 660
    PLAYER_FIELD_INV_KEYRING_3 = 662
    PLAYER_FIELD_INV_KEYRING_4 = 664
    PLAYER_FIELD_INV_KEYRING_5 = 666
    PLAYER_FIELD_INV_KEYRING_6 = 668
    PLAYER_FIELD_INV_KEYRING_7 = 670
    PLAYER_FIELD_INV_KEYRING_8 = 672
    PLAYER_FIELD_INV_KEYRING_9 = 674
    PLAYER_FIELD_INV_KEYRING_10 = 676
    PLAYER_FIELD_INV_KEYRING_11 = 678
    PLAYER_FIELD_INV_KEYRING_12 = 680
    PLAYER_FIELD_INV_KEYRING_13 = 682
    PLAYER_FIELD_INV_KEYRING_14 = 684
    PLAYER_FIELD_INV_KEYRING_15 = 686
    PLAYER_FIELD_INV_KEYRING_16 = 688
    PLAYER_FIELD_INV_KEYRING_17 = 690
    PLAYER_FIELD_INV_KEYRING_18 = 692
    PLAYER_FIELD_INV_KEYRING_19 = 694
    PLAYER_FIELD_INV_KEYRING_20 = 696
    PLAYER_FIELD_INV_KEYRING_21 = 698
    PLAYER_FIELD_INV_KEYRING_22 = 700
    PLAYER_FIELD_INV_KEYRING_23 = 702
    PLAYER_FIELD_INV_KEYRING_24 = 704
    PLAYER_FIELD_INV_KEYRING_25 = 706
    PLAYER_FIELD_INV_KEYRING_26 = 708
    PLAYER_FIELD_INV_KEYRING_27 = 710
    PLAYER_FIELD_INV_KEYRING_28 = 712
    PLAYER_FIELD_INV_KEYRING_29 = 714
    PLAYER_FIELD_INV_KEYRING_30 = 716
    PLAYER_FIELD_INV_KEYRING_31 = 718
    PLAYER_FIELD_INV_KEYRING_32 = 720
    PLAYER_FIELD_INV_VANITY_PET_1 = 722
    PLAYER_FIELD_INV_VANITY_PET_2 = 724
    PLAYER_FIELD_INV_VANITY_PET_3 = 726
    PLAYER_FIELD_INV_VANITY_PET_4 = 728
    PLAYER_FIELD_INV_VANITY_PET_5 = 730
    PLAYER_FIELD_INV_VANITY_PET_6 = 732
    PLAYER_FIELD_INV_VANITY_PET_7 = 734
    PLAYER_FIELD_INV_VANITY_PET_8 = 736
    PLAYER_FIELD_INV_VANITY_PET_9 = 738
    PLAYER_FIELD_INV_VANITY_PET_10 = 740
    PLAYER_FIELD_INV_VANITY_PET_11 = 742
    PLAYER_FIELD_INV_VANITY_PET_12 = 744
    PLAYER_FIELD_INV_VANITY_PET_13 = 746
    PLAYER_FIELD_INV_VANITY_PET_14 = 748
    PLAYER_FIELD_INV_VANITY_PET_15 = 750
    PLAYER_FIELD_INV_VANITY_PET_16 = 752
    PLAYER_FIELD_INV_VANITY_PET_17 = 754
    PLAYER_FIELD_INV_VANITY_PET_18 = 756
    PLAYER_FARSIGHT = 922
    PLAYER_KNOWN_TITLES = 924
    PLAYER_XP = 926
    PLAYER_NEXT_LEVEL_XP = 927
    PLAYER_SKILL_INFO_0_SKILL_0 = 928
    PLAYER_SKILL_INFO_0_SKILL_STEP_1 = 928
    PLAYER_SKILL_INFO_0_MINIMUM_0 = 929
    PLAYER_SKILL_INFO_0_MAXIMUM_1 = 929
    PLAYER_SKILL_INFO_0_PERMANENT_BONUS_0 = 930
    PLAYER_SKILL_INFO_0_TEMPORARY_BONUS_1 = 930
    PLAYER_SKILL_INFO_1_SKILL_0 = 931
    PLAYER_SKILL_INFO_1_SKILL_STEP_1 = 931
    PLAYER_SKILL_INFO_1_MINIMUM_0 = 932
    PLAYER_SKILL_INFO_1_MAXIMUM_1 = 932
    PLAYER_SKILL_INFO_1_PERMANENT_BONUS_0 = 933
    PLAYER_SKILL_INFO_1_TEMPORARY_BONUS_1 = 933
    PLAYER_SKILL_INFO_2_SKILL_0 = 934
    PLAYER_SKILL_INFO_2_SKILL_STEP_1 = 934
    PLAYER_SKILL_INFO_2_MINIMUM_0 = 935
    PLAYER_SKILL_INFO_2_MAXIMUM_1 = 935
    PLAYER_SKILL_INFO_2_PERMANENT_BONUS_0 = 936
    PLAYER_SKILL_INFO_2_TEMPORARY_BONUS_1 = 936
    PLAYER_SKILL_INFO_3_SKILL_0 = 937
    PLAYER_SKILL_INFO_3_SKILL_STEP_1 = 937
    PLAYER_SKILL_INFO_3_MINIMUM_0 = 938
    PLAYER_SKILL_INFO_3_MAXIMUM_1 = 938
    PLAYER_SKILL_INFO_3_PERMANENT_BONUS_0 = 939
    PLAYER_SKILL_INFO_3_TEMPORARY_BONUS_1 = 939
    PLAYER_SKILL_INFO_4_SKILL_0 = 940
    PLAYER_SKILL_INFO_4_SKILL_STEP_1 = 940
    PLAYER_SKILL_INFO_4_MINIMUM_0 = 941
    PLAYER_SKILL_INFO_4_MAXIMUM_1 = 941
    PLAYER_SKILL_INFO_4_PERMANENT_BONUS_0 = 942
    PLAYER_SKILL_INFO_4_TEMPORARY_BONUS_1 = 942
    PLAYER_SKILL_INFO_5_SKILL_0 = 943
    PLAYER_SKILL_INFO_5_SKILL_STEP_1 = 943
    PLAYER_SKILL_INFO_5_MINIMUM_0 = 944
    PLAYER_SKILL_INFO_5_MAXIMUM_1 = 944
    PLAYER_SKILL_INFO_5_PERMANENT_BONUS_0 = 945
    PLAYER_SKILL_INFO_5_TEMPORARY_BONUS_1 = 945
    PLAYER_SKILL_INFO_6_SKILL_0 = 946
    PLAYER_SKILL_INFO_6_SKILL_STEP_1 = 946
    PLAYER_SKILL_INFO_6_MINIMUM_0 = 947
    PLAYER_SKILL_INFO_6_MAXIMUM_1 = 947
    PLAYER_SKILL_INFO_6_PERMANENT_BONUS_0 = 948
    PLAYER_SKILL_INFO_6_TEMPORARY_BONUS_1 = 948
    PLAYER_SKILL_INFO_7_SKILL_0 = 949
    PLAYER_SKILL_INFO_7_SKILL_STEP_1 = 949
    PLAYER_SKILL_INFO_7_MINIMUM_0 = 950
    PLAYER_SKILL_INFO_7_MAXIMUM_1 = 950
    PLAYER_SKILL_INFO_7_PERMANENT_BONUS_0 = 951
    PLAYER_SKILL_INFO_7_TEMPORARY_BONUS_1 = 951
    PLAYER_SKILL_INFO_8_SKILL_0 = 952
    PLAYER_SKILL_INFO_8_SKILL_STEP_1 = 952
    PLAYER_SKILL_INFO_8_MINIMUM_0 = 953
    PLAYER_SKILL_INFO_8_MAXIMUM_1 = 953
    PLAYER_SKILL_INFO_8_PERMANENT_BONUS_0 = 954
    PLAYER_SKILL_INFO_8_TEMPORARY_BONUS_1 = 954
    PLAYER_SKILL_INFO_9_SKILL_0 = 955
    PLAYER_SKILL_INFO_9_SKILL_STEP_1 = 955
    PLAYER_SKILL_INFO_9_MINIMUM_0 = 956
    PLAYER_SKILL_INFO_9_MAXIMUM_1 = 956
    PLAYER_SKILL_INFO_9_PERMANENT_BONUS_0 = 957
    PLAYER_SKILL_INFO_9_TEMPORARY_BONUS_1 = 957
    PLAYER_SKILL_INFO_10_SKILL_0 = 958
    PLAYER_SKILL_INFO_10_SKILL_STEP_1 = 958
    PLAYER_SKILL_INFO_10_MINIMUM_0 = 959
    PLAYER_SKILL_INFO_10_MAXIMUM_1 = 959
    PLAYER_SKILL_INFO_10_PERMANENT_BONUS_0 = 960
    PLAYER_SKILL_INFO_10_TEMPORARY_BONUS_1 = 960
    PLAYER_SKILL_INFO_11_SKILL_0 = 961
    PLAYER_SKILL_INFO_11_SKILL_STEP_1 = 961
    PLAYER_SKILL_INFO_11_MINIMUM_0 = 962
    PLAYER_SKILL_INFO_11_MAXIMUM_1 = 962
    PLAYER_SKILL_INFO_11_PERMANENT_BONUS_0 = 963
    PLAYER_SKILL_INFO_11_TEMPORARY_BONUS_1 = 963
    PLAYER_SKILL_INFO_12_SKILL_0 = 964
    PLAYER_SKILL_INFO_12_SKILL_STEP_1 = 964
    PLAYER_SKILL_INFO_12_MINIMUM_0 = 965
    PLAYER_SKILL_INFO_12_MAXIMUM_1 = 965
    PLAYER_SKILL_INFO_12_PERMANENT_BONUS_0 = 966
    PLAYER_SKILL_INFO_12_TEMPORARY_BONUS_1 = 966
    PLAYER_SKILL_INFO_13_SKILL_0 = 967
    PLAYER_SKILL_INFO_13_SKILL_STEP_1 = 967
    PLAYER_SKILL_INFO_13_MINIMUM_0 = 968
    PLAYER_SKILL_INFO_13_MAXIMUM_1 = 968
    PLAYER_SKILL_INFO_13_PERMANENT_BONUS_0 = 969
    PLAYER_SKILL_INFO_13_TEMPORARY_BONUS_1 = 969
    PLAYER_SKILL_INFO_14_SKILL_0 = 970
    PLAYER_SKILL_INFO_14_SKILL_STEP_1 = 970
    PLAYER_SKILL_INFO_14_MINIMUM_0 = 971
    PLAYER_SKILL_INFO_14_MAXIMUM_1 = 971
    PLAYER_SKILL_INFO_14_PERMANENT_BONUS_0 = 972
    PLAYER_SKILL_INFO_14_TEMPORARY_BONUS_1 = 972
    PLAYER_SKILL_INFO_15_SKILL_0 = 973
    PLAYER_SKILL_INFO_15_SKILL_STEP_1 = 973
    PLAYER_SKILL_INFO_15_MINIMUM_0 = 974
    PLAYER_SKILL_INFO_15_MAXIMUM_1 = 974
    PLAYER_SKILL_INFO_15_PERMANENT_BONUS_0 = 975
    PLAYER_SKILL_INFO_15_TEMPORARY_BONUS_1 = 975
    PLAYER_SKILL_INFO_16_SKILL_0 = 976
    PLAYER_SKILL_INFO_16_SKILL_STEP_1 = 976
    PLAYER_SKILL_INFO_16_MINIMUM_0 = 977
    PLAYER_SKILL_INFO_16_MAXIMUM_1 = 977
    PLAYER_SKILL_INFO_16_PERMANENT_BONUS_0 = 978
    PLAYER_SKILL_INFO_16_TEMPORARY_BONUS_1 = 978
    PLAYER_SKILL_INFO_17_SKILL_0 = 979
    PLAYER_SKILL_INFO_17_SKILL_STEP_1 = 979
    PLAYER_SKILL_INFO_17_MINIMUM_0 = 980
    PLAYER_SKILL_INFO_17_MAXIMUM_1 = 980
    PLAYER_SKILL_INFO_17_PERMANENT_BONUS_0 = 981
    PLAYER_SKILL_INFO_17_TEMPORARY_BONUS_1 = 981
    PLAYER_SKILL_INFO_18_SKILL_0 = 982
    PLAYER_SKILL_INFO_18_SKILL_STEP_1 = 982
    PLAYER_SKILL_INFO_18_MINIMUM_0 = 983
    PLAYER_SKILL_INFO_18_MAXIMUM_1 = 983
    PLAYER_SKILL_INFO_18_PERMANENT_BONUS_0 = 984
    PLAYER_SKILL_INFO_18_TEMPORARY_BONUS_1 = 984
    PLAYER_SKILL_INFO_19_SKILL_0 = 985
    PLAYER_SKILL_INFO_19_SKILL_STEP_1 = 985
    PLAYER_SKILL_INFO_19_MINIMUM_0 = 986
    PLAYER_SKILL_INFO_19_MAXIMUM_1 = 986
    PLAYER_SKILL_INFO_19_PERMANENT_BONUS_0 = 987
    PLAYER_SKILL_INFO_19_TEMPORARY_BONUS_1 = 987
    PLAYER_SKILL_INFO_20_SKILL_0 = 988
    PLAYER_SKILL_INFO_20_SKILL_STEP_1 = 988
    PLAYER_SKILL_INFO_20_MINIMUM_0 = 989
    PLAYER_SKILL_INFO_20_MAXIMUM_1 = 989
    PLAYER_SKILL_INFO_20_PERMANENT_BONUS_0 = 990
    PLAYER_SKILL_INFO_20_TEMPORARY_BONUS_1 = 990
    PLAYER_SKILL_INFO_21_SKILL_0 = 991
    PLAYER_SKILL_INFO_21_SKILL_STEP_1 = 991
    PLAYER_SKILL_INFO_21_MINIMUM_0 = 992
    PLAYER_SKILL_INFO_21_MAXIMUM_1 = 992
    PLAYER_SKILL_INFO_21_PERMANENT_BONUS_0 = 993
    PLAYER_SKILL_INFO_21_TEMPORARY_BONUS_1 = 993
    PLAYER_SKILL_INFO_22_SKILL_0 = 994
    PLAYER_SKILL_INFO_22_SKILL_STEP_1 = 994
    PLAYER_SKILL_INFO_22_MINIMUM_0 = 995
    PLAYER_SKILL_INFO_22_MAXIMUM_1 = 995
    PLAYER_SKILL_INFO_22_PERMANENT_BONUS_0 = 996
    PLAYER_SKILL_INFO_22_TEMPORARY_BONUS_1 = 996
    PLAYER_SKILL_INFO_23_SKILL_0 = 997
    PLAYER_SKILL_INFO_23_SKILL_STEP_1 = 997
    PLAYER_SKILL_INFO_23_MINIMUM_0 = 998
    PLAYER_SKILL_INFO_23_MAXIMUM_1 = 998
    PLAYER_SKILL_INFO_23_PERMANENT_BONUS_0 = 999
    PLAYER_SKILL_INFO_23_TEMPORARY_BONUS_1 = 999
    PLAYER_SKILL_INFO_24_SKILL_0 = 1000
    PLAYER_SKILL_INFO_24_SKILL_STEP_1 = 1000
    PLAYER_SKILL_INFO_24_MINIMUM_0 = 1001
    PLAYER_SKILL_INFO_24_MAXIMUM_1 = 1001
    PLAYER_SKILL_INFO_24_PERMANENT_BONUS_0 = 1002
    PLAYER_SKILL_INFO_24_TEMPORARY_BONUS_1 = 1002
    PLAYER_SKILL_INFO_25_SKILL_0 = 1003
    PLAYER_SKILL_INFO_25_SKILL_STEP_1 = 1003
    PLAYER_SKILL_INFO_25_MINIMUM_0 = 1004
    PLAYER_SKILL_INFO_25_MAXIMUM_1 = 1004
    PLAYER_SKILL_INFO_25_PERMANENT_BONUS_0 = 1005
    PLAYER_SKILL_INFO_25_TEMPORARY_BONUS_1 = 1005
    PLAYER_SKILL_INFO_26_SKILL_0 = 1006
    PLAYER_SKILL_INFO_26_SKILL_STEP_1 = 1006
    PLAYER_SKILL_INFO_26_MINIMUM_0 = 1007
    PLAYER_SKILL_INFO_26_MAXIMUM_1 = 1007
    PLAYER_SKILL_INFO_26_PERMANENT_BONUS_0 = 1008
    PLAYER_SKILL_INFO_26_TEMPORARY_BONUS_1 = 1008
    PLAYER_SKILL_INFO_27_SKILL_0 = 1009
    PLAYER_SKILL_INFO_27_SKILL_STEP_1 = 1009
    PLAYER_SKILL_INFO_27_MINIMUM_0 = 1010
    PLAYER_SKILL_INFO_27_MAXIMUM_1 = 1010
    PLAYER_SKILL_INFO_27_PERMANENT_BONUS_0 = 1011
    PLAYER_SKILL_INFO_27_TEMPORARY_BONUS_1 = 1011
    PLAYER_SKILL_INFO_28_SKILL_0 = 1012
    PLAYER_SKILL_INFO_28_SKILL_STEP_1 = 1012
    PLAYER_SKILL_INFO_28_MINIMUM_0 = 1013
    PLAYER_SKILL_INFO_28_MAXIMUM_1 = 1013
    PLAYER_SKILL_INFO_28_PERMANENT_BONUS_0 = 1014
    PLAYER_SKILL_INFO_28_TEMPORARY_BONUS_1 = 1014
    PLAYER_SKILL_INFO_29_SKILL_0 = 1015
    PLAYER_SKILL_INFO_29_SKILL_STEP_1 = 1015
    PLAYER_SKILL_INFO_29_MINIMUM_0 = 1016
    PLAYER_SKILL_INFO_29_MAXIMUM_1 = 1016
    PLAYER_SKILL_INFO_29_PERMANENT_BONUS_0 = 1017
    PLAYER_SKILL_INFO_29_TEMPORARY_BONUS_1 = 1017
    PLAYER_SKILL_INFO_30_SKILL_0 = 1018
    PLAYER_SKILL_INFO_30_SKILL_STEP_1 = 1018
    PLAYER_SKILL_INFO_30_MINIMUM_0 = 1019
    PLAYER_SKILL_INFO_30_MAXIMUM_1 = 1019
    PLAYER_SKILL_INFO_30_PERMANENT_BONUS_0 = 1020
    PLAYER_SKILL_INFO_30_TEMPORARY_BONUS_1 = 1020
    PLAYER_SKILL_INFO_31_SKILL_0 = 1021
    PLAYER_SKILL_INFO_31_SKILL_STEP_1 = 1021
    PLAYER_SKILL_INFO_31_MINIMUM_0 = 1022
    PLAYER_SKILL_INFO_31_MAXIMUM_1 = 1022
    PLAYER_SKILL_INFO_31_PERMANENT_BONUS_0 = 1023
    PLAYER_SKILL_INFO_31_TEMPORARY_BONUS_1 = 1023
    PLAYER_SKILL_INFO_32_SKILL_0 = 1024
    PLAYER_SKILL_INFO_32_SKILL_STEP_1 = 1024
    PLAYER_SKILL_INFO_32_MINIMUM_0 = 1025
    PLAYER_SKILL_INFO_32_MAXIMUM_1 = 1025
    PLAYER_SKILL_INFO_32_PERMANENT_BONUS_0 = 1026
    PLAYER_SKILL_INFO_32_TEMPORARY_BONUS_1 = 1026
    PLAYER_SKILL_INFO_33_SKILL_0 = 1027
    PLAYER_SKILL_INFO_33_SKILL_STEP_1 = 1027
    PLAYER_SKILL_INFO_33_MINIMUM_0 = 1028
    PLAYER_SKILL_INFO_33_MAXIMUM_1 = 1028
    PLAYER_SKILL_INFO_33_PERMANENT_BONUS_0 = 1029
    PLAYER_SKILL_INFO_33_TEMPORARY_BONUS_1 = 1029
    PLAYER_SKILL_INFO_34_SKILL_0 = 1030
    PLAYER_SKILL_INFO_34_SKILL_STEP_1 = 1030
    PLAYER_SKILL_INFO_34_MINIMUM_0 = 1031
    PLAYER_SKILL_INFO_34_MAXIMUM_1 = 1031
    PLAYER_SKILL_INFO_34_PERMANENT_BONUS_0 = 1032
    PLAYER_SKILL_INFO_34_TEMPORARY_BONUS_1 = 1032
    PLAYER_SKILL_INFO_35_SKILL_0 = 1033
    PLAYER_SKILL_INFO_35_SKILL_STEP_1 = 1033
    PLAYER_SKILL_INFO_35_MINIMUM_0 = 1034
    PLAYER_SKILL_INFO_35_MAXIMUM_1 = 1034
    PLAYER_SKILL_INFO_35_PERMANENT_BONUS_0 = 1035
    PLAYER_SKILL_INFO_35_TEMPORARY_BONUS_1 = 1035
    PLAYER_SKILL_INFO_36_SKILL_0 = 1036
    PLAYER_SKILL_INFO_36_SKILL_STEP_1 = 1036
    PLAYER_SKILL_INFO_36_MINIMUM_0 = 1037
    PLAYER_SKILL_INFO_36_MAXIMUM_1 = 1037
    PLAYER_SKILL_INFO_36_PERMANENT_BONUS_0 = 1038
    PLAYER_SKILL_INFO_36_TEMPORARY_BONUS_1 = 1038
    PLAYER_SKILL_INFO_37_SKILL_0 = 1039
    PLAYER_SKILL_INFO_37_SKILL_STEP_1 = 1039
    PLAYER_SKILL_INFO_37_MINIMUM_0 = 1040
    PLAYER_SKILL_INFO_37_MAXIMUM_1 = 1040
    PLAYER_SKILL_INFO_37_PERMANENT_BONUS_0 = 1041
    PLAYER_SKILL_INFO_37_TEMPORARY_BONUS_1 = 1041
    PLAYER_SKILL_INFO_38_SKILL_0 = 1042
    PLAYER_SKILL_INFO_38_SKILL_STEP_1 = 1042
    PLAYER_SKILL_INFO_38_MINIMUM_0 = 1043
    PLAYER_SKILL_INFO_38_MAXIMUM_1 = 1043
    PLAYER_SKILL_INFO_38_PERMANENT_BONUS_0 = 1044
    PLAYER_SKILL_INFO_38_TEMPORARY_BONUS_1 = 1044
    PLAYER_SKILL_INFO_39_SKILL_0 = 1045
    PLAYER_SKILL_INFO_39_SKILL_STEP_1 = 1045
    PLAYER_SKILL_INFO_39_MINIMUM_0 = 1046
    PLAYER_SKILL_INFO_39_MAXIMUM_1 = 1046
    PLAYER_SKILL_INFO_39_PERMANENT_BONUS_0 = 1047
    PLAYER_SKILL_INFO_39_TEMPORARY_BONUS_1 = 1047
    PLAYER_SKILL_INFO_40_SKILL_0 = 1048
    PLAYER_SKILL_INFO_40_SKILL_STEP_1 = 1048
    PLAYER_SKILL_INFO_40_MINIMUM_0 = 1049
    PLAYER_SKILL_INFO_40_MAXIMUM_1 = 1049
    PLAYER_SKILL_INFO_40_PERMANENT_BONUS_0 = 1050
    PLAYER_SKILL_INFO_40_TEMPORARY_BONUS_1 = 1050
    PLAYER_SKILL_INFO_41_SKILL_0 = 1051
    PLAYER_SKILL_INFO_41_SKILL_STEP_1 = 1051
    PLAYER_SKILL_INFO_41_MINIMUM_0 = 1052
    PLAYER_SKILL_INFO_41_MAXIMUM_1 = 1052
    PLAYER_SKILL_INFO_41_PERMANENT_BONUS_0 = 1053
    PLAYER_SKILL_INFO_41_TEMPORARY_BONUS_1 = 1053
    PLAYER_SKILL_INFO_42_SKILL_0 = 1054
    PLAYER_SKILL_INFO_42_SKILL_STEP_1 = 1054
    PLAYER_SKILL_INFO_42_MINIMUM_0 = 1055
    PLAYER_SKILL_INFO_42_MAXIMUM_1 = 1055
    PLAYER_SKILL_INFO_42_PERMANENT_BONUS_0 = 1056
    PLAYER_SKILL_INFO_42_TEMPORARY_BONUS_1 = 1056
    PLAYER_SKILL_INFO_43_SKILL_0 = 1057
    PLAYER_SKILL_INFO_43_SKILL_STEP_1 = 1057
    PLAYER_SKILL_INFO_43_MINIMUM_0 = 1058
    PLAYER_SKILL_INFO_43_MAXIMUM_1 = 1058
    PLAYER_SKILL_INFO_43_PERMANENT_BONUS_0 = 1059
    PLAYER_SKILL_INFO_43_TEMPORARY_BONUS_1 = 1059
    PLAYER_SKILL_INFO_44_SKILL_0 = 1060
    PLAYER_SKILL_INFO_44_SKILL_STEP_1 = 1060
    PLAYER_SKILL_INFO_44_MINIMUM_0 = 1061
    PLAYER_SKILL_INFO_44_MAXIMUM_1 = 1061
    PLAYER_SKILL_INFO_44_PERMANENT_BONUS_0 = 1062
    PLAYER_SKILL_INFO_44_TEMPORARY_BONUS_1 = 1062
    PLAYER_SKILL_INFO_45_SKILL_0 = 1063
    PLAYER_SKILL_INFO_45_SKILL_STEP_1 = 1063
    PLAYER_SKILL_INFO_45_MINIMUM_0 = 1064
    PLAYER_SKILL_INFO_45_MAXIMUM_1 = 1064
    PLAYER_SKILL_INFO_45_PERMANENT_BONUS_0 = 1065
    PLAYER_SKILL_INFO_45_TEMPORARY_BONUS_1 = 1065
    PLAYER_SKILL_INFO_46_SKILL_0 = 1066
    PLAYER_SKILL_INFO_46_SKILL_STEP_1 = 1066
    PLAYER_SKILL_INFO_46_MINIMUM_0 = 1067
    PLAYER_SKILL_INFO_46_MAXIMUM_1 = 1067
    PLAYER_SKILL_INFO_46_PERMANENT_BONUS_0 = 1068
    PLAYER_SKILL_INFO_46_TEMPORARY_BONUS_1 = 1068
    PLAYER_SKILL_INFO_47_SKILL_0 = 1069
    PLAYER_SKILL_INFO_47_SKILL_STEP_1 = 1069
    PLAYER_SKILL_INFO_47_MINIMUM_0 = 1070
    PLAYER_SKILL_INFO_47_MAXIMUM_1 = 1070
    PLAYER_SKILL_INFO_47_PERMANENT_BONUS_0 = 1071
    PLAYER_SKILL_INFO_47_TEMPORARY_BONUS_1 = 1071
    PLAYER_SKILL_INFO_48_SKILL_0 = 1072
    PLAYER_SKILL_INFO_48_SKILL_STEP_1 = 1072
    PLAYER_SKILL_INFO_48_MINIMUM_0 = 1073
    PLAYER_SKILL_INFO_48_MAXIMUM_1 = 1073
    PLAYER_SKILL_INFO_48_PERMANENT_BONUS_0 = 1074
    PLAYER_SKILL_INFO_48_TEMPORARY_BONUS_1 = 1074
    PLAYER_SKILL_INFO_49_SKILL_0 = 1075
    PLAYER_SKILL_INFO_49_SKILL_STEP_1 = 1075
    PLAYER_SKILL_INFO_49_MINIMUM_0 = 1076
    PLAYER_SKILL_INFO_49_MAXIMUM_1 = 1076
    PLAYER_SKILL_INFO_49_PERMANENT_BONUS_0 = 1077
    PLAYER_SKILL_INFO_49_TEMPORARY_BONUS_1 = 1077
    PLAYER_SKILL_INFO_50_SKILL_0 = 1078
    PLAYER_SKILL_INFO_50_SKILL_STEP_1 = 1078
    PLAYER_SKILL_INFO_50_MINIMUM_0 = 1079
    PLAYER_SKILL_INFO_50_MAXIMUM_1 = 1079
    PLAYER_SKILL_INFO_50_PERMANENT_BONUS_0 = 1080
    PLAYER_SKILL_INFO_50_TEMPORARY_BONUS_1 = 1080
    PLAYER_SKILL_INFO_51_SKILL_0 = 1081
    PLAYER_SKILL_INFO_51_SKILL_STEP_1 = 1081
    PLAYER_SKILL_INFO_51_MINIMUM_0 = 1082
    PLAYER_SKILL_INFO_51_MAXIMUM_1 = 1082
    PLAYER_SKILL_INFO_51_PERMANENT_BONUS_0 = 1083
    PLAYER_SKILL_INFO_51_TEMPORARY_BONUS_1 = 1083
    PLAYER_SKILL_INFO_52_SKILL_0 = 1084
    PLAYER_SKILL_INFO_52_SKILL_STEP_1 = 1084
    PLAYER_SKILL_INFO_52_MINIMUM_0 = 1085
    PLAYER_SKILL_INFO_52_MAXIMUM_1 = 1085
    PLAYER_SKILL_INFO_52_PERMANENT_BONUS_0 = 1086
    PLAYER_SKILL_INFO_52_TEMPORARY_BONUS_1 = 1086
    PLAYER_SKILL_INFO_53_SKILL_0 = 1087
    PLAYER_SKILL_INFO_53_SKILL_STEP_1 = 1087
    PLAYER_SKILL_INFO_53_MINIMUM_0 = 1088
    PLAYER_SKILL_INFO_53_MAXIMUM_1 = 1088
    PLAYER_SKILL_INFO_53_PERMANENT_BONUS_0 = 1089
    PLAYER_SKILL_INFO_53_TEMPORARY_BONUS_1 = 1089
    PLAYER_SKILL_INFO_54_SKILL_0 = 1090
    PLAYER_SKILL_INFO_54_SKILL_STEP_1 = 1090
    PLAYER_SKILL_INFO_54_MINIMUM_0 = 1091
    PLAYER_SKILL_INFO_54_MAXIMUM_1 = 1091
    PLAYER_SKILL_INFO_54_PERMANENT_BONUS_0 = 1092
    PLAYER_SKILL_INFO_54_TEMPORARY_BONUS_1 = 1092
    PLAYER_SKILL_INFO_55_SKILL_0 = 1093
    PLAYER_SKILL_INFO_55_SKILL_STEP_1 = 1093
    PLAYER_SKILL_INFO_55_MINIMUM_0 = 1094
    PLAYER_SKILL_INFO_55_MAXIMUM_1 = 1094
    PLAYER_SKILL_INFO_55_PERMANENT_BONUS_0 = 1095
    PLAYER_SKILL_INFO_55_TEMPORARY_BONUS_1 = 1095
    PLAYER_SKILL_INFO_56_SKILL_0 = 1096
    PLAYER_SKILL_INFO_56_SKILL_STEP_1 = 1096
    PLAYER_SKILL_INFO_56_MINIMUM_0 = 1097
    PLAYER_SKILL_INFO_56_MAXIMUM_1 = 1097
    PLAYER_SKILL_INFO_56_PERMANENT_BONUS_0 = 1098
    PLAYER_SKILL_INFO_56_TEMPORARY_BONUS_1 = 1098
    PLAYER_SKILL_INFO_57_SKILL_0 = 1099
    PLAYER_SKILL_INFO_57_SKILL_STEP_1 = 1099
    PLAYER_SKILL_INFO_57_MINIMUM_0 = 1100
    PLAYER_SKILL_INFO_57_MAXIMUM_1 = 1100
    PLAYER_SKILL_INFO_57_PERMANENT_BONUS_0 = 1101
    PLAYER_SKILL_INFO_57_TEMPORARY_BONUS_1 = 1101
    PLAYER_SKILL_INFO_58_SKILL_0 = 1102
    PLAYER_SKILL_INFO_58_SKILL_STEP_1 = 1102
    PLAYER_SKILL_INFO_58_MINIMUM_0 = 1103
    PLAYER_SKILL_INFO_58_MAXIMUM_1 = 1103
    PLAYER_SKILL_INFO_58_PERMANENT_BONUS_0 = 1104
    PLAYER_SKILL_INFO_58_TEMPORARY_BONUS_1 = 1104
    PLAYER_SKILL_INFO_59_SKILL_0 = 1105
    PLAYER_SKILL_INFO_59_SKILL_STEP_1 = 1105
    PLAYER_SKILL_INFO_59_MINIMUM_0 = 1106
    PLAYER_SKILL_INFO_59_MAXIMUM_1 = 1106
    PLAYER_SKILL_INFO_59_PERMANENT_BONUS_0 = 1107
    PLAYER_SKILL_INFO_59_TEMPORARY_BONUS_1 = 1107
    PLAYER_SKILL_INFO_60_SKILL_0 = 1108
    PLAYER_SKILL_INFO_60_SKILL_STEP_1 = 1108
    PLAYER_SKILL_INFO_60_MINIMUM_0 = 1109
    PLAYER_SKILL_INFO_60_MAXIMUM_1 = 1109
    PLAYER_SKILL_INFO_60_PERMANENT_BONUS_0 = 1110
    PLAYER_SKILL_INFO_60_TEMPORARY_BONUS_1 = 1110
    PLAYER_SKILL_INFO_61_SKILL_0 = 1111
    PLAYER_SKILL_INFO_61_SKILL_STEP_1 = 1111
    PLAYER_SKILL_INFO_61_MINIMUM_0 = 1112
    PLAYER_SKILL_INFO_61_MAXIMUM_1 = 1112
    PLAYER_SKILL_INFO_61_PERMANENT_BONUS_0 = 1113
    PLAYER_SKILL_INFO_61_TEMPORARY_BONUS_1 = 1113
    PLAYER_SKILL_INFO_62_SKILL_0 = 1114
    PLAYER_SKILL_INFO_62_SKILL_STEP_1 = 1114
    PLAYER_SKILL_INFO_62_MINIMUM_0 = 1115
    PLAYER_SKILL_INFO_62_MAXIMUM_1 = 1115
    PLAYER_SKILL_INFO_62_PERMANENT_BONUS_0 = 1116
    PLAYER_SKILL_INFO_62_TEMPORARY_BONUS_1 = 1116
    PLAYER_SKILL_INFO_63_SKILL_0 = 1117
    PLAYER_SKILL_INFO_63_SKILL_STEP_1 = 1117
    PLAYER_SKILL_INFO_63_MINIMUM_0 = 1118
    PLAYER_SKILL_INFO_63_MAXIMUM_1 = 1118
    PLAYER_SKILL_INFO_63_PERMANENT_BONUS_0 = 1119
    PLAYER_SKILL_INFO_63_TEMPORARY_BONUS_1 = 1119
    PLAYER_SKILL_INFO_64_SKILL_0 = 1120
    PLAYER_SKILL_INFO_64_SKILL_STEP_1 = 1120
    PLAYER_SKILL_INFO_64_MINIMUM_0 = 1121
    PLAYER_SKILL_INFO_64_MAXIMUM_1 = 1121
    PLAYER_SKILL_INFO_64_PERMANENT_BONUS_0 = 1122
    PLAYER_SKILL_INFO_64_TEMPORARY_BONUS_1 = 1122
    PLAYER_SKILL_INFO_65_SKILL_0 = 1123
    PLAYER_SKILL_INFO_65_SKILL_STEP_1 = 1123
    PLAYER_SKILL_INFO_65_MINIMUM_0 = 1124
    PLAYER_SKILL_INFO_65_MAXIMUM_1 = 1124
    PLAYER_SKILL_INFO_65_PERMANENT_BONUS_0 = 1125
    PLAYER_SKILL_INFO_65_TEMPORARY_BONUS_1 = 1125
    PLAYER_SKILL_INFO_66_SKILL_0 = 1126
    PLAYER_SKILL_INFO_66_SKILL_STEP_1 = 1126
    PLAYER_SKILL_INFO_66_MINIMUM_0 = 1127
    PLAYER_SKILL_INFO_66_MAXIMUM_1 = 1127
    PLAYER_SKILL_INFO_66_PERMANENT_BONUS_0 = 1128
    PLAYER_SKILL_INFO_66_TEMPORARY_BONUS_1 = 1128
    PLAYER_SKILL_INFO_67_SKILL_0 = 1129
    PLAYER_SKILL_INFO_67_SKILL_STEP_1 = 1129
    PLAYER_SKILL_INFO_67_MINIMUM_0 = 1130
    PLAYER_SKILL_INFO_67_MAXIMUM_1 = 1130
    PLAYER_SKILL_INFO_67_PERMANENT_BONUS_0 = 1131
    PLAYER_SKILL_INFO_67_TEMPORARY_BONUS_1 = 1131
    PLAYER_SKILL_INFO_68_SKILL_0 = 1132
    PLAYER_SKILL_INFO_68_SKILL_STEP_1 = 1132
    PLAYER_SKILL_INFO_68_MINIMUM_0 = 1133
    PLAYER_SKILL_INFO_68_MAXIMUM_1 = 1133
    PLAYER_SKILL_INFO_68_PERMANENT_BONUS_0 = 1134
    PLAYER_SKILL_INFO_68_TEMPORARY_BONUS_1 = 1134
    PLAYER_SKILL_INFO_69_SKILL_0 = 1135
    PLAYER_SKILL_INFO_69_SKILL_STEP_1 = 1135
    PLAYER_SKILL_INFO_69_MINIMUM_0 = 1136
    PLAYER_SKILL_INFO_69_MAXIMUM_1 = 1136
    PLAYER_SKILL_INFO_69_PERMANENT_BONUS_0 = 1137
    PLAYER_SKILL_INFO_69_TEMPORARY_BONUS_1 = 1137
    PLAYER_SKILL_INFO_70_SKILL_0 = 1138
    PLAYER_SKILL_INFO_70_SKILL_STEP_1 = 1138
    PLAYER_SKILL_INFO_70_MINIMUM_0 = 1139
    PLAYER_SKILL_INFO_70_MAXIMUM_1 = 1139
    PLAYER_SKILL_INFO_70_PERMANENT_BONUS_0 = 1140
    PLAYER_SKILL_INFO_70_TEMPORARY_BONUS_1 = 1140
    PLAYER_SKILL_INFO_71_SKILL_0 = 1141
    PLAYER_SKILL_INFO_71_SKILL_STEP_1 = 1141
    PLAYER_SKILL_INFO_71_MINIMUM_0 = 1142
    PLAYER_SKILL_INFO_71_MAXIMUM_1 = 1142
    PLAYER_SKILL_INFO_71_PERMANENT_BONUS_0 = 1143
    PLAYER_SKILL_INFO_71_TEMPORARY_BONUS_1 = 1143
    PLAYER_SKILL_INFO_72_SKILL_0 = 1144
    PLAYER_SKILL_INFO_72_SKILL_STEP_1 = 1144
    PLAYER_SKILL_INFO_72_MINIMUM_0 = 1145
    PLAYER_SKILL_INFO_72_MAXIMUM_1 = 1145
    PLAYER_SKILL_INFO_72_PERMANENT_BONUS_0 = 1146
    PLAYER_SKILL_INFO_72_TEMPORARY_BONUS_1 = 1146
    PLAYER_SKILL_INFO_73_SKILL_0 = 1147
    PLAYER_SKILL_INFO_73_SKILL_STEP_1 = 1147
    PLAYER_SKILL_INFO_73_MINIMUM_0 = 1148
    PLAYER_SKILL_INFO_73_MAXIMUM_1 = 1148
    PLAYER_SKILL_INFO_73_PERMANENT_BONUS_0 = 1149
    PLAYER_SKILL_INFO_73_TEMPORARY_BONUS_1 = 1149
    PLAYER_SKILL_INFO_74_SKILL_0 = 1150
    PLAYER_SKILL_INFO_74_SKILL_STEP_1 = 1150
    PLAYER_SKILL_INFO_74_MINIMUM_0 = 1151
    PLAYER_SKILL_INFO_74_MAXIMUM_1 = 1151
    PLAYER_SKILL_INFO_74_PERMANENT_BONUS_0 = 1152
    PLAYER_SKILL_INFO_74_TEMPORARY_BONUS_1 = 1152
    PLAYER_SKILL_INFO_75_SKILL_0 = 1153
    PLAYER_SKILL_INFO_75_SKILL_STEP_1 = 1153
    PLAYER_SKILL_INFO_75_MINIMUM_0 = 1154
    PLAYER_SKILL_INFO_75_MAXIMUM_1 = 1154
    PLAYER_SKILL_INFO_75_PERMANENT_BONUS_0 = 1155
    PLAYER_SKILL_INFO_75_TEMPORARY_BONUS_1 = 1155
    PLAYER_SKILL_INFO_76_SKILL_0 = 1156
    PLAYER_SKILL_INFO_76_SKILL_STEP_1 = 1156
    PLAYER_SKILL_INFO_76_MINIMUM_0 = 1157
    PLAYER_SKILL_INFO_76_MAXIMUM_1 = 1157
    PLAYER_SKILL_INFO_76_PERMANENT_BONUS_0 = 1158
    PLAYER_SKILL_INFO_76_TEMPORARY_BONUS_1 = 1158
    PLAYER_SKILL_INFO_77_SKILL_0 = 1159
    PLAYER_SKILL_INFO_77_SKILL_STEP_1 = 1159
    PLAYER_SKILL_INFO_77_MINIMUM_0 = 1160
    PLAYER_SKILL_INFO_77_MAXIMUM_1 = 1160
    PLAYER_SKILL_INFO_77_PERMANENT_BONUS_0 = 1161
    PLAYER_SKILL_INFO_77_TEMPORARY_BONUS_1 = 1161
    PLAYER_SKILL_INFO_78_SKILL_0 = 1162
    PLAYER_SKILL_INFO_78_SKILL_STEP_1 = 1162
    PLAYER_SKILL_INFO_78_MINIMUM_0 = 1163
    PLAYER_SKILL_INFO_78_MAXIMUM_1 = 1163
    PLAYER_SKILL_INFO_78_PERMANENT_BONUS_0 = 1164
    PLAYER_SKILL_INFO_78_TEMPORARY_BONUS_1 = 1164
    PLAYER_SKILL_INFO_79_SKILL_0 = 1165
    PLAYER_SKILL_INFO_79_SKILL_STEP_1 = 1165
    PLAYER_SKILL_INFO_79_MINIMUM_0 = 1166
    PLAYER_SKILL_INFO_79_MAXIMUM_1 = 1166
    PLAYER_SKILL_INFO_79_PERMANENT_BONUS_0 = 1167
    PLAYER_SKILL_INFO_79_TEMPORARY_BONUS_1 = 1167
    PLAYER_SKILL_INFO_80_SKILL_0 = 1168
    PLAYER_SKILL_INFO_80_SKILL_STEP_1 = 1168
    PLAYER_SKILL_INFO_80_MINIMUM_0 = 1169
    PLAYER_SKILL_INFO_80_MAXIMUM_1 = 1169
    PLAYER_SKILL_INFO_80_PERMANENT_BONUS_0 = 1170
    PLAYER_SKILL_INFO_80_TEMPORARY_BONUS_1 = 1170
    PLAYER_SKILL_INFO_81_SKILL_0 = 1171
    PLAYER_SKILL_INFO_81_SKILL_STEP_1 = 1171
    PLAYER_SKILL_INFO_81_MINIMUM_0 = 1172
    PLAYER_SKILL_INFO_81_MAXIMUM_1 = 1172
    PLAYER_SKILL_INFO_81_PERMANENT_BONUS_0 = 1173
    PLAYER_SKILL_INFO_81_TEMPORARY_BONUS_1 = 1173
    PLAYER_SKILL_INFO_82_SKILL_0 = 1174
    PLAYER_SKILL_INFO_82_SKILL_STEP_1 = 1174
    PLAYER_SKILL_INFO_82_MINIMUM_0 = 1175
    PLAYER_SKILL_INFO_82_MAXIMUM_1 = 1175
    PLAYER_SKILL_INFO_82_PERMANENT_BONUS_0 = 1176
    PLAYER_SKILL_INFO_82_TEMPORARY_BONUS_1 = 1176
    PLAYER_SKILL_INFO_83_SKILL_0 = 1177
    PLAYER_SKILL_INFO_83_SKILL_STEP_1 = 1177
    PLAYER_SKILL_INFO_83_MINIMUM_0 = 1178
    PLAYER_SKILL_INFO_83_MAXIMUM_1 = 1178
    PLAYER_SKILL_INFO_83_PERMANENT_BONUS_0 = 1179
    PLAYER_SKILL_INFO_83_TEMPORARY_BONUS_1 = 1179
    PLAYER_SKILL_INFO_84_SKILL_0 = 1180
    PLAYER_SKILL_INFO_84_SKILL_STEP_1 = 1180
    PLAYER_SKILL_INFO_84_MINIMUM_0 = 1181
    PLAYER_SKILL_INFO_84_MAXIMUM_1 = 1181
    PLAYER_SKILL_INFO_84_PERMANENT_BONUS_0 = 1182
    PLAYER_SKILL_INFO_84_TEMPORARY_BONUS_1 = 1182
    PLAYER_SKILL_INFO_85_SKILL_0 = 1183
    PLAYER_SKILL_INFO_85_SKILL_STEP_1 = 1183
    PLAYER_SKILL_INFO_85_MINIMUM_0 = 1184
    PLAYER_SKILL_INFO_85_MAXIMUM_1 = 1184
    PLAYER_SKILL_INFO_85_PERMANENT_BONUS_0 = 1185
    PLAYER_SKILL_INFO_85_TEMPORARY_BONUS_1 = 1185
    PLAYER_SKILL_INFO_86_SKILL_0 = 1186
    PLAYER_SKILL_INFO_86_SKILL_STEP_1 = 1186
    PLAYER_SKILL_INFO_86_MINIMUM_0 = 1187
    PLAYER_SKILL_INFO_86_MAXIMUM_1 = 1187
    PLAYER_SKILL_INFO_86_PERMANENT_BONUS_0 = 1188
    PLAYER_SKILL_INFO_86_TEMPORARY_BONUS_1 = 1188
    PLAYER_SKILL_INFO_87_SKILL_0 = 1189
    PLAYER_SKILL_INFO_87_SKILL_STEP_1 = 1189
    PLAYER_SKILL_INFO_87_MINIMUM_0 = 1190
    PLAYER_SKILL_INFO_87_MAXIMUM_1 = 1190
    PLAYER_SKILL_INFO_87_PERMANENT_BONUS_0 = 1191
    PLAYER_SKILL_INFO_87_TEMPORARY_BONUS_1 = 1191
    PLAYER_SKILL_INFO_88_SKILL_0 = 1192
    PLAYER_SKILL_INFO_88_SKILL_STEP_1 = 1192
    PLAYER_SKILL_INFO_88_MINIMUM_0 = 1193
    PLAYER_SKILL_INFO_88_MAXIMUM_1 = 1193
    PLAYER_SKILL_INFO_88_PERMANENT_BONUS_0 = 1194
    PLAYER_SKILL_INFO_88_TEMPORARY_BONUS_1 = 1194
    PLAYER_SKILL_INFO_89_SKILL_0 = 1195
    PLAYER_SKILL_INFO_89_SKILL_STEP_1 = 1195
    PLAYER_SKILL_INFO_89_MINIMUM_0 = 1196
    PLAYER_SKILL_INFO_89_MAXIMUM_1 = 1196
    PLAYER_SKILL_INFO_89_PERMANENT_BONUS_0 = 1197
    PLAYER_SKILL_INFO_89_TEMPORARY_BONUS_1 = 1197
    PLAYER_SKILL_INFO_90_SKILL_0 = 1198
    PLAYER_SKILL_INFO_90_SKILL_STEP_1 = 1198
    PLAYER_SKILL_INFO_90_MINIMUM_0 = 1199
    PLAYER_SKILL_INFO_90_MAXIMUM_1 = 1199
    PLAYER_SKILL_INFO_90_PERMANENT_BONUS_0 = 1200
    PLAYER_SKILL_INFO_90_TEMPORARY_BONUS_1 = 1200
    PLAYER_SKILL_INFO_91_SKILL_0 = 1201
    PLAYER_SKILL_INFO_91_SKILL_STEP_1 = 1201
    PLAYER_SKILL_INFO_91_MINIMUM_0 = 1202
    PLAYER_SKILL_INFO_91_MAXIMUM_1 = 1202
    PLAYER_SKILL_INFO_91_PERMANENT_BONUS_0 = 1203
    PLAYER_SKILL_INFO_91_TEMPORARY_BONUS_1 = 1203
    PLAYER_SKILL_INFO_92_SKILL_0 = 1204
    PLAYER_SKILL_INFO_92_SKILL_STEP_1 = 1204
    PLAYER_SKILL_INFO_92_MINIMUM_0 = 1205
    PLAYER_SKILL_INFO_92_MAXIMUM_1 = 1205
    PLAYER_SKILL_INFO_92_PERMANENT_BONUS_0 = 1206
    PLAYER_SKILL_INFO_92_TEMPORARY_BONUS_1 = 1206
    PLAYER_SKILL_INFO_93_SKILL_0 = 1207
    PLAYER_SKILL_INFO_93_SKILL_STEP_1 = 1207
    PLAYER_SKILL_INFO_93_MINIMUM_0 = 1208
    PLAYER_SKILL_INFO_93_MAXIMUM_1 = 1208
    PLAYER_SKILL_INFO_93_PERMANENT_BONUS_0 = 1209
    PLAYER_SKILL_INFO_93_TEMPORARY_BONUS_1 = 1209
    PLAYER_SKILL_INFO_94_SKILL_0 = 1210
    PLAYER_SKILL_INFO_94_SKILL_STEP_1 = 1210
    PLAYER_SKILL_INFO_94_MINIMUM_0 = 1211
    PLAYER_SKILL_INFO_94_MAXIMUM_1 = 1211
    PLAYER_SKILL_INFO_94_PERMANENT_BONUS_0 = 1212
    PLAYER_SKILL_INFO_94_TEMPORARY_BONUS_1 = 1212
    PLAYER_SKILL_INFO_95_SKILL_0 = 1213
    PLAYER_SKILL_INFO_95_SKILL_STEP_1 = 1213
    PLAYER_SKILL_INFO_95_MINIMUM_0 = 1214
    PLAYER_SKILL_INFO_95_MAXIMUM_1 = 1214
    PLAYER_SKILL_INFO_95_PERMANENT_BONUS_0 = 1215
    PLAYER_SKILL_INFO_95_TEMPORARY_BONUS_1 = 1215
    PLAYER_SKILL_INFO_96_SKILL_0 = 1216
    PLAYER_SKILL_INFO_96_SKILL_STEP_1 = 1216
    PLAYER_SKILL_INFO_96_MINIMUM_0 = 1217
    PLAYER_SKILL_INFO_96_MAXIMUM_1 = 1217
    PLAYER_SKILL_INFO_96_PERMANENT_BONUS_0 = 1218
    PLAYER_SKILL_INFO_96_TEMPORARY_BONUS_1 = 1218
    PLAYER_SKILL_INFO_97_SKILL_0 = 1219
    PLAYER_SKILL_INFO_97_SKILL_STEP_1 = 1219
    PLAYER_SKILL_INFO_97_MINIMUM_0 = 1220
    PLAYER_SKILL_INFO_97_MAXIMUM_1 = 1220
    PLAYER_SKILL_INFO_97_PERMANENT_BONUS_0 = 1221
    PLAYER_SKILL_INFO_97_TEMPORARY_BONUS_1 = 1221
    PLAYER_SKILL_INFO_98_SKILL_0 = 1222
    PLAYER_SKILL_INFO_98_SKILL_STEP_1 = 1222
    PLAYER_SKILL_INFO_98_MINIMUM_0 = 1223
    PLAYER_SKILL_INFO_98_MAXIMUM_1 = 1223
    PLAYER_SKILL_INFO_98_PERMANENT_BONUS_0 = 1224
    PLAYER_SKILL_INFO_98_TEMPORARY_BONUS_1 = 1224
    PLAYER_SKILL_INFO_99_SKILL_0 = 1225
    PLAYER_SKILL_INFO_99_SKILL_STEP_1 = 1225
    PLAYER_SKILL_INFO_99_MINIMUM_0 = 1226
    PLAYER_SKILL_INFO_99_MAXIMUM_1 = 1226
    PLAYER_SKILL_INFO_99_PERMANENT_BONUS_0 = 1227
    PLAYER_SKILL_INFO_99_TEMPORARY_BONUS_1 = 1227
    PLAYER_SKILL_INFO_100_SKILL_0 = 1228
    PLAYER_SKILL_INFO_100_SKILL_STEP_1 = 1228
    PLAYER_SKILL_INFO_100_MINIMUM_0 = 1229
    PLAYER_SKILL_INFO_100_MAXIMUM_1 = 1229
    PLAYER_SKILL_INFO_100_PERMANENT_BONUS_0 = 1230
    PLAYER_SKILL_INFO_100_TEMPORARY_BONUS_1 = 1230
    PLAYER_SKILL_INFO_101_SKILL_0 = 1231
    PLAYER_SKILL_INFO_101_SKILL_STEP_1 = 1231
    PLAYER_SKILL_INFO_101_MINIMUM_0 = 1232
    PLAYER_SKILL_INFO_101_MAXIMUM_1 = 1232
    PLAYER_SKILL_INFO_101_PERMANENT_BONUS_0 = 1233
    PLAYER_SKILL_INFO_101_TEMPORARY_BONUS_1 = 1233
    PLAYER_SKILL_INFO_102_SKILL_0 = 1234
    PLAYER_SKILL_INFO_102_SKILL_STEP_1 = 1234
    PLAYER_SKILL_INFO_102_MINIMUM_0 = 1235
    PLAYER_SKILL_INFO_102_MAXIMUM_1 = 1235
    PLAYER_SKILL_INFO_102_PERMANENT_BONUS_0 = 1236
    PLAYER_SKILL_INFO_102_TEMPORARY_BONUS_1 = 1236
    PLAYER_SKILL_INFO_103_SKILL_0 = 1237
    PLAYER_SKILL_INFO_103_SKILL_STEP_1 = 1237
    PLAYER_SKILL_INFO_103_MINIMUM_0 = 1238
    PLAYER_SKILL_INFO_103_MAXIMUM_1 = 1238
    PLAYER_SKILL_INFO_103_PERMANENT_BONUS_0 = 1239
    PLAYER_SKILL_INFO_103_TEMPORARY_BONUS_1 = 1239
    PLAYER_SKILL_INFO_104_SKILL_0 = 1240
    PLAYER_SKILL_INFO_104_SKILL_STEP_1 = 1240
    PLAYER_SKILL_INFO_104_MINIMUM_0 = 1241
    PLAYER_SKILL_INFO_104_MAXIMUM_1 = 1241
    PLAYER_SKILL_INFO_104_PERMANENT_BONUS_0 = 1242
    PLAYER_SKILL_INFO_104_TEMPORARY_BONUS_1 = 1242
    PLAYER_SKILL_INFO_105_SKILL_0 = 1243
    PLAYER_SKILL_INFO_105_SKILL_STEP_1 = 1243
    PLAYER_SKILL_INFO_105_MINIMUM_0 = 1244
    PLAYER_SKILL_INFO_105_MAXIMUM_1 = 1244
    PLAYER_SKILL_INFO_105_PERMANENT_BONUS_0 = 1245
    PLAYER_SKILL_INFO_105_TEMPORARY_BONUS_1 = 1245
    PLAYER_SKILL_INFO_106_SKILL_0 = 1246
    PLAYER_SKILL_INFO_106_SKILL_STEP_1 = 1246
    PLAYER_SKILL_INFO_106_MINIMUM_0 = 1247
    PLAYER_SKILL_INFO_106_MAXIMUM_1 = 1247
    PLAYER_SKILL_INFO_106_PERMANENT_BONUS_0 = 1248
    PLAYER_SKILL_INFO_106_TEMPORARY_BONUS_1 = 1248
    PLAYER_SKILL_INFO_107_SKILL_0 = 1249
    PLAYER_SKILL_INFO_107_SKILL_STEP_1 = 1249
    PLAYER_SKILL_INFO_107_MINIMUM_0 = 1250
    PLAYER_SKILL_INFO_107_MAXIMUM_1 = 1250
    PLAYER_SKILL_INFO_107_PERMANENT_BONUS_0 = 1251
    PLAYER_SKILL_INFO_107_TEMPORARY_BONUS_1 = 1251
    PLAYER_SKILL_INFO_108_SKILL_0 = 1252
    PLAYER_SKILL_INFO_108_SKILL_STEP_1 = 1252
    PLAYER_SKILL_INFO_108_MINIMUM_0 = 1253
    PLAYER_SKILL_INFO_108_MAXIMUM_1 = 1253
    PLAYER_SKILL_INFO_108_PERMANENT_BONUS_0 = 1254
    PLAYER_SKILL_INFO_108_TEMPORARY_BONUS_1 = 1254
    PLAYER_SKILL_INFO_109_SKILL_0 = 1255
    PLAYER_SKILL_INFO_109_SKILL_STEP_1 = 1255
    PLAYER_SKILL_INFO_109_MINIMUM_0 = 1256
    PLAYER_SKILL_INFO_109_MAXIMUM_1 = 1256
    PLAYER_SKILL_INFO_109_PERMANENT_BONUS_0 = 1257
    PLAYER_SKILL_INFO_109_TEMPORARY_BONUS_1 = 1257
    PLAYER_SKILL_INFO_110_SKILL_0 = 1258
    PLAYER_SKILL_INFO_110_SKILL_STEP_1 = 1258
    PLAYER_SKILL_INFO_110_MINIMUM_0 = 1259
    PLAYER_SKILL_INFO_110_MAXIMUM_1 = 1259
    PLAYER_SKILL_INFO_110_PERMANENT_BONUS_0 = 1260
    PLAYER_SKILL_INFO_110_TEMPORARY_BONUS_1 = 1260
    PLAYER_SKILL_INFO_111_SKILL_0 = 1261
    PLAYER_SKILL_INFO_111_SKILL_STEP_1 = 1261
    PLAYER_SKILL_INFO_111_MINIMUM_0 = 1262
    PLAYER_SKILL_INFO_111_MAXIMUM_1 = 1262
    PLAYER_SKILL_INFO_111_PERMANENT_BONUS_0 = 1263
    PLAYER_SKILL_INFO_111_TEMPORARY_BONUS_1 = 1263
    PLAYER_SKILL_INFO_112_SKILL_0 = 1264
    PLAYER_SKILL_INFO_112_SKILL_STEP_1 = 1264
    PLAYER_SKILL_INFO_112_MINIMUM_0 = 1265
    PLAYER_SKILL_INFO_112_MAXIMUM_1 = 1265
    PLAYER_SKILL_INFO_112_PERMANENT_BONUS_0 = 1266
    PLAYER_SKILL_INFO_112_TEMPORARY_BONUS_1 = 1266
    PLAYER_SKILL_INFO_113_SKILL_0 = 1267
    PLAYER_SKILL_INFO_113_SKILL_STEP_1 = 1267
    PLAYER_SKILL_INFO_113_MINIMUM_0 = 1268
    PLAYER_SKILL_INFO_113_MAXIMUM_1 = 1268
    PLAYER_SKILL_INFO_113_PERMANENT_BONUS_0 = 1269
    PLAYER_SKILL_INFO_113_TEMPORARY_BONUS_1 = 1269
    PLAYER_SKILL_INFO_114_SKILL_0 = 1270
    PLAYER_SKILL_INFO_114_SKILL_STEP_1 = 1270
    PLAYER_SKILL_INFO_114_MINIMUM_0 = 1271
    PLAYER_SKILL_INFO_114_MAXIMUM_1 = 1271
    PLAYER_SKILL_INFO_114_PERMANENT_BONUS_0 = 1272
    PLAYER_SKILL_INFO_114_TEMPORARY_BONUS_1 = 1272
    PLAYER_SKILL_INFO_115_SKILL_0 = 1273
    PLAYER_SKILL_INFO_115_SKILL_STEP_1 = 1273
    PLAYER_SKILL_INFO_115_MINIMUM_0 = 1274
    PLAYER_SKILL_INFO_115_MAXIMUM_1 = 1274
    PLAYER_SKILL_INFO_115_PERMANENT_BONUS_0 = 1275
    PLAYER_SKILL_INFO_115_TEMPORARY_BONUS_1 = 1275
    PLAYER_SKILL_INFO_116_SKILL_0 = 1276
    PLAYER_SKILL_INFO_116_SKILL_STEP_1 = 1276
    PLAYER_SKILL_INFO_116_MINIMUM_0 = 1277
    PLAYER_SKILL_INFO_116_MAXIMUM_1 = 1277
    PLAYER_SKILL_INFO_116_PERMANENT_BONUS_0 = 1278
    PLAYER_SKILL_INFO_116_TEMPORARY_BONUS_1 = 1278
    PLAYER_SKILL_INFO_117_SKILL_0 = 1279
    PLAYER_SKILL_INFO_117_SKILL_STEP_1 = 1279
    PLAYER_SKILL_INFO_117_MINIMUM_0 = 1280
    PLAYER_SKILL_INFO_117_MAXIMUM_1 = 1280
    PLAYER_SKILL_INFO_117_PERMANENT_BONUS_0 = 1281
    PLAYER_SKILL_INFO_117_TEMPORARY_BONUS_1 = 1281
    PLAYER_SKILL_INFO_118_SKILL_0 = 1282
    PLAYER_SKILL_INFO_118_SKILL_STEP_1 = 1282
    PLAYER_SKILL_INFO_118_MINIMUM_0 = 1283
    PLAYER_SKILL_INFO_118_MAXIMUM_1 = 1283
    PLAYER_SKILL_INFO_118_PERMANENT_BONUS_0 = 1284
    PLAYER_SKILL_INFO_118_TEMPORARY_BONUS_1 = 1284
    PLAYER_SKILL_INFO_119_SKILL_0 = 1285
    PLAYER_SKILL_INFO_119_SKILL_STEP_1 = 1285
    PLAYER_SKILL_INFO_119_MINIMUM_0 = 1286
    PLAYER_SKILL_INFO_119_MAXIMUM_1 = 1286
    PLAYER_SKILL_INFO_119_PERMANENT_BONUS_0 = 1287
    PLAYER_SKILL_INFO_119_TEMPORARY_BONUS_1 = 1287
    PLAYER_SKILL_INFO_120_SKILL_0 = 1288
    PLAYER_SKILL_INFO_120_SKILL_STEP_1 = 1288
    PLAYER_SKILL_INFO_120_MINIMUM_0 = 1289
    PLAYER_SKILL_INFO_120_MAXIMUM_1 = 1289
    PLAYER_SKILL_INFO_120_PERMANENT_BONUS_0 = 1290
    PLAYER_SKILL_INFO_120_TEMPORARY_BONUS_1 = 1290
    PLAYER_SKILL_INFO_121_SKILL_0 = 1291
    PLAYER_SKILL_INFO_121_SKILL_STEP_1 = 1291
    PLAYER_SKILL_INFO_121_MINIMUM_0 = 1292
    PLAYER_SKILL_INFO_121_MAXIMUM_1 = 1292
    PLAYER_SKILL_INFO_121_PERMANENT_BONUS_0 = 1293
    PLAYER_SKILL_INFO_121_TEMPORARY_BONUS_1 = 1293
    PLAYER_SKILL_INFO_122_SKILL_0 = 1294
    PLAYER_SKILL_INFO_122_SKILL_STEP_1 = 1294
    PLAYER_SKILL_INFO_122_MINIMUM_0 = 1295
    PLAYER_SKILL_INFO_122_MAXIMUM_1 = 1295
    PLAYER_SKILL_INFO_122_PERMANENT_BONUS_0 = 1296
    PLAYER_SKILL_INFO_122_TEMPORARY_BONUS_1 = 1296
    PLAYER_SKILL_INFO_123_SKILL_0 = 1297
    PLAYER_SKILL_INFO_123_SKILL_STEP_1 = 1297
    PLAYER_SKILL_INFO_123_MINIMUM_0 = 1298
    PLAYER_SKILL_INFO_123_MAXIMUM_1 = 1298
    PLAYER_SKILL_INFO_123_PERMANENT_BONUS_0 = 1299
    PLAYER_SKILL_INFO_123_TEMPORARY_BONUS_1 = 1299
    PLAYER_SKILL_INFO_124_SKILL_0 = 1300
    PLAYER_SKILL_INFO_124_SKILL_STEP_1 = 1300
    PLAYER_SKILL_INFO_124_MINIMUM_0 = 1301
    PLAYER_SKILL_INFO_124_MAXIMUM_1 = 1301
    PLAYER_SKILL_INFO_124_PERMANENT_BONUS_0 = 1302
    PLAYER_SKILL_INFO_124_TEMPORARY_BONUS_1 = 1302
    PLAYER_SKILL_INFO_125_SKILL_0 = 1303
    PLAYER_SKILL_INFO_125_SKILL_STEP_1 = 1303
    PLAYER_SKILL_INFO_125_MINIMUM_0 = 1304
    PLAYER_SKILL_INFO_125_MAXIMUM_1 = 1304
    PLAYER_SKILL_INFO_125_PERMANENT_BONUS_0 = 1305
    PLAYER_SKILL_INFO_125_TEMPORARY_BONUS_1 = 1305
    PLAYER_SKILL_INFO_126_SKILL_0 = 1306
    PLAYER_SKILL_INFO_126_SKILL_STEP_1 = 1306
    PLAYER_SKILL_INFO_126_MINIMUM_0 = 1307
    PLAYER_SKILL_INFO_126_MAXIMUM_1 = 1307
    PLAYER_SKILL_INFO_126_PERMANENT_BONUS_0 = 1308
    PLAYER_SKILL_INFO_126_TEMPORARY_BONUS_1 = 1308
    PLAYER_SKILL_INFO_127_SKILL_0 = 1309
    PLAYER_SKILL_INFO_127_SKILL_STEP_1 = 1309
    PLAYER_SKILL_INFO_127_MINIMUM_0 = 1310
    PLAYER_SKILL_INFO_127_MAXIMUM_1 = 1310
    PLAYER_SKILL_INFO_127_PERMANENT_BONUS_0 = 1311
    PLAYER_SKILL_INFO_127_TEMPORARY_BONUS_1 = 1311
    PLAYER_CHARACTER_POINTS1 = 1312
    PLAYER_CHARACTER_POINTS2 = 1313
    PLAYER_TRACK_CREATURES = 1314
    PLAYER_TRACK_RESOURCES = 1315
    PLAYER_BLOCK_PERCENTAGE = 1316
    PLAYER_DODGE_PERCENTAGE = 1317
    PLAYER_PARRY_PERCENTAGE = 1318
    PLAYER_EXPERTISE = 1319
    PLAYER_OFFHAND_EXPERTISE = 1320
    PLAYER_CRIT_PERCENTAGE = 1321
    PLAYER_RANGED_CRIT_PERCENTAGE = 1322
    PLAYER_OFFHAND_CRIT_PERCENTAGE = 1323
    PLAYER_SPELL_CRIT_PERCENTAGE1 = 1324
    PLAYER_SHIELD_BLOCK = 1331
    PLAYER_EXPLORED_ZONES_1 = 1332
    PLAYER_REST_STATE_EXPERIENCE = 1460
    PLAYER_COINAGE = 1461
    PLAYER_MOD_DAMAGE_DONE_POS = 1462
    PLAYER_MOD_DAMAGE_DONE_NEG = 1469
    PLAYER_MOD_DAMAGE_DONE_PCT = 1476
    PLAYER_MOD_HEALING_DONE_POS = 1483
    PLAYER_MOD_TARGET_RESISTANCE = 1484
    PLAYER_MOD_TARGET_PHYSICAL_RESISTANCE = 1485
    PLAYER_FEATURES = 1486
    PLAYER_AMMO_ID = 1487
    PLAYER_SELF_RES_SPELL = 1488
    PLAYER_PVP_MEDALS = 1489
    PLAYER_BUYBACK_PRICE_1 = 1490
    PLAYER_BUYBACK_TIMESTAMP_1 = 1502
    PLAYER_KILLS = 1514
    PLAYER_TODAY_CONTRIBUTION = 1515
    PLAYER_YESTERDAY_CONTRIBUTION = 1516
    PLAYER_LIFETIME_HONORABLE_KILLS = 1517
    PLAYER_BYTES2_GLOW = 1518
    PLAYER_WATCHED_FACTION_INDEX = 1519
    PLAYER_COMBAT_RATING_1 = 1520
    PLAYER_ARENA_TEAM_INFO_1_1 = 1544
    PLAYER_HONOR_CURRENCY = 1562
    PLAYER_ARENA_CURRENCY = 1563
    PLAYER_MOD_MANA_REGEN = 1564
    PLAYER_MOD_MANA_REGEN_INTERRUPT = 1565
    PLAYER_MAX_LEVEL = 1566
    PLAYER_DAILY_QUESTS_1 = 1567
    OBJECT_CREATED_BY = 6
    GAME_OBJECT_DISPLAYID = 8
    GAME_OBJECT_FLAGS = 9
    GAME_OBJECT_ROTATION = 10
    GAME_OBJECT_STATE = 14
    GAME_OBJECT_POS_X = 15
    GAME_OBJECT_POS_Y = 16
    GAME_OBJECT_POS_Z = 17
    GAME_OBJECT_FACING = 18
    GAME_OBJECT_DYN_FLAGS = 19
    GAME_OBJECT_FACTION = 20
    GAME_OBJECT_TYPE_ID = 21
    GAME_OBJECT_LEVEL = 22
    GAME_OBJECT_ARTKIT = 23
    GAME_OBJECT_ANIMPROGRESS = 24
    DYNAMIC_OBJECT_CASTER = 6
    DYNAMIC_OBJECT_BYTES = 8
    DYNAMIC_OBJECT_SPELLID = 9
    DYNAMIC_OBJECT_RADIUS = 10
    DYNAMIC_OBJECT_POS_X = 11
    DYNAMIC_OBJECT_POS_Y = 12
    DYNAMIC_OBJECT_POS_Z = 13
    DYNAMIC_OBJECT_FACING = 14
    DYNAMIC_OBJECT_CASTTIME = 15
    CORPSE_OWNER = 6
    CORPSE_PARTY = 8
    CORPSE_FACING = 10
    CORPSE_POS_X = 11
    CORPSE_POS_Y = 12
    CORPSE_POS_Z = 13
    CORPSE_DISPLAY_ID = 14
    CORPSE_ITEM = 15
    CORPSE_BYTES_1 = 34
    CORPSE_BYTES_2 = 35
    CORPSE_GUILD = 36
    CORPSE_FLAGS = 37
    CORPSE_DYNAMIC_FLAGS = 38


class AccountDataType(enum.Enum):
    GLOBAL_CONFIG_CACHE = 0
    PER_CHARACTER_CONFIG_CACHE = 1
    GLOBAL_BINDINGS_CACHE = 2
    PER_CHARACTER_BINDINGS_CACHE = 3
    GLOBAL_MACROS_CACHE = 4
    PER_CHARACTER_MACROS_CACHE = 5
    PER_CHARACTER_LAYOUT_CACHE = 6
    PER_CHARACTER_CHAT_CACHE = 7
    NUM_ACCOUNT_DATA_TYPES = 8


class ActivateTaxiReply(enum.Enum):
    OK = 0
    UNSPECIFIED_SERVER_ERROR = 1
    NO_SUCH_PATH = 2
    NOT_ENOUGH_MONEY = 3
    TOO_FAR_AWAY = 4
    NO_VENDOR_NEARBY = 5
    NOT_VISITED = 6
    PLAYER_BUSY = 7
    PLAYER_ALREADY_MOUNTED = 8
    PLAYER_SHAPE_SHIFTED = 9
    PLAYER_MOVING = 10
    SAME_NODE = 11
    NOT_STANDING = 12


class AiReaction(enum.Enum):
    ALERT = 0
    FRIENDLY = 1
    HOSTILE = 2
    AFRAID = 3
    DESTROY = 4


class Area(enum.Enum):
    NONE = 0
    DUN_MOROGH = 1
    LONGSHORE = 2
    BADLANDS = 3
    BLASTED_LANDS = 4
    BLACKWATER_COVE = 7
    SWAMP_OF_SORROWS = 8
    NORTHSHIRE_VALLEY = 9
    DUSKWOOD = 10
    WETLANDS = 11
    ELWYNN_FOREST = 12
    THE_WORLD_TREE = 13
    DUROTAR = 14
    DUSTWALLOW_MARSH = 15
    AZSHARA = 16
    THE_BARRENS = 17
    CRYSTAL_LAKE = 18
    ZUL_GURUB = 19
    MOONBROOK = 20
    KUL_TIRAS = 21
    PROGRAMMER_ISLE = 22
    NORTHSHIRE_RIVER = 23
    NORTHSHIRE_ABBEY = 24
    BLACKROCK_MOUNTAIN = 25
    LIGHTHOUSE = 26
    WESTERN_PLAGUELANDS = 28
    NINE = 30
    THE_CEMETARY = 32
    STRANGLETHORN_VALE = 33
    ECHO_RIDGE_MINE = 34
    BOOTY_BAY = 35
    ALTERAC_MOUNTAINS = 36
    LAKE_NAZFERITI = 37
    LOCH_MODAN = 38
    WESTFALL = 40
    DEADWIND_PASS = 41
    DARKSHIRE = 42
    WILD_SHORE = 43
    REDRIDGE_MOUNTAINS = 44
    ARATHI_HIGHLANDS = 45
    BURNING_STEPPES = 46
    THE_HINTERLANDS = 47
    DEAD_MANS_HOLE = 49
    SEARING_GORGE = 51
    THIEVES_CAMP = 53
    JASPERLODE_MINE = 54
    VALLEY_OF_HEROES_UNUSED = 55
    HEROES_VIGIL = 56
    FARGODEEP_MINE = 57
    NORTHSHIRE_VINEYARDS = 59
    FORESTS_EDGE = 60
    THUNDER_FALLS = 61
    BRACKWELL_PUMPKIN_PATCH = 62
    THE_STONEFIELD_FARM = 63
    THE_MACLURE_VINEYARDS = 64
    REUSE_ME_THREE = 65
    REUSE_ME_SIX = 66
    REUSE_ME_FIVE = 67
    LAKE_EVERSTILL = 68
    LAKESHIRE = 69
    STONEWATCH = 70
    STONEWATCH_FALLS = 71
    THE_DARK_PORTAL = 72
    THE_TAINTED_SCAR = 73
    POOL_OF_TEARS = 74
    STONARD = 75
    FALLOW_SANCTUARY = 76
    ANVILMAR = 77
    STORMWIND_MOUNTAINS = 80
    JEFF_NE_QUADRANT_CHANGED = 81
    JEFF_NW_QUADRANT = 82
    JEFF_SE_QUADRANT = 83
    JEFF_SW_QUADRANT = 84
    TIRISFAL_GLADES = 85
    STONE_CAIRN_LAKE = 86
    GOLDSHIRE = 87
    EASTVALE_LOGGING_CAMP = 88
    MIRROR_LAKE_ORCHARD = 89
    TOWER_OF_AZORA = 91
    MIRROR_LAKE = 92
    VUL_GOL_OGRE_MOUND = 93
    RAVEN_HILL = 94
    REDRIDGE_CANYONS = 95
    TOWER_OF_ILGALAR = 96
    ALTHERS_MILL = 97
    RETHBAN_CAVERNS = 98
    REBEL_CAMP = 99
    NESINGWARYS_EXPEDITION = 100
    KURZENS_COMPOUND = 101
    RUINS_OF_ZUL_KUNDA = 102
    RUINS_OF_ZUL_MAMWE = 103
    THE_VILE_REEF = 104
    MOSH_OGG_OGRE_MOUND = 105
    THE_STOCKPILE = 106
    SALDEANS_FARM = 107
    SENTINEL_HILL = 108
    FURLBROWS_PUMPKIN_FARM = 109
    JANGOLODE_MINE = 111
    GOLD_COAST_QUARRY = 113
    WESTFALL_LIGHTHOUSE = 115
    MISTY_VALLEY = 116
    GROM_GOL_BASE_CAMP = 117
    WHELGARS_EXCAVATION_SITE = 118
    WESTBROOK_GARRISON = 120
    TRANQUIL_GARDENS_CEMETERY = 121
    ZUULDAIA_RUINS = 122
    BAL_LAL_RUINS = 123
    KAL_AI_RUINS = 125
    TKASHI_RUINS = 126
    BALIA_MAH_RUINS = 127
    ZIATA_JAI_RUINS = 128
    MIZJAH_RUINS = 129
    SILVERPINE_FOREST = 130
    KHARANOS = 131
    COLDRIDGE_VALLEY = 132
    GNOMEREGAN = 133
    GOL_BOLAR_QUARRY = 134
    FROSTMANE_HOLD = 135
    THE_GRIZZLED_DEN = 136
    BREWNALL_VILLAGE = 137
    MISTY_PINE_REFUGE = 138
    EASTERN_PLAGUELANDS = 139
    TELDRASSIL = 141
    IRONBANDS_EXCAVATION_SITE = 142
    MO_GROSH_STRONGHOLD = 143
    THELSAMAR = 144
    ALGAZ_GATE = 145
    STONEWROUGHT_DAM = 146
    THE_FARSTRIDER_LODGE = 147
    DARKSHORE = 148
    SILVER_STREAM_MINE = 149
    MENETHIL_HARBOR = 150
    DESIGNER_ISLAND = 151
    THE_BULWARK = 152
    RUINS_OF_LORDAERON = 153
    DEATHKNELL = 154
    NIGHT_WEBS_HOLLOW = 155
    SOLLIDEN_FARMSTEAD = 156
    AGAMAND_MILLS = 157
    AGAMAND_FAMILY_CRYPT = 158
    BRILL = 159
    WHISPERING_GARDENS = 160
    TERRACE_OF_REPOSE = 161
    BRIGHTWATER_LAKE = 162
    GUNTHERS_RETREAT = 163
    GARRENS_HAUNT = 164
    BALNIR_FARMSTEAD = 165
    COLD_HEARTH_MANOR = 166
    CRUSADER_OUTPOST = 167
    THE_NORTH_COAST = 168
    WHISPERING_SHORE = 169
    LORDAMERE_LAKE = 170
    FENRIS_ISLE = 172
    FAOLS_REST = 173
    DOLANAAR = 186
    DARNASSUS_UNUSED = 187
    SHADOWGLEN = 188
    STEELGRILLS_DEPOT = 189
    HEARTHGLEN = 190
    NORTHRIDGE_LUMBER_CAMP = 192
    RUINS_OF_ANDORHAL = 193
    SCHOOL_OF_NECROMANCY = 195
    UTHERS_TOMB = 196
    SORROW_HILL = 197
    THE_WEEPING_CAVE = 198
    FELSTONE_FIELD = 199
    DALSONS_TEARS = 200
    GAHRRONS_WITHERING = 201
    THE_WRITHING_HAUNT = 202
    MARDENHOLDE_KEEP = 203
    PYREWOOD_VILLAGE = 204
    DUN_MODR = 205
    UNUSED_WESTFALL = 206
    THE_GREAT_SEA = 207
    UNUSED_IRONCLADCOVE = 208
    SHADOWFANG_KEEP = 209
    REUSE_ME_2 = 210
    ICEFLOW_LAKE = 211
    HELMS_BED_LAKE = 212
    DEEP_ELEM_MINE = 213
    THE_GREAT_SEA1 = 214
    MULGORE = 215
    ALEXSTON_FARMSTEAD = 219
    RED_CLOUD_MESA = 220
    CAMP_NARACHE = 221
    BLOODHOOF_VILLAGE = 222
    STONEBULL_LAKE = 223
    RAVAGED_CARAVAN = 224
    RED_ROCKS = 225
    THE_SKITTERING_DARK = 226
    VALGANS_FIELD = 227
    THE_SEPULCHER = 228
    OLSENS_FARTHING = 229
    THE_GREYMANE_WALL = 230
    BERENS_PERIL = 231
    THE_DAWNING_ISLES = 232
    AMBERMILL = 233
    FENRIS_KEEP = 235
    SHADOWFANG_KEEP1 = 236
    THE_DECREPIT_FERRY = 237
    MALDENS_ORCHARD = 238
    THE_IVAR_PATCH = 239
    THE_DEAD_FIELD = 240
    THE_ROTTING_ORCHARD = 241
    BRIGHTWOOD_GROVE = 242
    FORLORN_ROWE = 243
    THE_WHIPPLE_ESTATE = 244
    THE_YORGEN_FARMSTEAD = 245
    THE_CAULDRON = 246
    GRIMESILT_DIG_SITE = 247
    DREADMAUL_ROCK = 249
    RUINS_OF_THAURISSAN = 250
    FLAME_CREST = 251
    BLACKROCK_STRONGHOLD = 252
    THE_PILLAR_OF_ASH = 253
    BLACKROCK_MOUNTAIN1 = 254
    ALTAR_OF_STORMS = 255
    ALDRASSIL = 256
    SHADOWTHREAD_CAVE = 257
    FEL_ROCK = 258
    LAKE_AL_AMETH = 259
    STARBREEZE_VILLAGE = 260
    GNARLPINE_HOLD = 261
    BAN_ETHIL_BARROW_DEN = 262
    THE_CLEFT = 263
    THE_ORACLE_GLADE = 264
    WELLSPRING_RIVER = 265
    WELLSPRING_LAKE = 266
    HILLSBRAD_FOOTHILLS = 267
    AZSHARA_CRATER = 268
    DUN_ALGAZ = 269
    SOUTHSHORE = 271
    TARREN_MILL = 272
    DURNHOLDE_KEEP = 275
    UNUSED_STONEWROUGHT_PASS = 276
    THE_FOOTHILL_CAVERNS = 277
    LORDAMERE_INTERNMENT_CAMP = 278
    DALARAN = 279
    STRAHNBRAD = 280
    RUINS_OF_ALTERAC = 281
    CRUSHRIDGE_HOLD = 282
    SLAUGHTER_HOLLOW = 283
    THE_UPLANDS = 284
    SOUTHPOINT_TOWER = 285
    HILLSBRAD_FIELDS = 286
    HILLSBRAD = 287
    AZURELODE_MINE = 288
    NETHANDER_STEAD = 289
    DUN_GAROK = 290
    THORADINS_WALL = 293
    EASTERN_STRAND = 294
    WESTERN_STRAND = 295
    SOUTH_SEAS_UNUSED = 296
    JAGUERO_ISLE = 297
    BARADIN_BAY = 298
    MENETHIL_BAY = 299
    MISTY_REED_STRAND = 300
    THE_SAVAGE_COAST = 301
    THE_CRYSTAL_SHORE = 302
    SHELL_BEACH = 303
    NORTH_TIDES_RUN = 305
    SOUTH_TIDES_RUN = 306
    THE_OVERLOOK_CLIFFS = 307
    THE_FORBIDDING_SEA = 308
    IRONBEARDS_TOMB = 309
    CRYSTALVEIN_MINE = 310
    RUINS_OF_ABORAZ = 311
    JANEIROS_POINT = 312
    NORTHFOLD_MANOR = 313
    GO_SHEK_FARM = 314
    DABYRIES_FARMSTEAD = 315
    BOULDERFIST_HALL = 316
    WITHERBARK_VILLAGE = 317
    DRYWHISKER_GORGE = 318
    REFUGE_POINTE = 320
    HAMMERFALL = 321
    BLACKWATER_SHIPWRECKS = 322
    O_BREENS_CAMP = 323
    STROMGARDE_KEEP = 324
    THE_TOWER_OF_ARATHOR = 325
    THE_SANCTUM = 326
    FALDIRS_COVE = 327
    THE_DROWNED_REEF = 328
    THANDOL_SPAN = 330
    ASHENVALE = 331
    THE_GREAT_SEA2 = 332
    CIRCLE_OF_EAST_BINDING = 333
    CIRCLE_OF_WEST_BINDING = 334
    CIRCLE_OF_INNER_BINDING = 335
    CIRCLE_OF_OUTER_BINDING = 336
    APOCRYPHANS_REST = 337
    ANGOR_FORTRESS = 338
    LETHLOR_RAVINE = 339
    KARGATH = 340
    CAMP_KOSH = 341
    CAMP_BOFF = 342
    CAMP_WURG = 343
    CAMP_CAGG = 344
    AGMONDS_END = 345
    HAMMERTOES_DIGSITE = 346
    DUSTBELCH_GROTTO = 347
    AERIE_PEAK = 348
    WILDHAMMER_KEEP = 349
    QUEL_DANIL_LODGE = 350
    SKULK_ROCK = 351
    ZUN_WATHA = 352
    SHADRA_ALOR = 353
    JINTHA_ALOR = 354
    THE_ALTAR_OF_ZUL = 355
    SERADANE = 356
    FERALAS = 357
    BRAMBLEBLADE_RAVINE = 358
    BAEL_MODAN = 359
    THE_VENTURE_CO_MINE = 360
    FELWOOD = 361
    RAZOR_HILL = 362
    VALLEY_OF_TRIALS = 363
    THE_DEN = 364
    BURNING_BLADE_COVEN = 365
    KOLKAR_CRAG = 366
    SEN_JIN_VILLAGE = 367
    ECHO_ISLES = 368
    THUNDER_RIDGE = 369
    DRYGULCH_RAVINE = 370
    DUSTWIND_CAVE = 371
    TIRAGARDE_KEEP = 372
    SCUTTLE_COAST = 373
    BLADEFIST_BAY = 374
    DEADEYE_SHORE = 375
    SOUTHFURY_RIVER = 377
    CAMP_TAURAJO = 378
    FAR_WATCH_POST = 379
    THE_CROSSROADS = 380
    BOULDER_LODE_MINE = 381
    THE_SLUDGE_FEN = 382
    THE_DRY_HILLS = 383
    DREADMIST_PEAK = 384
    NORTHWATCH_HOLD = 385
    THE_FORGOTTEN_POOLS = 386
    LUSHWATER_OASIS = 387
    THE_STAGNANT_OASIS = 388
    FIELD_OF_GIANTS = 390
    THE_MERCHANT_COAST = 391
    RATCHET = 392
    DARKSPEAR_STRAND = 393
    DARROWMERE_LAKE_UNUSED = 394
    CAER_DARROW_UNUSED = 395
    WINTERHOOF_WATER_WELL = 396
    THUNDERHORN_WATER_WELL = 397
    WILDMANE_WATER_WELL = 398
    SKYLINE_RIDGE = 399
    THOUSAND_NEEDLES = 400
    THE_TIDUS_STAIR = 401
    SHADY_REST_INN = 403
    BAEL_DUN_DIGSITE = 404
    DESOLACE = 405
    STONETALON_MOUNTAINS = 406
    ORGRIMMAR_UNUSED = 407
    GILLIJIMS_ISLE = 408
    ISLAND_OF_DOCTOR_LAPIDIS = 409
    RAZORWIND_CANYON = 410
    BATHRANS_HAUNT = 411
    THE_RUINS_OF_ORDIL_ARAN = 412
    MAESTRAS_POST = 413
    THE_ZORAM_STRAND = 414
    ASTRANAAR = 415
    THE_SHRINE_OF_AESSINA = 416
    FIRE_SCAR_SHRINE = 417
    THE_RUINS_OF_STARDUST = 418
    THE_HOWLING_VALE = 419
    SILVERWIND_REFUGE = 420
    MYSTRAL_LAKE = 421
    FALLEN_SKY_LAKE = 422
    IRIS_LAKE = 424
    MOONWELL = 425
    RAYNEWOOD_RETREAT = 426
    THE_SHADY_NOOK = 427
    NIGHT_RUN = 428
    XAVIAN = 429
    SATYRNAAR = 430
    SPLINTERTREE_POST = 431
    THE_DOR_DANIL_BARROW_DEN = 432
    FALFARREN_RIVER = 433
    FELFIRE_HILL = 434
    DEMON_FALL_CANYON = 435
    DEMON_FALL_RIDGE = 436
    WARSONG_LUMBER_CAMP = 437
    BOUGH_SHADOW = 438
    THE_SHIMMERING_FLATS = 439
    TANARIS = 440
    LAKE_FALATHIM = 441
    AUBERDINE = 442
    RUINS_OF_MATHYSTRA = 443
    TOWER_OF_ALTHALAXX = 444
    CLIFFSPRING_FALLS = 445
    BASHAL_ARAN = 446
    AMETH_ARAN = 447
    GROVE_OF_THE_ANCIENTS = 448
    THE_MASTERS_GLAIVE = 449
    REMTRAVELS_EXCAVATION = 450
    MISTS_EDGE = 452
    THE_LONG_WASH = 453
    WILDBEND_RIVER = 454
    BLACKWOOD_DEN = 455
    CLIFFSPRING_RIVER = 456
    THE_VEILED_SEA = 457
    GOLD_ROAD = 458
    SCARLET_WATCH_POST = 459
    SUN_ROCK_RETREAT = 460
    WINDSHEAR_CRAG = 461
    CRAGPOOL_LAKE = 463
    MIRKFALLON_LAKE = 464
    THE_CHARRED_VALE = 465
    VALLEY_OF_THE_BLOODFURIES = 466
    STONETALON_PEAK = 467
    THE_TALON_DEN = 468
    GREATWOOD_VALE = 469
    THUNDER_BLUFF_UNUSED = 470
    BRAVE_WIND_MESA = 471
    FIRE_STONE_MESA = 472
    MANTLE_ROCK = 473
    HUNTER_RISE_UNUSED = 474
    SPIRIT_RISEUNUSED = 475
    ELDER_RISEUNUSED = 476
    RUINS_OF_JUBUWAL = 477
    POOLS_OF_ARLITHRIEN = 478
    THE_RUSTMAUL_DIG_SITE = 479
    CAMP_E_THOK = 480
    SPLITHOOF_CRAG = 481
    HIGHPERCH = 482
    THE_SCREECHING_CANYON = 483
    FREEWIND_POST = 484
    THE_GREAT_LIFT = 485
    GALAK_HOLD = 486
    ROGUEFEATHER_DEN = 487
    THE_WEATHERED_NOOK = 488
    THALANAAR = 489
    UN_GORO_CRATER = 490
    RAZORFEN_KRAUL = 491
    RAVEN_HILL_CEMETERY = 492
    MOONGLADE = 493
    DELETE_ME = 495
    BRACKENWALL_VILLAGE = 496
    SWAMPLIGHT_MANOR = 497
    BLOODFEN_BURROW = 498
    DARKMIST_CAVERN = 499
    MOGGLE_POINT = 500
    BEEZILS_WRECK = 501
    WITCH_HILL = 502
    SENTRY_POINT = 503
    NORTH_POINT_TOWER = 504
    WEST_POINT_TOWER = 505
    LOST_POINT = 506
    BLUEFEN = 507
    STONEMAUL_RUINS = 508
    THE_DEN_OF_FLAME = 509
    THE_DRAGONMURK = 510
    WYRMBOG = 511
    BLACKHOOF_VILLAGE = 512
    THERAMORE_ISLE = 513
    FOOTHOLD_CITADEL = 514
    IRONCLAD_PRISON = 515
    DUSTWALLOW_BAY = 516
    TIDEFURY_COVE = 517
    DREADMURK_SHORE = 518
    ADDLES_STEAD = 536
    FIRE_PLUME_RIDGE = 537
    LAKKARI_TAR_PITS = 538
    TERROR_RUN = 539
    THE_SLITHERING_SCAR = 540
    MARSHALS_REFUGE = 541
    FUNGAL_ROCK = 542
    GOLAKKA_HOT_SPRINGS = 543
    THE_LOCH = 556
    BEGGARS_HAUNT = 576
    KODO_GRAVEYARD = 596
    GHOST_WALKER_POST = 597
    SAR_THERIS_STRAND = 598
    THUNDER_AXE_FORTRESS = 599
    BOLGANS_HOLE = 600
    MANNOROC_COVEN = 602
    SARGERON = 603
    MAGRAM_VILLAGE = 604
    GELKIS_VILLAGE = 606
    VALLEY_OF_SPEARS = 607
    NIJELS_POINT = 608
    KOLKAR_VILLAGE = 609
    HYJAL = 616
    WINTERSPRING = 618
    BLACKWOLF_RIVER = 636
    KODO_ROCK = 637
    HIDDEN_PATH = 638
    SPIRIT_ROCK = 639
    SHRINE_OF_THE_DORMANT_FLAME = 640
    LAKE_ELUNE_ARA = 656
    THE_HARBORAGE = 657
    OUTLAND = 676
    CRAFTSMENS_TERRACE_UNUSED = 696
    TRADESMENS_TERRACE_UNUSED = 697
    THE_TEMPLE_GARDENS_UNUSED = 698
    TEMPLE_OF_ELUNE_UNUSED = 699
    CENARION_ENCLAVE_UNUSED = 700
    WARRIORS_TERRACE_UNUSED = 701
    RUT_THERAN_VILLAGE = 702
    IRONBANDS_COMPOUND = 716
    THE_STOCKADE = 717
    WAILING_CAVERNS = 718
    BLACKFATHOM_DEEPS = 719
    FRAY_ISLAND = 720
    GNOMEREGAN1 = 721
    RAZORFEN_DOWNS = 722
    BAN_ETHIL_HOLLOW = 736
    SCARLET_MONASTERY = 796
    JERODS_LANDING = 797
    RIDGEPOINT_TOWER = 798
    THE_DARKENED_BANK = 799
    COLDRIDGE_PASS = 800
    CHILL_BREEZE_VALLEY = 801
    SHIMMER_RIDGE = 802
    AMBERSTILL_RANCH = 803
    THE_TUNDRID_HILLS = 804
    SOUTH_GATE_PASS = 805
    SOUTH_GATE_OUTPOST = 806
    NORTH_GATE_PASS = 807
    NORTH_GATE_OUTPOST = 808
    GATES_OF_IRONFORGE = 809
    STILLWATER_POND = 810
    NIGHTMARE_VALE = 811
    VENOMWEB_VALE = 812
    THE_BULWARK1 = 813
    SOUTHFURY_RIVER1 = 814
    SOUTHFURY_RIVER2 = 815
    RAZORMANE_GROUNDS = 816
    SKULL_ROCK = 817
    PALEMANE_ROCK = 818
    WINDFURY_RIDGE = 819
    THE_GOLDEN_PLAINS = 820
    THE_ROLLING_PLAINS = 821
    DUN_ALGAZ1 = 836
    DUN_ALGAZ2 = 837
    NORTH_GATE_PASS1 = 838
    SOUTH_GATE_PASS1 = 839
    TWILIGHT_GROVE = 856
    GM_ISLAND = 876
    DELETE_ME1 = 877
    SOUTHFURY_RIVER3 = 878
    SOUTHFURY_RIVER4 = 879
    THANDOL_SPAN1 = 880
    THANDOL_SPAN2 = 881
    PURGATION_ISLE = 896
    THE_JANSEN_STEAD = 916
    THE_DEAD_ACRE = 917
    THE_MOLSEN_FARM = 918
    STENDELS_POND = 919
    THE_DAGGER_HILLS = 920
    DEMONTS_PLACE = 921
    THE_DUST_PLAINS = 922
    STONESPLINTER_VALLEY = 923
    VALLEY_OF_KINGS = 924
    ALGAZ_STATION = 925
    BUCKLEBREE_FARM = 926
    THE_SHINING_STRAND = 927
    NORTH_TIDES_HOLLOW = 928
    GRIZZLEPAW_RIDGE = 936
    THE_VERDANT_FIELDS = 956
    GADGETZAN = 976
    STEAMWHEEDLE_PORT = 977
    ZUL_FARRAK = 978
    SANDSORROW_WATCH = 979
    THISTLESHRUB_VALLEY = 980
    THE_GAPING_CHASM = 981
    THE_NOXIOUS_LAIR = 982
    DUNEMAUL_COMPOUND = 983
    EASTMOON_RUINS = 984
    WATERSPRING_FIELD = 985
    ZALASHJIS_DEN = 986
    LANDS_END_BEACH = 987
    WAVESTRIDER_BEACH = 988
    ULDUM = 989
    VALLEY_OF_THE_WATCHERS = 990
    GUNSTANS_POST = 991
    SOUTHMOON_RUINS = 992
    RENDERS_CAMP = 996
    RENDERS_VALLEY = 997
    RENDERS_ROCK = 998
    STONEWATCH_TOWER = 999
    GALARDELL_VALLEY = 1000
    LAKERIDGE_HIGHWAY = 1001
    THREE_CORNERS = 1002
    DIREFORGE_HILL = 1016
    RAPTOR_RIDGE = 1017
    BLACK_CHANNEL_MARSH = 1018
    THE_GREEN_BELT = 1019
    MOSSHIDE_FEN = 1020
    THELGEN_ROCK = 1021
    BLUEGILL_MARSH = 1022
    SALTSPRAY_GLEN = 1023
    SUNDOWN_MARSH = 1024
    THE_GREEN_BELT1 = 1025
    ANGERFANG_ENCAMPMENT = 1036
    GRIM_BATOL = 1037
    DRAGONMAW_GATES = 1038
    THE_LOST_FLEET = 1039
    DARROW_HILL = 1056
    THORADINS_WALL1 = 1057
    WEBWINDER_PATH = 1076
    THE_HUSHED_BANK = 1097
    MANOR_MISTMANTLE = 1098
    CAMP_MOJACHE = 1099
    GRIMTOTEM_COMPOUND = 1100
    THE_WRITHING_DEEP = 1101
    WILDWIND_LAKE = 1102
    GORDUNNI_OUTPOST = 1103
    MOK_GORDUN = 1104
    FERAL_SCAR_VALE = 1105
    FRAYFEATHER_HIGHLANDS = 1106
    IDLEWIND_LAKE = 1107
    THE_FORGOTTEN_COAST = 1108
    EAST_PILLAR = 1109
    WEST_PILLAR = 1110
    DREAM_BOUGH = 1111
    JADEMIR_LAKE = 1112
    ONEIROS = 1113
    RUINS_OF_RAVENWIND = 1114
    RAGE_SCAR_HOLD = 1115
    FEATHERMOON_STRONGHOLD = 1116
    RUINS_OF_SOLARSAL = 1117
    LOWER_WILDS_UNUSED = 1118
    THE_TWIN_COLOSSALS = 1119
    SARDOR_ISLE = 1120
    ISLE_OF_DREAD = 1121
    HIGH_WILDERNESS = 1136
    LOWER_WILDS = 1137
    SOUTHERN_BARRENS = 1156
    SOUTHERN_GOLD_ROAD = 1157
    ZUL_FARRAK1 = 1176
    UNUSEDALCAZ_ISLAND = 1196
    TIMBERMAW_HOLD = 1216
    VANNDIR_ENCAMPMENT = 1217
    TESTAZSHARA = 1218
    LEGASH_ENCAMPMENT = 1219
    THALASSIAN_BASE_CAMP = 1220
    RUINS_OF_ELDARATH = 1221
    HETAERAS_CLUTCH = 1222
    TEMPLE_OF_ZIN_MALOR = 1223
    BEARS_HEAD = 1224
    URSOLAN = 1225
    TEMPLE_OF_ARKKORAN = 1226
    BAY_OF_STORMS = 1227
    THE_SHATTERED_STRAND = 1228
    TOWER_OF_ELDARA = 1229
    JAGGED_REEF = 1230
    SOUTHRIDGE_BEACH = 1231
    RAVENCREST_MONUMENT = 1232
    FORLORN_RIDGE = 1233
    LAKE_MENNAR = 1234
    SHADOWSONG_SHRINE = 1235
    HALDARR_ENCAMPMENT = 1236
    VALORMOK = 1237
    THE_RUINED_REACHES = 1256
    THE_TALONDEEP_PATH = 1276
    THE_TALONDEEP_PATH1 = 1277
    ROCKTUSK_FARM = 1296
    JAGGEDSWINE_FARM = 1297
    RAZORFEN_DOWNS1 = 1316
    LOST_RIGGER_COVE = 1336
    ULDAMAN = 1337
    LORDAMERE_LAKE1 = 1338
    LORDAMERE_LAKE2 = 1339
    GALLOWS_CORNER = 1357
    SILITHUS = 1377
    EMERALD_FOREST = 1397
    SUNKEN_TEMPLE = 1417
    DREADMAUL_HOLD = 1437
    NETHERGARDE_KEEP = 1438
    DREADMAUL_POST = 1439
    SERPENTS_COIL = 1440
    ALTAR_OF_STORMS1 = 1441
    FIREWATCH_RIDGE = 1442
    THE_SLAG_PIT = 1443
    THE_SEA_OF_CINDERS = 1444
    BLACKROCK_MOUNTAIN2 = 1445
    THORIUM_POINT = 1446
    GARRISON_ARMORY = 1457
    THE_TEMPLE_OF_ATAL_HAKKAR = 1477
    UNDERCITY = 1497
    ULDAMAN1 = 1517
    NOT_USED_DEADMINES = 1518
    STORMWIND_CITY = 1519
    IRONFORGE = 1537
    SPLITHOOF_HOLD = 1557
    THE_CAPE_OF_STRANGLETHORN = 1577
    SOUTHERN_SAVAGE_COAST = 1578
    UNUSED_THE_DEADMINES_002 = 1579
    UNUSED_IRONCLAD_COVE_00THREE = 1580
    THE_DEADMINES = 1581
    IRONCLAD_COVE = 1582
    BLACKROCK_SPIRE = 1583
    BLACKROCK_DEPTHS = 1584
    RAPTOR_GROUNDS_UNUSED = 1597
    GROL_DOM_FARM_UNUSED = 1598
    MORSHAN_BASE_CAMP = 1599
    HONORS_STAND_UNUSED = 1600
    BLACKTHORN_RIDGE_UNUSED = 1601
    BRAMBLESCAR_UNUSED = 1602
    AGAMA_GOR_UNUSED = 1603
    VALLEY_OF_HEROES = 1617
    ORGRIMMAR = 1637
    THUNDER_BLUFF = 1638
    ELDER_RISE = 1639
    SPIRIT_RISE = 1640
    HUNTER_RISE = 1641
    DARNASSUS = 1657
    CENARION_ENCLAVE = 1658
    CRAFTSMENS_TERRACE = 1659
    WARRIORS_TERRACE = 1660
    THE_TEMPLE_GARDENS = 1661
    TRADESMENS_TERRACE = 1662
    GAVINS_NAZE = 1677
    SOFERAS_NAZE = 1678
    CORRAHNS_DAGGER = 1679
    THE_HEADLAND = 1680
    MISTY_SHORE = 1681
    DANDREDS_FOLD = 1682
    GROWLESS_CAVE = 1683
    CHILLWIND_POINT = 1684
    RAPTOR_GROUNDS = 1697
    BRAMBLESCAR = 1698
    THORN_HILL = 1699
    AGAMA_GOR = 1700
    BLACKTHORN_RIDGE = 1701
    HONORS_STAND = 1702
    THE_MORSHAN_RAMPART = 1703
    GROL_DOM_FARM = 1704
    RAZORFEN_KRAUL1 = 1717
    THE_GREAT_LIFT1 = 1718
    MISTVALE_VALLEY = 1737
    NEK_MANI_WELLSPRING = 1738
    BLOODSAIL_COMPOUND = 1739
    VENTURE_CO_BASE_CAMP = 1740
    GURUBASHI_ARENA = 1741
    SPIRIT_DEN = 1742
    THE_CRIMSON_VEIL = 1757
    THE_RIPTIDE = 1758
    THE_DAMSELS_LUCK = 1759
    VENTURE_CO_OPERATIONS_CENTER = 1760
    DEADWOOD_VILLAGE = 1761
    FELPAW_VILLAGE = 1762
    JAEDENAR = 1763
    BLOODVENOM_RIVER = 1764
    BLOODVENOM_FALLS = 1765
    SHATTER_SCAR_VALE = 1766
    IRONTREE_WOODS = 1767
    IRONTREE_CAVERN = 1768
    TIMBERMAW_HOLD1 = 1769
    SHADOW_HOLD = 1770
    SHRINE_OF_THE_DECEIVER = 1771
    ITHARIUSS_CAVE = 1777
    SORROWMURK = 1778
    DRAENIL_DUR_VILLAGE = 1779
    SPLINTERSPEAR_JUNCTION = 1780
    STAGALBOG = 1797
    THE_SHIFTING_MIRE = 1798
    STAGALBOG_CAVE = 1817
    WITHERBARK_CAVERNS = 1837
    THORADINS_WALL2 = 1857
    BOULDER_GOR = 1858
    VALLEY_OF_FANGS = 1877
    THE_DUSTBOWL = 1878
    MIRAGE_FLATS = 1879
    FEATHERBEARDS_HOVEL = 1880
    SHINDIGGERS_CAMP = 1881
    PLAGUEMIST_RAVINE = 1882
    VALORWIND_LAKE = 1883
    AGOL_WATHA = 1884
    HIRI_WATHA = 1885
    THE_CREEPING_RUIN = 1886
    BOGENS_LEDGE = 1887
    THE_MAKERS_TERRACE = 1897
    DUSTWIND_GULCH = 1898
    SHAOL_WATHA = 1917
    NOONSHADE_RUINS = 1937
    BROKEN_PILLAR = 1938
    ABYSSAL_SANDS = 1939
    SOUTHBREAK_SHORE = 1940
    CAVERNS_OF_TIME = 1941
    THE_MARSHLANDS = 1942
    IRONSTONE_PLATEAU = 1943
    BLACKCHAR_CAVE = 1957
    TANNER_CAMP = 1958
    DUSTFIRE_VALLEY = 1959
    ZUL_GURUB1 = 1977
    MISTY_REED_POST = 1978
    BLOODVENOM_POST = 1997
    TALONBRANCH_GLADE = 1998
    STRATHOLME = 2017
    QUEL_THALAS = 2037
    SCHOLOMANCE = 2057
    TWILIGHT_VALE = 2077
    TWILIGHT_SHORE = 2078
    ALCAZ_ISLAND = 2079
    DARKCLOUD_PINNACLE = 2097
    DAWNING_WOOD_CATACOMBS = 2098
    STONEWATCH_KEEP = 2099
    MARAUDON = 2100
    STOUTLAGER_INN = 2101
    THUNDERBREW_DISTILLERY = 2102
    MENETHIL_KEEP = 2103
    DEEPWATER_TAVERN = 2104
    SHADOW_GRAVE = 2117
    BRILL_TOWN_HALL = 2118
    GALLOWS_END_TAVERN = 2119
    THE_POOLS_OF_VISIONUNUSED = 2137
    DREADMIST_DEN = 2138
    BAEL_DUN_KEEP = 2157
    EMBERSTRIFES_DEN = 2158
    ONYXIAS_LAIR = 2159
    WINDSHEAR_MINE = 2160
    ROLANDS_DOOM = 2161
    BATTLE_RING = 2177
    THE_POOLS_OF_VISION = 2197
    SHADOWBREAK_RAVINE = 2198
    BROKEN_SPEAR_VILLAGE = 2217
    WHITEREACH_POST = 2237
    GORNIA = 2238
    ZANES_EYE_CRATER = 2239
    MIRAGE_RACEWAY = 2240
    FROSTSABER_ROCK = 2241
    THE_HIDDEN_GROVE = 2242
    TIMBERMAW_POST = 2243
    WINTERFALL_VILLAGE = 2244
    MAZTHORIL = 2245
    FROSTFIRE_HOT_SPRINGS = 2246
    ICE_THISTLE_HILLS = 2247
    DUN_MANDARR = 2248
    FROSTWHISPER_GORGE = 2249
    OWL_WING_THICKET = 2250
    LAKE_KEL_THERIL = 2251
    THE_RUINS_OF_KEL_THERIL = 2252
    STARFALL_VILLAGE = 2253
    BAN_THALLOW_BARROW_DEN = 2254
    EVERLOOK = 2255
    DARKWHISPER_GORGE = 2256
    DEEPRUN_TRAM = 2257
    THE_FUNGAL_VALE = 2258
    UNUSEDTHE_MARRIS_STEAD = 2259
    THE_MARRIS_STEAD = 2260
    THE_UNDERCROFT = 2261
    DARROWSHIRE = 2262
    CROWN_GUARD_TOWER = 2263
    CORINS_CROSSING = 2264
    SCARLET_BASE_CAMP = 2265
    TYRS_HAND = 2266
    THE_SCARLET_BASILICA = 2267
    LIGHTS_HOPE_CHAPEL = 2268
    BROWMAN_MILL = 2269
    THE_NOXIOUS_GLADE = 2270
    EASTWALL_TOWER = 2271
    NORTHDALE = 2272
    ZUL_MASHAR = 2273
    MAZRA_ALOR = 2274
    NORTHPASS_TOWER = 2275
    QUEL_LITHIEN_LODGE = 2276
    PLAGUEWOOD = 2277
    SCOURGEHOLD = 2278
    STRATHOLME1 = 2279
    UNUSED_STRATHOLME = 2280
    DARROWMERE_LAKE = 2297
    CAER_DARROW = 2298
    DARROWMERE_LAKE1 = 2299
    CAVERNS_OF_TIME1 = 2300
    THISTLEFUR_VILLAGE = 2301
    THE_QUAGMIRE = 2302
    WINDBREAK_CANYON = 2303
    SOUTH_SEAS = 2317
    THE_GREAT_SEA3 = 2318
    THE_GREAT_SEA4 = 2319
    THE_GREAT_SEA5 = 2320
    THE_GREAT_SEA6 = 2321
    THE_VEILED_SEA1 = 2322
    THE_VEILED_SEA2 = 2323
    THE_VEILED_SEA3 = 2324
    THE_VEILED_SEA4 = 2325
    THE_VEILED_SEA5 = 2326
    RAZOR_HILL_BARRACKS = 2337
    SOUTH_SEAS1 = 2338
    THE_GREAT_SEA7 = 2339
    BLOODTOOTH_CAMP = 2357
    FOREST_SONG = 2358
    GREENPAW_VILLAGE = 2359
    SILVERWING_OUTPOST = 2360
    NIGHTHAVEN = 2361
    SHRINE_OF_REMULOS = 2362
    STORMRAGE_BARROW_DENS = 2363
    THE_GREAT_SEA8 = 2364
    THE_GREAT_SEA9 = 2365
    THE_BLACK_MORASS = 2366
    OLD_HILLSBRAD_FOOTHILLS = 2367
    TARREN_MILL1 = 2368
    SOUTHSHORE1 = 2369
    DURNHOLDE_KEEP1 = 2370
    DUN_GAROK1 = 2371
    HILLSBRAD_FIELDS1 = 2372
    EASTERN_STRAND1 = 2373
    NETHANDER_STEAD1 = 2374
    DARROW_HILL1 = 2375
    SOUTHPOINT_TOWER1 = 2376
    THORADINS_WALL3 = 2377
    WESTERN_STRAND1 = 2378
    AZURELODE_MINE1 = 2379
    THE_GREAT_SEA10 = 2397
    THE_GREAT_SEA11 = 2398
    THE_GREAT_SEA12 = 2399
    THE_FORBIDDING_SEA1 = 2400
    THE_FORBIDDING_SEA2 = 2401
    THE_FORBIDDING_SEA3 = 2402
    THE_FORBIDDING_SEA4 = 2403
    TETHRIS_ARAN = 2404
    ETHEL_RETHOR = 2405
    RANAZJAR_ISLE = 2406
    KORMEKS_HUT = 2407
    SHADOWPREY_VILLAGE = 2408
    BLACKROCK_PASS = 2417
    MORGANS_VIGIL = 2418
    SLITHER_ROCK = 2419
    TERROR_WING_PATH = 2420
    DRACO_DAR = 2421
    RAGEFIRE_CHASM = 2437
    NIGHTSONG_WOODS = 2457
    THE_VEILED_SEA6 = 2477
    MORLOS_ARAN = 2478
    EMERALD_SANCTUARY = 2479
    JADEFIRE_GLEN = 2480
    RUINS_OF_CONSTELLAS = 2481
    BITTER_REACHES = 2497
    RISE_OF_THE_DEFILER = 2517
    LARISS_PAVILION = 2518
    WOODPAW_HILLS = 2519
    WOODPAW_DEN = 2520
    VERDANTIS_RIVER = 2521
    RUINS_OF_ISILDIEN = 2522
    GRIMTOTEM_POST = 2537
    CAMP_APARAJE = 2538
    MALAKA_JIN = 2539
    BOULDERSLIDE_RAVINE = 2540
    SISHIR_CANYON = 2541
    DIRE_MAUL = 2557
    DEADWIND_RAVINE = 2558
    DIAMONDHEAD_RIVER = 2559
    ARIDENS_CAMP = 2560
    THE_VICE = 2561
    KARAZHAN = 2562
    MORGANS_PLOT = 2563
    DIRE_MAUL1 = 2577
    ALTERAC_VALLEY = 2597
    SCRABBLESCREWS_CAMP = 2617
    JADEFIRE_RUN = 2618
    THONDRORIL_RIVER = 2619
    THONDRORIL_RIVER1 = 2620
    LAKE_MERELDAR = 2621
    PESTILENT_SCAR = 2622
    THE_INFECTIS_SCAR = 2623
    BLACKWOOD_LAKE = 2624
    EASTWALL_GATE = 2625
    TERRORWEB_TUNNEL = 2626
    TERRORDALE = 2627
    KARGATHIA_KEEP = 2637
    VALLEY_OF_BONES = 2657
    BLACKWING_LAIR = 2677
    DEADMANS_CROSSING = 2697
    MOLTEN_CORE = 2717
    THE_SCARAB_WALL = 2737
    SOUTHWIND_VILLAGE = 2738
    TWILIGHT_BASE_CAMP = 2739
    THE_CRYSTAL_VALE = 2740
    THE_SCARAB_DAIS = 2741
    HIVE_ASHI = 2742
    HIVE_ZORA = 2743
    HIVE_REGAL = 2744
    SHRINE_OF_THE_FALLEN_WARRIOR = 2757
    UNUSED_ALTERAC_VALLEY = 2777
    BLACKFATHOM_DEEPS1 = 2797
    REUSE_ME_4 = 2817
    THE_MASTERS_CELLAR = 2837
    STONEWROUGHT_PASS = 2838
    ALTERAC_VALLEY1 = 2839
    THE_RUMBLE_CAGE = 2857
    CHUNK_TEST = 2877
    ZORAM_GAR_OUTPOST = 2897
    HALL_OF_LEGENDS = 2917
    CHAMPIONS_HALL = 2918
    GROSH_GOK_COMPOUND = 2937
    SLEEPING_GORGE = 2938
    IRONDEEP_MINE = 2957
    STONEHEARTH_OUTPOST = 2958
    DUN_BALDAR = 2959
    ICEWING_PASS = 2960
    FROSTWOLF_VILLAGE = 2961
    TOWER_POINT = 2962
    COLDTOOTH_MINE = 2963
    WINTERAX_HOLD = 2964
    ICEBLOOD_GARRISON = 2977
    FROSTWOLF_KEEP = 2978
    TOR_KREN_FARM = 2979
    FROST_DAGGER_PASS = 3017
    IRONSTONE_CAMP = 3037
    WEAZELS_CRATER = 3038
    TAHONDA_RUINS = 3039
    FIELD_OF_STRIFE = 3057
    ICEWING_CAVERN = 3058
    VALORS_REST = 3077
    THE_SWARMING_PILLAR = 3097
    TWILIGHT_POST = 3098
    TWILIGHT_OUTPOST = 3099
    RAVAGED_TWILIGHT_CAMP = 3100
    SHALZARUS_LAIR = 3117
    TALRENDIS_POINT = 3137
    RETHRESS_SANCTUM = 3138
    MOON_HORROR_DEN = 3139
    SCALEBEARDS_CAVE = 3140
    BOULDERSLIDE_CAVERN = 3157
    WARSONG_LABOR_CAMP = 3177
    CHILLWIND_CAMP = 3197
    THE_MAUL = 3217
    THE_MAUL_UNUSED = 3237
    BONES_OF_GRAKKAROND = 3257
    WARSONG_GULCH = 3277
    FROSTWOLF_GRAVEYARD = 3297
    FROSTWOLF_PASS = 3298
    DUN_BALDAR_PASS = 3299
    ICEBLOOD_GRAVEYARD = 3300
    SNOWFALL_GRAVEYARD = 3301
    STONEHEARTH_GRAVEYARD = 3302
    STORMPIKE_GRAVEYARD = 3303
    ICEWING_BUNKER = 3304
    STONEHEARTH_BUNKER = 3305
    WILDPAW_RIDGE = 3306
    REVANTUSK_VILLAGE = 3317
    ROCK_OF_DUROTAN = 3318
    SILVERWING_GROVE = 3319
    WARSONG_LUMBER_MILL = 3320
    SILVERWING_HOLD = 3321
    WILDPAW_CAVERN = 3337
    THE_VEILED_CLEFT = 3338
    YOJAMBA_ISLE = 3357
    ARATHI_BASIN = 3358
    THE_COIL = 3377
    ALTAR_OF_HIR_EEK = 3378
    SHADRA_ZAAR = 3379
    HAKKARI_GROUNDS = 3380
    NAZE_OF_SHIRVALLAH = 3381
    TEMPLE_OF_BETHEKK = 3382
    THE_BLOODFIRE_PIT = 3383
    ALTAR_OF_THE_BLOOD_GOD = 3384
    ZANZAS_RISE = 3397
    EDGE_OF_MADNESS = 3398
    TROLLBANE_HALL = 3417
    DEFILERS_DEN = 3418
    PAGLES_POINTE = 3419
    FARM = 3420
    BLACKSMITH = 3421
    LUMBER_MILL = 3422
    GOLD_MINE = 3423
    STABLES = 3424
    CENARION_HOLD = 3425
    STAGHELM_POINT = 3426
    BRONZEBEARD_ENCAMPMENT = 3427
    AHN_QIRAJ = 3428
    RUINS_OF_AHN_QIRAJ = 3429
    EVERSONG_WOODS = 3430
    SUNSTRIDER_ISLE = 3431
    SHRINE_OF_DATH_REMAR = 3432
    GHOSTLANDS = 3433
    SCARAB_TERRACE = 3434
    GENERALS_TERRACE = 3435
    THE_RESERVOIR = 3436
    THE_HATCHERY = 3437
    THE_COMB = 3438
    WATCHERS_TERRACE = 3439
    SCARAB_TERRACE1 = 3440
    GENERALS_TERRACE1 = 3441
    THE_RESERVOIR1 = 3442
    THE_HATCHERY1 = 3443
    THE_COMB1 = 3444
    WATCHERS_TERRACE1 = 3445
    TWILIGHTS_RUN = 3446
    ORTELLS_HIDEOUT = 3447
    SCARAB_TERRACE2 = 3448
    GENERALS_TERRACE2 = 3449
    THE_RESERVOIR2 = 3450
    THE_HATCHERY2 = 3451
    THE_COMB2 = 3452
    WATCHERS_TERRACE2 = 3453
    RUINS_OF_AHN_QIRAJ1 = 3454
    THE_NORTH_SEA = 3455
    NAXXRAMAS = 3456
    KARAZHAN1 = 3457
    CITY = 3459
    GOLDEN_STRAND = 3460
    SUNSAIL_ANCHORAGE = 3461
    FAIRBREEZE_VILLAGE = 3462
    MAGISTERS_GATE = 3463
    FARSTRIDER_RETREAT = 3464
    NORTH_SANCTUM = 3465
    WEST_SANCTUM = 3466
    EAST_SANCTUM = 3467
    SALTHERILS_HAVEN = 3468
    THURONS_LIVERY = 3469
    STILLWHISPER_POND = 3470
    THE_LIVING_WOOD = 3471
    AZUREBREEZE_COAST = 3472
    LAKE_ELRENDAR = 3473
    THE_SCORCHED_GROVE = 3474
    ZEB_WATHA = 3475
    TOR_WATHA = 3476
    KARAZHAN_UNUSED = 3477
    GATES_OF_AHN_QIRAJ = 3478
    THE_VEILED_SEA7 = 3479
    DUSKWITHER_GROUNDS = 3480
    DUSKWITHER_SPIRE = 3481
    THE_DEAD_SCAR = 3482
    HELLFIRE_PENINSULA = 3483
    THE_SUNSPIRE = 3484
    FALTHRIEN_ACADEMY = 3485
    RAVENHOLDT_MANOR = 3486
    SILVERMOON_CITY = 3487
    TRANQUILLIEN = 3488
    SUNCROWN_VILLAGE = 3489
    GOLDENMIST_VILLAGE = 3490
    WINDRUNNER_VILLAGE = 3491
    WINDRUNNER_SPIRE = 3492
    SANCTUM_OF_THE_SUN = 3493
    SANCTUM_OF_THE_MOON = 3494
    DAWNSTAR_SPIRE = 3495
    FARSTRIDER_ENCLAVE = 3496
    AN_DAROTH = 3497
    AN_TELAS = 3498
    AN_OWYN = 3499
    DEATHOLME = 3500
    BLEEDING_ZIGGURAT = 3501
    HOWLING_ZIGGURAT = 3502
    SHALANDIS_ISLE = 3503
    TORYL_ESTATE = 3504
    UNDERLIGHT_MINES = 3505
    ANDILIEN_ESTATE = 3506
    HATCHET_HILLS = 3507
    AMANI_PASS = 3508
    SUNGRAZE_PEAK = 3509
    AMANI_CATACOMBS = 3510
    TOWER_OF_THE_DAMNED = 3511
    ZEB_SORA = 3512
    LAKE_ELRENDAR1 = 3513
    THE_DEAD_SCAR1 = 3514
    ELRENDAR_RIVER = 3515
    ZEB_TELA = 3516
    ZEB_NOWA = 3517
    NAGRAND = 3518
    TEROKKAR_FOREST = 3519
    SHADOWMOON_VALLEY = 3520
    ZANGARMARSH = 3521
    BLADES_EDGE_MOUNTAINS = 3522
    NETHERSTORM = 3523
    AZUREMYST_ISLE = 3524
    BLOODMYST_ISLE = 3525
    AMMEN_VALE = 3526
    CRASH_SITE = 3527
    SILVERLINE_LAKE = 3528
    NESTLEWOOD_THICKET = 3529
    SHADOW_RIDGE = 3530
    SKULKING_ROW = 3531
    DAWNING_LANE = 3532
    RUINS_OF_SILVERMOON = 3533
    FETHS_WAY = 3534
    HELLFIRE_CITADEL = 3535
    THRALLMAR = 3536
    REUSE = 3537
    HONOR_HOLD = 3538
    THE_STAIR_OF_DESTINY = 3539
    TWISTING_NETHER = 3540
    FORGE_CAMP_MAGEDDON = 3541
    THE_PATH_OF_GLORY = 3542
    THE_GREAT_FISSURE = 3543
    PLAIN_OF_SHARDS = 3544
    HELLFIRE_CITADEL1 = 3545
    EXPEDITION_ARMORY = 3546
    THRONE_OF_KIL_JAEDEN = 3547
    FORGE_CAMP_RAGE = 3548
    INVASION_POINT_ANNIHILATOR = 3549
    BORUNE_RUINS = 3550
    RUINS_OF_SHA_NAAR = 3551
    TEMPLE_OF_TELHAMAT = 3552
    POOLS_OF_AGGONAR = 3553
    FALCON_WATCH = 3554
    MAG_HAR_POST = 3555
    DEN_OF_HAAL_ESH = 3556
    THE_EXODAR = 3557
    ELRENDAR_FALLS = 3558
    NESTLEWOOD_HILLS = 3559
    AMMEN_FIELDS = 3560
    THE_SACRED_GROVE = 3561
    HELLFIRE_RAMPARTS = 3562
    HELLFIRE_CITADEL2 = 3563
    EMBERGLADE = 3564
    CENARION_REFUGE = 3565
    MOONWING_DEN = 3566
    POD_CLUSTER = 3567
    POD_WRECKAGE = 3568
    TIDES_HOLLOW = 3569
    WRATHSCALE_POINT = 3570
    BRISTLELIMB_VILLAGE = 3571
    STILLPINE_HOLD = 3572
    ODESYUS_LANDING = 3573
    VALAARS_BERTH = 3574
    SILTING_SHORE = 3575
    AZURE_WATCH = 3576
    GEEZLES_CAMP = 3577
    MENAGERIE_WRECKAGE = 3578
    TRAITORS_COVE = 3579
    WILDWIND_PEAK = 3580
    WILDWIND_PATH = 3581
    ZETH_GOR = 3582
    BERYL_COAST = 3583
    BLOOD_WATCH = 3584
    BLADEWOOD = 3585
    THE_VECTOR_COIL = 3586
    THE_WARP_PISTON = 3587
    THE_CRYO_CORE = 3588
    THE_CRIMSON_REACH = 3589
    WRATHSCALE_LAIR = 3590
    RUINS_OF_LORETH_ARAN = 3591
    NAZZIVIAN = 3592
    AXXARIEN = 3593
    BLACKSILT_SHORE = 3594
    THE_FOUL_POOL = 3595
    THE_HIDDEN_REEF = 3596
    AMBERWEB_PASS = 3597
    WYRMSCAR_ISLAND = 3598
    TALON_STAND = 3599
    BRISTLELIMB_ENCLAVE = 3600
    RAGEFEATHER_RIDGE = 3601
    KESSELS_CROSSING = 3602
    TEL_ATHIONS_CAMP = 3603
    THE_BLOODCURSED_REEF = 3604
    HYJAL_PAST = 3605
    HYJAL_SUMMIT = 3606
    SERPENTSHRINE_CAVERN = 3607
    VINDICATORS_REST = 3608
    UNUSEDTHREE = 3609
    BURNING_BLADE_RUINS = 3610
    CLAN_WATCH = 3611
    BLOODCURSE_ISLE = 3612
    GARADAR = 3613
    SKYSONG_LAKE = 3614
    THRONE_OF_THE_ELEMENTS = 3615
    LAUGHING_SKULL_RUINS = 3616
    WARMAUL_HILL = 3617
    GRUULS_LAIR = 3618
    AUREN_RIDGE = 3619
    AUREN_FALLS = 3620
    LAKE_SUNSPRING = 3621
    SUNSPRING_POST = 3622
    AERIS_LANDING = 3623
    FORGE_CAMP_FEAR = 3624
    FORGE_CAMP_HATE = 3625
    TELAAR = 3626
    NORTHWIND_CLEFT = 3627
    HALAA = 3628
    SOUTHWIND_CLEFT = 3629
    OSHU_GUN = 3630
    SPIRIT_FIELDS = 3631
    SHAMANAR = 3632
    ANCESTRAL_GROUNDS = 3633
    WINDYREED_VILLAGE = 3634
    UNUSED2 = 3635
    ELEMENTAL_PLATEAU = 3636
    KILSORROW_FORTRESS = 3637
    THE_RING_OF_TRIALS = 3638
    SILVERMYST_ISLE = 3639
    DAGGERFEN_VILLAGE = 3640
    UMBRAFEN_VILLAGE = 3641
    FERALFEN_VILLAGE = 3642
    BLOODSCALE_ENCLAVE = 3643
    TELREDOR = 3644
    ZABRA_JIN = 3645
    QUAGG_RIDGE = 3646
    THE_SPAWNING_GLEN = 3647
    THE_DEAD_MIRE = 3648
    SPOREGGAR = 3649
    ANGO_ROSH_GROUNDS = 3650
    ANGO_ROSH_STRONGHOLD = 3651
    FUNGGOR_CAVERN = 3652
    SERPENT_LAKE = 3653
    THE_DRAIN = 3654
    UMBRAFEN_LAKE = 3655
    MARSHLIGHT_LAKE = 3656
    PORTAL_CLEARING = 3657
    SPOREWIND_LAKE = 3658
    THE_LAGOON = 3659
    BLADES_RUN = 3660
    BLADE_TOOTH_CANYON = 3661
    COMMONS_HALL = 3662
    DERELICT_MANOR = 3663
    HUNTRESS_OF_THE_SUN = 3664
    FALCONWING_SQUARE = 3665
    HALAANI_BASIN = 3666
    HEWN_BOG = 3667
    BOHA_MU_RUINS = 3668
    THE_STADIUM = 3669
    THE_OVERLOOK = 3670
    BROKEN_HILL = 3671
    MAG_HARI_PROCESSION = 3672
    NESINGWARY_SAFARI = 3673
    CENARION_THICKET = 3674
    TUUREM = 3675
    VEIL_SHIENOR = 3676
    VEIL_SKITH = 3677
    VEIL_SHALAS = 3678
    SKETTIS = 3679
    BLACKWIND_VALLEY = 3680
    FIREWING_POINT = 3681
    GRANGOL_VAR_VILLAGE = 3682
    STONEBREAKER_HOLD = 3683
    ALLERIAN_STRONGHOLD = 3684
    BONECHEWER_RUINS = 3685
    VEIL_LITHIC = 3686
    OLEMBAS = 3687
    AUCHINDOUN = 3688
    VEIL_RESKK = 3689
    BLACKWIND_LAKE = 3690
    LAKE_ERE_NORU = 3691
    LAKE_JORUNE = 3692
    SKETHYL_MOUNTAINS = 3693
    MISTY_RIDGE = 3694
    THE_BROKEN_HILLS = 3695
    THE_BARRIER_HILLS = 3696
    THE_BONE_WASTES = 3697
    NAGRAND_ARENA = 3698
    LAUGHING_SKULL_COURTYARD = 3699
    THE_RING_OF_BLOOD = 3700
    ARENA_FLOOR = 3701
    BLADES_EDGE_ARENA = 3702
    SHATTRATH_CITY = 3703
    THE_SHEPHERDS_GATE = 3704
    TELAARI_BASIN = 3705
    THE_DARK_PORTAL1 = 3706
    ALLIANCE_BASE = 3707
    HORDE_ENCAMPMENT = 3708
    NIGHT_ELF_VILLAGE = 3709
    NORDRASSIL = 3710
    REUSE_ME = 3711
    AREA_52 = 3712
    THE_BLOOD_FURNACE = 3713
    THE_SHATTERED_HALLS = 3714
    THE_STEAMVAULT = 3715
    THE_UNDERBOG = 3716
    THE_SLAVE_PENS = 3717
    SWAMPRAT_POST = 3718
    BLEEDING_HOLLOW_RUINS = 3719
    TWIN_SPIRE_RUINS = 3720
    THE_CRUMBLING_WASTE = 3721
    MANAFORGE_ARA = 3722
    ARKLON_RUINS = 3723
    COSMOWRENCH = 3724
    RUINS_OF_ENKAAT = 3725
    MANAFORGE_B_NAAR = 3726
    THE_SCRAP_FIELD = 3727
    THE_VORTEX_FIELDS = 3728
    THE_HEAP = 3729
    MANAFORGE_CORUU = 3730
    THE_TEMPEST_RIFT = 3731
    KIRIN_VAR_VILLAGE = 3732
    THE_VIOLET_TOWER = 3733
    MANAFORGE_DURO = 3734
    VOIDWIND_PLATEAU = 3735
    MANAFORGE_ULTRIS = 3736
    CELESTIAL_RIDGE = 3737
    THE_STORMSPIRE = 3738
    FORGE_BASE_OBLIVION = 3739
    FORGE_BASE_GEHENNA = 3740
    RUINS_OF_FARAHLON = 3741
    SOCRETHARS_SEAT = 3742
    LEGION_HOLD = 3743
    SHADOWMOON_VILLAGE = 3744
    WILDHAMMER_STRONGHOLD = 3745
    THE_HAND_OF_GUL_DAN = 3746
    THE_FEL_PITS = 3747
    THE_DEATHFORGE = 3748
    COILSKAR_CISTERN = 3749
    COILSKAR_POINT = 3750
    SUNFIRE_POINT = 3751
    ILLIDARI_POINT = 3752
    RUINS_OF_BAA_RI = 3753
    ALTAR_OF_SHA_TAR = 3754
    THE_STAIR_OF_DOOM = 3755
    RUINS_OF_KARABOR = 3756
    ATA_MAL_TERRACE = 3757
    NETHERWING_FIELDS = 3758
    NETHERWING_LEDGE = 3759
    THE_BARRIER_HILLS1 = 3760
    THE_HIGH_PATH = 3761
    WINDYREED_PASS = 3762
    ZANGAR_RIDGE = 3763
    THE_TWILIGHT_RIDGE = 3764
    RAZORTHORN_TRAIL = 3765
    OREBOR_HARBORAGE = 3766
    BLADES_RUN1 = 3767
    JAGGED_RIDGE = 3768
    THUNDERLORD_STRONGHOLD = 3769
    BLADE_TOOTH_CANYON1 = 3770
    THE_LIVING_GROVE = 3771
    SYLVANAAR = 3772
    BLADESPIRE_HOLD = 3773
    GRUULS_LAIR1 = 3774
    CIRCLE_OF_BLOOD = 3775
    BLOODMAUL_OUTPOST = 3776
    BLOODMAUL_CAMP = 3777
    DRAENETHYST_MINE = 3778
    TROGMAS_CLAIM = 3779
    BLACKWING_COVEN = 3780
    GRISHNATH = 3781
    VEIL_LASHH = 3782
    VEIL_VEKH = 3783
    FORGE_CAMP_TERROR = 3784
    FORGE_CAMP_WRATH = 3785
    OGRI_LA = 3786
    FORGE_CAMP_ANGER = 3787
    THE_LOW_PATH = 3788
    SHADOW_LABYRINTH = 3789
    AUCHENAI_CRYPTS = 3790
    SETHEKK_HALLS = 3791
    MANA_TOMBS = 3792
    FELSPARK_RAVINE = 3793
    VALLEY_OF_BONES1 = 3794
    SHA_NAARI_WASTES = 3795
    THE_WARP_FIELDS = 3796
    FALLEN_SKY_RIDGE = 3797
    HAAL_ESHI_GORGE = 3798
    STONEWALL_CANYON = 3799
    THORNFANG_HILL = 3800
    MAG_HAR_GROUNDS = 3801
    VOID_RIDGE = 3802
    THE_ABYSSAL_SHELF = 3803
    THE_LEGION_FRONT = 3804
    ZUL_AMAN = 3805
    SUPPLY_CARAVAN = 3806
    REAVERS_FALL = 3807
    CENARION_POST = 3808
    SOUTHERN_RAMPART = 3809
    NORTHERN_RAMPART = 3810
    GOR_GAZ_OUTPOST = 3811
    SPINEBREAKER_POST = 3812
    THE_PATH_OF_ANGUISH = 3813
    EAST_SUPPLY_CARAVAN = 3814
    EXPEDITION_POINT = 3815
    ZEPPELIN_CRASH = 3816
    TESTING = 3817
    BLOODSCALE_GROUNDS = 3818
    DARKCREST_ENCLAVE = 3819
    EYE_OF_THE_STORM = 3820
    WARDENS_CAGE = 3821
    ECLIPSE_POINT = 3822
    ISLE_OF_TRIBULATIONS = 3823
    BLOODMAUL_RAVINE = 3824
    DRAGONS_END = 3825
    DAGGERMAW_CANYON = 3826
    VEKHAAR_STAND = 3827
    RUUAN_WEALD = 3828
    VEIL_RUUAN = 3829
    RAVENS_WOOD = 3830
    DEATHS_DOOR = 3831
    VORTEX_PINNACLE = 3832
    RAZOR_RIDGE = 3833
    RIDGE_OF_MADNESS = 3834
    DUSTQUILL_RAVINE = 3835
    MAGTHERIDONS_LAIR = 3836
    SUNFURY_HOLD = 3837
    SPINEBREAKER_MOUNTAINS = 3838
    ABANDONED_ARMORY = 3839
    THE_BLACK_TEMPLE = 3840
    DARKCREST_SHORE = 3841
    TEMPEST_KEEP = 3842
    MOK_NATHAL_VILLAGE = 3844
    TEMPEST_KEEP1 = 3845
    THE_ARCATRAZ = 3846
    THE_BOTANICA = 3847
    THE_ARCATRAZ1 = 3848
    THE_MECHANAR = 3849
    NETHERSTONE = 3850
    MIDREALM_POST = 3851
    TULUMANS_LANDING = 3852
    PROTECTORATE_WATCH_POST = 3854
    CIRCLE_OF_BLOOD_ARENA = 3855
    ELRENDAR_CROSSING = 3856
    AMMEN_FORD = 3857
    RAZORTHORN_SHELF = 3858
    SILMYR_LAKE = 3859
    RAASTOK_GLADE = 3860
    THALASSIAN_PASS = 3861
    CHURNING_GULCH = 3862
    BROKEN_WILDS = 3863
    BASH_IR_LANDING = 3864
    CRYSTAL_SPINE = 3865
    SKALD = 3866
    BLADED_GULCH = 3867
    GYRO_PLANK_BRIDGE = 3868
    MAGE_TOWER = 3869
    BLOOD_ELF_TOWER = 3870
    DRAENEI_RUINS = 3871
    FEL_REAVER_RUINS = 3872
    THE_PROVING_GROUNDS = 3873
    ECO_DOME_FARFIELD = 3874
    ECO_DOME_SKYPERCH = 3875
    ECO_DOME_SUTHERON = 3876
    ECO_DOME_MIDREALM = 3877
    ETHEREUM_STAGING_GROUNDS = 3878
    CHAPEL_YARD = 3879
    ACCESS_SHAFT_ZEON = 3880
    TRELLEUM_MINE = 3881
    INVASION_POINT_DESTROYER = 3882
    CAMP_OF_BOOM = 3883
    SPINEBREAKER_PASS = 3884
    NETHERWEB_RIDGE = 3885
    DERELICT_CARAVAN = 3886
    REFUGEE_CARAVAN = 3887
    SHADOW_TOMB = 3888
    VEIL_RHAZE = 3889
    TOMB_OF_LIGHTS = 3890
    CARRION_HILL = 3891
    WRITHING_MOUND = 3892
    RING_OF_OBSERVANCE = 3893
    AUCHENAI_GROUNDS = 3894
    CENARION_WATCHPOST = 3895
    ALDOR_RISE = 3896
    TERRACE_OF_LIGHT = 3897
    SCRYERS_TIER = 3898
    LOWER_CITY = 3899
    INVASION_POINT_OVERLORD = 3900
    ALLERIAN_POST = 3901
    STONEBREAKER_CAMP = 3902
    BOULDER_MOK = 3903
    CURSED_HOLLOW = 3904
    COILFANG_RESERVOIR = 3905
    THE_BLOODWASH = 3906
    VERIDIAN_POINT = 3907
    MIDDENVALE = 3908
    THE_LOST_FOLD = 3909
    MYSTWOOD = 3910
    TRANQUIL_SHORE = 3911
    GOLDENBOUGH_PASS = 3912
    RUNESTONE_FALITHAS = 3913
    RUNESTONE_SHAN_DOR = 3914
    FAIRBRIDGE_STRAND = 3915
    MOONGRAZE_WOODS = 3916
    AUCHINDOUN1 = 3917
    TOSHLEYS_STATION = 3918
    SINGING_RIDGE = 3919
    SHATTER_POINT = 3920
    ARKLONIS_RIDGE = 3921
    BLADESPIRE_OUTPOST = 3922
    GRUULS_LAIR2 = 3923
    NORTHMAUL_TOWER = 3924
    SOUTHMAUL_TOWER = 3925
    SHATTERED_PLAINS = 3926
    ORONOKS_FARM = 3927
    THE_ALTAR_OF_DAMNATION = 3928
    THE_PATH_OF_CONQUEST = 3929
    ECLIPSION_FIELDS = 3930
    BLADESPIRE_GROUNDS = 3931
    SKETH_LON_BASE_CAMP = 3932
    SKETH_LON_WRECKAGE = 3933
    TOWN_SQUARE = 3934
    WIZARD_ROW = 3935
    DEATHFORGE_TOWER = 3936
    SLAG_WATCH = 3937
    SANCTUM_OF_THE_STARS = 3938
    DRAGONMAW_FORTRESS = 3939
    THE_FETID_POOL = 3940
    TEST = 3941
    RAZAANS_LANDING = 3942
    INVASION_POINT_CATACLYSM = 3943
    THE_ALTAR_OF_SHADOWS = 3944
    NETHERWING_PASS = 3945
    WAYNES_REFUGE = 3946
    THE_SCALDING_POOLS = 3947
    BRIAN_AND_PAT_TEST = 3948
    MAGMA_FIELDS = 3949
    CRIMSON_WATCH = 3950
    EVERGROVE = 3951
    WYRMSKULL_BRIDGE = 3952
    SCALEWING_SHELF = 3953
    WYRMSKULL_TUNNEL = 3954
    HELLFIRE_BASIN = 3955
    THE_SHADOW_STAIR = 3956
    SHA_TARI_OUTPOST = 3957
    SHA_TARI_BASE_CAMP = 3958
    BLACK_TEMPLE = 3959
    SOULGRINDERS_BARROW = 3960
    SORROW_WING_POINT = 3961
    VIM_GOLS_CIRCLE = 3962
    DRAGONSPINE_RIDGE = 3963
    SKYGUARD_OUTPOST = 3964
    NETHERWING_MINES = 3965
    DRAGONMAW_BASE_CAMP = 3966
    DRAGONMAW_SKYWAY = 3967
    RUINS_OF_LORDAERON1 = 3968
    RIVENDARKS_PERCH = 3969
    OBSIDIAS_PERCH = 3970
    INSIDIONS_PERCH = 3971
    FURYWINGS_PERCH = 3972
    BLACKWIND_LANDING = 3973
    VEIL_HARR_IK = 3974
    TEROKKS_REST = 3975
    VEIL_ALA_RAK = 3976
    UPPER_VEIL_SHIL_AK = 3977
    LOWER_VEIL_SHIL_AK = 3978
    SHARTUULS_TRANSPORTER = 4008
    ILLIDARI_TRAINING_GROUNDS = 4009
    MUDSPROCKET = 4010
    DIREHORN_POST = 4046
    NATS_LANDING = 4047
    TABETHAS_FARM = 4049
    PLAGUEWOOD_TOWER = 4067
    SUNWELL_PLATEAU = 4075
    REUSE_ME_SEVEN = 4076
    RAZORTHORN_RISE = 4078
    ISLE_OF_QUEL_DANAS = 4080
    THE_DAWNCHASER = 4081
    THE_SIN_LOREN = 4082
    SILVERMOONS_PRIDE = 4083
    THE_BLOODOATH = 4084
    SHATTERED_SUN_STAGING_AREA = 4085
    SUNS_REACH_SANCTUM = 4086
    SUNS_REACH_HARBOR = 4087
    SUNS_REACH_ARMORY = 4088
    DAWNSTAR_VILLAGE = 4089
    THE_DAWNING_SQUARE = 4090
    GREENGILL_COAST = 4091
    THE_DEAD_SCAR2 = 4092
    THE_SUN_FORGE = 4093
    SUNWELL_PLATEAU1 = 4094
    MAGISTERS_TERRACE = 4095
    MAGISTERS_TERRACE1 = 4131
    PARHELION_PLAZA = 4139
    THE_DEAD_SCAR3 = 4140


class ArenaFaction(enum.Enum):
    HORDE = 0
    ALLIANCE = 1


class ArenaTeamCommand(enum.Enum):
    TEAM_CREATE_S = 0
    TEAM_INVITE_SS = 1
    TEAM_QUIT_S = 3
    TEAM_FOUNDER_S = 14


class ArenaTeamCommandError(enum.Enum):
    ARENA_TEAM_INTERNAL = 1
    ALREADY_IN_ARENA_TEAM = 2
    ALREADY_IN_ARENA_TEAM_S = 3
    INVITED_TO_ARENA_TEAM = 4
    ALREADY_INVITED_TO_ARENA_TEAM_S = 5
    ARENA_TEAM_NAME_INVALID = 6
    ARENA_TEAM_NAME_EXISTS_S = 7
    ARENA_TEAM_LEADER_LEAVE_S = 8
    ARENA_TEAM_PLAYER_NOT_IN_TEAM = 9
    ARENA_TEAM_PLAYER_NOT_IN_TEAM_SS = 10
    ARENA_TEAM_PLAYER_NOT_FOUND_S = 11
    ARENA_TEAM_NOT_ALLIED = 12
    ARENA_TEAM_IGNORING_YOU_S = 19
    ARENA_TEAM_TARGET_TOO_LOW_S = 21
    ARENA_TEAM_TOO_MANY_MEMBERS_S = 22


class ArenaTeamEvent(enum.Enum):
    JOIN = 3
    LEAVE = 4
    REMOVE = 5
    LEADER_IS = 6
    LEADER_CHANGED = 7
    DISBANDED = 8


class ArenaTeamRole(enum.Enum):
    CAPTAIN = 0
    MEMBER = 1


class ArenaType(enum.Enum):
    NOT_ARENA = 0
    TWO_VS_TWO = 2
    THREE_VS_THREE = 3
    FIVE_VS_FIVE = 5


class AuctionCommandAction(enum.Enum):
    STARTED = 0
    REMOVED = 1
    BID_PLACED = 2


class AuctionCommandResult(enum.Enum):
    OK = 0
    ERR_INVENTORY = 1
    ERR_DATABASE = 2
    ERR_NOT_ENOUGH_MONEY = 3
    ERR_ITEM_NOT_FOUND = 4
    ERR_HIGHER_BID = 5
    ERR_BID_INCREMENT = 7
    ERR_BID_OWN = 10
    ERR_RESTRICTED_ACCOUNT = 13


class AuctionCommandResultTwo(enum.Enum):
    OK = 0
    ERR_INVENTORY = 1
    ERR_DATABASE = 2
    ERR_NOT_ENOUGH_MONEY = 3
    ERR_ITEM_NOT_FOUND = 4
    ERR_HIGHER_BID = 5
    ERR_BID_INCREMENT = 7
    ERR_BID_OWN = 10
    ERR_RESTRICTED_ACCOUNT = 13


class AuctionHouse(enum.Enum):
    STORMWIND = 1
    ALLIANCE = 2
    DARNASSUS = 3
    UNDERCITY = 4
    THUNDER_BLUFF = 5
    HORDE = 6
    GOBLIN = 7


class AuraMod(enum.Enum):
    NONE = 0
    BIND_SIGHT = 1
    MOD_POSSESS = 2
    PERIODIC_DAMAGE = 3
    DUMMY = 4
    MOD_CONFUSE = 5
    MOD_CHARM = 6
    MOD_FEAR = 7
    PERIODIC_HEAL = 8
    MOD_ATTACKSPEED = 9
    MOD_THREAT = 10
    MOD_TAUNT = 11
    MOD_STUN = 12
    MOD_DAMAGE_DONE = 13
    MOD_DAMAGE_TAKEN = 14
    DAMAGE_SHIELD = 15
    MOD_STEALTH = 16
    MOD_STEALTH_DETECT = 17
    MOD_INVISIBILITY = 18
    MOD_INVISIBILITY_DETECTION = 19
    OBS_MOD_HEALTH = 20
    OBS_MOD_MANA = 21
    MOD_RESISTANCE = 22
    PERIODIC_TRIGGER_SPELL = 23
    PERIODIC_ENERGIZE = 24
    MOD_PACIFY = 25
    MOD_ROOT = 26
    MOD_SILENCE = 27
    REFLECT_SPELLS = 28
    MOD_STAT = 29
    MOD_SKILL = 30
    MOD_INCREASE_SPEED = 31
    MOD_INCREASE_MOUNTED_SPEED = 32
    MOD_DECREASE_SPEED = 33
    MOD_INCREASE_HEALTH = 34
    MOD_INCREASE_ENERGY = 35
    MOD_SHAPESHIFT = 36
    EFFECT_IMMUNITY = 37
    STATE_IMMUNITY = 38
    SCHOOL_IMMUNITY = 39
    DAMAGE_IMMUNITY = 40
    DISPEL_IMMUNITY = 41
    PROC_TRIGGER_SPELL = 42
    PROC_TRIGGER_DAMAGE = 43
    TRACK_CREATURES = 44
    TRACK_RESOURCES = 45
    UNKNOWN46 = 46
    MOD_PARRY_PERCENT = 47
    UNKNOWN48 = 48
    MOD_DODGE_PERCENT = 49
    MOD_BLOCK_SKILL = 50
    MOD_BLOCK_PERCENT = 51
    MOD_CRIT_PERCENT = 52
    PERIODIC_LEECH = 53
    MOD_HIT_CHANCE = 54
    MOD_SPELL_HIT_CHANCE = 55
    TRANSFORM = 56
    MOD_SPELL_CRIT_CHANCE = 57
    MOD_INCREASE_SWIM_SPEED = 58
    MOD_DAMAGE_DONE_CREATURE = 59
    MOD_PACIFY_SILENCE = 60
    MOD_SCALE = 61
    PERIODIC_HEALTH_FUNNEL = 62
    PERIODIC_MANA_FUNNEL = 63
    PERIODIC_MANA_LEECH = 64
    MOD_CASTING_SPEED_NOT_STACK = 65
    FEIGN_DEATH = 66
    MOD_DISARM = 67
    MOD_STALKED = 68
    SCHOOL_ABSORB = 69
    EXTRA_ATTACKS = 70
    MOD_SPELL_CRIT_CHANCE_SCHOOL = 71
    MOD_POWER_COST_SCHOOL_PCT = 72
    MOD_POWER_COST_SCHOOL = 73
    REFLECT_SPELLS_SCHOOL = 74
    MOD_LANGUAGE = 75
    FAR_SIGHT = 76
    MECHANIC_IMMUNITY = 77
    MOUNTED = 78
    MOD_DAMAGE_PERCENT_DONE = 79
    MOD_PERCENT_STAT = 80
    SPLIT_DAMAGE_PCT = 81
    WATER_BREATHING = 82
    MOD_BASE_RESISTANCE = 83
    MOD_REGEN = 84
    MOD_POWER_REGEN = 85
    CHANNEL_DEATH_ITEM = 86
    MOD_DAMAGE_PERCENT_TAKEN = 87
    MOD_HEALTH_REGEN_PERCENT = 88
    PERIODIC_DAMAGE_PERCENT = 89
    MOD_RESIST_CHANCE = 90
    MOD_DETECT_RANGE = 91
    PREVENTS_FLEEING = 92
    MOD_UNATTACKABLE = 93
    INTERRUPT_REGEN = 94
    GHOST = 95
    SPELL_MAGNET = 96
    MANA_SHIELD = 97
    MOD_SKILL_TALENT = 98
    MOD_ATTACK_POWER = 99
    AURAS_VISIBLE = 100
    MOD_RESISTANCE_PCT = 101
    MOD_MELEE_ATTACK_POWER_VERSUS = 102
    MOD_TOTAL_THREAT = 103
    WATER_WALK = 104
    FEATHER_FALL = 105
    HOVER = 106
    ADD_FLAT_MODIFIER = 107
    ADD_PCT_MODIFIER = 108
    ADD_TARGET_TRIGGER = 109
    MOD_POWER_REGEN_PERCENT = 110
    ADD_CASTER_HIT_TRIGGER = 111
    OVERRIDE_CLASS_SCRIPTS = 112
    MOD_RANGED_DAMAGE_TAKEN = 113
    MOD_RANGED_DAMAGE_TAKEN_PCT = 114
    MOD_HEALING = 115
    MOD_REGEN_DURING_COMBAT = 116
    MOD_MECHANIC_RESISTANCE = 117
    MOD_HEALING_PCT = 118
    SHARE_PET_TRACKING = 119
    UNTRACKABLE = 120
    EMPATHY = 121
    MOD_OFFHAND_DAMAGE_PCT = 122
    MOD_TARGET_RESISTANCE = 123
    MOD_RANGED_ATTACK_POWER = 124
    MOD_MELEE_DAMAGE_TAKEN = 125
    MOD_MELEE_DAMAGE_TAKEN_PCT = 126
    RANGED_ATTACK_POWER_ATTACKER_BONUS = 127
    MOD_POSSESS_PET = 128
    MOD_SPEED_ALWAYS = 129
    MOD_MOUNTED_SPEED_ALWAYS = 130
    MOD_RANGED_ATTACK_POWER_VERSUS = 131
    MOD_INCREASE_ENERGY_PERCENT = 132
    MOD_INCREASE_HEALTH_PERCENT = 133
    MOD_MANA_REGEN_INTERRUPT = 134
    MOD_HEALING_DONE = 135
    MOD_HEALING_DONE_PERCENT = 136
    MOD_TOTAL_STAT_PERCENTAGE = 137
    MOD_MELEE_HASTE = 138
    FORCE_REACTION = 139
    MOD_RANGED_HASTE = 140
    MOD_RANGED_AMMO_HASTE = 141
    MOD_BASE_RESISTANCE_PCT = 142
    MOD_RESISTANCE_EXCLUSIVE = 143
    SAFE_FALL = 144
    CHARISMA = 145
    PERSUADED = 146
    MECHANIC_IMMUNITY_MASK = 147
    RETAIN_COMBO_POINTS = 148
    RESIST_PUSHBACK = 149
    MOD_SHIELD_BLOCKVALUE_PCT = 150
    TRACK_STEALTHED = 151
    MOD_DETECTED_RANGE = 152
    SPLIT_DAMAGE_FLAT = 153
    MOD_STEALTH_LEVEL = 154
    MOD_WATER_BREATHING = 155
    MOD_REPUTATION_GAIN = 156
    PET_DAMAGE_MULTI = 157
    MOD_SHIELD_BLOCKVALUE = 158
    NO_PVP_CREDIT = 159
    MOD_AOE_AVOIDANCE = 160
    MOD_HEALTH_REGEN_IN_COMBAT = 161
    POWER_BURN_MANA = 162
    MOD_CRIT_DAMAGE_BONUS = 163
    UNKNOWN164 = 164
    MELEE_ATTACK_POWER_ATTACKER_BONUS = 165
    MOD_ATTACK_POWER_PCT = 166
    MOD_RANGED_ATTACK_POWER_PCT = 167
    MOD_DAMAGE_DONE_VERSUS = 168
    MOD_CRIT_PERCENT_VERSUS = 169
    DETECT_AMORE = 170
    MOD_SPEED_NOT_STACK = 171
    MOD_MOUNTED_SPEED_NOT_STACK = 172
    ALLOW_CHAMPION_SPELLS = 173
    MOD_SPELL_DAMAGE_OF_STAT_PERCENT = 174
    MOD_SPELL_HEALING_OF_STAT_PERCENT = 175
    SPIRIT_OF_REDEMPTION = 176
    AOE_CHARM = 177
    MOD_DEBUFF_RESISTANCE = 178
    MOD_ATTACKER_SPELL_CRIT_CHANCE = 179
    MOD_FLAT_SPELL_DAMAGE_VERSUS = 180
    MOD_FLAT_SPELL_CRIT_DAMAGE_VERSUS = 181
    MOD_RESISTANCE_OF_STAT_PERCENT = 182
    MOD_CRITICAL_THREAT = 183
    MOD_ATTACKER_MELEE_HIT_CHANCE = 184
    MOD_ATTACKER_RANGED_HIT_CHANCE = 185
    MOD_ATTACKER_SPELL_HIT_CHANCE = 186
    MOD_ATTACKER_MELEE_CRIT_CHANCE = 187
    MOD_ATTACKER_RANGED_CRIT_CHANCE = 188
    MOD_RATING = 189
    MOD_FACTION_REPUTATION_GAIN = 190
    USE_NORMAL_MOVEMENT_SPEED = 191
    MOD_MELEE_RANGED_HASTE = 192
    HASTE_ALL = 193
    MOD_DEPRICATED_1 = 194
    MOD_DEPRICATED_2 = 195
    MOD_COOLDOWN = 196
    MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE = 197
    MOD_ALL_WEAPON_SKILLS = 198
    MOD_INCREASES_SPELL_PCT_TO_HIT = 199
    MOD_XP_PCT = 200
    FLY = 201
    IGNORE_COMBAT_RESULT = 202
    MOD_ATTACKER_MELEE_CRIT_DAMAGE = 203
    MOD_ATTACKER_RANGED_CRIT_DAMAGE = 204
    MOD_ATTACKER_SPELL_CRIT_DAMAGE = 205
    MOD_FLIGHT_SPEED = 206
    MOD_FLIGHT_SPEED_MOUNTED = 207
    MOD_FLIGHT_SPEED_STACKING = 208
    MOD_FLIGHT_SPEED_MOUNTED_STACKING = 209
    MOD_FLIGHT_SPEED_NOT_STACKING = 210
    MOD_FLIGHT_SPEED_MOUNTED_NOT_STACKING = 211
    MOD_RANGED_ATTACK_POWER_OF_STAT_PERCENT = 212
    MOD_RAGE_FROM_DAMAGE_DEALT = 213
    UNKNOWN214 = 214
    ARENA_PREPARATION = 215
    HASTE_SPELLS = 216
    UNKNOWN217 = 217
    HASTE_RANGED = 218
    MOD_MANA_REGEN_FROM_STAT = 219
    MOD_RATING_FROM_STAT = 220
    UNKNOWN221 = 221
    UNKNOWN222 = 222
    UNKNOWN223 = 223
    UNKNOWN224 = 224
    PRAYER_OF_MENDING = 225
    PERIODIC_DUMMY = 226
    PERIODIC_TRIGGER_SPELL_WITH_VALUE = 227
    DETECT_STEALTH = 228
    MOD_AOE_DAMAGE_AVOIDANCE = 229
    UNKNOWN230 = 230
    PROC_TRIGGER_SPELL_WITH_VALUE = 231
    MECHANIC_DURATION_MOD = 232
    UNKNOWN233 = 233
    MECHANIC_DURATION_MOD_NOT_STACK = 234
    MOD_DISPEL_RESIST = 235
    UNKNOWN236 = 236
    MOD_SPELL_DAMAGE_OF_ATTACK_POWER = 237
    MOD_SPELL_HEALING_OF_ATTACK_POWER = 238
    MOD_SCALE_2 = 239
    MOD_EXPERTISE = 240
    FORCE_MOVE_FORWARD = 241
    UNKNOWN242 = 242
    UNKNOWN243 = 243
    COMPREHEND_LANGUAGE = 244
    UNKNOWN245 = 245
    UNKNOWN246 = 246
    MIRROR_IMAGE = 247
    MOD_COMBAT_RESULT_CHANCE = 248
    UNKNOWN249 = 249
    MOD_INCREASE_HEALTH_2 = 250
    MOD_ENEMY_DODGE = 251
    UNKNOWN252 = 252
    UNKNOWN253 = 253
    UNKNOWN254 = 254
    UNKNOWN255 = 255
    UNKNOWN256 = 256
    UNKNOWN257 = 257
    UNKNOWN258 = 258
    UNKNOWN259 = 259
    UNKNOWN260 = 260
    UNKNOWN261 = 261


class AuraType(enum.Enum):
    NONE = 0
    BIND_SIGHT = 1
    MOD_POSSESS = 2
    PERIODIC_DAMAGE = 3
    DUMMY = 4
    MOD_CONFUSE = 5
    MOD_CHARM = 6
    MOD_FEAR = 7
    PERIODIC_HEAL = 8
    MOD_ATTACKSPEED = 9
    MOD_THREAT = 10
    MOD_TAUNT = 11
    MOD_STUN = 12
    MOD_DAMAGE_DONE = 13
    MOD_DAMAGE_TAKEN = 14
    DAMAGE_SHIELD = 15
    MOD_STEALTH = 16
    MOD_STEALTH_DETECT = 17
    MOD_INVISIBILITY = 18
    MOD_INVISIBILITY_DETECTION = 19
    OBS_MOD_HEALTH = 20
    OBS_MOD_MANA = 21
    MOD_RESISTANCE = 22
    PERIODIC_TRIGGER_SPELL = 23
    PERIODIC_ENERGIZE = 24
    MOD_PACIFY = 25
    MOD_ROOT = 26
    MOD_SILENCE = 27
    REFLECT_SPELLS = 28
    MOD_STAT = 29
    MOD_SKILL = 30
    MOD_INCREASE_SPEED = 31
    MOD_INCREASE_MOUNTED_SPEED = 32
    MOD_DECREASE_SPEED = 33
    MOD_INCREASE_HEALTH = 34
    MOD_INCREASE_ENERGY = 35
    MOD_SHAPESHIFT = 36
    EFFECT_IMMUNITY = 37
    STATE_IMMUNITY = 38
    SCHOOL_IMMUNITY = 39
    DAMAGE_IMMUNITY = 40
    DISPEL_IMMUNITY = 41
    PROC_TRIGGER_SPELL = 42
    PROC_TRIGGER_DAMAGE = 43
    TRACK_CREATURES = 44
    TRACK_RESOURCES = 45
    UNKNOWN46 = 46
    MOD_PARRY_PERCENT = 47
    UNKNOWN48 = 48
    MOD_DODGE_PERCENT = 49
    MOD_BLOCK_SKILL = 50
    MOD_BLOCK_PERCENT = 51
    MOD_CRIT_PERCENT = 52
    PERIODIC_LEECH = 53
    MOD_HIT_CHANCE = 54
    MOD_SPELL_HIT_CHANCE = 55
    TRANSFORM = 56
    MOD_SPELL_CRIT_CHANCE = 57
    MOD_INCREASE_SWIM_SPEED = 58
    MOD_DAMAGE_DONE_CREATURE = 59
    MOD_PACIFY_SILENCE = 60
    MOD_SCALE = 61
    PERIODIC_HEALTH_FUNNEL = 62
    PERIODIC_MANA_FUNNEL = 63
    PERIODIC_MANA_LEECH = 64
    MOD_CASTING_SPEED_NOT_STACK = 65
    FEIGN_DEATH = 66
    MOD_DISARM = 67
    MOD_STALKED = 68
    SCHOOL_ABSORB = 69
    EXTRA_ATTACKS = 70
    MOD_SPELL_CRIT_CHANCE_SCHOOL = 71
    MOD_POWER_COST_SCHOOL_PCT = 72
    MOD_POWER_COST_SCHOOL = 73
    REFLECT_SPELLS_SCHOOL = 74
    MOD_LANGUAGE = 75
    FAR_SIGHT = 76
    MECHANIC_IMMUNITY = 77
    MOUNTED = 78
    MOD_DAMAGE_PERCENT_DONE = 79
    MOD_PERCENT_STAT = 80
    SPLIT_DAMAGE_PCT = 81
    WATER_BREATHING = 82
    MOD_BASE_RESISTANCE = 83
    MOD_REGEN = 84
    MOD_POWER_REGEN = 85
    CHANNEL_DEATH_ITEM = 86
    MOD_DAMAGE_PERCENT_TAKEN = 87
    MOD_HEALTH_REGEN_PERCENT = 88
    PERIODIC_DAMAGE_PERCENT = 89
    MOD_RESIST_CHANCE = 90
    MOD_DETECT_RANGE = 91
    PREVENTS_FLEEING = 92
    MOD_UNATTACKABLE = 93
    INTERRUPT_REGEN = 94
    GHOST = 95
    SPELL_MAGNET = 96
    MANA_SHIELD = 97
    MOD_SKILL_TALENT = 98
    MOD_ATTACK_POWER = 99
    AURAS_VISIBLE = 100
    MOD_RESISTANCE_PCT = 101
    MOD_MELEE_ATTACK_POWER_VERSUS = 102
    MOD_TOTAL_THREAT = 103
    WATER_WALK = 104
    FEATHER_FALL = 105
    HOVER = 106
    ADD_FLAT_MODIFIER = 107
    ADD_PCT_MODIFIER = 108
    ADD_TARGET_TRIGGER = 109
    MOD_POWER_REGEN_PERCENT = 110
    ADD_CASTER_HIT_TRIGGER = 111
    OVERRIDE_CLASS_SCRIPTS = 112
    MOD_RANGED_DAMAGE_TAKEN = 113
    MOD_RANGED_DAMAGE_TAKEN_PCT = 114
    MOD_HEALING = 115
    MOD_REGEN_DURING_COMBAT = 116
    MOD_MECHANIC_RESISTANCE = 117
    MOD_HEALING_PCT = 118
    SHARE_PET_TRACKING = 119
    UNTRACKABLE = 120
    EMPATHY = 121
    MOD_OFFHAND_DAMAGE_PCT = 122
    MOD_TARGET_RESISTANCE = 123
    MOD_RANGED_ATTACK_POWER = 124
    MOD_MELEE_DAMAGE_TAKEN = 125
    MOD_MELEE_DAMAGE_TAKEN_PCT = 126
    RANGED_ATTACK_POWER_ATTACKER_BONUS = 127
    MOD_POSSESS_PET = 128
    MOD_SPEED_ALWAYS = 129
    MOD_MOUNTED_SPEED_ALWAYS = 130
    MOD_RANGED_ATTACK_POWER_VERSUS = 131
    MOD_INCREASE_ENERGY_PERCENT = 132
    MOD_INCREASE_HEALTH_PERCENT = 133
    MOD_MANA_REGEN_INTERRUPT = 134
    MOD_HEALING_DONE = 135
    MOD_HEALING_DONE_PERCENT = 136
    MOD_TOTAL_STAT_PERCENTAGE = 137
    MOD_MELEE_HASTE = 138
    FORCE_REACTION = 139
    MOD_RANGED_HASTE = 140
    MOD_RANGED_AMMO_HASTE = 141
    MOD_BASE_RESISTANCE_PCT = 142
    MOD_RESISTANCE_EXCLUSIVE = 143
    SAFE_FALL = 144
    CHARISMA = 145
    PERSUADED = 146
    MECHANIC_IMMUNITY_MASK = 147
    RETAIN_COMBO_POINTS = 148
    RESIST_PUSHBACK = 149
    MOD_SHIELD_BLOCKVALUE_PCT = 150
    TRACK_STEALTHED = 151
    MOD_DETECTED_RANGE = 152
    SPLIT_DAMAGE_FLAT = 153
    MOD_STEALTH_LEVEL = 154
    MOD_WATER_BREATHING = 155
    MOD_REPUTATION_GAIN = 156
    PET_DAMAGE_MULTI = 157
    MOD_SHIELD_BLOCKVALUE = 158
    NO_PVP_CREDIT = 159
    MOD_AOE_AVOIDANCE = 160
    MOD_HEALTH_REGEN_IN_COMBAT = 161
    POWER_BURN_MANA = 162
    MOD_CRIT_DAMAGE_BONUS = 163
    UNKNOWN164 = 164
    MELEE_ATTACK_POWER_ATTACKER_BONUS = 165
    MOD_ATTACK_POWER_PCT = 166
    MOD_RANGED_ATTACK_POWER_PCT = 167
    MOD_DAMAGE_DONE_VERSUS = 168
    MOD_CRIT_PERCENT_VERSUS = 169
    DETECT_AMORE = 170
    MOD_SPEED_NOT_STACK = 171
    MOD_MOUNTED_SPEED_NOT_STACK = 172
    ALLOW_CHAMPION_SPELLS = 173
    MOD_SPELL_DAMAGE_OF_STAT_PERCENT = 174
    MOD_SPELL_HEALING_OF_STAT_PERCENT = 175
    SPIRIT_OF_REDEMPTION = 176
    AOE_CHARM = 177
    MOD_DEBUFF_RESISTANCE = 178
    MOD_ATTACKER_SPELL_CRIT_CHANCE = 179
    MOD_FLAT_SPELL_DAMAGE_VERSUS = 180
    MOD_FLAT_SPELL_CRIT_DAMAGE_VERSUS = 181
    MOD_RESISTANCE_OF_STAT_PERCENT = 182
    MOD_CRITICAL_THREAT = 183
    MOD_ATTACKER_MELEE_HIT_CHANCE = 184
    MOD_ATTACKER_RANGED_HIT_CHANCE = 185
    MOD_ATTACKER_SPELL_HIT_CHANCE = 186
    MOD_ATTACKER_MELEE_CRIT_CHANCE = 187
    MOD_ATTACKER_RANGED_CRIT_CHANCE = 188
    MOD_RATING = 189
    MOD_FACTION_REPUTATION_GAIN = 190
    USE_NORMAL_MOVEMENT_SPEED = 191
    MOD_MELEE_RANGED_HASTE = 192
    HASTE_ALL = 193
    MOD_DEPRICATED_1 = 194
    MOD_DEPRICATED_2 = 195
    MOD_COOLDOWN = 196
    MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE = 197
    MOD_ALL_WEAPON_SKILLS = 198
    MOD_INCREASES_SPELL_PCT_TO_HIT = 199
    MOD_XP_PCT = 200
    FLY = 201
    IGNORE_COMBAT_RESULT = 202
    MOD_ATTACKER_MELEE_CRIT_DAMAGE = 203
    MOD_ATTACKER_RANGED_CRIT_DAMAGE = 204
    MOD_ATTACKER_SPELL_CRIT_DAMAGE = 205
    MOD_FLIGHT_SPEED = 206
    MOD_FLIGHT_SPEED_MOUNTED = 207
    MOD_FLIGHT_SPEED_STACKING = 208
    MOD_FLIGHT_SPEED_MOUNTED_STACKING = 209
    MOD_FLIGHT_SPEED_NOT_STACKING = 210
    MOD_FLIGHT_SPEED_MOUNTED_NOT_STACKING = 211
    MOD_RANGED_ATTACK_POWER_OF_STAT_PERCENT = 212
    MOD_RAGE_FROM_DAMAGE_DEALT = 213
    UNKNOWN214 = 214
    ARENA_PREPARATION = 215
    HASTE_SPELLS = 216
    UNKNOWN217 = 217
    HASTE_RANGED = 218
    MOD_MANA_REGEN_FROM_STAT = 219
    MOD_RATING_FROM_STAT = 220
    UNKNOWN221 = 221
    UNKNOWN222 = 222
    UNKNOWN223 = 223
    UNKNOWN224 = 224
    PRAYER_OF_MENDING = 225
    PERIODIC_DUMMY = 226
    PERIODIC_TRIGGER_SPELL_WITH_VALUE = 227
    DETECT_STEALTH = 228
    MOD_AOE_DAMAGE_AVOIDANCE = 229
    UNKNOWN230 = 230
    PROC_TRIGGER_SPELL_WITH_VALUE = 231
    MECHANIC_DURATION_MOD = 232
    UNKNOWN233 = 233
    MECHANIC_DURATION_MOD_NOT_STACK = 234
    MOD_DISPEL_RESIST = 235
    UNKNOWN236 = 236
    MOD_SPELL_DAMAGE_OF_ATTACK_POWER = 237
    MOD_SPELL_HEALING_OF_ATTACK_POWER = 238
    MOD_SCALE_2 = 239
    MOD_EXPERTISE = 240
    FORCE_MOVE_FORWARD = 241
    UNKNOWN242 = 242
    UNKNOWN243 = 243
    COMPREHEND_LANGUAGE = 244
    UNKNOWN245 = 245
    UNKNOWN246 = 246
    MIRROR_IMAGE = 247
    MOD_COMBAT_RESULT_CHANCE = 248
    UNKNOWN249 = 249
    MOD_INCREASE_HEALTH_2 = 250
    MOD_ENEMY_DODGE = 251
    UNKNOWN252 = 252
    UNKNOWN253 = 253
    UNKNOWN254 = 254
    UNKNOWN255 = 255
    UNKNOWN256 = 256
    UNKNOWN257 = 257
    UNKNOWN258 = 258
    UNKNOWN259 = 259
    UNKNOWN260 = 260
    UNKNOWN261 = 261


class BankSwapSource(enum.Enum):
    INVENTORY = 0
    BANK = 1


class BankSwapStoreMode(enum.Enum):
    MANUAL = 0
    AUTOMATIC = 1


class BattlefieldPortAction(enum.Enum):
    LEAVE_QUEUE = 0
    ENTER_BATTLE = 1


class BattlegroundType(enum.Enum):
    NONE = 0
    ALTERAC_VALLEY = 1
    WARSONG_GULCH = 2
    ARATHI_BASIN = 3
    NETHERSTORM = 4
    BLADES_EDGE_ARENA = 5
    ARENA = 6
    EYE_OF_THE_STORM = 7
    RUINS_OF_LORDAERON = 8


class BgTypeId(enum.Enum):
    NOT_ELIGIBLE = 0
    QUEUED_FOR_AV = 1
    QUEUED_FOR_WSG = 2
    QUEUED_FOR_AB = 3
    QUEUED_FOR_NETHERSTORM = 4
    QUEUED_FOR_BLADES_EDGE_ARENA = 5
    QUEUED_FOR_ARENA = 6
    QUEUED_FOR_EYE_OF_THE_STORM = 7
    QUEUED_FOR_RUINS_OF_LORDAERON = 8
    REMOVE_FROM_QUEUE = 4294967294


class Bonding(enum.Enum):
    NO_BIND = 0
    PICK_UP = 1
    EQUIP = 2
    USE = 3
    QUEST_ITEM = 4
    QUEST_ITEM1 = 5


class BuyBankSlotResult(enum.Enum):
    FAILED_TOO_MANY = 0
    INSUFFICIENT_FUNDS = 1
    NOT_BANKER = 2
    OK = 3


class BuyResult(enum.Enum):
    CANT_FIND_ITEM = 0
    ITEM_ALREADY_SOLD = 1
    NOT_ENOUGH_MONEY = 2
    SELLER_DONT_LIKE_YOU = 4
    DISTANCE_TOO_FAR = 5
    ITEM_SOLD_OUT = 7
    CANT_CARRY_MORE = 8
    RANK_REQUIRE = 11
    REPUTATION_REQUIRE = 12


class BuybackSlot(enum.Enum):
    SLOT1 = 69
    SLOT2 = 70
    SLOT3 = 71
    SLOT4 = 72
    SLOT5 = 73
    SLOT6 = 74
    SLOT7 = 75
    SLOT8 = 76
    SLOT9 = 77
    SLOT10 = 78
    SLOT11 = 79
    SLOT12 = 80
    SLOT13 = 81


class CharterType(enum.Enum):
    GUILD = 0
    ARENA = 1


class ChatNotify(enum.Enum):
    JOINED_NOTICE = 0
    LEFT_NOTICE = 1
    YOU_JOINED_NOTICE = 2
    YOU_LEFT_NOTICE = 3
    WRONG_PASSWORD_NOTICE = 4
    NOT_MEMBER_NOTICE = 5
    NOT_MODERATOR_NOTICE = 6
    PASSWORD_CHANGED_NOTICE = 7
    OWNER_CHANGED_NOTICE = 8
    PLAYER_NOT_FOUND_NOTICE = 9
    NOT_OWNER_NOTICE = 10
    CHANNEL_OWNER_NOTICE = 11
    MODE_CHANGE_NOTICE = 12
    ANNOUNCEMENTS_ON_NOTICE = 13
    ANNOUNCEMENTS_OFF_NOTICE = 14
    MODERATION_ON_NOTICE = 15
    MODERATION_OFF_NOTICE = 16
    MUTED_NOTICE = 17
    PLAYER_KICKED_NOTICE = 18
    BANNED_NOTICE = 19
    PLAYER_BANNED_NOTICE = 20
    PLAYER_UNBANNED_NOTICE = 21
    PLAYER_NOT_BANNED_NOTICE = 22
    PLAYER_ALREADY_MEMBER_NOTICE = 23
    INVITE_NOTICE = 24
    INVITE_WRONG_FACTION_NOTICE = 25
    WRONG_FACTION_NOTICE = 26
    INVALID_NAME_NOTICE = 27
    NOT_MODERATED_NOTICE = 28
    PLAYER_INVITED_NOTICE = 29
    PLAYER_INVITE_BANNED_NOTICE = 30
    THROTTLED_NOTICE = 31
    NOT_IN_AREA_NOTICE = 32
    NOT_IN_LFG_NOTICE = 33
    VOICE_ON_NOTICE = 34
    VOICE_OFF_NOTICE = 35


class ChatRestrictionType(enum.Enum):
    CHAT_RESTRICTED = 0
    CHAT_THROTTLED = 1
    USER_SQUELCHED = 2


class ChatType(enum.Enum):
    SYSTEM = 0
    SAY = 1
    PARTY = 2
    RAID = 3
    GUILD = 4
    OFFICER = 5
    YELL = 6
    WHISPER = 7
    WHISPER_INFORM = 8
    REPLY = 9
    EMOTE = 10
    TEXT_EMOTE = 11
    MONSTER_SAY = 12
    MONSTER_PARTY = 13
    MONSTER_YELL = 14
    MONSTER_WHISPER = 15
    MONSTER_EMOTE = 16
    CHANNEL = 17
    CHANNEL_JOIN = 18
    CHANNEL_LEAVE = 19
    CHANNEL_LIST = 20
    CHANNEL_NOTICE = 21
    CHANNEL_NOTICE_USER = 22
    AFK = 23
    DND = 24
    IGNORED = 25
    SKILL = 26
    LOOT = 27
    MONEY = 28
    OPENING = 29
    TRADESKILLS = 30
    PET_INFO = 31
    COMBAT_MISC_INFO = 32
    COMBAT_XP_GAIN = 33
    COMBAT_HONOR_GAIN = 34
    COMBAT_FACTION_CHANGE = 35
    BG_SYSTEM_NEUTRAL = 36
    BG_SYSTEM_ALLIANCE = 37
    BG_SYSTEM_HORDE = 38
    RAID_LEADER = 39
    RAID_WARNING = 40
    RAID_BOSS_WHISPER = 41
    RAID_BOSS_EMOTE = 42
    FILTERED = 43
    BATTLEGROUND = 44
    BATTLEGROUND_LEADER = 45
    RESTRICTED = 46


class CinematicSequenceId(enum.Enum):
    GOBLIN = 0
    PALANTIR_OF_AZORA = 1
    UNDEAD = 2
    ORC = 21
    DWARF = 41
    NIGHT_ELF = 61
    HUMAN = 81
    GNOME = 101
    TROLL = 121
    TAUREN = 141
    SCRY_CAM = 161
    BLOOD_ELF = 162
    DRAENEI = 163
    SUNWELL_FIVE_MAN = 164


class Class(enum.Enum):
    WARRIOR = 1
    PALADIN = 2
    HUNTER = 3
    ROGUE = 4
    PRIEST = 5
    SHAMAN = 7
    MAGE = 8
    WARLOCK = 9
    DRUID = 11


class CommentatorEnableOption(enum.Enum):
    DISABLE = 0
    ENABLE = 1
    TOGGLE = 2


class ComplainResultWindow(enum.Enum):
    DO_NOT_SHOW = 0
    SHOW = 1


class ComplaintStatus(enum.Enum):
    DISABLED = 0
    ENABLED_WITHOUT_AUTO_IGNORE = 1
    ENABLED_WITH_AUTO_IGNORE = 2


class CorpseQueryResult(enum.Enum):
    NOT_FOUND = 0
    FOUND = 1


class CreatureFamily(enum.Enum):
    NONE = 0
    WOLF = 1
    CAT = 2
    SPIDER = 3
    BEAR = 4
    BOAR = 5
    CROCOLISK = 6
    CARRION_BIRD = 7
    CRAB = 8
    GORILLA = 9
    RAPTOR = 11
    TALLSTRIDER = 12
    FELHUNTER = 15
    VOIDWALKER = 16
    SUCCUBUS = 17
    DOOMGUARD = 19
    SCORPID = 20
    TURTLE = 21
    IMP = 23
    BAT = 24
    HYENA = 25
    OWL = 26
    WIND_SERPENT = 27
    REMOTE_CONTROL = 28
    FELGUARD = 29
    DRAGONHAWK = 30
    RAVAGER = 31
    WARP_STALKER = 32
    SPOREBAT = 33
    NETHER_RAY = 34
    SERPENT = 35
    SEA_LION = 36


class DeclinedNames(enum.Enum):
    NO = 0
    YES = 1


class DeclinedPetNameIncluded(enum.Enum):
    NOT_INCLUDED = 0
    INCLUDED = 1


class DispelMethod(enum.Enum):
    DISPELLED = 0
    CLEANSED = 1


class DuelWinnerReason(enum.Enum):
    WON = 0
    FLED = 1


class DungeonDifficulty(enum.Enum):
    NORMAL = 0
    HEROIC = 1


class Emote(enum.Enum):
    ONESHOT_NONE = 0
    ONESHOT_TALK = 1
    ONESHOT_BOW = 2
    ONESHOT_WAVE = 3
    ONESHOT_CHEER = 4
    ONESHOT_EXCLAMATION = 5
    ONESHOT_QUESTION = 6
    ONESHOT_EAT = 7
    STATE_DANCE = 10
    ONESHOT_LAUGH = 11
    STATE_SLEEP = 12
    STATE_SIT = 13
    ONESHOT_RUDE = 14
    ONESHOT_ROAR = 15
    ONESHOT_KNEEL = 16
    ONESHOT_KISS = 17
    ONESHOT_CRY = 18
    ONESHOT_CHICKEN = 19
    ONESHOT_BEG = 20
    ONESHOT_APPLAUD = 21
    ONESHOT_SHOUT = 22
    ONESHOT_FLEX = 23
    ONESHOT_SHY = 24
    ONESHOT_POINT = 25
    STATE_STAND = 26
    STATE_READYUNARMED = 27
    STATE_WORK_SHEATHED = 28
    STATE_POINT = 29
    STATE_NONE = 30
    ONESHOT_WOUND = 33
    ONESHOT_WOUNDCRITICAL = 34
    ONESHOT_ATTACKUNARMED = 35
    ONESHOT_ATTACK1H = 36
    ONESHOT_ATTACK2HTIGHT = 37
    ONESHOT_ATTACK2HLOOSE = 38
    ONESHOT_PARRYUNARMED = 39
    ONESHOT_PARRYSHIELD = 43
    ONESHOT_READYUNARMED = 44
    ONESHOT_READY1H = 45
    ONESHOT_READYBOW = 48
    ONESHOT_SPELLPRECAST = 50
    ONESHOT_SPELLCAST = 51
    ONESHOT_BATTLEROAR = 53
    ONESHOT_SPECIALATTACK1H = 54
    ONESHOT_KICK = 60
    ONESHOT_ATTACKTHROWN = 61
    STATE_STUN = 64
    STATE_DEAD = 65
    ONESHOT_SALUTE = 66
    STATE_KNEEL = 68
    STATE_USESTANDING = 69
    ONESHOT_WAVE_NOSHEATHE = 70
    ONESHOT_CHEER_NOSHEATHE = 71
    ONESHOT_EAT_NOSHEATHE = 92
    STATE_STUN_NOSHEATHE = 93
    ONESHOT_DANCE = 94
    ONESHOT_SALUTE_NOSHEATH = 113
    STATE_USESTANDING_NOSHEATHE = 133
    ONESHOT_LAUGH_NOSHEATHE = 153
    STATE_WORK = 173
    STATE_SPELLPRECAST = 193
    ONESHOT_READYRIFLE = 213
    STATE_READYRIFLE = 214
    STATE_WORK_MINING = 233
    STATE_WORK_CHOPWOOD = 234
    STATE_APPLAUD = 253
    ONESHOT_LIFTOFF = 254
    ONESHOT_YES = 273
    ONESHOT_NO = 274
    ONESHOT_TRAIN = 275
    ONESHOT_LAND = 293
    STATE_AT_EASE = 313
    STATE_READY1H = 333
    STATE_SPELLKNEELSTART = 353
    STATE_SUBMERGED = 373
    ONESHOT_SUBMERGE = 374
    STATE_READY2H = 375
    STATE_READYBOW = 376
    ONESHOT_MOUNTSPECIAL = 377
    STATE_TALK = 378
    STATE_FISHING = 379
    ONESHOT_FISHING = 380
    ONESHOT_LOOT = 381
    STATE_WHIRLWIND = 382
    STATE_DROWNED = 383
    STATE_HOLD_BOW = 384
    STATE_HOLD_RIFLE = 385
    STATE_HOLD_THROWN = 386
    ONESHOT_DROWN = 387
    ONESHOT_STOMP = 388
    ONESHOT_ATTACKOFF = 389
    ONESHOT_ATTACKOFFPIERCE = 390
    STATE_ROAR = 391
    STATE_LAUGH = 392
    ONESHOT_CREATURE_SPECIAL = 393
    ONESHOT_JUMPLANDRUN = 394
    ONESHOT_JUMPEND = 395
    ONESHOT_TALK_NOSHEATHE = 396
    ONESHOT_POINT_NOSHEATHE = 397
    STATE_CANNIBALIZE = 398
    ONESHOT_JUMPSTART = 399
    STATE_DANCESPECIAL = 400
    ONESHOT_DANCESPECIAL = 401
    ONESHOT_CUSTOMSPELL01 = 402
    ONESHOT_CUSTOMSPELL02 = 403
    ONESHOT_CUSTOMSPELL03 = 404
    ONESHOT_CUSTOMSPELL04 = 405
    ONESHOT_CUSTOMSPELL05 = 406
    ONESHOT_CUSTOMSPELL06 = 407
    ONESHOT_CUSTOMSPELL07 = 408
    ONESHOT_CUSTOMSPELL08 = 409
    ONESHOT_CUSTOMSPELL09 = 410
    ONESHOT_CUSTOMSPELL10 = 411
    STATE_EXCLAIM = 412
    STATE_SIT_CHAIR_MED = 415
    STATE_SPELLEFFECT_HOLD = 422
    STATE_EAT_NO_SHEATHE = 423


class EnvironmentalDamageType(enum.Enum):
    EXHAUSTED = 0
    DROWNING = 1
    FALL = 2
    LAVA = 3
    SLIME = 4
    FIRE = 5


class Expansion(enum.Enum):
    VANILLA = 0
    THE_BURNING_CRUSADE = 1


class ExperienceAwardType(enum.Enum):
    KILL = 0
    NON_KILL = 1


class Faction(enum.Enum):
    NONE = 0
    PLAYER_HUMAN = 1
    PLAYER_ORC = 2
    PLAYER_DWARF = 3
    PLAYER_NIGHT_ELF = 4
    PLAYER_UNDEAD = 5
    PLAYER_TAUREN = 6
    CREATURE = 7
    PLAYER_GNOME = 8
    PLAYER_TROLL = 9
    MONSTER = 14
    DEFIAS_BROTHERHOOD = 15
    GNOLL_RIVERPAW = 16
    GNOLL_REDRIDGE = 17
    GNOLL_SHADOWHIDE = 18
    MURLOC = 19
    UNDEAD_SCOURGE = 20
    BOOTY_BAY = 21
    BEAST_SPIDER = 22
    BEAST_BOAR = 23
    WORGEN = 24
    KOBOLD = 25
    TROLL_BLOODSCALP = 26
    TROLL_SKULLSPLITTER = 27
    PREY = 28
    BEAST_WOLF = 29
    DEFIAS_BROTHERHOOD_TRAITOR = 30
    FRIENDLY = 31
    TROGG = 32
    TROLL_FROSTMANE = 33
    ORC_BLACKROCK = 34
    VILLIAN = 35
    VICTIM = 36
    BEAST_BEAR = 37
    OGRE = 38
    KURZENS_MERCENARIES = 39
    ESCORTEE = 40
    VENTURE_COMPANY = 41
    BEAST_RAPTOR = 42
    BASILISK = 43
    DRAGONFLIGHT_GREEN = 44
    LOST_ONES = 45
    BLACKSMITHING_ARMORSMITHING = 46
    IRONFORGE = 47
    DARK_IRON_DWARVES = 48
    HUMAN_NIGHT_WATCH = 49
    DRAGONFLIGHT_RED = 50
    GNOLL_MOSSHIDE = 51
    ORC_DRAGONMAW = 52
    GNOME_LEPER = 53
    GNOMEREGAN_EXILES = 54
    LEOPARD = 55
    SCARLET_CRUSADE = 56
    GNOLL_ROTHIDE = 57
    BEAST_GORILLA = 58
    THORIUM_BROTHERHOOD = 59
    NAGA = 60
    DALARAN = 61
    FORLORN_SPIRIT = 62
    DARKHOWL = 63
    GRELL = 64
    FURBOLG = 65
    HORDE_GENERIC = 66
    HORDE = 67
    UNDERCITY = 68
    DARNASSUS = 69
    SYNDICATE = 70
    HILLSBRAD_MILITIA = 71
    STORMWIND = 72
    DEMON = 73
    ELEMENTAL = 74
    SPIRIT = 75
    ORGRIMMAR = 76
    TREASURE = 77
    GNOLL_MUDSNOUT = 78
    HILLSBRAD_SOUTHSHORE_MAYOR = 79
    DRAGONFLIGHT_BLACK = 80
    THUNDER_BLUFF = 81
    TROLL_WITHERBARK = 82
    LEATHERWORKING_ELEMENTAL = 83
    QUILBOAR_RAZORMANE = 84
    QUILBOAR_BRISTLEBACK = 85
    LEATHERWORKING_DRAGONSCALE = 86
    BLOODSAIL_BUCCANEERS = 87
    BLACKFATHOM = 88
    MAKRURA = 89
    CENTAUR_KOLKAR = 90
    CENTAUR_GALAK = 91
    GELKIS_CLAN_CENTAUR = 92
    MAGRAM_CLAN_CENTAUR = 93
    MARAUDINE = 94
    THERAMORE = 108
    QUILBOAR_RAZORFEN = 109
    QUILBOAR_RAZORMANE_2 = 110
    QUILBOAR_DEATHSHEAD = 111
    ENEMY = 128
    AMBIENT = 148
    NETHERGARDE_CARAVAN = 168
    STEAMWHEEDLE_CARTEL = 169
    ALLIANCE_GENERIC = 189
    NETHERGARDE = 209
    WAILING_CAVERNS = 229
    SILITHID = 249
    SILVERMOON_REMNANT = 269
    ZANDALAR_TRIBE = 270
    BLACKSMITHING_WEAPONSMITHING = 289
    SCORPID = 309
    BEAST_BAT = 310
    TITAN = 311
    TASKMASTER_FIZZULE = 329
    RAVENHOLDT = 349
    GADGETZAN = 369
    GNOMEREGAN_BUG = 389
    HARPY = 409
    BURNING_BLADE = 429
    SHADOWSILK_POACHER = 449
    SEARING_SPIDER = 450
    ALLIANCE = 469
    RATCHET = 470
    WILDHAMMER_CLAN = 471
    GOBLIN_DARK_IRON_BAR_PATRON = 489
    THE_LEAGUE_OF_ARATHOR = 509
    THE_DEFILERS = 510
    GIANT = 511
    ARGENT_DAWN = 529
    DARKSPEAR_TROLLS = 530
    DRAGONFLIGHT_BRONZE = 531
    DRAGONFLIGHT_BLUE = 532
    LEATHERWORKING_TRIBAL = 549
    ENGINEERING_GOBLIN = 550
    ENGINEERING_GNOME = 551
    BLACKSMITHING_HAMMERSMITHING = 569
    BLACKSMITHING_AXESMITHING = 570
    BLACKSMITHING_SWORDSMITHING = 571
    TROLL_VILEBRANCH = 572
    SOUTHSEA_FREEBOOTERS = 573
    CAER_DARROW = 574
    FURBOLG_UNCORRUPTED = 575
    TIMBERMAW_HOLD = 576
    EVERLOOK = 577
    WINTERSABER_TRAINERS = 589
    CENARION_CIRCLE = 609
    SHATTERSPEAR_TROLLS = 629
    RAVASAUR_TRAINERS = 630
    MAJORDOMO_EXECUTUS = 649
    BEAST_CARRION_BIRD = 669
    BEAST_CAT = 670
    BEAST_CRAB = 671
    BEAST_CROCILISK = 672
    BEAST_HYENA = 673
    BEAST_OWL = 674
    BEAST_SCORPID = 675
    BEAST_TALLSTRIDER = 676
    BEAST_TURTLE = 677
    BEAST_WIND_SERPENT = 678
    TRAINING_DUMMY = 679
    DRAGONFLIGHT_BLACK_BAIT = 689
    BATTLEGROUND_NEUTRAL = 709
    FROSTWOLF_CLAN = 729
    STORMPIKE_GUARD = 730
    HYDRAXIAN_WATERLORDS = 749
    SULFURON_FIRELORDS = 750
    GIZLOCKS_DUMMY = 769
    GIZLOCKS_CHARM = 770
    GIZLOCK = 771
    MORO_GAI = 789
    SPIRIT_GUIDE_ALLIANCE = 790
    SHEN_DRALAR = 809
    OGRE_CAPTAIN_KROMCRUSH = 829
    SPIRIT_GUIDE_HORDE = 849
    JAEDENAR = 869
    WARSONG_OUTRIDERS = 889
    SILVERWING_SENTINELS = 890
    ALLIANCE_FORCES = 891
    HORDE_FORCES = 892
    REVANTUSK_TROLLS = 893
    DARKMOON_FAIRE = 909
    BROOD_OF_NOZDORMU = 910
    SILVERMOON_CITY = 911
    MIGHT_OF_KALIMDOR = 912
    PLAYER_BLOOD_ELF = 914
    ARMIES_OF_C_THUN = 915
    SILITHID_ATTACKERS = 916
    THE_IRONFORGE_BRIGADE = 917
    RC_ENEMIES = 918
    RC_OBJECTS = 919
    RED = 920
    BLUE = 921
    TRANQUILLIEN = 922
    FARSTRIDERS = 923
    DEPRECATED = 924
    SUNSTRIDERS = 925
    MAGISTERS_GUILD = 926
    PLAYER_DRAENEI = 927
    SCOURGE_INVADERS = 928
    BLOODMAUL_CLAN = 929
    EXODAR = 930
    TEST_FACTION_NOT_A_REAL_FACTION = 931
    THE_ALDOR = 932
    THE_CONSORTIUM = 933
    THE_SCRYERS = 934
    THE_SHA_TAR = 935
    SHATTRATH_CITY = 936
    TROLL_FOREST = 937
    THE_OMENAI = 938
    DEPRECATED1 = 939
    THE_SONS_OF_LOTHAR = 940
    THE_MAG_HAR = 941
    CENARION_EXPEDITION = 942
    FEL_ORC = 943
    FEL_ORC_GHOST = 944
    SONS_OF_LOTHAR_GHOSTS = 945
    HONOR_HOLD = 946
    THRALLMAR = 947
    TEST_FACTION_2 = 948
    TEST_FACTION_1 = 949
    TOWOW_FLAG = 950
    TOWOW_FLAG_TRIGGER_ALLIANCE_DND = 951
    TEST_FACTION_3 = 952
    TEST_FACTION_4 = 953
    TOWOW_FLAG_TRIGGER_HORDE_DND = 954
    BROKEN = 955
    ETHEREUM = 956
    EARTH_ELEMENTAL = 957
    FIGHTING_ROBOTS = 958
    ACTOR_GOOD = 959
    ACTOR_EVIL = 960
    STILLPINE_FURBOLG = 961
    CRAZED_OWLKIN = 962
    CHESS_ALLIANCE = 963
    CHESS_HORDE = 964
    MONSTER_SPAR = 965
    MONSTER_SPAR_BUDDY = 966
    THE_VIOLET_EYE = 967
    SUNHAWKS = 968
    HAND_OF_ARGUS = 969
    SPOREGGAR = 970
    FUNGAL_GIANT = 971
    SPORE_BAT = 972
    MONSTER_PREDATOR = 973
    MONSTER_PREY = 974
    VOID_ANOMALY = 975
    HYJAL_DEFENDERS = 976
    HYJAL_INVADERS = 977
    KURENAI = 978
    EARTHEN_RING = 979
    OUTLAND = 980
    ARAKKOA = 981
    ZANGARMARSH_BANNER_ALLIANCE = 982
    ZANGARMARSH_BANNER_HORDE = 983
    ZANGARMARSH_BANNER_NEUTRAL = 984
    CAVERNS_OF_TIME_THRALL = 985
    CAVERNS_OF_TIME_DURNHOLDE = 986
    CAVERNS_OF_TIME_SOUTHSHORE_GUARDS = 987
    SHADOW_COUNCIL_COVERT = 988
    KEEPERS_OF_TIME = 989
    THE_SCALE_OF_THE_SANDS = 990
    DARK_PORTAL_DEFENDER_ALLIANCE = 991
    DARK_PORTAL_DEFENDER_HORDE = 992
    DARK_PORTAL_ATTACKER_LEGION = 993
    INCITER_TRIGGER = 994
    INCITER_TRIGGER_2 = 995
    INCITER_TRIGGER_3 = 996
    INCITER_TRIGGER_4 = 997
    INCITER_TRIGGER_5 = 998
    MANA_CREATURE = 999
    KHADGARS_SERVANT = 1000
    BLADESPIRE_CLAN = 1001
    ETHEREUM_SPARBUDDY = 1002
    PROTECTORATE = 1003
    ARCANE_ANNIHILATOR_DNR = 1004
    FRIENDLY_HIDDEN = 1005
    KIRIN_VAR_DATHRIC = 1006
    KIRIN_VAR_BELMARA = 1007
    KIRIN_VAR_LUMINRATH = 1008
    KIRIN_VAR_COHLIEN = 1009
    SERVANT_OF_ILLIDAN = 1010
    LOWER_CITY = 1011
    ASHTONGUE_DEATHSWORN = 1012
    SPIRITS_OF_SHADOWMOON_1 = 1013
    SPIRITS_OF_SHADOWMOON_2 = 1014
    NETHERWING = 1015
    WYRMCULT = 1016
    TREANT = 1017
    LEOTHERAS_DEMON_I = 1018
    LEOTHERAS_DEMON_II = 1019
    LEOTHERAS_DEMON_III = 1020
    LEOTHERAS_DEMON_IV = 1021
    LEOTHERAS_DEMON_V = 1022
    AZALOTH = 1023
    ROCK_FLAYER = 1024
    FLAYER_HUNTER = 1025
    SHADOWMOON_SHADE = 1026
    LEGION_COMMUNICATOR = 1027
    RAVENSWOOD_ANCIENTS = 1028
    CHESS_FRIENDLY_TO_ALL_CHESS = 1029
    BLACK_TEMPLE_GATES_ILLIDARI = 1030
    SHA_TARI_SKYGUARD = 1031
    AREA_52 = 1032
    MAIEV = 1033
    SKETTIS_SHADOWY_ARAKKOA = 1034
    SKETTIS_ARAKKOA = 1035
    DRAGONMAW_ENEMY = 1036
    REUSE = 1037
    OGRI_LA = 1038
    RAVAGER = 1039
    REUSE1 = 1040
    FRENZY = 1041
    SKYGUARD_ENEMY = 1042
    SKUNK_PETUNIA = 1043
    THERAMORE_DESERTER = 1044
    TROLL_AMANI = 1049
    CTF_FLAGS = 1059
    RAM_RACING_POWERUP_DND = 1069
    RAM_RACING_TRAP_DND = 1070
    CRAIGS_SQUIRRELS = 1071
    HOLIDAY_WATER_BARREL = 1074
    HOLIDAY_GENERIC = 1075
    SHATTERED_SUN_OFFENSIVE = 1077
    FIGHTING_VANITY_PET = 1078
    MONSTER_FORCE_REACTION = 1080
    OBJECT_FORCE_REACTION = 1081
    HOLIDAY_MONSTER = 1087


class FarSightOperation(enum.Enum):
    REMOVE = 0
    ADD = 1


class FriendResult(enum.Enum):
    DB_ERROR = 0
    LIST_FULL = 1
    ONLINE = 2
    OFFLINE = 3
    NOT_FOUND = 4
    REMOVED = 5
    ADDED_ONLINE = 6
    ADDED_OFFLINE = 7
    ALREADY = 8
    SELF = 9
    ENEMY = 10
    IGNORE_FULL = 11
    IGNORE_SELF = 12
    IGNORE_NOT_FOUND = 13
    IGNORE_ALREADY = 14
    IGNORE_ADDED = 15
    IGNORE_REMOVED = 16
    IGNORE_AMBIGUOUS = 17
    MUTE_FULL = 18
    MUTE_SELF = 19
    MUTE_NOT_FOUND = 20
    MUTE_ALREADY = 21
    MUTE_ADDED = 22
    MUTE_REMOVED = 23
    MUTE_AMBIGUOUS = 24
    UNKNOWN19 = 25
    UNKNOWN20 = 26


class FriendStatus(enum.Enum):
    OFFLINE = 0
    ONLINE = 1
    AFK = 2
    UNKNOWN3 = 3
    DND = 4


class Gender(enum.Enum):
    MALE = 0
    FEMALE = 1
    NONE = 2


class GmTicketEscalationStatus(enum.Enum):
    GMTICKET_ASSIGNEDTOGM_STATUS_NOT_ASSIGNED = 0
    GMTICKET_ASSIGNEDTOGM_STATUS_ASSIGNED = 1
    GMTICKET_ASSIGNEDTOGM_STATUS_ESCALATED = 2


class GmTicketQueueStatus(enum.Enum):
    ENABLED = 1
    DISABLED = 0


class GmTicketResponse(enum.Enum):
    NOT_EXIST = 0
    ALREADY_EXIST = 1
    CREATE_SUCCESS = 2
    CREATE_ERROR = 3
    UPDATE_SUCCESS = 4
    UPDATE_ERROR = 5
    TICKET_DELETED = 9


class GmTicketStatus(enum.Enum):
    DB_ERROR = 0
    HAS_TEXT = 6
    DEFAULT = 10


class GmTicketStatusResponse(enum.Enum):
    UPDATED = 1
    CLOSED = 2
    SURVEY = 3


class GmTicketType(enum.Enum):
    NOT_SET = 0
    STUCK = 1
    BEHAVIOR_HARASSMENT = 2
    GUILD = 3
    ITEM = 4
    ENVIRONMENTAL = 5
    NON_QUEST_CREEP = 6
    QUEST_QUEST_NPC = 7
    TECHNICAL = 8
    ACCOUNT_BILLING = 9
    CHARACTER = 10
    ARENA_HONOR_ITEM_ISSUES = 11
    ARENA_HONOR_POINTS_ISSUES = 12
    BOTTING_CHEATING_HACKING = 13
    BUG_REPORT = 14
    COMPROMISED_ACCOUNT_ISSUE = 15
    GAME_SUGGESTIONS = 16
    GAMEPLAY_QUESTION = 17
    GUILD_BANK_ISSUE = 18
    GUILD_MASTER_ISSUE = 19
    HARASSMENT_SCAM_REPORT = 20
    INAPPROPRIATE_NAME_GUILD_ARENA_CHARACTER_PET = 21
    KNOWN_ISSUE_FIX = 22
    LATENCY_LAG_REPORT = 23
    LOOTING_ISSUE_MISTAKE = 24
    MAIL_ISSUE = 25
    NON_IN_GAME_RELATED_INQUIRY = 26
    PARENTAL_CONTROLS_CAIS = 27
    PCNC = 28
    PCT = 29
    RESTORATION_STATUS_FOLLOW_UP = 30
    SERVER_INSTANCE_ISSUES = 31
    SPAM = 32
    SUICIDE_CASE = 33
    SUSPENSION_QUESTIONS = 34
    TECHNICAL_SOUND_GRAPHICS_ISSUE = 35
    UI_ISSUE = 36


class GroupLootSetting(enum.Enum):
    FREE_FOR_ALL = 0
    ROUND_ROBIN = 1
    MASTER_LOOT = 2
    GROUP_LOOT = 3
    NEED_BEFORE_GREED = 4


class GroupType(enum.Enum):
    NORMAL = 0
    RAID = 1


class GuildBankTabResult(enum.Enum):
    NOT_PRESENT = 0
    PRESENT = 1


class GuildCommand(enum.Enum):
    CREATE = 0
    INVITE = 1
    QUIT = 3
    FOUNDER = 14
    UNKNOWN19 = 19
    UNKNOWN20 = 20


class GuildCommandResult(enum.Enum):
    PLAYER_NO_MORE_IN_GUILD = 0
    GUILD_INTERNAL = 1
    ALREADY_IN_GUILD = 2
    ALREADY_IN_GUILD_S = 3
    INVITED_TO_GUILD = 4
    ALREADY_INVITED_TO_GUILD_S = 5
    GUILD_NAME_INVALID = 6
    GUILD_NAME_EXISTS_S = 7
    GUILD_LEADER_LEAVE_OR_PERMISSIONS = 8
    GUILD_PLAYER_NOT_IN_GUILD = 9
    GUILD_PLAYER_NOT_IN_GUILD_S = 10
    GUILD_PLAYER_NOT_FOUND_S = 11
    GUILD_NOT_ALLIED = 12
    GUILD_RANK_TOO_HIGH_S = 13
    GUILD_RANK_TOO_LOW_S = 14
    GUILD_RANKS_LOCKED = 17
    GUILD_RANK_IN_USE = 18
    GUILD_IGNORING_YOU_S = 19
    GUILD_UNK20 = 20


class GuildEmblemResult(enum.Enum):
    SUCCESS = 0
    INVALID_TABARD_COLORS = 1
    NO_GUILD = 2
    NOT_GUILD_MASTER = 3
    NOT_ENOUGH_MONEY = 4
    INVALID_VENDOR = 5


class GuildEvent(enum.Enum):
    PROMOTION = 0
    DEMOTION = 1
    MOTD = 2
    JOINED = 3
    LEFT = 4
    REMOVED = 5
    LEADER_IS = 6
    LEADER_CHANGED = 7
    DISBANDED = 8
    TABARD_CHANGED = 9
    UNK1 = 10
    UNK2 = 11
    SIGNED_ON = 12
    SIGNED_OFF = 13
    GUILD_BANK_BAG_SLOTS_CHANGED = 14
    BANKTAB_PURCHASED = 15
    UNK5 = 16
    GUILD_BANK_UPDATE_MONEY = 17
    GUILD_BANK_MONEY_WITHDRAWN = 18
    GUILD_BANK_TEXT_CHANGED = 19


class GuildMemberStatus(enum.Enum):
    OFFLINE = 0
    ONLINE = 1


class HitInfo(enum.Enum):
    NORMAL_SWING = 0
    UNK1 = 1
    AFFECTS_VICTIM = 2
    LEFT_SWING = 4
    EARLY_CRITICAL_HIT = 8
    MISS = 16
    ABSORB = 32
    RESIST = 64
    CRITICAL_HIT = 128
    UNK9 = 256
    UNK10 = 8192
    GLANCING = 16384
    CRUSHING = 32768
    NO_ACTION = 65536
    SWING_NO_HIT_SOUND = 524288


class InstanceResetFailedReason(enum.Enum):
    GENERAL = 0
    OFFLINE = 1
    ZONING = 2
    SILENTLY = 3


class InventoryResult(enum.Enum):
    OK = 0
    CANT_EQUIP_LEVEL_I = 1
    CANT_EQUIP_SKILL = 2
    ITEM_DOESNT_GO_TO_SLOT = 3
    BAG_FULL = 4
    NONEMPTY_BAG_OVER_OTHER_BAG = 5
    CANT_TRADE_EQUIP_BAGS = 6
    ONLY_AMMO_CAN_GO_HERE = 7
    NO_REQUIRED_PROFICIENCY = 8
    NO_EQUIPMENT_SLOT_AVAILABLE = 9
    YOU_CAN_NEVER_USE_THAT_ITEM = 10
    YOU_CAN_NEVER_USE_THAT_ITEM2 = 11
    NO_EQUIPMENT_SLOT_AVAILABLE2 = 12
    CANT_EQUIP_WITH_TWOHANDED = 13
    CANT_DUAL_WIELD = 14
    ITEM_DOESNT_GO_INTO_BAG = 15
    ITEM_DOESNT_GO_INTO_BAG2 = 16
    CANT_CARRY_MORE_OF_THIS = 17
    NO_EQUIPMENT_SLOT_AVAILABLE3 = 18
    ITEM_CANT_STACK = 19
    ITEM_CANT_BE_EQUIPPED = 20
    ITEMS_CANT_BE_SWAPPED = 21
    SLOT_IS_EMPTY = 22
    ITEM_NOT_FOUND = 23
    CANT_DROP_SOULBOUND = 24
    OUT_OF_RANGE = 25
    TRIED_TO_SPLIT_MORE_THAN_COUNT = 26
    COULDNT_SPLIT_ITEMS = 27
    MISSING_REAGENT = 28
    NOT_ENOUGH_MONEY = 29
    NOT_A_BAG = 30
    CAN_ONLY_DO_WITH_EMPTY_BAGS = 31
    DONT_OWN_THAT_ITEM = 32
    CAN_EQUIP_ONLY1_QUIVER = 33
    MUST_PURCHASE_THAT_BAG_SLOT = 34
    TOO_FAR_AWAY_FROM_BANK = 35
    ITEM_LOCKED = 36
    YOU_ARE_STUNNED = 37
    YOU_ARE_DEAD = 38
    CANT_DO_RIGHT_NOW = 39
    INT_BAG_ERROR = 40
    CAN_EQUIP_ONLY1_BOLT = 41
    CAN_EQUIP_ONLY1_AMMOPOUCH = 42
    STACKABLE_CANT_BE_WRAPPED = 43
    EQUIPPED_CANT_BE_WRAPPED = 44
    WRAPPED_CANT_BE_WRAPPED = 45
    BOUND_CANT_BE_WRAPPED = 46
    UNIQUE_CANT_BE_WRAPPED = 47
    BAGS_CANT_BE_WRAPPED = 48
    ALREADY_LOOTED = 49
    INVENTORY_FULL = 50
    BANK_FULL = 51
    ITEM_IS_CURRENTLY_SOLD_OUT = 52
    BAG_FULL3 = 53
    ITEM_NOT_FOUND2 = 54
    ITEM_CANT_STACK2 = 55
    BAG_FULL4 = 56
    ITEM_SOLD_OUT = 57
    OBJECT_IS_BUSY = 58
    NONE = 59
    NOT_IN_COMBAT = 60
    NOT_WHILE_DISARMED = 61
    BAG_FULL6 = 62
    CANT_EQUIP_RANK = 63
    CANT_EQUIP_REPUTATION = 64
    TOO_MANY_SPECIAL_BAGS = 65
    LOOT_CANT_LOOT_THAT_NOW = 66
    ITEM_UNIQUE_EQUIPABLE = 67
    VENDOR_MISSING_TURNINS = 68
    NOT_ENOUGH_HONOR_POINTS = 69
    NOT_ENOUGH_ARENA_POINTS = 70
    ITEM_MAX_COUNT_SOCKETED = 71
    MAIL_BOUND_ITEM = 72
    NO_SPLIT_WHILE_PROSPECTING = 73
    BAG_FULL7 = 74
    ITEM_MAX_COUNT_EQUIPPED_SOCKETED = 75
    ITEM_UNIQUE_EQUIPPABLE_SOCKETED = 76
    TOO_MUCH_GOLD = 77
    NOT_DURING_ARENA_MATCH = 78
    CANNOT_TRADE_THAT = 79
    PERSONAL_ARENA_RATING_TOO_LOW = 80


class InventoryType(enum.Enum):
    NON_EQUIP = 0
    HEAD = 1
    NECK = 2
    SHOULDERS = 3
    BODY = 4
    CHEST = 5
    WAIST = 6
    LEGS = 7
    FEET = 8
    WRISTS = 9
    HANDS = 10
    FINGER = 11
    TRINKET = 12
    WEAPON = 13
    SHIELD = 14
    RANGED = 15
    CLOAK = 16
    TWO_HANDED_WEAPON = 17
    BAG = 18
    TABARD = 19
    ROBE = 20
    WEAPON_MAIN_HAND = 21
    WEAPON_OFF_HAND = 22
    HOLDABLE = 23
    AMMO = 24
    THROWN = 25
    RANGED_RIGHT = 26
    QUIVER = 27
    RELIC = 28


class ItemClass(enum.Enum):
    CONSUMABLE = 0
    CONTAINER = 1
    WEAPON = 2
    GEM = 3
    ARMOR = 4
    REAGENT = 5
    PROJECTILE = 6
    TRADE_GOODS = 7
    GENERIC = 8
    RECIPE = 9
    MONEY = 10
    QUIVER = 11
    QUEST = 12
    KEY = 13
    PERMANENT = 14
    MISC = 15


class ItemClassAndSubClass(enum.Enum):
    CONSUMABLE = 0
    FOOD_AND_DRINK = 21474836480
    POTION = 4294967296
    ELIXIR = 8589934592
    FLASK = 12884901888
    BANDAGE = 30064771072
    ITEM_ENHANCEMENT = 25769803776
    SCROLL = 17179869184
    OTHER_CONSUMABLE = 34359738368
    BAG = 1
    SOUL_BAG = 4294967297
    HERB_BAG = 8589934593
    ENCHANTING_BAG = 12884901889
    ENGINEERING_BAG = 17179869185
    GEM_BAG = 21474836481
    MINING_BAG = 25769803777
    LEATHERWORKING_BAG = 30064771073
    ONE_HANDED_AXE = 2
    TWO_HANDED_AXE = 4294967298
    BOW = 8589934594
    GUN = 12884901890
    ONE_HANDED_MACE = 17179869186
    TWO_HANDED_MACE = 21474836482
    POLEARM = 25769803778
    ONE_HANDED_SWORD = 30064771074
    TWO_HANDED_SWORD = 34359738370
    OBSOLETE_WEAPON = 38654705666
    STAFF = 42949672962
    ONE_HANDED_EXOTIC = 47244640258
    TWO_HANDED_EXOTIC = 51539607554
    FIST_WEAPON = 55834574850
    MISCELLANEOUS_WEAPON = 60129542146
    DAGGER = 64424509442
    THROWN = 68719476738
    SPEAR = 73014444034
    CROSSBOW = 77309411330
    WAND = 81604378626
    FISHING_POLE = 85899345922
    GEM_RED = 3
    GEM_BLUE = 4294967299
    GEM_YELLOW = 8589934595
    GEM_PURPLE = 12884901891
    GEM_GREEN = 17179869187
    GEM_ORANGE = 21474836483
    GEM_META = 25769803779
    GEM_SIMPLE = 30064771075
    GEM_PRISMATIC = 34359738371
    MISCELLANEOUS_ARMOR = 4
    CLOTH_ARMOR = 4294967300
    LEATHER_ARMOR = 8589934596
    MAIL_ARMOR = 12884901892
    PLATE_ARMOR = 17179869188
    BUCKLER_OBSOLETE = 21474836484
    SHIELD = 25769803780
    LIBRAM = 30064771076
    IDOL = 34359738372
    TOTEM = 38654705668
    REAGENT = 5
    WAND_OBSOLETE = 6
    BOLT_OBSOLETE = 4294967302
    ARROW = 8589934598
    BULLET = 12884901894
    THROWN_OBSOLETE = 17179869190
    TRADE_GOOD = 7
    ELEMENTAL_TRADE_GOOD = 42949672967
    CLOTH_TRADE_GOOD = 21474836487
    LEATHER_TRADE_GOOD = 25769803783
    METAL_AND_STONE_TRADE_GOOD = 30064771079
    MEAT_TRADE_GOOD = 34359738375
    HERB_TRADE_GOOD = 38654705671
    ENCHANTING_TRADE_GOOD = 51539607559
    JEWELCRAFTING_TRADE_GOOD = 17179869191
    PART_TRADE_GOOD = 4294967303
    DEVICE_TRADE_GOOD = 12884901895
    EXPLOSIVE_TRADE_GOOD = 8589934599
    MATERIAL_TRADE_GOOD = 55834574855
    OTHER_TRADE_GOOD = 47244640263
    GENERIC_OBSOLETE = 8
    BOOK = 9
    LEATHERWORKING_RECIPE = 4294967305
    TAILORING_RECIPE = 8589934601
    ENGINEERING_RECIPE = 12884901897
    BLACKSMITHING_RECIPE = 17179869193
    COOKING_RECIPE = 21474836489
    ALCHEMY_RECIPE = 25769803785
    FIRST_AID_RECIPE = 30064771081
    ENCHANTING_RECIPE = 34359738377
    FISHING_RECIPE = 38654705673
    JEWELCRAFTING_RECIPE = 42949672969
    MONEY_OBSOLETE = 10
    QUIVER_OBSOLETE = 11
    QUIVER_OBSOLETE1 = 4294967307
    QUIVER = 8589934603
    AMMO_POUCH = 12884901899
    QUEST = 12
    KEY = 13
    LOCKPICK = 4294967309
    PERMANENT = 14
    JUNK = 15
    MISCELLANEOUS_REAGENT = 4294967311
    PET = 8589934607
    HOLIDAY = 12884901903
    MISCELLANEOUS_OTHER = 17179869199
    MOUNT = 21474836495


class ItemQuality(enum.Enum):
    POOR = 0
    NORMAL = 1
    UNCOMMON = 2
    RARE = 3
    EPIC = 4
    LEGENDARY = 5
    ARTIFACT = 6


class ItemSet(enum.Enum):
    NONE = 0
    THE_GLADIATOR = 1
    DAL_RENDS_ARMS = 41
    SPIDERS_KISS = 65
    THE_POSTMASTER = 81
    CADAVEROUS_GARB = 121
    NECROPILE_RAIMENT = 122
    BLOODMAIL_REGALIA = 123
    DEATHBONE_GUARDIAN = 124
    VOLCANIC_ARMOR = 141
    STORMSHROUD_ARMOR = 142
    DEVILSAUR_ARMOR = 143
    IRONFEATHER_ARMOR = 144
    DEFIAS_LEATHER = 161
    EMBRACE_OF_THE_VIPER = 162
    CHAIN_OF_THE_SCARLET_CRUSADE = 163
    MAGISTERS_REGALIA = 181
    VESTMENTS_OF_THE_DEVOUT = 182
    DREADMIST_RAIMENT = 183
    SHADOWCRAFT_ARMOR = 184
    WILDHEART_RAIMENT = 185
    BEASTSTALKER_ARMOR = 186
    THE_ELEMENTS = 187
    LIGHTFORGE_ARMOR = 188
    BATTLEGEAR_OF_VALOR = 189
    ARCANIST_REGALIA = 201
    VESTMENTS_OF_PROPHECY = 202
    FELHEART_RAIMENT = 203
    NIGHTSLAYER_ARMOR = 204
    CENARION_RAIMENT = 205
    GIANTSTALKER_ARMOR = 206
    THE_EARTHFURY = 207
    LAWBRINGER_ARMOR = 208
    BATTLEGEAR_OF_MIGHT = 209
    NETHERWIND_REGALIA = 210
    VESTMENTS_OF_TRANSCENDENCE = 211
    NEMESIS_RAIMENT = 212
    BLOODFANG_ARMOR = 213
    STORMRAGE_RAIMENT = 214
    DRAGONSTALKER_ARMOR = 215
    THE_TEN_STORMS = 216
    JUDGEMENT_ARMOR = 217
    BATTLEGEAR_OF_WRATH = 218
    GARB_OF_THERO_SHAN = 221
    SHARD_OF_THE_GODS = 241
    SPIRIT_OF_ESKHANDAR = 261
    CHAMPIONS_BATTLEGEAR = 281
    LIEUTENANT_COMMANDERS_BATTLEGEAR = 282
    CHAMPIONS_EARTHSHAKER = 301
    IMPERIAL_PLATE = 321
    CHAMPIONS_REGALIA = 341
    CHAMPIONS_RAIMENT = 342
    LIEUTENANT_COMMANDERS_REGALIA = 343
    LIEUTENANT_COMMANDERS_RAIMENT = 344
    CHAMPIONS_THREADS = 345
    LIEUTENANT_COMMANDERS_THREADS = 346
    CHAMPIONS_VESTMENTS = 347
    LIEUTENANT_COMMANDERS_VESTMENTS = 348
    CHAMPIONS_PURSUIT = 361
    LIEUTENANT_COMMANDERS_PURSUIT = 362
    LIEUTENANT_COMMANDERS_SANCTUARY = 381
    CHAMPIONS_SANCTUARY = 382
    WARLORDS_BATTLEGEAR = 383
    FIELD_MARSHALS_BATTLEGEAR = 384
    WARLORDS_EARTHSHAKER = 386
    WARLORDS_REGALIA = 387
    FIELD_MARSHALS_REGALIA = 388
    FIELD_MARSHALS_RAIMENT = 389
    WARLORDS_RAIMENT = 390
    WARLORDS_THREADS = 391
    FIELD_MARSHALS_THREADS = 392
    WARLORDS_VESTMENTS = 393
    FIELD_MARSHALS_VESTMENTS = 394
    FIELD_MARSHALS_PURSUIT = 395
    WARLORDS_PURSUIT = 396
    FIELD_MARSHALS_SANCTUARY = 397
    WARLORDS_SANCTUARY = 398
    LIEUTENANT_COMMANDERS_AEGIS = 401
    FIELD_MARSHALS_AEGIS = 402
    BLOODVINE_GARB = 421
    PRIMAL_BATSKIN = 441
    BLOOD_TIGER_HARNESS = 442
    BLOODSOUL_EMBRACE = 443
    THE_DARKSOUL = 444
    THE_TWIN_BLADES_OF_HAKKARI = 461
    ZANZILS_CONCENTRATION = 462
    PRIMAL_BLESSING = 463
    OVERLORDS_RESOLUTION = 464
    PRAYER_OF_THE_PRIMAL = 465
    MAJOR_MOJO_INFUSION = 466
    THE_HIGHLANDERS_RESOLUTION = 467
    THE_HIGHLANDERS_RESOLVE = 468
    THE_HIGHLANDERS_DETERMINATION = 469
    THE_HIGHLANDERS_FORTITUDE = 470
    THE_HIGHLANDERS_PURPOSE = 471
    THE_HIGHLANDERS_WILL = 472
    THE_HIGHLANDERS_INTENT = 473
    VINDICATORS_BATTLEGEAR = 474
    FREETHINKERS_ARMOR = 475
    AUGURS_REGALIA = 476
    PREDATORS_ARMOR = 477
    MADCAPS_OUTFIT = 478
    HARUSPEXS_GARB = 479
    CONFESSORS_RAIMENT = 480
    DEMONIACS_THREADS = 481
    ILLUSIONISTS_ATTIRE = 482
    THE_DEFILERS_DETERMINATION = 483
    THE_DEFILERS_FORTITUDE = 484
    THE_DEFILERS_INTENT = 485
    THE_DEFILERS_PURPOSE = 486
    THE_DEFILERS_RESOLUTION = 487
    THE_DEFILERS_WILL = 488
    BLACK_DRAGON_MAIL = 489
    GREEN_DRAGON_MAIL = 490
    BLUE_DRAGON_MAIL = 491
    TWILIGHT_TRAPPINGS = 492
    GENESIS_RAIMENT = 493
    SYMBOLS_OF_UNENDING_LIFE = 494
    BATTLEGEAR_OF_UNYIELDING_STRENGTH = 495
    CONQUERORS_BATTLEGEAR = 496
    DEATHDEALERS_EMBRACE = 497
    EMBLEMS_OF_VEILED_SHADOWS = 498
    DOOMCALLERS_ATTIRE = 499
    IMPLEMENTS_OF_UNSPOKEN_NAMES = 500
    STORMCALLERS_GARB = 501
    GIFT_OF_THE_GATHERING_STORM = 502
    ENIGMA_VESTMENTS = 503
    TRAPPINGS_OF_VAULTED_SECRETS = 504
    AVENGERS_BATTLEGEAR = 505
    BATTLEGEAR_OF_ETERNAL_JUSTICE = 506
    GARMENTS_OF_THE_ORACLE = 507
    FINERY_OF_INFINITE_WISDOM = 508
    STRIKERS_GARB = 509
    TRAPPINGS_OF_THE_UNSEEN_PATH = 510
    BATTLEGEAR_OF_HEROISM = 511
    DARKMANTLE_ARMOR = 512
    FERALHEART_RAIMENT = 513
    VESTMENTS_OF_THE_VIRTUOUS = 514
    BEASTMASTER_ARMOR = 515
    SOULFORGE_ARMOR = 516
    SORCERERS_REGALIA = 517
    DEATHMIST_RAIMENT = 518
    THE_FIVE_THUNDERS = 519
    IRONWEAVE_BATTLESUIT = 520
    DREAMWALKER_RAIMENT = 521
    CHAMPIONS_GUARD = 522
    DREADNAUGHTS_BATTLEGEAR = 523
    BONESCYTHE_ARMOR = 524
    VESTMENTS_OF_FAITH = 525
    FROSTFIRE_REGALIA = 526
    THE_EARTHSHATTERER = 527
    REDEMPTION_ARMOR = 528
    PLAGUEHEART_RAIMENT = 529
    CRYPTSTALKER_ARMOR = 530
    BATTLEGEAR_OF_UNDEAD_SLAYING = 533
    UNDEAD_SLAYERS_ARMOR = 534
    GARB_OF_THE_UNDEAD_SLAYER = 535
    REGALIA_OF_UNDEAD_CLEANSING = 536
    CHAMPIONS_BATTLEARMOR = 537
    CHAMPIONS_STORMCALLER = 538
    CHAMPIONS_REFUGE = 539
    CHAMPIONS_INVESTITURE = 540
    CHAMPIONS_DREADGEAR = 541
    CHAMPIONS_ARCANUM = 542
    CHAMPIONS_PURSUANCE = 543
    LIEUTENANT_COMMANDERS_REDOUBT = 544
    LIEUTENANT_COMMANDERS_BATTLEARMOR = 545
    LIEUTENANT_COMMANDERS_ARCANUM = 546
    LIEUTENANT_COMMANDERS_DREADGEAR = 547
    LIEUTENANT_COMMANDERS_GUARD = 548
    LIEUTENANT_COMMANDERS_INVESTITURE = 549
    LIEUTENANT_COMMANDERS_PURSUANCE = 550
    LIEUTENANT_COMMANDERS_REFUGE = 551
    WRATH_OF_SPELLFIRE = 552
    SHADOWS_EMBRACE = 553
    PRIMAL_MOONCLOTH = 554
    NETHERWEAVE_VESTMENTS = 555
    IMBUED_NETHERWEAVE = 556
    SOULCLOTH_EMBRACE = 557
    ARCANOWEAVE_VESTMENTS = 558
    SPELLSTRIKE_INFUSION = 559
    FEL_IRON_PLATE = 560
    FEL_IRON_CHAIN = 561
    ADAMANTITE_BATTLEGEAR = 562
    ENCHANTED_ADAMANTITE_ARMOR = 563
    FLAME_GUARD = 564
    KHORIUM_WARD = 565
    BURNING_RAGE = 566
    GLADIATORS_BATTLEGEAR = 567
    GLADIATORS_DREADGEAR = 568
    FAITH_IN_FELSTEEL = 569
    THE_UNYIELDING = 570
    WHITEMEND_WISDOM = 571
    BATTLECAST_GARB = 572
    FEL_SKIN = 573
    STRENGTH_OF_THE_CLEFTHOOF = 574
    FELSTALKER_ARMOR = 575
    FURY_OF_THE_NETHER = 576
    GLADIATORS_VESTMENTS = 577
    GLADIATORS_EARTHSHAKER = 578
    GLADIATORS_REGALIA = 579
    GLADIATORS_THUNDERFIST = 580
    GLADIATORS_RAIMENT = 581
    GLADIATORS_AEGIS = 582
    GLADIATORS_VINDICATION = 583
    GLADIATORS_SANCTUARY = 584
    GLADIATORS_WILDHIDE = 585
    GLADIATORS_PURSUIT = 586
    HIGH_WARLORDS_AEGIS = 587
    HIGH_WARLORDS_BATTLEGEAR = 588
    GRAND_MARSHALS_AEGIS = 589
    GRAND_MARSHALS_BATTLEGEAR = 590
    GRAND_MARSHALS_DREADGEAR = 591
    HIGH_WARLORDS_DREADGEAR = 592
    GRAND_MARSHALS_EARTHSHAKER = 593
    HIGH_WARLORDS_EARTHSHAKER = 594
    GRAND_MARSHALS_PURSUIT = 595
    HIGH_WARLORDS_PURSUIT = 596
    GRAND_MARSHALS_RAIMENT = 597
    HIGH_WARLORDS_RAIMENT = 598
    GRAND_MARSHALS_REGALIA = 599
    HIGH_WARLORDS_REGALIA = 600
    GRAND_MARSHALS_SANCTUARY = 601
    HIGH_WARLORDS_SANCTUARY = 602
    GRAND_MARSHALS_THUNDERFIST = 603
    HIGH_WARLORDS_THUNDERFIST = 604
    GRAND_MARSHALS_VESTMENTS = 605
    HIGH_WARLORDS_VESTMENTS = 606
    GRAND_MARSHALS_VINDICATION = 607
    HIGH_WARLORDS_VINDICATION = 608
    GRAND_MARSHALS_WILDHIDE = 609
    HIGH_WARLORDS_WILDHIDE = 610
    FELSCALE_ARMOR = 611
    SCALED_DRAENIC_ARMOR = 612
    THICK_DRAENIC_ARMOR = 613
    WILD_DRAENISH_ARMOR = 614
    GLADIATORS_FELSHROUD = 615
    NETHERSCALE_ARMOR = 616
    NETHERSTRIKE_ARMOR = 617
    WINDHAWK_ARMOR = 618
    PRIMAL_INTENT = 619
    ASSASSINATION_ARMOR = 620
    NETHERBLADE = 621
    DEATHMANTLE = 622
    RIGHTEOUS_ARMOR = 623
    JUSTICAR_RAIMENT = 624
    JUSTICAR_ARMOR = 625
    JUSTICAR_BATTLEGEAR = 626
    CRYSTALFORGE_RAIMENT = 627
    CRYSTALFORGE_ARMOR = 628
    CRYSTALFORGE_BATTLEGEAR = 629
    TIDEFURY_RAIMENT = 630
    CYCLONE_RAIMENT = 631
    CYCLONE_REGALIA = 632
    CYCLONE_HARNESS = 633
    CATACLYSM_RAIMENT = 634
    CATACLYSM_REGALIA = 635
    CATACLYSM_HARNESS = 636
    MOONGLADE_RAIMENT = 637
    MALORNE_RAIMENT = 638
    MALORNE_REGALIA = 639
    MALORNE_HARNESS = 640
    NORDRASSIL_HARNESS = 641
    NORDRASSIL_RAIMENT = 642
    NORDRASSIL_REGALIA = 643
    OBLIVION_RAIMENT = 644
    VOIDHEART_RAIMENT = 645
    CORRUPTOR_RAIMENT = 646
    INCANTERS_REGALIA = 647
    ALDOR_REGALIA = 648
    TIRISFAL_REGALIA = 649
    BEAST_LORD_ARMOR = 650
    DEMON_STALKER_ARMOR = 651
    RIFT_STALKER_ARMOR = 652
    BOLD_ARMOR = 653
    WARBRINGER_ARMOR = 654
    WARBRINGER_BATTLEGEAR = 655
    DESTROYER_ARMOR = 656
    DESTROYER_BATTLEGEAR = 657
    MANA_ETCHED_REGALIA = 658
    WASTEWALKER_ARMOR = 659
    DESOLATION_BATTLEGEAR = 660
    DOOMPLATE_BATTLEGEAR = 661
    HALLOWED_RAIMENT = 662
    INCARNATE_RAIMENT = 663
    INCARNATE_REGALIA = 664
    AVATAR_RAIMENT = 665
    AVATAR_REGALIA = 666
    THE_TWIN_STARS = 667
    SLAYERS_ARMOR = 668
    GRONNSTALKERS_ARMOR = 669
    MALEFIC_RAIMENT = 670
    TEMPEST_REGALIA = 671
    ONSLAUGHT_BATTLEGEAR = 672
    ONSLAUGHT_ARMOR = 673
    ABSOLUTION_REGALIA = 674
    VESTMENTS_OF_ABSOLUTION = 675
    THUNDERHEART_HARNESS = 676
    THUNDERHEART_REGALIA = 677
    THUNDERHEART_RAIMENT = 678
    LIGHTBRINGER_ARMOR = 679
    LIGHTBRINGER_BATTLEGEAR = 680
    LIGHTBRINGER_RAIMENT = 681
    SKYSHATTER_HARNESS = 682
    SKYSHATTER_RAIMENT = 683
    SKYSHATTER_REGALIA = 684
    GLADIATORS_REFUGE = 685
    GLADIATORS_WARTIDE = 686
    GLADIATORS_INVESTITURE = 687
    GRAND_MARSHALS_REFUGE = 688
    HIGH_WARLORDS_REFUGE = 689
    GLADIATORS_REDEMPTION = 690
    GRAND_MARSHALS_INVESTITURE = 691
    HIGH_WARLORDS_INVESTITURE = 692
    GRAND_MARSHALS_REDEMPTION = 693
    HIGH_WARLORDS_REDEMPTION = 694
    GRAND_MARSHALS_WARTIDE = 695
    HIGH_WARLORDS_WARTIDE = 696
    CHAMPIONS_REDOUBT = 697
    WARLORDS_AEGIS = 698
    THE_TWIN_BLADES_OF_AZZINOTH = 699
    MERCILESS_GLADIATORS_AEGIS = 700
    MERCILESS_GLADIATORS_BATTLEGEAR = 701
    MERCILESS_GLADIATORS_DREADGEAR = 702
    MERCILESS_GLADIATORS_EARTHSHAKER = 703
    MERCILESS_GLADIATORS_FELSHROUD = 704
    MERCILESS_GLADIATORS_INVESTITURE = 705
    MERCILESS_GLADIATORS_PURSUIT = 706
    MERCILESS_GLADIATORS_RAIMENT = 707
    MERCILESS_GLADIATORS_REDEMPTION = 708
    MERCILESS_GLADIATORS_REFUGE = 709
    MERCILESS_GLADIATORS_REGALIA = 710
    MERCILESS_GLADIATORS_SANCTUARY = 711
    MERCILESS_GLADIATORS_THUNDERFIST = 712
    MERCILESS_GLADIATORS_VESTMENTS = 713
    MERCILESS_GLADIATORS_VINDICATION = 714
    MERCILESS_GLADIATORS_WARTIDE = 715
    MERCILESS_GLADIATORS_WILDHIDE = 716
    FIELD_MARSHALS_EARTHSHAKER = 717
    LIEUTENANT_COMMANDERS_EARTHSHAKER = 718
    THE_FISTS_OF_FURY = 719
    VENGEFUL_GLADIATORS_REFUGE = 720
    VENGEFUL_GLADIATORS_SANCTUARY = 721
    VENGEFUL_GLADIATORS_WILDHIDE = 722
    VENGEFUL_GLADIATORS_PURSUIT = 723
    VENGEFUL_GLADIATORS_REGALIA = 724
    VENGEFUL_GLADIATORS_REDEMPTION = 725
    VENGEFUL_GLADIATORS_VINDICATION = 726
    VENGEFUL_GLADIATORS_AEGIS = 727
    VENGEFUL_GLADIATORS_INVESTITURE = 728
    VENGEFUL_GLADIATORS_RAIMENT = 729
    VENGEFUL_GLADIATORS_VESTMENTS = 730
    VENGEFUL_GLADIATORS_WARTIDE = 731
    VENGEFUL_GLADIATORS_EARTHSHAKER = 732
    VENGEFUL_GLADIATORS_THUNDERFIST = 733
    VENGEFUL_GLADIATORS_DREADGEAR = 734
    VENGEFUL_GLADIATORS_FELSHROUD = 735
    VENGEFUL_GLADIATORS_BATTLEGEAR = 736
    LATROS_FLURRY = 737
    DREADWEAVE_BATTLEGEAR = 738
    MOONCLOTH_BATTLEGEAR = 739
    SATIN_BATTLEGEAR = 740
    EVOKERS_SILK_BATTLEGEAR = 741
    DRAGONHIDE_BATTLEGEAR = 742
    WYRMHIDE_BATTLEGEAR = 743
    KODOHIDE_BATTLEGEAR = 744
    OPPORTUNISTS_BATTLEGEAR = 745
    SEERS_MAIL_BATTLEGEAR = 746
    SEERS_RINGMAIL_BATTLEGEAR = 747
    SEERS_LINKED_BATTLEGEAR = 748
    STALKERS_CHAIN_BATTLEGEAR = 749
    SAVAGE_PLATE_BATTLEGEAR = 750
    CRUSADERS_ORNAMENTED_BATTLEGEAR = 751
    CRUSADERS_SCALED_BATTLEGEAR = 752


class ItemSlot(enum.Enum):
    HEAD = 0
    NECK = 1
    SHOULDERS = 2
    SHIRT = 3
    CHEST = 4
    WAIST = 5
    LEGS = 6
    BOOTS = 7
    WRIST = 8
    HANDS = 9
    RING1 = 10
    RING2 = 11
    TRINKET1 = 12
    TRINKET2 = 13
    BACK = 14
    MAIN_HAND = 15
    OFF_HAND = 16
    RANGED_OR_RELIC = 17
    TABARD = 18
    BAG1 = 19
    BAG2 = 20
    BAG3 = 21
    BAG4 = 22
    INVENTORY_0 = 23
    INVENTORY_1 = 24
    INVENTORY_2 = 25
    INVENTORY_3 = 26
    INVENTORY_4 = 27
    INVENTORY_5 = 28
    INVENTORY_6 = 29
    INVENTORY_7 = 30
    INVENTORY_8 = 31
    INVENTORY_9 = 32
    INVENTORY_10 = 33
    INVENTORY_11 = 34
    INVENTORY_12 = 35
    INVENTORY_13 = 36
    INVENTORY_14 = 37
    INVENTORY_15 = 38
    BANK_1 = 39
    BANK_2 = 40
    BANK_3 = 41
    BANK_4 = 42
    BANK_5 = 43
    BANK_6 = 44
    BANK_7 = 45
    BANK_8 = 46
    BANK_9 = 47
    BANK_10 = 48
    BANK_11 = 49
    BANK_12 = 50
    BANK_13 = 51
    BANK_14 = 52
    BANK_15 = 53
    BANK_16 = 54
    BANK_17 = 55
    BANK_18 = 56
    BANK_19 = 57
    BANK_20 = 58
    BANK_21 = 59
    BANK_22 = 60
    BANK_23 = 61
    BANK_24 = 62
    BANK_25 = 63
    BANK_26 = 64
    BANK_27 = 65
    BANK_28 = 66
    BANK_BAG_SLOT_1 = 67
    BANK_BAG_SLOT_2 = 68
    BANK_BAG_SLOT_3 = 69
    BANK_BAG_SLOT_4 = 70
    BANK_BAG_SLOT_5 = 71
    BANK_BAG_SLOT_6 = 72
    BANK_BAG_SLOT_7 = 73
    VENDOR_BUYBACK_1 = 74
    VENDOR_BUYBACK_2 = 75
    VENDOR_BUYBACK_3 = 76
    VENDOR_BUYBACK_4 = 77
    VENDOR_BUYBACK_5 = 78
    VENDOR_BUYBACK_6 = 79
    VENDOR_BUYBACK_7 = 80
    VENDOR_BUYBACK_8 = 81
    VENDOR_BUYBACK_9 = 82
    VENDOR_BUYBACK_10 = 83
    VENDOR_BUYBACK_11 = 84
    VENDOR_BUYBACK_12 = 85
    KEYRING_1 = 86
    KEYRING_2 = 87
    KEYRING_3 = 88
    KEYRING_4 = 89
    KEYRING_5 = 90
    KEYRING_6 = 91
    KEYRING_7 = 92
    KEYRING_8 = 93
    KEYRING_9 = 94
    KEYRING_10 = 95
    KEYRING_11 = 96
    KEYRING_12 = 97
    KEYRING_13 = 98
    KEYRING_14 = 99
    KEYRING_15 = 100
    KEYRING_16 = 101
    KEYRING_17 = 102
    KEYRING_18 = 103
    KEYRING_19 = 104
    KEYRING_20 = 105
    KEYRING_21 = 106
    KEYRING_22 = 107
    KEYRING_23 = 108
    KEYRING_24 = 109
    KEYRING_25 = 110
    KEYRING_26 = 111
    KEYRING_27 = 112
    KEYRING_28 = 113
    KEYRING_29 = 114
    KEYRING_30 = 115
    KEYRING_31 = 116
    KEYRING_32 = 117
    VANITY_PET_1 = 118
    VANITY_PET_2 = 119
    VANITY_PET_3 = 120
    VANITY_PET_4 = 121
    VANITY_PET_5 = 122
    VANITY_PET_6 = 123
    VANITY_PET_7 = 124
    VANITY_PET_8 = 125
    VANITY_PET_9 = 126
    VANITY_PET_10 = 127
    VANITY_PET_11 = 128
    VANITY_PET_12 = 129
    VANITY_PET_13 = 130
    VANITY_PET_14 = 131
    VANITY_PET_15 = 132
    VANITY_PET_16 = 133
    VANITY_PET_17 = 134
    VANITY_PET_18 = 135


class JoinArenaType(enum.Enum):
    TWO_VS_TWO = 0
    THREE_VS_THREE = 1
    FIVE_VS_FIVE = 2


class Language(enum.Enum):
    UNIVERSAL = 0
    ORCISH = 1
    DARNASSIAN = 2
    TAURAHE = 3
    DWARVISH = 6
    COMMON = 7
    DEMONIC = 8
    TITAN = 9
    THALASSIAN = 10
    DRACONIC = 11
    KALIMAG = 12
    GNOMISH = 13
    TROLL = 14
    GUTTERSPEAK = 33
    DRAENEI = 35
    ZOMBIE = 36
    GNOMISH_BINARY = 37
    GOBLIN_BINARY = 38


class LfgMode(enum.Enum):
    LOOKING_FOR_GROUP = 0
    LOOKING_FOR_MORE = 1


class LfgType(enum.Enum):
    NONE = 0
    DUNGEON = 1
    RAID = 2
    QUEST = 3
    ZONE = 4
    HEROIC_DUNGEON = 5


class LfgUpdateLookingForMore(enum.Enum):
    NOT_LOOKING_FOR_MORE = 0
    LOOKING_FOR_MORE = 1


class LogFormat(enum.Enum):
    DEFAULT = 0
    DEBUG = 1


class LogoutResult(enum.Enum):
    SUCCESS = 0
    FAILURE_IN_COMBAT = 1
    FAILURE_FROZEN_BY_GM = 2
    FAILURE_JUMPING_OR_FALLING = 3


class LogoutSpeed(enum.Enum):
    DELAYED = 0
    INSTANT = 1


class LootMethod(enum.Enum):
    ERROR = 0
    CORPSE = 1
    PICKPOCKETING = 2
    FISHING = 3
    DISENCHANTING = 4
    SKINNING = 6
    FISHINGHOLE = 20
    FISHING_FAIL = 21
    INSIGNIA = 22


class LootMethodError(enum.Enum):
    DIDNT_KILL = 0
    TOO_FAR = 4
    BAD_FACING = 5
    LOCKED = 6
    NOTSTANDING = 8
    STUNNED = 9
    PLAYER_NOT_FOUND = 10
    PLAY_TIME_EXCEEDED = 11
    MASTER_INV_FULL = 12
    MASTER_UNIQUE_ITEM = 13
    MASTER_OTHER = 14
    ALREADY_PICKPOCKETED = 15
    NOT_WHILE_SHAPESHIFTED = 16


class LootSlotType(enum.Enum):
    TYPE_ALLOW_LOOT = 0
    TYPE_ROLL_ONGOING = 1
    TYPE_MASTER = 2
    TYPE_LOCKED = 3
    TYPE_OWNER = 4


class MailAction(enum.Enum):
    SEND = 0
    MONEY_TAKEN = 1
    ITEM_TAKEN = 2
    RETURNED_TO_SENDER = 3
    DELETED = 4
    MADE_PERMANENT = 5


class MailMessageType(enum.Enum):
    NORMAL = 0
    AUCTION = 2
    CREATURE = 3
    GAMEOBJECT = 4
    ITEM = 5


class MailResult(enum.Enum):
    OK = 0
    ERR_EQUIP_ERROR = 1
    ERR_CANNOT_SEND_TO_SELF = 2
    ERR_NOT_ENOUGH_MONEY = 3
    ERR_RECIPIENT_NOT_FOUND = 4
    ERR_NOT_YOUR_TEAM = 5
    ERR_INTERNAL_ERROR = 6
    ERR_DISABLED_FOR_TRIAL_ACC = 14
    ERR_RECIPIENT_CAP_REACHED = 15
    ERR_CANT_SEND_WRAPPED_COD = 16
    ERR_MAIL_AND_CHAT_SUSPENDED = 17
    ERR_TOO_MANY_ATTACHMENTS = 18
    ERR_MAIL_ATTACHMENT_INVALID = 19


class MailResultTwo(enum.Enum):
    OK = 0
    ERR_EQUIP_ERROR = 1
    ERR_CANNOT_SEND_TO_SELF = 2
    ERR_NOT_ENOUGH_MONEY = 3
    ERR_RECIPIENT_NOT_FOUND = 4
    ERR_NOT_YOUR_TEAM = 5
    ERR_INTERNAL_ERROR = 6
    ERR_DISABLED_FOR_TRIAL_ACC = 14
    ERR_RECIPIENT_CAP_REACHED = 15
    ERR_CANT_SEND_WRAPPED_COD = 16
    ERR_MAIL_AND_CHAT_SUSPENDED = 17
    ERR_TOO_MANY_ATTACHMENTS = 18
    ERR_MAIL_ATTACHMENT_INVALID = 19


class MailType(enum.Enum):
    NORMAL = 0
    AUCTION = 2
    CREATURE = 3
    GAMEOBJECT = 4
    ITEM = 5


class Map(enum.Enum):
    EASTERN_KINGDOMS = 0
    KALIMDOR = 1
    TESTING = 13
    SCOTT_TEST = 25
    CASH_TEST = 29
    ALTERAC_VALLEY = 30
    SHADOWFANG_KEEP = 33
    STORMWIND_STOCKADE = 34
    STORMWIND_PRISON = 35
    DEADMINES = 36
    AZSHARA_CRATER = 37
    COLLINS_TEST = 42
    WAILING_CAVERNS = 43
    MONASTERY_UNUSED = 44
    RAZORFEN_KRAUL = 47
    BLACKFATHOM_DEEPS = 48
    ULDAMAN = 70
    GNOMEREGAN = 90
    SUNKEN_TEMPLE = 109
    RAZORFEN_DOWNS = 129
    EMERALD_DREAM = 169
    SCARLET_MONASTERY = 189
    ZUL_FARRAK = 209
    BLACKROCK_SPIRE = 229
    BLACKROCK_DEPTHS = 230
    ONYXIAS_LAIR = 249
    OPENING_OF_THE_DARK_PORTAL = 269
    SCHOLOMANCE = 289
    ZUL_GURUB = 309
    STRATHOLME = 329
    MARAUDON = 349
    DEEPRUN_TRAM = 369
    RAGEFIRE_CHASM = 389
    MOLTEN_CORE = 409
    DIRE_MAUL = 429
    ALLIANCE_PVP_BARRACKS = 449
    HORDE_PVP_BARRACKS = 450
    DEVELOPMENT_LAND = 451
    BLACKWING_LAIR = 469
    WARSONG_GULCH = 489
    RUINS_OF_AHN_QIRAJ = 509
    ARATHI_BASIN = 529
    OUTLAND = 530
    AHN_QIRAJ_TEMPLE = 531
    KARAZHAN = 532
    NAXXRAMAS = 533
    THE_BATTLE_FOR_MOUNT_HYJAL = 534
    HELLFIRE_CITADEL_THE_SHATTERED_HALLS = 540
    HELLFIRE_CITADEL_THE_BLOOD_FURNACE = 542
    HELLFIRE_CITADEL_RAMPARTS = 543
    MAGTHERIDONS_LAIR = 544
    COILFANG_THE_STEAMVAULT = 545
    COILFANG_THE_UNDERBOG = 546
    COILFANG_THE_SLAVE_PENS = 547
    COILFANG_SERPENTSHRINE_CAVERN = 548
    TEMPEST_KEEP = 550
    TEMPEST_KEEP_THE_ARCATRAZ = 552
    TEMPEST_KEEP_THE_BOTANICA = 553
    TEMPEST_KEEP_THE_MECHANAR = 554
    AUCHINDOUN_SHADOW_LABYRINTH = 555
    AUCHINDOUN_SETHEKK_HALLS = 556
    AUCHINDOUN_MANA_TOMBS = 557
    AUCHINDOUN_AUCHENAI_CRYPTS = 558
    NAGRAND_ARENA = 559
    THE_ESCAPE_FROM_DURNHOLDE = 560
    BLADES_EDGE_ARENA = 562
    BLACK_TEMPLE = 564
    GRUULS_LAIR = 565
    EYE_OF_THE_STORM = 566
    ZUL_AMAN = 568
    RUINS_OF_LORDAERON = 572
    THE_SUNWELL = 580
    TRANSPORT_RUT_THERAN_TO_AUBERDINE = 582
    TRANSPORT_MENETHIL_TO_THERAMORE = 584
    MAGISTERS_TERRACE = 585
    TRANSPORT_EXODAR_TO_AUBERDINE = 586
    TRANSPORT_FEATHERMOON_FERRY = 587
    TRANSPORT_MENETHIL_TO_AUBERDINE = 588
    TRANSPORT_ORGRIMMAR_TO_GROM_GOL = 589
    TRANSPORT_GROM_GOL_TO_UNDERCITY = 590
    TRANSPORT_UNDERCITY_TO_ORGRIMMAR = 591
    TRANSPORT_BOOTY_BAY_TO_RATCHET = 593
    SUNWELL_FIX_UNUSED = 598


class MeetingStoneStatus(enum.Enum):
    LEAVE_QUEUE = 0
    JOINED_QUEUE = 1
    PARTY_MEMBER_LEFT_LFG = 2
    PARTY_MEMBER_REMOVED_PARTY_REMOVED = 3
    LOOKING_FOR_NEW_PARTY_IN_QUEUE = 4
    NONE = 5


class MonsterMoveType(enum.Enum):
    NORMAL = 0
    STOP = 1
    FACING_SPOT = 2
    FACING_TARGET = 3
    FACING_ANGLE = 4


class MountResult(enum.Enum):
    INVALID_MOUNTEE = 0
    TOO_FAR_AWAY = 1
    ALREADY_MOUNTED = 2
    NOT_MOUNTABLE = 3
    NOT_YOUR_PET = 4
    OTHER = 5
    LOOTING = 6
    RACE_CANT_MOUNT = 7
    SHAPESHIFTED = 8
    FORCED_DISMOUNT = 9
    OK = 10


class NewItemChatAlert(enum.Enum):
    DO_NOT_SHOW = 0
    SHOW = 1


class NewItemCreationType(enum.Enum):
    RECEIVED = 0
    CREATED = 1


class NewItemSource(enum.Enum):
    LOOTED = 0
    FROM_NPC = 1


class ObjectType(enum.Enum):
    OBJECT = 0
    ITEM = 1
    CONTAINER = 2
    UNIT = 3
    PLAYER = 4
    GAME_OBJECT = 5
    DYNAMIC_OBJECT = 6
    CORPSE = 7


class PageTextMaterial(enum.Enum):
    NONE = 0
    PARCHMENT = 1
    STONE = 2
    MARBLE = 3
    SILVER = 4
    BRONZE = 5
    VALENTINE = 6
    ILLIDAN = 7


class PartyOperation(enum.Enum):
    INVITE = 0
    LEAVE = 2


class PartyResult(enum.Enum):
    SUCCESS = 0
    BAD_PLAYER_NAME = 1
    TARGET_NOT_IN_GROUP = 2
    TARGET_NOT_IN_INSTANCE = 3
    GROUP_FULL = 4
    ALREADY_IN_GROUP = 5
    NOT_IN_GROUP = 6
    NOT_LEADER = 7
    PLAYER_WRONG_FACTION = 8
    IGNORING_YOU = 9
    LFG_PENDING = 12
    INVITE_RESTRICTED = 13


class PartyRole(enum.Enum):
    MAIN_TANK = 0
    ASSISTANT = 1


class PetCommandState(enum.Enum):
    STAY = 0
    FOLLOW = 1
    ATTACK = 2
    DISMISS = 3


class PetEnabled(enum.Enum):
    ENABLED = 8
    DISABLED = 0


class PetFeedback(enum.Enum):
    PET_DEAD = 1
    NOTHING_TO_ATTACK = 2
    CANT_ATTACK_TARGET = 3
    NO_PATH_TO = 4


class PetNameInvalidReason(enum.Enum):
    INVALID = 1
    NO_NAME = 2
    TOO_SHORT = 3
    TOO_LONG = 4
    MIXED_LANGUAGES = 6
    PROFANE = 7
    RESERVED = 8
    THREE_CONSECUTIVE = 11
    INVALID_SPACE = 12
    CONSECUTIVE_SPACES = 13
    RUSSIAN_CONSECUTIVE_SILENT_CHARACTERS = 14
    RUSSIAN_SILENT_CHARACTER_AT_BEGINNING_OR_END = 15
    DECLENSION_DOESNT_MATCH_BASE_NAME = 16


class PetQueryDisabledNames(enum.Enum):
    PRESENT = 1
    NOT_PRESENT = 0


class PetReactState(enum.Enum):
    PASSIVE = 0
    DEFENSIVE = 1
    AGGRESSIVE = 2


class PetTalkReason(enum.Enum):
    SPECIAL_SPELL = 0
    ATTACK = 1


class PetTameFailureReason(enum.Enum):
    INVALID_CREATURE = 1
    TOO_MANY = 2
    CREATURE_ALREADY_OWNED = 3
    NOT_TAMEABLE = 4
    ANOTHER_SUMMON_ACTIVE = 5
    UNITS_CANT_TAME = 6
    NO_PET_AVAILABLE = 7
    INTERNAL_ERROR = 8
    TOO_HIGH_LEVEL = 9
    DEAD = 10
    NOT_DEAD = 11
    UNKNOWN_ERROR = 12


class PetitionResult(enum.Enum):
    OK = 0
    ALREADY_SIGNED = 1
    ALREADY_IN_GUILD = 2
    CANT_SIGN_OWN = 3
    NOT_SERVER = 4


class PlayerChatTag(enum.Enum):
    NONE = 0
    AFK = 1
    DND = 2
    GM = 3


class Power(enum.Enum):
    MANA = 0
    RAGE = 1
    FOCUS = 2
    ENERGY = 3
    HAPPINESS = 4
    HEALTH = 254


class PvpRank(enum.Enum):
    NO_RANK = 0
    PARIAH = 1
    OUTLAW = 2
    EXILED = 3
    DISHONORED = 4
    RANK1 = 5
    RANK2 = 6
    RANK3 = 7
    RANK4 = 8
    RANK5 = 9
    RANK6 = 10
    RANK7 = 11
    RANK8 = 12
    RANK9 = 13
    RANK10 = 14
    RANK11 = 15
    RANK12 = 16
    RANK13 = 17
    RANK14 = 18
    FACTION_LEADER = 19


class QuestCompletable(enum.Enum):
    NOT_COMPLETABLE = 0
    COMPLETEABLE = 3


class QuestFailedReason(enum.Enum):
    DONT_HAVE_REQ = 0
    QUEST_FAILED_LOW_LEVEL = 1
    QUEST_FAILED_WRONG_RACE = 6
    QUEST_ALREADY_DONE = 7
    QUEST_ONLY_ONE_TIMED = 12
    QUEST_ALREADY_ON = 13
    QUEST_FAILED_EXPANSION = 16
    QUEST_ALREADY_ON2 = 18
    QUEST_FAILED_MISSING_ITEMS = 21
    QUEST_FAILED_NOT_ENOUGH_MONEY = 23
    DAILY_QUESTS_REMAINING = 26
    QUEST_FAILED_CAIS = 27


class QuestGiverStatus(enum.Enum):
    NONE = 0
    UNAVAILABLE = 1
    CHAT = 2
    INCOMPLETE = 3
    REWARD_REP = 4
    AVAILABLE_REP = 5
    AVAILABLE = 6
    REWARD_OLD = 7
    REWARD2 = 8


class QuestPartyMessage(enum.Enum):
    SHARING_QUEST = 0
    CANT_TAKE_QUEST = 1
    ACCEPT_QUEST = 2
    DECLINE_QUEST = 3
    TOO_FAR = 4
    BUSY = 5
    LOG_FULL = 6
    HAVE_QUEST = 7
    FINISH_QUEST = 8


class Race(enum.Enum):
    HUMAN = 1
    ORC = 2
    DWARF = 3
    NIGHT_ELF = 4
    UNDEAD = 5
    TAUREN = 6
    GNOME = 7
    TROLL = 8
    GOBLIN = 9
    BLOOD_ELF = 10
    DRAENEI = 11
    FEL_ORC = 12
    NAGA = 13
    BROKEN = 14
    SKELETON = 15
    VRYKUL = 16
    TUSKARR = 17
    FOREST_TROLL = 18


class RaidGroupError(enum.Enum):
    REQUIRED = 1
    FULL = 2


class RaidInstanceMessage(enum.Enum):
    WARNING_HOURS = 1
    WARNING_MIN = 2
    WARNING_MIN_SOON = 3
    WELCOME = 4


class RaidTargetIndex(enum.Enum):
    UNKNOWN0 = 0
    UNKNOWN1 = 1
    UNKNOWN2 = 2
    UNKNOWN3 = 3
    UNKNOWN4 = 4
    UNKNOWN5 = 5
    UNKNOWN6 = 6
    UNKNOWN7 = 7
    UNKNOWN8 = 8
    REQUEST_ICONS = 255


class RaidTargetUpdateType(enum.Enum):
    PARTIAL = 0
    FULL = 1


class RealmSplitState(enum.Enum):
    NORMAL = 0
    SPLIT = 1
    SPLIT_PENDING = 2


class ReferAFriendError(enum.Enum):
    NONE = 0
    NOT_REFERRED_BY = 1
    TARGET_TOO_HIGH = 2
    INSUFFICIENT_GRANTABLE_LEVELS = 3
    TOO_FAR = 4
    DIFFERENT_FACTION = 5
    NOT_NOW = 6
    GRANT_LEVEL_MAX = 7
    NO_TARGET = 8
    NOT_IN_GROUP = 9
    SUMMON_LEVEL_MAX = 10
    SUMMON_COOLDOWN = 11
    INSUFFICIENT_EXPANSION_LEVEL = 12
    SUMMON_OFFLINE = 13


class RollVote(enum.Enum):
    PASS = 0
    NEED = 1
    GREED = 2
    DISENCHANT = 3


class SellItemResult(enum.Enum):
    CANT_FIND_ITEM = 1
    CANT_SELL_ITEM = 2
    CANT_FIND_VENDOR = 3
    YOU_DONT_OWN_THAT_ITEM = 4
    UNK = 5
    ONLY_EMPTY_BAG = 6


class ServerMessageType(enum.Enum):
    SHUTDOWN_TIME = 1
    RESTART_TIME = 2
    CUSTOM = 3
    SHUTDOWN_CANCELLED = 4
    RESTART_CANCELLED = 5


class SheathState(enum.Enum):
    UNARMED = 0
    MELEE = 1
    RANGED = 2


class SheatheType(enum.Enum):
    NONE = 0
    MAIN_HAND = 1
    OFF_HAND = 2
    LARGE_WEAPON_LEFT = 3
    LARGE_WEAPON_RIGHT = 4
    HIP_WEAPON_LEFT = 5
    HIP_WEAPON_RIGHT = 6
    SHIELD = 7


class SizeClass(enum.Enum):
    NONE = -1
    SMALL = 0
    MEDIUM = 1
    LARGE = 2
    GIANT = 3
    COLOSSAL = 4


class Skill(enum.Enum):
    NONE = 0
    FROST = 6
    FIRE = 8
    ARMS = 26
    COMBAT = 38
    SUBTLETY = 39
    POISONS = 40
    SWORDS = 43
    AXES = 44
    BOWS = 45
    GUNS = 46
    BEAST_MASTERY = 50
    SURVIVAL = 51
    MACES = 54
    TWO_HANDED_SWORDS = 55
    HOLY = 56
    SHADOW = 78
    DEFENSE = 95
    LANGUAGE_COMMON = 98
    RACIAL_DWARVEN = 101
    LANGUAGE_ORCISH = 109
    LANGUAGE_DWARVEN = 111
    LANGUAGE_DARNASSIAN = 113
    LANGUAGE_TAURAHE = 115
    DUAL_WIELD = 118
    RACIAL_TAUREN = 124
    ORC_RACIAL = 125
    RACIAL_NIGHT_ELF = 126
    FIRST_AID = 129
    FERAL_COMBAT = 134
    STAVES = 136
    LANGUAGE_THALASSIAN = 137
    LANGUAGE_DRACONIC = 138
    LANGUAGE_DEMON_TONGUE = 139
    LANGUAGE_TITAN = 140
    LANGUAGE_OLD_TONGUE = 141
    SURVIVAL2 = 142
    RIDING_HORSE = 148
    RIDING_WOLF = 149
    RIDING_TIGER = 150
    RIDING_RAM = 152
    SWIMMING = 155
    TWO_HANDED_MACES = 160
    UNARMED = 162
    MARKSMANSHIP = 163
    BLACKSMITHING = 164
    LEATHERWORKING = 165
    ALCHEMY = 171
    TWO_HANDED_AXES = 172
    DAGGERS = 173
    THROWN = 176
    HERBALISM = 182
    GENERIC_DND = 183
    RETRIBUTION = 184
    COOKING = 185
    MINING = 186
    PET_IMP = 188
    PET_FELHUNTER = 189
    TAILORING = 197
    ENGINEERING = 202
    PET_SPIDER = 203
    PET_VOIDWALKER = 204
    PET_SUCCUBUS = 205
    PET_INFERNAL = 206
    PET_DOOMGUARD = 207
    PET_WOLF = 208
    PET_CAT = 209
    PET_BEAR = 210
    PET_BOAR = 211
    PET_CROCILISK = 212
    PET_CARRION_BIRD = 213
    PET_CRAB = 214
    PET_GORILLA = 215
    PET_RAPTOR = 217
    PET_TALLSTRIDER = 218
    RACIAL_UNDED = 220
    CROSSBOWS = 226
    WANDS = 228
    POLEARMS = 229
    PET_SCORPID = 236
    ARCANE = 237
    PET_TURTLE = 251
    ASSASSINATION = 253
    FURY = 256
    PROTECTION = 257
    BEAST_TRAINING = 261
    PROTECTION2 = 267
    PET_TALENTS = 270
    PLATE_MAIL = 293
    LANGUAGE_GNOMISH = 313
    LANGUAGE_TROLL = 315
    ENCHANTING = 333
    DEMONOLOGY = 354
    AFFLICTION = 355
    FISHING = 356
    ENHANCEMENT = 373
    RESTORATION = 374
    ELEMENTAL_COMBAT = 375
    SKINNING = 393
    MAIL = 413
    LEATHER = 414
    CLOTH = 415
    SHIELD = 433
    FIST_WEAPONS = 473
    RIDING_RAPTOR = 533
    RIDING_MECHANOSTRIDER = 553
    RIDING_UNDEAD_HORSE = 554
    RESTORATION2 = 573
    BALANCE = 574
    DESTRUCTION = 593
    HOLY2 = 594
    DISCIPLINE = 613
    LOCKPICKING = 633
    PET_BAT = 653
    PET_HYENA = 654
    PET_OWL = 655
    PET_WIND_SERPENT = 656
    LANGUAGE_GUTTERSPEAK = 673
    RIDING_KODO = 713
    RACIAL_TROLL = 733
    RACIAL_GNOME = 753
    RACIAL_HUMAN = 754
    JEWELCRAFTING = 755
    RACIAL_BLOODELF = 756
    PET_EVENT_RC = 758
    LANGUAGE_DRAENEI = 759
    RACIAL_DRAENEI = 760
    PET_FELGUARD = 761
    RIDING = 762
    PET_DRAGONHAWK = 763
    PET_NETHER_RAY = 764
    PET_SPOREBAT = 765
    PET_WARP_STALKER = 766
    PET_RAVAGER = 767
    PET_SERPENT = 768
    INTERNAL = 769


class SkillCategory(enum.Enum):
    ATTRIBUTE = 5
    WEAPON = 6
    CLASS = 7
    ARMOR = 8
    SECONDARY_PROFESSION = 9
    LANGUAGE = 10
    PRIMARY_PROFESSION = 11
    GENERIC = 12


class SpamType(enum.Enum):
    MAIL = 0
    CHAT = 1


class SpellCastResult(enum.Enum):
    AFFECTING_COMBAT = 0
    ALREADY_AT_FULL_HEALTH = 1
    ALREADY_AT_FULL_MANA = 2
    ALREADY_AT_FULL_POWER = 3
    ALREADY_BEING_TAMED = 4
    ALREADY_HAVE_CHARM = 5
    ALREADY_HAVE_SUMMON = 6
    ALREADY_OPEN = 7
    AURA_BOUNCED = 8
    AUTOTRACK_INTERRUPTED = 9
    BAD_IMPLICIT_TARGETS = 10
    BAD_TARGETS = 11
    CANT_BE_CHARMED = 12
    CANT_BE_DISENCHANTED = 13
    CANT_BE_DISENCHANTED_SKILL = 14
    CANT_BE_PROSPECTED = 15
    CANT_CAST_ON_TAPPED = 16
    CANT_DUEL_WHILE_INVISIBLE = 17
    CANT_DUEL_WHILE_STEALTHED = 18
    CANT_STEALTH = 19
    CASTER_AURASTATE = 20
    CASTER_DEAD = 21
    CHARMED = 22
    CHEST_IN_USE = 23
    CONFUSED = 24
    DONT_REPORT = 25
    EQUIPPED_ITEM = 26
    EQUIPPED_ITEM_CLASS = 27
    EQUIPPED_ITEM_CLASS_MAINHAND = 28
    EQUIPPED_ITEM_CLASS_OFFHAND = 29
    ERROR = 30
    FIZZLE = 31
    FLEEING = 32
    FOOD_LOWLEVEL = 33
    HIGHLEVEL = 34
    HUNGER_SATIATED = 35
    IMMUNE = 36
    INTERRUPTED = 37
    INTERRUPTED_COMBAT = 38
    ITEM_ALREADY_ENCHANTED = 39
    ITEM_GONE = 40
    ITEM_NOT_FOUND = 41
    ITEM_NOT_READY = 42
    LEVEL_REQUIREMENT = 43
    LINE_OF_SIGHT = 44
    LOWLEVEL = 45
    LOW_CASTLEVEL = 46
    MAINHAND_EMPTY = 47
    MOVING = 48
    NEED_AMMO = 49
    NEED_AMMO_POUCH = 50
    NEED_EXOTIC_AMMO = 51
    NOPATH = 52
    NOT_BEHIND = 53
    NOT_FISHABLE = 54
    NOT_FLYING = 55
    NOT_HERE = 56
    NOT_INFRONT = 57
    NOT_IN_CONTROL = 58
    NOT_KNOWN = 59
    NOT_MOUNTED = 60
    NOT_ON_TAXI = 61
    NOT_ON_TRANSPORT = 62
    NOT_READY = 63
    NOT_SHAPESHIFT = 64
    NOT_STANDING = 65
    NOT_TRADEABLE = 66
    NOT_TRADING = 67
    NOT_UNSHEATHED = 68
    NOT_WHILE_GHOST = 69
    NO_AMMO = 70
    NO_CHARGES_REMAIN = 71
    NO_CHAMPION = 72
    NO_COMBO_POINTS = 73
    NO_DUELING = 74
    NO_ENDURANCE = 75
    NO_FISH = 76
    NO_ITEMS_WHILE_SHAPESHIFTED = 77
    NO_MOUNTS_ALLOWED = 78
    NO_PET = 79
    NO_POWER = 80
    NOTHING_TO_DISPEL = 81
    NOTHING_TO_STEAL = 82
    ONLY_ABOVEWATER = 83
    ONLY_DAYTIME = 84
    ONLY_INDOORS = 85
    ONLY_MOUNTED = 86
    ONLY_NIGHTTIME = 87
    ONLY_OUTDOORS = 88
    ONLY_SHAPESHIFT = 89
    ONLY_STEALTHED = 90
    ONLY_UNDERWATER = 91
    OUT_OF_RANGE = 92
    PACIFIED = 93
    POSSESSED = 94
    REAGENTS = 95
    REQUIRES_AREA = 96
    REQUIRES_SPELL_FOCUS = 97
    ROOTED = 98
    SILENCED = 99
    SPELL_IN_PROGRESS = 100
    SPELL_LEARNED = 101
    SPELL_UNAVAILABLE = 102
    STUNNED = 103
    TARGETS_DEAD = 104
    TARGET_AFFECTING_COMBAT = 105
    TARGET_AURASTATE = 106
    TARGET_DUELING = 107
    TARGET_ENEMY = 108
    TARGET_ENRAGED = 109
    TARGET_FRIENDLY = 110
    TARGET_IN_COMBAT = 111
    TARGET_IS_PLAYER = 112
    TARGET_IS_PLAYER_CONTROLLED = 113
    TARGET_NOT_DEAD = 114
    TARGET_NOT_IN_PARTY = 115
    TARGET_NOT_LOOTED = 116
    TARGET_NOT_PLAYER = 117
    TARGET_NO_POCKETS = 118
    TARGET_NO_WEAPONS = 119
    TARGET_UNSKINNABLE = 120
    THIRST_SATIATED = 121
    TOO_CLOSE = 122
    TOO_MANY_OF_ITEM = 123
    TOTEM_CATEGORY = 124
    TOTEMS = 125
    TRAINING_POINTS = 126
    TRY_AGAIN = 127
    UNIT_NOT_BEHIND = 128
    UNIT_NOT_INFRONT = 129
    WRONG_PET_FOOD = 130
    NOT_WHILE_FATIGUED = 131
    TARGET_NOT_IN_INSTANCE = 132
    NOT_WHILE_TRADING = 133
    TARGET_NOT_IN_RAID = 134
    DISENCHANT_WHILE_LOOTING = 135
    PROSPECT_WHILE_LOOTING = 136
    PROSPECT_NEED_MORE = 137
    TARGET_FREEFORALL = 138
    NO_EDIBLE_CORPSES = 139
    ONLY_BATTLEGROUNDS = 140
    TARGET_NOT_GHOST = 141
    TOO_MANY_SKILLS = 142
    TRANSFORM_UNUSABLE = 143
    WRONG_WEATHER = 144
    DAMAGE_IMMUNE = 145
    PREVENTED_BY_MECHANIC = 146
    PLAY_TIME = 147
    REPUTATION = 148
    MIN_SKILL = 149
    NOT_IN_ARENA = 150
    NOT_ON_SHAPESHIFT = 151
    NOT_ON_STEALTHED = 152
    NOT_ON_DAMAGE_IMMUNE = 153
    NOT_ON_MOUNTED = 154
    TOO_SHALLOW = 155
    TARGET_NOT_IN_SANCTUARY = 156
    TARGET_IS_TRIVIAL = 157
    BM_OR_INVISGOD = 158
    EXPERT_RIDING_REQUIREMENT = 159
    ARTISAN_RIDING_REQUIREMENT = 160
    NOT_IDLE = 161
    NOT_INACTIVE = 162
    PARTIAL_PLAYTIME = 163
    NO_PLAYTIME = 164
    NOT_IN_BATTLEGROUND = 165
    ONLY_IN_ARENA = 166
    TARGET_LOCKED_TO_RAID_INSTANCE = 167
    UNKNOWN = 168


class SpellEffect(enum.Enum):
    NONE = 0
    INSTAKILL = 1
    SCHOOL_DAMAGE = 2
    DUMMY = 3
    PORTAL_TELEPORT = 4
    TELEPORT_UNITS = 5
    APPLY_AURA = 6
    ENVIRONMENTAL_DAMAGE = 7
    POWER_DRAIN = 8
    HEALTH_LEECH = 9
    HEAL = 10
    BIND = 11
    PORTAL = 12
    RITUAL_BASE = 13
    RITUAL_SPECIALIZE = 14
    RITUAL_ACTIVATE_PORTAL = 15
    QUEST_COMPLETE = 16
    WEAPON_DAMAGE_NOSCHOOL = 17
    RESURRECT = 18
    ADD_EXTRA_ATTACKS = 19
    DODGE = 20
    EVADE = 21
    PARRY = 22
    BLOCK = 23
    CREATE_ITEM = 24
    WEAPON = 25
    DEFENSE = 26
    PERSISTENT_AREA_AURA = 27
    SUMMON = 28
    LEAP = 29
    ENERGIZE = 30
    WEAPON_PERCENT_DAMAGE = 31
    TRIGGER_MISSILE = 32
    OPEN_LOCK = 33
    SUMMON_CHANGE_ITEM = 34
    APPLY_AREA_AURA_PARTY = 35
    LEARN_SPELL = 36
    SPELL_DEFENSE = 37
    DISPEL = 38
    LANGUAGE = 39
    DUAL_WIELD = 40
    UNKNOWN41 = 41
    UNKNOWN42 = 42
    TELEPORT_UNITS_FACE_CASTER = 43
    SKILL_STEP = 44
    UNDEFINED_45 = 45
    SPAWN = 46
    TRADE_SKILL = 47
    STEALTH = 48
    DETECT = 49
    TRANS_DOOR = 50
    FORCE_CRITICAL_HIT = 51
    GUARANTEE_HIT = 52
    ENCHANT_ITEM = 53
    ENCHANT_ITEM_TEMPORARY = 54
    TAMECREATURE = 55
    SUMMON_PET = 56
    LEARN_PET_SPELL = 57
    WEAPON_DAMAGE = 58
    OPEN_LOCK_ITEM = 59
    PROFICIENCY = 60
    SEND_EVENT = 61
    POWER_BURN = 62
    THREAT = 63
    TRIGGER_SPELL = 64
    HEALTH_FUNNEL = 65
    POWER_FUNNEL = 66
    HEAL_MAX_HEALTH = 67
    INTERRUPT_CAST = 68
    DISTRACT = 69
    PULL = 70
    PICKPOCKET = 71
    ADD_FARSIGHT = 72
    UNKNOWN73 = 73
    UNKNOWN74 = 74
    HEAL_MECHANICAL = 75
    SUMMON_OBJECT_WILD = 76
    SCRIPT_EFFECT = 77
    ATTACK = 78
    SANCTUARY = 79
    ADD_COMBO_POINTS = 80
    CREATE_HOUSE = 81
    BIND_SIGHT = 82
    DUEL = 83
    STUCK = 84
    SUMMON_PLAYER = 85
    ACTIVATE_OBJECT = 86
    UNKNOWN87 = 87
    UNKNOWN88 = 88
    UNKNOWN89 = 89
    UNKNOWN90 = 90
    THREAT_ALL = 91
    ENCHANT_HELD_ITEM = 92
    UNKNOWN93 = 93
    SELF_RESURRECT = 94
    SKINNING = 95
    CHARGE = 96
    UNKNOWN97 = 97
    KNOCK_BACK = 98
    DISENCHANT = 99
    INEBRIATE = 100
    FEED_PET = 101
    DISMISS_PET = 102
    REPUTATION = 103
    SUMMON_OBJECT_SLOT1 = 104
    SUMMON_OBJECT_SLOT2 = 105
    SUMMON_OBJECT_SLOT3 = 106
    SUMMON_OBJECT_SLOT4 = 107
    DISPEL_MECHANIC = 108
    SUMMON_DEAD_PET = 109
    DESTROY_ALL_TOTEMS = 110
    DURABILITY_DAMAGE = 111
    UNKNOWN112 = 112
    RESURRECT_NEW = 113
    ATTACK_ME = 114
    DURABILITY_DAMAGE_PCT = 115
    SKIN_PLAYER_CORPSE = 116
    SPIRIT_HEAL = 117
    SKILL = 118
    APPLY_AREA_AURA_PET = 119
    TELEPORT_GRAVEYARD = 120
    NORMALIZED_WEAPON_DMG = 121
    UNKNOWN122 = 122
    SEND_TAXI = 123
    PLAYER_PULL = 124
    MODIFY_THREAT_PERCENT = 125
    STEAL_BENEFICIAL_BUFF = 126
    PROSPECTING = 127
    APPLY_AREA_AURA_FRIEND = 128
    APPLY_AREA_AURA_ENEMY = 129
    REDIRECT_THREAT = 130
    PLAY_SOUND = 131
    PLAY_MUSIC = 132
    UNLEARN_SPECIALIZATION = 133
    KILL_CREDIT_GROUP = 134
    CALL_PET = 135
    HEAL_PCT = 136
    ENERGIZE_PCT = 137
    LEAP_BACK = 138
    CLEAR_QUEST = 139
    FORCE_CAST = 140
    UNKNOWN141 = 141
    TRIGGER_SPELL_WITH_VALUE = 142
    APPLY_AREA_AURA_OWNER = 143
    KNOCKBACK_FROM_POSITION = 144
    UNKNOWN145 = 145
    UNKNOWN146 = 146
    QUEST_FAIL = 147
    UNKNOWN148 = 148
    CHARGE2 = 149
    UNKNOWN150 = 150
    TRIGGER_SPELL_2 = 151
    UNKNOWN152 = 152
    UNKNOWN153 = 153


class SpellMissInfo(enum.Enum):
    NONE = 0
    MISS = 1
    RESIST = 2
    DODGE = 3
    PARRY = 4
    BLOCK = 5
    EVADE = 6
    IMMUNE = 7
    IMMUNE2 = 8
    DEFLECT = 9
    ABSORB = 10
    REFLECT = 11


class SpellSchool(enum.Enum):
    NORMAL = 0
    HOLY = 1
    FIRE = 2
    NATURE = 3
    FROST = 4
    SHADOW = 5
    ARCANE = 6


class SpellStealAction(enum.Enum):
    STEAL = 0
    CLEANSE = 1


class SpellTriggerType(enum.Enum):
    ON_USE = 0
    ON_EQUIP = 1
    CHANCE_ON_HIT = 2
    SERVER_SIDE_SCRIPT = 3
    SOULSTONE = 4
    NO_EQUIP_COOLDOWN = 5
    LEARN_SPELL_ID = 6


class StableResult(enum.Enum):
    ERR_MONEY = 1
    ERR_STABLE = 6
    SUCCESS_STABLE = 8
    SUCCESS_UNSTABLE = 9
    SUCCESS_BUY_SLOT = 10


class StatusId(enum.Enum):
    NONE = 0
    WAIT_QUEUE = 1
    WAIT_JOIN = 2
    IN_PROGRESS = 3
    WAIT_LEAVE = 4


class Talent(enum.Enum):
    BURNING_SOUL = 23
    MOLTEN_SHIELDS = 24
    IMPROVED_SCORCH = 25
    IMPROVED_FIREBALL = 26
    IMPROVED_FIRE_BLAST = 27
    FLAME_THROWING = 28
    PYROBLAST = 29
    IMPACT = 30
    IMPROVED_FLAMESTRIKE = 31
    BLAST_WAVE = 32
    CRITICAL_MASS = 33
    IGNITE = 34
    FIRE_POWER = 35
    COMBUSTION = 36
    IMPROVED_FROSTBOLT = 37
    FROSTBITE = 38
    PIERCING_ICE = 61
    IMPROVED_FROST_NOVA = 62
    IMPROVED_BLIZZARD = 63
    IMPROVED_CONE_OF_COLD = 64
    PERMAFROST = 65
    FROST_CHANNELING = 66
    SHATTER = 67
    WINTERS_CHILL = 68
    ICY_VEINS = 69
    FROST_WARDING = 70
    ICE_BARRIER = 71
    COLD_SNAP = 72
    ICE_SHARDS = 73
    ARCANE_SUBTLETY = 74
    ARCANE_CONCENTRATION = 75
    ARCANE_FOCUS = 76
    ARCANE_MIND = 77
    MAGE_WAND_SPECIALIZATION = 78
    IMPROVED_ARCANE_MISSILES = 80
    ARCANE_IMPACT = 81
    MAGIC_ATTUNEMENT = 82
    IMPROVED_MANA_SHIELD = 83
    ARCANE_FORTITUDE = 85
    PRESENCE_OF_MIND = 86
    ARCANE_POWER = 87
    IMPROVED_COUNTERSPELL = 88
    DEEP_WOUNDS = 121
    WARRIOR_SWORD_SPECIALIZATION = 123
    IMPROVED_HEROIC_STRIKE = 124
    WARRIOR_MACE_SPECIALIZATION = 125
    IMPROVED_CHARGE = 126
    IMPROVED_REND = 127
    IMPROVED_THUNDER_CLAP = 128
    IMPROVED_HAMSTRING = 129
    WARRIOR_DEFLECTION = 130
    IMPROVED_OVERPOWER = 131
    POLEAXE_SPECIALIZATION = 132
    DEATH_WISH = 133
    IMPROVED_INTERCEPT = 134
    MORTAL_STRIKE = 135
    WARRIOR_TWO_HANDED_WEAPON_SPECIALIZATION = 136
    ANGER_MANAGEMENT = 137
    WARRIOR_ANTICIPATION = 138
    WARRIOR_TOUGHNESS = 140
    TACTICAL_MASTERY = 141
    IMPROVED_BLOODRAGE = 142
    IMPROVED_TAUNT = 143
    DEFIANCE = 144
    IMPROVED_SHIELD_BLOCK = 145
    IMPROVED_SUNDER_ARMOR = 146
    IMPROVED_REVENGE = 147
    SHIELD_SLAM = 148
    IMPROVED_SHIELD_BASH = 149
    IMPROVED_SHIELD_WALL = 150
    IMPROVED_DISARM = 151
    CONCUSSION_BLOW = 152
    LAST_STAND = 153
    COMMANDING_PRESENCE = 154
    ENRAGE = 155
    WARRIOR_FLURRY = 156
    CRUELTY = 157
    BOOMING_VOICE = 158
    UNBRIDLED_WRATH = 159
    PIERCING_HOWL = 160
    IMPROVED_DEMORALIZING_SHOUT = 161
    SWEEPING_STRIKES = 165
    IMPROVED_CLEAVE = 166
    BLOODTHIRST = 167
    IMPROVED_SLAM = 168
    ROGUE_PRECISION = 181
    DAGGER_SPECIALIZATION = 182
    FIST_WEAPON_SPECIALIZATION = 183
    ROGUE_MACE_SPECIALIZATION = 184
    ROGUE_LIGHTNING_REFLEXES = 186
    ROGUE_DEFLECTION = 187
    IMPROVED_SINISTER_STRIKE = 201
    IMPROVED_GOUGE = 203
    ENDURANCE = 204
    ADRENALINE_RUSH = 205
    IMPROVED_KICK = 206
    ROGUE_DUAL_WIELD_SPECIALIZATION = 221
    IMPROVED_SPRINT = 222
    BLADE_FLURRY = 223
    MASTER_OF_DECEPTION = 241
    ROGUE_SWORD_SPECIALIZATION = 242
    CAMOUFLAGE = 244
    INITIATIVE = 245
    SETUP = 246
    ELUSIVENESS = 247
    OPPORTUNITY = 261
    DIRTY_TRICKS = 262
    IMPROVED_AMBUSH = 263
    DIRTY_DEEDS = 265
    IMPROVED_POISONS = 268
    LETHALITY = 269
    MALICE = 270
    REMORSELESS_ATTACKS = 272
    RUTHLESSNESS = 273
    MURDER = 274
    IMPROVED_EVISCERATE = 276
    PUNCTURING_WOUNDS = 277
    IMPROVED_EXPOSE_ARMOR = 278
    IMPROVED_KIDNEY_SHOT = 279
    COLD_BLOOD = 280
    RELENTLESS_STRIKES = 281
    SEAL_FATE = 283
    PREPARATION = 284
    RIPOSTE = 301
    GHOSTLY_STRIKE = 303
    MARTYRDOM = 321
    POWER_INFUSION = 322
    MENTAL_AGILITY = 341
    UNBREAKABLE_WILL = 342
    IMPROVED_POWER_WORD_SHIELD = 343
    IMPROVED_POWER_WORD_FORTITUDE = 344
    PRIEST_WAND_SPECIALIZATION = 345
    IMPROVED_INNER_FIRE = 346
    MEDITATION = 347
    INNER_FOCUS = 348
    IMPROVED_MANA_BURN = 350
    DIVINE_SPIRIT = 351
    SILENT_RESOLVE = 352
    INSPIRATION = 361
    PREMEDITATION = 381
    VIGOR = 382
    HOLY_SPECIALIZATION = 401
    SPIRITUAL_GUIDANCE = 402
    SEARING_LIGHT = 403
    SPIRITUAL_HEALING = 404
    IMPROVED_RENEW = 406
    IMPROVED_HEALING = 408
    PRIEST_HEALING_FOCUS = 410
    PRIEST_SPELL_WARDING = 411
    HEALING_PRAYERS = 413
    ARCANE_INSTABILITY = 421
    HOLY_NOVA = 442
    SHADOW_WEAVING = 461
    DARKNESS = 462
    SHADOW_FOCUS = 463
    BLACKOUT = 464
    SPIRIT_TAP = 465
    SHADOW_AFFINITY = 466
    IMPROVED_MIND_BLAST = 481
    IMPROVED_SHADOW_WORD_PAIN = 482
    IMPROVED_FADE = 483
    VAMPIRIC_EMBRACE = 484
    MIND_FLAY = 501
    SHADOWFORM = 521
    SILENCE = 541
    IMPROVED_PSYCHIC_SCREAM = 542
    CALL_OF_FLAME = 561
    CALL_OF_THUNDER = 562
    CONCUSSION = 563
    CONVECTION = 564
    ELEMENTAL_FURY = 565
    IMPROVED_FIRE_TOTEMS = 567
    EARTHS_GRASP = 572
    ELEMENTAL_MASTERY = 573
    ELEMENTAL_FOCUS = 574
    REVERBERATION = 575
    ANCESTRAL_HEALING = 581
    TOTEMIC_MASTERY = 582
    NATURES_GUIDANCE = 583
    IMPROVED_HEALING_WAVE = 586
    SHAMAN_HEALING_FOCUS = 587
    RESTORATIVE_TOTEMS = 588
    IMPROVED_REINCARNATION = 589
    MANA_TIDE_TOTEM = 590
    SHAMAN_NATURES_SWIFTNESS = 591
    PURIFICATION = 592
    TIDAL_FOCUS = 593
    TIDAL_MASTERY = 594
    TOTEMIC_FOCUS = 595
    SHAMAN_ANTICIPATION = 601
    SHAMAN_FLURRY = 602
    IMPROVED_GHOST_WOLF = 605
    IMPROVED_LIGHTNING_SHIELD = 607
    GUARDIAN_TOTEMS = 609
    ENHANCING_TOTEMS = 610
    ELEMENTAL_WEAPONS = 611
    SHAMAN_SHIELD_SPECIALIZATION = 612
    THUNDERING_STRIKES = 613
    ANCESTRAL_KNOWLEDGE = 614
    SHAMAN_TOUGHNESS = 615
    SPIRIT_WEAPONS = 616
    SHAMANISTIC_FOCUS = 617
    IRON_WILL = 641
    BLOOD_CRAZE = 661
    IMPALE = 662
    HEMORRHAGE = 681
    VILE_POISONS = 682
    WARRIOR_ONE_HANDED_WEAPON_SPECIALIZATION = 702
    LIGHTNING_MASTERY = 721
    ARCTIC_REACH = 741
    NATURES_GRASP = 761
    STARLIGHT_WRATH = 762
    IMPROVED_MOONFIRE = 763
    NATURES_REACH = 764
    BRAMBLES = 782
    MOONGLOW = 783
    CELESTIAL_FOCUS = 784
    CONTROL_OF_NATURE = 787
    INSECT_SWARM = 788
    NATURES_GRACE = 789
    MOONFURY = 790
    DRUID_VENGEANCE = 792
    MOONKIN_FORM = 793
    DRUID_THICK_HIDE = 794
    FERAL_AGGRESSION = 795
    DRUID_FEROCITY = 796
    BRUTAL_IMPACT = 797
    SHARPENED_CLAWS = 798
    FERAL_INSTINCT = 799
    PRIMAL_FURY = 801
    SHREDDING_ATTACKS = 802
    PREDATORY_STRIKES = 803
    FERAL_CHARGE = 804
    SAVAGE_FURY = 805
    FERAL_SWIFTNESS = 807
    HEART_OF_THE_WILD = 808
    LEADER_OF_THE_PACK = 809
    IMPROVED_MARK_OF_THE_WILD = 821
    FUROR = 822
    NATURES_FOCUS = 823
    NATURALIST = 824
    IMPROVED_REGROWTH = 825
    NATURAL_SHAPESHIFTER = 826
    OMEN_OF_CLARITY = 827
    GIFT_OF_NATURE = 828
    DRUID_INTENSITY = 829
    IMPROVED_REJUVENATION = 830
    DRUID_NATURES_SWIFTNESS = 831
    SUBTLETY = 841
    IMPROVED_TRANQUILITY = 842
    TRANQUIL_SPIRIT = 843
    SWIFTMEND = 844
    SHADOW_REACH = 881
    STORMSTRIKE = 901
    IMPROVED_NATURES_GRASP = 921
    CATACLYSM = 941
    BANE = 943
    IMPROVED_SHADOW_BOLT = 944
    IMPROVED_IMMOLATE = 961
    SHADOWBURN = 963
    DESTRUCTIVE_REACH = 964
    IMPROVED_SEARING_PAIN = 965
    EMBERSTORM = 966
    RUIN = 967
    CONFLAGRATE = 968
    DEVASTATION = 981
    AFTERMATH = 982
    IMPROVED_FIREBOLT = 983
    IMPROVED_LASH_OF_PAIN = 984
    WARLOCK_INTENSITY = 985
    PYROCLASM = 986
    FEL_CONCENTRATION = 1001
    NIGHTFALL = 1002
    IMPROVED_CORRUPTION = 1003
    SOUL_SIPHON = 1004
    SUPPRESSION = 1005
    IMPROVED_CURSE_OF_WEAKNESS = 1006
    IMPROVED_LIFE_TAP = 1007
    GRIM_REACH = 1021
    DARK_PACT = 1022
    SIPHON_LIFE = 1041
    SHADOW_MASTERY = 1042
    AMPLIFY_CURSE = 1061
    CURSE_OF_EXHAUSTION = 1081
    IMPROVED_DRAIN_SOUL = 1101
    AGGRESSION = 1122
    SERRATED_BLADES = 1123
    INCINERATION = 1141
    ARCANE_MEDITATION = 1142
    FAERIE_FIRE_FERAL = 1162
    DIVINE_FURY = 1181
    MENTAL_STRENGTH = 1201
    FORCE_OF_WILL = 1202
    IMPROVED_HEALTHSTONE = 1221
    IMPROVED_IMP = 1222
    DEMONIC_EMBRACE = 1223
    IMPROVED_HEALTH_FUNNEL = 1224
    IMPROVED_VOIDWALKER = 1225
    FEL_DOMINATION = 1226
    MASTER_SUMMONER = 1227
    FEL_STAMINA = 1241
    FEL_INTELLECT = 1242
    IMPROVED_SUCCUBUS = 1243
    MASTER_DEMONOLOGIST = 1244
    MASTER_CONJUROR = 1261
    UNHOLY_POWER = 1262
    DEMONIC_KNOWLEDGE = 1263
    DEMONIC_SACRIFICE = 1281
    SOUL_LINK = 1282
    IMPROVED_ENSLAVE_DEMON = 1283
    IMPROVED_CURSE_OF_AGONY = 1284
    HUMANOID_SLAYING = 1301
    HUNTER_LIGHTNING_REFLEXES = 1303
    ENTRAPMENT = 1304
    IMPROVED_WING_CLIP = 1305
    CLEVER_TRAPS = 1306
    DETERRENCE = 1308
    IMPROVED_FEIGN_DEATH = 1309
    SUREFOOTED = 1310
    HUNTER_DEFLECTION = 1311
    COUNTERATTACK = 1312
    KILLER_INSTINCT = 1321
    TRAP_MASTERY = 1322
    WYVERN_STING = 1325
    IMPROVED_CONCUSSIVE_SHOT = 1341
    EFFICIENCY = 1342
    IMPROVED_HUNTERS_MARK = 1343
    LETHAL_SHOTS = 1344
    AIMED_SHOT = 1345
    IMPROVED_ARCANE_SHOT = 1346
    BARRAGE = 1347
    IMPROVED_STINGS = 1348
    MORTAL_SHOTS = 1349
    CONCUSSIVE_BARRAGE = 1351
    SCATTER_SHOT = 1353
    TRUESHOT_AURA = 1361
    RANGED_WEAPON_SPECIALIZATION = 1362
    IMPROVED_ASPECT_OF_THE_MONKEY = 1381
    IMPROVED_ASPECT_OF_THE_HAWK = 1382
    PATHFINDING = 1384
    IMPROVED_MEND_PET = 1385
    BESTIAL_WRATH = 1386
    INTIMIDATION = 1387
    SPIRIT_BOND = 1388
    ENDURANCE_TRAINING = 1389
    BESTIAL_DISCIPLINE = 1390
    BESTIAL_SWIFTNESS = 1391
    HUNTER_FEROCITY = 1393
    HUNTER_THICK_HIDE = 1395
    UNLEASHED_FURY = 1396
    FRENZY = 1397
    IMPROVED_BLESSING_OF_MIGHT = 1401
    PALADIN_VENGEANCE = 1402
    PALADIN_DEFLECTION = 1403
    IMPROVED_RETRIBUTION_AURA = 1405
    BENEDICTION = 1407
    SANCTITY_AURA = 1409
    PALADIN_TWO_HANDED_WEAPON_SPECIALIZATION = 1410
    CONVICTION = 1411
    REDOUBT = 1421
    IMPROVED_DEVOTION_AURA = 1422
    PALADIN_TOUGHNESS = 1423
    PALADIN_SHIELD_SPECIALIZATION = 1424
    GUARDIANS_FAVOR = 1425
    RECKONING = 1426
    PALADIN_ONE_HANDED_WEAPON_SPECIALIZATION = 1429
    HOLY_SHIELD = 1430
    BLESSING_OF_SANCTUARY = 1431
    SPIRITUAL_FOCUS = 1432
    DIVINE_FAVOR = 1433
    AURA_MASTERY = 1435
    REPENTANCE = 1441
    BLESSING_OF_KINGS = 1442
    IMPROVED_LAY_ON_HANDS = 1443
    HEALING_LIGHT = 1444
    IMPROVED_BLESSING_OF_WISDOM = 1446
    DIVINE_INTELLECT = 1449
    DIVINE_STRENGTH = 1450
    ILLUMINATION = 1461
    IMPROVED_SEAL_OF_RIGHTEOUSNESS = 1463
    IMPROVED_SEAL_OF_THE_CRUSADER = 1464
    SANCTIFIED_LIGHT = 1465
    SEAL_OF_COMMAND = 1481
    IMPROVED_RIGHTEOUS_FURY = 1501
    HOLY_SHOCK = 1502
    IMPROVED_HAMMER_OF_JUSTICE = 1521
    IMPROVED_BERSERKER_RAGE = 1541
    IMPROVED_EXECUTE = 1542
    WARRIOR_WEAPON_MASTERY = 1543
    SPIRIT_OF_REDEMPTION = 1561
    WARRIOR_DUAL_WIELD_SPECIALIZATION = 1581
    WARRIOR_SHIELD_SPECIALIZATION = 1601
    SAVAGE_STRIKES = 1621
    SURVIVALIST = 1622
    MONSTER_SLAYING = 1623
    FOCUSED_FIRE = 1624
    IMPROVED_REVIVE_PET = 1625
    IMPROVED_CONCENTRATION_AURA = 1626
    HOLY_POWER = 1627
    UNYIELDING_FAITH = 1628
    PALADIN_ANTICIPATION = 1629
    PALADIN_PRECISION = 1630
    IMPROVED_JUDGEMENT = 1631
    EYE_FOR_AN_EYE = 1632
    VINDICATION = 1633
    PURSUIT_OF_JUSTICE = 1634
    HOLY_REACH = 1635
    BLESSED_RECOVERY = 1636
    LIGHTWELL = 1637
    IMPROVED_VAMPIRIC_EMBRACE = 1638
    MASTER_OF_ELEMENTS = 1639
    ELEMENTAL_WARDING = 1640
    STORM_REACH = 1641
    EYE_OF_THE_STORM = 1642
    SHAMAN_WEAPON_MASTERY = 1643
    ELEMENTAL_DEVASTATION = 1645
    HEALING_GRACE = 1646
    IMPROVED_WEAPON_TOTEMS = 1647
    HEALING_WAY = 1648
    MAGE_ELEMENTAL_PRECISION = 1649
    MAGIC_ABSORPTION = 1650
    IMPROVED_DEFENSIVE_STANCE = 1652
    WARRIOR_VITALITY = 1653
    SHIELD_MASTERY = 1654
    IMPROVED_WHIRLWIND = 1655
    WARRIOR_PRECISION = 1657
    IMPROVED_BERSERKER_STANCE = 1658
    RAMPAGE = 1659
    FOCUSED_RAGE = 1660
    ENDLESS_RAGE = 1661
    IMPROVED_DISCIPLINES = 1662
    SECOND_WIND = 1663
    BLOOD_FRENZY = 1664
    DEVASTATE = 1666
    MALEDICTION = 1667
    IMPROVED_HOWL_OF_TERROR = 1668
    CONTAGION = 1669
    UNSTABLE_AFFLICTION = 1670
    DEMONIC_AEGIS = 1671
    SUMMON_FELGUARD = 1672
    DEMONIC_TACTICS = 1673
    SHADOWFURY = 1676
    SHADOW_AND_FLAME = 1677
    SOUL_LEECH = 1678
    NETHER_PROTECTION = 1679
    DEMONIC_RESILIENCE = 1680
    MANA_FEED = 1681
    UNRELENTING_STORM = 1682
    ELEMENTAL_SHIELDS = 1683
    SHAMAN_ELEMENTAL_PRECISION = 1685
    LIGHTNING_OVERLOAD = 1686
    TOTEM_OF_WRATH = 1687
    UNLEASHED_RAGE = 1689
    DUAL_WIELD = 1690
    MENTAL_QUICKNESS = 1691
    SHAMAN_DUAL_WIELD_SPECIALIZATION = 1692
    SHAMANISTIC_RAGE = 1693
    SHAMAN_FOCUSED_MIND = 1695
    NATURES_BLESSING = 1696
    IMPROVED_CHAIN_HEAL = 1697
    EARTH_SHIELD = 1698
    NATURES_GUARDIAN = 1699
    SLEIGHT_OF_HAND = 1700
    HEIGHTENED_SENSES = 1701
    DEADLINESS = 1702
    WEAPON_EXPERTISE = 1703
    ROGUE_VITALITY = 1705
    BLADE_TWISTING = 1706
    NERVES_OF_STEEL = 1707
    SURPRISE_ATTACKS = 1709
    ENVELOPING_SHADOWS = 1711
    SINISTER_CALLING = 1712
    MASTER_OF_SUBTLETY = 1713
    SHADOWSTEP = 1714
    MASTER_POISONER = 1715
    FIND_WEAKNESS = 1718
    MUTILATE = 1719
    FLEET_FOOTED = 1721
    CHEAT_DEATH = 1722
    DEADENED_NERVES = 1723
    IMPROVED_BLINK = 1724
    ARCANE_POTENCY = 1725
    PRISMATIC_CLOAK = 1726
    EMPOWERED_ARCANE_MISSILES = 1727
    MIND_MASTERY = 1728
    SLOW = 1729
    PLAYING_WITH_FIRE = 1730
    BLAZING_SPEED = 1731
    MOLTEN_FURY = 1732
    PYROMANIAC = 1733
    EMPOWERED_FIREBALL = 1734
    DRAGONS_BREATH = 1735
    FROZEN_CORE = 1736
    ICE_FLOES = 1737
    ARCTIC_WINDS = 1738
    EMPOWERED_FROSTBOLT = 1740
    SUMMON_WATER_ELEMENTAL = 1741
    PURE_OF_HEART = 1742
    PURIFYING_POWER = 1743
    BLESSED_LIFE = 1744
    LIGHTS_GRACE = 1745
    HOLY_GUIDANCE = 1746
    DIVINE_ILLUMINATION = 1747
    STOICISM = 1748
    PALADIN_SPELL_WARDING = 1749
    SACRED_DUTY = 1750
    ARDENT_DEFENDER = 1751
    COMBAT_EXPERTISE = 1753
    AVENGERS_SHIELD = 1754
    CRUSADE = 1755
    IMPROVED_SANCTITY_AURA = 1756
    DIVINE_PURPOSE = 1757
    SANCTIFIED_JUDGEMENT = 1758
    FANATICISM = 1759
    SANCTIFIED_SEALS = 1761
    QUICK_RECOVERY = 1762
    SHADOW_EMBRACE = 1763
    EMPOWERED_CORRUPTION = 1764
    BLESSED_RESILIENCE = 1765
    SURGE_OF_LIGHT = 1766
    EMPOWERED_HEALING = 1767
    HOLY_CONCENTRATION = 1768
    ABSOLUTION = 1769
    IMPROVED_DIVINE_SPIRIT = 1770
    FOCUSED_POWER = 1771
    ENLIGHTENMENT = 1772
    REFLECTIVE_SHIELD = 1773
    PAIN_SUPPRESSION = 1774
    PRIEST_FOCUSED_MIND = 1777
    SHADOW_POWER = 1778
    VAMPIRIC_TOUCH = 1779
    SHADOW_RESILIENCE = 1781
    LUNAR_GUIDANCE = 1782
    BALANCE_OF_POWER = 1783
    DREAMSTATE = 1784
    IMPROVED_FAERIE_FIRE = 1785
    WRATH_OF_CENARIUS = 1786
    FORCE_OF_NATURE = 1787
    EMPOWERED_TOUCH = 1788
    EMPOWERED_REJUVENATION = 1789
    NATURAL_PERFECTION = 1790
    TREE_OF_LIFE = 1791
    NURTURING_INSTINCT = 1792
    PRIMAL_TENACITY = 1793
    SURVIVAL_OF_THE_FITTEST = 1794
    PREDATORY_INSTINCTS = 1795
    MANGLE = 1796
    LIVING_SPIRIT = 1797
    IMPROVED_LEADER_OF_THE_PACK = 1798
    ANIMAL_HANDLER = 1799
    FEROCIOUS_INSPIRATION = 1800
    CATLIKE_REFLEXES = 1801
    SERPENTS_SWIFTNESS = 1802
    THE_BEAST_WITHIN = 1803
    COMBAT_EXPERIENCE = 1804
    CAREFUL_AIM = 1806
    MASTER_MARKSMAN = 1807
    SILENCING_SHOT = 1808
    RESOURCEFULNESS = 1809
    SURVIVAL_INSTINCTS = 1810
    THRILL_OF_THE_HUNT = 1811
    EXPOSE_WEAKNESS = 1812
    MASTER_TACTICIAN = 1813
    READINESS = 1814
    CIRCLE_OF_HEALING = 1815
    MISERY = 1816
    BACKLASH = 1817
    GO_FOR_THE_THROAT = 1818
    RAPID_KILLING = 1819
    HAWK_EYE = 1820
    IMPROVED_BARRAGE = 1821
    FOCUSED_STARLIGHT = 1822
    CRUSADER_STRIKE = 1823
    IMPROVED_MORTAL_STRIKE = 1824
    COMBAT_POTENCY = 1825
    SPELL_POWER = 1826
    IMPROVED_SLICE_AND_DICE = 1827
    IMPROVED_HOLY_SHIELD = 1829
    FOCUSED_WILL = 1858


class TextEmote(enum.Enum):
    AGREE = 1
    AMAZE = 2
    ANGRY = 3
    APOLOGIZE = 4
    APPLAUD = 5
    BASHFUL = 6
    BECKON = 7
    BEG = 8
    BITE = 9
    BLEED = 10
    BLINK = 11
    BLUSH = 12
    BONK = 13
    BORED = 14
    BOUNCE = 15
    BRB = 16
    BOW = 17
    BURP = 18
    BYE = 19
    CACKLE = 20
    CHEER = 21
    CHICKEN = 22
    CHUCKLE = 23
    CLAP = 24
    CONFUSED = 25
    CONGRATULATE = 26
    COUGH = 27
    COWER = 28
    CRACK = 29
    CRINGE = 30
    CRY = 31
    CURIOUS = 32
    CURTSEY = 33
    DANCE = 34
    DRINK = 35
    DROOL = 36
    EAT = 37
    EYE = 38
    FART = 39
    FIDGET = 40
    FLEX = 41
    FROWN = 42
    GASP = 43
    GAZE = 44
    GIGGLE = 45
    GLARE = 46
    GLOAT = 47
    GREET = 48
    GRIN = 49
    GROAN = 50
    GROVEL = 51
    GUFFAW = 52
    HAIL = 53
    HAPPY = 54
    HELLO = 55
    HUG = 56
    HUNGRY = 57
    KISS = 58
    KNEEL = 59
    LAUGH = 60
    LAYDOWN = 61
    MASSAGE = 62
    MOAN = 63
    MOON = 64
    MOURN = 65
    NO = 66
    NOD = 67
    NOSE_PICK = 68
    PANIC = 69
    PEER = 70
    PLEAD = 71
    POINT = 72
    POKE = 73
    PRAY = 74
    ROAR = 75
    ROFL = 76
    RUDE = 77
    SALUTE = 78
    SCRATCH = 79
    SEXY = 80
    SHAKE = 81
    SHOUT = 82
    SHRUG = 83
    SHY = 84
    SIGH = 85
    SIT = 86
    SLEEP = 87
    SNARL = 88
    SPIT = 89
    STARE = 90
    SURPRISED = 91
    SURRENDER = 92
    TALK = 93
    TALK_EX = 94
    TALK_Q = 95
    TAP = 96
    THANK = 97
    THREATEN = 98
    TIRED = 99
    VICTORY = 100
    WAVE = 101
    WELCOME = 102
    WHINE = 103
    WHISTLE = 104
    WORK = 105
    YAWN = 106
    BOGGLE = 107
    CALM = 108
    COLD = 109
    COMFORT = 110
    CUDDLE = 111
    DUCK = 112
    INSULT = 113
    INTRODUCE = 114
    JK = 115
    LICK = 116
    LISTEN = 117
    LOST = 118
    MOCK = 119
    PONDER = 120
    POUNCE = 121
    PRAISE = 122
    PURR = 123
    PUZZLE = 124
    RAISE = 125
    READY = 126
    SHIMMY = 127
    SHIVER = 128
    SHOO = 129
    SLAP = 130
    SMIRK = 131
    SNIFF = 132
    SNUB = 133
    SOOTHE = 134
    STINK = 135
    TAUNT = 136
    TEASE = 137
    THIRSTY = 138
    VETO = 139
    SNICKER = 140
    STAND = 141
    TICKLE = 142
    VIOLIN = 143
    SMILE = 163
    RASP = 183
    PITY = 203
    GROWL = 204
    BARK = 205
    SCARED = 223
    FLOP = 224
    LOVE = 225
    MOO = 226
    COMMEND = 243
    TRAIN = 264
    HELPME = 303
    INCOMING = 304
    CHARGE = 305
    FLEE = 306
    ATTACK_MY_TARGET = 307
    OOM = 323
    FOLLOW = 324
    WAIT = 325
    HEAL_ME = 326
    OPEN_FIRE = 327
    FLIRT = 328
    JOKE = 329
    GOLF_CLAP = 343
    WINK = 363
    PAT = 364
    SERIOUS = 365
    MOUNT_SPECIAL = 366
    GOOD_LUCK = 367
    BLAME = 368
    BLANK = 369
    BRANDISH = 370
    BREATH = 371
    DISAGREE = 372
    DOUBT = 373
    EMBARRASS = 374
    ENCOURAGE = 375
    ENEMY = 376
    EYE_BROW = 377
    TOAST = 378


class TimerType(enum.Enum):
    FATIGUE = 0
    BREATH = 1
    FEIGN_DEATH = 2
    ENVIRONMENTAL = 3


class TitleEarnStatus(enum.Enum):
    LOST = 0
    EARNED = 1


class TradeStatus(enum.Enum):
    BUSY = 0
    BEGIN_TRADE = 1
    OPEN_WINDOW = 2
    TRADE_CANCELED = 3
    TRADE_ACCEPT = 4
    BUSY_2 = 5
    NO_TARGET = 6
    BACK_TO_TRADE = 7
    TRADE_COMPLETE = 8
    TRADE_REJECTED = 9
    TARGET_TO_FAR = 10
    WRONG_FACTION = 11
    CLOSE_WINDOW = 12
    UNKNOWN_13 = 13
    IGNORE_YOU = 14
    YOU_STUNNED = 15
    TARGET_STUNNED = 16
    YOU_DEAD = 17
    TARGET_DEAD = 18
    YOU_LOGOUT = 19
    TARGET_LOGOUT = 20
    TRIAL_ACCOUNT = 21
    ONLY_CONJURED = 22
    NOT_ON_TAPLIST = 23


class TrainerSpellState(enum.Enum):
    GREEN = 0
    RED = 1
    GRAY = 2


class TrainingFailureReason(enum.Enum):
    UNAVAILABLE = 0
    NOT_ENOUGH_MONEY = 1
    NOT_ENOUGH_SKILL = 2


class TransferAbortReason(enum.Enum):
    NONE = 0
    IS_FULL = 1
    NOT_FOUND = 2
    TOO_MANY_INSTANCES = 3
    ZONE_IS_IN_COMBAT = 5
    INSUFFICIENT_EXPANSION_LEVEL = 6
    DIFFICULTY_NOT_AVAILABLE = 7
    MISSING_DIFFICULTY = 8
    ZONE_IN_COMBAT = 9
    INSTANCE_IS_FULL = 10
    NOT_ALLOWED = 11
    HAS_BIND = 12


class UnitStandState(enum.Enum):
    STAND = 0
    SIT = 1
    SIT_CHAIR = 2
    SLEEP = 3
    SIT_LOW_CHAIR = 4
    SIT_MEDIUM_CHAIR = 5
    SIT_HIGH_CHAIR = 6
    DEAD = 7
    KNEEL = 8
    CUSTOM = 9


class UpdateType(enum.Enum):
    VALUES = 0
    MOVEMENT = 1
    CREATE_OBJECT = 2
    CREATE_OBJECT2 = 3
    OUT_OF_RANGE_OBJECTS = 4
    NEAR_OBJECTS = 5


class WeatherChangeType(enum.Enum):
    SMOOTH = 0
    INSTANT = 1


class WeatherType(enum.Enum):
    FINE = 0
    LIGHT_RAIN = 3
    MEDIUM_RAIN = 4
    HEAVY_RAIN = 5
    LIGHT_SNOW = 6
    MEDIUM_SNOW = 7
    HEAVY_SNOW = 8
    LIGHT_SANDSTORM = 22
    MEDIUM_SANDSTORM = 41
    HEAVY_SANDSTORM = 42
    THUNDERS = 86
    BLACKRAIN = 90


class WorldResult(enum.Enum):
    RESPONSE_SUCCESS = 0
    RESPONSE_FAILURE = 1
    RESPONSE_CANCELLED = 2
    RESPONSE_DISCONNECTED = 3
    RESPONSE_FAILED_TO_CONNECT = 4
    RESPONSE_CONNECTED = 5
    RESPONSE_VERSION_MISMATCH = 6
    CSTATUS_CONNECTING = 7
    CSTATUS_NEGOTIATING_SECURITY = 8
    CSTATUS_NEGOTIATION_COMPLETE = 9
    CSTATUS_NEGOTIATION_FAILED = 10
    CSTATUS_AUTHENTICATING = 11
    AUTH_OK = 12
    AUTH_FAILED = 13
    AUTH_REJECT = 14
    AUTH_BAD_SERVER_PROOF = 15
    AUTH_UNAVAILABLE = 16
    AUTH_SYSTEM_ERROR = 17
    AUTH_BILLING_ERROR = 18
    AUTH_BILLING_EXPIRED = 19
    AUTH_VERSION_MISMATCH = 20
    AUTH_UNKNOWN_ACCOUNT = 21
    AUTH_INCORRECT_PASSWORD = 22
    AUTH_SESSION_EXPIRED = 23
    AUTH_SERVER_SHUTTING_DOWN = 24
    AUTH_ALREADY_LOGGING_IN = 25
    AUTH_LOGIN_SERVER_NOT_FOUND = 26
    AUTH_WAIT_QUEUE = 27
    AUTH_BANNED = 28
    AUTH_ALREADY_ONLINE = 29
    AUTH_NO_TIME = 30
    AUTH_DB_BUSY = 31
    AUTH_SUSPENDED = 32
    AUTH_PARENTAL_CONTROL = 33
    AUTH_LOCKED_ENFORCED = 34
    REALM_LIST_IN_PROGRESS = 35
    REALM_LIST_SUCCESS = 36
    REALM_LIST_FAILED = 37
    REALM_LIST_INVALID = 38
    REALM_LIST_REALM_NOT_FOUND = 39
    ACCOUNT_CREATE_IN_PROGRESS = 40
    ACCOUNT_CREATE_SUCCESS = 41
    ACCOUNT_CREATE_FAILED = 42
    CHAR_LIST_RETRIEVING = 43
    CHAR_LIST_RETRIEVED = 44
    CHAR_LIST_FAILED = 45
    CHAR_CREATE_IN_PROGRESS = 46
    CHAR_CREATE_SUCCESS = 47
    CHAR_CREATE_ERROR = 48
    CHAR_CREATE_FAILED = 49
    CHAR_CREATE_NAME_IN_USE = 50
    CHAR_CREATE_DISABLED = 51
    CHAR_CREATE_PVP_TEAMS_VIOLATION = 52
    CHAR_CREATE_SERVER_LIMIT = 53
    CHAR_CREATE_ACCOUNT_LIMIT = 54
    CHAR_CREATE_SERVER_QUEUE = 55
    CHAR_CREATE_ONLY_EXISTING = 56
    CHAR_CREATE_EXPANSION = 57
    CHAR_DELETE_IN_PROGRESS = 58
    CHAR_DELETE_SUCCESS = 59
    CHAR_DELETE_FAILED = 60
    CHAR_DELETE_FAILED_LOCKED_FOR_TRANSFER = 61
    CHAR_DELETE_FAILED_GUILD_LEADER = 62
    CHAR_DELETE_FAILED_ARENA_CAPTAIN = 63
    CHAR_LOGIN_IN_PROGRESS = 64
    CHAR_LOGIN_SUCCESS = 65
    CHAR_LOGIN_NO_WORLD = 66
    CHAR_LOGIN_DUPLICATE_CHARACTER = 67
    CHAR_LOGIN_NO_INSTANCES = 68
    CHAR_LOGIN_FAILED = 69
    CHAR_LOGIN_DISABLED = 70
    CHAR_LOGIN_NO_CHARACTER = 71
    CHAR_LOGIN_LOCKED_FOR_TRANSFER = 72
    CHAR_LOGIN_LOCKED_BY_BILLING = 73
    CHAR_NAME_SUCCESS = 74
    CHAR_NAME_FAILURE = 75
    CHAR_NAME_NO_NAME = 76
    CHAR_NAME_TOO_SHORT = 77
    CHAR_NAME_TOO_LONG = 78
    CHAR_NAME_INVALID_CHARACTER = 79
    CHAR_NAME_MIXED_LANGUAGES = 80
    CHAR_NAME_PROFANE = 81
    CHAR_NAME_RESERVED = 82
    CHAR_NAME_INVALID_APOSTROPHE = 83
    CHAR_NAME_MULTIPLE_APOSTROPHES = 84
    CHAR_NAME_THREE_CONSECUTIVE = 85
    CHAR_NAME_INVALID_SPACE = 86
    CHAR_NAME_CONSECUTIVE_SPACES = 87
    CHAR_NAME_RUSSIAN_CONSECUTIVE_SILENT_CHARACTERS = 88
    CHAR_NAME_RUSSIAN_SILENT_CHARACTER_AT_BEGINNING_OR_END = 89
    CHAR_NAME_DECLENSION_DOESNT_MATCH_BASE_NAME = 90


class AllowedClass(enum.Flag):
    ALL = 0
    WARRIOR = 1
    PALADIN = 2
    HUNTER = 4
    ROGUE = 8
    PRIEST = 16
    SHAMAN = 64
    MAGE = 128
    WARLOCK = 256
    DRUID = 1024


class AllowedRace(enum.Flag):
    ALL = 0
    HUMAN = 1
    ORC = 2
    DWARF = 4
    NIGHT_ELF = 8
    UNDEAD = 16
    TAUREN = 32
    GNOME = 64
    TROLL = 128
    GOBLIN = 256
    BLOODELF = 512
    DRAENEI = 1024
    FEL_ORC = 2048
    NAGA = 4096
    BROKEN = 8192
    SKELETON = 16384
    VRYKUL = 32768
    TUSKARR = 65536
    FOREST_TROLL = 131072


class BagFamily(enum.Flag):
    NONE = 0
    ARROWS = 1
    BULLETS = 2
    SOUL_SHARDS = 4
    LEATHERWORKING_SUPPLIES = 8
    INSCRIPTION_SUPPLIES = 16
    HERBS = 32
    ENCHANTING_SUPPLIES = 64
    ENGINEERING_SUPPLIES = 128
    KEYS = 256
    GEMS = 512
    MINING_SUPPLIES = 1024
    SOULBOUND_EQUIPMENT = 2048
    VANITY_PETS = 4096
    CURRENCY_TOKENS = 8192
    QUEST_ITEMS = 16384


class BillingPlanFlags(enum.Flag):
    NONE = 0
    UNUSED = 1
    RECURRING_BILL = 2
    FREE_TRIAL = 4
    IGR = 8
    USAGE = 16
    TIME_MIXTURE = 32
    RESTRICTED = 64
    ENABLE_CAIS = 128


class CastFlags(enum.Flag):
    NONE = 0
    HIDDEN_COMBATLOG = 1
    UNKNOWN2 = 2
    UNKNOWN3 = 4
    UNKNOWN4 = 8
    UNKNOWN5 = 16
    AMMO = 32
    UNKNOWN7 = 64
    UNKNOWN8 = 128
    UNKNOWN9 = 256


class ChannelFlags(enum.Flag):
    NONE = 0
    CUSTOM = 1
    TRADE = 4
    NOT_LFG = 8
    GENERAL = 16
    CITY = 32
    LFG = 64
    VOICE = 128


class ChannelMemberFlags(enum.Flag):
    NONE = 0
    OWNER = 1
    MODERATOR = 4
    VOICED = 8
    MUTED = 16
    CUSTOM = 32
    MICROPHONE_MUTE = 64


class FactionFlag(enum.Flag):
    VISIBLE = 1
    AT_WAR = 2
    HIDDEN = 4
    INVISIBLE_FORCED = 8
    PEACE_FORCED = 16
    INACTIVE = 32
    RIVAL = 64


class GroupMemberOnlineStatus(enum.Flag):
    OFFLINE = 0
    ONLINE = 1
    PVP = 2
    DEAD = 4
    GHOST = 8
    PVP_FFA = 16
    ZONE_OUT = 32
    AFK = 64
    DND = 128


class GroupUpdateFlags(enum.Flag):
    NONE = 0
    STATUS = 1
    CUR_HP = 2
    MAX_HP = 4
    POWER_TYPE = 8
    CUR_POWER = 16
    MAX_POWER = 32
    LEVEL = 64
    ZONE = 128
    POSITION = 256
    AURAS = 512
    PET_GUID = 1024
    PET_NAME = 2048
    PET_MODEL_ID = 4096
    PET_CUR_HP = 8192
    PET_MAX_HP = 16384
    PET_POWER_TYPE = 32768
    PET_CUR_POWER = 65536
    PET_MAX_POWER = 131072
    PET_AURAS = 262144


class ItemFlag(enum.Flag):
    NO_PICKUP = 1
    CONJURED = 2
    LOOTABLE = 4
    DEPRECATED = 16
    INDESTRUCTIBLE = 32
    PLAYER_CAST = 64
    NO_EQUIP_COOLDOWN = 128
    INT_BONUS_INSTEAD = 256
    WRAPPER = 512
    IGNORE_BAG_SPACE = 1024
    PARTY_LOOT = 2048
    CHARTER = 8192
    LETTER = 16384
    NO_DISENCHANT = 32768
    REAL_DURATION = 65536
    NO_CREATOR = 131072
    PROSPECTABLE = 262144
    UNIQUE_EQUIPPED = 524288
    IGNORE_FOR_AURAS = 1048576
    IGNORE_DEFAULT_ARENA_RESTRICTIONS = 2097152
    NO_DURABILITY_LOSS = 4194304
    SPECIAL_USE = 8388608


class MovementFlags(enum.Flag):
    NONE = 0
    FORWARD = 1
    BACKWARD = 2
    STRAFE_LEFT = 4
    STRAFE_RIGHT = 8
    TURN_LEFT = 16
    TURN_RIGHT = 32
    PITCH_UP = 64
    PITCH_DOWN = 128
    WALK_MODE = 256
    ON_TRANSPORT = 512
    LEVITATING = 1024
    FIXED_Z = 2048
    ROOT = 4096
    JUMPING = 8192
    FALLINGFAR = 16384
    SWIMMING = 2097152
    ASCENDING = 4194304
    CAN_FLY = 8388608
    FLYING = 16777216
    ONTRANSPORT = 33554432
    SPLINE_ELEVATION = 67108864
    SPLINE_ENABLED = 134217728
    WATERWALKING = 268435456
    SAFE_FALL = 536870912
    HOVER = 1073741824


class RelationType(enum.Flag):
    NONE = 0
    FRIEND = 1
    IGNORED = 2
    MUTED = 4
    RECRUITAFRIEND = 8


class SpellCastTargetFlags(enum.Flag):
    SELF = 0
    UNUSED1 = 1
    UNIT = 2
    UNIT_RAID = 4
    UNIT_PARTY = 8
    ITEM = 16
    SOURCE_LOCATION = 32
    DEST_LOCATION = 64
    UNIT_ENEMY = 128
    UNIT_ALLY = 256
    CORPSE_ENEMY = 512
    UNIT_DEAD = 1024
    GAMEOBJECT = 2048
    TRADE_ITEM = 4096
    STRING = 8192
    LOCKED = 16384
    CORPSE_ALLY = 32768
    UNIT_MINIPET = 65536


class SplineFlag(enum.Flag):
    NONE = 0
    DONE = 1
    FALLING = 2
    UNKNOWN3 = 4
    UNKNOWN4 = 8
    UNKNOWN5 = 16
    UNKNOWN6 = 32
    UNKNOWN7 = 64
    UNKNOWN8 = 128
    RUN_MODE = 256
    FLYING = 512
    NO_SPLINE = 1024
    UNKNOWN12 = 2048
    UNKNOWN13 = 4096
    UNKNOWN14 = 8192
    UNKNOWN15 = 16384
    UNKNOWN16 = 32768
    FINAL_POINT = 65536
    FINAL_TARGET = 131072
    FINAL_ANGLE = 262144
    UNKNOWN19 = 524288
    CYCLIC = 1048576
    ENTER_CYCLE = 2097152
    FROZEN = 4194304
    UNKNOWN23 = 8388608
    UNKNOWN24 = 16777216
    UNKNOWN25 = 33554432
    UNKNOWN26 = 67108864
    UNKNOWN27 = 134217728
    UNKNOWN28 = 268435456
    UNKNOWN29 = 536870912
    UNKNOWN30 = 1073741824
    UNKNOWN31 = 2147483648


class UpdateFlag(enum.Flag):
    NONE = 0
    SELF = 1
    TRANSPORT = 2
    MELEE_ATTACKING = 4
    HIGH_GUID = 8
    ALL = 16
    LIVING = 32
    HAS_POSITION = 64


@dataclasses.dataclass
class Addon:
    addon_type: int
    uses_crc: int
    uses_diffent_public_key: bool
    unknown1: int
    unknown2: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Addon:
        # addon_type: u8
        addon_type = await read_int(reader, 1)

        # uses_crc: u8
        uses_crc = await read_int(reader, 1)

        # uses_diffent_public_key: Bool8
        uses_diffent_public_key = await read_bool(reader, 1)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # unknown2: u8
        unknown2 = await read_int(reader, 1)

        return Addon(
            addon_type=addon_type,
            uses_crc=uses_crc,
            uses_diffent_public_key=uses_diffent_public_key,
            unknown1=unknown1,
            unknown2=unknown2,
        )

    def write(self, _fmt, _data):
        _fmt += 'BBBIB'
        _data.extend([self.addon_type, self.uses_crc, self.uses_diffent_public_key, self.unknown1, self.unknown2])
        return _fmt, _data


@dataclasses.dataclass
class AddonInfo:
    addon_name: str
    addon_has_signature: int
    addon_crc: int
    addon_extra_crc: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> AddonInfo:
        # addon_name: CString
        addon_name = await read_cstring(reader)

        # addon_has_signature: u8
        addon_has_signature = await read_int(reader, 1)

        # addon_crc: u32
        addon_crc = await read_int(reader, 4)

        # addon_extra_crc: u32
        addon_extra_crc = await read_int(reader, 4)

        return AddonInfo(
            addon_name=addon_name,
            addon_has_signature=addon_has_signature,
            addon_crc=addon_crc,
            addon_extra_crc=addon_extra_crc,
        )

    def write(self, _fmt, _data):
        _fmt += f'{len(self.addon_name)}sBBII'
        _data.extend([self.addon_name.encode('utf-8'), 0, self.addon_has_signature, self.addon_crc, self.addon_extra_crc])
        return _fmt, _data

    def size(self) -> int:
        return 10 + len(self.addon_name)


@dataclasses.dataclass
class ArenaTeamMember:
    guid: int
    online: bool
    name: str
    level: int
    class_type: Class
    games_played_this_week: int
    wins_this_week: int
    games_played_this_season: int
    wins_this_season: int
    personal_rating: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ArenaTeamMember:
        # guid: Guid
        guid = await read_int(reader, 8)

        # online: Bool8
        online = await read_bool(reader, 1)

        # name: CString
        name = await read_cstring(reader)

        # level: Level
        level = await read_int(reader, 1)

        # class_type: Class
        class_type = Class(await read_int(reader, 1))

        # games_played_this_week: u32
        games_played_this_week = await read_int(reader, 4)

        # wins_this_week: u32
        wins_this_week = await read_int(reader, 4)

        # games_played_this_season: u32
        games_played_this_season = await read_int(reader, 4)

        # wins_this_season: u32
        wins_this_season = await read_int(reader, 4)

        # personal_rating: u32
        personal_rating = await read_int(reader, 4)

        return ArenaTeamMember(
            guid=guid,
            online=online,
            name=name,
            level=level,
            class_type=class_type,
            games_played_this_week=games_played_this_week,
            wins_this_week=wins_this_week,
            games_played_this_season=games_played_this_season,
            wins_this_season=wins_this_season,
            personal_rating=personal_rating,
        )

    def write(self, _fmt, _data):
        _fmt += f'QB{len(self.name)}sBBBIIIII'
        _data.extend([self.guid, self.online, self.name.encode('utf-8'), 0, self.level, self.class_type.value, self.games_played_this_week, self.wins_this_week, self.games_played_this_season, self.wins_this_season, self.personal_rating])
        return _fmt, _data

    def size(self) -> int:
        return 32 + len(self.name)


@dataclasses.dataclass
class AuctionEnchantment:
    enchant_id: int
    enchant_duration: int
    enchant_charges: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> AuctionEnchantment:
        # enchant_id: u32
        enchant_id = await read_int(reader, 4)

        # enchant_duration: u32
        enchant_duration = await read_int(reader, 4)

        # enchant_charges: u32
        enchant_charges = await read_int(reader, 4)

        return AuctionEnchantment(
            enchant_id=enchant_id,
            enchant_duration=enchant_duration,
            enchant_charges=enchant_charges,
        )

    def write(self, _fmt, _data):
        _fmt += 'III'
        _data.extend([self.enchant_id, self.enchant_duration, self.enchant_charges])
        return _fmt, _data


@dataclasses.dataclass
class AuctionListItem:
    id: int
    item: int
    enchantments: typing.List[AuctionEnchantment]
    item_random_property_id: int
    item_suffix_factor: int
    item_count: int
    item_charges: int
    item_flags: int
    item_owner: int
    start_bid: int
    minimum_bid: int
    buyout_amount: int
    time_left: int
    highest_bidder: int
    highest_bid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> AuctionListItem:
        # id: u32
        id = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        # enchantments: AuctionEnchantment[6]
        enchantments = []
        for _ in range(0, 6):
            enchantments.append(await AuctionEnchantment.read(reader))

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # item_suffix_factor: u32
        item_suffix_factor = await read_int(reader, 4)

        # item_count: u32
        item_count = await read_int(reader, 4)

        # item_charges: u32
        item_charges = await read_int(reader, 4)

        # item_flags: u32
        item_flags = await read_int(reader, 4)

        # item_owner: Guid
        item_owner = await read_int(reader, 8)

        # start_bid: u32
        start_bid = await read_int(reader, 4)

        # minimum_bid: u32
        minimum_bid = await read_int(reader, 4)

        # buyout_amount: u32
        buyout_amount = await read_int(reader, 4)

        # time_left: Milliseconds
        time_left = await read_int(reader, 4)

        # highest_bidder: Guid
        highest_bidder = await read_int(reader, 8)

        # highest_bid: u32
        highest_bid = await read_int(reader, 4)

        return AuctionListItem(
            id=id,
            item=item,
            enchantments=enchantments,
            item_random_property_id=item_random_property_id,
            item_suffix_factor=item_suffix_factor,
            item_count=item_count,
            item_charges=item_charges,
            item_flags=item_flags,
            item_owner=item_owner,
            start_bid=start_bid,
            minimum_bid=minimum_bid,
            buyout_amount=buyout_amount,
            time_left=time_left,
            highest_bidder=highest_bidder,
            highest_bid=highest_bid,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.id, self.item])
        # enchantments: AuctionEnchantment[6]
        for i in self.enchantments:
            _fmt, _data = i.write(_fmt, _data)

        # item_random_property_id: u32
        _fmt += 'I'
        _data.append(self.item_random_property_id)

        # item_suffix_factor: u32
        _fmt += 'I'
        _data.append(self.item_suffix_factor)

        # item_count: u32
        _fmt += 'I'
        _data.append(self.item_count)

        # item_charges: u32
        _fmt += 'I'
        _data.append(self.item_charges)

        # item_flags: u32
        _fmt += 'I'
        _data.append(self.item_flags)

        # item_owner: Guid
        _fmt += 'Q'
        _data.append(self.item_owner)

        # start_bid: u32
        _fmt += 'I'
        _data.append(self.start_bid)

        # minimum_bid: u32
        _fmt += 'I'
        _data.append(self.minimum_bid)

        # buyout_amount: u32
        _fmt += 'I'
        _data.append(self.buyout_amount)

        # time_left: Milliseconds
        _fmt += 'I'
        _data.append(self.time_left)

        # highest_bidder: Guid
        _fmt += 'Q'
        _data.append(self.highest_bidder)

        # highest_bid: u32
        _fmt += 'I'
        _data.append(self.highest_bid)

        return _fmt, _data


@dataclasses.dataclass
class AuctionSort:
    column: int
    reversed: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> AuctionSort:
        # column: u8
        column = await read_int(reader, 1)

        # reversed: u8
        reversed = await read_int(reader, 1)

        return AuctionSort(
            column=column,
            reversed=reversed,
        )

    def write(self, _fmt, _data):
        _fmt += 'BB'
        _data.extend([self.column, self.reversed])
        return _fmt, _data


@dataclasses.dataclass
class Aura:
    aura: int
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Aura:
        # aura: u16
        aura = await read_int(reader, 2)

        # unknown: u8
        unknown = await read_int(reader, 1)

        return Aura(
            aura=aura,
            unknown=unknown,
        )

    def write(self, _fmt, _data):
        _fmt += 'HB'
        _data.extend([self.aura, self.unknown])
        return _fmt, _data


@dataclasses.dataclass
class AuraMask:
    fields: dict[int, Aura]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        mask = await read_int(reader, 8)

        fields = {}
        for index in range(0, 64):
            if mask & 1 << index:
                aura = await Aura.read(reader)
                fields[index] = aura

        return AuraMask(fields=fields)

    def write(self, fmt, data):
        mask = 0
        for i, _ in enumerate(self.fields):
            mask |= 1 << i

        fmt += 'Q'
        data.append(mask)

        for aura in self.fields:
            fmt, data = aura.write(fmt, data)

        return fmt, data

    def size(self):
        return 4 + len(self.fields) * 3


@dataclasses.dataclass
class AuraLog:
    aura_type: AuraType
    damage1: typing.Optional[int] = None
    school: typing.Optional[SpellSchool] = None
    absorbed: typing.Optional[int] = None
    resisted: typing.Optional[int] = None
    damage2: typing.Optional[int] = None
    misc_value1: typing.Optional[int] = None
    damage3: typing.Optional[int] = None
    misc_value2: typing.Optional[int] = None
    damage: typing.Optional[int] = None
    gain_multiplier: typing.Optional[float] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> AuraLog:
        damage1 = None
        school = None
        absorbed = None
        resisted = None
        damage2 = None
        misc_value1 = None
        damage3 = None
        misc_value2 = None
        damage = None
        gain_multiplier = None
        # aura_type: AuraType
        aura_type = AuraType(await read_int(reader, 4))

        if aura_type in {AuraType.PERIODIC_DAMAGE, AuraType.PERIODIC_DAMAGE_PERCENT}:
            # damage1: u32
            damage1 = await read_int(reader, 4)

            # school: SpellSchool
            school = SpellSchool(await read_int(reader, 1))

            # absorbed: u32
            absorbed = await read_int(reader, 4)

            # resisted: u32
            resisted = await read_int(reader, 4)

        elif aura_type in {AuraType.PERIODIC_HEAL, AuraType.OBS_MOD_HEALTH}:
            # damage2: u32
            damage2 = await read_int(reader, 4)

        elif aura_type in {AuraType.OBS_MOD_MANA, AuraType.PERIODIC_ENERGIZE}:
            # misc_value1: u32
            misc_value1 = await read_int(reader, 4)

            # damage3: u32
            damage3 = await read_int(reader, 4)

        elif aura_type == AuraType.PERIODIC_MANA_LEECH:
            # misc_value2: u32
            misc_value2 = await read_int(reader, 4)

            # damage: u32
            damage = await read_int(reader, 4)

            # gain_multiplier: f32
            gain_multiplier = await read_float(reader)

        return AuraLog(
            aura_type=aura_type,
            damage1=damage1,
            school=school,
            absorbed=absorbed,
            resisted=resisted,
            damage2=damage2,
            misc_value1=misc_value1,
            damage3=damage3,
            misc_value2=misc_value2,
            damage=damage,
            gain_multiplier=gain_multiplier,
        )

    def write(self, _fmt, _data):
        _fmt += 'I'
        _data.append(self.aura_type.value)
        if self.aura_type in {AuraType.PERIODIC_DAMAGE, AuraType.PERIODIC_DAMAGE_PERCENT}:
            _fmt += 'IBII'
            _data.extend([self.damage1, self.school.value, self.absorbed, self.resisted])
        elif self.aura_type in {AuraType.PERIODIC_HEAL, AuraType.OBS_MOD_HEALTH}:
            _fmt += 'I'
            _data.append(self.damage2)
        elif self.aura_type in {AuraType.OBS_MOD_MANA, AuraType.PERIODIC_ENERGIZE}:
            _fmt += 'II'
            _data.extend([self.misc_value1, self.damage3])
        elif self.aura_type == AuraType.PERIODIC_MANA_LEECH:
            _fmt += 'IIf'
            _data.extend([self.misc_value2, self.damage, self.gain_multiplier])
        return _fmt, _data

    def size(self) -> int:
        _size = 4

        if self.aura_type in {AuraType.PERIODIC_DAMAGE, AuraType.PERIODIC_DAMAGE_PERCENT}:
            _size += 13
        elif self.aura_type in {AuraType.PERIODIC_HEAL, AuraType.OBS_MOD_HEALTH}:
            _size += 4
        elif self.aura_type in {AuraType.OBS_MOD_MANA, AuraType.PERIODIC_ENERGIZE}:
            _size += 8
        elif self.aura_type == AuraType.PERIODIC_MANA_LEECH:
            _size += 12

        return _size


@dataclasses.dataclass
class BankTab:
    flags: int
    stacks_per_day: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> BankTab:
        # flags: u32
        flags = await read_int(reader, 4)

        # stacks_per_day: u32
        stacks_per_day = await read_int(reader, 4)

        return BankTab(
            flags=flags,
            stacks_per_day=stacks_per_day,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.flags, self.stacks_per_day])
        return _fmt, _data


@dataclasses.dataclass
class BattlegroundPlayerPosition:
    player: int
    position_x: float
    position_y: float

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> BattlegroundPlayerPosition:
        # player: Guid
        player = await read_int(reader, 8)

        # position_x: f32
        position_x = await read_float(reader)

        # position_y: f32
        position_y = await read_float(reader)

        return BattlegroundPlayerPosition(
            player=player,
            position_x=position_x,
            position_y=position_y,
        )

    def write(self, _fmt, _data):
        _fmt += 'Qff'
        _data.extend([self.player, self.position_x, self.position_y])
        return _fmt, _data


@dataclasses.dataclass
class ChannelMember:
    guid: int
    member_flags: ChannelMemberFlags

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ChannelMember:
        # guid: Guid
        guid = await read_int(reader, 8)

        # member_flags: ChannelMemberFlags
        member_flags = ChannelMemberFlags(await read_int(reader, 1))

        return ChannelMember(
            guid=guid,
            member_flags=member_flags,
        )

    def write(self, _fmt, _data):
        _fmt += 'QB'
        _data.extend([self.guid, self.member_flags.value])
        return _fmt, _data


@dataclasses.dataclass
class Vector3d:
    x: float
    y: float
    z: float

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Vector3d:
        # x: f32
        x = await read_float(reader)

        # y: f32
        y = await read_float(reader)

        # z: f32
        z = await read_float(reader)

        return Vector3d(
            x=x,
            y=y,
            z=z,
        )

    def write(self, _fmt, _data):
        _fmt += 'fff'
        _data.extend([self.x, self.y, self.z])
        return _fmt, _data


@dataclasses.dataclass
class MonsterMoveSpline:
    splines: list[Vector3d]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        def packed_to_vec(packed: int) -> Vector3d:
            x = float(packed & 0x7FF) / 4
            y = float((packed >> 11) & 0x7FF) / 4
            z = float((packed >> 22) & 0x3FF) / 4
            return Vector3d(x=x, y=y, z=z)

        amount_of_splines = await read_int(reader, 4)

        if amount_of_splines == 0:
            return MonsterMoveSpline(splines=[])

        splines = [await Vector3d.read(reader)]

        for i in range(1, amount_of_splines): # subtract the 'real' one
            packed = await read_int(reader, 4)
            splines.append(packed_to_vec(packed))

        return MonsterMoveSpline(splines=splines)

    def write(self, fmt, data):
        def vec_to_packed(vec: Vector3d) -> int:
            packed = 0
            packed |= int(vec.x / 0.25) & 0x7FF
            packed |= (int(vec.y / 0.25) & 0x7FF) << 11
            packed |= (int(vec.z / 0.25) & 0x3FF) << 22
            return packed
        amount_of_splines = len(self.splines)
        fmt += 'I'
        data.append(amount_of_splines)

        if amount_of_splines == 0:
            return fmt, data

        fmt, data = self.splines[0].write(fmt, data)

        for i in range(1, amount_of_splines):
            packed = vec_to_packed(self.splines[i])
            fmt += 'I'
            data.append(packed)

        return fmt, data

    def size(self):
        if len(self.splines) == 0:
            return 4

        return 4 + 3 * 4 + (len(self.splines) - 1) * 4


@dataclasses.dataclass
class CharacterGear:
    equipment_display_id: int
    inventory_type: InventoryType
    enchantment: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> CharacterGear:
        # equipment_display_id: u32
        equipment_display_id = await read_int(reader, 4)

        # inventory_type: InventoryType
        inventory_type = InventoryType(await read_int(reader, 1))

        # enchantment: u32
        enchantment = await read_int(reader, 4)

        return CharacterGear(
            equipment_display_id=equipment_display_id,
            inventory_type=inventory_type,
            enchantment=enchantment,
        )

    def write(self, _fmt, _data):
        _fmt += 'IBI'
        _data.extend([self.equipment_display_id, self.inventory_type.value, self.enchantment])
        return _fmt, _data


@dataclasses.dataclass
class Character:
    guid: int
    name: str
    race: Race
    class_type: Class
    gender: Gender
    skin: int
    face: int
    hair_style: int
    hair_color: int
    facial_hair: int
    level: int
    area: Area
    map: Map
    position: Vector3d
    guild_id: int
    flags: int
    first_login: bool
    pet_display_id: int
    pet_level: int
    pet_family: CreatureFamily
    equipment: typing.List[CharacterGear]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Character:
        # guid: Guid
        guid = await read_int(reader, 8)

        # name: CString
        name = await read_cstring(reader)

        # race: Race
        race = Race(await read_int(reader, 1))

        # class_type: Class
        class_type = Class(await read_int(reader, 1))

        # gender: Gender
        gender = Gender(await read_int(reader, 1))

        # skin: u8
        skin = await read_int(reader, 1)

        # face: u8
        face = await read_int(reader, 1)

        # hair_style: u8
        hair_style = await read_int(reader, 1)

        # hair_color: u8
        hair_color = await read_int(reader, 1)

        # facial_hair: u8
        facial_hair = await read_int(reader, 1)

        # level: Level
        level = await read_int(reader, 1)

        # area: Area
        area = Area(await read_int(reader, 4))

        # map: Map
        map = Map(await read_int(reader, 4))

        # position: Vector3d
        position = await Vector3d.read(reader)

        # guild_id: u32
        guild_id = await read_int(reader, 4)

        # flags: u32
        flags = await read_int(reader, 4)

        # first_login: Bool8
        first_login = await read_bool(reader, 1)

        # pet_display_id: u32
        pet_display_id = await read_int(reader, 4)

        # pet_level: Level32
        pet_level = await read_int(reader, 4)

        # pet_family: CreatureFamily
        pet_family = CreatureFamily(await read_int(reader, 4))

        # equipment: CharacterGear[20]
        equipment = []
        for _ in range(0, 20):
            equipment.append(await CharacterGear.read(reader))

        return Character(
            guid=guid,
            name=name,
            race=race,
            class_type=class_type,
            gender=gender,
            skin=skin,
            face=face,
            hair_style=hair_style,
            hair_color=hair_color,
            facial_hair=facial_hair,
            level=level,
            area=area,
            map=map,
            position=position,
            guild_id=guild_id,
            flags=flags,
            first_login=first_login,
            pet_display_id=pet_display_id,
            pet_level=pet_level,
            pet_family=pet_family,
            equipment=equipment,
        )

    def write(self, _fmt, _data):
        _fmt += f'Q{len(self.name)}sBBBBBBBBBBII'
        _data.extend([self.guid, self.name.encode('utf-8'), 0, self.race.value, self.class_type.value, self.gender.value, self.skin, self.face, self.hair_style, self.hair_color, self.facial_hair, self.level, self.area.value, self.map.value])
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # guild_id: u32
        _fmt += 'I'
        _data.append(self.guild_id)

        # flags: u32
        _fmt += 'I'
        _data.append(self.flags)

        # first_login: Bool8
        _fmt += 'B'
        _data.append(self.first_login)

        # pet_display_id: u32
        _fmt += 'I'
        _data.append(self.pet_display_id)

        # pet_level: Level32
        _fmt += 'I'
        _data.append(self.pet_level)

        # pet_family: CreatureFamily
        _fmt += 'I'
        _data.append(self.pet_family.value)

        # equipment: CharacterGear[20]
        for i in self.equipment:
            _fmt, _data = i.write(_fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        return 239 + len(self.name)


@dataclasses.dataclass
class CooldownSpell:
    spell_id: int
    item_id: int
    spell_category: int
    cooldown: int
    category_cooldown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> CooldownSpell:
        # spell_id: u16
        spell_id = await read_int(reader, 2)

        # item_id: u16
        item_id = await read_int(reader, 2)

        # spell_category: u16
        spell_category = await read_int(reader, 2)

        # cooldown: Milliseconds
        cooldown = await read_int(reader, 4)

        # category_cooldown: Milliseconds
        category_cooldown = await read_int(reader, 4)

        return CooldownSpell(
            spell_id=spell_id,
            item_id=item_id,
            spell_category=spell_category,
            cooldown=cooldown,
            category_cooldown=category_cooldown,
        )

    def write(self, _fmt, _data):
        _fmt += 'HHHII'
        _data.extend([self.spell_id, self.item_id, self.spell_category, self.cooldown, self.category_cooldown])
        return _fmt, _data


@dataclasses.dataclass
class DamageInfo:
    spell_school_mask: int
    damage_float: float
    damage_uint: int
    absorb: int
    resist: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> DamageInfo:
        # spell_school_mask: u32
        spell_school_mask = await read_int(reader, 4)

        # damage_float: f32
        damage_float = await read_float(reader)

        # damage_uint: u32
        damage_uint = await read_int(reader, 4)

        # absorb: u32
        absorb = await read_int(reader, 4)

        # resist: u32
        resist = await read_int(reader, 4)

        return DamageInfo(
            spell_school_mask=spell_school_mask,
            damage_float=damage_float,
            damage_uint=damage_uint,
            absorb=absorb,
            resist=resist,
        )

    def write(self, _fmt, _data):
        _fmt += 'IfIII'
        _data.extend([self.spell_school_mask, self.damage_float, self.damage_uint, self.absorb, self.resist])
        return _fmt, _data


@dataclasses.dataclass
class DispelledSpell:
    spell: int
    method: DispelMethod

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> DispelledSpell:
        # spell: Spell
        spell = await read_int(reader, 4)

        # method: DispelMethod
        method = DispelMethod(await read_int(reader, 1))

        return DispelledSpell(
            spell=spell,
            method=method,
        )

    def write(self, _fmt, _data):
        _fmt += 'IB'
        _data.extend([self.spell, self.method.value])
        return _fmt, _data


@dataclasses.dataclass
class FactionInitializer:
    flag: FactionFlag
    standing: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> FactionInitializer:
        # flag: FactionFlag
        flag = FactionFlag(await read_int(reader, 1))

        # standing: u32
        standing = await read_int(reader, 4)

        return FactionInitializer(
            flag=flag,
            standing=standing,
        )

    def write(self, _fmt, _data):
        _fmt += 'BI'
        _data.extend([self.flag.value, self.standing])
        return _fmt, _data


@dataclasses.dataclass
class FactionStanding:
    faction: Faction
    standing: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> FactionStanding:
        # faction: Faction
        faction = Faction(await read_int(reader, 2))

        # standing: u32
        standing = await read_int(reader, 4)

        return FactionStanding(
            faction=faction,
            standing=standing,
        )

    def write(self, _fmt, _data):
        _fmt += 'HI'
        _data.extend([self.faction.value, self.standing])
        return _fmt, _data


@dataclasses.dataclass
class ForcedReaction:
    faction: Faction
    reputation_rank: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ForcedReaction:
        # faction: Faction
        faction = Faction(await read_int(reader, 2))

        # reputation_rank: u32
        reputation_rank = await read_int(reader, 4)

        return ForcedReaction(
            faction=faction,
            reputation_rank=reputation_rank,
        )

    def write(self, _fmt, _data):
        _fmt += 'HI'
        _data.extend([self.faction.value, self.reputation_rank])
        return _fmt, _data


@dataclasses.dataclass
class GmSurveyQuestion:
    question_id: int
    answer: int
    comment: str

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GmSurveyQuestion:
        # question_id: u32
        question_id = await read_int(reader, 4)

        # answer: u8
        answer = await read_int(reader, 1)

        # comment: CString
        comment = await read_cstring(reader)

        return GmSurveyQuestion(
            question_id=question_id,
            answer=answer,
            comment=comment,
        )

    def write(self, _fmt, _data):
        _fmt += f'IB{len(self.comment)}sB'
        _data.extend([self.question_id, self.answer, self.comment.encode('utf-8'), 0])
        return _fmt, _data

    def size(self) -> int:
        return 6 + len(self.comment)


@dataclasses.dataclass
class GossipItem:
    id: int
    item_icon: int
    coded: bool
    money_required: int
    message: str
    accept_text: str

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GossipItem:
        # id: u32
        id = await read_int(reader, 4)

        # item_icon: u8
        item_icon = await read_int(reader, 1)

        # coded: Bool8
        coded = await read_bool(reader, 1)

        # money_required: Gold
        money_required = await read_int(reader, 4)

        # message: CString
        message = await read_cstring(reader)

        # accept_text: CString
        accept_text = await read_cstring(reader)

        return GossipItem(
            id=id,
            item_icon=item_icon,
            coded=coded,
            money_required=money_required,
            message=message,
            accept_text=accept_text,
        )

    def write(self, _fmt, _data):
        _fmt += f'IBBI{len(self.message)}sB{len(self.accept_text)}sB'
        _data.extend([self.id, self.item_icon, self.coded, self.money_required, self.message.encode('utf-8'), 0, self.accept_text.encode('utf-8'), 0])
        return _fmt, _data

    def size(self) -> int:
        return 12 + len(self.message) + len(self.accept_text)


@dataclasses.dataclass
class GroupListMember:
    name: str
    guid: int
    is_online: bool
    group_id: int
    flags: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GroupListMember:
        # name: CString
        name = await read_cstring(reader)

        # guid: Guid
        guid = await read_int(reader, 8)

        # is_online: Bool8
        is_online = await read_bool(reader, 1)

        # group_id: u8
        group_id = await read_int(reader, 1)

        # flags: u8
        flags = await read_int(reader, 1)

        return GroupListMember(
            name=name,
            guid=guid,
            is_online=is_online,
            group_id=group_id,
            flags=flags,
        )

    def write(self, _fmt, _data):
        _fmt += f'{len(self.name)}sBQBBB'
        _data.extend([self.name.encode('utf-8'), 0, self.guid, self.is_online, self.group_id, self.flags])
        return _fmt, _data

    def size(self) -> int:
        return 12 + len(self.name)


@dataclasses.dataclass
class GuildBankRights:
    rights: int
    slots_per_day: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GuildBankRights:
        # rights: u32
        rights = await read_int(reader, 4)

        # slots_per_day: u32
        slots_per_day = await read_int(reader, 4)

        return GuildBankRights(
            rights=rights,
            slots_per_day=slots_per_day,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.rights, self.slots_per_day])
        return _fmt, _data


@dataclasses.dataclass
class GuildBankSocket:
    socket_index: int
    gem: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GuildBankSocket:
        # socket_index: u8
        socket_index = await read_int(reader, 1)

        # gem: u32
        gem = await read_int(reader, 4)

        return GuildBankSocket(
            socket_index=socket_index,
            gem=gem,
        )

    def write(self, _fmt, _data):
        _fmt += 'BI'
        _data.extend([self.socket_index, self.gem])
        return _fmt, _data


@dataclasses.dataclass
class GuildBankSlot:
    slot: int
    item: int
    item_random_property_id: VariableItemRandomProperty
    amount_of_items: int
    enchant: int
    charges: int
    sockets: typing.List[GuildBankSocket]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GuildBankSlot:
        # slot: u8
        slot = await read_int(reader, 1)

        # item: Item
        item = await read_int(reader, 4)

        # item_random_property_id: VariableItemRandomProperty
        item_random_property_id = await VariableItemRandomProperty.read(reader)

        # amount_of_items: u8
        amount_of_items = await read_int(reader, 1)

        # enchant: u32
        enchant = await read_int(reader, 4)

        # charges: u8
        charges = await read_int(reader, 1)

        # amount_of_sockets: u8
        amount_of_sockets = await read_int(reader, 1)

        # sockets: GuildBankSocket[amount_of_sockets]
        sockets = []
        for _ in range(0, amount_of_sockets):
            sockets.append(await GuildBankSocket.read(reader))

        return GuildBankSlot(
            slot=slot,
            item=item,
            item_random_property_id=item_random_property_id,
            amount_of_items=amount_of_items,
            enchant=enchant,
            charges=charges,
            sockets=sockets,
        )

    def write(self, _fmt, _data):
        _fmt += 'BI'
        _data.extend([self.slot, self.item])
        # item_random_property_id: VariableItemRandomProperty
        _fmt, _data = self.item_random_property_id.write(_fmt, _data)

        # amount_of_items: u8
        _fmt += 'B'
        _data.append(self.amount_of_items)

        # enchant: u32
        _fmt += 'I'
        _data.append(self.enchant)

        # charges: u8
        _fmt += 'B'
        _data.append(self.charges)

        # amount_of_sockets: u8
        _fmt += 'B'
        _data.append(len(self.sockets))

        # sockets: GuildBankSocket[amount_of_sockets]
        for i in self.sockets:
            _fmt, _data = i.write(_fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        return 12 + self.item_random_property_id.size() + 5 * len(self.sockets)


@dataclasses.dataclass
class GuildBankTab:
    tab_name: str
    tab_icon: str

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GuildBankTab:
        # tab_name: CString
        tab_name = await read_cstring(reader)

        # tab_icon: CString
        tab_icon = await read_cstring(reader)

        return GuildBankTab(
            tab_name=tab_name,
            tab_icon=tab_icon,
        )

    def write(self, _fmt, _data):
        _fmt += f'{len(self.tab_name)}sB{len(self.tab_icon)}sB'
        _data.extend([self.tab_name.encode('utf-8'), 0, self.tab_icon.encode('utf-8'), 0])
        return _fmt, _data

    def size(self) -> int:
        return 2 + len(self.tab_name) + len(self.tab_icon)


@dataclasses.dataclass
class GuildLogEvent:
    event: GuildEvent
    player1: int
    unix_time: int
    player2: typing.Optional[int] = None
    new_rank: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GuildLogEvent:
        player2 = None
        new_rank = None
        # event: GuildEvent
        event = GuildEvent(await read_int(reader, 1))

        # player1: Guid
        player1 = await read_int(reader, 8)

        if event in {GuildEvent.JOINED, GuildEvent.LEFT}:
            # player2: Guid
            player2 = await read_int(reader, 8)

        elif event in {GuildEvent.PROMOTION, GuildEvent.DEMOTION}:
            # new_rank: u8
            new_rank = await read_int(reader, 1)

        # unix_time: u32
        unix_time = await read_int(reader, 4)

        return GuildLogEvent(
            event=event,
            player1=player1,
            player2=player2,
            new_rank=new_rank,
            unix_time=unix_time,
        )

    def write(self, _fmt, _data):
        _fmt += 'BQ'
        _data.extend([self.event.value, self.player1])
        if self.event in {GuildEvent.JOINED, GuildEvent.LEFT}:
            _fmt += 'Q'
            _data.append(self.player2)
        elif self.event in {GuildEvent.PROMOTION, GuildEvent.DEMOTION}:
            _fmt += 'B'
            _data.append(self.new_rank)
        # unix_time: u32
        _fmt += 'I'
        _data.append(self.unix_time)

        return _fmt, _data

    def size(self) -> int:
        _size = 13

        if self.event in {GuildEvent.JOINED, GuildEvent.LEFT}:
            _size += 8
        elif self.event in {GuildEvent.PROMOTION, GuildEvent.DEMOTION}:
            _size += 1

        return _size


@dataclasses.dataclass
class GuildMember:
    guid: int
    status: GuildMemberStatus
    name: str
    rank: int
    level: int
    class_type: Class
    unknown1: int
    area: Area
    public_note: str
    officer_note: str
    time_offline: typing.Optional[float] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GuildMember:
        time_offline = None
        # guid: Guid
        guid = await read_int(reader, 8)

        # status: GuildMemberStatus
        status = GuildMemberStatus(await read_int(reader, 1))

        # name: CString
        name = await read_cstring(reader)

        # rank: u32
        rank = await read_int(reader, 4)

        # level: Level
        level = await read_int(reader, 1)

        # class_type: Class
        class_type = Class(await read_int(reader, 1))

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # area: Area
        area = Area(await read_int(reader, 4))

        if status == GuildMemberStatus.OFFLINE:
            # time_offline: f32
            time_offline = await read_float(reader)

        # public_note: CString
        public_note = await read_cstring(reader)

        # officer_note: CString
        officer_note = await read_cstring(reader)

        return GuildMember(
            guid=guid,
            status=status,
            name=name,
            rank=rank,
            level=level,
            class_type=class_type,
            unknown1=unknown1,
            area=area,
            time_offline=time_offline,
            public_note=public_note,
            officer_note=officer_note,
        )

    def write(self, _fmt, _data):
        _fmt += f'QB{len(self.name)}sBIBBBI'
        _data.extend([self.guid, self.status.value, self.name.encode('utf-8'), 0, self.rank, self.level, self.class_type.value, self.unknown1, self.area.value])
        if self.status == GuildMemberStatus.OFFLINE:
            _fmt += 'f'
            _data.append(self.time_offline)
        # public_note: CString
        _fmt += f'{len(self.public_note)}sB'
        _data.extend([self.public_note.encode('utf-8'), 0])

        # officer_note: CString
        _fmt += f'{len(self.officer_note)}sB'
        _data.extend([self.officer_note.encode('utf-8'), 0])

        return _fmt, _data

    def size(self) -> int:
        _size = 23 + len(self.name) + len(self.public_note) + len(self.officer_note)

        if self.status == GuildMemberStatus.OFFLINE:
            _size += 4

        return _size


@dataclasses.dataclass
class GuildRights:
    rights: int
    money_per_day: int
    bank_tab_rights: typing.List[GuildBankRights]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GuildRights:
        # rights: u32
        rights = await read_int(reader, 4)

        # money_per_day: Gold
        money_per_day = await read_int(reader, 4)

        # bank_tab_rights: GuildBankRights[6]
        bank_tab_rights = []
        for _ in range(0, 6):
            bank_tab_rights.append(await GuildBankRights.read(reader))

        return GuildRights(
            rights=rights,
            money_per_day=money_per_day,
            bank_tab_rights=bank_tab_rights,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.rights, self.money_per_day])
        # bank_tab_rights: GuildBankRights[6]
        for i in self.bank_tab_rights:
            _fmt, _data = i.write(_fmt, _data)

        return _fmt, _data


@dataclasses.dataclass
class InitialSpell:
    spell_id: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> InitialSpell:
        # spell_id: u16
        spell_id = await read_int(reader, 2)

        # unknown1: u16
        unknown1 = await read_int(reader, 2)

        return InitialSpell(
            spell_id=spell_id,
            unknown1=unknown1,
        )

    def write(self, _fmt, _data):
        _fmt += 'HH'
        _data.extend([self.spell_id, self.unknown1])
        return _fmt, _data


@dataclasses.dataclass
class ItemDamageType:
    damage_minimum: float
    damage_maximum: float
    school: SpellSchool

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ItemDamageType:
        # damage_minimum: f32
        damage_minimum = await read_float(reader)

        # damage_maximum: f32
        damage_maximum = await read_float(reader)

        # school: SpellSchool
        school = SpellSchool(await read_int(reader, 4))

        return ItemDamageType(
            damage_minimum=damage_minimum,
            damage_maximum=damage_maximum,
            school=school,
        )

    def write(self, _fmt, _data):
        _fmt += 'ffI'
        _data.extend([self.damage_minimum, self.damage_maximum, self.school.value])
        return _fmt, _data


@dataclasses.dataclass
class ItemSocket:
    color: int
    content: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ItemSocket:
        # color: u32
        color = await read_int(reader, 4)

        # content: u32
        content = await read_int(reader, 4)

        return ItemSocket(
            color=color,
            content=content,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.color, self.content])
        return _fmt, _data


@dataclasses.dataclass
class ItemSpells:
    spell: int
    spell_trigger: SpellTriggerType
    spell_charges: int
    spell_cooldown: int
    spell_category: int
    spell_category_cooldown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ItemSpells:
        # spell: Spell
        spell = await read_int(reader, 4)

        # spell_trigger: SpellTriggerType
        spell_trigger = SpellTriggerType(await read_int(reader, 4))

        # spell_charges: i32
        spell_charges = await read_int(reader, 4)

        # spell_cooldown: i32
        spell_cooldown = await read_int(reader, 4)

        # spell_category: u32
        spell_category = await read_int(reader, 4)

        # spell_category_cooldown: i32
        spell_category_cooldown = await read_int(reader, 4)

        return ItemSpells(
            spell=spell,
            spell_trigger=spell_trigger,
            spell_charges=spell_charges,
            spell_cooldown=spell_cooldown,
            spell_category=spell_category,
            spell_category_cooldown=spell_category_cooldown,
        )

    def write(self, _fmt, _data):
        _fmt += 'IIiiIi'
        _data.extend([self.spell, self.spell_trigger.value, self.spell_charges, self.spell_cooldown, self.spell_category, self.spell_category_cooldown])
        return _fmt, _data


@dataclasses.dataclass
class ItemStat:
    stat_type: int
    value: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ItemStat:
        # stat_type: u32
        stat_type = await read_int(reader, 4)

        # value: i32
        value = await read_int(reader, 4)

        return ItemStat(
            stat_type=stat_type,
            value=value,
        )

    def write(self, _fmt, _data):
        _fmt += 'Ii'
        _data.extend([self.stat_type, self.value])
        return _fmt, _data


@dataclasses.dataclass
class LfgData:
    entry: int
    lfg_type: LfgType

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> LfgData:
        # entry: u16
        entry = await read_int(reader, 2)

        # lfg_type: LfgType
        lfg_type = LfgType(await read_int(reader, 2))

        return LfgData(
            entry=entry,
            lfg_type=lfg_type,
        )

    def write(self, _fmt, _data):
        _fmt += 'HH'
        _data.extend([self.entry, self.lfg_type.value])
        return _fmt, _data


@dataclasses.dataclass
class LfgPlayerMember:
    guid: int
    level: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> LfgPlayerMember:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # level: Level32
        level = await read_int(reader, 4)

        return LfgPlayerMember(
            guid=guid,
            level=level,
        )

    def write(self, _fmt, _data):
        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # level: Level32
        _fmt += 'I'
        _data.append(self.level)

        return _fmt, _data

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class LfgPlayer:
    guid: int
    level: int
    area: Area
    lfg_mode: LfgMode
    lfg_slots: typing.List[int]
    comment: str
    members: typing.List[LfgPlayerMember]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> LfgPlayer:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # level: Level32
        level = await read_int(reader, 4)

        # area: Area
        area = Area(await read_int(reader, 4))

        # lfg_mode: LfgMode
        lfg_mode = LfgMode(await read_int(reader, 1))

        # lfg_slots: u32[3]
        lfg_slots = []
        for _ in range(0, 3):
            lfg_slots.append(await read_int(reader, 4))

        # comment: CString
        comment = await read_cstring(reader)

        # amount_of_members: u32
        amount_of_members = await read_int(reader, 4)

        # members: LfgPlayerMember[amount_of_members]
        members = []
        for _ in range(0, amount_of_members):
            members.append(await LfgPlayerMember.read(reader))

        return LfgPlayer(
            guid=guid,
            level=level,
            area=area,
            lfg_mode=lfg_mode,
            lfg_slots=lfg_slots,
            comment=comment,
            members=members,
        )

    def write(self, _fmt, _data):
        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # level: Level32
        _fmt += 'I'
        _data.append(self.level)

        # area: Area
        _fmt += 'I'
        _data.append(self.area.value)

        # lfg_mode: LfgMode
        _fmt += 'B'
        _data.append(self.lfg_mode.value)

        # lfg_slots: u32[3]
        _fmt += f'{len(self.lfg_slots)}I'
        _data.extend([*self.lfg_slots])

        # comment: CString
        _fmt += f'{len(self.comment)}sB'
        _data.extend([self.comment.encode('utf-8'), 0])

        # amount_of_members: u32
        _fmt += 'I'
        _data.append(len(self.members))

        # members: LfgPlayerMember[amount_of_members]
        for i in self.members:
            _fmt, _data = i.write(_fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        return 26 + packed_guid_size(self.guid) + len(self.comment) + sum([i.size() for i in self.members])


@dataclasses.dataclass
class ListInventoryItem:
    item_stack_count: int
    item: int
    item_display_id: int
    max_items: int
    price: int
    max_durability: int
    durability: int
    extended_cost: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ListInventoryItem:
        # item_stack_count: u32
        item_stack_count = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        # item_display_id: u32
        item_display_id = await read_int(reader, 4)

        # max_items: u32
        max_items = await read_int(reader, 4)

        # price: Gold
        price = await read_int(reader, 4)

        # max_durability: u32
        max_durability = await read_int(reader, 4)

        # durability: u32
        durability = await read_int(reader, 4)

        # extended_cost: u32
        extended_cost = await read_int(reader, 4)

        return ListInventoryItem(
            item_stack_count=item_stack_count,
            item=item,
            item_display_id=item_display_id,
            max_items=max_items,
            price=price,
            max_durability=max_durability,
            durability=durability,
            extended_cost=extended_cost,
        )

    def write(self, _fmt, _data):
        _fmt += 'IIIIIIII'
        _data.extend([self.item_stack_count, self.item, self.item_display_id, self.max_items, self.price, self.max_durability, self.durability, self.extended_cost])
        return _fmt, _data


@dataclasses.dataclass
class LootItem:
    index: int
    item: int
    ty: LootSlotType

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> LootItem:
        # index: u8
        index = await read_int(reader, 1)

        # item: Item
        item = await read_int(reader, 4)

        # ty: LootSlotType
        ty = LootSlotType(await read_int(reader, 1))

        return LootItem(
            index=index,
            item=item,
            ty=ty,
        )

    def write(self, _fmt, _data):
        _fmt += 'BIB'
        _data.extend([self.index, self.item, self.ty.value])
        return _fmt, _data


@dataclasses.dataclass
class MailListItemEnchant:
    charges: int
    duration: int
    enchant_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> MailListItemEnchant:
        # charges: u32
        charges = await read_int(reader, 4)

        # duration: u32
        duration = await read_int(reader, 4)

        # enchant_id: u32
        enchant_id = await read_int(reader, 4)

        return MailListItemEnchant(
            charges=charges,
            duration=duration,
            enchant_id=enchant_id,
        )

    def write(self, _fmt, _data):
        _fmt += 'III'
        _data.extend([self.charges, self.duration, self.enchant_id])
        return _fmt, _data


@dataclasses.dataclass
class MailListItem:
    item_index: int
    low_guid: int
    item: int
    enchants: typing.List[MailListItemEnchant]
    item_random_property_id: int
    item_suffix_factor: int
    item_amount: int
    charges: int
    max_durability: int
    durability: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> MailListItem:
        # item_index: u8
        item_index = await read_int(reader, 1)

        # low_guid: u32
        low_guid = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        # enchants: MailListItemEnchant[6]
        enchants = []
        for _ in range(0, 6):
            enchants.append(await MailListItemEnchant.read(reader))

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # item_suffix_factor: u32
        item_suffix_factor = await read_int(reader, 4)

        # item_amount: u8
        item_amount = await read_int(reader, 1)

        # charges: u32
        charges = await read_int(reader, 4)

        # max_durability: u32
        max_durability = await read_int(reader, 4)

        # durability: u32
        durability = await read_int(reader, 4)

        return MailListItem(
            item_index=item_index,
            low_guid=low_guid,
            item=item,
            enchants=enchants,
            item_random_property_id=item_random_property_id,
            item_suffix_factor=item_suffix_factor,
            item_amount=item_amount,
            charges=charges,
            max_durability=max_durability,
            durability=durability,
        )

    def write(self, _fmt, _data):
        _fmt += 'BII'
        _data.extend([self.item_index, self.low_guid, self.item])
        # enchants: MailListItemEnchant[6]
        for i in self.enchants:
            _fmt, _data = i.write(_fmt, _data)

        # item_random_property_id: u32
        _fmt += 'I'
        _data.append(self.item_random_property_id)

        # item_suffix_factor: u32
        _fmt += 'I'
        _data.append(self.item_suffix_factor)

        # item_amount: u8
        _fmt += 'B'
        _data.append(self.item_amount)

        # charges: u32
        _fmt += 'I'
        _data.append(self.charges)

        # max_durability: u32
        _fmt += 'I'
        _data.append(self.max_durability)

        # durability: u32
        _fmt += 'I'
        _data.append(self.durability)

        return _fmt, _data


@dataclasses.dataclass
class Mail:
    message_id: int
    message_type: MailType
    cash_on_delivery: int
    item_text_id: int
    unknown: int
    stationery: int
    money: int
    flags: int
    expiration_time: float
    mail_template_id: int
    subject: str
    items: typing.List[MailListItem]
    sender: typing.Optional[int] = None
    sender_id: typing.Optional[int] = None
    auction_id: typing.Optional[int] = None
    item: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Mail:
        sender = None
        sender_id = None
        auction_id = None
        item = None
        # size: u16
        _size = await read_int(reader, 2)

        # message_id: u32
        message_id = await read_int(reader, 4)

        # message_type: MailType
        message_type = MailType(await read_int(reader, 1))

        if message_type == MailType.NORMAL:
            # sender: Guid
            sender = await read_int(reader, 8)

        elif message_type in {MailType.CREATURE, MailType.GAMEOBJECT}:
            # sender_id: u32
            sender_id = await read_int(reader, 4)

        elif message_type == MailType.AUCTION:
            # auction_id: u32
            auction_id = await read_int(reader, 4)

        elif message_type == MailType.ITEM:
            # item: Item
            item = await read_int(reader, 4)

        # cash_on_delivery: Gold
        cash_on_delivery = await read_int(reader, 4)

        # item_text_id: u32
        item_text_id = await read_int(reader, 4)

        # unknown: u32
        unknown = await read_int(reader, 4)

        # stationery: u32
        stationery = await read_int(reader, 4)

        # money: Gold
        money = await read_int(reader, 4)

        # flags: u32
        flags = await read_int(reader, 4)

        # expiration_time: f32
        expiration_time = await read_float(reader)

        # mail_template_id: u32
        mail_template_id = await read_int(reader, 4)

        # subject: CString
        subject = await read_cstring(reader)

        # amount_of_items: u8
        amount_of_items = await read_int(reader, 1)

        # items: MailListItem[amount_of_items]
        items = []
        for _ in range(0, amount_of_items):
            items.append(await MailListItem.read(reader))

        return Mail(
            message_id=message_id,
            message_type=message_type,
            sender=sender,
            sender_id=sender_id,
            auction_id=auction_id,
            item=item,
            cash_on_delivery=cash_on_delivery,
            item_text_id=item_text_id,
            unknown=unknown,
            stationery=stationery,
            money=money,
            flags=flags,
            expiration_time=expiration_time,
            mail_template_id=mail_template_id,
            subject=subject,
            items=items,
        )

    def write(self, _fmt, _data):
        _fmt += 'HIB'
        _data.extend([self.size(), self.message_id, self.message_type.value])
        if self.message_type == MailType.NORMAL:
            _fmt += 'Q'
            _data.append(self.sender)
        elif self.message_type in {MailType.CREATURE, MailType.GAMEOBJECT}:
            _fmt += 'I'
            _data.append(self.sender_id)
        elif self.message_type == MailType.AUCTION:
            _fmt += 'I'
            _data.append(self.auction_id)
        elif self.message_type == MailType.ITEM:
            _fmt += 'I'
            _data.append(self.item)
        # cash_on_delivery: Gold
        _fmt += 'I'
        _data.append(self.cash_on_delivery)

        # item_text_id: u32
        _fmt += 'I'
        _data.append(self.item_text_id)

        # unknown: u32
        _fmt += 'I'
        _data.append(self.unknown)

        # stationery: u32
        _fmt += 'I'
        _data.append(self.stationery)

        # money: Gold
        _fmt += 'I'
        _data.append(self.money)

        # flags: u32
        _fmt += 'I'
        _data.append(self.flags)

        # expiration_time: f32
        _fmt += 'f'
        _data.append(self.expiration_time)

        # mail_template_id: u32
        _fmt += 'I'
        _data.append(self.mail_template_id)

        # subject: CString
        _fmt += f'{len(self.subject)}sB'
        _data.extend([self.subject.encode('utf-8'), 0])

        # amount_of_items: u8
        _fmt += 'B'
        _data.append(len(self.items))

        # items: MailListItem[amount_of_items]
        for i in self.items:
            _fmt, _data = i.write(_fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        _size = 41 + len(self.subject) + 102 * len(self.items)

        if self.message_type == MailType.NORMAL:
            _size += 8
        elif self.message_type in {MailType.CREATURE, MailType.GAMEOBJECT}:
            _size += 4
        elif self.message_type == MailType.AUCTION:
            _size += 4
        elif self.message_type == MailType.ITEM:
            _size += 4

        return _size


@dataclasses.dataclass
class MailItem:
    item: int
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> MailItem:
        # item: Guid
        item = await read_int(reader, 8)

        # slot: u8
        slot = await read_int(reader, 1)

        return MailItem(
            item=item,
            slot=slot,
        )

    def write(self, _fmt, _data):
        _fmt += 'QB'
        _data.extend([self.item, self.slot])
        return _fmt, _data


@dataclasses.dataclass
class MoneyLogItem:
    action: int
    player: int
    entry: int
    timestamp: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> MoneyLogItem:
        # action: u8
        action = await read_int(reader, 1)

        # player: Guid
        player = await read_int(reader, 8)

        # entry: u32
        entry = await read_int(reader, 4)

        # timestamp: u32
        timestamp = await read_int(reader, 4)

        return MoneyLogItem(
            action=action,
            player=player,
            entry=entry,
            timestamp=timestamp,
        )

    def write(self, _fmt, _data):
        _fmt += 'BQII'
        _data.extend([self.action, self.player, self.entry, self.timestamp])
        return _fmt, _data


@dataclasses.dataclass
class TransportInfo:
    guid: int
    position: Vector3d
    orientation: float
    timestamp: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> TransportInfo:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # position: Vector3d
        position = await Vector3d.read(reader)

        # orientation: f32
        orientation = await read_float(reader)

        # timestamp: u32
        timestamp = await read_int(reader, 4)

        return TransportInfo(
            guid=guid,
            position=position,
            orientation=orientation,
            timestamp=timestamp,
        )

    def write(self, _fmt, _data):
        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # orientation: f32
        _fmt += 'f'
        _data.append(self.orientation)

        # timestamp: u32
        _fmt += 'I'
        _data.append(self.timestamp)

        return _fmt, _data

    def size(self) -> int:
        return 20 + packed_guid_size(self.guid)


@dataclasses.dataclass
class MovementBlock:
    update_flag: UpdateFlag
    flags: typing.Optional[MovementFlags] = None
    extra_flags: typing.Optional[int] = None
    timestamp: typing.Optional[int] = None
    living_position: typing.Optional[Vector3d] = None
    living_orientation: typing.Optional[float] = None
    transport: typing.Optional[TransportInfo] = None
    pitch1: typing.Optional[float] = None
    pitch2: typing.Optional[float] = None
    fall_time: typing.Optional[float] = None
    z_speed: typing.Optional[float] = None
    cos_angle: typing.Optional[float] = None
    sin_angle: typing.Optional[float] = None
    xy_speed: typing.Optional[float] = None
    spline_elevation: typing.Optional[float] = None
    walking_speed: typing.Optional[float] = None
    running_speed: typing.Optional[float] = None
    backwards_running_speed: typing.Optional[float] = None
    swimming_speed: typing.Optional[float] = None
    flying_speed: typing.Optional[float] = None
    backwards_flying_speed: typing.Optional[float] = None
    backwards_swimming_speed: typing.Optional[float] = None
    turn_rate: typing.Optional[float] = None
    spline_flags: typing.Optional[SplineFlag] = None
    angle: typing.Optional[float] = None
    target: typing.Optional[int] = None
    spline_final_point: typing.Optional[Vector3d] = None
    time_passed: typing.Optional[int] = None
    duration: typing.Optional[int] = None
    id: typing.Optional[int] = None
    nodes: typing.Optional[typing.List[Vector3d]] = None
    final_node: typing.Optional[Vector3d] = None
    position: typing.Optional[Vector3d] = None
    orientation: typing.Optional[float] = None
    unknown0: typing.Optional[int] = None
    unknown1: typing.Optional[int] = None
    unknown2: typing.Optional[int] = None
    guid: typing.Optional[int] = None
    transport_progress_in_ms: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> MovementBlock:
        flags = None
        extra_flags = None
        timestamp = None
        living_position = None
        living_orientation = None
        transport = None
        pitch1 = None
        pitch2 = None
        fall_time = None
        z_speed = None
        cos_angle = None
        sin_angle = None
        xy_speed = None
        spline_elevation = None
        walking_speed = None
        running_speed = None
        backwards_running_speed = None
        swimming_speed = None
        flying_speed = None
        backwards_flying_speed = None
        backwards_swimming_speed = None
        turn_rate = None
        spline_flags = None
        angle = None
        target = None
        spline_final_point = None
        time_passed = None
        duration = None
        id = None
        amount_of_nodes = None
        nodes = None
        final_node = None
        position = None
        orientation = None
        unknown0 = None
        unknown1 = None
        unknown2 = None
        guid = None
        transport_progress_in_ms = None
        # update_flag: UpdateFlag
        update_flag = UpdateFlag(await read_int(reader, 1))

        if UpdateFlag.LIVING in update_flag:
            # flags: MovementFlags
            flags = MovementFlags(await read_int(reader, 4))

            # extra_flags: u8
            extra_flags = await read_int(reader, 1)

            # timestamp: u32
            timestamp = await read_int(reader, 4)

            # living_position: Vector3d
            living_position = await Vector3d.read(reader)

            # living_orientation: f32
            living_orientation = await read_float(reader)

            if MovementFlags.ON_TRANSPORT in flags:
                # transport: TransportInfo
                transport = await TransportInfo.read(reader)

            if MovementFlags.SWIMMING in flags:
                # pitch1: f32
                pitch1 = await read_float(reader)

            elif MovementFlags.ONTRANSPORT in flags:
                # pitch2: f32
                pitch2 = await read_float(reader)

            # fall_time: f32
            fall_time = await read_float(reader)

            if MovementFlags.JUMPING in flags:
                # z_speed: f32
                z_speed = await read_float(reader)

                # cos_angle: f32
                cos_angle = await read_float(reader)

                # sin_angle: f32
                sin_angle = await read_float(reader)

                # xy_speed: f32
                xy_speed = await read_float(reader)

            if MovementFlags.SPLINE_ELEVATION in flags:
                # spline_elevation: f32
                spline_elevation = await read_float(reader)

            # walking_speed: f32
            walking_speed = await read_float(reader)

            # running_speed: f32
            running_speed = await read_float(reader)

            # backwards_running_speed: f32
            backwards_running_speed = await read_float(reader)

            # swimming_speed: f32
            swimming_speed = await read_float(reader)

            # flying_speed: f32
            flying_speed = await read_float(reader)

            # backwards_flying_speed: f32
            backwards_flying_speed = await read_float(reader)

            # backwards_swimming_speed: f32
            backwards_swimming_speed = await read_float(reader)

            # turn_rate: f32
            turn_rate = await read_float(reader)

            if MovementFlags.SPLINE_ENABLED in flags:
                # spline_flags: SplineFlag
                spline_flags = SplineFlag(await read_int(reader, 4))

                if SplineFlag.FINAL_ANGLE in spline_flags:
                    # angle: f32
                    angle = await read_float(reader)

                elif SplineFlag.FINAL_TARGET in spline_flags:
                    # target: Guid
                    target = await read_int(reader, 8)

                elif SplineFlag.FINAL_POINT in spline_flags:
                    # spline_final_point: Vector3d
                    spline_final_point = await Vector3d.read(reader)

                # time_passed: u32
                time_passed = await read_int(reader, 4)

                # duration: u32
                duration = await read_int(reader, 4)

                # id: u32
                id = await read_int(reader, 4)

                # amount_of_nodes: u32
                amount_of_nodes = await read_int(reader, 4)

                # nodes: Vector3d[amount_of_nodes]
                nodes = []
                for _ in range(0, amount_of_nodes):
                    nodes.append(await Vector3d.read(reader))

                # final_node: Vector3d
                final_node = await Vector3d.read(reader)

        elif UpdateFlag.HAS_POSITION in update_flag:
            # position: Vector3d
            position = await Vector3d.read(reader)

            # orientation: f32
            orientation = await read_float(reader)

        if UpdateFlag.HIGH_GUID in update_flag:
            # unknown0: u32
            unknown0 = await read_int(reader, 4)

            # unknown1: u32
            unknown1 = await read_int(reader, 4)

        if UpdateFlag.ALL in update_flag:
            # unknown2: u32
            unknown2 = await read_int(reader, 4)

        if UpdateFlag.MELEE_ATTACKING in update_flag:
            # guid: PackedGuid
            guid = await read_packed_guid(reader)

        if UpdateFlag.TRANSPORT in update_flag:
            # transport_progress_in_ms: u32
            transport_progress_in_ms = await read_int(reader, 4)

        return MovementBlock(
            update_flag=update_flag,
            flags=flags,
            extra_flags=extra_flags,
            timestamp=timestamp,
            living_position=living_position,
            living_orientation=living_orientation,
            transport=transport,
            pitch1=pitch1,
            pitch2=pitch2,
            fall_time=fall_time,
            z_speed=z_speed,
            cos_angle=cos_angle,
            sin_angle=sin_angle,
            xy_speed=xy_speed,
            spline_elevation=spline_elevation,
            walking_speed=walking_speed,
            running_speed=running_speed,
            backwards_running_speed=backwards_running_speed,
            swimming_speed=swimming_speed,
            flying_speed=flying_speed,
            backwards_flying_speed=backwards_flying_speed,
            backwards_swimming_speed=backwards_swimming_speed,
            turn_rate=turn_rate,
            spline_flags=spline_flags,
            angle=angle,
            target=target,
            spline_final_point=spline_final_point,
            time_passed=time_passed,
            duration=duration,
            id=id,
            nodes=nodes,
            final_node=final_node,
            position=position,
            orientation=orientation,
            unknown0=unknown0,
            unknown1=unknown1,
            unknown2=unknown2,
            guid=guid,
            transport_progress_in_ms=transport_progress_in_ms,
        )

    def write(self, _fmt, _data):
        _fmt += 'B'
        _data.append(self.update_flag.value)
        if UpdateFlag.LIVING in self.update_flag:
            _fmt += 'IBI'
            _data.extend([self.flags.value, self.extra_flags, self.timestamp])
            # living_position: Vector3d
            _fmt, _data = self.living_position.write(_fmt, _data)

            # living_orientation: f32
            _fmt += 'f'
            _data.append(self.living_orientation)

            if MovementFlags.ON_TRANSPORT in self.flags:
                # transport: TransportInfo
                _fmt, _data = self.transport.write(_fmt, _data)

            if MovementFlags.SWIMMING in self.flags:
                _fmt += 'f'
                _data.append(self.pitch1)
            elif MovementFlags.ONTRANSPORT in self.flags:
                _fmt += 'f'
                _data.append(self.pitch2)
            # fall_time: f32
            _fmt += 'f'
            _data.append(self.fall_time)

            if MovementFlags.JUMPING in self.flags:
                _fmt += 'ffff'
                _data.extend([self.z_speed, self.cos_angle, self.sin_angle, self.xy_speed])
            if MovementFlags.SPLINE_ELEVATION in self.flags:
                _fmt += 'f'
                _data.append(self.spline_elevation)
            # walking_speed: f32
            _fmt += 'f'
            _data.append(self.walking_speed)

            # running_speed: f32
            _fmt += 'f'
            _data.append(self.running_speed)

            # backwards_running_speed: f32
            _fmt += 'f'
            _data.append(self.backwards_running_speed)

            # swimming_speed: f32
            _fmt += 'f'
            _data.append(self.swimming_speed)

            # flying_speed: f32
            _fmt += 'f'
            _data.append(self.flying_speed)

            # backwards_flying_speed: f32
            _fmt += 'f'
            _data.append(self.backwards_flying_speed)

            # backwards_swimming_speed: f32
            _fmt += 'f'
            _data.append(self.backwards_swimming_speed)

            # turn_rate: f32
            _fmt += 'f'
            _data.append(self.turn_rate)

            if MovementFlags.SPLINE_ENABLED in self.flags:
                _fmt += 'I'
                _data.append(self.spline_flags.value)
                if SplineFlag.FINAL_ANGLE in self.spline_flags:
                    _fmt += 'f'
                    _data.append(self.angle)
                elif SplineFlag.FINAL_TARGET in self.spline_flags:
                    _fmt += 'Q'
                    _data.append(self.target)
                elif SplineFlag.FINAL_POINT in self.spline_flags:
                    # spline_final_point: Vector3d
                    _fmt, _data = self.spline_final_point.write(_fmt, _data)

                # time_passed: u32
                _fmt += 'I'
                _data.append(self.time_passed)

                # duration: u32
                _fmt += 'I'
                _data.append(self.duration)

                # id: u32
                _fmt += 'I'
                _data.append(self.id)

                # amount_of_nodes: u32
                _fmt += 'I'
                _data.append(len(self.nodes))

                # nodes: Vector3d[amount_of_nodes]
                for i in self.nodes:
                    _fmt, _data = i.write(_fmt, _data)

                # final_node: Vector3d
                _fmt, _data = self.final_node.write(_fmt, _data)

        elif UpdateFlag.HAS_POSITION in self.update_flag:
            # position: Vector3d
            _fmt, _data = self.position.write(_fmt, _data)

            # orientation: f32
            _fmt += 'f'
            _data.append(self.orientation)

        if UpdateFlag.HIGH_GUID in self.update_flag:
            _fmt += 'II'
            _data.extend([self.unknown0, self.unknown1])
        if UpdateFlag.ALL in self.update_flag:
            _fmt += 'I'
            _data.append(self.unknown2)
        if UpdateFlag.MELEE_ATTACKING in self.update_flag:
            # guid: PackedGuid
            _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        if UpdateFlag.TRANSPORT in self.update_flag:
            _fmt += 'I'
            _data.append(self.transport_progress_in_ms)
        return _fmt, _data

    def size(self) -> int:
        _size = 1

        if UpdateFlag.LIVING in self.update_flag:
            _size += 61

            if MovementFlags.ON_TRANSPORT in self.flags:
                _size += 0 + self.transport.size()

            if MovementFlags.SWIMMING in self.flags:
                _size += 4
            elif MovementFlags.ONTRANSPORT in self.flags:
                _size += 4

            if MovementFlags.JUMPING in self.flags:
                _size += 16

            if MovementFlags.SPLINE_ELEVATION in self.flags:
                _size += 4

            if MovementFlags.SPLINE_ENABLED in self.flags:
                _size += 32 + 12 * len(self.nodes)

                if SplineFlag.FINAL_ANGLE in self.spline_flags:
                    _size += 4
                elif SplineFlag.FINAL_TARGET in self.spline_flags:
                    _size += 8
                elif SplineFlag.FINAL_POINT in self.spline_flags:
                    _size += 12


        elif UpdateFlag.HAS_POSITION in self.update_flag:
            _size += 16

        if UpdateFlag.HIGH_GUID in self.update_flag:
            _size += 8

        if UpdateFlag.ALL in self.update_flag:
            _size += 4

        if UpdateFlag.MELEE_ATTACKING in self.update_flag:
            _size += 0 + packed_guid_size(self.guid)

        if UpdateFlag.TRANSPORT in self.update_flag:
            _size += 4

        return _size


@dataclasses.dataclass
class MovementInfo:
    flags: MovementFlags
    extra_flags: int
    timestamp: int
    position: Vector3d
    orientation: float
    fall_time: float
    transport: typing.Optional[TransportInfo] = None
    pitch1: typing.Optional[float] = None
    pitch2: typing.Optional[float] = None
    z_speed: typing.Optional[float] = None
    cos_angle: typing.Optional[float] = None
    sin_angle: typing.Optional[float] = None
    xy_speed: typing.Optional[float] = None
    spline_elevation: typing.Optional[float] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> MovementInfo:
        transport = None
        pitch1 = None
        pitch2 = None
        z_speed = None
        cos_angle = None
        sin_angle = None
        xy_speed = None
        spline_elevation = None
        # flags: MovementFlags
        flags = MovementFlags(await read_int(reader, 4))

        # extra_flags: u8
        extra_flags = await read_int(reader, 1)

        # timestamp: u32
        timestamp = await read_int(reader, 4)

        # position: Vector3d
        position = await Vector3d.read(reader)

        # orientation: f32
        orientation = await read_float(reader)

        if MovementFlags.ON_TRANSPORT in flags:
            # transport: TransportInfo
            transport = await TransportInfo.read(reader)

        if MovementFlags.SWIMMING in flags:
            # pitch1: f32
            pitch1 = await read_float(reader)

        elif MovementFlags.ONTRANSPORT in flags:
            # pitch2: f32
            pitch2 = await read_float(reader)

        # fall_time: f32
        fall_time = await read_float(reader)

        if MovementFlags.JUMPING in flags:
            # z_speed: f32
            z_speed = await read_float(reader)

            # cos_angle: f32
            cos_angle = await read_float(reader)

            # sin_angle: f32
            sin_angle = await read_float(reader)

            # xy_speed: f32
            xy_speed = await read_float(reader)

        if MovementFlags.SPLINE_ELEVATION in flags:
            # spline_elevation: f32
            spline_elevation = await read_float(reader)

        return MovementInfo(
            flags=flags,
            extra_flags=extra_flags,
            timestamp=timestamp,
            position=position,
            orientation=orientation,
            transport=transport,
            pitch1=pitch1,
            pitch2=pitch2,
            fall_time=fall_time,
            z_speed=z_speed,
            cos_angle=cos_angle,
            sin_angle=sin_angle,
            xy_speed=xy_speed,
            spline_elevation=spline_elevation,
        )

    def write(self, _fmt, _data):
        _fmt += 'IBI'
        _data.extend([self.flags.value, self.extra_flags, self.timestamp])
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # orientation: f32
        _fmt += 'f'
        _data.append(self.orientation)

        if MovementFlags.ON_TRANSPORT in self.flags:
            # transport: TransportInfo
            _fmt, _data = self.transport.write(_fmt, _data)

        if MovementFlags.SWIMMING in self.flags:
            _fmt += 'f'
            _data.append(self.pitch1)
        elif MovementFlags.ONTRANSPORT in self.flags:
            _fmt += 'f'
            _data.append(self.pitch2)
        # fall_time: f32
        _fmt += 'f'
        _data.append(self.fall_time)

        if MovementFlags.JUMPING in self.flags:
            _fmt += 'ffff'
            _data.extend([self.z_speed, self.cos_angle, self.sin_angle, self.xy_speed])
        if MovementFlags.SPLINE_ELEVATION in self.flags:
            _fmt += 'f'
            _data.append(self.spline_elevation)
        return _fmt, _data

    def size(self) -> int:
        _size = 29

        if MovementFlags.ON_TRANSPORT in self.flags:
            _size += 0 + self.transport.size()

        if MovementFlags.SWIMMING in self.flags:
            _size += 4
        elif MovementFlags.ONTRANSPORT in self.flags:
            _size += 4

        if MovementFlags.JUMPING in self.flags:
            _size += 16

        if MovementFlags.SPLINE_ELEVATION in self.flags:
            _size += 4

        return _size


@dataclasses.dataclass
class NpcTextUpdateEmote:
    delay: int
    emote: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> NpcTextUpdateEmote:
        # delay: u32
        delay = await read_int(reader, 4)

        # emote: u32
        emote = await read_int(reader, 4)

        return NpcTextUpdateEmote(
            delay=delay,
            emote=emote,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.delay, self.emote])
        return _fmt, _data


@dataclasses.dataclass
class NpcTextUpdate:
    probability: float
    texts: typing.List[str]
    language: Language
    emotes: typing.List[NpcTextUpdateEmote]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> NpcTextUpdate:
        # probability: f32
        probability = await read_float(reader)

        # texts: CString[2]
        texts = []
        for _ in range(0, 2):
            texts.append(await read_cstring(reader))

        # language: Language
        language = Language(await read_int(reader, 1))

        # emotes: NpcTextUpdateEmote[3]
        emotes = []
        for _ in range(0, 3):
            emotes.append(await NpcTextUpdateEmote.read(reader))

        return NpcTextUpdate(
            probability=probability,
            texts=texts,
            language=language,
            emotes=emotes,
        )

    def write(self, _fmt, _data):
        _fmt += 'f'
        _data.append(self.probability)
        # texts: CString[2]
        for i in self.texts:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        # language: Language
        _fmt += 'B'
        _data.append(self.language.value)

        # emotes: NpcTextUpdateEmote[3]
        for i in self.emotes:
            _fmt, _data = i.write(_fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        return 29 + sum([len(i) + 1 for i in self.texts])


@dataclasses.dataclass
class Object:
    update_type: UpdateType
    guid1: typing.Optional[int] = None
    mask1: typing.Optional[UpdateMask] = None
    guid2: typing.Optional[int] = None
    movement1: typing.Optional[MovementBlock] = None
    guid3: typing.Optional[int] = None
    object_type: typing.Optional[ObjectType] = None
    movement2: typing.Optional[MovementBlock] = None
    mask2: typing.Optional[UpdateMask] = None
    guids: typing.Optional[typing.List[int]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Object:
        guid1 = None
        mask1 = None
        guid2 = None
        movement1 = None
        guid3 = None
        object_type = None
        movement2 = None
        mask2 = None
        count = None
        guids = None
        # update_type: UpdateType
        update_type = UpdateType(await read_int(reader, 1))

        if update_type == UpdateType.VALUES:
            # guid1: PackedGuid
            guid1 = await read_packed_guid(reader)

            # mask1: UpdateMask
            mask1 = await UpdateMask.read(reader)

        elif update_type == UpdateType.MOVEMENT:
            # guid2: PackedGuid
            guid2 = await read_packed_guid(reader)

            # movement1: MovementBlock
            movement1 = await MovementBlock.read(reader)

        elif update_type in {UpdateType.CREATE_OBJECT, UpdateType.CREATE_OBJECT2}:
            # guid3: PackedGuid
            guid3 = await read_packed_guid(reader)

            # object_type: ObjectType
            object_type = ObjectType(await read_int(reader, 1))

            # movement2: MovementBlock
            movement2 = await MovementBlock.read(reader)

            # mask2: UpdateMask
            mask2 = await UpdateMask.read(reader)

        elif update_type in {UpdateType.OUT_OF_RANGE_OBJECTS, UpdateType.NEAR_OBJECTS}:
            # count: u32
            count = await read_int(reader, 4)

            # guids: PackedGuid[count]
            guids = []
            for _ in range(0, count):
                guids.append(await read_packed_guid(reader))

        return Object(
            update_type=update_type,
            guid1=guid1,
            mask1=mask1,
            guid2=guid2,
            movement1=movement1,
            guid3=guid3,
            object_type=object_type,
            movement2=movement2,
            mask2=mask2,
            guids=guids,
        )

    def write(self, _fmt, _data):
        _fmt += 'B'
        _data.append(self.update_type.value)
        if self.update_type == UpdateType.VALUES:
            # guid1: PackedGuid
            _fmt, _data = packed_guid_write(self.guid1, _fmt, _data)

            # mask1: UpdateMask
            _fmt, _data = self.mask1.write(_fmt, _data)

        elif self.update_type == UpdateType.MOVEMENT:
            # guid2: PackedGuid
            _fmt, _data = packed_guid_write(self.guid2, _fmt, _data)

            # movement1: MovementBlock
            _fmt, _data = self.movement1.write(_fmt, _data)

        elif self.update_type in {UpdateType.CREATE_OBJECT, UpdateType.CREATE_OBJECT2}:
            # guid3: PackedGuid
            _fmt, _data = packed_guid_write(self.guid3, _fmt, _data)

            # object_type: ObjectType
            _fmt += 'B'
            _data.append(self.object_type.value)

            # movement2: MovementBlock
            _fmt, _data = self.movement2.write(_fmt, _data)

            # mask2: UpdateMask
            _fmt, _data = self.mask2.write(_fmt, _data)

        elif self.update_type in {UpdateType.OUT_OF_RANGE_OBJECTS, UpdateType.NEAR_OBJECTS}:
            _fmt += 'I'
            _data.append(len(self.guids))
            # guids: PackedGuid[count]
            for i in self.guids:
                _fmt, _data = packed_guid_write(i, _fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        _size = 1

        if self.update_type == UpdateType.VALUES:
            _size += 0 + packed_guid_size(self.guid1) + self.mask1.size()
        elif self.update_type == UpdateType.MOVEMENT:
            _size += 0 + packed_guid_size(self.guid2) + self.movement1.size()
        elif self.update_type in {UpdateType.CREATE_OBJECT, UpdateType.CREATE_OBJECT2}:
            _size += 1 + packed_guid_size(self.guid3) + self.movement2.size() + self.mask2.size()
        elif self.update_type in {UpdateType.OUT_OF_RANGE_OBJECTS, UpdateType.NEAR_OBJECTS}:
            _size += 4 + sum([packed_guid_size(i) for i in self.guids])

        return _size


@dataclasses.dataclass
class PetSpellCooldown:
    spell: int
    spell_category: int
    cooldown: int
    category_cooldown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> PetSpellCooldown:
        # spell: Spell16
        spell = await read_int(reader, 2)

        # spell_category: u16
        spell_category = await read_int(reader, 2)

        # cooldown: Milliseconds
        cooldown = await read_int(reader, 4)

        # category_cooldown: Milliseconds
        category_cooldown = await read_int(reader, 4)

        return PetSpellCooldown(
            spell=spell,
            spell_category=spell_category,
            cooldown=cooldown,
            category_cooldown=category_cooldown,
        )

    def write(self, _fmt, _data):
        _fmt += 'HHII'
        _data.extend([self.spell, self.spell_category, self.cooldown, self.category_cooldown])
        return _fmt, _data


@dataclasses.dataclass
class PetitionShowlist:
    index: int
    charter_entry: int
    charter_display_id: int
    guild_charter_cost: int
    unknown1: int
    signatures_required: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> PetitionShowlist:
        # index: u32
        index = await read_int(reader, 4)

        # charter_entry: u32
        charter_entry = await read_int(reader, 4)

        # charter_display_id: u32
        charter_display_id = await read_int(reader, 4)

        # guild_charter_cost: u32
        guild_charter_cost = await read_int(reader, 4)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # signatures_required: u32
        signatures_required = await read_int(reader, 4)

        return PetitionShowlist(
            index=index,
            charter_entry=charter_entry,
            charter_display_id=charter_display_id,
            guild_charter_cost=guild_charter_cost,
            unknown1=unknown1,
            signatures_required=signatures_required,
        )

    def write(self, _fmt, _data):
        _fmt += 'IIIIII'
        _data.extend([self.index, self.charter_entry, self.charter_display_id, self.guild_charter_cost, self.unknown1, self.signatures_required])
        return _fmt, _data


@dataclasses.dataclass
class PetitionSignature:
    signer: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> PetitionSignature:
        # signer: Guid
        signer = await read_int(reader, 8)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return PetitionSignature(
            signer=signer,
            unknown1=unknown1,
        )

    def write(self, _fmt, _data):
        _fmt += 'QI'
        _data.extend([self.signer, self.unknown1])
        return _fmt, _data


@dataclasses.dataclass
class QuestDetailsEmote:
    emote: int
    emote_delay: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> QuestDetailsEmote:
        # emote: u32
        emote = await read_int(reader, 4)

        # emote_delay: Milliseconds
        emote_delay = await read_int(reader, 4)

        return QuestDetailsEmote(
            emote=emote,
            emote_delay=emote_delay,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.emote, self.emote_delay])
        return _fmt, _data


@dataclasses.dataclass
class QuestGiverStatusReport:
    npc: int
    dialog_status: QuestGiverStatus

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> QuestGiverStatusReport:
        # npc: Guid
        npc = await read_int(reader, 8)

        # dialog_status: QuestGiverStatus
        dialog_status = QuestGiverStatus(await read_int(reader, 1))

        return QuestGiverStatusReport(
            npc=npc,
            dialog_status=dialog_status,
        )

    def write(self, _fmt, _data):
        _fmt += 'QB'
        _data.extend([self.npc, self.dialog_status.value])
        return _fmt, _data


@dataclasses.dataclass
class QuestItem:
    quest_id: int
    quest_icon: int
    level: int
    title: str

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> QuestItem:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # quest_icon: u32
        quest_icon = await read_int(reader, 4)

        # level: Level32
        level = await read_int(reader, 4)

        # title: CString
        title = await read_cstring(reader)

        return QuestItem(
            quest_id=quest_id,
            quest_icon=quest_icon,
            level=level,
            title=title,
        )

    def write(self, _fmt, _data):
        _fmt += f'III{len(self.title)}sB'
        _data.extend([self.quest_id, self.quest_icon, self.level, self.title.encode('utf-8'), 0])
        return _fmt, _data

    def size(self) -> int:
        return 13 + len(self.title)


@dataclasses.dataclass
class QuestItemRequirement:
    item: int
    item_count: int
    item_display_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> QuestItemRequirement:
        # item: Item
        item = await read_int(reader, 4)

        # item_count: u32
        item_count = await read_int(reader, 4)

        # item_display_id: u32
        item_display_id = await read_int(reader, 4)

        return QuestItemRequirement(
            item=item,
            item_count=item_count,
            item_display_id=item_display_id,
        )

    def write(self, _fmt, _data):
        _fmt += 'III'
        _data.extend([self.item, self.item_count, self.item_display_id])
        return _fmt, _data


@dataclasses.dataclass
class QuestItemReward:
    item: int
    item_count: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> QuestItemReward:
        # item: Item
        item = await read_int(reader, 4)

        # item_count: u32
        item_count = await read_int(reader, 4)

        return QuestItemReward(
            item=item,
            item_count=item_count,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.item, self.item_count])
        return _fmt, _data


@dataclasses.dataclass
class QuestObjective:
    creature_id: int
    kill_count: int
    required_item_id: int
    required_item_count: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> QuestObjective:
        # creature_id: u32
        creature_id = await read_int(reader, 4)

        # kill_count: u32
        kill_count = await read_int(reader, 4)

        # required_item_id: u32
        required_item_id = await read_int(reader, 4)

        # required_item_count: u32
        required_item_count = await read_int(reader, 4)

        return QuestObjective(
            creature_id=creature_id,
            kill_count=kill_count,
            required_item_id=required_item_id,
            required_item_count=required_item_count,
        )

    def write(self, _fmt, _data):
        _fmt += 'IIII'
        _data.extend([self.creature_id, self.kill_count, self.required_item_id, self.required_item_count])
        return _fmt, _data


@dataclasses.dataclass
class RaidInfo:
    map: Map
    reset_time: int
    instance_id: int
    index: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> RaidInfo:
        # map: Map
        map = Map(await read_int(reader, 4))

        # reset_time: u32
        reset_time = await read_int(reader, 4)

        # instance_id: u32
        instance_id = await read_int(reader, 4)

        # index: u32
        index = await read_int(reader, 4)

        return RaidInfo(
            map=map,
            reset_time=reset_time,
            instance_id=instance_id,
            index=index,
        )

    def write(self, _fmt, _data):
        _fmt += 'IIII'
        _data.extend([self.map.value, self.reset_time, self.instance_id, self.index])
        return _fmt, _data


@dataclasses.dataclass
class RaidTargetUpdate:
    index: RaidTargetIndex
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> RaidTargetUpdate:
        # index: RaidTargetIndex
        index = RaidTargetIndex(await read_int(reader, 1))

        # guid: Guid
        guid = await read_int(reader, 8)

        return RaidTargetUpdate(
            index=index,
            guid=guid,
        )

    def write(self, _fmt, _data):
        _fmt += 'BQ'
        _data.extend([self.index.value, self.guid])
        return _fmt, _data


@dataclasses.dataclass
class ReceivedMail:
    sender: int
    auction_house: AuctionHouse
    message_type: MailMessageType
    stationery: int
    time: float

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ReceivedMail:
        # sender: Guid
        sender = await read_int(reader, 8)

        # auction_house: AuctionHouse
        auction_house = AuctionHouse(await read_int(reader, 4))

        # message_type: MailMessageType
        message_type = MailMessageType(await read_int(reader, 4))

        # stationery: u32
        stationery = await read_int(reader, 4)

        # time: f32
        time = await read_float(reader)

        return ReceivedMail(
            sender=sender,
            auction_house=auction_house,
            message_type=message_type,
            stationery=stationery,
            time=time,
        )

    def write(self, _fmt, _data):
        _fmt += 'QIIIf'
        _data.extend([self.sender, self.auction_house.value, self.message_type.value, self.stationery, self.time])
        return _fmt, _data


@dataclasses.dataclass
class Relation:
    guid: int
    relation_mask: RelationType
    note: str
    status: typing.Optional[FriendStatus] = None
    area: typing.Optional[Area] = None
    level: typing.Optional[int] = None
    class_type: typing.Optional[Class] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Relation:
        status = None
        area = None
        level = None
        class_type = None
        # guid: Guid
        guid = await read_int(reader, 8)

        # relation_mask: RelationType
        relation_mask = RelationType(await read_int(reader, 4))

        # note: CString
        note = await read_cstring(reader)

        if RelationType.FRIEND in relation_mask:
            # status: FriendStatus
            status = FriendStatus(await read_int(reader, 1))

            if status == FriendStatus.ONLINE:
                # area: Area
                area = Area(await read_int(reader, 4))

                # level: Level32
                level = await read_int(reader, 4)

                # class_type: Class
                class_type = Class(await read_int(reader, 4))

        return Relation(
            guid=guid,
            relation_mask=relation_mask,
            note=note,
            status=status,
            area=area,
            level=level,
            class_type=class_type,
        )

    def write(self, _fmt, _data):
        _fmt += f'QI{len(self.note)}sB'
        _data.extend([self.guid, self.relation_mask.value, self.note.encode('utf-8'), 0])
        if RelationType.FRIEND in self.relation_mask:
            _fmt += 'B'
            _data.append(self.status.value)
            if self.status == FriendStatus.ONLINE:
                _fmt += 'III'
                _data.extend([self.area.value, self.level, self.class_type.value])
        return _fmt, _data

    def size(self) -> int:
        _size = 13 + len(self.note)

        if RelationType.FRIEND in self.relation_mask:
            _size += 1

            if self.status == FriendStatus.ONLINE:
                _size += 12


        return _size


@dataclasses.dataclass
class SpellCastTargets:
    target_flags: SpellCastTargetFlags
    unit_target: typing.Optional[int] = None
    unit_minipet: typing.Optional[int] = None
    unit_enemy: typing.Optional[int] = None
    gameobject: typing.Optional[int] = None
    locked: typing.Optional[int] = None
    item: typing.Optional[int] = None
    trade_item: typing.Optional[int] = None
    source: typing.Optional[Vector3d] = None
    destination: typing.Optional[Vector3d] = None
    target_string: typing.Optional[str] = None
    corpse_ally: typing.Optional[int] = None
    corpse_enemy: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SpellCastTargets:
        unit_target = None
        unit_minipet = None
        unit_enemy = None
        gameobject = None
        locked = None
        item = None
        trade_item = None
        source = None
        destination = None
        target_string = None
        corpse_ally = None
        corpse_enemy = None
        # target_flags: SpellCastTargetFlags
        target_flags = SpellCastTargetFlags(await read_int(reader, 4))

        if SpellCastTargetFlags.UNIT in target_flags:
            # unit_target: PackedGuid
            unit_target = await read_packed_guid(reader)

        elif SpellCastTargetFlags.UNIT_MINIPET in target_flags:
            # unit_minipet: PackedGuid
            unit_minipet = await read_packed_guid(reader)

        elif SpellCastTargetFlags.UNIT_ENEMY in target_flags:
            # unit_enemy: PackedGuid
            unit_enemy = await read_packed_guid(reader)

        if SpellCastTargetFlags.GAMEOBJECT in target_flags:
            # gameobject: PackedGuid
            gameobject = await read_packed_guid(reader)

        elif SpellCastTargetFlags.LOCKED in target_flags:
            # locked: PackedGuid
            locked = await read_packed_guid(reader)

        if SpellCastTargetFlags.ITEM in target_flags:
            # item: PackedGuid
            item = await read_packed_guid(reader)

        elif SpellCastTargetFlags.TRADE_ITEM in target_flags:
            # trade_item: PackedGuid
            trade_item = await read_packed_guid(reader)

        if SpellCastTargetFlags.SOURCE_LOCATION in target_flags:
            # source: Vector3d
            source = await Vector3d.read(reader)

        if SpellCastTargetFlags.DEST_LOCATION in target_flags:
            # destination: Vector3d
            destination = await Vector3d.read(reader)

        if SpellCastTargetFlags.STRING in target_flags:
            # target_string: CString
            target_string = await read_cstring(reader)

        if SpellCastTargetFlags.CORPSE_ALLY in target_flags:
            # corpse_ally: PackedGuid
            corpse_ally = await read_packed_guid(reader)

        elif SpellCastTargetFlags.CORPSE_ENEMY in target_flags:
            # corpse_enemy: PackedGuid
            corpse_enemy = await read_packed_guid(reader)

        return SpellCastTargets(
            target_flags=target_flags,
            unit_target=unit_target,
            unit_minipet=unit_minipet,
            unit_enemy=unit_enemy,
            gameobject=gameobject,
            locked=locked,
            item=item,
            trade_item=trade_item,
            source=source,
            destination=destination,
            target_string=target_string,
            corpse_ally=corpse_ally,
            corpse_enemy=corpse_enemy,
        )

    def write(self, _fmt, _data):
        _fmt += 'I'
        _data.append(self.target_flags.value)
        if SpellCastTargetFlags.UNIT in self.target_flags:
            # unit_target: PackedGuid
            _fmt, _data = packed_guid_write(self.unit_target, _fmt, _data)

        elif SpellCastTargetFlags.UNIT_MINIPET in self.target_flags:
            # unit_minipet: PackedGuid
            _fmt, _data = packed_guid_write(self.unit_minipet, _fmt, _data)

        elif SpellCastTargetFlags.UNIT_ENEMY in self.target_flags:
            # unit_enemy: PackedGuid
            _fmt, _data = packed_guid_write(self.unit_enemy, _fmt, _data)

        if SpellCastTargetFlags.GAMEOBJECT in self.target_flags:
            # gameobject: PackedGuid
            _fmt, _data = packed_guid_write(self.gameobject, _fmt, _data)

        elif SpellCastTargetFlags.LOCKED in self.target_flags:
            # locked: PackedGuid
            _fmt, _data = packed_guid_write(self.locked, _fmt, _data)

        if SpellCastTargetFlags.ITEM in self.target_flags:
            # item: PackedGuid
            _fmt, _data = packed_guid_write(self.item, _fmt, _data)

        elif SpellCastTargetFlags.TRADE_ITEM in self.target_flags:
            # trade_item: PackedGuid
            _fmt, _data = packed_guid_write(self.trade_item, _fmt, _data)

        if SpellCastTargetFlags.SOURCE_LOCATION in self.target_flags:
            # source: Vector3d
            _fmt, _data = self.source.write(_fmt, _data)

        if SpellCastTargetFlags.DEST_LOCATION in self.target_flags:
            # destination: Vector3d
            _fmt, _data = self.destination.write(_fmt, _data)

        if SpellCastTargetFlags.STRING in self.target_flags:
            _fmt += f'{len(self.target_string)}sB'
            _data.extend([self.target_string.encode('utf-8'), 0])
        if SpellCastTargetFlags.CORPSE_ALLY in self.target_flags:
            # corpse_ally: PackedGuid
            _fmt, _data = packed_guid_write(self.corpse_ally, _fmt, _data)

        elif SpellCastTargetFlags.CORPSE_ENEMY in self.target_flags:
            # corpse_enemy: PackedGuid
            _fmt, _data = packed_guid_write(self.corpse_enemy, _fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        _size = 4

        if SpellCastTargetFlags.UNIT in self.target_flags:
            _size += 0 + packed_guid_size(self.unit_target)
        elif SpellCastTargetFlags.UNIT_MINIPET in self.target_flags:
            _size += 0 + packed_guid_size(self.unit_minipet)
        elif SpellCastTargetFlags.UNIT_ENEMY in self.target_flags:
            _size += 0 + packed_guid_size(self.unit_enemy)

        if SpellCastTargetFlags.GAMEOBJECT in self.target_flags:
            _size += 0 + packed_guid_size(self.gameobject)
        elif SpellCastTargetFlags.LOCKED in self.target_flags:
            _size += 0 + packed_guid_size(self.locked)

        if SpellCastTargetFlags.ITEM in self.target_flags:
            _size += 0 + packed_guid_size(self.item)
        elif SpellCastTargetFlags.TRADE_ITEM in self.target_flags:
            _size += 0 + packed_guid_size(self.trade_item)

        if SpellCastTargetFlags.SOURCE_LOCATION in self.target_flags:
            _size += 12

        if SpellCastTargetFlags.DEST_LOCATION in self.target_flags:
            _size += 12

        if SpellCastTargetFlags.STRING in self.target_flags:
            _size += 1 + len(self.target_string)

        if SpellCastTargetFlags.CORPSE_ALLY in self.target_flags:
            _size += 0 + packed_guid_size(self.corpse_ally)
        elif SpellCastTargetFlags.CORPSE_ENEMY in self.target_flags:
            _size += 0 + packed_guid_size(self.corpse_enemy)

        return _size


@dataclasses.dataclass
class SpellCooldownStatus:
    id: int
    cooldown_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SpellCooldownStatus:
        # id: Spell
        id = await read_int(reader, 4)

        # cooldown_time: Milliseconds
        cooldown_time = await read_int(reader, 4)

        return SpellCooldownStatus(
            id=id,
            cooldown_time=cooldown_time,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.id, self.cooldown_time])
        return _fmt, _data


@dataclasses.dataclass
class SpellLog:
    effect: SpellEffect
    target1: typing.Optional[int] = None
    amount: typing.Optional[int] = None
    power: typing.Optional[Power] = None
    multiplier: typing.Optional[float] = None
    target4: typing.Optional[int] = None
    extra_attacks: typing.Optional[int] = None
    target5: typing.Optional[int] = None
    interrupted_spell: typing.Optional[int] = None
    target6: typing.Optional[int] = None
    item_to_damage: typing.Optional[int] = None
    unknown5: typing.Optional[int] = None
    lock_target: typing.Optional[int] = None
    item: typing.Optional[int] = None
    summon_target: typing.Optional[int] = None
    pet_feed_guid: typing.Optional[int] = None
    pet_dismiss_guid: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SpellLog:
        target1 = None
        amount = None
        power = None
        multiplier = None
        target4 = None
        extra_attacks = None
        target5 = None
        interrupted_spell = None
        target6 = None
        item_to_damage = None
        unknown5 = None
        lock_target = None
        item = None
        summon_target = None
        pet_feed_guid = None
        pet_dismiss_guid = None
        # effect: SpellEffect
        effect = SpellEffect(await read_int(reader, 4))

        # amount_of_logs: u32
        _amount_of_logs = await read_int(reader, 4)

        if effect == SpellEffect.POWER_DRAIN:
            # target1: PackedGuid
            target1 = await read_packed_guid(reader)

            # amount: u32
            amount = await read_int(reader, 4)

            # power: Power
            power = Power(await read_int(reader, 4))

            # multiplier: f32
            multiplier = await read_float(reader)

        elif effect == SpellEffect.ADD_EXTRA_ATTACKS:
            # target4: PackedGuid
            target4 = await read_packed_guid(reader)

            # extra_attacks: u32
            extra_attacks = await read_int(reader, 4)

        elif effect == SpellEffect.INTERRUPT_CAST:
            # target5: PackedGuid
            target5 = await read_packed_guid(reader)

            # interrupted_spell: Spell
            interrupted_spell = await read_int(reader, 4)

        elif effect == SpellEffect.DURABILITY_DAMAGE:
            # target6: PackedGuid
            target6 = await read_packed_guid(reader)

            # item_to_damage: Item
            item_to_damage = await read_int(reader, 4)

            # unknown5: u32
            unknown5 = await read_int(reader, 4)

        elif effect in {SpellEffect.OPEN_LOCK, SpellEffect.OPEN_LOCK_ITEM}:
            # lock_target: PackedGuid
            lock_target = await read_packed_guid(reader)

        elif effect == SpellEffect.CREATE_ITEM:
            # item: Item
            item = await read_int(reader, 4)

        elif effect in {SpellEffect.SUMMON, SpellEffect.TRANS_DOOR, SpellEffect.SUMMON_PET, SpellEffect.SUMMON_OBJECT_WILD, SpellEffect.CREATE_HOUSE, SpellEffect.DUEL, SpellEffect.SUMMON_OBJECT_SLOT1, SpellEffect.SUMMON_OBJECT_SLOT2, SpellEffect.SUMMON_OBJECT_SLOT3, SpellEffect.SUMMON_OBJECT_SLOT4}:
            # summon_target: PackedGuid
            summon_target = await read_packed_guid(reader)

        elif effect == SpellEffect.FEED_PET:
            # pet_feed_guid: PackedGuid
            pet_feed_guid = await read_packed_guid(reader)

        elif effect == SpellEffect.DISMISS_PET:
            # pet_dismiss_guid: PackedGuid
            pet_dismiss_guid = await read_packed_guid(reader)

        return SpellLog(
            effect=effect,
            target1=target1,
            amount=amount,
            power=power,
            multiplier=multiplier,
            target4=target4,
            extra_attacks=extra_attacks,
            target5=target5,
            interrupted_spell=interrupted_spell,
            target6=target6,
            item_to_damage=item_to_damage,
            unknown5=unknown5,
            lock_target=lock_target,
            item=item,
            summon_target=summon_target,
            pet_feed_guid=pet_feed_guid,
            pet_dismiss_guid=pet_dismiss_guid,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.effect.value, 1])
        if self.effect == SpellEffect.POWER_DRAIN:
            # target1: PackedGuid
            _fmt, _data = packed_guid_write(self.target1, _fmt, _data)

            # amount: u32
            _fmt += 'I'
            _data.append(self.amount)

            # power: Power
            _fmt += 'I'
            _data.append(self.power.value)

            # multiplier: f32
            _fmt += 'f'
            _data.append(self.multiplier)

        elif self.effect == SpellEffect.ADD_EXTRA_ATTACKS:
            # target4: PackedGuid
            _fmt, _data = packed_guid_write(self.target4, _fmt, _data)

            # extra_attacks: u32
            _fmt += 'I'
            _data.append(self.extra_attacks)

        elif self.effect == SpellEffect.INTERRUPT_CAST:
            # target5: PackedGuid
            _fmt, _data = packed_guid_write(self.target5, _fmt, _data)

            # interrupted_spell: Spell
            _fmt += 'I'
            _data.append(self.interrupted_spell)

        elif self.effect == SpellEffect.DURABILITY_DAMAGE:
            # target6: PackedGuid
            _fmt, _data = packed_guid_write(self.target6, _fmt, _data)

            # item_to_damage: Item
            _fmt += 'I'
            _data.append(self.item_to_damage)

            # unknown5: u32
            _fmt += 'I'
            _data.append(self.unknown5)

        elif self.effect in {SpellEffect.OPEN_LOCK, SpellEffect.OPEN_LOCK_ITEM}:
            # lock_target: PackedGuid
            _fmt, _data = packed_guid_write(self.lock_target, _fmt, _data)

        elif self.effect == SpellEffect.CREATE_ITEM:
            _fmt += 'I'
            _data.append(self.item)
        elif self.effect in {SpellEffect.SUMMON, SpellEffect.TRANS_DOOR, SpellEffect.SUMMON_PET, SpellEffect.SUMMON_OBJECT_WILD, SpellEffect.CREATE_HOUSE, SpellEffect.DUEL, SpellEffect.SUMMON_OBJECT_SLOT1, SpellEffect.SUMMON_OBJECT_SLOT2, SpellEffect.SUMMON_OBJECT_SLOT3, SpellEffect.SUMMON_OBJECT_SLOT4}:
            # summon_target: PackedGuid
            _fmt, _data = packed_guid_write(self.summon_target, _fmt, _data)

        elif self.effect == SpellEffect.FEED_PET:
            # pet_feed_guid: PackedGuid
            _fmt, _data = packed_guid_write(self.pet_feed_guid, _fmt, _data)

        elif self.effect == SpellEffect.DISMISS_PET:
            # pet_dismiss_guid: PackedGuid
            _fmt, _data = packed_guid_write(self.pet_dismiss_guid, _fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        _size = 8

        if self.effect == SpellEffect.POWER_DRAIN:
            _size += 12 + packed_guid_size(self.target1)
        elif self.effect == SpellEffect.ADD_EXTRA_ATTACKS:
            _size += 4 + packed_guid_size(self.target4)
        elif self.effect == SpellEffect.INTERRUPT_CAST:
            _size += 4 + packed_guid_size(self.target5)
        elif self.effect == SpellEffect.DURABILITY_DAMAGE:
            _size += 8 + packed_guid_size(self.target6)
        elif self.effect in {SpellEffect.OPEN_LOCK, SpellEffect.OPEN_LOCK_ITEM}:
            _size += 0 + packed_guid_size(self.lock_target)
        elif self.effect == SpellEffect.CREATE_ITEM:
            _size += 4
        elif self.effect in {SpellEffect.SUMMON, SpellEffect.TRANS_DOOR, SpellEffect.SUMMON_PET, SpellEffect.SUMMON_OBJECT_WILD, SpellEffect.CREATE_HOUSE, SpellEffect.DUEL, SpellEffect.SUMMON_OBJECT_SLOT1, SpellEffect.SUMMON_OBJECT_SLOT2, SpellEffect.SUMMON_OBJECT_SLOT3, SpellEffect.SUMMON_OBJECT_SLOT4}:
            _size += 0 + packed_guid_size(self.summon_target)
        elif self.effect == SpellEffect.FEED_PET:
            _size += 0 + packed_guid_size(self.pet_feed_guid)
        elif self.effect == SpellEffect.DISMISS_PET:
            _size += 0 + packed_guid_size(self.pet_dismiss_guid)

        return _size


@dataclasses.dataclass
class SpellLogMiss:
    target: int
    miss_info: SpellMissInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SpellLogMiss:
        # target: Guid
        target = await read_int(reader, 8)

        # miss_info: SpellMissInfo
        miss_info = SpellMissInfo(await read_int(reader, 1))

        return SpellLogMiss(
            target=target,
            miss_info=miss_info,
        )

    def write(self, _fmt, _data):
        _fmt += 'QB'
        _data.extend([self.target, self.miss_info.value])
        return _fmt, _data


@dataclasses.dataclass
class SpellMiss:
    target: int
    miss_info: SpellMissInfo
    reflect_result: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SpellMiss:
        reflect_result = None
        # target: Guid
        target = await read_int(reader, 8)

        # miss_info: SpellMissInfo
        miss_info = SpellMissInfo(await read_int(reader, 1))

        if miss_info == SpellMissInfo.REFLECT:
            # reflect_result: u8
            reflect_result = await read_int(reader, 1)

        return SpellMiss(
            target=target,
            miss_info=miss_info,
            reflect_result=reflect_result,
        )

    def write(self, _fmt, _data):
        _fmt += 'QB'
        _data.extend([self.target, self.miss_info.value])
        if self.miss_info == SpellMissInfo.REFLECT:
            _fmt += 'B'
            _data.append(self.reflect_result)
        return _fmt, _data

    def size(self) -> int:
        _size = 9

        if self.miss_info == SpellMissInfo.REFLECT:
            _size += 1

        return _size


@dataclasses.dataclass
class SpellSteal:
    spell: int
    action: SpellStealAction

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SpellSteal:
        # spell: Spell
        spell = await read_int(reader, 4)

        # action: SpellStealAction
        action = SpellStealAction(await read_int(reader, 1))

        return SpellSteal(
            spell=spell,
            action=action,
        )

    def write(self, _fmt, _data):
        _fmt += 'IB'
        _data.extend([self.spell, self.action.value])
        return _fmt, _data


@dataclasses.dataclass
class StabledPet:
    pet_number: int
    entry: int
    level: int
    name: str
    loyalty: int
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> StabledPet:
        # pet_number: u32
        pet_number = await read_int(reader, 4)

        # entry: u32
        entry = await read_int(reader, 4)

        # level: Level32
        level = await read_int(reader, 4)

        # name: CString
        name = await read_cstring(reader)

        # loyalty: u32
        loyalty = await read_int(reader, 4)

        # slot: u8
        slot = await read_int(reader, 1)

        return StabledPet(
            pet_number=pet_number,
            entry=entry,
            level=level,
            name=name,
            loyalty=loyalty,
            slot=slot,
        )

    def write(self, _fmt, _data):
        _fmt += f'III{len(self.name)}sBIB'
        _data.extend([self.pet_number, self.entry, self.level, self.name.encode('utf-8'), 0, self.loyalty, self.slot])
        return _fmt, _data

    def size(self) -> int:
        return 18 + len(self.name)


@dataclasses.dataclass
class TradeSlot:
    trade_slot_number: int
    item: int
    display_id: int
    stack_count: int
    wrapped: bool
    gift_wrapper: int
    enchantment: int
    enchantments_slots: typing.List[int]
    item_creator: int
    spell_charges: int
    item_suffix_factor: int
    item_random_properties_id: int
    lock_id: int
    max_durability: int
    durability: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> TradeSlot:
        # trade_slot_number: u8
        trade_slot_number = await read_int(reader, 1)

        # item: Item
        item = await read_int(reader, 4)

        # display_id: u32
        display_id = await read_int(reader, 4)

        # stack_count: u32
        stack_count = await read_int(reader, 4)

        # wrapped: Bool32
        wrapped = await read_bool(reader, 4)

        # gift_wrapper: Guid
        gift_wrapper = await read_int(reader, 8)

        # enchantment: u32
        enchantment = await read_int(reader, 4)

        # enchantments_slots: u32[3]
        enchantments_slots = []
        for _ in range(0, 3):
            enchantments_slots.append(await read_int(reader, 4))

        # item_creator: Guid
        item_creator = await read_int(reader, 8)

        # spell_charges: u32
        spell_charges = await read_int(reader, 4)

        # item_suffix_factor: u32
        item_suffix_factor = await read_int(reader, 4)

        # item_random_properties_id: u32
        item_random_properties_id = await read_int(reader, 4)

        # lock_id: u32
        lock_id = await read_int(reader, 4)

        # max_durability: u32
        max_durability = await read_int(reader, 4)

        # durability: u32
        durability = await read_int(reader, 4)

        return TradeSlot(
            trade_slot_number=trade_slot_number,
            item=item,
            display_id=display_id,
            stack_count=stack_count,
            wrapped=wrapped,
            gift_wrapper=gift_wrapper,
            enchantment=enchantment,
            enchantments_slots=enchantments_slots,
            item_creator=item_creator,
            spell_charges=spell_charges,
            item_suffix_factor=item_suffix_factor,
            item_random_properties_id=item_random_properties_id,
            lock_id=lock_id,
            max_durability=max_durability,
            durability=durability,
        )

    def write(self, _fmt, _data):
        _fmt += f'BIIIIQI{len(self.enchantments_slots)}IQIIIIII'
        _data.extend([self.trade_slot_number, self.item, self.display_id, self.stack_count, self.wrapped, self.gift_wrapper, self.enchantment, *self.enchantments_slots, self.item_creator, self.spell_charges, self.item_suffix_factor, self.item_random_properties_id, self.lock_id, self.max_durability, self.durability])
        return _fmt, _data


@dataclasses.dataclass
class TrainerSpell:
    spell: int
    state: TrainerSpellState
    spell_cost: int
    talent_point_cost: int
    first_rank: int
    required_level: int
    required_skill: Skill
    required_skill_value: int
    required_spells: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> TrainerSpell:
        # spell: Spell
        spell = await read_int(reader, 4)

        # state: TrainerSpellState
        state = TrainerSpellState(await read_int(reader, 1))

        # spell_cost: u32
        spell_cost = await read_int(reader, 4)

        # talent_point_cost: u32
        talent_point_cost = await read_int(reader, 4)

        # first_rank: u32
        first_rank = await read_int(reader, 4)

        # required_level: u8
        required_level = await read_int(reader, 1)

        # required_skill: Skill
        required_skill = Skill(await read_int(reader, 4))

        # required_skill_value: u32
        required_skill_value = await read_int(reader, 4)

        # required_spells: u32[3]
        required_spells = []
        for _ in range(0, 3):
            required_spells.append(await read_int(reader, 4))

        return TrainerSpell(
            spell=spell,
            state=state,
            spell_cost=spell_cost,
            talent_point_cost=talent_point_cost,
            first_rank=first_rank,
            required_level=required_level,
            required_skill=required_skill,
            required_skill_value=required_skill_value,
            required_spells=required_spells,
        )

    def write(self, _fmt, _data):
        _fmt += f'IBIIIBII{len(self.required_spells)}I'
        _data.extend([self.spell, self.state.value, self.spell_cost, self.talent_point_cost, self.first_rank, self.required_level, self.required_skill.value, self.required_skill_value, *self.required_spells])
        return _fmt, _data


@dataclasses.dataclass
class Vector2d:
    x: float
    y: float

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Vector2d:
        # x: f32
        x = await read_float(reader)

        # y: f32
        y = await read_float(reader)

        return Vector2d(
            x=x,
            y=y,
        )

    def write(self, _fmt, _data):
        _fmt += 'ff'
        _data.extend([self.x, self.y])
        return _fmt, _data


@dataclasses.dataclass
class WhoPlayer:
    name: str
    guild: str
    level: int
    class_type: Class
    race: Race
    gender: Gender
    area: Area

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> WhoPlayer:
        # name: CString
        name = await read_cstring(reader)

        # guild: CString
        guild = await read_cstring(reader)

        # level: Level32
        level = await read_int(reader, 4)

        # class_type: Class
        class_type = Class(await read_int(reader, 1))

        # race: Race
        race = Race(await read_int(reader, 1))

        # gender: Gender
        gender = Gender(await read_int(reader, 1))

        # area: Area
        area = Area(await read_int(reader, 4))

        return WhoPlayer(
            name=name,
            guild=guild,
            level=level,
            class_type=class_type,
            race=race,
            gender=gender,
            area=area,
        )

    def write(self, _fmt, _data):
        _fmt += f'{len(self.name)}sB{len(self.guild)}sBIBBBI'
        _data.extend([self.name.encode('utf-8'), 0, self.guild.encode('utf-8'), 0, self.level, self.class_type.value, self.race.value, self.gender.value, self.area.value])
        return _fmt, _data

    def size(self) -> int:
        return 13 + len(self.name) + len(self.guild)


@dataclasses.dataclass
class WorldState:
    state: int
    value: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> WorldState:
        # state: u32
        state = await read_int(reader, 4)

        # value: u32
        value = await read_int(reader, 4)

        return WorldState(
            state=state,
            value=value,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.state, self.value])
        return _fmt, _data


@dataclasses.dataclass
class CMSG_BOOTME:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BOOTME:
        return CMSG_BOOTME()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0001))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_DBLOOKUP:
    query: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_DBLOOKUP:
        # query: CString
        query = await read_cstring(reader)

        return CMSG_DBLOOKUP(
            query=query,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0002))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.query)}sB'
        _data.extend([self.query.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.query)


@dataclasses.dataclass
class CMSG_WORLD_TELEPORT:
    time: int
    map: Map
    position: Vector3d
    orientation: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_WORLD_TELEPORT:
        # time: Milliseconds
        time = await read_int(reader, 4)

        # map: Map
        map = Map(await read_int(reader, 4))

        # position: Vector3d
        position = await Vector3d.read(reader)

        # orientation: f32
        orientation = await read_float(reader)

        return CMSG_WORLD_TELEPORT(
            time=time,
            map=map,
            position=position,
            orientation=orientation,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(24 + 4, 0x0008))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.time, self.map.value])
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # orientation: f32
        _fmt += 'f'
        _data.append(self.orientation)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TELEPORT_TO_UNIT:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TELEPORT_TO_UNIT:
        # name: CString
        name = await read_cstring(reader)

        return CMSG_TELEPORT_TO_UNIT(
            name=name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0009))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class CMSG_CHAR_CREATE:
    name: str
    race: Race
    class_type: Class
    gender: Gender
    skin_color: int
    face: int
    hair_style: int
    hair_color: int
    facial_hair: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHAR_CREATE:
        # name: CString
        name = await read_cstring(reader)

        # race: Race
        race = Race(await read_int(reader, 1))

        # class_type: Class
        class_type = Class(await read_int(reader, 1))

        # gender: Gender
        gender = Gender(await read_int(reader, 1))

        # skin_color: u8
        skin_color = await read_int(reader, 1)

        # face: u8
        face = await read_int(reader, 1)

        # hair_style: u8
        hair_style = await read_int(reader, 1)

        # hair_color: u8
        hair_color = await read_int(reader, 1)

        # facial_hair: u8
        facial_hair = await read_int(reader, 1)

        # outfit_id: u8
        _outfit_id = await read_int(reader, 1)

        return CMSG_CHAR_CREATE(
            name=name,
            race=race,
            class_type=class_type,
            gender=gender,
            skin_color=skin_color,
            face=face,
            hair_style=hair_style,
            hair_color=hair_color,
            facial_hair=facial_hair,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0036))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sBBBBBBBBBB'
        _data.extend([self.name.encode('utf-8'), 0, self.race.value, self.class_type.value, self.gender.value, self.skin_color, self.face, self.hair_style, self.hair_color, self.facial_hair, 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 10 + len(self.name)


@dataclasses.dataclass
class CMSG_CHAR_ENUM:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHAR_ENUM:
        return CMSG_CHAR_ENUM()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0037))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CHAR_DELETE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHAR_DELETE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_CHAR_DELETE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0038))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CHAR_CREATE:
    result: WorldResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAR_CREATE:
        # result: WorldResult
        result = WorldResult(await read_int(reader, 1))

        return SMSG_CHAR_CREATE(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x003A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CHAR_ENUM:
    characters: typing.List[Character]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAR_ENUM:
        # amount_of_characters: u8
        amount_of_characters = await read_int(reader, 1)

        # characters: Character[amount_of_characters]
        characters = []
        for _ in range(0, amount_of_characters):
            characters.append(await Character.read(reader))

        return SMSG_CHAR_ENUM(
            characters=characters,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x003B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(len(self.characters))
        # characters: Character[amount_of_characters]
        for i in self.characters:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + sum([i.size() for i in self.characters])


@dataclasses.dataclass
class SMSG_CHAR_DELETE:
    result: WorldResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAR_DELETE:
        # result: WorldResult
        result = WorldResult(await read_int(reader, 1))

        return SMSG_CHAR_DELETE(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x003C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PLAYER_LOGIN:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PLAYER_LOGIN:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_PLAYER_LOGIN(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x003D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_NEW_WORLD:
    map: Map
    position: Vector3d
    orientation: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_NEW_WORLD:
        # map: Map
        map = Map(await read_int(reader, 4))

        # position: Vector3d
        position = await Vector3d.read(reader)

        # orientation: f32
        orientation = await read_float(reader)

        return SMSG_NEW_WORLD(
            map=map,
            position=position,
            orientation=orientation,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x003E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # orientation: f32
        _fmt += 'f'
        _data.append(self.orientation)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TRANSFER_PENDING:
    map: Map
    transport: typing.Optional[int] = None
    transport_map: typing.Optional[Map] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRANSFER_PENDING:
        transport = None
        transport_map = None
        _size = 0

        # map: Map
        map = Map(await read_int(reader, 4))
        _size += 4

        # has_transport: optional
        if _size < body_size:
            # transport: u32
            transport = await read_int(reader, 4)
            _size += 4

            # transport_map: Map
            transport_map = Map(await read_int(reader, 4))
            _size += 4

        return SMSG_TRANSFER_PENDING(
            map=map,
            transport=transport,
            transport_map=transport_map,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x003F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        # has_transport: optional
        if self.transport is not None and self.transport_map is not None:
            _fmt += 'II'
            _data.extend([self.transport, self.transport_map.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        # has_transport: optional
        if self.transport is not None and self.transport_map is not None:
            _size += 8

        return _size


@dataclasses.dataclass
class SMSG_TRANSFER_ABORTED:
    map: Map
    reason: TransferAbortReason
    difficulty: typing.Optional[DungeonDifficulty] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRANSFER_ABORTED:
        difficulty = None
        # map: Map
        map = Map(await read_int(reader, 4))

        # reason: TransferAbortReason
        reason = TransferAbortReason(await read_int(reader, 1))

        if reason in {TransferAbortReason.INSUFFICIENT_EXPANSION_LEVEL, TransferAbortReason.DIFFICULTY_NOT_AVAILABLE}:
            # difficulty: DungeonDifficulty
            difficulty = DungeonDifficulty(await read_int(reader, 1))

        return SMSG_TRANSFER_ABORTED(
            map=map,
            reason=reason,
            difficulty=difficulty,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0040))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([self.map.value, self.reason.value])
        if self.reason in {TransferAbortReason.INSUFFICIENT_EXPANSION_LEVEL, TransferAbortReason.DIFFICULTY_NOT_AVAILABLE}:
            _fmt += 'B'
            _data.append(self.difficulty.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 5

        if self.reason in {TransferAbortReason.INSUFFICIENT_EXPANSION_LEVEL, TransferAbortReason.DIFFICULTY_NOT_AVAILABLE}:
            _size += 1

        return _size


@dataclasses.dataclass
class SMSG_CHARACTER_LOGIN_FAILED:
    result: WorldResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHARACTER_LOGIN_FAILED:
        # result: WorldResult
        result = WorldResult(await read_int(reader, 1))

        return SMSG_CHARACTER_LOGIN_FAILED(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x0041))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOGIN_SETTIMESPEED:
    datetime: int
    timescale: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOGIN_SETTIMESPEED:
        # datetime: DateTime
        datetime = await read_int(reader, 4)

        # timescale: f32
        timescale = await read_float(reader)

        return SMSG_LOGIN_SETTIMESPEED(
            datetime=datetime,
            timescale=timescale,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0042))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'If'
        _data.extend([self.datetime, self.timescale])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PLAYER_LOGOUT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PLAYER_LOGOUT:
        return CMSG_PLAYER_LOGOUT()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x004A))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LOGOUT_REQUEST:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOGOUT_REQUEST:
        return CMSG_LOGOUT_REQUEST()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x004B))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOGOUT_RESPONSE:
    result: LogoutResult
    speed: LogoutSpeed

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOGOUT_RESPONSE:
        # result: LogoutResult
        result = LogoutResult(await read_int(reader, 4))

        # speed: LogoutSpeed
        speed = LogoutSpeed(await read_int(reader, 1))

        return SMSG_LOGOUT_RESPONSE(
            result=result,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x004C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([self.result.value, self.speed.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOGOUT_COMPLETE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOGOUT_COMPLETE:
        return SMSG_LOGOUT_COMPLETE()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x004D))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LOGOUT_CANCEL:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOGOUT_CANCEL:
        return CMSG_LOGOUT_CANCEL()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x004E))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOGOUT_CANCEL_ACK:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOGOUT_CANCEL_ACK:
        return SMSG_LOGOUT_CANCEL_ACK()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x004F))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_NAME_QUERY:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_NAME_QUERY:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_NAME_QUERY(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0050))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_NAME_QUERY_RESPONSE:
    guid: int
    character_name: str
    realm_name: str
    race: Race
    gender: Gender
    class_type: Class
    has_declined_names: DeclinedNames
    declined_names: typing.Optional[typing.List[str]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_NAME_QUERY_RESPONSE:
        declined_names = None
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # character_name: CString
        character_name = await read_cstring(reader)

        # realm_name: CString
        realm_name = await read_cstring(reader)

        # race: Race
        race = Race(await read_int(reader, 4))

        # gender: Gender
        gender = Gender(await read_int(reader, 4))

        # class_type: Class
        class_type = Class(await read_int(reader, 4))

        # has_declined_names: DeclinedNames
        has_declined_names = DeclinedNames(await read_int(reader, 1))

        if has_declined_names == DeclinedNames.YES:
            # declined_names: CString[5]
            declined_names = []
            for _ in range(0, 5):
                declined_names.append(await read_cstring(reader))

        return SMSG_NAME_QUERY_RESPONSE(
            guid=guid,
            character_name=character_name,
            realm_name=realm_name,
            race=race,
            gender=gender,
            class_type=class_type,
            has_declined_names=has_declined_names,
            declined_names=declined_names,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0051))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # character_name: CString
        _fmt += f'{len(self.character_name)}sB'
        _data.extend([self.character_name.encode('utf-8'), 0])

        # realm_name: CString
        _fmt += f'{len(self.realm_name)}sB'
        _data.extend([self.realm_name.encode('utf-8'), 0])

        # race: Race
        _fmt += 'I'
        _data.append(self.race.value)

        # gender: Gender
        _fmt += 'I'
        _data.append(self.gender.value)

        # class_type: Class
        _fmt += 'I'
        _data.append(self.class_type.value)

        # has_declined_names: DeclinedNames
        _fmt += 'B'
        _data.append(self.has_declined_names.value)

        if self.has_declined_names == DeclinedNames.YES:
            # declined_names: CString[5]
            for i in self.declined_names:
                _fmt += f'{len(i)}sB'
                _data.append(i.encode('utf-8'))
                _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 15 + packed_guid_size(self.guid) + len(self.character_name) + len(self.realm_name)

        if self.has_declined_names == DeclinedNames.YES:
            _size += 0 + sum([len(i) + 1 for i in self.declined_names])

        return _size


@dataclasses.dataclass
class CMSG_PET_NAME_QUERY:
    pet_number: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_NAME_QUERY:
        # pet_number: u32
        pet_number = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_PET_NAME_QUERY(
            pet_number=pet_number,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0052))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.pet_number, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PET_NAME_QUERY_RESPONSE:
    pet_number: int
    name: str
    pet_name_timestamp: int
    names: PetQueryDisabledNames
    declined_names: typing.Optional[typing.List[str]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_NAME_QUERY_RESPONSE:
        declined_names = None
        # pet_number: u32
        pet_number = await read_int(reader, 4)

        # name: CString
        name = await read_cstring(reader)

        # pet_name_timestamp: u32
        pet_name_timestamp = await read_int(reader, 4)

        # names: PetQueryDisabledNames
        names = PetQueryDisabledNames(await read_int(reader, 1))

        if names == PetQueryDisabledNames.PRESENT:
            # declined_names: CString[5]
            declined_names = []
            for _ in range(0, 5):
                declined_names.append(await read_cstring(reader))

        return SMSG_PET_NAME_QUERY_RESPONSE(
            pet_number=pet_number,
            name=name,
            pet_name_timestamp=pet_name_timestamp,
            names=names,
            declined_names=declined_names,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0053))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.name)}sBIB'
        _data.extend([self.pet_number, self.name.encode('utf-8'), 0, self.pet_name_timestamp, self.names.value])
        if self.names == PetQueryDisabledNames.PRESENT:
            # declined_names: CString[5]
            for i in self.declined_names:
                _fmt += f'{len(i)}sB'
                _data.append(i.encode('utf-8'))
                _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 10 + len(self.name)

        if self.names == PetQueryDisabledNames.PRESENT:
            _size += 0 + sum([len(i) + 1 for i in self.declined_names])

        return _size


@dataclasses.dataclass
class CMSG_GUILD_QUERY:
    guild_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_QUERY:
        # guild_id: u32
        guild_id = await read_int(reader, 4)

        return CMSG_GUILD_QUERY(
            guild_id=guild_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0054))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.guild_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GUILD_QUERY_RESPONSE:
    id: int
    name: str
    rank_names: typing.List[str]
    emblem_style: int
    emblem_color: int
    border_style: int
    border_color: int
    background_color: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_QUERY_RESPONSE:
        # id: u32
        id = await read_int(reader, 4)

        # name: CString
        name = await read_cstring(reader)

        # rank_names: CString[10]
        rank_names = []
        for _ in range(0, 10):
            rank_names.append(await read_cstring(reader))

        # emblem_style: u32
        emblem_style = await read_int(reader, 4)

        # emblem_color: u32
        emblem_color = await read_int(reader, 4)

        # border_style: u32
        border_style = await read_int(reader, 4)

        # border_color: u32
        border_color = await read_int(reader, 4)

        # background_color: u32
        background_color = await read_int(reader, 4)

        return SMSG_GUILD_QUERY_RESPONSE(
            id=id,
            name=name,
            rank_names=rank_names,
            emblem_style=emblem_style,
            emblem_color=emblem_color,
            border_style=border_style,
            border_color=border_color,
            background_color=background_color,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0055))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.name)}sB'
        _data.extend([self.id, self.name.encode('utf-8'), 0])
        # rank_names: CString[10]
        for i in self.rank_names:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        # emblem_style: u32
        _fmt += 'I'
        _data.append(self.emblem_style)

        # emblem_color: u32
        _fmt += 'I'
        _data.append(self.emblem_color)

        # border_style: u32
        _fmt += 'I'
        _data.append(self.border_style)

        # border_color: u32
        _fmt += 'I'
        _data.append(self.border_color)

        # background_color: u32
        _fmt += 'I'
        _data.append(self.background_color)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 25 + len(self.name) + sum([len(i) + 1 for i in self.rank_names])


@dataclasses.dataclass
class CMSG_ITEM_QUERY_SINGLE:
    item: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ITEM_QUERY_SINGLE:
        # item: Item
        item = await read_int(reader, 4)

        return CMSG_ITEM_QUERY_SINGLE(
            item=item,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0056))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.item)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_QUERY_SINGLE_RESPONSE:
    item: int
    class_and_sub_class: typing.Optional[ItemClassAndSubClass] = None
    sound_override_sub_class: typing.Optional[int] = None
    name1: typing.Optional[str] = None
    name2: typing.Optional[str] = None
    name3: typing.Optional[str] = None
    name4: typing.Optional[str] = None
    display_id: typing.Optional[int] = None
    quality: typing.Optional[ItemQuality] = None
    flags: typing.Optional[ItemFlag] = None
    buy_price: typing.Optional[int] = None
    sell_price: typing.Optional[int] = None
    inventory_type: typing.Optional[InventoryType] = None
    allowed_class: typing.Optional[AllowedClass] = None
    allowed_race: typing.Optional[AllowedRace] = None
    item_level: typing.Optional[int] = None
    required_level: typing.Optional[int] = None
    required_skill: typing.Optional[Skill] = None
    required_skill_rank: typing.Optional[int] = None
    required_spell: typing.Optional[int] = None
    required_honor_rank: typing.Optional[int] = None
    required_city_rank: typing.Optional[int] = None
    required_faction: typing.Optional[Faction] = None
    required_faction_rank: typing.Optional[int] = None
    max_count: typing.Optional[int] = None
    stackable: typing.Optional[int] = None
    container_slots: typing.Optional[int] = None
    stats: typing.Optional[typing.List[ItemStat]] = None
    damages: typing.Optional[typing.List[ItemDamageType]] = None
    armor: typing.Optional[int] = None
    holy_resistance: typing.Optional[int] = None
    fire_resistance: typing.Optional[int] = None
    nature_resistance: typing.Optional[int] = None
    frost_resistance: typing.Optional[int] = None
    shadow_resistance: typing.Optional[int] = None
    arcane_resistance: typing.Optional[int] = None
    delay: typing.Optional[int] = None
    ammo_type: typing.Optional[int] = None
    ranged_range_modification: typing.Optional[float] = None
    spells: typing.Optional[typing.List[ItemSpells]] = None
    bonding: typing.Optional[Bonding] = None
    description: typing.Optional[str] = None
    page_text: typing.Optional[int] = None
    language: typing.Optional[Language] = None
    page_text_material: typing.Optional[PageTextMaterial] = None
    start_quest: typing.Optional[int] = None
    lock_id: typing.Optional[int] = None
    material: typing.Optional[int] = None
    sheathe_type: typing.Optional[SheatheType] = None
    random_property: typing.Optional[int] = None
    block: typing.Optional[int] = None
    item_set: typing.Optional[ItemSet] = None
    max_durability: typing.Optional[int] = None
    area: typing.Optional[Area] = None
    map: typing.Optional[Map] = None
    bag_family: typing.Optional[BagFamily] = None
    totem_category: typing.Optional[int] = None
    sockets: typing.Optional[typing.List[ItemSocket]] = None
    socket_bonus: typing.Optional[int] = None
    gem_properties: typing.Optional[int] = None
    required_disenchant_skill: typing.Optional[int] = None
    armor_damage_modifier: typing.Optional[float] = None
    duration: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_QUERY_SINGLE_RESPONSE:
        class_and_sub_class = None
        sound_override_sub_class = None
        name1 = None
        name2 = None
        name3 = None
        name4 = None
        display_id = None
        quality = None
        flags = None
        buy_price = None
        sell_price = None
        inventory_type = None
        allowed_class = None
        allowed_race = None
        item_level = None
        required_level = None
        required_skill = None
        required_skill_rank = None
        required_spell = None
        required_honor_rank = None
        required_city_rank = None
        required_faction = None
        required_faction_rank = None
        max_count = None
        stackable = None
        container_slots = None
        stats = None
        damages = None
        armor = None
        holy_resistance = None
        fire_resistance = None
        nature_resistance = None
        frost_resistance = None
        shadow_resistance = None
        arcane_resistance = None
        delay = None
        ammo_type = None
        ranged_range_modification = None
        spells = None
        bonding = None
        description = None
        page_text = None
        language = None
        page_text_material = None
        start_quest = None
        lock_id = None
        material = None
        sheathe_type = None
        random_property = None
        block = None
        item_set = None
        max_durability = None
        area = None
        map = None
        bag_family = None
        totem_category = None
        sockets = None
        socket_bonus = None
        gem_properties = None
        required_disenchant_skill = None
        armor_damage_modifier = None
        duration = None
        _size = 0

        # item: Item
        item = await read_int(reader, 4)
        _size += 4

        # found: optional
        if _size < body_size:
            # class_and_sub_class: ItemClassAndSubClass
            class_and_sub_class = ItemClassAndSubClass(await read_int(reader, 8))
            _size += 8

            # sound_override_sub_class: u32
            sound_override_sub_class = await read_int(reader, 4)
            _size += 4

            # name1: CString
            name1 = await read_cstring(reader)
            _size += len(name1) + 1

            # name2: CString
            name2 = await read_cstring(reader)
            _size += len(name2) + 1

            # name3: CString
            name3 = await read_cstring(reader)
            _size += len(name3) + 1

            # name4: CString
            name4 = await read_cstring(reader)
            _size += len(name4) + 1

            # display_id: u32
            display_id = await read_int(reader, 4)
            _size += 4

            # quality: ItemQuality
            quality = ItemQuality(await read_int(reader, 4))
            _size += 4

            # flags: ItemFlag
            flags = ItemFlag(await read_int(reader, 4))
            _size += 4

            # buy_price: Gold
            buy_price = await read_int(reader, 4)
            _size += 4

            # sell_price: Gold
            sell_price = await read_int(reader, 4)
            _size += 4

            # inventory_type: InventoryType
            inventory_type = InventoryType(await read_int(reader, 4))
            _size += 4

            # allowed_class: AllowedClass
            allowed_class = AllowedClass(await read_int(reader, 4))
            _size += 4

            # allowed_race: AllowedRace
            allowed_race = AllowedRace(await read_int(reader, 4))
            _size += 4

            # item_level: u32
            item_level = await read_int(reader, 4)
            _size += 4

            # required_level: Level32
            required_level = await read_int(reader, 4)
            _size += 4

            # required_skill: Skill
            required_skill = Skill(await read_int(reader, 4))
            _size += 4

            # required_skill_rank: u32
            required_skill_rank = await read_int(reader, 4)
            _size += 4

            # required_spell: Spell
            required_spell = await read_int(reader, 4)
            _size += 4

            # required_honor_rank: u32
            required_honor_rank = await read_int(reader, 4)
            _size += 4

            # required_city_rank: u32
            required_city_rank = await read_int(reader, 4)
            _size += 4

            # required_faction: Faction
            required_faction = Faction(await read_int(reader, 4))
            _size += 4

            # required_faction_rank: u32
            required_faction_rank = await read_int(reader, 4)
            _size += 4

            # max_count: u32
            max_count = await read_int(reader, 4)
            _size += 4

            # stackable: u32
            stackable = await read_int(reader, 4)
            _size += 4

            # container_slots: u32
            container_slots = await read_int(reader, 4)
            _size += 4

            # stats: ItemStat[10]
            stats = []
            for _ in range(0, 10):
                stats.append(await ItemStat.read(reader))
                _size += 8

            # damages: ItemDamageType[5]
            damages = []
            for _ in range(0, 5):
                damages.append(await ItemDamageType.read(reader))
                _size += 12

            # armor: i32
            armor = await read_int(reader, 4)
            _size += 4

            # holy_resistance: i32
            holy_resistance = await read_int(reader, 4)
            _size += 4

            # fire_resistance: i32
            fire_resistance = await read_int(reader, 4)
            _size += 4

            # nature_resistance: i32
            nature_resistance = await read_int(reader, 4)
            _size += 4

            # frost_resistance: i32
            frost_resistance = await read_int(reader, 4)
            _size += 4

            # shadow_resistance: i32
            shadow_resistance = await read_int(reader, 4)
            _size += 4

            # arcane_resistance: i32
            arcane_resistance = await read_int(reader, 4)
            _size += 4

            # delay: u32
            delay = await read_int(reader, 4)
            _size += 4

            # ammo_type: u32
            ammo_type = await read_int(reader, 4)
            _size += 4

            # ranged_range_modification: f32
            ranged_range_modification = await read_float(reader)
            _size += 4

            # spells: ItemSpells[5]
            spells = []
            for _ in range(0, 5):
                spells.append(await ItemSpells.read(reader))
                _size += 24

            # bonding: Bonding
            bonding = Bonding(await read_int(reader, 4))
            _size += 4

            # description: CString
            description = await read_cstring(reader)
            _size += len(description) + 1

            # page_text: u32
            page_text = await read_int(reader, 4)
            _size += 4

            # language: Language
            language = Language(await read_int(reader, 4))
            _size += 4

            # page_text_material: PageTextMaterial
            page_text_material = PageTextMaterial(await read_int(reader, 4))
            _size += 4

            # start_quest: u32
            start_quest = await read_int(reader, 4)
            _size += 4

            # lock_id: u32
            lock_id = await read_int(reader, 4)
            _size += 4

            # material: u32
            material = await read_int(reader, 4)
            _size += 4

            # sheathe_type: SheatheType
            sheathe_type = SheatheType(await read_int(reader, 4))
            _size += 4

            # random_property: u32
            random_property = await read_int(reader, 4)
            _size += 4

            # block: u32
            block = await read_int(reader, 4)
            _size += 4

            # item_set: ItemSet
            item_set = ItemSet(await read_int(reader, 4))
            _size += 4

            # max_durability: u32
            max_durability = await read_int(reader, 4)
            _size += 4

            # area: Area
            area = Area(await read_int(reader, 4))
            _size += 4

            # map: Map
            map = Map(await read_int(reader, 4))
            _size += 4

            # bag_family: BagFamily
            bag_family = BagFamily(await read_int(reader, 4))
            _size += 4

            # totem_category: u32
            totem_category = await read_int(reader, 4)
            _size += 4

            # sockets: ItemSocket[3]
            sockets = []
            for _ in range(0, 3):
                sockets.append(await ItemSocket.read(reader))
                _size += 8

            # socket_bonus: u32
            socket_bonus = await read_int(reader, 4)
            _size += 4

            # gem_properties: u32
            gem_properties = await read_int(reader, 4)
            _size += 4

            # required_disenchant_skill: u32
            required_disenchant_skill = await read_int(reader, 4)
            _size += 4

            # armor_damage_modifier: f32
            armor_damage_modifier = await read_float(reader)
            _size += 4

            # duration: Seconds
            duration = await read_int(reader, 4)
            _size += 4

        return SMSG_ITEM_QUERY_SINGLE_RESPONSE(
            item=item,
            class_and_sub_class=class_and_sub_class,
            sound_override_sub_class=sound_override_sub_class,
            name1=name1,
            name2=name2,
            name3=name3,
            name4=name4,
            display_id=display_id,
            quality=quality,
            flags=flags,
            buy_price=buy_price,
            sell_price=sell_price,
            inventory_type=inventory_type,
            allowed_class=allowed_class,
            allowed_race=allowed_race,
            item_level=item_level,
            required_level=required_level,
            required_skill=required_skill,
            required_skill_rank=required_skill_rank,
            required_spell=required_spell,
            required_honor_rank=required_honor_rank,
            required_city_rank=required_city_rank,
            required_faction=required_faction,
            required_faction_rank=required_faction_rank,
            max_count=max_count,
            stackable=stackable,
            container_slots=container_slots,
            stats=stats,
            damages=damages,
            armor=armor,
            holy_resistance=holy_resistance,
            fire_resistance=fire_resistance,
            nature_resistance=nature_resistance,
            frost_resistance=frost_resistance,
            shadow_resistance=shadow_resistance,
            arcane_resistance=arcane_resistance,
            delay=delay,
            ammo_type=ammo_type,
            ranged_range_modification=ranged_range_modification,
            spells=spells,
            bonding=bonding,
            description=description,
            page_text=page_text,
            language=language,
            page_text_material=page_text_material,
            start_quest=start_quest,
            lock_id=lock_id,
            material=material,
            sheathe_type=sheathe_type,
            random_property=random_property,
            block=block,
            item_set=item_set,
            max_durability=max_durability,
            area=area,
            map=map,
            bag_family=bag_family,
            totem_category=totem_category,
            sockets=sockets,
            socket_bonus=socket_bonus,
            gem_properties=gem_properties,
            required_disenchant_skill=required_disenchant_skill,
            armor_damage_modifier=armor_damage_modifier,
            duration=duration,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0058))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.item)
        # found: optional
        if self.class_and_sub_class is not None and self.sound_override_sub_class is not None and self.name1 is not None and self.name2 is not None and self.name3 is not None and self.name4 is not None and self.display_id is not None and self.quality is not None and self.flags is not None and self.buy_price is not None and self.sell_price is not None and self.inventory_type is not None and self.allowed_class is not None and self.allowed_race is not None and self.item_level is not None and self.required_level is not None and self.required_skill is not None and self.required_skill_rank is not None and self.required_spell is not None and self.required_honor_rank is not None and self.required_city_rank is not None and self.required_faction is not None and self.required_faction_rank is not None and self.max_count is not None and self.stackable is not None and self.container_slots is not None and self.stats is not None and self.damages is not None and self.armor is not None and self.holy_resistance is not None and self.fire_resistance is not None and self.nature_resistance is not None and self.frost_resistance is not None and self.shadow_resistance is not None and self.arcane_resistance is not None and self.delay is not None and self.ammo_type is not None and self.ranged_range_modification is not None and self.spells is not None and self.bonding is not None and self.description is not None and self.page_text is not None and self.language is not None and self.page_text_material is not None and self.start_quest is not None and self.lock_id is not None and self.material is not None and self.sheathe_type is not None and self.random_property is not None and self.block is not None and self.item_set is not None and self.max_durability is not None and self.area is not None and self.map is not None and self.bag_family is not None and self.totem_category is not None and self.sockets is not None and self.socket_bonus is not None and self.gem_properties is not None and self.required_disenchant_skill is not None and self.armor_damage_modifier is not None and self.duration is not None:
            _fmt += f'QI{len(self.name1)}sB{len(self.name2)}sB{len(self.name3)}sB{len(self.name4)}sBIIIIIIIIIIIIIIIIIIII'
            _data.extend([self.class_and_sub_class.value, self.sound_override_sub_class, self.name1.encode('utf-8'), 0, self.name2.encode('utf-8'), 0, self.name3.encode('utf-8'), 0, self.name4.encode('utf-8'), 0, self.display_id, self.quality.value, self.flags.value, self.buy_price, self.sell_price, self.inventory_type.value, self.allowed_class.value, self.allowed_race.value, self.item_level, self.required_level, self.required_skill.value, self.required_skill_rank, self.required_spell, self.required_honor_rank, self.required_city_rank, self.required_faction.value, self.required_faction_rank, self.max_count, self.stackable, self.container_slots])
            # stats: ItemStat[10]
            for i in self.stats:
                _fmt, _data = i.write(_fmt, _data)

            # damages: ItemDamageType[5]
            for i in self.damages:
                _fmt, _data = i.write(_fmt, _data)

            # armor: i32
            _fmt += 'i'
            _data.append(self.armor)

            # holy_resistance: i32
            _fmt += 'i'
            _data.append(self.holy_resistance)

            # fire_resistance: i32
            _fmt += 'i'
            _data.append(self.fire_resistance)

            # nature_resistance: i32
            _fmt += 'i'
            _data.append(self.nature_resistance)

            # frost_resistance: i32
            _fmt += 'i'
            _data.append(self.frost_resistance)

            # shadow_resistance: i32
            _fmt += 'i'
            _data.append(self.shadow_resistance)

            # arcane_resistance: i32
            _fmt += 'i'
            _data.append(self.arcane_resistance)

            # delay: u32
            _fmt += 'I'
            _data.append(self.delay)

            # ammo_type: u32
            _fmt += 'I'
            _data.append(self.ammo_type)

            # ranged_range_modification: f32
            _fmt += 'f'
            _data.append(self.ranged_range_modification)

            # spells: ItemSpells[5]
            for i in self.spells:
                _fmt, _data = i.write(_fmt, _data)

            # bonding: Bonding
            _fmt += 'I'
            _data.append(self.bonding.value)

            # description: CString
            _fmt += f'{len(self.description)}sB'
            _data.extend([self.description.encode('utf-8'), 0])

            # page_text: u32
            _fmt += 'I'
            _data.append(self.page_text)

            # language: Language
            _fmt += 'I'
            _data.append(self.language.value)

            # page_text_material: PageTextMaterial
            _fmt += 'I'
            _data.append(self.page_text_material.value)

            # start_quest: u32
            _fmt += 'I'
            _data.append(self.start_quest)

            # lock_id: u32
            _fmt += 'I'
            _data.append(self.lock_id)

            # material: u32
            _fmt += 'I'
            _data.append(self.material)

            # sheathe_type: SheatheType
            _fmt += 'I'
            _data.append(self.sheathe_type.value)

            # random_property: u32
            _fmt += 'I'
            _data.append(self.random_property)

            # block: u32
            _fmt += 'I'
            _data.append(self.block)

            # item_set: ItemSet
            _fmt += 'I'
            _data.append(self.item_set.value)

            # max_durability: u32
            _fmt += 'I'
            _data.append(self.max_durability)

            # area: Area
            _fmt += 'I'
            _data.append(self.area.value)

            # map: Map
            _fmt += 'I'
            _data.append(self.map.value)

            # bag_family: BagFamily
            _fmt += 'I'
            _data.append(self.bag_family.value)

            # totem_category: u32
            _fmt += 'I'
            _data.append(self.totem_category)

            # sockets: ItemSocket[3]
            for i in self.sockets:
                _fmt, _data = i.write(_fmt, _data)

            # socket_bonus: u32
            _fmt += 'I'
            _data.append(self.socket_bonus)

            # gem_properties: u32
            _fmt += 'I'
            _data.append(self.gem_properties)

            # required_disenchant_skill: u32
            _fmt += 'I'
            _data.append(self.required_disenchant_skill)

            # armor_damage_modifier: f32
            _fmt += 'f'
            _data.append(self.armor_damage_modifier)

            # duration: Seconds
            _fmt += 'I'
            _data.append(self.duration)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        # found: optional
        if self.class_and_sub_class is not None and self.sound_override_sub_class is not None and self.name1 is not None and self.name2 is not None and self.name3 is not None and self.name4 is not None and self.display_id is not None and self.quality is not None and self.flags is not None and self.buy_price is not None and self.sell_price is not None and self.inventory_type is not None and self.allowed_class is not None and self.allowed_race is not None and self.item_level is not None and self.required_level is not None and self.required_skill is not None and self.required_skill_rank is not None and self.required_spell is not None and self.required_honor_rank is not None and self.required_city_rank is not None and self.required_faction is not None and self.required_faction_rank is not None and self.max_count is not None and self.stackable is not None and self.container_slots is not None and self.stats is not None and self.damages is not None and self.armor is not None and self.holy_resistance is not None and self.fire_resistance is not None and self.nature_resistance is not None and self.frost_resistance is not None and self.shadow_resistance is not None and self.arcane_resistance is not None and self.delay is not None and self.ammo_type is not None and self.ranged_range_modification is not None and self.spells is not None and self.bonding is not None and self.description is not None and self.page_text is not None and self.language is not None and self.page_text_material is not None and self.start_quest is not None and self.lock_id is not None and self.material is not None and self.sheathe_type is not None and self.random_property is not None and self.block is not None and self.item_set is not None and self.max_durability is not None and self.area is not None and self.map is not None and self.bag_family is not None and self.totem_category is not None and self.sockets is not None and self.socket_bonus is not None and self.gem_properties is not None and self.required_disenchant_skill is not None and self.armor_damage_modifier is not None and self.duration is not None:
            _size += 505 + len(self.name1) + len(self.name2) + len(self.name3) + len(self.name4) + len(self.description)

        return _size


@dataclasses.dataclass
class CMSG_PAGE_TEXT_QUERY:
    page_id: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PAGE_TEXT_QUERY:
        # page_id: u32
        page_id = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_PAGE_TEXT_QUERY(
            page_id=page_id,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x005A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.page_id, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PAGE_TEXT_QUERY_RESPONSE:
    page_id: int
    text: str
    next_page_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PAGE_TEXT_QUERY_RESPONSE:
        # page_id: u32
        page_id = await read_int(reader, 4)

        # text: CString
        text = await read_cstring(reader)

        # next_page_id: u32
        next_page_id = await read_int(reader, 4)

        return SMSG_PAGE_TEXT_QUERY_RESPONSE(
            page_id=page_id,
            text=text,
            next_page_id=next_page_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x005B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.text)}sBI'
        _data.extend([self.page_id, self.text.encode('utf-8'), 0, self.next_page_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.text)


@dataclasses.dataclass
class CMSG_QUEST_QUERY:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUEST_QUERY:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return CMSG_QUEST_QUERY(
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x005C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.quest_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUEST_QUERY_RESPONSE:
    quest_id: int
    quest_method: int
    quest_level: int
    zone_or_sort: int
    quest_type: int
    suggest_player_amount: int
    reputation_objective_faction: Faction
    reputation_objective_value: int
    required_opposite_faction: Faction
    required_opposite_reputation_value: int
    next_quest_in_chain: int
    money_reward: int
    max_level_money_reward: int
    reward_spell: int
    casted_reward_spell: int
    honor_reward: int
    source_item_id: int
    quest_flags: int
    title_reward: int
    rewards: typing.List[QuestItemReward]
    choice_rewards: typing.List[QuestItemReward]
    point_map_id: int
    position: Vector2d
    point_opt: int
    title: str
    objective_text: str
    details: str
    end_text: str
    objectives: typing.List[QuestObjective]
    objective_texts: typing.List[str]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUEST_QUERY_RESPONSE:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # quest_method: u32
        quest_method = await read_int(reader, 4)

        # quest_level: Level32
        quest_level = await read_int(reader, 4)

        # zone_or_sort: u32
        zone_or_sort = await read_int(reader, 4)

        # quest_type: u32
        quest_type = await read_int(reader, 4)

        # suggest_player_amount: u32
        suggest_player_amount = await read_int(reader, 4)

        # reputation_objective_faction: Faction
        reputation_objective_faction = Faction(await read_int(reader, 2))

        # reputation_objective_value: u32
        reputation_objective_value = await read_int(reader, 4)

        # required_opposite_faction: Faction
        required_opposite_faction = Faction(await read_int(reader, 2))

        # required_opposite_reputation_value: u32
        required_opposite_reputation_value = await read_int(reader, 4)

        # next_quest_in_chain: u32
        next_quest_in_chain = await read_int(reader, 4)

        # money_reward: Gold
        money_reward = await read_int(reader, 4)

        # max_level_money_reward: Gold
        max_level_money_reward = await read_int(reader, 4)

        # reward_spell: u32
        reward_spell = await read_int(reader, 4)

        # casted_reward_spell: u32
        casted_reward_spell = await read_int(reader, 4)

        # honor_reward: u32
        honor_reward = await read_int(reader, 4)

        # source_item_id: u32
        source_item_id = await read_int(reader, 4)

        # quest_flags: u32
        quest_flags = await read_int(reader, 4)

        # title_reward: u32
        title_reward = await read_int(reader, 4)

        # rewards: QuestItemReward[4]
        rewards = []
        for _ in range(0, 4):
            rewards.append(await QuestItemReward.read(reader))

        # choice_rewards: QuestItemReward[6]
        choice_rewards = []
        for _ in range(0, 6):
            choice_rewards.append(await QuestItemReward.read(reader))

        # point_map_id: u32
        point_map_id = await read_int(reader, 4)

        # position: Vector2d
        position = await Vector2d.read(reader)

        # point_opt: u32
        point_opt = await read_int(reader, 4)

        # title: CString
        title = await read_cstring(reader)

        # objective_text: CString
        objective_text = await read_cstring(reader)

        # details: CString
        details = await read_cstring(reader)

        # end_text: CString
        end_text = await read_cstring(reader)

        # objectives: QuestObjective[4]
        objectives = []
        for _ in range(0, 4):
            objectives.append(await QuestObjective.read(reader))

        # objective_texts: CString[4]
        objective_texts = []
        for _ in range(0, 4):
            objective_texts.append(await read_cstring(reader))

        return SMSG_QUEST_QUERY_RESPONSE(
            quest_id=quest_id,
            quest_method=quest_method,
            quest_level=quest_level,
            zone_or_sort=zone_or_sort,
            quest_type=quest_type,
            suggest_player_amount=suggest_player_amount,
            reputation_objective_faction=reputation_objective_faction,
            reputation_objective_value=reputation_objective_value,
            required_opposite_faction=required_opposite_faction,
            required_opposite_reputation_value=required_opposite_reputation_value,
            next_quest_in_chain=next_quest_in_chain,
            money_reward=money_reward,
            max_level_money_reward=max_level_money_reward,
            reward_spell=reward_spell,
            casted_reward_spell=casted_reward_spell,
            honor_reward=honor_reward,
            source_item_id=source_item_id,
            quest_flags=quest_flags,
            title_reward=title_reward,
            rewards=rewards,
            choice_rewards=choice_rewards,
            point_map_id=point_map_id,
            position=position,
            point_opt=point_opt,
            title=title,
            objective_text=objective_text,
            details=details,
            end_text=end_text,
            objectives=objectives,
            objective_texts=objective_texts,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x005D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIIIIHIHIIIIIIIIII'
        _data.extend([self.quest_id, self.quest_method, self.quest_level, self.zone_or_sort, self.quest_type, self.suggest_player_amount, self.reputation_objective_faction.value, self.reputation_objective_value, self.required_opposite_faction.value, self.required_opposite_reputation_value, self.next_quest_in_chain, self.money_reward, self.max_level_money_reward, self.reward_spell, self.casted_reward_spell, self.honor_reward, self.source_item_id, self.quest_flags, self.title_reward])
        # rewards: QuestItemReward[4]
        for i in self.rewards:
            _fmt, _data = i.write(_fmt, _data)

        # choice_rewards: QuestItemReward[6]
        for i in self.choice_rewards:
            _fmt, _data = i.write(_fmt, _data)

        # point_map_id: u32
        _fmt += 'I'
        _data.append(self.point_map_id)

        # position: Vector2d
        _fmt, _data = self.position.write(_fmt, _data)

        # point_opt: u32
        _fmt += 'I'
        _data.append(self.point_opt)

        # title: CString
        _fmt += f'{len(self.title)}sB'
        _data.extend([self.title.encode('utf-8'), 0])

        # objective_text: CString
        _fmt += f'{len(self.objective_text)}sB'
        _data.extend([self.objective_text.encode('utf-8'), 0])

        # details: CString
        _fmt += f'{len(self.details)}sB'
        _data.extend([self.details.encode('utf-8'), 0])

        # end_text: CString
        _fmt += f'{len(self.end_text)}sB'
        _data.extend([self.end_text.encode('utf-8'), 0])

        # objectives: QuestObjective[4]
        for i in self.objectives:
            _fmt, _data = i.write(_fmt, _data)

        # objective_texts: CString[4]
        for i in self.objective_texts:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 236 + len(self.title) + len(self.objective_text) + len(self.details) + len(self.end_text) + sum([len(i) + 1 for i in self.objective_texts])


@dataclasses.dataclass
class CMSG_GAMEOBJECT_QUERY:
    entry_id: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GAMEOBJECT_QUERY:
        # entry_id: u32
        entry_id = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_GAMEOBJECT_QUERY(
            entry_id=entry_id,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x005E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.entry_id, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GAMEOBJECT_QUERY_RESPONSE:
    entry_id: int
    info_type: typing.Optional[int] = None
    display_id: typing.Optional[int] = None
    name1: typing.Optional[str] = None
    name2: typing.Optional[str] = None
    name3: typing.Optional[str] = None
    name4: typing.Optional[str] = None
    icon_name: typing.Optional[str] = None
    cast_bar_caption: typing.Optional[str] = None
    unknown: typing.Optional[str] = None
    raw_data: typing.Optional[typing.List[int]] = None
    gameobject_size: typing.Optional[float] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GAMEOBJECT_QUERY_RESPONSE:
        info_type = None
        display_id = None
        name1 = None
        name2 = None
        name3 = None
        name4 = None
        icon_name = None
        cast_bar_caption = None
        unknown = None
        raw_data = None
        gameobject_size = None
        _size = 0

        # entry_id: u32
        entry_id = await read_int(reader, 4)
        _size += 4

        # found: optional
        if _size < body_size:
            # info_type: u32
            info_type = await read_int(reader, 4)
            _size += 4

            # display_id: u32
            display_id = await read_int(reader, 4)
            _size += 4

            # name1: CString
            name1 = await read_cstring(reader)
            _size += len(name1) + 1

            # name2: CString
            name2 = await read_cstring(reader)
            _size += len(name2) + 1

            # name3: CString
            name3 = await read_cstring(reader)
            _size += len(name3) + 1

            # name4: CString
            name4 = await read_cstring(reader)
            _size += len(name4) + 1

            # icon_name: CString
            icon_name = await read_cstring(reader)
            _size += len(icon_name) + 1

            # cast_bar_caption: CString
            cast_bar_caption = await read_cstring(reader)
            _size += len(cast_bar_caption) + 1

            # unknown: CString
            unknown = await read_cstring(reader)
            _size += len(unknown) + 1

            # raw_data: u32[6]
            raw_data = []
            for _ in range(0, 6):
                raw_data.append(await read_int(reader, 4))
                _size += 4

            # gameobject_size: f32
            gameobject_size = await read_float(reader)
            _size += 4

        return SMSG_GAMEOBJECT_QUERY_RESPONSE(
            entry_id=entry_id,
            info_type=info_type,
            display_id=display_id,
            name1=name1,
            name2=name2,
            name3=name3,
            name4=name4,
            icon_name=icon_name,
            cast_bar_caption=cast_bar_caption,
            unknown=unknown,
            raw_data=raw_data,
            gameobject_size=gameobject_size,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x005F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.entry_id)
        # found: optional
        if self.info_type is not None and self.display_id is not None and self.name1 is not None and self.name2 is not None and self.name3 is not None and self.name4 is not None and self.icon_name is not None and self.cast_bar_caption is not None and self.unknown is not None and self.raw_data is not None and self.gameobject_size is not None:
            _fmt += f'II{len(self.name1)}sB{len(self.name2)}sB{len(self.name3)}sB{len(self.name4)}sB{len(self.icon_name)}sB{len(self.cast_bar_caption)}sB{len(self.unknown)}sB{len(self.raw_data)}If'
            _data.extend([self.info_type, self.display_id, self.name1.encode('utf-8'), 0, self.name2.encode('utf-8'), 0, self.name3.encode('utf-8'), 0, self.name4.encode('utf-8'), 0, self.icon_name.encode('utf-8'), 0, self.cast_bar_caption.encode('utf-8'), 0, self.unknown.encode('utf-8'), 0, *self.raw_data, self.gameobject_size])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        # found: optional
        if self.info_type is not None and self.display_id is not None and self.name1 is not None and self.name2 is not None and self.name3 is not None and self.name4 is not None and self.icon_name is not None and self.cast_bar_caption is not None and self.unknown is not None and self.raw_data is not None and self.gameobject_size is not None:
            _size += 43 + len(self.name1) + len(self.name2) + len(self.name3) + len(self.name4) + len(self.icon_name) + len(self.cast_bar_caption) + len(self.unknown)

        return _size


@dataclasses.dataclass
class CMSG_CREATURE_QUERY:
    creature: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CREATURE_QUERY:
        # creature: u32
        creature = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_CREATURE_QUERY(
            creature=creature,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0060))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.creature, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CREATURE_QUERY_RESPONSE:
    creature_entry: int
    name1: typing.Optional[str] = None
    name2: typing.Optional[str] = None
    name3: typing.Optional[str] = None
    name4: typing.Optional[str] = None
    sub_name: typing.Optional[str] = None
    description: typing.Optional[str] = None
    type_flags: typing.Optional[int] = None
    creature_type: typing.Optional[int] = None
    creature_family: typing.Optional[CreatureFamily] = None
    creature_rank: typing.Optional[int] = None
    unknown0: typing.Optional[int] = None
    spell_data_id: typing.Optional[int] = None
    display_ids: typing.Optional[typing.List[int]] = None
    health_multiplier: typing.Optional[float] = None
    mana_multiplier: typing.Optional[float] = None
    racial_leader: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CREATURE_QUERY_RESPONSE:
        name1 = None
        name2 = None
        name3 = None
        name4 = None
        sub_name = None
        description = None
        type_flags = None
        creature_type = None
        creature_family = None
        creature_rank = None
        unknown0 = None
        spell_data_id = None
        display_ids = None
        health_multiplier = None
        mana_multiplier = None
        racial_leader = None
        _size = 0

        # creature_entry: u32
        creature_entry = await read_int(reader, 4)
        _size += 4

        # found: optional
        if _size < body_size:
            # name1: CString
            name1 = await read_cstring(reader)
            _size += len(name1) + 1

            # name2: CString
            name2 = await read_cstring(reader)
            _size += len(name2) + 1

            # name3: CString
            name3 = await read_cstring(reader)
            _size += len(name3) + 1

            # name4: CString
            name4 = await read_cstring(reader)
            _size += len(name4) + 1

            # sub_name: CString
            sub_name = await read_cstring(reader)
            _size += len(sub_name) + 1

            # description: CString
            description = await read_cstring(reader)
            _size += len(description) + 1

            # type_flags: u32
            type_flags = await read_int(reader, 4)
            _size += 4

            # creature_type: u32
            creature_type = await read_int(reader, 4)
            _size += 4

            # creature_family: CreatureFamily
            creature_family = CreatureFamily(await read_int(reader, 4))
            _size += 4

            # creature_rank: u32
            creature_rank = await read_int(reader, 4)
            _size += 4

            # unknown0: u32
            unknown0 = await read_int(reader, 4)
            _size += 4

            # spell_data_id: u32
            spell_data_id = await read_int(reader, 4)
            _size += 4

            # display_ids: u32[4]
            display_ids = []
            for _ in range(0, 4):
                display_ids.append(await read_int(reader, 4))
                _size += 4

            # health_multiplier: f32
            health_multiplier = await read_float(reader)
            _size += 4

            # mana_multiplier: f32
            mana_multiplier = await read_float(reader)
            _size += 4

            # racial_leader: u8
            racial_leader = await read_int(reader, 1)
            _size += 1

        return SMSG_CREATURE_QUERY_RESPONSE(
            creature_entry=creature_entry,
            name1=name1,
            name2=name2,
            name3=name3,
            name4=name4,
            sub_name=sub_name,
            description=description,
            type_flags=type_flags,
            creature_type=creature_type,
            creature_family=creature_family,
            creature_rank=creature_rank,
            unknown0=unknown0,
            spell_data_id=spell_data_id,
            display_ids=display_ids,
            health_multiplier=health_multiplier,
            mana_multiplier=mana_multiplier,
            racial_leader=racial_leader,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0061))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.creature_entry)
        # found: optional
        if self.name1 is not None and self.name2 is not None and self.name3 is not None and self.name4 is not None and self.sub_name is not None and self.description is not None and self.type_flags is not None and self.creature_type is not None and self.creature_family is not None and self.creature_rank is not None and self.unknown0 is not None and self.spell_data_id is not None and self.display_ids is not None and self.health_multiplier is not None and self.mana_multiplier is not None and self.racial_leader is not None:
            _fmt += f'{len(self.name1)}sB{len(self.name2)}sB{len(self.name3)}sB{len(self.name4)}sB{len(self.sub_name)}sB{len(self.description)}sBIIIIII{len(self.display_ids)}IffB'
            _data.extend([self.name1.encode('utf-8'), 0, self.name2.encode('utf-8'), 0, self.name3.encode('utf-8'), 0, self.name4.encode('utf-8'), 0, self.sub_name.encode('utf-8'), 0, self.description.encode('utf-8'), 0, self.type_flags, self.creature_type, self.creature_family.value, self.creature_rank, self.unknown0, self.spell_data_id, *self.display_ids, self.health_multiplier, self.mana_multiplier, self.racial_leader])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        # found: optional
        if self.name1 is not None and self.name2 is not None and self.name3 is not None and self.name4 is not None and self.sub_name is not None and self.description is not None and self.type_flags is not None and self.creature_type is not None and self.creature_family is not None and self.creature_rank is not None and self.unknown0 is not None and self.spell_data_id is not None and self.display_ids is not None and self.health_multiplier is not None and self.mana_multiplier is not None and self.racial_leader is not None:
            _size += 55 + len(self.name1) + len(self.name2) + len(self.name3) + len(self.name4) + len(self.sub_name) + len(self.description)

        return _size


@dataclasses.dataclass
class CMSG_WHO:
    minimum_level: int
    maximum_level: int
    player_name: str
    guild_name: str
    race_mask: int
    class_mask: int
    zones: typing.List[int]
    search_strings: typing.List[str]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_WHO:
        # minimum_level: Level32
        minimum_level = await read_int(reader, 4)

        # maximum_level: Level32
        maximum_level = await read_int(reader, 4)

        # player_name: CString
        player_name = await read_cstring(reader)

        # guild_name: CString
        guild_name = await read_cstring(reader)

        # race_mask: u32
        race_mask = await read_int(reader, 4)

        # class_mask: u32
        class_mask = await read_int(reader, 4)

        # amount_of_zones: u32
        amount_of_zones = await read_int(reader, 4)

        # zones: u32[amount_of_zones]
        zones = []
        for _ in range(0, amount_of_zones):
            zones.append(await read_int(reader, 4))

        # amount_of_strings: u32
        amount_of_strings = await read_int(reader, 4)

        # search_strings: CString[amount_of_strings]
        search_strings = []
        for _ in range(0, amount_of_strings):
            search_strings.append(await read_cstring(reader))

        return CMSG_WHO(
            minimum_level=minimum_level,
            maximum_level=maximum_level,
            player_name=player_name,
            guild_name=guild_name,
            race_mask=race_mask,
            class_mask=class_mask,
            zones=zones,
            search_strings=search_strings,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0062))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'II{len(self.player_name)}sB{len(self.guild_name)}sBIII{len(self.zones)}II'
        _data.extend([self.minimum_level, self.maximum_level, self.player_name.encode('utf-8'), 0, self.guild_name.encode('utf-8'), 0, self.race_mask, self.class_mask, len(self.zones), *self.zones, len(self.search_strings)])
        # search_strings: CString[amount_of_strings]
        for i in self.search_strings:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 26 + len(self.player_name) + len(self.guild_name) + 4 * len(self.zones) + sum([len(i) + 1 for i in self.search_strings])


@dataclasses.dataclass
class SMSG_WHO:
    online_players: int
    players: typing.List[WhoPlayer]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_WHO:
        # listed_players: u32
        listed_players = await read_int(reader, 4)

        # online_players: u32
        online_players = await read_int(reader, 4)

        # players: WhoPlayer[listed_players]
        players = []
        for _ in range(0, listed_players):
            players.append(await WhoPlayer.read(reader))

        return SMSG_WHO(
            online_players=online_players,
            players=players,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0063))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([len(self.players), self.online_players])
        # players: WhoPlayer[listed_players]
        for i in self.players:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + sum([i.size() for i in self.players])


@dataclasses.dataclass
class CMSG_WHOIS:
    character: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_WHOIS:
        # character: CString
        character = await read_cstring(reader)

        return CMSG_WHOIS(
            character=character,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0064))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.character)}sB'
        _data.extend([self.character.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.character)


@dataclasses.dataclass
class SMSG_WHOIS:
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_WHOIS:
        # message: CString
        message = await read_cstring(reader)

        return SMSG_WHOIS(
            message=message,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0065))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.message)}sB'
        _data.extend([self.message.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.message)


@dataclasses.dataclass
class CMSG_CONTACT_LIST:
    flags: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CONTACT_LIST:
        # flags: u32
        flags = await read_int(reader, 4)

        return CMSG_CONTACT_LIST(
            flags=flags,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0066))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.flags)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CONTACT_LIST:
    list_mask: RelationType
    relations: typing.List[Relation]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CONTACT_LIST:
        # list_mask: RelationType
        list_mask = RelationType(await read_int(reader, 4))

        # amount_of_relations: u32
        amount_of_relations = await read_int(reader, 4)

        # relations: Relation[amount_of_relations]
        relations = []
        for _ in range(0, amount_of_relations):
            relations.append(await Relation.read(reader))

        return SMSG_CONTACT_LIST(
            list_mask=list_mask,
            relations=relations,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0067))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.list_mask.value, len(self.relations)])
        # relations: Relation[amount_of_relations]
        for i in self.relations:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + sum([i.size() for i in self.relations])


@dataclasses.dataclass
class SMSG_FRIEND_STATUS:
    result: FriendResult
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FRIEND_STATUS:
        # result: FriendResult
        result = FriendResult(await read_int(reader, 1))

        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_FRIEND_STATUS(
            result=result,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x0068))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BQ'
        _data.extend([self.result.value, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ADD_FRIEND:
    name: str
    note: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ADD_FRIEND:
        # name: CString
        name = await read_cstring(reader)

        # note: CString
        note = await read_cstring(reader)

        return CMSG_ADD_FRIEND(
            name=name,
            note=note,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0069))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB{len(self.note)}sB'
        _data.extend([self.name.encode('utf-8'), 0, self.note.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.name) + len(self.note)


@dataclasses.dataclass
class CMSG_DEL_FRIEND:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_DEL_FRIEND:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_DEL_FRIEND(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x006A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_CONTACT_NOTES:
    player: int
    note: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_CONTACT_NOTES:
        # player: Guid
        player = await read_int(reader, 8)

        # note: CString
        note = await read_cstring(reader)

        return CMSG_SET_CONTACT_NOTES(
            player=player,
            note=note,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x006B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.note)}sB'
        _data.extend([self.player, self.note.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.note)


@dataclasses.dataclass
class CMSG_ADD_IGNORE:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ADD_IGNORE:
        # name: CString
        name = await read_cstring(reader)

        return CMSG_ADD_IGNORE(
            name=name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x006C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class CMSG_DEL_IGNORE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_DEL_IGNORE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_DEL_IGNORE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x006D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_INVITE:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_INVITE:
        # name: CString
        name = await read_cstring(reader)

        return CMSG_GROUP_INVITE(
            name=name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x006E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class SMSG_GROUP_INVITE:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GROUP_INVITE:
        # name: CString
        name = await read_cstring(reader)

        return SMSG_GROUP_INVITE(
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x006F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class CMSG_GROUP_CANCEL:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_CANCEL:
        return CMSG_GROUP_CANCEL()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0070))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_ACCEPT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_ACCEPT:
        return CMSG_GROUP_ACCEPT()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0072))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_DECLINE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_DECLINE:
        return CMSG_GROUP_DECLINE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0073))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GROUP_DECLINE:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GROUP_DECLINE:
        # name: CString
        name = await read_cstring(reader)

        return SMSG_GROUP_DECLINE(
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0074))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class CMSG_GROUP_UNINVITE:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_UNINVITE:
        # name: CString
        name = await read_cstring(reader)

        return CMSG_GROUP_UNINVITE(
            name=name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0075))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class CMSG_GROUP_UNINVITE_GUID:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_UNINVITE_GUID:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_GROUP_UNINVITE_GUID(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0076))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GROUP_UNINVITE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GROUP_UNINVITE:
        return SMSG_GROUP_UNINVITE()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0077))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_SET_LEADER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_SET_LEADER:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_GROUP_SET_LEADER(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0078))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GROUP_SET_LEADER:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GROUP_SET_LEADER:
        # name: CString
        name = await read_cstring(reader)

        return SMSG_GROUP_SET_LEADER(
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0079))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class CMSG_LOOT_METHOD:
    loot_setting: GroupLootSetting
    loot_master: int
    loot_threshold: ItemQuality

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOOT_METHOD:
        # loot_setting: GroupLootSetting
        loot_setting = GroupLootSetting(await read_int(reader, 4))

        # loot_master: Guid
        loot_master = await read_int(reader, 8)

        # loot_threshold: ItemQuality
        loot_threshold = ItemQuality(await read_int(reader, 4))

        return CMSG_LOOT_METHOD(
            loot_setting=loot_setting,
            loot_master=loot_master,
            loot_threshold=loot_threshold,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x007A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQI'
        _data.extend([self.loot_setting.value, self.loot_master, self.loot_threshold.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_DISBAND:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_DISBAND:
        return CMSG_GROUP_DISBAND()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x007B))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GROUP_DESTROYED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GROUP_DESTROYED:
        return SMSG_GROUP_DESTROYED()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x007C))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GROUP_LIST:
    group_type: GroupType
    battleground_group: bool
    group_id: int
    flags: int
    group: int
    members: typing.List[GroupListMember]
    leader: int
    loot_setting: typing.Optional[GroupLootSetting] = None
    master_loot: typing.Optional[int] = None
    loot_threshold: typing.Optional[ItemQuality] = None
    difficulty: typing.Optional[DungeonDifficulty] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GROUP_LIST:
        loot_setting = None
        master_loot = None
        loot_threshold = None
        difficulty = None
        _size = 0

        # group_type: GroupType
        group_type = GroupType(await read_int(reader, 1))
        _size += 1

        # battleground_group: Bool8
        battleground_group = await read_bool(reader, 1)
        _size += 1

        # group_id: u8
        group_id = await read_int(reader, 1)
        _size += 1

        # flags: u8
        flags = await read_int(reader, 1)
        _size += 1

        # group: Guid
        group = await read_int(reader, 8)
        _size += 8

        # amount_of_members: u32
        amount_of_members = await read_int(reader, 4)
        _size += 4

        # members: GroupListMember[amount_of_members]
        members = []
        for _ in range(0, amount_of_members):
            members.append(await GroupListMember.read(reader))
            _size += members[-1].size()

        # leader: Guid
        leader = await read_int(reader, 8)
        _size += 8

        # group_not_empty: optional
        if _size < body_size:
            # loot_setting: GroupLootSetting
            loot_setting = GroupLootSetting(await read_int(reader, 1))
            _size += 1

            # master_loot: Guid
            master_loot = await read_int(reader, 8)
            _size += 8

            # loot_threshold: ItemQuality
            loot_threshold = ItemQuality(await read_int(reader, 1))
            _size += 1

            # difficulty: DungeonDifficulty
            difficulty = DungeonDifficulty(await read_int(reader, 1))
            _size += 1

        return SMSG_GROUP_LIST(
            group_type=group_type,
            battleground_group=battleground_group,
            group_id=group_id,
            flags=flags,
            group=group,
            members=members,
            leader=leader,
            loot_setting=loot_setting,
            master_loot=master_loot,
            loot_threshold=loot_threshold,
            difficulty=difficulty,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x007D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BBBBQI'
        _data.extend([self.group_type.value, self.battleground_group, self.group_id, self.flags, self.group, len(self.members)])
        # members: GroupListMember[amount_of_members]
        for i in self.members:
            _fmt, _data = i.write(_fmt, _data)

        # leader: Guid
        _fmt += 'Q'
        _data.append(self.leader)

        # group_not_empty: optional
        if self.loot_setting is not None and self.master_loot is not None and self.loot_threshold is not None and self.difficulty is not None:
            _fmt += 'BQBB'
            _data.extend([self.loot_setting.value, self.master_loot, self.loot_threshold.value, self.difficulty.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 24 + sum([i.size() for i in self.members])

        # group_not_empty: optional
        if self.loot_setting is not None and self.master_loot is not None and self.loot_threshold is not None and self.difficulty is not None:
            _size += 11

        return _size


@dataclasses.dataclass
class SMSG_PARTY_MEMBER_STATS:
    guid: int
    mask: GroupUpdateFlags
    status: typing.Optional[GroupMemberOnlineStatus] = None
    current_health: typing.Optional[int] = None
    max_health: typing.Optional[int] = None
    power: typing.Optional[Power] = None
    current_power: typing.Optional[int] = None
    max_power: typing.Optional[int] = None
    level: typing.Optional[int] = None
    area: typing.Optional[Area] = None
    position_x: typing.Optional[int] = None
    position_y: typing.Optional[int] = None
    auras: typing.Optional[AuraMask] = None
    pet: typing.Optional[int] = None
    pet_name: typing.Optional[str] = None
    pet_display_id: typing.Optional[int] = None
    pet_current_health: typing.Optional[int] = None
    pet_max_health: typing.Optional[int] = None
    pet_power_type: typing.Optional[Power] = None
    pet_current_power: typing.Optional[int] = None
    pet_max_power: typing.Optional[int] = None
    pet_auras: typing.Optional[AuraMask] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PARTY_MEMBER_STATS:
        status = None
        current_health = None
        max_health = None
        power = None
        current_power = None
        max_power = None
        level = None
        area = None
        position_x = None
        position_y = None
        auras = None
        pet = None
        pet_name = None
        pet_display_id = None
        pet_current_health = None
        pet_max_health = None
        pet_power_type = None
        pet_current_power = None
        pet_max_power = None
        pet_auras = None
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # mask: GroupUpdateFlags
        mask = GroupUpdateFlags(await read_int(reader, 4))

        if GroupUpdateFlags.STATUS in mask:
            # status: GroupMemberOnlineStatus
            status = GroupMemberOnlineStatus(await read_int(reader, 1))

        if GroupUpdateFlags.CUR_HP in mask:
            # current_health: u16
            current_health = await read_int(reader, 2)

        if GroupUpdateFlags.MAX_HP in mask:
            # max_health: u16
            max_health = await read_int(reader, 2)

        if GroupUpdateFlags.POWER_TYPE in mask:
            # power: Power
            power = Power(await read_int(reader, 1))

        if GroupUpdateFlags.CUR_POWER in mask:
            # current_power: u16
            current_power = await read_int(reader, 2)

        if GroupUpdateFlags.MAX_POWER in mask:
            # max_power: u16
            max_power = await read_int(reader, 2)

        if GroupUpdateFlags.LEVEL in mask:
            # level: Level16
            level = await read_int(reader, 2)

        if GroupUpdateFlags.ZONE in mask:
            # area: Area
            area = Area(await read_int(reader, 4))

        if GroupUpdateFlags.POSITION in mask:
            # position_x: u16
            position_x = await read_int(reader, 2)

            # position_y: u16
            position_y = await read_int(reader, 2)

        if GroupUpdateFlags.AURAS in mask:
            # auras: AuraMask
            auras = await AuraMask.read(reader)

        if GroupUpdateFlags.PET_GUID in mask:
            # pet: Guid
            pet = await read_int(reader, 8)

        if GroupUpdateFlags.PET_NAME in mask:
            # pet_name: CString
            pet_name = await read_cstring(reader)

        if GroupUpdateFlags.PET_MODEL_ID in mask:
            # pet_display_id: u16
            pet_display_id = await read_int(reader, 2)

        if GroupUpdateFlags.PET_CUR_HP in mask:
            # pet_current_health: u16
            pet_current_health = await read_int(reader, 2)

        if GroupUpdateFlags.PET_MAX_HP in mask:
            # pet_max_health: u16
            pet_max_health = await read_int(reader, 2)

        if GroupUpdateFlags.PET_POWER_TYPE in mask:
            # pet_power_type: Power
            pet_power_type = Power(await read_int(reader, 1))

        if GroupUpdateFlags.PET_CUR_POWER in mask:
            # pet_current_power: u16
            pet_current_power = await read_int(reader, 2)

        if GroupUpdateFlags.PET_MAX_POWER in mask:
            # pet_max_power: u16
            pet_max_power = await read_int(reader, 2)

        if GroupUpdateFlags.PET_AURAS in mask:
            # pet_auras: AuraMask
            pet_auras = await AuraMask.read(reader)

        return SMSG_PARTY_MEMBER_STATS(
            guid=guid,
            mask=mask,
            status=status,
            current_health=current_health,
            max_health=max_health,
            power=power,
            current_power=current_power,
            max_power=max_power,
            level=level,
            area=area,
            position_x=position_x,
            position_y=position_y,
            auras=auras,
            pet=pet,
            pet_name=pet_name,
            pet_display_id=pet_display_id,
            pet_current_health=pet_current_health,
            pet_max_health=pet_max_health,
            pet_power_type=pet_power_type,
            pet_current_power=pet_current_power,
            pet_max_power=pet_max_power,
            pet_auras=pet_auras,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x007E))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # mask: GroupUpdateFlags
        _fmt += 'I'
        _data.append(self.mask.value)

        if GroupUpdateFlags.STATUS in self.mask:
            _fmt += 'B'
            _data.append(self.status.value)
        if GroupUpdateFlags.CUR_HP in self.mask:
            _fmt += 'H'
            _data.append(self.current_health)
        if GroupUpdateFlags.MAX_HP in self.mask:
            _fmt += 'H'
            _data.append(self.max_health)
        if GroupUpdateFlags.POWER_TYPE in self.mask:
            _fmt += 'B'
            _data.append(self.power.value)
        if GroupUpdateFlags.CUR_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.current_power)
        if GroupUpdateFlags.MAX_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.max_power)
        if GroupUpdateFlags.LEVEL in self.mask:
            _fmt += 'H'
            _data.append(self.level)
        if GroupUpdateFlags.ZONE in self.mask:
            _fmt += 'I'
            _data.append(self.area.value)
        if GroupUpdateFlags.POSITION in self.mask:
            _fmt += 'HH'
            _data.extend([self.position_x, self.position_y])
        if GroupUpdateFlags.AURAS in self.mask:
            # auras: AuraMask
            _fmt, _data = self.auras.write(_fmt, _data)

        if GroupUpdateFlags.PET_GUID in self.mask:
            _fmt += 'Q'
            _data.append(self.pet)
        if GroupUpdateFlags.PET_NAME in self.mask:
            _fmt += f'{len(self.pet_name)}sB'
            _data.extend([self.pet_name.encode('utf-8'), 0])
        if GroupUpdateFlags.PET_MODEL_ID in self.mask:
            _fmt += 'H'
            _data.append(self.pet_display_id)
        if GroupUpdateFlags.PET_CUR_HP in self.mask:
            _fmt += 'H'
            _data.append(self.pet_current_health)
        if GroupUpdateFlags.PET_MAX_HP in self.mask:
            _fmt += 'H'
            _data.append(self.pet_max_health)
        if GroupUpdateFlags.PET_POWER_TYPE in self.mask:
            _fmt += 'B'
            _data.append(self.pet_power_type.value)
        if GroupUpdateFlags.PET_CUR_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.pet_current_power)
        if GroupUpdateFlags.PET_MAX_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.pet_max_power)
        if GroupUpdateFlags.PET_AURAS in self.mask:
            # pet_auras: AuraMask
            _fmt, _data = self.pet_auras.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4 + packed_guid_size(self.guid)

        if GroupUpdateFlags.STATUS in self.mask:
            _size += 1

        if GroupUpdateFlags.CUR_HP in self.mask:
            _size += 2

        if GroupUpdateFlags.MAX_HP in self.mask:
            _size += 2

        if GroupUpdateFlags.POWER_TYPE in self.mask:
            _size += 1

        if GroupUpdateFlags.CUR_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.MAX_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.LEVEL in self.mask:
            _size += 2

        if GroupUpdateFlags.ZONE in self.mask:
            _size += 4

        if GroupUpdateFlags.POSITION in self.mask:
            _size += 4

        if GroupUpdateFlags.AURAS in self.mask:
            _size += 0 + self.auras.size()

        if GroupUpdateFlags.PET_GUID in self.mask:
            _size += 8

        if GroupUpdateFlags.PET_NAME in self.mask:
            _size += 1 + len(self.pet_name)

        if GroupUpdateFlags.PET_MODEL_ID in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_CUR_HP in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_MAX_HP in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_POWER_TYPE in self.mask:
            _size += 1

        if GroupUpdateFlags.PET_CUR_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_MAX_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_AURAS in self.mask:
            _size += 0 + self.pet_auras.size()

        return _size


@dataclasses.dataclass
class SMSG_PARTY_COMMAND_RESULT:
    operation: PartyOperation
    member: str
    result: PartyResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PARTY_COMMAND_RESULT:
        # operation: PartyOperation
        operation = PartyOperation(await read_int(reader, 4))

        # member: CString
        member = await read_cstring(reader)

        # result: PartyResult
        result = PartyResult(await read_int(reader, 4))

        return SMSG_PARTY_COMMAND_RESULT(
            operation=operation,
            member=member,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x007F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.member)}sBI'
        _data.extend([self.operation.value, self.member.encode('utf-8'), 0, self.result.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.member)


@dataclasses.dataclass
class CMSG_GUILD_CREATE:
    guild_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_CREATE:
        # guild_name: CString
        guild_name = await read_cstring(reader)

        return CMSG_GUILD_CREATE(
            guild_name=guild_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0081))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.guild_name)}sB'
        _data.extend([self.guild_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.guild_name)


@dataclasses.dataclass
class CMSG_GUILD_INVITE:
    invited_player: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_INVITE:
        # invited_player: CString
        invited_player = await read_cstring(reader)

        return CMSG_GUILD_INVITE(
            invited_player=invited_player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0082))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.invited_player)}sB'
        _data.extend([self.invited_player.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.invited_player)


@dataclasses.dataclass
class SMSG_GUILD_INVITE:
    player_name: str
    guild_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_INVITE:
        # player_name: CString
        player_name = await read_cstring(reader)

        # guild_name: CString
        guild_name = await read_cstring(reader)

        return SMSG_GUILD_INVITE(
            player_name=player_name,
            guild_name=guild_name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0083))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.player_name)}sB{len(self.guild_name)}sB'
        _data.extend([self.player_name.encode('utf-8'), 0, self.guild_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.player_name) + len(self.guild_name)


@dataclasses.dataclass
class CMSG_GUILD_ACCEPT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_ACCEPT:
        return CMSG_GUILD_ACCEPT()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0084))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_DECLINE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_DECLINE:
        return CMSG_GUILD_DECLINE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0085))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GUILD_DECLINE:
    player: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_DECLINE:
        # player: CString
        player = await read_cstring(reader)

        return SMSG_GUILD_DECLINE(
            player=player,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0086))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.player)}sB'
        _data.extend([self.player.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.player)


@dataclasses.dataclass
class CMSG_GUILD_INFO:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_INFO:
        return CMSG_GUILD_INFO()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0087))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GUILD_INFO:
    guild_name: str
    created_day: int
    created_month: int
    created_year: int
    amount_of_characters_in_guild: int
    amount_of_accounts_in_guild: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_INFO:
        # guild_name: CString
        guild_name = await read_cstring(reader)

        # created_day: u32
        created_day = await read_int(reader, 4)

        # created_month: u32
        created_month = await read_int(reader, 4)

        # created_year: u32
        created_year = await read_int(reader, 4)

        # amount_of_characters_in_guild: u32
        amount_of_characters_in_guild = await read_int(reader, 4)

        # amount_of_accounts_in_guild: u32
        amount_of_accounts_in_guild = await read_int(reader, 4)

        return SMSG_GUILD_INFO(
            guild_name=guild_name,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            amount_of_characters_in_guild=amount_of_characters_in_guild,
            amount_of_accounts_in_guild=amount_of_accounts_in_guild,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0088))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.guild_name)}sBIIIII'
        _data.extend([self.guild_name.encode('utf-8'), 0, self.created_day, self.created_month, self.created_year, self.amount_of_characters_in_guild, self.amount_of_accounts_in_guild])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 21 + len(self.guild_name)


@dataclasses.dataclass
class CMSG_GUILD_ROSTER:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_ROSTER:
        return CMSG_GUILD_ROSTER()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0089))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GUILD_ROSTER:
    motd: str
    guild_info: str
    rights: typing.List[GuildRights]
    members: typing.List[GuildMember]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_ROSTER:
        # amount_of_members: u32
        amount_of_members = await read_int(reader, 4)

        # motd: CString
        motd = await read_cstring(reader)

        # guild_info: CString
        guild_info = await read_cstring(reader)

        # amount_of_rights: u32
        amount_of_rights = await read_int(reader, 4)

        # rights: GuildRights[amount_of_rights]
        rights = []
        for _ in range(0, amount_of_rights):
            rights.append(await GuildRights.read(reader))

        # members: GuildMember[amount_of_members]
        members = []
        for _ in range(0, amount_of_members):
            members.append(await GuildMember.read(reader))

        return SMSG_GUILD_ROSTER(
            motd=motd,
            guild_info=guild_info,
            rights=rights,
            members=members,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x008A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.motd)}sB{len(self.guild_info)}sBI'
        _data.extend([len(self.members), self.motd.encode('utf-8'), 0, self.guild_info.encode('utf-8'), 0, len(self.rights)])
        # rights: GuildRights[amount_of_rights]
        for i in self.rights:
            _fmt, _data = i.write(_fmt, _data)

        # members: GuildMember[amount_of_members]
        for i in self.members:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 10 + len(self.motd) + len(self.guild_info) + 56 * len(self.rights) + sum([i.size() for i in self.members])


@dataclasses.dataclass
class CMSG_GUILD_PROMOTE:
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_PROMOTE:
        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_GUILD_PROMOTE(
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x008B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.player_name)}sB'
        _data.extend([self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.player_name)


@dataclasses.dataclass
class CMSG_GUILD_DEMOTE:
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_DEMOTE:
        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_GUILD_DEMOTE(
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x008C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.player_name)}sB'
        _data.extend([self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.player_name)


@dataclasses.dataclass
class CMSG_GUILD_LEAVE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_LEAVE:
        return CMSG_GUILD_LEAVE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x008D))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_REMOVE:
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_REMOVE:
        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_GUILD_REMOVE(
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x008E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.player_name)}sB'
        _data.extend([self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.player_name)


@dataclasses.dataclass
class CMSG_GUILD_DISBAND:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_DISBAND:
        return CMSG_GUILD_DISBAND()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x008F))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_LEADER:
    new_guild_leader_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_LEADER:
        # new_guild_leader_name: CString
        new_guild_leader_name = await read_cstring(reader)

        return CMSG_GUILD_LEADER(
            new_guild_leader_name=new_guild_leader_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0090))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.new_guild_leader_name)}sB'
        _data.extend([self.new_guild_leader_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.new_guild_leader_name)


@dataclasses.dataclass
class CMSG_GUILD_MOTD:
    message_of_the_day: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_MOTD:
        # message_of_the_day: CString
        message_of_the_day = await read_cstring(reader)

        return CMSG_GUILD_MOTD(
            message_of_the_day=message_of_the_day,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0091))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.message_of_the_day)}sB'
        _data.extend([self.message_of_the_day.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.message_of_the_day)


@dataclasses.dataclass
class SMSG_GUILD_EVENT:
    event: GuildEvent
    event_descriptions: typing.List[str]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_EVENT:
        # event: GuildEvent
        event = GuildEvent(await read_int(reader, 1))

        # amount_of_events: u8
        amount_of_events = await read_int(reader, 1)

        # event_descriptions: CString[amount_of_events]
        event_descriptions = []
        for _ in range(0, amount_of_events):
            event_descriptions.append(await read_cstring(reader))

        return SMSG_GUILD_EVENT(
            event=event,
            event_descriptions=event_descriptions,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0092))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.event.value, len(self.event_descriptions)])
        # event_descriptions: CString[amount_of_events]
        for i in self.event_descriptions:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + sum([len(i) + 1 for i in self.event_descriptions])


@dataclasses.dataclass
class SMSG_GUILD_COMMAND_RESULT:
    command: GuildCommand
    string: str
    result: GuildCommandResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_COMMAND_RESULT:
        # command: GuildCommand
        command = GuildCommand(await read_int(reader, 4))

        # string: CString
        string = await read_cstring(reader)

        # result: GuildCommandResult
        result = GuildCommandResult(await read_int(reader, 4))

        return SMSG_GUILD_COMMAND_RESULT(
            command=command,
            string=string,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0093))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.string)}sBI'
        _data.extend([self.command.value, self.string.encode('utf-8'), 0, self.result.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.string)


@dataclasses.dataclass
class CMSG_MESSAGECHAT:
    chat_type: ChatType
    language: Language
    message: str
    target_player: typing.Optional[str] = None
    channel: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MESSAGECHAT:
        target_player = None
        channel = None
        # chat_type: ChatType
        chat_type = ChatType(await read_int(reader, 4))

        # language: Language
        language = Language(await read_int(reader, 4))

        if chat_type == ChatType.WHISPER:
            # target_player: CString
            target_player = await read_cstring(reader)

        elif chat_type == ChatType.CHANNEL:
            # channel: CString
            channel = await read_cstring(reader)

        # message: CString
        message = await read_cstring(reader)

        return CMSG_MESSAGECHAT(
            chat_type=chat_type,
            language=language,
            target_player=target_player,
            channel=channel,
            message=message,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0095))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.chat_type.value, self.language.value])
        if self.chat_type == ChatType.WHISPER:
            _fmt += f'{len(self.target_player)}sB'
            _data.extend([self.target_player.encode('utf-8'), 0])
        elif self.chat_type == ChatType.CHANNEL:
            _fmt += f'{len(self.channel)}sB'
            _data.extend([self.channel.encode('utf-8'), 0])
        # message: CString
        _fmt += f'{len(self.message)}sB'
        _data.extend([self.message.encode('utf-8'), 0])

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 9 + len(self.message)

        if self.chat_type == ChatType.WHISPER:
            _size += 1 + len(self.target_player)
        elif self.chat_type == ChatType.CHANNEL:
            _size += 1 + len(self.channel)

        return _size


@dataclasses.dataclass
class SMSG_MESSAGECHAT:
    chat_type: ChatType
    language: Language
    message: str
    tag: PlayerChatTag
    sender: typing.Optional[str] = None
    target1: typing.Optional[NamedGUID] = None
    target2: typing.Optional[NamedGUID] = None
    channel_name: typing.Optional[str] = None
    target4: typing.Optional[int] = None
    target5: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MESSAGECHAT:
        sender = None
        target1 = None
        target2 = None
        channel_name = None
        target4 = None
        target5 = None
        # chat_type: ChatType
        chat_type = ChatType(await read_int(reader, 1))

        # language: Language
        language = Language(await read_int(reader, 4))

        if chat_type in {ChatType.MONSTER_SAY, ChatType.MONSTER_PARTY, ChatType.MONSTER_YELL, ChatType.MONSTER_WHISPER, ChatType.RAID_BOSS_WHISPER, ChatType.RAID_BOSS_EMOTE, ChatType.MONSTER_EMOTE}:
            # sender: SizedCString
            sender = await read_sized_cstring(reader)

            # target1: NamedGuid
            target1 = await NamedGuid.read(reader)

        elif chat_type in {ChatType.BG_SYSTEM_NEUTRAL, ChatType.BG_SYSTEM_ALLIANCE, ChatType.BG_SYSTEM_HORDE}:
            # target2: NamedGuid
            target2 = await NamedGuid.read(reader)

        elif chat_type == ChatType.CHANNEL:
            # channel_name: CString
            channel_name = await read_cstring(reader)

            # target4: Guid
            target4 = await read_int(reader, 8)

        elif chat_type in {ChatType.SYSTEM, ChatType.SAY, ChatType.PARTY, ChatType.RAID, ChatType.GUILD, ChatType.OFFICER, ChatType.YELL, ChatType.WHISPER, ChatType.WHISPER_INFORM, ChatType.REPLY, ChatType.EMOTE, ChatType.TEXT_EMOTE, ChatType.CHANNEL_JOIN, ChatType.CHANNEL_LEAVE, ChatType.CHANNEL_LIST, ChatType.CHANNEL_NOTICE, ChatType.CHANNEL_NOTICE_USER, ChatType.AFK, ChatType.DND, ChatType.IGNORED, ChatType.SKILL, ChatType.LOOT, ChatType.MONEY, ChatType.OPENING, ChatType.TRADESKILLS, ChatType.PET_INFO, ChatType.COMBAT_MISC_INFO, ChatType.COMBAT_XP_GAIN, ChatType.COMBAT_HONOR_GAIN, ChatType.COMBAT_FACTION_CHANGE, ChatType.RAID_LEADER, ChatType.RAID_WARNING, ChatType.FILTERED, ChatType.BATTLEGROUND, ChatType.BATTLEGROUND_LEADER, ChatType.RESTRICTED}:
            # target5: Guid
            target5 = await read_int(reader, 8)

        # message: SizedCString
        message = await read_sized_cstring(reader)

        # tag: PlayerChatTag
        tag = PlayerChatTag(await read_int(reader, 1))

        return SMSG_MESSAGECHAT(
            chat_type=chat_type,
            language=language,
            sender=sender,
            target1=target1,
            target2=target2,
            channel_name=channel_name,
            target4=target4,
            target5=target5,
            message=message,
            tag=tag,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0096))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BI'
        _data.extend([self.chat_type.value, self.language.value])
        if self.chat_type in {ChatType.MONSTER_SAY, ChatType.MONSTER_PARTY, ChatType.MONSTER_YELL, ChatType.MONSTER_WHISPER, ChatType.RAID_BOSS_WHISPER, ChatType.RAID_BOSS_EMOTE, ChatType.MONSTER_EMOTE}:
            _fmt += f'I{len(self.sender)}sB'
            _data.extend([len(self.sender) + 1, self.sender.encode('utf-8'), 0])
            # target1: NamedGuid
            _fmt, _data = self.target1.write(_fmt, _data)

        elif self.chat_type in {ChatType.BG_SYSTEM_NEUTRAL, ChatType.BG_SYSTEM_ALLIANCE, ChatType.BG_SYSTEM_HORDE}:
            # target2: NamedGuid
            _fmt, _data = self.target2.write(_fmt, _data)

        elif self.chat_type == ChatType.CHANNEL:
            _fmt += f'{len(self.channel_name)}sBQ'
            _data.extend([self.channel_name.encode('utf-8'), 0, self.target4])
        elif self.chat_type in {ChatType.SYSTEM, ChatType.SAY, ChatType.PARTY, ChatType.RAID, ChatType.GUILD, ChatType.OFFICER, ChatType.YELL, ChatType.WHISPER, ChatType.WHISPER_INFORM, ChatType.REPLY, ChatType.EMOTE, ChatType.TEXT_EMOTE, ChatType.CHANNEL_JOIN, ChatType.CHANNEL_LEAVE, ChatType.CHANNEL_LIST, ChatType.CHANNEL_NOTICE, ChatType.CHANNEL_NOTICE_USER, ChatType.AFK, ChatType.DND, ChatType.IGNORED, ChatType.SKILL, ChatType.LOOT, ChatType.MONEY, ChatType.OPENING, ChatType.TRADESKILLS, ChatType.PET_INFO, ChatType.COMBAT_MISC_INFO, ChatType.COMBAT_XP_GAIN, ChatType.COMBAT_HONOR_GAIN, ChatType.COMBAT_FACTION_CHANGE, ChatType.RAID_LEADER, ChatType.RAID_WARNING, ChatType.FILTERED, ChatType.BATTLEGROUND, ChatType.BATTLEGROUND_LEADER, ChatType.RESTRICTED}:
            _fmt += 'Q'
            _data.append(self.target5)
        # message: SizedCString
        _fmt += f'I{len(self.message)}sB'
        _data.extend([len(self.message) + 1, self.message.encode('utf-8'), 0])

        # tag: PlayerChatTag
        _fmt += 'B'
        _data.append(self.tag.value)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 11 + len(self.message)

        if self.chat_type in {ChatType.MONSTER_SAY, ChatType.MONSTER_PARTY, ChatType.MONSTER_YELL, ChatType.MONSTER_WHISPER, ChatType.RAID_BOSS_WHISPER, ChatType.RAID_BOSS_EMOTE, ChatType.MONSTER_EMOTE}:
            _size += 5 + len(self.sender) + self.target1.size()
        elif self.chat_type in {ChatType.BG_SYSTEM_NEUTRAL, ChatType.BG_SYSTEM_ALLIANCE, ChatType.BG_SYSTEM_HORDE}:
            _size += 0 + self.target2.size()
        elif self.chat_type == ChatType.CHANNEL:
            _size += 9 + len(self.channel_name)
        elif self.chat_type in {ChatType.SYSTEM, ChatType.SAY, ChatType.PARTY, ChatType.RAID, ChatType.GUILD, ChatType.OFFICER, ChatType.YELL, ChatType.WHISPER, ChatType.WHISPER_INFORM, ChatType.REPLY, ChatType.EMOTE, ChatType.TEXT_EMOTE, ChatType.CHANNEL_JOIN, ChatType.CHANNEL_LEAVE, ChatType.CHANNEL_LIST, ChatType.CHANNEL_NOTICE, ChatType.CHANNEL_NOTICE_USER, ChatType.AFK, ChatType.DND, ChatType.IGNORED, ChatType.SKILL, ChatType.LOOT, ChatType.MONEY, ChatType.OPENING, ChatType.TRADESKILLS, ChatType.PET_INFO, ChatType.COMBAT_MISC_INFO, ChatType.COMBAT_XP_GAIN, ChatType.COMBAT_HONOR_GAIN, ChatType.COMBAT_FACTION_CHANGE, ChatType.RAID_LEADER, ChatType.RAID_WARNING, ChatType.FILTERED, ChatType.BATTLEGROUND, ChatType.BATTLEGROUND_LEADER, ChatType.RESTRICTED}:
            _size += 8

        return _size


@dataclasses.dataclass
class CMSG_JOIN_CHANNEL:
    channel_id: int
    unknown1: int
    unknown2: int
    channel_name: str
    channel_password: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_JOIN_CHANNEL:
        # channel_id: u32
        channel_id = await read_int(reader, 4)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # unknown2: u8
        unknown2 = await read_int(reader, 1)

        # channel_name: CString
        channel_name = await read_cstring(reader)

        # channel_password: CString
        channel_password = await read_cstring(reader)

        return CMSG_JOIN_CHANNEL(
            channel_id=channel_id,
            unknown1=unknown1,
            unknown2=unknown2,
            channel_name=channel_name,
            channel_password=channel_password,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0097))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'IBB{len(self.channel_name)}sB{len(self.channel_password)}sB'
        _data.extend([self.channel_id, self.unknown1, self.unknown2, self.channel_name.encode('utf-8'), 0, self.channel_password.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + len(self.channel_name) + len(self.channel_password)


@dataclasses.dataclass
class CMSG_LEAVE_CHANNEL:
    channel_id: int
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LEAVE_CHANNEL:
        # channel_id: u32
        channel_id = await read_int(reader, 4)

        # channel_name: CString
        channel_name = await read_cstring(reader)

        return CMSG_LEAVE_CHANNEL(
            channel_id=channel_id,
            channel_name=channel_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0098))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'I{len(self.channel_name)}sB'
        _data.extend([self.channel_id, self.channel_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + len(self.channel_name)


@dataclasses.dataclass
class SMSG_CHANNEL_NOTIFY:
    notify_type: ChatNotify
    channel_name: str
    unknown2: typing.Optional[int] = None
    unkwown3: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHANNEL_NOTIFY:
        unknown2 = None
        unkwown3 = None
        _size = 0

        # notify_type: ChatNotify
        notify_type = ChatNotify(await read_int(reader, 1))
        _size += 1

        # channel_name: CString
        channel_name = await read_cstring(reader)
        _size += len(channel_name) + 1

        # unknown1: optional
        if _size < body_size:
            # unknown2: u32
            unknown2 = await read_int(reader, 4)
            _size += 4

            # unkwown3: u32
            unkwown3 = await read_int(reader, 4)
            _size += 4

        return SMSG_CHANNEL_NOTIFY(
            notify_type=notify_type,
            channel_name=channel_name,
            unknown2=unknown2,
            unkwown3=unkwown3,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0099))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'B{len(self.channel_name)}sB'
        _data.extend([self.notify_type.value, self.channel_name.encode('utf-8'), 0])
        # unknown1: optional
        if self.unknown2 is not None and self.unkwown3 is not None:
            _fmt += 'II'
            _data.extend([self.unknown2, self.unkwown3])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 2 + len(self.channel_name)

        # unknown1: optional
        if self.unknown2 is not None and self.unkwown3 is not None:
            _size += 8

        return _size


@dataclasses.dataclass
class CMSG_CHANNEL_LIST:
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_LIST:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        return CMSG_CHANNEL_LIST(
            channel_name=channel_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x009A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.channel_name)


@dataclasses.dataclass
class SMSG_CHANNEL_LIST:
    channel_name: str
    channel_flags: ChannelFlags
    members: typing.List[ChannelMember]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHANNEL_LIST:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # channel_flags: ChannelFlags
        channel_flags = ChannelFlags(await read_int(reader, 1))

        # amount_of_members: u32
        amount_of_members = await read_int(reader, 4)

        # members: ChannelMember[amount_of_members]
        members = []
        for _ in range(0, amount_of_members):
            members.append(await ChannelMember.read(reader))

        return SMSG_CHANNEL_LIST(
            channel_name=channel_name,
            channel_flags=channel_flags,
            members=members,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x009B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sBBI'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.channel_flags.value, len(self.members)])
        # members: ChannelMember[amount_of_members]
        for i in self.members:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 6 + len(self.channel_name) + 9 * len(self.members)


@dataclasses.dataclass
class CMSG_CHANNEL_PASSWORD:
    channel_name: str
    channel_password: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_PASSWORD:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # channel_password: CString
        channel_password = await read_cstring(reader)

        return CMSG_CHANNEL_PASSWORD(
            channel_name=channel_name,
            channel_password=channel_password,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x009C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.channel_password)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.channel_password.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.channel_password)


@dataclasses.dataclass
class CMSG_CHANNEL_SET_OWNER:
    channel_name: str
    new_owner: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_SET_OWNER:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # new_owner: CString
        new_owner = await read_cstring(reader)

        return CMSG_CHANNEL_SET_OWNER(
            channel_name=channel_name,
            new_owner=new_owner,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x009D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.new_owner)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.new_owner.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.new_owner)


@dataclasses.dataclass
class CMSG_CHANNEL_OWNER:
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_OWNER:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        return CMSG_CHANNEL_OWNER(
            channel_name=channel_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x009E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.channel_name)


@dataclasses.dataclass
class CMSG_CHANNEL_MODERATOR:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_MODERATOR:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_MODERATOR(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x009F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_UNMODERATOR:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_UNMODERATOR:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_UNMODERATOR(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_MUTE:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_MUTE:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_MUTE(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A1))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_UNMUTE:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_UNMUTE:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_UNMUTE(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_INVITE:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_INVITE:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_INVITE(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_KICK:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_KICK:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_KICK(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A4))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_BAN:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_BAN:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_BAN(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A5))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_UNBAN:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_UNBAN:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_UNBAN(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A6))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_ANNOUNCEMENTS:
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_ANNOUNCEMENTS:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        return CMSG_CHANNEL_ANNOUNCEMENTS(
            channel_name=channel_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A7))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.channel_name)


@dataclasses.dataclass
class CMSG_CHANNEL_MODERATE:
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_MODERATE:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        return CMSG_CHANNEL_MODERATE(
            channel_name=channel_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A8))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.channel_name)


@dataclasses.dataclass
class SMSG_UPDATE_OBJECT:
    has_transport: int
    objects: typing.List[Object]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_UPDATE_OBJECT:
        # amount_of_objects: u32
        amount_of_objects = await read_int(reader, 4)

        # has_transport: u8
        has_transport = await read_int(reader, 1)

        # objects: Object[amount_of_objects]
        objects = []
        for _ in range(0, amount_of_objects):
            objects.append(await Object.read(reader))

        return SMSG_UPDATE_OBJECT(
            has_transport=has_transport,
            objects=objects,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00A9))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([len(self.objects), self.has_transport])
        # objects: Object[amount_of_objects]
        for i in self.objects:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + sum([i.size() for i in self.objects])


@dataclasses.dataclass
class SMSG_DESTROY_OBJECT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DESTROY_OBJECT:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_DESTROY_OBJECT(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x00AA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_USE_ITEM:
    bag_index: int
    bag_slot: int
    spell_index: int
    cast_count: int
    item: int
    targets: SpellCastTargets

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_USE_ITEM:
        # bag_index: u8
        bag_index = await read_int(reader, 1)

        # bag_slot: u8
        bag_slot = await read_int(reader, 1)

        # spell_index: u8
        spell_index = await read_int(reader, 1)

        # cast_count: u8
        cast_count = await read_int(reader, 1)

        # item: Guid
        item = await read_int(reader, 8)

        # targets: SpellCastTargets
        targets = await SpellCastTargets.read(reader)

        return CMSG_USE_ITEM(
            bag_index=bag_index,
            bag_slot=bag_slot,
            spell_index=spell_index,
            cast_count=cast_count,
            item=item,
            targets=targets,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00AB))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBBBQ'
        _data.extend([self.bag_index, self.bag_slot, self.spell_index, self.cast_count, self.item])
        # targets: SpellCastTargets
        _fmt, _data = self.targets.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + self.targets.size()


@dataclasses.dataclass
class CMSG_OPEN_ITEM:
    bag_index: int
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_OPEN_ITEM:
        # bag_index: u8
        bag_index = await read_int(reader, 1)

        # slot: u8
        slot = await read_int(reader, 1)

        return CMSG_OPEN_ITEM(
            bag_index=bag_index,
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x00AC))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.bag_index, self.slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_READ_ITEM:
    bag_index: int
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_READ_ITEM:
        # bag_index: u8
        bag_index = await read_int(reader, 1)

        # slot: u8
        slot = await read_int(reader, 1)

        return CMSG_READ_ITEM(
            bag_index=bag_index,
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x00AD))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.bag_index, self.slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_READ_ITEM_OK:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_READ_ITEM_OK:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_READ_ITEM_OK(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x00AE))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_READ_ITEM_FAILED:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_READ_ITEM_FAILED:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_READ_ITEM_FAILED(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x00AF))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_COOLDOWN:
    guid: int
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_COOLDOWN:
        # guid: Guid
        guid = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        return SMSG_ITEM_COOLDOWN(
            guid=guid,
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x00B0))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GAMEOBJ_USE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GAMEOBJ_USE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_GAMEOBJ_USE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x00B1))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GAMEOBJECT_CUSTOM_ANIM:
    guid: int
    animation_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GAMEOBJECT_CUSTOM_ANIM:
        # guid: Guid
        guid = await read_int(reader, 8)

        # animation_id: u32
        animation_id = await read_int(reader, 4)

        return SMSG_GAMEOBJECT_CUSTOM_ANIM(
            guid=guid,
            animation_id=animation_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x00B3))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.animation_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AREATRIGGER:
    trigger_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AREATRIGGER:
        # trigger_id: u32
        trigger_id = await read_int(reader, 4)

        return CMSG_AREATRIGGER(
            trigger_id=trigger_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x00B4))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.trigger_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MOVE_START_FORWARD_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_FORWARD_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_FORWARD_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00B5))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_FORWARD_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_FORWARD_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_FORWARD_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00B5))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_BACKWARD_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_BACKWARD_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_BACKWARD_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00B6))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_BACKWARD_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_BACKWARD_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_BACKWARD_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00B6))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00B7))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00B7))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_STRAFE_LEFT_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_STRAFE_LEFT_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_STRAFE_LEFT_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00B8))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_STRAFE_LEFT_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_STRAFE_LEFT_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_STRAFE_LEFT_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00B8))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_STRAFE_RIGHT_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_STRAFE_RIGHT_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_STRAFE_RIGHT_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00B9))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_STRAFE_RIGHT_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_STRAFE_RIGHT_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_STRAFE_RIGHT_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00B9))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_STRAFE_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_STRAFE_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_STRAFE_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00BA))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_STRAFE_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_STRAFE_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_STRAFE_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00BA))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_JUMP_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_JUMP_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_JUMP_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00BB))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_JUMP_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_JUMP_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_JUMP_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00BB))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_TURN_LEFT_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_TURN_LEFT_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_TURN_LEFT_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00BC))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_TURN_LEFT_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_TURN_LEFT_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_TURN_LEFT_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00BC))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_TURN_RIGHT_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_TURN_RIGHT_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_TURN_RIGHT_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00BD))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_TURN_RIGHT_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_TURN_RIGHT_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_TURN_RIGHT_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00BD))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_TURN_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_TURN_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_TURN_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00BE))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_TURN_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_TURN_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_TURN_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00BE))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_PITCH_UP_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_PITCH_UP_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_PITCH_UP_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00BF))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_PITCH_UP_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_PITCH_UP_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_PITCH_UP_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00BF))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_PITCH_DOWN_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_PITCH_DOWN_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_PITCH_DOWN_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00C0))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_PITCH_DOWN_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_PITCH_DOWN_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_PITCH_DOWN_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00C0))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_PITCH_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_PITCH_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_PITCH_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00C1))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_PITCH_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_PITCH_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_PITCH_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00C1))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_RUN_MODE_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_RUN_MODE_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_RUN_MODE_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00C2))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_RUN_MODE_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_RUN_MODE_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_RUN_MODE_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00C2))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_WALK_MODE_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_WALK_MODE_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_WALK_MODE_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00C3))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_WALK_MODE_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_WALK_MODE_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_WALK_MODE_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00C3))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_TELEPORT_Server:
    player: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_TELEPORT_Server:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_TELEPORT_Server(
            player=player,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00C5))
        _fmt = "<6s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_TELEPORT_CHEAT_Server:
    position: Vector3d
    orientation: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_TELEPORT_CHEAT_Server:
        # position: Vector3d
        position = await Vector3d.read(reader)

        # orientation: f32
        orientation = await read_float(reader)

        return MSG_MOVE_TELEPORT_CHEAT_Server(
            position=position,
            orientation=orientation,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x00C6))
        _fmt = "<4s"
        _data = [_data]

        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # orientation: f32
        _fmt += 'f'
        _data.append(self.orientation)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MOVE_TELEPORT_ACK_Client:
    guid: int
    movement_counter: int
    time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_TELEPORT_ACK_Client:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # time: Milliseconds
        time = await read_int(reader, 4)

        return MSG_MOVE_TELEPORT_ACK_Client(
            guid=guid,
            movement_counter=movement_counter,
            time=time,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00C7))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # movement_counter: u32
        _fmt += 'I'
        _data.append(self.movement_counter)

        # time: Milliseconds
        _fmt += 'I'
        _data.append(self.time)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class MSG_MOVE_TELEPORT_ACK_Server:
    guid: int
    movement_counter: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_TELEPORT_ACK_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_TELEPORT_ACK_Server(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00C7))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # movement_counter: u32
        _fmt += 'I'
        _data.append(self.movement_counter)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_FALL_LAND_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_FALL_LAND_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_FALL_LAND_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00C9))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_FALL_LAND_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_FALL_LAND_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_FALL_LAND_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00C9))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_SWIM_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_SWIM_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_SWIM_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00CA))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_SWIM_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_SWIM_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_SWIM_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00CA))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_SWIM_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_SWIM_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_SWIM_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00CB))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_SWIM_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_SWIM_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_SWIM_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00CB))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_FACING_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_FACING_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_FACING_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00DA))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_FACING_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_FACING_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_FACING_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00DA))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_PITCH_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_PITCH_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_PITCH_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00DB))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_PITCH_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_PITCH_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_PITCH_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00DB))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_WORLDPORT_ACK:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_WORLDPORT_ACK:
        return MSG_MOVE_WORLDPORT_ACK()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x00DC))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x00DC))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MONSTER_MOVE:
    guid: int
    spline_point: Vector3d
    spline_id: int
    move_type: MonsterMoveType
    spline_flags: SplineFlag
    duration: int
    splines: MonsterMoveSpline
    target: typing.Optional[int] = None
    angle: typing.Optional[float] = None
    position: typing.Optional[Vector3d] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MONSTER_MOVE:
        target = None
        angle = None
        position = None
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # spline_point: Vector3d
        spline_point = await Vector3d.read(reader)

        # spline_id: u32
        spline_id = await read_int(reader, 4)

        # move_type: MonsterMoveType
        move_type = MonsterMoveType(await read_int(reader, 1))

        if move_type == MonsterMoveType.FACING_TARGET:
            # target: Guid
            target = await read_int(reader, 8)

        elif move_type == MonsterMoveType.FACING_ANGLE:
            # angle: f32
            angle = await read_float(reader)

        elif move_type == MonsterMoveType.FACING_SPOT:
            # position: Vector3d
            position = await Vector3d.read(reader)

        # spline_flags: SplineFlag
        spline_flags = SplineFlag(await read_int(reader, 4))

        # duration: u32
        duration = await read_int(reader, 4)

        # splines: MonsterMoveSpline
        splines = await MonsterMoveSpline.read(reader)

        return SMSG_MONSTER_MOVE(
            guid=guid,
            spline_point=spline_point,
            spline_id=spline_id,
            move_type=move_type,
            target=target,
            angle=angle,
            position=position,
            spline_flags=spline_flags,
            duration=duration,
            splines=splines,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00DD))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # spline_point: Vector3d
        _fmt, _data = self.spline_point.write(_fmt, _data)

        # spline_id: u32
        _fmt += 'I'
        _data.append(self.spline_id)

        # move_type: MonsterMoveType
        _fmt += 'B'
        _data.append(self.move_type.value)

        if self.move_type == MonsterMoveType.FACING_TARGET:
            _fmt += 'Q'
            _data.append(self.target)
        elif self.move_type == MonsterMoveType.FACING_ANGLE:
            _fmt += 'f'
            _data.append(self.angle)
        elif self.move_type == MonsterMoveType.FACING_SPOT:
            # position: Vector3d
            _fmt, _data = self.position.write(_fmt, _data)

        # spline_flags: SplineFlag
        _fmt += 'I'
        _data.append(self.spline_flags.value)

        # duration: u32
        _fmt += 'I'
        _data.append(self.duration)

        # splines: MonsterMoveSpline
        _fmt, _data = self.splines.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 25 + packed_guid_size(self.guid) + self.splines.size()

        if self.move_type == MonsterMoveType.FACING_TARGET:
            _size += 8
        elif self.move_type == MonsterMoveType.FACING_ANGLE:
            _size += 4
        elif self.move_type == MonsterMoveType.FACING_SPOT:
            _size += 12

        return _size


@dataclasses.dataclass
class SMSG_MOVE_WATER_WALK:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_WATER_WALK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_WATER_WALK(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00DE))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_MOVE_LAND_WALK:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_LAND_WALK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_LAND_WALK(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00DF))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_MOVE_SET_RAW_POSITION:
    position: Vector3d
    orientation: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_SET_RAW_POSITION:
        # position: Vector3d
        position = await Vector3d.read(reader)

        # orientation: f32
        orientation = await read_float(reader)

        return CMSG_MOVE_SET_RAW_POSITION(
            position=position,
            orientation=orientation,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x00E1))
        _fmt = "<6s"
        _data = [_data]

        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # orientation: f32
        _fmt += 'f'
        _data.append(self.orientation)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_FORCE_RUN_SPEED_CHANGE:
    guid: int
    move_event: int
    unknown: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_RUN_SPEED_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # unknown: u8
        unknown = await read_int(reader, 1)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_RUN_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            unknown=unknown,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00E2))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # unknown: u8
        _fmt += 'B'
        _data.append(self.unknown)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_RUN_SPEED_CHANGE_ACK:
    guid: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_RUN_SPEED_CHANGE_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_RUN_SPEED_CHANGE_ACK(
            guid=guid,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00E3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_RUN_BACK_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_RUN_BACK_SPEED_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_RUN_BACK_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00E4))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK:
    guid: int
    movement_counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00E5))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.movement_counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_SWIM_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_SWIM_SPEED_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_SWIM_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00E6))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_SWIM_SPEED_CHANGE_ACK:
    guid: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_SWIM_SPEED_CHANGE_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_SWIM_SPEED_CHANGE_ACK(
            guid=guid,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00E7))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_MOVE_ROOT:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_MOVE_ROOT:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_FORCE_MOVE_ROOT(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00E8))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_MOVE_ROOT_ACK:
    guid: int
    movement_counter: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_MOVE_ROOT_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return CMSG_FORCE_MOVE_ROOT_ACK(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00E9))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.movement_counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_MOVE_UNROOT:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_MOVE_UNROOT:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_FORCE_MOVE_UNROOT(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00EA))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_MOVE_UNROOT_ACK:
    guid: int
    movement_counter: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_MOVE_UNROOT_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return CMSG_FORCE_MOVE_UNROOT_ACK(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00EB))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.movement_counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_ROOT_Server:
    player: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_ROOT_Server:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_ROOT_Server(
            player=player,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00EC))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_UNROOT_Server:
    player: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_UNROOT_Server:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_UNROOT_Server(
            player=player,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00ED))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_HEARTBEAT_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_HEARTBEAT_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_HEARTBEAT_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00EE))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_HEARTBEAT_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_HEARTBEAT_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_HEARTBEAT_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00EE))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class SMSG_MOVE_KNOCK_BACK:
    guid: int
    movement_counter: int
    v_cos: float
    v_sin: float
    horizontal_speed: float
    vertical_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_KNOCK_BACK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # v_cos: f32
        v_cos = await read_float(reader)

        # v_sin: f32
        v_sin = await read_float(reader)

        # horizontal_speed: f32
        horizontal_speed = await read_float(reader)

        # vertical_speed: f32
        vertical_speed = await read_float(reader)

        return SMSG_MOVE_KNOCK_BACK(
            guid=guid,
            movement_counter=movement_counter,
            v_cos=v_cos,
            v_sin=v_sin,
            horizontal_speed=horizontal_speed,
            vertical_speed=vertical_speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00EF))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # movement_counter: u32
        _fmt += 'I'
        _data.append(self.movement_counter)

        # v_cos: f32
        _fmt += 'f'
        _data.append(self.v_cos)

        # v_sin: f32
        _fmt += 'f'
        _data.append(self.v_sin)

        # horizontal_speed: f32
        _fmt += 'f'
        _data.append(self.horizontal_speed)

        # vertical_speed: f32
        _fmt += 'f'
        _data.append(self.vertical_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 20 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_MOVE_KNOCK_BACK_ACK:
    guid: int
    counter: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_KNOCK_BACK_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return CMSG_MOVE_KNOCK_BACK_ACK(
            guid=guid,
            counter=counter,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00F0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_KNOCK_BACK_Server:
    player: int
    info: MovementInfo
    sin_angle: float
    cos_angle: float
    x_y_speed: float
    velocity: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_KNOCK_BACK_Server:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # sin_angle: f32
        sin_angle = await read_float(reader)

        # cos_angle: f32
        cos_angle = await read_float(reader)

        # x_y_speed: f32
        x_y_speed = await read_float(reader)

        # velocity: f32
        velocity = await read_float(reader)

        return MSG_MOVE_KNOCK_BACK_Server(
            player=player,
            info=info,
            sin_angle=sin_angle,
            cos_angle=cos_angle,
            x_y_speed=x_y_speed,
            velocity=velocity,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00F1))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # sin_angle: f32
        _fmt += 'f'
        _data.append(self.sin_angle)

        # cos_angle: f32
        _fmt += 'f'
        _data.append(self.cos_angle)

        # x_y_speed: f32
        _fmt += 'f'
        _data.append(self.x_y_speed)

        # velocity: f32
        _fmt += 'f'
        _data.append(self.velocity)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class SMSG_MOVE_FEATHER_FALL:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_FEATHER_FALL:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_FEATHER_FALL(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00F2))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_MOVE_NORMAL_FALL:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_NORMAL_FALL:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_NORMAL_FALL(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00F3))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_MOVE_SET_HOVER:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_SET_HOVER:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_SET_HOVER(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00F4))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_MOVE_UNSET_HOVER:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_UNSET_HOVER:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_UNSET_HOVER(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00F5))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_MOVE_HOVER_ACK:
    guid: int
    counter: int
    info: MovementInfo
    is_applied: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_HOVER_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # is_applied: u32
        is_applied = await read_int(reader, 4)

        return CMSG_MOVE_HOVER_ACK(
            guid=guid,
            counter=counter,
            info=info,
            is_applied=is_applied,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00F6))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # is_applied: u32
        _fmt += 'I'
        _data.append(self.is_applied)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_HOVER:
    player: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_HOVER:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_HOVER(
            player=player,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00F7))
        _fmt = "<6s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00F7))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class SMSG_TRIGGER_CINEMATIC:
    cinematic_sequence_id: CinematicSequenceId

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRIGGER_CINEMATIC:
        # cinematic_sequence_id: CinematicSequenceId
        cinematic_sequence_id = CinematicSequenceId(await read_int(reader, 4))

        return SMSG_TRIGGER_CINEMATIC(
            cinematic_sequence_id=cinematic_sequence_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x00FA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.cinematic_sequence_id.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_NEXT_CINEMATIC_CAMERA:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_NEXT_CINEMATIC_CAMERA:
        return CMSG_NEXT_CINEMATIC_CAMERA()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x00FB))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_COMPLETE_CINEMATIC:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_COMPLETE_CINEMATIC:
        return CMSG_COMPLETE_CINEMATIC()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x00FC))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TUTORIAL_FLAGS:
    tutorial_data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TUTORIAL_FLAGS:
        # tutorial_data: u32[8]
        tutorial_data = []
        for _ in range(0, 8):
            tutorial_data.append(await read_int(reader, 4))

        return SMSG_TUTORIAL_FLAGS(
            tutorial_data=tutorial_data,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(32 + 2, 0x00FD))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.tutorial_data)}I'
        _data.extend([*self.tutorial_data])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TUTORIAL_FLAG:
    tutorial_flag: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TUTORIAL_FLAG:
        # tutorial_flag: u32
        tutorial_flag = await read_int(reader, 4)

        return CMSG_TUTORIAL_FLAG(
            tutorial_flag=tutorial_flag,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x00FE))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.tutorial_flag)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TUTORIAL_CLEAR:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TUTORIAL_CLEAR:
        return CMSG_TUTORIAL_CLEAR()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x00FF))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TUTORIAL_RESET:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TUTORIAL_RESET:
        return CMSG_TUTORIAL_RESET()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0100))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_STANDSTATECHANGE:
    animation_state: UnitStandState

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_STANDSTATECHANGE:
        # animation_state: UnitStandState
        animation_state = UnitStandState(await read_int(reader, 4))

        return CMSG_STANDSTATECHANGE(
            animation_state=animation_state,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0101))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.animation_state.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_EMOTE:
    emote: Emote

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_EMOTE:
        # emote: Emote
        emote = Emote(await read_int(reader, 4))

        return CMSG_EMOTE(
            emote=emote,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0102))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.emote.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_EMOTE:
    emote: Emote
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_EMOTE:
        # emote: Emote
        emote = Emote(await read_int(reader, 4))

        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_EMOTE(
            emote=emote,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0103))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.emote.value, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TEXT_EMOTE:
    text_emote: TextEmote
    emote: int
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TEXT_EMOTE:
        # text_emote: TextEmote
        text_emote = TextEmote(await read_int(reader, 4))

        # emote: u32
        emote = await read_int(reader, 4)

        # target: Guid
        target = await read_int(reader, 8)

        return CMSG_TEXT_EMOTE(
            text_emote=text_emote,
            emote=emote,
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x0104))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IIQ'
        _data.extend([self.text_emote.value, self.emote, self.target])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TEXT_EMOTE:
    guid: int
    text_emote: TextEmote
    emote: int
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TEXT_EMOTE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # text_emote: TextEmote
        text_emote = TextEmote(await read_int(reader, 4))

        # emote: u32
        emote = await read_int(reader, 4)

        # name: SizedCString
        name = await read_sized_cstring(reader)

        return SMSG_TEXT_EMOTE(
            guid=guid,
            text_emote=text_emote,
            emote=emote,
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0105))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QIII{len(self.name)}sB'
        _data.extend([self.guid, self.text_emote.value, self.emote, len(self.name) + 1, self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 21 + len(self.name)


@dataclasses.dataclass
class CMSG_AUTOSTORE_LOOT_ITEM:
    item_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUTOSTORE_LOOT_ITEM:
        # item_slot: u8
        item_slot = await read_int(reader, 1)

        return CMSG_AUTOSTORE_LOOT_ITEM(
            item_slot=item_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x0108))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.item_slot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUTOEQUIP_ITEM:
    source_bag: int
    source_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUTOEQUIP_ITEM:
        # source_bag: u8
        source_bag = await read_int(reader, 1)

        # source_slot: u8
        source_slot = await read_int(reader, 1)

        return CMSG_AUTOEQUIP_ITEM(
            source_bag=source_bag,
            source_slot=source_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x010A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.source_bag, self.source_slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUTOSTORE_BAG_ITEM:
    source_bag: int
    source_slot: int
    destination_bag: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUTOSTORE_BAG_ITEM:
        # source_bag: u8
        source_bag = await read_int(reader, 1)

        # source_slot: u8
        source_slot = await read_int(reader, 1)

        # destination_bag: u8
        destination_bag = await read_int(reader, 1)

        return CMSG_AUTOSTORE_BAG_ITEM(
            source_bag=source_bag,
            source_slot=source_slot,
            destination_bag=destination_bag,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(3 + 4, 0x010B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBB'
        _data.extend([self.source_bag, self.source_slot, self.destination_bag])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SWAP_ITEM:
    destination_bag: int
    destionation_slot: int
    source_bag: int
    source_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SWAP_ITEM:
        # destination_bag: u8
        destination_bag = await read_int(reader, 1)

        # destionation_slot: u8
        destionation_slot = await read_int(reader, 1)

        # source_bag: u8
        source_bag = await read_int(reader, 1)

        # source_slot: u8
        source_slot = await read_int(reader, 1)

        return CMSG_SWAP_ITEM(
            destination_bag=destination_bag,
            destionation_slot=destionation_slot,
            source_bag=source_bag,
            source_slot=source_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x010C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBBB'
        _data.extend([self.destination_bag, self.destionation_slot, self.source_bag, self.source_slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SWAP_INV_ITEM:
    source_slot: ItemSlot
    destination_slot: ItemSlot

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SWAP_INV_ITEM:
        # source_slot: ItemSlot
        source_slot = ItemSlot(await read_int(reader, 1))

        # destination_slot: ItemSlot
        destination_slot = ItemSlot(await read_int(reader, 1))

        return CMSG_SWAP_INV_ITEM(
            source_slot=source_slot,
            destination_slot=destination_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x010D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.source_slot.value, self.destination_slot.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SPLIT_ITEM:
    source_bag: int
    source_slot: int
    destination_bag: int
    destination_slot: int
    amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SPLIT_ITEM:
        # source_bag: u8
        source_bag = await read_int(reader, 1)

        # source_slot: u8
        source_slot = await read_int(reader, 1)

        # destination_bag: u8
        destination_bag = await read_int(reader, 1)

        # destination_slot: u8
        destination_slot = await read_int(reader, 1)

        # amount: u8
        amount = await read_int(reader, 1)

        return CMSG_SPLIT_ITEM(
            source_bag=source_bag,
            source_slot=source_slot,
            destination_bag=destination_bag,
            destination_slot=destination_slot,
            amount=amount,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 4, 0x010E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBBBB'
        _data.extend([self.source_bag, self.source_slot, self.destination_bag, self.destination_slot, self.amount])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUTOEQUIP_ITEM_SLOT:
    guid: int
    destination_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUTOEQUIP_ITEM_SLOT:
        # guid: Guid
        guid = await read_int(reader, 8)

        # destination_slot: u8
        destination_slot = await read_int(reader, 1)

        return CMSG_AUTOEQUIP_ITEM_SLOT(
            guid=guid,
            destination_slot=destination_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x010F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.destination_slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_DESTROYITEM:
    bag: int
    slot: int
    amount: int
    unknown1: int
    unknown2: int
    unknown3: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_DESTROYITEM:
        # bag: u8
        bag = await read_int(reader, 1)

        # slot: u8
        slot = await read_int(reader, 1)

        # amount: u8
        amount = await read_int(reader, 1)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # unknown2: u8
        unknown2 = await read_int(reader, 1)

        # unknown3: u8
        unknown3 = await read_int(reader, 1)

        return CMSG_DESTROYITEM(
            bag=bag,
            slot=slot,
            amount=amount,
            unknown1=unknown1,
            unknown2=unknown2,
            unknown3=unknown3,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(6 + 4, 0x0111))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBBBBB'
        _data.extend([self.bag, self.slot, self.amount, self.unknown1, self.unknown2, self.unknown3])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_INVENTORY_CHANGE_FAILURE:
    result: InventoryResult
    item1: typing.Optional[int] = None
    item2: typing.Optional[int] = None
    bag_type_subclass: typing.Optional[int] = None
    required_level: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INVENTORY_CHANGE_FAILURE:
        item1 = None
        item2 = None
        bag_type_subclass = None
        required_level = None
        # result: InventoryResult
        result = InventoryResult(await read_int(reader, 1))

        if result in {InventoryResult.CANT_EQUIP_LEVEL_I, InventoryResult.CANT_EQUIP_SKILL, InventoryResult.ITEM_DOESNT_GO_TO_SLOT, InventoryResult.BAG_FULL, InventoryResult.NONEMPTY_BAG_OVER_OTHER_BAG, InventoryResult.CANT_TRADE_EQUIP_BAGS, InventoryResult.ONLY_AMMO_CAN_GO_HERE, InventoryResult.NO_REQUIRED_PROFICIENCY, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE, InventoryResult.YOU_CAN_NEVER_USE_THAT_ITEM, InventoryResult.YOU_CAN_NEVER_USE_THAT_ITEM2, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE2, InventoryResult.CANT_EQUIP_WITH_TWOHANDED, InventoryResult.CANT_DUAL_WIELD, InventoryResult.ITEM_DOESNT_GO_INTO_BAG, InventoryResult.ITEM_DOESNT_GO_INTO_BAG2, InventoryResult.CANT_CARRY_MORE_OF_THIS, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE3, InventoryResult.ITEM_CANT_STACK, InventoryResult.ITEM_CANT_BE_EQUIPPED, InventoryResult.ITEMS_CANT_BE_SWAPPED, InventoryResult.SLOT_IS_EMPTY, InventoryResult.ITEM_NOT_FOUND, InventoryResult.CANT_DROP_SOULBOUND, InventoryResult.OUT_OF_RANGE, InventoryResult.TRIED_TO_SPLIT_MORE_THAN_COUNT, InventoryResult.COULDNT_SPLIT_ITEMS, InventoryResult.MISSING_REAGENT, InventoryResult.NOT_ENOUGH_MONEY, InventoryResult.NOT_A_BAG, InventoryResult.CAN_ONLY_DO_WITH_EMPTY_BAGS, InventoryResult.DONT_OWN_THAT_ITEM, InventoryResult.CAN_EQUIP_ONLY1_QUIVER, InventoryResult.MUST_PURCHASE_THAT_BAG_SLOT, InventoryResult.TOO_FAR_AWAY_FROM_BANK, InventoryResult.ITEM_LOCKED, InventoryResult.YOU_ARE_STUNNED, InventoryResult.YOU_ARE_DEAD, InventoryResult.CANT_DO_RIGHT_NOW, InventoryResult.INT_BAG_ERROR, InventoryResult.CAN_EQUIP_ONLY1_BOLT, InventoryResult.CAN_EQUIP_ONLY1_AMMOPOUCH, InventoryResult.STACKABLE_CANT_BE_WRAPPED, InventoryResult.EQUIPPED_CANT_BE_WRAPPED, InventoryResult.WRAPPED_CANT_BE_WRAPPED, InventoryResult.BOUND_CANT_BE_WRAPPED, InventoryResult.UNIQUE_CANT_BE_WRAPPED, InventoryResult.BAGS_CANT_BE_WRAPPED, InventoryResult.ALREADY_LOOTED, InventoryResult.INVENTORY_FULL, InventoryResult.BANK_FULL, InventoryResult.ITEM_IS_CURRENTLY_SOLD_OUT, InventoryResult.BAG_FULL3, InventoryResult.ITEM_NOT_FOUND2, InventoryResult.ITEM_CANT_STACK2, InventoryResult.BAG_FULL4, InventoryResult.ITEM_SOLD_OUT, InventoryResult.OBJECT_IS_BUSY, InventoryResult.NONE, InventoryResult.NOT_IN_COMBAT, InventoryResult.NOT_WHILE_DISARMED, InventoryResult.BAG_FULL6, InventoryResult.CANT_EQUIP_RANK, InventoryResult.CANT_EQUIP_REPUTATION, InventoryResult.TOO_MANY_SPECIAL_BAGS, InventoryResult.LOOT_CANT_LOOT_THAT_NOW, InventoryResult.ITEM_UNIQUE_EQUIPABLE, InventoryResult.VENDOR_MISSING_TURNINS, InventoryResult.NOT_ENOUGH_HONOR_POINTS, InventoryResult.NOT_ENOUGH_ARENA_POINTS, InventoryResult.ITEM_MAX_COUNT_SOCKETED, InventoryResult.MAIL_BOUND_ITEM, InventoryResult.NO_SPLIT_WHILE_PROSPECTING, InventoryResult.BAG_FULL7, InventoryResult.ITEM_MAX_COUNT_EQUIPPED_SOCKETED, InventoryResult.ITEM_UNIQUE_EQUIPPABLE_SOCKETED, InventoryResult.TOO_MUCH_GOLD, InventoryResult.NOT_DURING_ARENA_MATCH, InventoryResult.CANNOT_TRADE_THAT, InventoryResult.PERSONAL_ARENA_RATING_TOO_LOW}:
            # item1: Guid
            item1 = await read_int(reader, 8)

            # item2: Guid
            item2 = await read_int(reader, 8)

            # bag_type_subclass: u8
            bag_type_subclass = await read_int(reader, 1)

        if result == InventoryResult.CANT_EQUIP_LEVEL_I:
            # required_level: Level32
            required_level = await read_int(reader, 4)

        return SMSG_INVENTORY_CHANGE_FAILURE(
            result=result,
            item1=item1,
            item2=item2,
            bag_type_subclass=bag_type_subclass,
            required_level=required_level,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0112))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        if self.result in {InventoryResult.CANT_EQUIP_LEVEL_I, InventoryResult.CANT_EQUIP_SKILL, InventoryResult.ITEM_DOESNT_GO_TO_SLOT, InventoryResult.BAG_FULL, InventoryResult.NONEMPTY_BAG_OVER_OTHER_BAG, InventoryResult.CANT_TRADE_EQUIP_BAGS, InventoryResult.ONLY_AMMO_CAN_GO_HERE, InventoryResult.NO_REQUIRED_PROFICIENCY, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE, InventoryResult.YOU_CAN_NEVER_USE_THAT_ITEM, InventoryResult.YOU_CAN_NEVER_USE_THAT_ITEM2, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE2, InventoryResult.CANT_EQUIP_WITH_TWOHANDED, InventoryResult.CANT_DUAL_WIELD, InventoryResult.ITEM_DOESNT_GO_INTO_BAG, InventoryResult.ITEM_DOESNT_GO_INTO_BAG2, InventoryResult.CANT_CARRY_MORE_OF_THIS, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE3, InventoryResult.ITEM_CANT_STACK, InventoryResult.ITEM_CANT_BE_EQUIPPED, InventoryResult.ITEMS_CANT_BE_SWAPPED, InventoryResult.SLOT_IS_EMPTY, InventoryResult.ITEM_NOT_FOUND, InventoryResult.CANT_DROP_SOULBOUND, InventoryResult.OUT_OF_RANGE, InventoryResult.TRIED_TO_SPLIT_MORE_THAN_COUNT, InventoryResult.COULDNT_SPLIT_ITEMS, InventoryResult.MISSING_REAGENT, InventoryResult.NOT_ENOUGH_MONEY, InventoryResult.NOT_A_BAG, InventoryResult.CAN_ONLY_DO_WITH_EMPTY_BAGS, InventoryResult.DONT_OWN_THAT_ITEM, InventoryResult.CAN_EQUIP_ONLY1_QUIVER, InventoryResult.MUST_PURCHASE_THAT_BAG_SLOT, InventoryResult.TOO_FAR_AWAY_FROM_BANK, InventoryResult.ITEM_LOCKED, InventoryResult.YOU_ARE_STUNNED, InventoryResult.YOU_ARE_DEAD, InventoryResult.CANT_DO_RIGHT_NOW, InventoryResult.INT_BAG_ERROR, InventoryResult.CAN_EQUIP_ONLY1_BOLT, InventoryResult.CAN_EQUIP_ONLY1_AMMOPOUCH, InventoryResult.STACKABLE_CANT_BE_WRAPPED, InventoryResult.EQUIPPED_CANT_BE_WRAPPED, InventoryResult.WRAPPED_CANT_BE_WRAPPED, InventoryResult.BOUND_CANT_BE_WRAPPED, InventoryResult.UNIQUE_CANT_BE_WRAPPED, InventoryResult.BAGS_CANT_BE_WRAPPED, InventoryResult.ALREADY_LOOTED, InventoryResult.INVENTORY_FULL, InventoryResult.BANK_FULL, InventoryResult.ITEM_IS_CURRENTLY_SOLD_OUT, InventoryResult.BAG_FULL3, InventoryResult.ITEM_NOT_FOUND2, InventoryResult.ITEM_CANT_STACK2, InventoryResult.BAG_FULL4, InventoryResult.ITEM_SOLD_OUT, InventoryResult.OBJECT_IS_BUSY, InventoryResult.NONE, InventoryResult.NOT_IN_COMBAT, InventoryResult.NOT_WHILE_DISARMED, InventoryResult.BAG_FULL6, InventoryResult.CANT_EQUIP_RANK, InventoryResult.CANT_EQUIP_REPUTATION, InventoryResult.TOO_MANY_SPECIAL_BAGS, InventoryResult.LOOT_CANT_LOOT_THAT_NOW, InventoryResult.ITEM_UNIQUE_EQUIPABLE, InventoryResult.VENDOR_MISSING_TURNINS, InventoryResult.NOT_ENOUGH_HONOR_POINTS, InventoryResult.NOT_ENOUGH_ARENA_POINTS, InventoryResult.ITEM_MAX_COUNT_SOCKETED, InventoryResult.MAIL_BOUND_ITEM, InventoryResult.NO_SPLIT_WHILE_PROSPECTING, InventoryResult.BAG_FULL7, InventoryResult.ITEM_MAX_COUNT_EQUIPPED_SOCKETED, InventoryResult.ITEM_UNIQUE_EQUIPPABLE_SOCKETED, InventoryResult.TOO_MUCH_GOLD, InventoryResult.NOT_DURING_ARENA_MATCH, InventoryResult.CANNOT_TRADE_THAT, InventoryResult.PERSONAL_ARENA_RATING_TOO_LOW}:
            _fmt += 'QQB'
            _data.extend([self.item1, self.item2, self.bag_type_subclass])
        if self.result == InventoryResult.CANT_EQUIP_LEVEL_I:
            _fmt += 'I'
            _data.append(self.required_level)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.result in {InventoryResult.CANT_EQUIP_LEVEL_I, InventoryResult.CANT_EQUIP_SKILL, InventoryResult.ITEM_DOESNT_GO_TO_SLOT, InventoryResult.BAG_FULL, InventoryResult.NONEMPTY_BAG_OVER_OTHER_BAG, InventoryResult.CANT_TRADE_EQUIP_BAGS, InventoryResult.ONLY_AMMO_CAN_GO_HERE, InventoryResult.NO_REQUIRED_PROFICIENCY, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE, InventoryResult.YOU_CAN_NEVER_USE_THAT_ITEM, InventoryResult.YOU_CAN_NEVER_USE_THAT_ITEM2, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE2, InventoryResult.CANT_EQUIP_WITH_TWOHANDED, InventoryResult.CANT_DUAL_WIELD, InventoryResult.ITEM_DOESNT_GO_INTO_BAG, InventoryResult.ITEM_DOESNT_GO_INTO_BAG2, InventoryResult.CANT_CARRY_MORE_OF_THIS, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE3, InventoryResult.ITEM_CANT_STACK, InventoryResult.ITEM_CANT_BE_EQUIPPED, InventoryResult.ITEMS_CANT_BE_SWAPPED, InventoryResult.SLOT_IS_EMPTY, InventoryResult.ITEM_NOT_FOUND, InventoryResult.CANT_DROP_SOULBOUND, InventoryResult.OUT_OF_RANGE, InventoryResult.TRIED_TO_SPLIT_MORE_THAN_COUNT, InventoryResult.COULDNT_SPLIT_ITEMS, InventoryResult.MISSING_REAGENT, InventoryResult.NOT_ENOUGH_MONEY, InventoryResult.NOT_A_BAG, InventoryResult.CAN_ONLY_DO_WITH_EMPTY_BAGS, InventoryResult.DONT_OWN_THAT_ITEM, InventoryResult.CAN_EQUIP_ONLY1_QUIVER, InventoryResult.MUST_PURCHASE_THAT_BAG_SLOT, InventoryResult.TOO_FAR_AWAY_FROM_BANK, InventoryResult.ITEM_LOCKED, InventoryResult.YOU_ARE_STUNNED, InventoryResult.YOU_ARE_DEAD, InventoryResult.CANT_DO_RIGHT_NOW, InventoryResult.INT_BAG_ERROR, InventoryResult.CAN_EQUIP_ONLY1_BOLT, InventoryResult.CAN_EQUIP_ONLY1_AMMOPOUCH, InventoryResult.STACKABLE_CANT_BE_WRAPPED, InventoryResult.EQUIPPED_CANT_BE_WRAPPED, InventoryResult.WRAPPED_CANT_BE_WRAPPED, InventoryResult.BOUND_CANT_BE_WRAPPED, InventoryResult.UNIQUE_CANT_BE_WRAPPED, InventoryResult.BAGS_CANT_BE_WRAPPED, InventoryResult.ALREADY_LOOTED, InventoryResult.INVENTORY_FULL, InventoryResult.BANK_FULL, InventoryResult.ITEM_IS_CURRENTLY_SOLD_OUT, InventoryResult.BAG_FULL3, InventoryResult.ITEM_NOT_FOUND2, InventoryResult.ITEM_CANT_STACK2, InventoryResult.BAG_FULL4, InventoryResult.ITEM_SOLD_OUT, InventoryResult.OBJECT_IS_BUSY, InventoryResult.NONE, InventoryResult.NOT_IN_COMBAT, InventoryResult.NOT_WHILE_DISARMED, InventoryResult.BAG_FULL6, InventoryResult.CANT_EQUIP_RANK, InventoryResult.CANT_EQUIP_REPUTATION, InventoryResult.TOO_MANY_SPECIAL_BAGS, InventoryResult.LOOT_CANT_LOOT_THAT_NOW, InventoryResult.ITEM_UNIQUE_EQUIPABLE, InventoryResult.VENDOR_MISSING_TURNINS, InventoryResult.NOT_ENOUGH_HONOR_POINTS, InventoryResult.NOT_ENOUGH_ARENA_POINTS, InventoryResult.ITEM_MAX_COUNT_SOCKETED, InventoryResult.MAIL_BOUND_ITEM, InventoryResult.NO_SPLIT_WHILE_PROSPECTING, InventoryResult.BAG_FULL7, InventoryResult.ITEM_MAX_COUNT_EQUIPPED_SOCKETED, InventoryResult.ITEM_UNIQUE_EQUIPPABLE_SOCKETED, InventoryResult.TOO_MUCH_GOLD, InventoryResult.NOT_DURING_ARENA_MATCH, InventoryResult.CANNOT_TRADE_THAT, InventoryResult.PERSONAL_ARENA_RATING_TOO_LOW}:
            _size += 17

        if self.result == InventoryResult.CANT_EQUIP_LEVEL_I:
            _size += 4

        return _size


@dataclasses.dataclass
class CMSG_INSPECT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_INSPECT:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_INSPECT(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0114))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_INITIATE_TRADE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_INITIATE_TRADE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_INITIATE_TRADE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0116))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BEGIN_TRADE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BEGIN_TRADE:
        return CMSG_BEGIN_TRADE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0117))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BUSY_TRADE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BUSY_TRADE:
        return CMSG_BUSY_TRADE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0118))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_IGNORE_TRADE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_IGNORE_TRADE:
        return CMSG_IGNORE_TRADE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0119))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ACCEPT_TRADE:
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ACCEPT_TRADE:
        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return CMSG_ACCEPT_TRADE(
            unknown1=unknown1,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x011A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.unknown1)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_UNACCEPT_TRADE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_UNACCEPT_TRADE:
        return CMSG_UNACCEPT_TRADE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x011B))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CANCEL_TRADE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_TRADE:
        return CMSG_CANCEL_TRADE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x011C))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_TRADE_ITEM:
    trade_slot: int
    bag: int
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_TRADE_ITEM:
        # trade_slot: u8
        trade_slot = await read_int(reader, 1)

        # bag: u8
        bag = await read_int(reader, 1)

        # slot: u8
        slot = await read_int(reader, 1)

        return CMSG_SET_TRADE_ITEM(
            trade_slot=trade_slot,
            bag=bag,
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(3 + 4, 0x011D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBB'
        _data.extend([self.trade_slot, self.bag, self.slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CLEAR_TRADE_ITEM:
    trade_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CLEAR_TRADE_ITEM:
        # trade_slot: u8
        trade_slot = await read_int(reader, 1)

        return CMSG_CLEAR_TRADE_ITEM(
            trade_slot=trade_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x011E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.trade_slot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_TRADE_GOLD:
    gold: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_TRADE_GOLD:
        # gold: Gold
        gold = await read_int(reader, 4)

        return CMSG_SET_TRADE_GOLD(
            gold=gold,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x011F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.gold)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TRADE_STATUS:
    status: TradeStatus
    unknown1: typing.Optional[int] = None
    inventory_result: typing.Optional[InventoryResult] = None
    target_error: typing.Optional[bool] = None
    item_limit_category_id: typing.Optional[int] = None
    slot: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRADE_STATUS:
        unknown1 = None
        inventory_result = None
        target_error = None
        item_limit_category_id = None
        slot = None
        # status: TradeStatus
        status = TradeStatus(await read_int(reader, 4))

        if status == TradeStatus.BEGIN_TRADE:
            # unknown1: Guid
            unknown1 = await read_int(reader, 8)

        elif status == TradeStatus.CLOSE_WINDOW:
            # inventory_result: InventoryResult
            inventory_result = InventoryResult(await read_int(reader, 4))

            # target_error: Bool8
            target_error = await read_bool(reader, 1)

            # item_limit_category_id: u32
            item_limit_category_id = await read_int(reader, 4)

        elif status in {TradeStatus.ONLY_CONJURED, TradeStatus.NOT_ON_TAPLIST}:
            # slot: u8
            slot = await read_int(reader, 1)

        return SMSG_TRADE_STATUS(
            status=status,
            unknown1=unknown1,
            inventory_result=inventory_result,
            target_error=target_error,
            item_limit_category_id=item_limit_category_id,
            slot=slot,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0120))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.status.value)
        if self.status == TradeStatus.BEGIN_TRADE:
            _fmt += 'Q'
            _data.append(self.unknown1)
        elif self.status == TradeStatus.CLOSE_WINDOW:
            _fmt += 'IBI'
            _data.extend([self.inventory_result.value, self.target_error, self.item_limit_category_id])
        elif self.status in {TradeStatus.ONLY_CONJURED, TradeStatus.NOT_ON_TAPLIST}:
            _fmt += 'B'
            _data.append(self.slot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        if self.status == TradeStatus.BEGIN_TRADE:
            _size += 8
        elif self.status == TradeStatus.CLOSE_WINDOW:
            _size += 9
        elif self.status in {TradeStatus.ONLY_CONJURED, TradeStatus.NOT_ON_TAPLIST}:
            _size += 1

        return _size


@dataclasses.dataclass
class SMSG_TRADE_STATUS_EXTENDED:
    self_player: bool
    trade_id: int
    trade_slot_count1: int
    trade_slot_count2: int
    money_in_trade: int
    spell_on_lowest_slot: int
    trade_slots: typing.List[TradeSlot]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRADE_STATUS_EXTENDED:
        # self_player: Bool8
        self_player = await read_bool(reader, 1)

        # trade_id: u32
        trade_id = await read_int(reader, 4)

        # trade_slot_count1: u32
        trade_slot_count1 = await read_int(reader, 4)

        # trade_slot_count2: u32
        trade_slot_count2 = await read_int(reader, 4)

        # money_in_trade: Gold
        money_in_trade = await read_int(reader, 4)

        # spell_on_lowest_slot: Spell
        spell_on_lowest_slot = await read_int(reader, 4)

        # trade_slots: TradeSlot[7]
        trade_slots = []
        for _ in range(0, 7):
            trade_slots.append(await TradeSlot.read(reader))

        return SMSG_TRADE_STATUS_EXTENDED(
            self_player=self_player,
            trade_id=trade_id,
            trade_slot_count1=trade_slot_count1,
            trade_slot_count2=trade_slot_count2,
            money_in_trade=money_in_trade,
            spell_on_lowest_slot=spell_on_lowest_slot,
            trade_slots=trade_slots,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(532 + 2, 0x0121))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BIIIII'
        _data.extend([self.self_player, self.trade_id, self.trade_slot_count1, self.trade_slot_count2, self.money_in_trade, self.spell_on_lowest_slot])
        # trade_slots: TradeSlot[7]
        for i in self.trade_slots:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_INITIALIZE_FACTIONS:
    factions: typing.List[FactionInitializer]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INITIALIZE_FACTIONS:
        # amount_of_factions: u32
        amount_of_factions = await read_int(reader, 4)

        # factions: FactionInitializer[amount_of_factions]
        factions = []
        for _ in range(0, amount_of_factions):
            factions.append(await FactionInitializer.read(reader))

        return SMSG_INITIALIZE_FACTIONS(
            factions=factions,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0122))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.factions))
        # factions: FactionInitializer[amount_of_factions]
        for i in self.factions:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + 5 * len(self.factions)


@dataclasses.dataclass
class SMSG_SET_FACTION_VISIBLE:
    faction: Faction

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_FACTION_VISIBLE:
        # faction: Faction
        faction = Faction(await read_int(reader, 2))

        return SMSG_SET_FACTION_VISIBLE(
            faction=faction,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 2, 0x0123))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'H'
        _data.append(self.faction.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SET_FACTION_STANDING:
    refer_a_friend_bonus: float
    faction_standings: typing.List[FactionStanding]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_FACTION_STANDING:
        # refer_a_friend_bonus: f32
        refer_a_friend_bonus = await read_float(reader)

        # amount_of_faction_standings: u32
        amount_of_faction_standings = await read_int(reader, 4)

        # faction_standings: FactionStanding[amount_of_faction_standings]
        faction_standings = []
        for _ in range(0, amount_of_faction_standings):
            faction_standings.append(await FactionStanding.read(reader))

        return SMSG_SET_FACTION_STANDING(
            refer_a_friend_bonus=refer_a_friend_bonus,
            faction_standings=faction_standings,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0124))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'fI'
        _data.extend([self.refer_a_friend_bonus, len(self.faction_standings)])
        # faction_standings: FactionStanding[amount_of_faction_standings]
        for i in self.faction_standings:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + 6 * len(self.faction_standings)


@dataclasses.dataclass
class CMSG_SET_FACTION_ATWAR:
    faction: Faction
    flags: FactionFlag

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_FACTION_ATWAR:
        # faction: Faction
        faction = Faction(await read_int(reader, 2))

        # flags: FactionFlag
        flags = FactionFlag(await read_int(reader, 1))

        return CMSG_SET_FACTION_ATWAR(
            faction=faction,
            flags=flags,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(3 + 4, 0x0125))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'HB'
        _data.extend([self.faction.value, self.flags.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SET_PROFICIENCY:
    class_type: ItemClass
    item_sub_class_mask: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_PROFICIENCY:
        # class_type: ItemClass
        class_type = ItemClass(await read_int(reader, 1))

        # item_sub_class_mask: u32
        item_sub_class_mask = await read_int(reader, 4)

        return SMSG_SET_PROFICIENCY(
            class_type=class_type,
            item_sub_class_mask=item_sub_class_mask,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x0127))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BI'
        _data.extend([self.class_type.value, self.item_sub_class_mask])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_ACTION_BUTTON:
    button: int
    action: int
    misc: int
    action_type: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_ACTION_BUTTON:
        # button: u8
        button = await read_int(reader, 1)

        # action: u16
        action = await read_int(reader, 2)

        # misc: u8
        misc = await read_int(reader, 1)

        # action_type: u8
        action_type = await read_int(reader, 1)

        return CMSG_SET_ACTION_BUTTON(
            button=button,
            action=action,
            misc=misc,
            action_type=action_type,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 4, 0x0128))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BHBB'
        _data.extend([self.button, self.action, self.misc, self.action_type])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ACTION_BUTTONS:
    data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ACTION_BUTTONS:
        # data: u32[132]
        data = []
        for _ in range(0, 132):
            data.append(await read_int(reader, 4))

        return SMSG_ACTION_BUTTONS(
            data=data,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(528 + 2, 0x0129))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.data)}I'
        _data.extend([*self.data])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_INITIAL_SPELLS:
    unknown1: int
    initial_spells: typing.List[InitialSpell]
    cooldowns: typing.List[CooldownSpell]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INITIAL_SPELLS:
        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # spell_count: u16
        spell_count = await read_int(reader, 2)

        # initial_spells: InitialSpell[spell_count]
        initial_spells = []
        for _ in range(0, spell_count):
            initial_spells.append(await InitialSpell.read(reader))

        # cooldown_count: u16
        cooldown_count = await read_int(reader, 2)

        # cooldowns: CooldownSpell[cooldown_count]
        cooldowns = []
        for _ in range(0, cooldown_count):
            cooldowns.append(await CooldownSpell.read(reader))

        return SMSG_INITIAL_SPELLS(
            unknown1=unknown1,
            initial_spells=initial_spells,
            cooldowns=cooldowns,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x012A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BH'
        _data.extend([self.unknown1, len(self.initial_spells)])
        # initial_spells: InitialSpell[spell_count]
        for i in self.initial_spells:
            _fmt, _data = i.write(_fmt, _data)

        # cooldown_count: u16
        _fmt += 'H'
        _data.append(len(self.cooldowns))

        # cooldowns: CooldownSpell[cooldown_count]
        for i in self.cooldowns:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + 4 * len(self.initial_spells) + 14 * len(self.cooldowns)


@dataclasses.dataclass
class SMSG_LEARNED_SPELL:
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LEARNED_SPELL:
        # id: Spell
        id = await read_int(reader, 4)

        return SMSG_LEARNED_SPELL(
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x012B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SUPERCEDED_SPELL:
    new_spell_id: int
    old_spell_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SUPERCEDED_SPELL:
        # new_spell_id: u16
        new_spell_id = await read_int(reader, 2)

        # old_spell_id: u16
        old_spell_id = await read_int(reader, 2)

        return SMSG_SUPERCEDED_SPELL(
            new_spell_id=new_spell_id,
            old_spell_id=old_spell_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x012C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'HH'
        _data.extend([self.new_spell_id, self.old_spell_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CAST_SPELL:
    spell: int
    targets: SpellCastTargets

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CAST_SPELL:
        # spell: Spell
        spell = await read_int(reader, 4)

        # targets: SpellCastTargets
        targets = await SpellCastTargets.read(reader)

        return CMSG_CAST_SPELL(
            spell=spell,
            targets=targets,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x012E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.spell)
        # targets: SpellCastTargets
        _fmt, _data = self.targets.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + self.targets.size()


@dataclasses.dataclass
class CMSG_CANCEL_CAST:
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_CAST:
        # id: Spell
        id = await read_int(reader, 4)

        return CMSG_CANCEL_CAST(
            id=id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x012F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CAST_FAILED:
    id: int
    result: SpellCastResult
    multiple_casts: bool
    spell_focus: typing.Optional[int] = None
    area: typing.Optional[Area] = None
    totems: typing.Optional[typing.List[int]] = None
    totem_categories: typing.Optional[typing.List[int]] = None
    item_class: typing.Optional[int] = None
    item_sub_class: typing.Optional[int] = None
    item_inventory_type: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CAST_FAILED:
        spell_focus = None
        area = None
        totems = None
        totem_categories = None
        item_class = None
        item_sub_class = None
        item_inventory_type = None
        # id: Spell
        id = await read_int(reader, 4)

        # result: SpellCastResult
        result = SpellCastResult(await read_int(reader, 1))

        # multiple_casts: Bool8
        multiple_casts = await read_bool(reader, 1)

        if result == SpellCastResult.REQUIRES_SPELL_FOCUS:
            # spell_focus: u32
            spell_focus = await read_int(reader, 4)

        elif result == SpellCastResult.REQUIRES_AREA:
            # area: Area
            area = Area(await read_int(reader, 4))

        elif result == SpellCastResult.TOTEMS:
            # totems: u32[2]
            totems = []
            for _ in range(0, 2):
                totems.append(await read_int(reader, 4))

        elif result == SpellCastResult.TOTEM_CATEGORY:
            # totem_categories: u32[2]
            totem_categories = []
            for _ in range(0, 2):
                totem_categories.append(await read_int(reader, 4))

        elif result == SpellCastResult.EQUIPPED_ITEM_CLASS:
            # item_class: u32
            item_class = await read_int(reader, 4)

            # item_sub_class: u32
            item_sub_class = await read_int(reader, 4)

            # item_inventory_type: u32
            item_inventory_type = await read_int(reader, 4)

        return SMSG_CAST_FAILED(
            id=id,
            result=result,
            multiple_casts=multiple_casts,
            spell_focus=spell_focus,
            area=area,
            totems=totems,
            totem_categories=totem_categories,
            item_class=item_class,
            item_sub_class=item_sub_class,
            item_inventory_type=item_inventory_type,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0130))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IBB'
        _data.extend([self.id, self.result.value, self.multiple_casts])
        if self.result == SpellCastResult.REQUIRES_SPELL_FOCUS:
            _fmt += 'I'
            _data.append(self.spell_focus)
        elif self.result == SpellCastResult.REQUIRES_AREA:
            _fmt += 'I'
            _data.append(self.area.value)
        elif self.result == SpellCastResult.TOTEMS:
            _fmt += f'{len(self.totems)}I'
            _data.extend([*self.totems])
        elif self.result == SpellCastResult.TOTEM_CATEGORY:
            _fmt += f'{len(self.totem_categories)}I'
            _data.extend([*self.totem_categories])
        elif self.result == SpellCastResult.EQUIPPED_ITEM_CLASS:
            _fmt += 'III'
            _data.extend([self.item_class, self.item_sub_class, self.item_inventory_type])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 6

        if self.result == SpellCastResult.REQUIRES_SPELL_FOCUS:
            _size += 4
        elif self.result == SpellCastResult.REQUIRES_AREA:
            _size += 4
        elif self.result == SpellCastResult.TOTEMS:
            _size += 8
        elif self.result == SpellCastResult.TOTEM_CATEGORY:
            _size += 8
        elif self.result == SpellCastResult.EQUIPPED_ITEM_CLASS:
            _size += 12

        return _size


@dataclasses.dataclass
class SMSG_SPELL_START:
    cast_item: int
    caster: int
    spell: int
    cast_count: int
    flags: CastFlags
    timer: int
    targets: SpellCastTargets
    ammo_display_id: typing.Optional[int] = None
    ammo_inventory_type: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELL_START:
        ammo_display_id = None
        ammo_inventory_type = None
        # cast_item: PackedGuid
        cast_item = await read_packed_guid(reader)

        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # spell: Spell
        spell = await read_int(reader, 4)

        # cast_count: u8
        cast_count = await read_int(reader, 1)

        # flags: CastFlags
        flags = CastFlags(await read_int(reader, 2))

        # timer: u32
        timer = await read_int(reader, 4)

        # targets: SpellCastTargets
        targets = await SpellCastTargets.read(reader)

        if CastFlags.AMMO in flags:
            # ammo_display_id: u32
            ammo_display_id = await read_int(reader, 4)

            # ammo_inventory_type: u32
            ammo_inventory_type = await read_int(reader, 4)

        return SMSG_SPELL_START(
            cast_item=cast_item,
            caster=caster,
            spell=spell,
            cast_count=cast_count,
            flags=flags,
            timer=timer,
            targets=targets,
            ammo_display_id=ammo_display_id,
            ammo_inventory_type=ammo_inventory_type,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0131))
        _fmt = "<4s"
        _data = [_data]

        # cast_item: PackedGuid
        _fmt, _data = packed_guid_write(self.cast_item, _fmt, _data)

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # cast_count: u8
        _fmt += 'B'
        _data.append(self.cast_count)

        # flags: CastFlags
        _fmt += 'H'
        _data.append(self.flags.value)

        # timer: u32
        _fmt += 'I'
        _data.append(self.timer)

        # targets: SpellCastTargets
        _fmt, _data = self.targets.write(_fmt, _data)

        if CastFlags.AMMO in self.flags:
            _fmt += 'II'
            _data.extend([self.ammo_display_id, self.ammo_inventory_type])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 11 + packed_guid_size(self.cast_item) + packed_guid_size(self.caster) + self.targets.size()

        if CastFlags.AMMO in self.flags:
            _size += 8

        return _size


@dataclasses.dataclass
class SMSG_SPELL_GO:
    cast_item: int
    caster: int
    spell: int
    flags: CastFlags
    timestamp: int
    hits: typing.List[int]
    misses: typing.List[SpellMiss]
    targets: SpellCastTargets
    ammo_display_id: typing.Optional[int] = None
    ammo_inventory_type: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELL_GO:
        ammo_display_id = None
        ammo_inventory_type = None
        # cast_item: PackedGuid
        cast_item = await read_packed_guid(reader)

        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # spell: Spell
        spell = await read_int(reader, 4)

        # flags: CastFlags
        flags = CastFlags(await read_int(reader, 2))

        # timestamp: u32
        timestamp = await read_int(reader, 4)

        # amount_of_hits: u8
        amount_of_hits = await read_int(reader, 1)

        # hits: Guid[amount_of_hits]
        hits = []
        for _ in range(0, amount_of_hits):
            hits.append(await read_int(reader, 8))

        # amount_of_misses: u8
        amount_of_misses = await read_int(reader, 1)

        # misses: SpellMiss[amount_of_misses]
        misses = []
        for _ in range(0, amount_of_misses):
            misses.append(await SpellMiss.read(reader))

        # targets: SpellCastTargets
        targets = await SpellCastTargets.read(reader)

        if CastFlags.AMMO in flags:
            # ammo_display_id: u32
            ammo_display_id = await read_int(reader, 4)

            # ammo_inventory_type: u32
            ammo_inventory_type = await read_int(reader, 4)

        return SMSG_SPELL_GO(
            cast_item=cast_item,
            caster=caster,
            spell=spell,
            flags=flags,
            timestamp=timestamp,
            hits=hits,
            misses=misses,
            targets=targets,
            ammo_display_id=ammo_display_id,
            ammo_inventory_type=ammo_inventory_type,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0132))
        _fmt = "<4s"
        _data = [_data]

        # cast_item: PackedGuid
        _fmt, _data = packed_guid_write(self.cast_item, _fmt, _data)

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # flags: CastFlags
        _fmt += 'H'
        _data.append(self.flags.value)

        # timestamp: u32
        _fmt += 'I'
        _data.append(self.timestamp)

        # amount_of_hits: u8
        _fmt += 'B'
        _data.append(len(self.hits))

        # hits: Guid[amount_of_hits]
        _fmt += f'{len(self.hits)}Q'
        _data.extend([*self.hits])

        # amount_of_misses: u8
        _fmt += 'B'
        _data.append(len(self.misses))

        # misses: SpellMiss[amount_of_misses]
        for i in self.misses:
            _fmt, _data = i.write(_fmt, _data)

        # targets: SpellCastTargets
        _fmt, _data = self.targets.write(_fmt, _data)

        if CastFlags.AMMO in self.flags:
            _fmt += 'II'
            _data.extend([self.ammo_display_id, self.ammo_inventory_type])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 12 + packed_guid_size(self.cast_item) + packed_guid_size(self.caster) + 8 * len(self.hits) + sum([i.size() for i in self.misses]) + self.targets.size()

        if CastFlags.AMMO in self.flags:
            _size += 8

        return _size


@dataclasses.dataclass
class SMSG_SPELL_FAILURE:
    guid: int
    spell: int
    result: SpellCastResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELL_FAILURE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # spell: Spell
        spell = await read_int(reader, 4)

        # result: SpellCastResult
        result = SpellCastResult(await read_int(reader, 1))

        return SMSG_SPELL_FAILURE(
            guid=guid,
            spell=spell,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(13 + 2, 0x0133))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIB'
        _data.extend([self.guid, self.spell, self.result.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELL_COOLDOWN:
    guid: int
    flags: int
    cooldowns: typing.List[SpellCooldownStatus]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELL_COOLDOWN:
        _size = 0

        # guid: Guid
        guid = await read_int(reader, 8)
        _size += 8

        # flags: u8
        flags = await read_int(reader, 1)
        _size += 1

        # cooldowns: SpellCooldownStatus[-]
        cooldowns = []
        while _size < body_size:
            cooldowns.append(await SpellCooldownStatus.read(reader))
            _size += 8

        return SMSG_SPELL_COOLDOWN(
            guid=guid,
            flags=flags,
            cooldowns=cooldowns,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0134))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.flags])
        # cooldowns: SpellCooldownStatus[-]
        for i in self.cooldowns:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + 8 * len(self.cooldowns)


@dataclasses.dataclass
class SMSG_COOLDOWN_EVENT:
    id: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_COOLDOWN_EVENT:
        # id: Spell
        id = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_COOLDOWN_EVENT(
            id=id,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0135))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.id, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CANCEL_AURA:
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_AURA:
        # id: Spell
        id = await read_int(reader, 4)

        return CMSG_CANCEL_AURA(
            id=id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0136))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_UPDATE_AURA_DURATION:
    aura_slot: int
    aura_duration: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_UPDATE_AURA_DURATION:
        # aura_slot: u8
        aura_slot = await read_int(reader, 1)

        # aura_duration: u32
        aura_duration = await read_int(reader, 4)

        return SMSG_UPDATE_AURA_DURATION(
            aura_slot=aura_slot,
            aura_duration=aura_duration,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x0137))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BI'
        _data.extend([self.aura_slot, self.aura_duration])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PET_CAST_FAILED:
    id: int
    result: SpellCastResult
    multiple_casts: bool
    spell_focus: typing.Optional[int] = None
    area: typing.Optional[Area] = None
    totems: typing.Optional[typing.List[int]] = None
    totem_categories: typing.Optional[typing.List[int]] = None
    item_class: typing.Optional[int] = None
    item_sub_class: typing.Optional[int] = None
    item_inventory_type: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_CAST_FAILED:
        spell_focus = None
        area = None
        totems = None
        totem_categories = None
        item_class = None
        item_sub_class = None
        item_inventory_type = None
        # id: Spell
        id = await read_int(reader, 4)

        # result: SpellCastResult
        result = SpellCastResult(await read_int(reader, 1))

        # multiple_casts: Bool8
        multiple_casts = await read_bool(reader, 1)

        if result == SpellCastResult.REQUIRES_SPELL_FOCUS:
            # spell_focus: u32
            spell_focus = await read_int(reader, 4)

        elif result == SpellCastResult.REQUIRES_AREA:
            # area: Area
            area = Area(await read_int(reader, 4))

        elif result == SpellCastResult.TOTEMS:
            # totems: u32[2]
            totems = []
            for _ in range(0, 2):
                totems.append(await read_int(reader, 4))

        elif result == SpellCastResult.TOTEM_CATEGORY:
            # totem_categories: u32[2]
            totem_categories = []
            for _ in range(0, 2):
                totem_categories.append(await read_int(reader, 4))

        elif result == SpellCastResult.EQUIPPED_ITEM_CLASS:
            # item_class: u32
            item_class = await read_int(reader, 4)

            # item_sub_class: u32
            item_sub_class = await read_int(reader, 4)

            # item_inventory_type: u32
            item_inventory_type = await read_int(reader, 4)

        return SMSG_PET_CAST_FAILED(
            id=id,
            result=result,
            multiple_casts=multiple_casts,
            spell_focus=spell_focus,
            area=area,
            totems=totems,
            totem_categories=totem_categories,
            item_class=item_class,
            item_sub_class=item_sub_class,
            item_inventory_type=item_inventory_type,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0138))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IBB'
        _data.extend([self.id, self.result.value, self.multiple_casts])
        if self.result == SpellCastResult.REQUIRES_SPELL_FOCUS:
            _fmt += 'I'
            _data.append(self.spell_focus)
        elif self.result == SpellCastResult.REQUIRES_AREA:
            _fmt += 'I'
            _data.append(self.area.value)
        elif self.result == SpellCastResult.TOTEMS:
            _fmt += f'{len(self.totems)}I'
            _data.extend([*self.totems])
        elif self.result == SpellCastResult.TOTEM_CATEGORY:
            _fmt += f'{len(self.totem_categories)}I'
            _data.extend([*self.totem_categories])
        elif self.result == SpellCastResult.EQUIPPED_ITEM_CLASS:
            _fmt += 'III'
            _data.extend([self.item_class, self.item_sub_class, self.item_inventory_type])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 6

        if self.result == SpellCastResult.REQUIRES_SPELL_FOCUS:
            _size += 4
        elif self.result == SpellCastResult.REQUIRES_AREA:
            _size += 4
        elif self.result == SpellCastResult.TOTEMS:
            _size += 8
        elif self.result == SpellCastResult.TOTEM_CATEGORY:
            _size += 8
        elif self.result == SpellCastResult.EQUIPPED_ITEM_CLASS:
            _size += 12

        return _size


@dataclasses.dataclass
class MSG_CHANNEL_START_Server:
    caster: int
    spell: int
    duration: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_CHANNEL_START_Server:
        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # spell: Spell
        spell = await read_int(reader, 4)

        # duration: u32
        duration = await read_int(reader, 4)

        return MSG_CHANNEL_START_Server(
            caster=caster,
            spell=spell,
            duration=duration,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0139))
        _fmt = "<4s"
        _data = [_data]

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # duration: u32
        _fmt += 'I'
        _data.append(self.duration)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.caster)


@dataclasses.dataclass
class MSG_CHANNEL_UPDATE_Server:
    caster: int
    time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_CHANNEL_UPDATE_Server:
        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # time: u32
        time = await read_int(reader, 4)

        return MSG_CHANNEL_UPDATE_Server(
            caster=caster,
            time=time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x013A))
        _fmt = "<4s"
        _data = [_data]

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # time: u32
        _fmt += 'I'
        _data.append(self.time)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.caster)


@dataclasses.dataclass
class CMSG_CANCEL_CHANNELLING:
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_CHANNELLING:
        # id: Spell
        id = await read_int(reader, 4)

        return CMSG_CANCEL_CHANNELLING(
            id=id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x013B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AI_REACTION:
    guid: int
    reaction: AiReaction

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AI_REACTION:
        # guid: Guid
        guid = await read_int(reader, 8)

        # reaction: AiReaction
        reaction = AiReaction(await read_int(reader, 4))

        return SMSG_AI_REACTION(
            guid=guid,
            reaction=reaction,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x013C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.reaction.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_SELECTION:
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_SELECTION:
        # target: Guid
        target = await read_int(reader, 8)

        return CMSG_SET_SELECTION(
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x013D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.target)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_TARGET_OBSOLETE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_TARGET_OBSOLETE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_SET_TARGET_OBSOLETE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x013E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ATTACKSWING:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ATTACKSWING:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_ATTACKSWING(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0141))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ATTACKSTOP:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ATTACKSTOP:
        return CMSG_ATTACKSTOP()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0142))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ATTACKSTART:
    attacker: int
    victim: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKSTART:
        # attacker: Guid
        attacker = await read_int(reader, 8)

        # victim: Guid
        victim = await read_int(reader, 8)

        return SMSG_ATTACKSTART(
            attacker=attacker,
            victim=victim,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x0143))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQ'
        _data.extend([self.attacker, self.victim])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ATTACKSTOP:
    player: int
    enemy: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKSTOP:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # enemy: PackedGuid
        enemy = await read_packed_guid(reader)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return SMSG_ATTACKSTOP(
            player=player,
            enemy=enemy,
            unknown1=unknown1,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0144))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # enemy: PackedGuid
        _fmt, _data = packed_guid_write(self.enemy, _fmt, _data)

        # unknown1: u32
        _fmt += 'I'
        _data.append(self.unknown1)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.player) + packed_guid_size(self.enemy)


@dataclasses.dataclass
class SMSG_ATTACKSWING_NOTINRANGE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKSWING_NOTINRANGE:
        return SMSG_ATTACKSWING_NOTINRANGE()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0145))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ATTACKSWING_BADFACING:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKSWING_BADFACING:
        return SMSG_ATTACKSWING_BADFACING()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0146))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ATTACKSWING_NOTSTANDING:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKSWING_NOTSTANDING:
        return SMSG_ATTACKSWING_NOTSTANDING()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0147))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ATTACKSWING_DEADTARGET:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKSWING_DEADTARGET:
        return SMSG_ATTACKSWING_DEADTARGET()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0148))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ATTACKSWING_CANT_ATTACK:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKSWING_CANT_ATTACK:
        return SMSG_ATTACKSWING_CANT_ATTACK()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0149))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ATTACKERSTATEUPDATE:
    hit_info: HitInfo
    attacker: int
    target: int
    total_damage: int
    damages: typing.List[DamageInfo]
    damage_state: int
    unknown1: int
    spell_id: int
    blocked_amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKERSTATEUPDATE:
        # hit_info: HitInfo
        hit_info = HitInfo(await read_int(reader, 4))

        # attacker: PackedGuid
        attacker = await read_packed_guid(reader)

        # target: PackedGuid
        target = await read_packed_guid(reader)

        # total_damage: u32
        total_damage = await read_int(reader, 4)

        # amount_of_damages: u8
        amount_of_damages = await read_int(reader, 1)

        # damages: DamageInfo[amount_of_damages]
        damages = []
        for _ in range(0, amount_of_damages):
            damages.append(await DamageInfo.read(reader))

        # damage_state: u32
        damage_state = await read_int(reader, 4)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # spell_id: u32
        spell_id = await read_int(reader, 4)

        # blocked_amount: u32
        blocked_amount = await read_int(reader, 4)

        return SMSG_ATTACKERSTATEUPDATE(
            hit_info=hit_info,
            attacker=attacker,
            target=target,
            total_damage=total_damage,
            damages=damages,
            damage_state=damage_state,
            unknown1=unknown1,
            spell_id=spell_id,
            blocked_amount=blocked_amount,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x014A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.hit_info.value)
        # attacker: PackedGuid
        _fmt, _data = packed_guid_write(self.attacker, _fmt, _data)

        # target: PackedGuid
        _fmt, _data = packed_guid_write(self.target, _fmt, _data)

        # total_damage: u32
        _fmt += 'I'
        _data.append(self.total_damage)

        # amount_of_damages: u8
        _fmt += 'B'
        _data.append(len(self.damages))

        # damages: DamageInfo[amount_of_damages]
        for i in self.damages:
            _fmt, _data = i.write(_fmt, _data)

        # damage_state: u32
        _fmt += 'I'
        _data.append(self.damage_state)

        # unknown1: u32
        _fmt += 'I'
        _data.append(self.unknown1)

        # spell_id: u32
        _fmt += 'I'
        _data.append(self.spell_id)

        # blocked_amount: u32
        _fmt += 'I'
        _data.append(self.blocked_amount)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 25 + packed_guid_size(self.attacker) + packed_guid_size(self.target) + 20 * len(self.damages)


@dataclasses.dataclass
class SMSG_CANCEL_COMBAT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CANCEL_COMBAT:
        return SMSG_CANCEL_COMBAT()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x014E))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELLHEALLOG:
    victim: int
    caster: int
    id: int
    damage: int
    critical: bool
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLHEALLOG:
        # victim: PackedGuid
        victim = await read_packed_guid(reader)

        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # id: Spell
        id = await read_int(reader, 4)

        # damage: u32
        damage = await read_int(reader, 4)

        # critical: Bool8
        critical = await read_bool(reader, 1)

        # unknown: u8
        unknown = await read_int(reader, 1)

        return SMSG_SPELLHEALLOG(
            victim=victim,
            caster=caster,
            id=id,
            damage=damage,
            critical=critical,
            unknown=unknown,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0150))
        _fmt = "<4s"
        _data = [_data]

        # victim: PackedGuid
        _fmt, _data = packed_guid_write(self.victim, _fmt, _data)

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # id: Spell
        _fmt += 'I'
        _data.append(self.id)

        # damage: u32
        _fmt += 'I'
        _data.append(self.damage)

        # critical: Bool8
        _fmt += 'B'
        _data.append(self.critical)

        # unknown: u8
        _fmt += 'B'
        _data.append(self.unknown)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 10 + packed_guid_size(self.victim) + packed_guid_size(self.caster)


@dataclasses.dataclass
class SMSG_SPELLENERGIZELOG:
    victim: int
    caster: int
    spell: int
    power: Power
    damage: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLENERGIZELOG:
        # victim: PackedGuid
        victim = await read_packed_guid(reader)

        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # spell: Spell
        spell = await read_int(reader, 4)

        # power: Power
        power = Power(await read_int(reader, 4))

        # damage: u32
        damage = await read_int(reader, 4)

        return SMSG_SPELLENERGIZELOG(
            victim=victim,
            caster=caster,
            spell=spell,
            power=power,
            damage=damage,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0151))
        _fmt = "<4s"
        _data = [_data]

        # victim: PackedGuid
        _fmt, _data = packed_guid_write(self.victim, _fmt, _data)

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # power: Power
        _fmt += 'I'
        _data.append(self.power.value)

        # damage: u32
        _fmt += 'I'
        _data.append(self.damage)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + packed_guid_size(self.victim) + packed_guid_size(self.caster)


@dataclasses.dataclass
class SMSG_BINDPOINTUPDATE:
    position: Vector3d
    map: Map
    area: Area

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BINDPOINTUPDATE:
        # position: Vector3d
        position = await Vector3d.read(reader)

        # map: Map
        map = Map(await read_int(reader, 4))

        # area: Area
        area = Area(await read_int(reader, 4))

        return SMSG_BINDPOINTUPDATE(
            position=position,
            map=map,
            area=area,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x0155))
        _fmt = "<4s"
        _data = [_data]

        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # map: Map
        _fmt += 'I'
        _data.append(self.map.value)

        # area: Area
        _fmt += 'I'
        _data.append(self.area.value)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PLAYERBOUND:
    guid: int
    area: Area

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAYERBOUND:
        # guid: Guid
        guid = await read_int(reader, 8)

        # area: Area
        area = Area(await read_int(reader, 4))

        return SMSG_PLAYERBOUND(
            guid=guid,
            area=area,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0158))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.area.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CLIENT_CONTROL_UPDATE:
    guid: int
    allow_movement: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CLIENT_CONTROL_UPDATE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # allow_movement: Bool8
        allow_movement = await read_bool(reader, 1)

        return SMSG_CLIENT_CONTROL_UPDATE(
            guid=guid,
            allow_movement=allow_movement,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0159))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # allow_movement: Bool8
        _fmt += 'B'
        _data.append(self.allow_movement)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_REPOP_REQUEST:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REPOP_REQUEST:
        return CMSG_REPOP_REQUEST()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x015A))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_RESURRECT_REQUEST:
    guid: int
    name: str
    player: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RESURRECT_REQUEST:
        # guid: Guid
        guid = await read_int(reader, 8)

        # name: SizedCString
        name = await read_sized_cstring(reader)

        # player: Bool8
        player = await read_bool(reader, 1)

        return SMSG_RESURRECT_REQUEST(
            guid=guid,
            name=name,
            player=player,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x015B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QI{len(self.name)}sBB'
        _data.extend([self.guid, len(self.name) + 1, self.name.encode('utf-8'), 0, self.player])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 14 + len(self.name)


@dataclasses.dataclass
class CMSG_RESURRECT_RESPONSE:
    guid: int
    status: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_RESURRECT_RESPONSE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # status: u8
        status = await read_int(reader, 1)

        return CMSG_RESURRECT_RESPONSE(
            guid=guid,
            status=status,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x015C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.status])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LOOT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOOT:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_LOOT(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x015D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LOOT_MONEY:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOOT_MONEY:
        return CMSG_LOOT_MONEY()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x015E))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LOOT_RELEASE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOOT_RELEASE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_LOOT_RELEASE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x015F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_RESPONSE:
    guid: int
    loot_method: LootMethod
    gold: int
    items: typing.List[LootItem]
    loot_error: typing.Optional[LootMethodError] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_RESPONSE:
        loot_error = None
        # guid: Guid
        guid = await read_int(reader, 8)

        # loot_method: LootMethod
        loot_method = LootMethod(await read_int(reader, 1))

        if loot_method == LootMethod.ERROR:
            # loot_error: LootMethodError
            loot_error = LootMethodError(await read_int(reader, 1))

        # gold: Gold
        gold = await read_int(reader, 4)

        # amount_of_items: u8
        amount_of_items = await read_int(reader, 1)

        # items: LootItem[amount_of_items]
        items = []
        for _ in range(0, amount_of_items):
            items.append(await LootItem.read(reader))

        return SMSG_LOOT_RESPONSE(
            guid=guid,
            loot_method=loot_method,
            loot_error=loot_error,
            gold=gold,
            items=items,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0160))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.loot_method.value])
        if self.loot_method == LootMethod.ERROR:
            _fmt += 'B'
            _data.append(self.loot_error.value)
        # gold: Gold
        _fmt += 'I'
        _data.append(self.gold)

        # amount_of_items: u8
        _fmt += 'B'
        _data.append(len(self.items))

        # items: LootItem[amount_of_items]
        for i in self.items:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 14 + 6 * len(self.items)

        if self.loot_method == LootMethod.ERROR:
            _size += 1

        return _size


@dataclasses.dataclass
class SMSG_LOOT_RELEASE_RESPONSE:
    guid: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_RELEASE_RESPONSE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        return SMSG_LOOT_RELEASE_RESPONSE(
            guid=guid,
            unknown1=unknown1,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x0161))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.unknown1])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_REMOVED:
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_REMOVED:
        # slot: u8
        slot = await read_int(reader, 1)

        return SMSG_LOOT_REMOVED(
            slot=slot,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x0162))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.slot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_MONEY_NOTIFY:
    amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_MONEY_NOTIFY:
        # amount: u32
        amount = await read_int(reader, 4)

        return SMSG_LOOT_MONEY_NOTIFY(
            amount=amount,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0163))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.amount)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_CLEAR_MONEY:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_CLEAR_MONEY:
        return SMSG_LOOT_CLEAR_MONEY()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0165))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_PUSH_RESULT:
    guid: int
    source: NewItemSource
    creation_type: NewItemCreationType
    alert_chat: NewItemChatAlert
    bag_slot: int
    item_slot: int
    item: int
    item_suffix_factor: int
    item_random_property_id: int
    item_count: int
    item_count_in_inventory: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_PUSH_RESULT:
        # guid: Guid
        guid = await read_int(reader, 8)

        # source: NewItemSource
        source = NewItemSource(await read_int(reader, 4))

        # creation_type: NewItemCreationType
        creation_type = NewItemCreationType(await read_int(reader, 4))

        # alert_chat: NewItemChatAlert
        alert_chat = NewItemChatAlert(await read_int(reader, 4))

        # bag_slot: u8
        bag_slot = await read_int(reader, 1)

        # item_slot: u32
        item_slot = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        # item_suffix_factor: u32
        item_suffix_factor = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # item_count: u32
        item_count = await read_int(reader, 4)

        # item_count_in_inventory: u32
        item_count_in_inventory = await read_int(reader, 4)

        return SMSG_ITEM_PUSH_RESULT(
            guid=guid,
            source=source,
            creation_type=creation_type,
            alert_chat=alert_chat,
            bag_slot=bag_slot,
            item_slot=item_slot,
            item=item,
            item_suffix_factor=item_suffix_factor,
            item_random_property_id=item_random_property_id,
            item_count=item_count,
            item_count_in_inventory=item_count_in_inventory,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(45 + 2, 0x0166))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIIIBIIIIII'
        _data.extend([self.guid, self.source.value, self.creation_type.value, self.alert_chat.value, self.bag_slot, self.item_slot, self.item, self.item_suffix_factor, self.item_random_property_id, self.item_count, self.item_count_in_inventory])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DUEL_REQUESTED:
    initiator: int
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DUEL_REQUESTED:
        # initiator: Guid
        initiator = await read_int(reader, 8)

        # target: Guid
        target = await read_int(reader, 8)

        return SMSG_DUEL_REQUESTED(
            initiator=initiator,
            target=target,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x0167))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQ'
        _data.extend([self.initiator, self.target])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DUEL_OUTOFBOUNDS:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DUEL_OUTOFBOUNDS:
        return SMSG_DUEL_OUTOFBOUNDS()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0168))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DUEL_INBOUNDS:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DUEL_INBOUNDS:
        return SMSG_DUEL_INBOUNDS()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0169))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DUEL_COMPLETE:
    ended_without_interruption: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DUEL_COMPLETE:
        # ended_without_interruption: Bool8
        ended_without_interruption = await read_bool(reader, 1)

        return SMSG_DUEL_COMPLETE(
            ended_without_interruption=ended_without_interruption,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x016A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.ended_without_interruption)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DUEL_WINNER:
    reason: DuelWinnerReason
    opponent_name: str
    initiator_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DUEL_WINNER:
        # reason: DuelWinnerReason
        reason = DuelWinnerReason(await read_int(reader, 1))

        # opponent_name: CString
        opponent_name = await read_cstring(reader)

        # initiator_name: CString
        initiator_name = await read_cstring(reader)

        return SMSG_DUEL_WINNER(
            reason=reason,
            opponent_name=opponent_name,
            initiator_name=initiator_name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x016B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'B{len(self.opponent_name)}sB{len(self.initiator_name)}sB'
        _data.extend([self.reason.value, self.opponent_name.encode('utf-8'), 0, self.initiator_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 3 + len(self.opponent_name) + len(self.initiator_name)


@dataclasses.dataclass
class CMSG_DUEL_ACCEPTED:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_DUEL_ACCEPTED:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_DUEL_ACCEPTED(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x016C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_DUEL_CANCELLED:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_DUEL_CANCELLED:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_DUEL_CANCELLED(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x016D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MOUNTRESULT:
    result: MountResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOUNTRESULT:
        # result: MountResult
        result = MountResult(await read_int(reader, 4))

        return SMSG_MOUNTRESULT(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x016E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MOUNTSPECIAL_ANIM:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOUNTSPECIAL_ANIM:
        return CMSG_MOUNTSPECIAL_ANIM()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0171))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MOUNTSPECIAL_ANIM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOUNTSPECIAL_ANIM:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_MOUNTSPECIAL_ANIM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0172))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PET_TAME_FAILURE:
    reason: PetTameFailureReason

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_TAME_FAILURE:
        # reason: PetTameFailureReason
        reason = PetTameFailureReason(await read_int(reader, 1))

        return SMSG_PET_TAME_FAILURE(
            reason=reason,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x0173))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.reason.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PET_SET_ACTION:
    guid: int
    position1: int
    data1: int
    position2: typing.Optional[int] = None
    data2: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_SET_ACTION:
        position2 = None
        data2 = None
        _size = 0

        # guid: Guid
        guid = await read_int(reader, 8)
        _size += 8

        # position1: u32
        position1 = await read_int(reader, 4)
        _size += 4

        # data1: u32
        data1 = await read_int(reader, 4)
        _size += 4

        # extra: optional
        if _size < body_size:
            # position2: u32
            position2 = await read_int(reader, 4)
            _size += 4

            # data2: u32
            data2 = await read_int(reader, 4)
            _size += 4

        return CMSG_PET_SET_ACTION(
            guid=guid,
            position1=position1,
            data1=data1,
            position2=position2,
            data2=data2,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0174))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.guid, self.position1, self.data1])
        # extra: optional
        if self.position2 is not None and self.data2 is not None:
            _fmt += 'II'
            _data.extend([self.position2, self.data2])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 16

        # extra: optional
        if self.position2 is not None and self.data2 is not None:
            _size += 8

        return _size


@dataclasses.dataclass
class CMSG_PET_ACTION:
    pet: int
    data: int
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_ACTION:
        # pet: Guid
        pet = await read_int(reader, 8)

        # data: u32
        data = await read_int(reader, 4)

        # target: Guid
        target = await read_int(reader, 8)

        return CMSG_PET_ACTION(
            pet=pet,
            data=data,
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 4, 0x0175))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIQ'
        _data.extend([self.pet, self.data, self.target])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PET_ABANDON:
    pet: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_ABANDON:
        # pet: Guid
        pet = await read_int(reader, 8)

        return CMSG_PET_ABANDON(
            pet=pet,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0176))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.pet)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PET_RENAME:
    pet: int
    name: str
    declined: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_RENAME:
        # pet: Guid
        pet = await read_int(reader, 8)

        # name: CString
        name = await read_cstring(reader)

        # declined: Bool8
        declined = await read_bool(reader, 1)

        return CMSG_PET_RENAME(
            pet=pet,
            name=name,
            declined=declined,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0177))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.name)}sBB'
        _data.extend([self.pet, self.name.encode('utf-8'), 0, self.declined])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 10 + len(self.name)


@dataclasses.dataclass
class SMSG_PET_NAME_INVALID:
    reason: PetNameInvalidReason
    name: str
    included: DeclinedPetNameIncluded
    declined_names: typing.Optional[typing.List[str]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_NAME_INVALID:
        declined_names = None
        # reason: PetNameInvalidReason
        reason = PetNameInvalidReason(await read_int(reader, 4))

        # name: CString
        name = await read_cstring(reader)

        # included: DeclinedPetNameIncluded
        included = DeclinedPetNameIncluded(await read_int(reader, 1))

        if included == DeclinedPetNameIncluded.INCLUDED:
            # declined_names: CString[5]
            declined_names = []
            for _ in range(0, 5):
                declined_names.append(await read_cstring(reader))

        return SMSG_PET_NAME_INVALID(
            reason=reason,
            name=name,
            included=included,
            declined_names=declined_names,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0178))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.name)}sBB'
        _data.extend([self.reason.value, self.name.encode('utf-8'), 0, self.included.value])
        if self.included == DeclinedPetNameIncluded.INCLUDED:
            # declined_names: CString[5]
            for i in self.declined_names:
                _fmt += f'{len(i)}sB'
                _data.append(i.encode('utf-8'))
                _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 6 + len(self.name)

        if self.included == DeclinedPetNameIncluded.INCLUDED:
            _size += 0 + sum([len(i) + 1 for i in self.declined_names])

        return _size


@dataclasses.dataclass
class SMSG_PET_SPELLS:
    pet: int
    duration: typing.Optional[int] = None
    react: typing.Optional[PetReactState] = None
    command: typing.Optional[PetCommandState] = None
    unknown: typing.Optional[int] = None
    pet_enabled: typing.Optional[PetEnabled] = None
    action_bars: typing.Optional[typing.List[int]] = None
    spells: typing.Optional[typing.List[int]] = None
    cooldowns: typing.Optional[typing.List[PetSpellCooldown]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_SPELLS:
        duration = None
        react = None
        command = None
        unknown = None
        pet_enabled = None
        action_bars = None
        amount_of_spells = None
        spells = None
        amount_of_cooldowns = None
        cooldowns = None
        _size = 0

        # pet: Guid
        pet = await read_int(reader, 8)
        _size += 8

        # action_bars: optional
        if _size < body_size:
            # duration: u32
            duration = await read_int(reader, 4)
            _size += 4

            # react: PetReactState
            react = PetReactState(await read_int(reader, 1))
            _size += 1

            # command: PetCommandState
            command = PetCommandState(await read_int(reader, 1))
            _size += 1

            # unknown: u8
            unknown = await read_int(reader, 1)
            _size += 1

            # pet_enabled: PetEnabled
            pet_enabled = PetEnabled(await read_int(reader, 1))
            _size += 1

            # action_bars: u32[10]
            action_bars = []
            for _ in range(0, 10):
                action_bars.append(await read_int(reader, 4))
                _size += 4

            # amount_of_spells: u8
            amount_of_spells = await read_int(reader, 1)
            _size += 1

            # spells: u32[amount_of_spells]
            spells = []
            for _ in range(0, amount_of_spells):
                spells.append(await read_int(reader, 4))
                _size += 4

            # amount_of_cooldowns: u8
            amount_of_cooldowns = await read_int(reader, 1)
            _size += 1

            # cooldowns: PetSpellCooldown[amount_of_cooldowns]
            cooldowns = []
            for _ in range(0, amount_of_cooldowns):
                cooldowns.append(await PetSpellCooldown.read(reader))
                _size += 12

        return SMSG_PET_SPELLS(
            pet=pet,
            duration=duration,
            react=react,
            command=command,
            unknown=unknown,
            pet_enabled=pet_enabled,
            action_bars=action_bars,
            spells=spells,
            cooldowns=cooldowns,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0179))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.pet)
        # action_bars: optional
        if self.duration is not None and self.react is not None and self.command is not None and self.unknown is not None and self.pet_enabled is not None and self.action_bars is not None and self.spells is not None and self.cooldowns is not None:
            _fmt += f'IBBBB{len(self.action_bars)}IB{len(self.spells)}IB'
            _data.extend([self.duration, self.react.value, self.command.value, self.unknown, self.pet_enabled.value, *self.action_bars, len(self.spells), *self.spells, len(self.cooldowns)])
            # cooldowns: PetSpellCooldown[amount_of_cooldowns]
            for i in self.cooldowns:
                _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 8

        # action_bars: optional
        if self.duration is not None and self.react is not None and self.command is not None and self.unknown is not None and self.pet_enabled is not None and self.action_bars is not None and self.spells is not None and self.cooldowns is not None:
            _size += 50 + 4 * len(self.spells) + 12 * len(self.cooldowns)

        return _size


@dataclasses.dataclass
class SMSG_PET_MODE:
    guid: int
    react_state: PetReactState
    command_state: PetCommandState
    unknown1: int
    pet_enabled: PetEnabled

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_MODE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # react_state: PetReactState
        react_state = PetReactState(await read_int(reader, 1))

        # command_state: PetCommandState
        command_state = PetCommandState(await read_int(reader, 1))

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # pet_enabled: PetEnabled
        pet_enabled = PetEnabled(await read_int(reader, 1))

        return SMSG_PET_MODE(
            guid=guid,
            react_state=react_state,
            command_state=command_state,
            unknown1=unknown1,
            pet_enabled=pet_enabled,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x017A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QBBBB'
        _data.extend([self.guid, self.react_state.value, self.command_state.value, self.unknown1, self.pet_enabled.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GOSSIP_HELLO:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GOSSIP_HELLO:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_GOSSIP_HELLO(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x017B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GOSSIP_SELECT_OPTION:
    guid: int
    menu_id: int
    gossip_list_id: int
    code: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GOSSIP_SELECT_OPTION:
        code = None
        _size = 0

        # guid: Guid
        guid = await read_int(reader, 8)
        _size += 8

        # menu_id: u32
        menu_id = await read_int(reader, 4)
        _size += 4

        # gossip_list_id: u32
        gossip_list_id = await read_int(reader, 4)
        _size += 4

        # unknown: optional
        if _size < body_size:
            # code: CString
            code = await read_cstring(reader)
            _size += len(code) + 1

        return CMSG_GOSSIP_SELECT_OPTION(
            guid=guid,
            menu_id=menu_id,
            gossip_list_id=gossip_list_id,
            code=code,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x017C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.guid, self.menu_id, self.gossip_list_id])
        # unknown: optional
        if self.code is not None:
            _fmt += f'{len(self.code)}sB'
            _data.extend([self.code.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 16

        # unknown: optional
        if self.code is not None:
            _size += 1 + len(self.code)

        return _size


@dataclasses.dataclass
class SMSG_GOSSIP_MESSAGE:
    guid: int
    menu_id: int
    title_text_id: int
    gossips: typing.List[GossipItem]
    quests: typing.List[QuestItem]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GOSSIP_MESSAGE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # menu_id: u32
        menu_id = await read_int(reader, 4)

        # title_text_id: u32
        title_text_id = await read_int(reader, 4)

        # amount_of_gossip_items: u32
        amount_of_gossip_items = await read_int(reader, 4)

        # gossips: GossipItem[amount_of_gossip_items]
        gossips = []
        for _ in range(0, amount_of_gossip_items):
            gossips.append(await GossipItem.read(reader))

        # amount_of_quests: u32
        amount_of_quests = await read_int(reader, 4)

        # quests: QuestItem[amount_of_quests]
        quests = []
        for _ in range(0, amount_of_quests):
            quests.append(await QuestItem.read(reader))

        return SMSG_GOSSIP_MESSAGE(
            guid=guid,
            menu_id=menu_id,
            title_text_id=title_text_id,
            gossips=gossips,
            quests=quests,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x017D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIII'
        _data.extend([self.guid, self.menu_id, self.title_text_id, len(self.gossips)])
        # gossips: GossipItem[amount_of_gossip_items]
        for i in self.gossips:
            _fmt, _data = i.write(_fmt, _data)

        # amount_of_quests: u32
        _fmt += 'I'
        _data.append(len(self.quests))

        # quests: QuestItem[amount_of_quests]
        for i in self.quests:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 24 + sum([i.size() for i in self.gossips]) + sum([i.size() for i in self.quests])


@dataclasses.dataclass
class SMSG_GOSSIP_COMPLETE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GOSSIP_COMPLETE:
        return SMSG_GOSSIP_COMPLETE()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x017E))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_NPC_TEXT_QUERY:
    text_id: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_NPC_TEXT_QUERY:
        # text_id: u32
        text_id = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_NPC_TEXT_QUERY(
            text_id=text_id,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x017F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.text_id, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_NPC_TEXT_UPDATE:
    text_id: int
    texts: typing.List[NpcTextUpdate]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_NPC_TEXT_UPDATE:
        # text_id: u32
        text_id = await read_int(reader, 4)

        # texts: NpcTextUpdate[8]
        texts = []
        for _ in range(0, 8):
            texts.append(await NpcTextUpdate.read(reader))

        return SMSG_NPC_TEXT_UPDATE(
            text_id=text_id,
            texts=texts,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0180))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.text_id)
        # texts: NpcTextUpdate[8]
        for i in self.texts:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + sum([i.size() for i in self.texts])


@dataclasses.dataclass
class CMSG_QUESTGIVER_STATUS_QUERY:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_STATUS_QUERY:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_QUESTGIVER_STATUS_QUERY(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0182))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_STATUS:
    guid: int
    status: QuestGiverStatus

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_STATUS:
        # guid: Guid
        guid = await read_int(reader, 8)

        # status: QuestGiverStatus
        status = QuestGiverStatus(await read_int(reader, 4))

        return SMSG_QUESTGIVER_STATUS(
            guid=guid,
            status=status,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0183))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.status.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUESTGIVER_HELLO:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_HELLO:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_QUESTGIVER_HELLO(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0184))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_QUEST_LIST:
    npc: int
    title: str
    emote_delay: int
    emote: int
    quest_items: typing.List[QuestItem]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_QUEST_LIST:
        # npc: Guid
        npc = await read_int(reader, 8)

        # title: CString
        title = await read_cstring(reader)

        # emote_delay: u32
        emote_delay = await read_int(reader, 4)

        # emote: u32
        emote = await read_int(reader, 4)

        # amount_of_entries: u8
        amount_of_entries = await read_int(reader, 1)

        # quest_items: QuestItem[amount_of_entries]
        quest_items = []
        for _ in range(0, amount_of_entries):
            quest_items.append(await QuestItem.read(reader))

        return SMSG_QUESTGIVER_QUEST_LIST(
            npc=npc,
            title=title,
            emote_delay=emote_delay,
            emote=emote,
            quest_items=quest_items,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0185))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'Q{len(self.title)}sBIIB'
        _data.extend([self.npc, self.title.encode('utf-8'), 0, self.emote_delay, self.emote, len(self.quest_items)])
        # quest_items: QuestItem[amount_of_entries]
        for i in self.quest_items:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 18 + len(self.title) + sum([i.size() for i in self.quest_items])


@dataclasses.dataclass
class CMSG_QUESTGIVER_QUERY_QUEST:
    guid: int
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_QUERY_QUEST:
        # guid: Guid
        guid = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return CMSG_QUESTGIVER_QUERY_QUEST(
            guid=guid,
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0186))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.quest_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUESTGIVER_QUEST_AUTOLAUNCH:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_QUEST_AUTOLAUNCH:
        return CMSG_QUESTGIVER_QUEST_AUTOLAUNCH()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0187))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_QUEST_DETAILS:
    guid: int
    quest_id: int
    title: str
    details: str
    objectives: str
    auto_finish: bool
    suggested_players: int
    choice_item_rewards: typing.List[QuestItemReward]
    item_rewards: typing.List[QuestItemReward]
    money_reward: int
    honor_reward: int
    reward_spell: int
    casted_spell: int
    title_reward: int
    emotes: typing.List[QuestDetailsEmote]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_QUEST_DETAILS:
        # guid: Guid
        guid = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # title: CString
        title = await read_cstring(reader)

        # details: CString
        details = await read_cstring(reader)

        # objectives: CString
        objectives = await read_cstring(reader)

        # auto_finish: Bool32
        auto_finish = await read_bool(reader, 4)

        # suggested_players: u32
        suggested_players = await read_int(reader, 4)

        # amount_of_choice_item_rewards: u32
        amount_of_choice_item_rewards = await read_int(reader, 4)

        # choice_item_rewards: QuestItemReward[amount_of_choice_item_rewards]
        choice_item_rewards = []
        for _ in range(0, amount_of_choice_item_rewards):
            choice_item_rewards.append(await QuestItemReward.read(reader))

        # amount_of_item_rewards: u32
        amount_of_item_rewards = await read_int(reader, 4)

        # item_rewards: QuestItemReward[amount_of_item_rewards]
        item_rewards = []
        for _ in range(0, amount_of_item_rewards):
            item_rewards.append(await QuestItemReward.read(reader))

        # money_reward: Gold
        money_reward = await read_int(reader, 4)

        # honor_reward: u32
        honor_reward = await read_int(reader, 4)

        # reward_spell: Spell
        reward_spell = await read_int(reader, 4)

        # casted_spell: Spell
        casted_spell = await read_int(reader, 4)

        # title_reward: u32
        title_reward = await read_int(reader, 4)

        # amount_of_emotes: u32
        amount_of_emotes = await read_int(reader, 4)

        # emotes: QuestDetailsEmote[amount_of_emotes]
        emotes = []
        for _ in range(0, amount_of_emotes):
            emotes.append(await QuestDetailsEmote.read(reader))

        return SMSG_QUESTGIVER_QUEST_DETAILS(
            guid=guid,
            quest_id=quest_id,
            title=title,
            details=details,
            objectives=objectives,
            auto_finish=auto_finish,
            suggested_players=suggested_players,
            choice_item_rewards=choice_item_rewards,
            item_rewards=item_rewards,
            money_reward=money_reward,
            honor_reward=honor_reward,
            reward_spell=reward_spell,
            casted_spell=casted_spell,
            title_reward=title_reward,
            emotes=emotes,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0188))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QI{len(self.title)}sB{len(self.details)}sB{len(self.objectives)}sBIII'
        _data.extend([self.guid, self.quest_id, self.title.encode('utf-8'), 0, self.details.encode('utf-8'), 0, self.objectives.encode('utf-8'), 0, self.auto_finish, self.suggested_players, len(self.choice_item_rewards)])
        # choice_item_rewards: QuestItemReward[amount_of_choice_item_rewards]
        for i in self.choice_item_rewards:
            _fmt, _data = i.write(_fmt, _data)

        # amount_of_item_rewards: u32
        _fmt += 'I'
        _data.append(len(self.item_rewards))

        # item_rewards: QuestItemReward[amount_of_item_rewards]
        for i in self.item_rewards:
            _fmt, _data = i.write(_fmt, _data)

        # money_reward: Gold
        _fmt += 'I'
        _data.append(self.money_reward)

        # honor_reward: u32
        _fmt += 'I'
        _data.append(self.honor_reward)

        # reward_spell: Spell
        _fmt += 'I'
        _data.append(self.reward_spell)

        # casted_spell: Spell
        _fmt += 'I'
        _data.append(self.casted_spell)

        # title_reward: u32
        _fmt += 'I'
        _data.append(self.title_reward)

        # amount_of_emotes: u32
        _fmt += 'I'
        _data.append(len(self.emotes))

        # emotes: QuestDetailsEmote[amount_of_emotes]
        for i in self.emotes:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 55 + len(self.title) + len(self.details) + len(self.objectives) + 8 * len(self.choice_item_rewards) + 8 * len(self.item_rewards) + 8 * len(self.emotes)


@dataclasses.dataclass
class CMSG_QUESTGIVER_ACCEPT_QUEST:
    guid: int
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_ACCEPT_QUEST:
        # guid: Guid
        guid = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return CMSG_QUESTGIVER_ACCEPT_QUEST(
            guid=guid,
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0189))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.quest_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUESTGIVER_COMPLETE_QUEST:
    guid: int
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_COMPLETE_QUEST:
        # guid: Guid
        guid = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return CMSG_QUESTGIVER_COMPLETE_QUEST(
            guid=guid,
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x018A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.quest_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_REQUEST_ITEMS:
    npc: int
    quest_id: int
    title: str
    request_items_text: str
    emote_delay: int
    emote: int
    auto_finish: bool
    suggested_players: int
    required_money: int
    required_items: typing.List[QuestItemRequirement]
    completable: QuestCompletable
    flags1: int
    flags2: int
    flags3: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_REQUEST_ITEMS:
        # npc: Guid
        npc = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # title: CString
        title = await read_cstring(reader)

        # request_items_text: CString
        request_items_text = await read_cstring(reader)

        # emote_delay: u32
        emote_delay = await read_int(reader, 4)

        # emote: u32
        emote = await read_int(reader, 4)

        # auto_finish: Bool32
        auto_finish = await read_bool(reader, 4)

        # suggested_players: u32
        suggested_players = await read_int(reader, 4)

        # required_money: Gold
        required_money = await read_int(reader, 4)

        # amount_of_required_items: u32
        amount_of_required_items = await read_int(reader, 4)

        # required_items: QuestItemRequirement[amount_of_required_items]
        required_items = []
        for _ in range(0, amount_of_required_items):
            required_items.append(await QuestItemRequirement.read(reader))

        # completable: QuestCompletable
        completable = QuestCompletable(await read_int(reader, 4))

        # flags1: u32
        flags1 = await read_int(reader, 4)

        # flags2: u32
        flags2 = await read_int(reader, 4)

        # flags3: u32
        flags3 = await read_int(reader, 4)

        return SMSG_QUESTGIVER_REQUEST_ITEMS(
            npc=npc,
            quest_id=quest_id,
            title=title,
            request_items_text=request_items_text,
            emote_delay=emote_delay,
            emote=emote,
            auto_finish=auto_finish,
            suggested_players=suggested_players,
            required_money=required_money,
            required_items=required_items,
            completable=completable,
            flags1=flags1,
            flags2=flags2,
            flags3=flags3,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x018B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QI{len(self.title)}sB{len(self.request_items_text)}sBIIIIII'
        _data.extend([self.npc, self.quest_id, self.title.encode('utf-8'), 0, self.request_items_text.encode('utf-8'), 0, self.emote_delay, self.emote, self.auto_finish, self.suggested_players, self.required_money, len(self.required_items)])
        # required_items: QuestItemRequirement[amount_of_required_items]
        for i in self.required_items:
            _fmt, _data = i.write(_fmt, _data)

        # completable: QuestCompletable
        _fmt += 'I'
        _data.append(self.completable.value)

        # flags1: u32
        _fmt += 'I'
        _data.append(self.flags1)

        # flags2: u32
        _fmt += 'I'
        _data.append(self.flags2)

        # flags3: u32
        _fmt += 'I'
        _data.append(self.flags3)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 54 + len(self.title) + len(self.request_items_text) + 12 * len(self.required_items)


@dataclasses.dataclass
class CMSG_QUESTGIVER_REQUEST_REWARD:
    guid: int
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_REQUEST_REWARD:
        # guid: Guid
        guid = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return CMSG_QUESTGIVER_REQUEST_REWARD(
            guid=guid,
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x018C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.quest_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_OFFER_REWARD:
    npc: int
    quest_id: int
    title: str
    offer_reward_text: str
    auto_finish: bool
    suggested_players: int
    emotes: typing.List[NpcTextUpdateEmote]
    choice_item_rewards: typing.List[QuestItemRequirement]
    item_rewards: typing.List[QuestItemRequirement]
    money_reward: int
    honor_reward: int
    unknown1: int
    reward_spell: int
    reward_spell_cast: int
    title_reward: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_OFFER_REWARD:
        # npc: Guid
        npc = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # title: CString
        title = await read_cstring(reader)

        # offer_reward_text: CString
        offer_reward_text = await read_cstring(reader)

        # auto_finish: Bool32
        auto_finish = await read_bool(reader, 4)

        # suggested_players: u32
        suggested_players = await read_int(reader, 4)

        # amount_of_emotes: u32
        amount_of_emotes = await read_int(reader, 4)

        # emotes: NpcTextUpdateEmote[amount_of_emotes]
        emotes = []
        for _ in range(0, amount_of_emotes):
            emotes.append(await NpcTextUpdateEmote.read(reader))

        # amount_of_choice_item_rewards: u32
        amount_of_choice_item_rewards = await read_int(reader, 4)

        # choice_item_rewards: QuestItemRequirement[amount_of_choice_item_rewards]
        choice_item_rewards = []
        for _ in range(0, amount_of_choice_item_rewards):
            choice_item_rewards.append(await QuestItemRequirement.read(reader))

        # amount_of_item_rewards: u32
        amount_of_item_rewards = await read_int(reader, 4)

        # item_rewards: QuestItemRequirement[amount_of_item_rewards]
        item_rewards = []
        for _ in range(0, amount_of_item_rewards):
            item_rewards.append(await QuestItemRequirement.read(reader))

        # money_reward: Gold
        money_reward = await read_int(reader, 4)

        # honor_reward: u32
        honor_reward = await read_int(reader, 4)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # reward_spell: Spell
        reward_spell = await read_int(reader, 4)

        # reward_spell_cast: Spell
        reward_spell_cast = await read_int(reader, 4)

        # title_reward: u32
        title_reward = await read_int(reader, 4)

        return SMSG_QUESTGIVER_OFFER_REWARD(
            npc=npc,
            quest_id=quest_id,
            title=title,
            offer_reward_text=offer_reward_text,
            auto_finish=auto_finish,
            suggested_players=suggested_players,
            emotes=emotes,
            choice_item_rewards=choice_item_rewards,
            item_rewards=item_rewards,
            money_reward=money_reward,
            honor_reward=honor_reward,
            unknown1=unknown1,
            reward_spell=reward_spell,
            reward_spell_cast=reward_spell_cast,
            title_reward=title_reward,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x018D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QI{len(self.title)}sB{len(self.offer_reward_text)}sBIII'
        _data.extend([self.npc, self.quest_id, self.title.encode('utf-8'), 0, self.offer_reward_text.encode('utf-8'), 0, self.auto_finish, self.suggested_players, len(self.emotes)])
        # emotes: NpcTextUpdateEmote[amount_of_emotes]
        for i in self.emotes:
            _fmt, _data = i.write(_fmt, _data)

        # amount_of_choice_item_rewards: u32
        _fmt += 'I'
        _data.append(len(self.choice_item_rewards))

        # choice_item_rewards: QuestItemRequirement[amount_of_choice_item_rewards]
        for i in self.choice_item_rewards:
            _fmt, _data = i.write(_fmt, _data)

        # amount_of_item_rewards: u32
        _fmt += 'I'
        _data.append(len(self.item_rewards))

        # item_rewards: QuestItemRequirement[amount_of_item_rewards]
        for i in self.item_rewards:
            _fmt, _data = i.write(_fmt, _data)

        # money_reward: Gold
        _fmt += 'I'
        _data.append(self.money_reward)

        # honor_reward: u32
        _fmt += 'I'
        _data.append(self.honor_reward)

        # unknown1: u32
        _fmt += 'I'
        _data.append(self.unknown1)

        # reward_spell: Spell
        _fmt += 'I'
        _data.append(self.reward_spell)

        # reward_spell_cast: Spell
        _fmt += 'I'
        _data.append(self.reward_spell_cast)

        # title_reward: u32
        _fmt += 'I'
        _data.append(self.title_reward)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 58 + len(self.title) + len(self.offer_reward_text) + 8 * len(self.emotes) + 12 * len(self.choice_item_rewards) + 12 * len(self.item_rewards)


@dataclasses.dataclass
class CMSG_QUESTGIVER_CHOOSE_REWARD:
    guid: int
    quest_id: int
    reward: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_CHOOSE_REWARD:
        # guid: Guid
        guid = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # reward: u32
        reward = await read_int(reader, 4)

        return CMSG_QUESTGIVER_CHOOSE_REWARD(
            guid=guid,
            quest_id=quest_id,
            reward=reward,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x018E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.guid, self.quest_id, self.reward])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_QUEST_INVALID:
    msg: QuestFailedReason

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_QUEST_INVALID:
        # msg: QuestFailedReason
        msg = QuestFailedReason(await read_int(reader, 4))

        return SMSG_QUESTGIVER_QUEST_INVALID(
            msg=msg,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x018F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.msg.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUESTGIVER_CANCEL:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_CANCEL:
        return CMSG_QUESTGIVER_CANCEL()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0190))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_QUEST_COMPLETE:
    quest_id: int
    unknown: int
    experience_reward: int
    money_reward: int
    honor_reward: int
    item_rewards: typing.List[QuestItemReward]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_QUEST_COMPLETE:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # unknown: u32
        unknown = await read_int(reader, 4)

        # experience_reward: u32
        experience_reward = await read_int(reader, 4)

        # money_reward: Gold
        money_reward = await read_int(reader, 4)

        # honor_reward: u32
        honor_reward = await read_int(reader, 4)

        # amount_of_item_rewards: u32
        amount_of_item_rewards = await read_int(reader, 4)

        # item_rewards: QuestItemReward[amount_of_item_rewards]
        item_rewards = []
        for _ in range(0, amount_of_item_rewards):
            item_rewards.append(await QuestItemReward.read(reader))

        return SMSG_QUESTGIVER_QUEST_COMPLETE(
            quest_id=quest_id,
            unknown=unknown,
            experience_reward=experience_reward,
            money_reward=money_reward,
            honor_reward=honor_reward,
            item_rewards=item_rewards,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0191))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIIII'
        _data.extend([self.quest_id, self.unknown, self.experience_reward, self.money_reward, self.honor_reward, len(self.item_rewards)])
        # item_rewards: QuestItemReward[amount_of_item_rewards]
        for i in self.item_rewards:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 24 + 8 * len(self.item_rewards)


@dataclasses.dataclass
class SMSG_QUESTGIVER_QUEST_FAILED:
    quest_id: int
    reason: QuestFailedReason

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_QUEST_FAILED:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # reason: QuestFailedReason
        reason = QuestFailedReason(await read_int(reader, 4))

        return SMSG_QUESTGIVER_QUEST_FAILED(
            quest_id=quest_id,
            reason=reason,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0192))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.quest_id, self.reason.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUESTLOG_SWAP_QUEST:
    slot1: int
    slot2: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTLOG_SWAP_QUEST:
        # slot1: u8
        slot1 = await read_int(reader, 1)

        # slot2: u8
        slot2 = await read_int(reader, 1)

        return CMSG_QUESTLOG_SWAP_QUEST(
            slot1=slot1,
            slot2=slot2,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x0193))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.slot1, self.slot2])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUESTLOG_REMOVE_QUEST:
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTLOG_REMOVE_QUEST:
        # slot: u8
        slot = await read_int(reader, 1)

        return CMSG_QUESTLOG_REMOVE_QUEST(
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x0194))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.slot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTLOG_FULL:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTLOG_FULL:
        return SMSG_QUESTLOG_FULL()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0195))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTUPDATE_FAILED:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTUPDATE_FAILED:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return SMSG_QUESTUPDATE_FAILED(
            quest_id=quest_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0196))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.quest_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTUPDATE_FAILEDTIMER:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTUPDATE_FAILEDTIMER:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return SMSG_QUESTUPDATE_FAILEDTIMER(
            quest_id=quest_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0197))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.quest_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTUPDATE_COMPLETE:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTUPDATE_COMPLETE:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return SMSG_QUESTUPDATE_COMPLETE(
            quest_id=quest_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0198))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.quest_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTUPDATE_ADD_KILL:
    quest_id: int
    creature_id: int
    kill_count: int
    required_kill_count: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTUPDATE_ADD_KILL:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # creature_id: u32
        creature_id = await read_int(reader, 4)

        # kill_count: u32
        kill_count = await read_int(reader, 4)

        # required_kill_count: u32
        required_kill_count = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_QUESTUPDATE_ADD_KILL(
            quest_id=quest_id,
            creature_id=creature_id,
            kill_count=kill_count,
            required_kill_count=required_kill_count,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(24 + 2, 0x0199))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIIQ'
        _data.extend([self.quest_id, self.creature_id, self.kill_count, self.required_kill_count, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTUPDATE_ADD_ITEM:
    required_item_id: int
    items_required: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTUPDATE_ADD_ITEM:
        # required_item_id: u32
        required_item_id = await read_int(reader, 4)

        # items_required: u32
        items_required = await read_int(reader, 4)

        return SMSG_QUESTUPDATE_ADD_ITEM(
            required_item_id=required_item_id,
            items_required=items_required,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x019A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.required_item_id, self.items_required])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUEST_CONFIRM_ACCEPT:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUEST_CONFIRM_ACCEPT:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return CMSG_QUEST_CONFIRM_ACCEPT(
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x019B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.quest_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUEST_CONFIRM_ACCEPT:
    quest_id: int
    quest_title: str
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUEST_CONFIRM_ACCEPT:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # quest_title: CString
        quest_title = await read_cstring(reader)

        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_QUEST_CONFIRM_ACCEPT(
            quest_id=quest_id,
            quest_title=quest_title,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x019C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.quest_title)}sBQ'
        _data.extend([self.quest_id, self.quest_title.encode('utf-8'), 0, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 13 + len(self.quest_title)


@dataclasses.dataclass
class CMSG_PUSHQUESTTOPARTY:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PUSHQUESTTOPARTY:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return CMSG_PUSHQUESTTOPARTY(
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x019D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.quest_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LIST_INVENTORY:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LIST_INVENTORY:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_LIST_INVENTORY(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x019E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LIST_INVENTORY:
    vendor: int
    items: typing.List[ListInventoryItem]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LIST_INVENTORY:
        # vendor: Guid
        vendor = await read_int(reader, 8)

        # amount_of_items: u8
        amount_of_items = await read_int(reader, 1)

        # items: ListInventoryItem[amount_of_items]
        items = []
        for _ in range(0, amount_of_items):
            items.append(await ListInventoryItem.read(reader))

        return SMSG_LIST_INVENTORY(
            vendor=vendor,
            items=items,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x019F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.vendor, len(self.items)])
        # items: ListInventoryItem[amount_of_items]
        for i in self.items:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + 32 * len(self.items)


@dataclasses.dataclass
class CMSG_SELL_ITEM:
    vendor: int
    item: int
    amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SELL_ITEM:
        # vendor: Guid
        vendor = await read_int(reader, 8)

        # item: Guid
        item = await read_int(reader, 8)

        # amount: u8
        amount = await read_int(reader, 1)

        return CMSG_SELL_ITEM(
            vendor=vendor,
            item=item,
            amount=amount,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(17 + 4, 0x01A0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QQB'
        _data.extend([self.vendor, self.item, self.amount])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SELL_ITEM:
    guid: int
    item: int
    result: SellItemResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SELL_ITEM:
        # guid: Guid
        guid = await read_int(reader, 8)

        # item: Guid
        item = await read_int(reader, 8)

        # result: SellItemResult
        result = SellItemResult(await read_int(reader, 1))

        return SMSG_SELL_ITEM(
            guid=guid,
            item=item,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(17 + 2, 0x01A1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQB'
        _data.extend([self.guid, self.item, self.result.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BUY_ITEM:
    vendor: int
    item: int
    amount: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BUY_ITEM:
        # vendor: Guid
        vendor = await read_int(reader, 8)

        # item: Item
        item = await read_int(reader, 4)

        # amount: u8
        amount = await read_int(reader, 1)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        return CMSG_BUY_ITEM(
            vendor=vendor,
            item=item,
            amount=amount,
            unknown1=unknown1,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(14 + 4, 0x01A2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIBB'
        _data.extend([self.vendor, self.item, self.amount, self.unknown1])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BUY_ITEM_IN_SLOT:
    vendor: int
    item: int
    bag: int
    bag_slot: int
    amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BUY_ITEM_IN_SLOT:
        # vendor: Guid
        vendor = await read_int(reader, 8)

        # item: Item
        item = await read_int(reader, 4)

        # bag: Guid
        bag = await read_int(reader, 8)

        # bag_slot: u8
        bag_slot = await read_int(reader, 1)

        # amount: u8
        amount = await read_int(reader, 1)

        return CMSG_BUY_ITEM_IN_SLOT(
            vendor=vendor,
            item=item,
            bag=bag,
            bag_slot=bag_slot,
            amount=amount,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(22 + 4, 0x01A3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIQBB'
        _data.extend([self.vendor, self.item, self.bag, self.bag_slot, self.amount])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BUY_ITEM:
    guid: int
    vendor_slot: int
    amount_for_sale: int
    amount_bought: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BUY_ITEM:
        # guid: Guid
        guid = await read_int(reader, 8)

        # vendor_slot: u32
        vendor_slot = await read_int(reader, 4)

        # amount_for_sale: u32
        amount_for_sale = await read_int(reader, 4)

        # amount_bought: u32
        amount_bought = await read_int(reader, 4)

        return SMSG_BUY_ITEM(
            guid=guid,
            vendor_slot=vendor_slot,
            amount_for_sale=amount_for_sale,
            amount_bought=amount_bought,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x01A4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIII'
        _data.extend([self.guid, self.vendor_slot, self.amount_for_sale, self.amount_bought])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BUY_FAILED:
    guid: int
    item: int
    result: BuyResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BUY_FAILED:
        # guid: Guid
        guid = await read_int(reader, 8)

        # item: Item
        item = await read_int(reader, 4)

        # result: BuyResult
        result = BuyResult(await read_int(reader, 1))

        return SMSG_BUY_FAILED(
            guid=guid,
            item=item,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(13 + 2, 0x01A5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIB'
        _data.extend([self.guid, self.item, self.result.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SHOWTAXINODES:
    unknown1: int
    guid: int
    nearest_node: int
    nodes: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SHOWTAXINODES:
        _size = 0

        # unknown1: u32
        unknown1 = await read_int(reader, 4)
        _size += 4

        # guid: Guid
        guid = await read_int(reader, 8)
        _size += 8

        # nearest_node: u32
        nearest_node = await read_int(reader, 4)
        _size += 4

        # nodes: u32[-]
        nodes = []
        while _size < body_size:
            nodes.append(await read_int(reader, 4))
            _size += 4

        return SMSG_SHOWTAXINODES(
            unknown1=unknown1,
            guid=guid,
            nearest_node=nearest_node,
            nodes=nodes,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01A9))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'IQI{len(self.nodes)}I'
        _data.extend([self.unknown1, self.guid, self.nearest_node, *self.nodes])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + 4 * len(self.nodes)


@dataclasses.dataclass
class CMSG_TAXINODE_STATUS_QUERY:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TAXINODE_STATUS_QUERY:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_TAXINODE_STATUS_QUERY(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01AA))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TAXINODE_STATUS:
    guid: int
    taxi_mask_node_known: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TAXINODE_STATUS:
        # guid: Guid
        guid = await read_int(reader, 8)

        # taxi_mask_node_known: Bool8
        taxi_mask_node_known = await read_bool(reader, 1)

        return SMSG_TAXINODE_STATUS(
            guid=guid,
            taxi_mask_node_known=taxi_mask_node_known,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x01AB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.taxi_mask_node_known])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TAXIQUERYAVAILABLENODES:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TAXIQUERYAVAILABLENODES:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_TAXIQUERYAVAILABLENODES(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01AC))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ACTIVATETAXI:
    guid: int
    source_node: int
    destination_node: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ACTIVATETAXI:
        # guid: Guid
        guid = await read_int(reader, 8)

        # source_node: u32
        source_node = await read_int(reader, 4)

        # destination_node: u32
        destination_node = await read_int(reader, 4)

        return CMSG_ACTIVATETAXI(
            guid=guid,
            source_node=source_node,
            destination_node=destination_node,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x01AD))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.guid, self.source_node, self.destination_node])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ACTIVATETAXIREPLY:
    reply: ActivateTaxiReply

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ACTIVATETAXIREPLY:
        # reply: ActivateTaxiReply
        reply = ActivateTaxiReply(await read_int(reader, 4))

        return SMSG_ACTIVATETAXIREPLY(
            reply=reply,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01AE))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.reply.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_NEW_TAXI_PATH:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_NEW_TAXI_PATH:
        return SMSG_NEW_TAXI_PATH()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x01AF))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TRAINER_LIST:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TRAINER_LIST:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_TRAINER_LIST(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01B0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TRAINER_LIST:
    guid: int
    trainer_type: int
    spells: typing.List[TrainerSpell]
    greeting: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRAINER_LIST:
        # guid: Guid
        guid = await read_int(reader, 8)

        # trainer_type: u32
        trainer_type = await read_int(reader, 4)

        # amount_of_spells: u32
        amount_of_spells = await read_int(reader, 4)

        # spells: TrainerSpell[amount_of_spells]
        spells = []
        for _ in range(0, amount_of_spells):
            spells.append(await TrainerSpell.read(reader))

        # greeting: CString
        greeting = await read_cstring(reader)

        return SMSG_TRAINER_LIST(
            guid=guid,
            trainer_type=trainer_type,
            spells=spells,
            greeting=greeting,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01B1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.guid, self.trainer_type, len(self.spells)])
        # spells: TrainerSpell[amount_of_spells]
        for i in self.spells:
            _fmt, _data = i.write(_fmt, _data)

        # greeting: CString
        _fmt += f'{len(self.greeting)}sB'
        _data.extend([self.greeting.encode('utf-8'), 0])

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 17 + 38 * len(self.spells) + len(self.greeting)


@dataclasses.dataclass
class CMSG_TRAINER_BUY_SPELL:
    guid: int
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TRAINER_BUY_SPELL:
        # guid: Guid
        guid = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        return CMSG_TRAINER_BUY_SPELL(
            guid=guid,
            id=id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x01B2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TRAINER_BUY_SUCCEEDED:
    guid: int
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRAINER_BUY_SUCCEEDED:
        # guid: Guid
        guid = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        return SMSG_TRAINER_BUY_SUCCEEDED(
            guid=guid,
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01B3))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TRAINER_BUY_FAILED:
    guid: int
    id: int
    error: TrainingFailureReason

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRAINER_BUY_FAILED:
        # guid: Guid
        guid = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        # error: TrainingFailureReason
        error = TrainingFailureReason(await read_int(reader, 4))

        return SMSG_TRAINER_BUY_FAILED(
            guid=guid,
            id=id,
            error=error,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x01B4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.guid, self.id, self.error.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BINDER_ACTIVATE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BINDER_ACTIVATE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_BINDER_ACTIVATE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01B5))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BANKER_ACTIVATE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BANKER_ACTIVATE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_BANKER_ACTIVATE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01B7))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SHOW_BANK:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SHOW_BANK:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_SHOW_BANK(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01B8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BUY_BANK_SLOT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BUY_BANK_SLOT:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_BUY_BANK_SLOT(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01B9))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BUY_BANK_SLOT_RESULT:
    result: BuyBankSlotResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BUY_BANK_SLOT_RESULT:
        # result: BuyBankSlotResult
        result = BuyBankSlotResult(await read_int(reader, 4))

        return SMSG_BUY_BANK_SLOT_RESULT(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01BA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PETITION_SHOWLIST:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PETITION_SHOWLIST:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_PETITION_SHOWLIST(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01BB))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PETITION_SHOWLIST:
    npc: int
    petitions: typing.List[PetitionShowlist]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PETITION_SHOWLIST:
        # npc: Guid
        npc = await read_int(reader, 8)

        # amount_of_petitions: u8
        amount_of_petitions = await read_int(reader, 1)

        # petitions: PetitionShowlist[amount_of_petitions]
        petitions = []
        for _ in range(0, amount_of_petitions):
            petitions.append(await PetitionShowlist.read(reader))

        return SMSG_PETITION_SHOWLIST(
            npc=npc,
            petitions=petitions,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01BC))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.npc, len(self.petitions)])
        # petitions: PetitionShowlist[amount_of_petitions]
        for i in self.petitions:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + 24 * len(self.petitions)


@dataclasses.dataclass
class CMSG_PETITION_BUY:
    npc: int
    unknown1: int
    unknown2: int
    name: str
    unknown3: int
    unknown4: int
    unknown5: int
    unknown6: int
    unknown7: int
    unknown8: int
    unknown9: int
    unknown10: int
    unknown11: int
    unknown12: int
    unknown13: int
    unknown14: int
    index: int
    unknown15: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PETITION_BUY:
        # npc: Guid
        npc = await read_int(reader, 8)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # unknown2: Guid
        unknown2 = await read_int(reader, 8)

        # name: CString
        name = await read_cstring(reader)

        # unknown3: u32
        unknown3 = await read_int(reader, 4)

        # unknown4: u32
        unknown4 = await read_int(reader, 4)

        # unknown5: u32
        unknown5 = await read_int(reader, 4)

        # unknown6: u32
        unknown6 = await read_int(reader, 4)

        # unknown7: u32
        unknown7 = await read_int(reader, 4)

        # unknown8: u32
        unknown8 = await read_int(reader, 4)

        # unknown9: u32
        unknown9 = await read_int(reader, 4)

        # unknown10: u32
        unknown10 = await read_int(reader, 4)

        # unknown11: u32
        unknown11 = await read_int(reader, 4)

        # unknown12: u32
        unknown12 = await read_int(reader, 4)

        # unknown13: u16
        unknown13 = await read_int(reader, 2)

        # unknown14: u8
        unknown14 = await read_int(reader, 1)

        # index: u32
        index = await read_int(reader, 4)

        # unknown15: u32
        unknown15 = await read_int(reader, 4)

        return CMSG_PETITION_BUY(
            npc=npc,
            unknown1=unknown1,
            unknown2=unknown2,
            name=name,
            unknown3=unknown3,
            unknown4=unknown4,
            unknown5=unknown5,
            unknown6=unknown6,
            unknown7=unknown7,
            unknown8=unknown8,
            unknown9=unknown9,
            unknown10=unknown10,
            unknown11=unknown11,
            unknown12=unknown12,
            unknown13=unknown13,
            unknown14=unknown14,
            index=index,
            unknown15=unknown15,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x01BD))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'QIQ{len(self.name)}sBIIIIIIIIIIHBII'
        _data.extend([self.npc, self.unknown1, self.unknown2, self.name.encode('utf-8'), 0, self.unknown3, self.unknown4, self.unknown5, self.unknown6, self.unknown7, self.unknown8, self.unknown9, self.unknown10, self.unknown11, self.unknown12, self.unknown13, self.unknown14, self.index, self.unknown15])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 72 + len(self.name)


@dataclasses.dataclass
class CMSG_PETITION_SHOW_SIGNATURES:
    item: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PETITION_SHOW_SIGNATURES:
        # item: Guid
        item = await read_int(reader, 8)

        return CMSG_PETITION_SHOW_SIGNATURES(
            item=item,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01BE))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.item)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PETITION_SHOW_SIGNATURES:
    item: int
    owner: int
    petition: int
    signatures: typing.List[PetitionSignature]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PETITION_SHOW_SIGNATURES:
        # item: Guid
        item = await read_int(reader, 8)

        # owner: Guid
        owner = await read_int(reader, 8)

        # petition: u32
        petition = await read_int(reader, 4)

        # amount_of_signatures: u8
        amount_of_signatures = await read_int(reader, 1)

        # signatures: PetitionSignature[amount_of_signatures]
        signatures = []
        for _ in range(0, amount_of_signatures):
            signatures.append(await PetitionSignature.read(reader))

        return SMSG_PETITION_SHOW_SIGNATURES(
            item=item,
            owner=owner,
            petition=petition,
            signatures=signatures,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01BF))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQIB'
        _data.extend([self.item, self.owner, self.petition, len(self.signatures)])
        # signatures: PetitionSignature[amount_of_signatures]
        for i in self.signatures:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 21 + 12 * len(self.signatures)


@dataclasses.dataclass
class CMSG_PETITION_SIGN:
    petition: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PETITION_SIGN:
        # petition: Guid
        petition = await read_int(reader, 8)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        return CMSG_PETITION_SIGN(
            petition=petition,
            unknown1=unknown1,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x01C0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.petition, self.unknown1])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PETITION_SIGN_RESULTS:
    petition: int
    owner: int
    result: PetitionResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PETITION_SIGN_RESULTS:
        # petition: Guid
        petition = await read_int(reader, 8)

        # owner: Guid
        owner = await read_int(reader, 8)

        # result: PetitionResult
        result = PetitionResult(await read_int(reader, 4))

        return SMSG_PETITION_SIGN_RESULTS(
            petition=petition,
            owner=owner,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x01C1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQI'
        _data.extend([self.petition, self.owner, self.result.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_PETITION_DECLINE:
    petition: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_PETITION_DECLINE:
        # petition: Guid
        petition = await read_int(reader, 8)

        return MSG_PETITION_DECLINE(
            petition=petition,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01C2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.petition)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01C2))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.petition)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_OFFER_PETITION:
    unknown0: int
    petition: int
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_OFFER_PETITION:
        # unknown0: u32
        unknown0 = await read_int(reader, 4)

        # petition: Guid
        petition = await read_int(reader, 8)

        # target: Guid
        target = await read_int(reader, 8)

        return CMSG_OFFER_PETITION(
            unknown0=unknown0,
            petition=petition,
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 4, 0x01C3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQQ'
        _data.extend([self.unknown0, self.petition, self.target])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TURN_IN_PETITION:
    petition: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TURN_IN_PETITION:
        # petition: Guid
        petition = await read_int(reader, 8)

        return CMSG_TURN_IN_PETITION(
            petition=petition,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01C4))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.petition)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TURN_IN_PETITION_RESULTS:
    result: PetitionResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TURN_IN_PETITION_RESULTS:
        # result: PetitionResult
        result = PetitionResult(await read_int(reader, 4))

        return SMSG_TURN_IN_PETITION_RESULTS(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01C5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PETITION_QUERY:
    guild_id: int
    petition: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PETITION_QUERY:
        # guild_id: u32
        guild_id = await read_int(reader, 4)

        # petition: Guid
        petition = await read_int(reader, 8)

        return CMSG_PETITION_QUERY(
            guild_id=guild_id,
            petition=petition,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x01C6))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.guild_id, self.petition])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PETITION_QUERY_RESPONSE:
    petition_id: int
    charter_owner: int
    guild_name: str
    body_text: str
    minimum_signatures: int
    maximum_signatures: int
    unknown1: int
    unknown2: int
    unknown3: int
    unknown4: int
    unknown5: int
    unknown6: int
    unknown7: int
    unknown8: int
    unknown9: int
    unknown10: int
    charter_type: CharterType

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PETITION_QUERY_RESPONSE:
        # petition_id: u32
        petition_id = await read_int(reader, 4)

        # charter_owner: Guid
        charter_owner = await read_int(reader, 8)

        # guild_name: CString
        guild_name = await read_cstring(reader)

        # body_text: CString
        body_text = await read_cstring(reader)

        # minimum_signatures: u32
        minimum_signatures = await read_int(reader, 4)

        # maximum_signatures: u32
        maximum_signatures = await read_int(reader, 4)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # unknown2: u32
        unknown2 = await read_int(reader, 4)

        # unknown3: u32
        unknown3 = await read_int(reader, 4)

        # unknown4: u32
        unknown4 = await read_int(reader, 4)

        # unknown5: u32
        unknown5 = await read_int(reader, 4)

        # unknown6: u16
        unknown6 = await read_int(reader, 2)

        # unknown7: u32
        unknown7 = await read_int(reader, 4)

        # unknown8: u32
        unknown8 = await read_int(reader, 4)

        # unknown9: u32
        unknown9 = await read_int(reader, 4)

        # unknown10: u32
        unknown10 = await read_int(reader, 4)

        # charter_type: CharterType
        charter_type = CharterType(await read_int(reader, 4))

        return SMSG_PETITION_QUERY_RESPONSE(
            petition_id=petition_id,
            charter_owner=charter_owner,
            guild_name=guild_name,
            body_text=body_text,
            minimum_signatures=minimum_signatures,
            maximum_signatures=maximum_signatures,
            unknown1=unknown1,
            unknown2=unknown2,
            unknown3=unknown3,
            unknown4=unknown4,
            unknown5=unknown5,
            unknown6=unknown6,
            unknown7=unknown7,
            unknown8=unknown8,
            unknown9=unknown9,
            unknown10=unknown10,
            charter_type=charter_type,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01C7))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'IQ{len(self.guild_name)}sB{len(self.body_text)}sBIIIIIIIHIIIII'
        _data.extend([self.petition_id, self.charter_owner, self.guild_name.encode('utf-8'), 0, self.body_text.encode('utf-8'), 0, self.minimum_signatures, self.maximum_signatures, self.unknown1, self.unknown2, self.unknown3, self.unknown4, self.unknown5, self.unknown6, self.unknown7, self.unknown8, self.unknown9, self.unknown10, self.charter_type.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 64 + len(self.guild_name) + len(self.body_text)


@dataclasses.dataclass
class SMSG_FISH_NOT_HOOKED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FISH_NOT_HOOKED:
        return SMSG_FISH_NOT_HOOKED()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x01C8))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_FISH_ESCAPED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FISH_ESCAPED:
        return SMSG_FISH_ESCAPED()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x01C9))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BUG:
    suggestion: int
    content: str
    bug_type: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BUG:
        # suggestion: u32
        suggestion = await read_int(reader, 4)

        # content: SizedCString
        content = await read_sized_cstring(reader)

        # bug_type: SizedCString
        bug_type = await read_sized_cstring(reader)

        return CMSG_BUG(
            suggestion=suggestion,
            content=content,
            bug_type=bug_type,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x01CA))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'II{len(self.content)}sBI{len(self.bug_type)}sB'
        _data.extend([self.suggestion, len(self.content) + 1, self.content.encode('utf-8'), 0, len(self.bug_type) + 1, self.bug_type.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 14 + len(self.content) + len(self.bug_type)


@dataclasses.dataclass
class SMSG_NOTIFICATION:
    notification: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_NOTIFICATION:
        # notification: CString
        notification = await read_cstring(reader)

        return SMSG_NOTIFICATION(
            notification=notification,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01CB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.notification)}sB'
        _data.extend([self.notification.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.notification)


@dataclasses.dataclass
class CMSG_PLAYED_TIME:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PLAYED_TIME:
        return CMSG_PLAYED_TIME()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x01CC))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PLAYED_TIME:
    total_played_time: int
    level_played_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAYED_TIME:
        # total_played_time: u32
        total_played_time = await read_int(reader, 4)

        # level_played_time: u32
        level_played_time = await read_int(reader, 4)

        return SMSG_PLAYED_TIME(
            total_played_time=total_played_time,
            level_played_time=level_played_time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01CD))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.total_played_time, self.level_played_time])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUERY_TIME:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUERY_TIME:
        return CMSG_QUERY_TIME()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x01CE))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUERY_TIME_RESPONSE:
    time: int
    time_until_daily_quest_reset: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUERY_TIME_RESPONSE:
        # time: u32
        time = await read_int(reader, 4)

        # time_until_daily_quest_reset: u32
        time_until_daily_quest_reset = await read_int(reader, 4)

        return SMSG_QUERY_TIME_RESPONSE(
            time=time,
            time_until_daily_quest_reset=time_until_daily_quest_reset,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01CF))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.time, self.time_until_daily_quest_reset])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOG_XPGAIN:
    target: int
    total_exp: int
    exp_type: ExperienceAwardType
    experience_without_rested: typing.Optional[int] = None
    exp_group_bonus: typing.Optional[float] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOG_XPGAIN:
        experience_without_rested = None
        exp_group_bonus = None
        # target: Guid
        target = await read_int(reader, 8)

        # total_exp: u32
        total_exp = await read_int(reader, 4)

        # exp_type: ExperienceAwardType
        exp_type = ExperienceAwardType(await read_int(reader, 1))

        if exp_type == ExperienceAwardType.NON_KILL:
            # experience_without_rested: u32
            experience_without_rested = await read_int(reader, 4)

            # exp_group_bonus: f32
            exp_group_bonus = await read_float(reader)

        return SMSG_LOG_XPGAIN(
            target=target,
            total_exp=total_exp,
            exp_type=exp_type,
            experience_without_rested=experience_without_rested,
            exp_group_bonus=exp_group_bonus,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01D0))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIB'
        _data.extend([self.target, self.total_exp, self.exp_type.value])
        if self.exp_type == ExperienceAwardType.NON_KILL:
            _fmt += 'If'
            _data.extend([self.experience_without_rested, self.exp_group_bonus])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 13

        if self.exp_type == ExperienceAwardType.NON_KILL:
            _size += 8

        return _size


@dataclasses.dataclass
class CMSG_RECLAIM_CORPSE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_RECLAIM_CORPSE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_RECLAIM_CORPSE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01D2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_WRAP_ITEM:
    gift_bag_index: int
    gift_slot: int
    item_bag_index: int
    item_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_WRAP_ITEM:
        # gift_bag_index: u8
        gift_bag_index = await read_int(reader, 1)

        # gift_slot: u8
        gift_slot = await read_int(reader, 1)

        # item_bag_index: u8
        item_bag_index = await read_int(reader, 1)

        # item_slot: u8
        item_slot = await read_int(reader, 1)

        return CMSG_WRAP_ITEM(
            gift_bag_index=gift_bag_index,
            gift_slot=gift_slot,
            item_bag_index=item_bag_index,
            item_slot=item_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x01D3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBBB'
        _data.extend([self.gift_bag_index, self.gift_slot, self.item_bag_index, self.item_slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LEVELUP_INFO:
    new_level: int
    health: int
    mana: int
    rage: int
    focus: int
    energy: int
    happiness: int
    strength: int
    agility: int
    stamina: int
    intellect: int
    spirit: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LEVELUP_INFO:
        # new_level: Level32
        new_level = await read_int(reader, 4)

        # health: u32
        health = await read_int(reader, 4)

        # mana: u32
        mana = await read_int(reader, 4)

        # rage: u32
        rage = await read_int(reader, 4)

        # focus: u32
        focus = await read_int(reader, 4)

        # energy: u32
        energy = await read_int(reader, 4)

        # happiness: u32
        happiness = await read_int(reader, 4)

        # strength: u32
        strength = await read_int(reader, 4)

        # agility: u32
        agility = await read_int(reader, 4)

        # stamina: u32
        stamina = await read_int(reader, 4)

        # intellect: u32
        intellect = await read_int(reader, 4)

        # spirit: u32
        spirit = await read_int(reader, 4)

        return SMSG_LEVELUP_INFO(
            new_level=new_level,
            health=health,
            mana=mana,
            rage=rage,
            focus=focus,
            energy=energy,
            happiness=happiness,
            strength=strength,
            agility=agility,
            stamina=stamina,
            intellect=intellect,
            spirit=spirit,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(48 + 2, 0x01D4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIIIIIIIIII'
        _data.extend([self.new_level, self.health, self.mana, self.rage, self.focus, self.energy, self.happiness, self.strength, self.agility, self.stamina, self.intellect, self.spirit])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MINIMAP_PING_Client:
    position_x: float
    position_y: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MINIMAP_PING_Client:
        # position_x: f32
        position_x = await read_float(reader)

        # position_y: f32
        position_y = await read_float(reader)

        return MSG_MINIMAP_PING_Client(
            position_x=position_x,
            position_y=position_y,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01D5))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'ff'
        _data.extend([self.position_x, self.position_y])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MINIMAP_PING_Server:
    guid: int
    position_x: float
    position_y: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MINIMAP_PING_Server:
        # guid: Guid
        guid = await read_int(reader, 8)

        # position_x: f32
        position_x = await read_float(reader)

        # position_y: f32
        position_y = await read_float(reader)

        return MSG_MINIMAP_PING_Server(
            guid=guid,
            position_x=position_x,
            position_y=position_y,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x01D5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Qff'
        _data.extend([self.guid, self.position_x, self.position_y])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ENCHANTMENTLOG:
    target: int
    caster: int
    item: int
    spell: int
    show_affiliation: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ENCHANTMENTLOG:
        # target: Guid
        target = await read_int(reader, 8)

        # caster: Guid
        caster = await read_int(reader, 8)

        # item: Item
        item = await read_int(reader, 4)

        # spell: Spell
        spell = await read_int(reader, 4)

        # show_affiliation: Bool8
        show_affiliation = await read_bool(reader, 1)

        return SMSG_ENCHANTMENTLOG(
            target=target,
            caster=caster,
            item=item,
            spell=spell,
            show_affiliation=show_affiliation,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(25 + 2, 0x01D7))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQIIB'
        _data.extend([self.target, self.caster, self.item, self.spell, self.show_affiliation])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_START_MIRROR_TIMER:
    timer: TimerType
    time_remaining: int
    duration: int
    scale: int
    is_frozen: bool
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_START_MIRROR_TIMER:
        # timer: TimerType
        timer = TimerType(await read_int(reader, 4))

        # time_remaining: u32
        time_remaining = await read_int(reader, 4)

        # duration: u32
        duration = await read_int(reader, 4)

        # scale: u32
        scale = await read_int(reader, 4)

        # is_frozen: Bool8
        is_frozen = await read_bool(reader, 1)

        # id: Spell
        id = await read_int(reader, 4)

        return SMSG_START_MIRROR_TIMER(
            timer=timer,
            time_remaining=time_remaining,
            duration=duration,
            scale=scale,
            is_frozen=is_frozen,
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(21 + 2, 0x01D9))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIIBI'
        _data.extend([self.timer.value, self.time_remaining, self.duration, self.scale, self.is_frozen, self.id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PAUSE_MIRROR_TIMER:
    timer: TimerType
    is_frozen: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PAUSE_MIRROR_TIMER:
        # timer: TimerType
        timer = TimerType(await read_int(reader, 4))

        # is_frozen: Bool8
        is_frozen = await read_bool(reader, 1)

        return SMSG_PAUSE_MIRROR_TIMER(
            timer=timer,
            is_frozen=is_frozen,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x01DA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([self.timer.value, self.is_frozen])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_STOP_MIRROR_TIMER:
    timer: TimerType

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_STOP_MIRROR_TIMER:
        # timer: TimerType
        timer = TimerType(await read_int(reader, 4))

        return SMSG_STOP_MIRROR_TIMER(
            timer=timer,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01DB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.timer.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PING:
    sequence_id: int
    round_time_in_ms: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PING:
        # sequence_id: u32
        sequence_id = await read_int(reader, 4)

        # round_time_in_ms: u32
        round_time_in_ms = await read_int(reader, 4)

        return CMSG_PING(
            sequence_id=sequence_id,
            round_time_in_ms=round_time_in_ms,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01DC))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.sequence_id, self.round_time_in_ms])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PONG:
    sequence_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PONG:
        # sequence_id: u32
        sequence_id = await read_int(reader, 4)

        return SMSG_PONG(
            sequence_id=sequence_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01DD))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.sequence_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CLEAR_COOLDOWN:
    id: int
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CLEAR_COOLDOWN:
        # id: Spell
        id = await read_int(reader, 4)

        # target: Guid
        target = await read_int(reader, 8)

        return SMSG_CLEAR_COOLDOWN(
            id=id,
            target=target,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01DE))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.id, self.target])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GAMEOBJECT_PAGETEXT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GAMEOBJECT_PAGETEXT:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_GAMEOBJECT_PAGETEXT(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01DF))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SETSHEATHED:
    sheathed: SheathState

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SETSHEATHED:
        # sheathed: SheathState
        sheathed = SheathState(await read_int(reader, 4))

        return CMSG_SETSHEATHED(
            sheathed=sheathed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x01E0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.sheathed.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELL_DELAYED:
    guid: int
    delay_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELL_DELAYED:
        # guid: Guid
        guid = await read_int(reader, 8)

        # delay_time: u32
        delay_time = await read_int(reader, 4)

        return SMSG_SPELL_DELAYED(
            guid=guid,
            delay_time=delay_time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01E2))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.delay_time])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_TIME_UPDATE:
    guid: int
    duration: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_TIME_UPDATE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # duration: u32
        duration = await read_int(reader, 4)

        return SMSG_ITEM_TIME_UPDATE(
            guid=guid,
            duration=duration,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01EA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.duration])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_ENCHANT_TIME_UPDATE:
    item: int
    slot: int
    duration: int
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_ENCHANT_TIME_UPDATE:
        # item: Guid
        item = await read_int(reader, 8)

        # slot: u32
        slot = await read_int(reader, 4)

        # duration: u32
        duration = await read_int(reader, 4)

        # player: Guid
        player = await read_int(reader, 8)

        return SMSG_ITEM_ENCHANT_TIME_UPDATE(
            item=item,
            slot=slot,
            duration=duration,
            player=player,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(24 + 2, 0x01EB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIIQ'
        _data.extend([self.item, self.slot, self.duration, self.player])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AUTH_CHALLENGE:
    server_seed: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUTH_CHALLENGE:
        # server_seed: u32
        server_seed = await read_int(reader, 4)

        return SMSG_AUTH_CHALLENGE(
            server_seed=server_seed,
        )

    def write_unencrypted(self, writer: typing.Union[asyncio.StreamWriter, bytearray]):
        _data = bytearray(4)
        struct.pack_into(">H", _data, 0, 4 + 2)
        struct.pack_into("<H", _data, 2, 0x01EC)
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.server_seed)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUTH_SESSION:
    build: int
    server_id: int
    username: str
    client_seed: int
    client_proof: typing.List[int]
    addon_info: typing.List[AddonInfo]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUTH_SESSION:
        _size = 0

        # build: u32
        build = await read_int(reader, 4)
        _size += 4

        # server_id: u32
        server_id = await read_int(reader, 4)
        _size += 4

        # username: CString
        username = await read_cstring(reader)
        _size += len(username) + 1

        # client_seed: u32
        client_seed = await read_int(reader, 4)
        _size += 4

        # client_proof: u8[20]
        client_proof = []
        for _ in range(0, 20):
            client_proof.append(await read_int(reader, 1))
            _size += 1

        # addon_info: AddonInfo[-]
        # {d.name}_decompressed_size: u32
        _size += 4  # decompressed_size

        addon_info_decompressed_size = await read_int(reader, 4)
        addon_info_bytes = await reader.readexactly(body_size - _size)

        addon_info_reader = reader
        if len(addon_info_bytes) != 0:
            addon_info_bytes = zlib.decompress(addon_info_bytes, bufsize=addon_info_decompressed_size)
            addon_info_reader = asyncio.StreamReader()
            addon_info_reader.feed_data(addon_info_bytes)
            addon_info_reader.feed_eof()

        addon_info = []
        while not addon_info_reader.at_eof():
            addon_info.append(await AddonInfo.read(addon_info_reader))
            _size += addon_info[-1].size()

        return CMSG_AUTH_SESSION(
            build=build,
            server_id=server_id,
            username=username,
            client_seed=client_seed,
            client_proof=client_proof,
            addon_info=addon_info,
        )

    def write_unencrypted(self, writer: typing.Union[asyncio.StreamWriter, bytearray]):
        _data = bytearray(6)
        struct.pack_into(">H", _data, 0, self.size() + 4)
        struct.pack_into("<I", _data, 2, 0x01ED)
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'II{len(self.username)}sBI{len(self.client_proof)}B'
        _data.extend([self.build, self.server_id, self.username.encode('utf-8'), 0, self.client_seed, *self.client_proof])
        # addon_info: AddonInfo[-]
        _addon_info_fmt = ''
        _addon_info_data = []

        _addon_info_decompressed_size = 0
        if len(self.addon_info) != 0:
            for i in self.addon_info:
                _addon_info_fmt, _addon_info_data = i.write(_addon_info_fmt, _addon_info_data)
            _addon_info_bytes = struct.pack(_addon_info_fmt, *_addon_info_data)
            _addon_info_decompressed_size = len(_addon_info_bytes)
            _addon_info_bytes = list(_addon_info_bytes)

            _fmt += 'I'
            _data.append(_addon_info_decompressed_size)

            _fmt += f'{len(_addon_info_bytes)}B'
            _data.extend(list(_addon_info_bytes))
        else:
            _fmt += 'I'
            _data.append(_addon_info_decompressed_size)


        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 33 + len(self.username)

        # addon_info: AddonInfo[-]
        _addon_info_fmt = ''
        _addon_info_data = []

        if len(self.addon_info) != 0:
            for i in self.addon_info:
                _addon_info_fmt, _addon_info_data = i.write(_addon_info_fmt, _addon_info_data)
            _addon_info_bytes = struct.pack(_addon_info_fmt, *_addon_info_data)
            _size += len(_addon_info_bytes) + 4
        else:
            _size += 4

        return _size


@dataclasses.dataclass
class SMSG_AUTH_RESPONSE:
    result: WorldResult
    billing_time: typing.Optional[int] = None
    billing_flags: typing.Optional[BillingPlanFlags] = None
    billing_rested: typing.Optional[int] = None
    expansion: typing.Optional[Expansion] = None
    queue_position: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUTH_RESPONSE:
        billing_time = None
        billing_flags = None
        billing_rested = None
        expansion = None
        queue_position = None
        # result: WorldResult
        result = WorldResult(await read_int(reader, 1))

        if result == WorldResult.AUTH_OK:
            # billing_time: u32
            billing_time = await read_int(reader, 4)

            # billing_flags: BillingPlanFlags
            billing_flags = BillingPlanFlags(await read_int(reader, 1))

            # billing_rested: u32
            billing_rested = await read_int(reader, 4)

            # expansion: Expansion
            expansion = Expansion(await read_int(reader, 1))

        elif result == WorldResult.AUTH_WAIT_QUEUE:
            # queue_position: u32
            queue_position = await read_int(reader, 4)

        return SMSG_AUTH_RESPONSE(
            result=result,
            billing_time=billing_time,
            billing_flags=billing_flags,
            billing_rested=billing_rested,
            expansion=expansion,
            queue_position=queue_position,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01EE))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        if self.result == WorldResult.AUTH_OK:
            _fmt += 'IBIB'
            _data.extend([self.billing_time, self.billing_flags.value, self.billing_rested, self.expansion.value])
        elif self.result == WorldResult.AUTH_WAIT_QUEUE:
            _fmt += 'I'
            _data.append(self.queue_position)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.result == WorldResult.AUTH_OK:
            _size += 10
        elif self.result == WorldResult.AUTH_WAIT_QUEUE:
            _size += 4

        return _size


@dataclasses.dataclass
class CMSG_PET_CAST_SPELL:
    guid: int
    id: int
    targets: SpellCastTargets

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_CAST_SPELL:
        # guid: Guid
        guid = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        # targets: SpellCastTargets
        targets = await SpellCastTargets.read(reader)

        return CMSG_PET_CAST_SPELL(
            guid=guid,
            id=id,
            targets=targets,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x01F0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.id])
        # targets: SpellCastTargets
        _fmt, _data = self.targets.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + self.targets.size()


@dataclasses.dataclass
class MSG_SAVE_GUILD_EMBLEM_Client:
    vendor: int
    emblem_style: int
    emblem_color: int
    border_style: int
    border_color: int
    background_color: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_SAVE_GUILD_EMBLEM_Client:
        # vendor: Guid
        vendor = await read_int(reader, 8)

        # emblem_style: u32
        emblem_style = await read_int(reader, 4)

        # emblem_color: u32
        emblem_color = await read_int(reader, 4)

        # border_style: u32
        border_style = await read_int(reader, 4)

        # border_color: u32
        border_color = await read_int(reader, 4)

        # background_color: u32
        background_color = await read_int(reader, 4)

        return MSG_SAVE_GUILD_EMBLEM_Client(
            vendor=vendor,
            emblem_style=emblem_style,
            emblem_color=emblem_color,
            border_style=border_style,
            border_color=border_color,
            background_color=background_color,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(28 + 4, 0x01F1))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIIIII'
        _data.extend([self.vendor, self.emblem_style, self.emblem_color, self.border_style, self.border_color, self.background_color])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_SAVE_GUILD_EMBLEM_Server:
    result: GuildEmblemResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_SAVE_GUILD_EMBLEM_Server:
        # result: GuildEmblemResult
        result = GuildEmblemResult(await read_int(reader, 4))

        return MSG_SAVE_GUILD_EMBLEM_Server(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01F1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_TABARDVENDOR_ACTIVATE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_TABARDVENDOR_ACTIVATE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return MSG_TABARDVENDOR_ACTIVATE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01F2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01F2))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PLAY_SPELL_VISUAL:
    guid: int
    spell_art_kit: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAY_SPELL_VISUAL:
        # guid: Guid
        guid = await read_int(reader, 8)

        # spell_art_kit: u32
        spell_art_kit = await read_int(reader, 4)

        return SMSG_PLAY_SPELL_VISUAL(
            guid=guid,
            spell_art_kit=spell_art_kit,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01F3))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.spell_art_kit])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ZONEUPDATE:
    area: Area

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ZONEUPDATE:
        # area: Area
        area = Area(await read_int(reader, 4))

        return CMSG_ZONEUPDATE(
            area=area,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x01F4))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.area.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PARTYKILLLOG:
    player_with_killing_blow: int
    victim: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PARTYKILLLOG:
        # player_with_killing_blow: Guid
        player_with_killing_blow = await read_int(reader, 8)

        # victim: Guid
        victim = await read_int(reader, 8)

        return SMSG_PARTYKILLLOG(
            player_with_killing_blow=player_with_killing_blow,
            victim=victim,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x01F5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQ'
        _data.extend([self.player_with_killing_blow, self.victim])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_COMPRESSED_UPDATE_OBJECT:
    has_transport: int
    objects: typing.List[Object]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_COMPRESSED_UPDATE_OBJECT:
        decompressed_size = await read_int(reader, 4)
        compressed_bytes = await reader.readexactly(body_size - 4)
        decompressed_bytes = zlib.decompress(compressed_bytes, bufsize=decompressed_size)
        reader = asyncio.StreamReader()
        reader.feed_data(decompressed_bytes)
        reader.feed_eof()


        # amount_of_objects: u32
        amount_of_objects = await read_int(reader, 4)

        # has_transport: u8
        has_transport = await read_int(reader, 1)

        # objects: Object[amount_of_objects]
        objects = []
        for _ in range(0, amount_of_objects):
            objects.append(await Object.read(reader))

        return SMSG_COMPRESSED_UPDATE_OBJECT(
            has_transport=has_transport,
            objects=objects,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01F6))
        _fmt = "<4s"
        _data = [_data]

        _compressed_fmt = "<"
        _compressed_data = []

        _fmt += 'IB'
        _data.extend([len(self.objects), self.has_transport])
        # objects: Object[amount_of_objects]
        for i in self.objects:
            _compressed_fmt, _compressed_data = i.write(_compressed_fmt, _compressed_data)

        _uncompressed_data = struct.pack(_compressed_fmt, *_compressed_data)
        _compressed_data = zlib.compress(_uncompressed_data)

        _fmt += 'I'
        _data.append(len(_uncompressed_data))

        _fmt += f'{len(_compressed_data)}s'
        _data.append(_compressed_data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _fmt = ''
        _data = []

        # amount_of_objects: u32
        _fmt += 'I'
        _data.append(len(self.objects))

        # has_transport: u8
        _fmt += 'B'
        _data.append(self.has_transport)

        # objects: Object[amount_of_objects]
        for i in self.objects:
            _fmt, _data = i.write(_fmt, _data)

        _uncompressed_data = struct.pack(_fmt, *_data)
        _compressed_data = zlib.compress(_uncompressed_data)
        return len(_compressed_data) + 4


@dataclasses.dataclass
class SMSG_PLAY_SPELL_IMPACT:
    guid: int
    spell_visual_kit: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAY_SPELL_IMPACT:
        # guid: Guid
        guid = await read_int(reader, 8)

        # spell_visual_kit: u32
        spell_visual_kit = await read_int(reader, 4)

        return SMSG_PLAY_SPELL_IMPACT(
            guid=guid,
            spell_visual_kit=spell_visual_kit,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01F7))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.spell_visual_kit])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_EXPLORATION_EXPERIENCE:
    area: Area
    experience: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_EXPLORATION_EXPERIENCE:
        # area: Area
        area = Area(await read_int(reader, 4))

        # experience: u32
        experience = await read_int(reader, 4)

        return SMSG_EXPLORATION_EXPERIENCE(
            area=area,
            experience=experience,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01F8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.area.value, self.experience])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_RANDOM_ROLL_Client:
    minimum: int
    maximum: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RANDOM_ROLL_Client:
        # minimum: u32
        minimum = await read_int(reader, 4)

        # maximum: u32
        maximum = await read_int(reader, 4)

        return MSG_RANDOM_ROLL_Client(
            minimum=minimum,
            maximum=maximum,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01FB))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.minimum, self.maximum])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_RANDOM_ROLL_Server:
    minimum: int
    maximum: int
    actual_roll: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RANDOM_ROLL_Server:
        # minimum: u32
        minimum = await read_int(reader, 4)

        # maximum: u32
        maximum = await read_int(reader, 4)

        # actual_roll: u32
        actual_roll = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return MSG_RANDOM_ROLL_Server(
            minimum=minimum,
            maximum=maximum,
            actual_roll=actual_roll,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x01FB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIQ'
        _data.extend([self.minimum, self.maximum, self.actual_roll, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ENVIRONMENTAL_DAMAGE_LOG:
    guid: int
    damage_type: EnvironmentalDamageType
    damage: int
    absorb: int
    resist: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ENVIRONMENTAL_DAMAGE_LOG:
        # guid: Guid
        guid = await read_int(reader, 8)

        # damage_type: EnvironmentalDamageType
        damage_type = EnvironmentalDamageType(await read_int(reader, 1))

        # damage: u32
        damage = await read_int(reader, 4)

        # absorb: u32
        absorb = await read_int(reader, 4)

        # resist: u32
        resist = await read_int(reader, 4)

        return SMSG_ENVIRONMENTAL_DAMAGE_LOG(
            guid=guid,
            damage_type=damage_type,
            damage=damage,
            absorb=absorb,
            resist=resist,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(21 + 2, 0x01FC))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QBIII'
        _data.extend([self.guid, self.damage_type.value, self.damage, self.absorb, self.resist])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_LOOKING_FOR_GROUP_Client:
    lfg_type: LfgType
    entry: int
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_LOOKING_FOR_GROUP_Client:
        # lfg_type: LfgType
        lfg_type = LfgType(await read_int(reader, 4))

        # entry: u32
        entry = await read_int(reader, 4)

        # unknown: u32
        unknown = await read_int(reader, 4)

        return MSG_LOOKING_FOR_GROUP_Client(
            lfg_type=lfg_type,
            entry=entry,
            unknown=unknown,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x01FF))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'III'
        _data.extend([self.lfg_type.value, self.entry, self.unknown])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_LOOKING_FOR_GROUP_Server:
    lfg_type: LfgType
    entry: int
    amount_of_players_found: int
    players_displayed: typing.List[LfgPlayer]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_LOOKING_FOR_GROUP_Server:
        # lfg_type: LfgType
        lfg_type = LfgType(await read_int(reader, 4))

        # entry: u32
        entry = await read_int(reader, 4)

        # amount_of_players_displayed: u32
        amount_of_players_displayed = await read_int(reader, 4)

        # amount_of_players_found: u32
        amount_of_players_found = await read_int(reader, 4)

        # players_displayed: LfgPlayer[amount_of_players_displayed]
        players_displayed = []
        for _ in range(0, amount_of_players_displayed):
            players_displayed.append(await LfgPlayer.read(reader))

        return MSG_LOOKING_FOR_GROUP_Server(
            lfg_type=lfg_type,
            entry=entry,
            amount_of_players_found=amount_of_players_found,
            players_displayed=players_displayed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01FF))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIII'
        _data.extend([self.lfg_type.value, self.entry, len(self.players_displayed), self.amount_of_players_found])
        # players_displayed: LfgPlayer[amount_of_players_displayed]
        for i in self.players_displayed:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + sum([i.size() for i in self.players_displayed])


@dataclasses.dataclass
class CMSG_SET_LOOKING_FOR_GROUP:
    slot: int
    data: LfgData

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_LOOKING_FOR_GROUP:
        # slot: u32
        slot = await read_int(reader, 4)

        # data: LfgData
        data = await LfgData.read(reader)

        return CMSG_SET_LOOKING_FOR_GROUP(
            slot=slot,
            data=data,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0200))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.slot)
        # data: LfgData
        _fmt, _data = self.data.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_UNLEARN_SKILL:
    skill: Skill

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_UNLEARN_SKILL:
        # skill: Skill
        skill = Skill(await read_int(reader, 4))

        return CMSG_UNLEARN_SKILL(
            skill=skill,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0202))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.skill.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_REMOVED_SPELL:
    spell: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_REMOVED_SPELL:
        # spell: Spell16
        spell = await read_int(reader, 2)

        return SMSG_REMOVED_SPELL(
            spell=spell,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 2, 0x0203))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'H'
        _data.append(self.spell)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GMTICKET_CREATE:
    category: GmTicketType
    map: Map
    position: Vector3d
    message: str
    reserved_for_future_use: str
    chat_data_line_count: typing.Optional[int] = None
    compressed_chat_data: typing.Optional[typing.List[int]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GMTICKET_CREATE:
        chat_data_line_count = None
        compressed_chat_data = None
        _size = 0

        # category: GmTicketType
        category = GmTicketType(await read_int(reader, 1))
        _size += 1

        # map: Map
        map = Map(await read_int(reader, 4))
        _size += 4

        # position: Vector3d
        position = await Vector3d.read(reader)
        _size += 12

        # message: CString
        message = await read_cstring(reader)
        _size += len(message) + 1

        # reserved_for_future_use: CString
        reserved_for_future_use = await read_cstring(reader)
        _size += len(reserved_for_future_use) + 1

        if category == GmTicketType.BEHAVIOR_HARASSMENT:
            # chat_data_line_count: u32
            chat_data_line_count = await read_int(reader, 4)
            _size += 4

            # compressed_chat_data: u8[-]
            # {d.name}_decompressed_size: u32
            _size += 4  # decompressed_size

            compressed_chat_data_decompressed_size = await read_int(reader, 4)
            compressed_chat_data_bytes = await reader.readexactly(body_size - _size)

            compressed_chat_data_reader = reader
            if len(compressed_chat_data_bytes) != 0:
                compressed_chat_data_bytes = zlib.decompress(compressed_chat_data_bytes, bufsize=compressed_chat_data_decompressed_size)
                compressed_chat_data_reader = asyncio.StreamReader()
                compressed_chat_data_reader.feed_data(compressed_chat_data_bytes)
                compressed_chat_data_reader.feed_eof()

            compressed_chat_data = []
            while not compressed_chat_data_reader.at_eof():
                compressed_chat_data.append(await read_int(compressed_chat_data_reader, 1))
                _size += 1

        return CMSG_GMTICKET_CREATE(
            category=category,
            map=map,
            position=position,
            message=message,
            reserved_for_future_use=reserved_for_future_use,
            chat_data_line_count=chat_data_line_count,
            compressed_chat_data=compressed_chat_data,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0205))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BI'
        _data.extend([self.category.value, self.map.value])
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # message: CString
        _fmt += f'{len(self.message)}sB'
        _data.extend([self.message.encode('utf-8'), 0])

        # reserved_for_future_use: CString
        _fmt += f'{len(self.reserved_for_future_use)}sB'
        _data.extend([self.reserved_for_future_use.encode('utf-8'), 0])

        if self.category == GmTicketType.BEHAVIOR_HARASSMENT:
            _fmt += 'I'
            _data.append(self.chat_data_line_count)
            # compressed_chat_data: u8[-]
            _compressed_chat_data_fmt = ''
            _compressed_chat_data_data = []

            _compressed_chat_data_decompressed_size = 0
            if len(self.compressed_chat_data) != 0:
                _compressed_chat_data_fmt += f'{len(self.compressed_chat_data)}B'
                _compressed_chat_data_data.extend(self.compressed_chat_data)
                _compressed_chat_data_bytes = struct.pack(_compressed_chat_data_fmt, *_compressed_chat_data_data)
                _compressed_chat_data_decompressed_size = len(_compressed_chat_data_bytes)
                _compressed_chat_data_bytes = list(_compressed_chat_data_bytes)

                _fmt += 'I'
                _data.append(_compressed_chat_data_decompressed_size)

                _fmt += f'{len(_compressed_chat_data_bytes)}B'
                _data.extend(list(_compressed_chat_data_bytes))
            else:
                _fmt += 'I'
                _data.append(_compressed_chat_data_decompressed_size)


        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 19 + len(self.message) + len(self.reserved_for_future_use)

        if self.category == GmTicketType.BEHAVIOR_HARASSMENT:
            _size += 4

            # compressed_chat_data: u8[-]
            _compressed_chat_data_fmt = ''
            _compressed_chat_data_data = []

            if len(self.compressed_chat_data) != 0:
                _compressed_chat_data_fmt += f'{len(self.compressed_chat_data)}B'
                _compressed_chat_data_data.extend(self.compressed_chat_data)
                _compressed_chat_data_bytes = struct.pack(_compressed_chat_data_fmt, *_compressed_chat_data_data)
                _size += len(_compressed_chat_data_bytes) + 4
            else:
                _size += 4


        return _size


@dataclasses.dataclass
class SMSG_GMTICKET_CREATE:
    response: GmTicketResponse

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GMTICKET_CREATE:
        # response: GmTicketResponse
        response = GmTicketResponse(await read_int(reader, 4))

        return SMSG_GMTICKET_CREATE(
            response=response,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0206))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.response.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GMTICKET_UPDATETEXT:
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GMTICKET_UPDATETEXT:
        # message: CString
        message = await read_cstring(reader)

        return CMSG_GMTICKET_UPDATETEXT(
            message=message,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0207))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.message)}sB'
        _data.extend([self.message.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.message)


@dataclasses.dataclass
class SMSG_GMTICKET_UPDATETEXT:
    response: GmTicketResponse

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GMTICKET_UPDATETEXT:
        # response: GmTicketResponse
        response = GmTicketResponse(await read_int(reader, 4))

        return SMSG_GMTICKET_UPDATETEXT(
            response=response,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0208))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.response.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ACCOUNT_DATA_TIMES:
    data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ACCOUNT_DATA_TIMES:
        # data: u32[32]
        data = []
        for _ in range(0, 32):
            data.append(await read_int(reader, 4))

        return SMSG_ACCOUNT_DATA_TIMES(
            data=data,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(128 + 2, 0x0209))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.data)}I'
        _data.extend([*self.data])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_REQUEST_ACCOUNT_DATA:
    data_type: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REQUEST_ACCOUNT_DATA:
        # data_type: u32
        data_type = await read_int(reader, 4)

        return CMSG_REQUEST_ACCOUNT_DATA(
            data_type=data_type,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x020A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.data_type)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_UPDATE_ACCOUNT_DATA:
    data_type: AccountDataType
    compressed_data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_UPDATE_ACCOUNT_DATA:
        _size = 0

        # data_type: AccountDataType
        data_type = AccountDataType(await read_int(reader, 4))
        _size += 4

        # compressed_data: u8[-]
        # {d.name}_decompressed_size: u32
        _size += 4  # decompressed_size

        compressed_data_decompressed_size = await read_int(reader, 4)
        compressed_data_bytes = await reader.readexactly(body_size - _size)

        compressed_data_reader = reader
        if len(compressed_data_bytes) != 0:
            compressed_data_bytes = zlib.decompress(compressed_data_bytes, bufsize=compressed_data_decompressed_size)
            compressed_data_reader = asyncio.StreamReader()
            compressed_data_reader.feed_data(compressed_data_bytes)
            compressed_data_reader.feed_eof()

        compressed_data = []
        while not compressed_data_reader.at_eof():
            compressed_data.append(await read_int(compressed_data_reader, 1))
            _size += 1

        return CMSG_UPDATE_ACCOUNT_DATA(
            data_type=data_type,
            compressed_data=compressed_data,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x020B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.data_type.value)
        # compressed_data: u8[-]
        _compressed_data_fmt = ''
        _compressed_data_data = []

        _compressed_data_decompressed_size = 0
        if len(self.compressed_data) != 0:
            _compressed_data_fmt += f'{len(self.compressed_data)}B'
            _compressed_data_data.extend(self.compressed_data)
            _compressed_data_bytes = struct.pack(_compressed_data_fmt, *_compressed_data_data)
            _compressed_data_decompressed_size = len(_compressed_data_bytes)
            _compressed_data_bytes = list(_compressed_data_bytes)

            _fmt += 'I'
            _data.append(_compressed_data_decompressed_size)

            _fmt += f'{len(_compressed_data_bytes)}B'
            _data.extend(list(_compressed_data_bytes))
        else:
            _fmt += 'I'
            _data.append(_compressed_data_decompressed_size)


        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        # compressed_data: u8[-]
        _compressed_data_fmt = ''
        _compressed_data_data = []

        if len(self.compressed_data) != 0:
            _compressed_data_fmt += f'{len(self.compressed_data)}B'
            _compressed_data_data.extend(self.compressed_data)
            _compressed_data_bytes = struct.pack(_compressed_data_fmt, *_compressed_data_data)
            _size += len(_compressed_data_bytes) + 4
        else:
            _size += 4

        return _size


@dataclasses.dataclass
class SMSG_UPDATE_ACCOUNT_DATA:
    data_type: int
    decompressed_size: int
    compressed_data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_UPDATE_ACCOUNT_DATA:
        _size = 0

        # data_type: u32
        data_type = await read_int(reader, 4)
        _size += 4

        # decompressed_size: u32
        decompressed_size = await read_int(reader, 4)
        _size += 4

        # compressed_data: u8[-]
        compressed_data = []
        while _size < body_size:
            compressed_data.append(await read_int(reader, 1))
            _size += 1

        return SMSG_UPDATE_ACCOUNT_DATA(
            data_type=data_type,
            decompressed_size=decompressed_size,
            compressed_data=compressed_data,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x020C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'II{len(self.compressed_data)}B'
        _data.extend([self.data_type, self.decompressed_size, *self.compressed_data])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + 1 * len(self.compressed_data)


@dataclasses.dataclass
class CMSG_GMTICKET_GETTICKET:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GMTICKET_GETTICKET:
        return CMSG_GMTICKET_GETTICKET()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0211))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GMTICKET_GETTICKET:
    status: GmTicketStatus
    text: typing.Optional[str] = None
    ticket_type: typing.Optional[GmTicketType] = None
    days_since_ticket_creation: typing.Optional[float] = None
    days_since_oldest_ticket_creation: typing.Optional[float] = None
    days_since_last_updated: typing.Optional[float] = None
    escalation_status: typing.Optional[GmTicketEscalationStatus] = None
    read_by_gm: typing.Optional[bool] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GMTICKET_GETTICKET:
        text = None
        ticket_type = None
        days_since_ticket_creation = None
        days_since_oldest_ticket_creation = None
        days_since_last_updated = None
        escalation_status = None
        read_by_gm = None
        # status: GmTicketStatus
        status = GmTicketStatus(await read_int(reader, 4))

        if status == GmTicketStatus.HAS_TEXT:
            # text: CString
            text = await read_cstring(reader)

            # ticket_type: GmTicketType
            ticket_type = GmTicketType(await read_int(reader, 1))

            # days_since_ticket_creation: f32
            days_since_ticket_creation = await read_float(reader)

            # days_since_oldest_ticket_creation: f32
            days_since_oldest_ticket_creation = await read_float(reader)

            # days_since_last_updated: f32
            days_since_last_updated = await read_float(reader)

            # escalation_status: GmTicketEscalationStatus
            escalation_status = GmTicketEscalationStatus(await read_int(reader, 1))

            # read_by_gm: Bool8
            read_by_gm = await read_bool(reader, 1)

        return SMSG_GMTICKET_GETTICKET(
            status=status,
            text=text,
            ticket_type=ticket_type,
            days_since_ticket_creation=days_since_ticket_creation,
            days_since_oldest_ticket_creation=days_since_oldest_ticket_creation,
            days_since_last_updated=days_since_last_updated,
            escalation_status=escalation_status,
            read_by_gm=read_by_gm,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0212))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.status.value)
        if self.status == GmTicketStatus.HAS_TEXT:
            _fmt += f'{len(self.text)}sBBfffBB'
            _data.extend([self.text.encode('utf-8'), 0, self.ticket_type.value, self.days_since_ticket_creation, self.days_since_oldest_ticket_creation, self.days_since_last_updated, self.escalation_status.value, self.read_by_gm])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        if self.status == GmTicketStatus.HAS_TEXT:
            _size += 16 + len(self.text)

        return _size


@dataclasses.dataclass
class CMSG_UNLEARN_TALENTS:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_UNLEARN_TALENTS:
        return CMSG_UNLEARN_TALENTS()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0213))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GAMEOBJECT_SPAWN_ANIM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GAMEOBJECT_SPAWN_ANIM:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_GAMEOBJECT_SPAWN_ANIM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0214))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GAMEOBJECT_DESPAWN_ANIM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GAMEOBJECT_DESPAWN_ANIM:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_GAMEOBJECT_DESPAWN_ANIM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0215))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_CORPSE_QUERY_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_CORPSE_QUERY_Client:
        return MSG_CORPSE_QUERY_Client()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0216))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_CORPSE_QUERY_Server:
    result: CorpseQueryResult
    map: typing.Optional[Map] = None
    position: typing.Optional[Vector3d] = None
    corpse_map: typing.Optional[Map] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_CORPSE_QUERY_Server:
        map = None
        position = None
        corpse_map = None
        # result: CorpseQueryResult
        result = CorpseQueryResult(await read_int(reader, 1))

        if result == CorpseQueryResult.FOUND:
            # map: Map
            map = Map(await read_int(reader, 4))

            # position: Vector3d
            position = await Vector3d.read(reader)

            # corpse_map: Map
            corpse_map = Map(await read_int(reader, 4))

        return MSG_CORPSE_QUERY_Server(
            result=result,
            map=map,
            position=position,
            corpse_map=corpse_map,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0216))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        if self.result == CorpseQueryResult.FOUND:
            _fmt += 'I'
            _data.append(self.map.value)
            # position: Vector3d
            _fmt, _data = self.position.write(_fmt, _data)

            # corpse_map: Map
            _fmt += 'I'
            _data.append(self.corpse_map.value)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.result == CorpseQueryResult.FOUND:
            _size += 20

        return _size


@dataclasses.dataclass
class CMSG_GMTICKET_DELETETICKET:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GMTICKET_DELETETICKET:
        return CMSG_GMTICKET_DELETETICKET()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0217))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GMTICKET_DELETETICKET:
    response: GmTicketResponse

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GMTICKET_DELETETICKET:
        # response: GmTicketResponse
        response = GmTicketResponse(await read_int(reader, 4))

        return SMSG_GMTICKET_DELETETICKET(
            response=response,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0218))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.response.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CHAT_WRONG_FACTION:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAT_WRONG_FACTION:
        return SMSG_CHAT_WRONG_FACTION()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0219))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GMTICKET_SYSTEMSTATUS:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GMTICKET_SYSTEMSTATUS:
        return CMSG_GMTICKET_SYSTEMSTATUS()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x021A))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GMTICKET_SYSTEMSTATUS:
    will_accept_tickets: GmTicketQueueStatus

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GMTICKET_SYSTEMSTATUS:
        # will_accept_tickets: GmTicketQueueStatus
        will_accept_tickets = GmTicketQueueStatus(await read_int(reader, 4))

        return SMSG_GMTICKET_SYSTEMSTATUS(
            will_accept_tickets=will_accept_tickets,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x021B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.will_accept_tickets.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SPIRIT_HEALER_ACTIVATE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SPIRIT_HEALER_ACTIVATE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_SPIRIT_HEALER_ACTIVATE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x021C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SET_REST_START:
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_REST_START:
        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return SMSG_SET_REST_START(
            unknown1=unknown1,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x021E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.unknown1)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPIRIT_HEALER_CONFIRM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPIRIT_HEALER_CONFIRM:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_SPIRIT_HEALER_CONFIRM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0222))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GOSSIP_POI:
    flags: int
    position: Vector2d
    icon: int
    data: int
    location_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GOSSIP_POI:
        # flags: u32
        flags = await read_int(reader, 4)

        # position: Vector2d
        position = await Vector2d.read(reader)

        # icon: u32
        icon = await read_int(reader, 4)

        # data: u32
        data = await read_int(reader, 4)

        # location_name: CString
        location_name = await read_cstring(reader)

        return SMSG_GOSSIP_POI(
            flags=flags,
            position=position,
            icon=icon,
            data=data,
            location_name=location_name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0224))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.flags)
        # position: Vector2d
        _fmt, _data = self.position.write(_fmt, _data)

        # icon: u32
        _fmt += 'I'
        _data.append(self.icon)

        # data: u32
        _fmt += 'I'
        _data.append(self.data)

        # location_name: CString
        _fmt += f'{len(self.location_name)}sB'
        _data.extend([self.location_name.encode('utf-8'), 0])

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 21 + len(self.location_name)


@dataclasses.dataclass
class CMSG_CHAT_IGNORED:
    guid: int
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHAT_IGNORED:
        # guid: Guid
        guid = await read_int(reader, 8)

        # unknown: u8
        unknown = await read_int(reader, 1)

        return CMSG_CHAT_IGNORED(
            guid=guid,
            unknown=unknown,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x0225))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.unknown])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_RANK:
    rank_id: int
    rights: int
    rank_name: str
    money_per_day: int
    bank_tab_rights: typing.List[GuildBankRights]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_RANK:
        # rank_id: u32
        rank_id = await read_int(reader, 4)

        # rights: u32
        rights = await read_int(reader, 4)

        # rank_name: CString
        rank_name = await read_cstring(reader)

        # money_per_day: Gold
        money_per_day = await read_int(reader, 4)

        # bank_tab_rights: GuildBankRights[6]
        bank_tab_rights = []
        for _ in range(0, 6):
            bank_tab_rights.append(await GuildBankRights.read(reader))

        return CMSG_GUILD_RANK(
            rank_id=rank_id,
            rights=rights,
            rank_name=rank_name,
            money_per_day=money_per_day,
            bank_tab_rights=bank_tab_rights,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0231))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'II{len(self.rank_name)}sBI'
        _data.extend([self.rank_id, self.rights, self.rank_name.encode('utf-8'), 0, self.money_per_day])
        # bank_tab_rights: GuildBankRights[6]
        for i in self.bank_tab_rights:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 61 + len(self.rank_name)


@dataclasses.dataclass
class CMSG_GUILD_ADD_RANK:
    rank_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_ADD_RANK:
        # rank_name: CString
        rank_name = await read_cstring(reader)

        return CMSG_GUILD_ADD_RANK(
            rank_name=rank_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0232))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.rank_name)}sB'
        _data.extend([self.rank_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.rank_name)


@dataclasses.dataclass
class CMSG_GUILD_DEL_RANK:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_DEL_RANK:
        return CMSG_GUILD_DEL_RANK()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0233))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_SET_PUBLIC_NOTE:
    player_name: str
    note: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_SET_PUBLIC_NOTE:
        # player_name: CString
        player_name = await read_cstring(reader)

        # note: CString
        note = await read_cstring(reader)

        return CMSG_GUILD_SET_PUBLIC_NOTE(
            player_name=player_name,
            note=note,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0234))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.player_name)}sB{len(self.note)}sB'
        _data.extend([self.player_name.encode('utf-8'), 0, self.note.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.player_name) + len(self.note)


@dataclasses.dataclass
class CMSG_GUILD_SET_OFFICER_NOTE:
    player_name: str
    note: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_SET_OFFICER_NOTE:
        # player_name: CString
        player_name = await read_cstring(reader)

        # note: CString
        note = await read_cstring(reader)

        return CMSG_GUILD_SET_OFFICER_NOTE(
            player_name=player_name,
            note=note,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0235))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.player_name)}sB{len(self.note)}sB'
        _data.extend([self.player_name.encode('utf-8'), 0, self.note.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.player_name) + len(self.note)


@dataclasses.dataclass
class SMSG_LOGIN_VERIFY_WORLD:
    map: Map
    position: Vector3d
    orientation: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOGIN_VERIFY_WORLD:
        # map: Map
        map = Map(await read_int(reader, 4))

        # position: Vector3d
        position = await Vector3d.read(reader)

        # orientation: f32
        orientation = await read_float(reader)

        return SMSG_LOGIN_VERIFY_WORLD(
            map=map,
            position=position,
            orientation=orientation,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x0236))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # orientation: f32
        _fmt += 'f'
        _data.append(self.orientation)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SEND_MAIL:
    mailbox: int
    receiver: str
    subject: str
    body: str
    unknown1: int
    unknown2: int
    items: typing.List[MailItem]
    money: int
    cash_on_delivery_amount: int
    unknown3: int
    unknown4: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SEND_MAIL:
        # mailbox: Guid
        mailbox = await read_int(reader, 8)

        # receiver: CString
        receiver = await read_cstring(reader)

        # subject: CString
        subject = await read_cstring(reader)

        # body: CString
        body = await read_cstring(reader)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # unknown2: u32
        unknown2 = await read_int(reader, 4)

        # amount_of_items: u8
        amount_of_items = await read_int(reader, 1)

        # items: MailItem[amount_of_items]
        items = []
        for _ in range(0, amount_of_items):
            items.append(await MailItem.read(reader))

        # money: Gold
        money = await read_int(reader, 4)

        # cash_on_delivery_amount: u32
        cash_on_delivery_amount = await read_int(reader, 4)

        # unknown3: u32
        unknown3 = await read_int(reader, 4)

        # unknown4: u32
        unknown4 = await read_int(reader, 4)

        return CMSG_SEND_MAIL(
            mailbox=mailbox,
            receiver=receiver,
            subject=subject,
            body=body,
            unknown1=unknown1,
            unknown2=unknown2,
            items=items,
            money=money,
            cash_on_delivery_amount=cash_on_delivery_amount,
            unknown3=unknown3,
            unknown4=unknown4,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0238))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.receiver)}sB{len(self.subject)}sB{len(self.body)}sBIIB'
        _data.extend([self.mailbox, self.receiver.encode('utf-8'), 0, self.subject.encode('utf-8'), 0, self.body.encode('utf-8'), 0, self.unknown1, self.unknown2, len(self.items)])
        # items: MailItem[amount_of_items]
        for i in self.items:
            _fmt, _data = i.write(_fmt, _data)

        # money: Gold
        _fmt += 'I'
        _data.append(self.money)

        # cash_on_delivery_amount: u32
        _fmt += 'I'
        _data.append(self.cash_on_delivery_amount)

        # unknown3: u32
        _fmt += 'I'
        _data.append(self.unknown3)

        # unknown4: u32
        _fmt += 'I'
        _data.append(self.unknown4)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 36 + len(self.receiver) + len(self.subject) + len(self.body) + 9 * len(self.items)


@dataclasses.dataclass
class SMSG_SEND_MAIL_RESULT:
    mail_id: int
    action: MailAction
    result: typing.Optional[MailResult] = None
    equip_error: typing.Optional[int] = None
    item: typing.Optional[int] = None
    item_count: typing.Optional[int] = None
    result2: typing.Optional[MailResultTwo] = None
    equip_error2: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SEND_MAIL_RESULT:
        result = None
        equip_error = None
        item = None
        item_count = None
        result2 = None
        equip_error2 = None
        # mail_id: u32
        mail_id = await read_int(reader, 4)

        # action: MailAction
        action = MailAction(await read_int(reader, 4))

        if action == MailAction.ITEM_TAKEN:
            # result: MailResult
            result = MailResult(await read_int(reader, 4))

            if result == MailResult.ERR_EQUIP_ERROR:
                # equip_error: u32
                equip_error = await read_int(reader, 4)

            elif result in {MailResult.OK, MailResult.ERR_CANNOT_SEND_TO_SELF, MailResult.ERR_NOT_ENOUGH_MONEY, MailResult.ERR_RECIPIENT_NOT_FOUND, MailResult.ERR_NOT_YOUR_TEAM, MailResult.ERR_INTERNAL_ERROR, MailResult.ERR_DISABLED_FOR_TRIAL_ACC, MailResult.ERR_RECIPIENT_CAP_REACHED, MailResult.ERR_CANT_SEND_WRAPPED_COD, MailResult.ERR_MAIL_AND_CHAT_SUSPENDED, MailResult.ERR_TOO_MANY_ATTACHMENTS, MailResult.ERR_MAIL_ATTACHMENT_INVALID}:
                # item: Item
                item = await read_int(reader, 4)

                # item_count: u32
                item_count = await read_int(reader, 4)

        elif action in {MailAction.SEND, MailAction.MONEY_TAKEN, MailAction.RETURNED_TO_SENDER, MailAction.DELETED, MailAction.MADE_PERMANENT}:
            # result2: MailResultTwo
            result2 = MailResultTwo(await read_int(reader, 4))

            if result2 == MailResultTwo.ERR_EQUIP_ERROR:
                # equip_error2: u32
                equip_error2 = await read_int(reader, 4)

        return SMSG_SEND_MAIL_RESULT(
            mail_id=mail_id,
            action=action,
            result=result,
            equip_error=equip_error,
            item=item,
            item_count=item_count,
            result2=result2,
            equip_error2=equip_error2,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0239))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.mail_id, self.action.value])
        if self.action == MailAction.ITEM_TAKEN:
            _fmt += 'I'
            _data.append(self.result.value)
            if self.result == MailResult.ERR_EQUIP_ERROR:
                _fmt += 'I'
                _data.append(self.equip_error)
            elif self.result in {MailResult.OK, MailResult.ERR_CANNOT_SEND_TO_SELF, MailResult.ERR_NOT_ENOUGH_MONEY, MailResult.ERR_RECIPIENT_NOT_FOUND, MailResult.ERR_NOT_YOUR_TEAM, MailResult.ERR_INTERNAL_ERROR, MailResult.ERR_DISABLED_FOR_TRIAL_ACC, MailResult.ERR_RECIPIENT_CAP_REACHED, MailResult.ERR_CANT_SEND_WRAPPED_COD, MailResult.ERR_MAIL_AND_CHAT_SUSPENDED, MailResult.ERR_TOO_MANY_ATTACHMENTS, MailResult.ERR_MAIL_ATTACHMENT_INVALID}:
                _fmt += 'II'
                _data.extend([self.item, self.item_count])
        elif self.action in {MailAction.SEND, MailAction.MONEY_TAKEN, MailAction.RETURNED_TO_SENDER, MailAction.DELETED, MailAction.MADE_PERMANENT}:
            _fmt += 'I'
            _data.append(self.result2.value)
            if self.result2 == MailResultTwo.ERR_EQUIP_ERROR:
                _fmt += 'I'
                _data.append(self.equip_error2)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 8

        if self.action == MailAction.ITEM_TAKEN:
            _size += 4

            if self.result == MailResult.ERR_EQUIP_ERROR:
                _size += 4
            elif self.result in {MailResult.OK, MailResult.ERR_CANNOT_SEND_TO_SELF, MailResult.ERR_NOT_ENOUGH_MONEY, MailResult.ERR_RECIPIENT_NOT_FOUND, MailResult.ERR_NOT_YOUR_TEAM, MailResult.ERR_INTERNAL_ERROR, MailResult.ERR_DISABLED_FOR_TRIAL_ACC, MailResult.ERR_RECIPIENT_CAP_REACHED, MailResult.ERR_CANT_SEND_WRAPPED_COD, MailResult.ERR_MAIL_AND_CHAT_SUSPENDED, MailResult.ERR_TOO_MANY_ATTACHMENTS, MailResult.ERR_MAIL_ATTACHMENT_INVALID}:
                _size += 8

        elif self.action in {MailAction.SEND, MailAction.MONEY_TAKEN, MailAction.RETURNED_TO_SENDER, MailAction.DELETED, MailAction.MADE_PERMANENT}:
            _size += 4

            if self.result2 == MailResultTwo.ERR_EQUIP_ERROR:
                _size += 4


        return _size


@dataclasses.dataclass
class CMSG_GET_MAIL_LIST:
    mailbox: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GET_MAIL_LIST:
        # mailbox: Guid
        mailbox = await read_int(reader, 8)

        return CMSG_GET_MAIL_LIST(
            mailbox=mailbox,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x023A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.mailbox)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MAIL_LIST_RESULT:
    mails: typing.List[Mail]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MAIL_LIST_RESULT:
        # amount_of_mails: u8
        amount_of_mails = await read_int(reader, 1)

        # mails: Mail[amount_of_mails]
        mails = []
        for _ in range(0, amount_of_mails):
            mails.append(await Mail.read(reader))

        return SMSG_MAIL_LIST_RESULT(
            mails=mails,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x023B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(len(self.mails))
        # mails: Mail[amount_of_mails]
        for i in self.mails:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + sum([i.size() for i in self.mails])


@dataclasses.dataclass
class CMSG_BATTLEFIELD_LIST:
    map: Map

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BATTLEFIELD_LIST:
        # map: Map
        map = Map(await read_int(reader, 4))

        return CMSG_BATTLEFIELD_LIST(
            map=map,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x023C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BATTLEFIELD_LIST:
    battlemaster: int
    battleground_type: BattlegroundType
    battlegrounds: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BATTLEFIELD_LIST:
        # battlemaster: Guid
        battlemaster = await read_int(reader, 8)

        # battleground_type: BattlegroundType
        battleground_type = BattlegroundType(await read_int(reader, 4))

        # number_of_battlegrounds: u32
        number_of_battlegrounds = await read_int(reader, 4)

        # battlegrounds: u32[number_of_battlegrounds]
        battlegrounds = []
        for _ in range(0, number_of_battlegrounds):
            battlegrounds.append(await read_int(reader, 4))

        return SMSG_BATTLEFIELD_LIST(
            battlemaster=battlemaster,
            battleground_type=battleground_type,
            battlegrounds=battlegrounds,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x023D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QII{len(self.battlegrounds)}I'
        _data.extend([self.battlemaster, self.battleground_type.value, len(self.battlegrounds), *self.battlegrounds])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + 4 * len(self.battlegrounds)


@dataclasses.dataclass
class CMSG_ITEM_TEXT_QUERY:
    item_text_id: int
    mail_id: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ITEM_TEXT_QUERY:
        # item_text_id: u32
        item_text_id = await read_int(reader, 4)

        # mail_id: u32
        mail_id = await read_int(reader, 4)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return CMSG_ITEM_TEXT_QUERY(
            item_text_id=item_text_id,
            mail_id=mail_id,
            unknown1=unknown1,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0243))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'III'
        _data.extend([self.item_text_id, self.mail_id, self.unknown1])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_TEXT_QUERY_RESPONSE:
    item_text_id: int
    text: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_TEXT_QUERY_RESPONSE:
        # item_text_id: u32
        item_text_id = await read_int(reader, 4)

        # text: CString
        text = await read_cstring(reader)

        return SMSG_ITEM_TEXT_QUERY_RESPONSE(
            item_text_id=item_text_id,
            text=text,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0244))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.text)}sB'
        _data.extend([self.item_text_id, self.text.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + len(self.text)


@dataclasses.dataclass
class CMSG_MAIL_TAKE_MONEY:
    mailbox: int
    mail_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MAIL_TAKE_MONEY:
        # mailbox: Guid
        mailbox = await read_int(reader, 8)

        # mail_id: u32
        mail_id = await read_int(reader, 4)

        return CMSG_MAIL_TAKE_MONEY(
            mailbox=mailbox,
            mail_id=mail_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0245))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.mailbox, self.mail_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MAIL_TAKE_ITEM:
    mailbox: int
    mail_id: int
    item: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MAIL_TAKE_ITEM:
        # mailbox: Guid
        mailbox = await read_int(reader, 8)

        # mail_id: u32
        mail_id = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        return CMSG_MAIL_TAKE_ITEM(
            mailbox=mailbox,
            mail_id=mail_id,
            item=item,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x0246))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.mailbox, self.mail_id, self.item])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MAIL_MARK_AS_READ:
    mailbox: int
    mail_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MAIL_MARK_AS_READ:
        # mailbox: Guid
        mailbox = await read_int(reader, 8)

        # mail_id: u32
        mail_id = await read_int(reader, 4)

        return CMSG_MAIL_MARK_AS_READ(
            mailbox=mailbox,
            mail_id=mail_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0247))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.mailbox, self.mail_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MAIL_RETURN_TO_SENDER:
    mailbox_id: int
    mail_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MAIL_RETURN_TO_SENDER:
        # mailbox_id: Guid
        mailbox_id = await read_int(reader, 8)

        # mail_id: u32
        mail_id = await read_int(reader, 4)

        return CMSG_MAIL_RETURN_TO_SENDER(
            mailbox_id=mailbox_id,
            mail_id=mail_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0248))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.mailbox_id, self.mail_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MAIL_DELETE:
    mailbox_id: int
    mail_id: int
    mail_template_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MAIL_DELETE:
        # mailbox_id: Guid
        mailbox_id = await read_int(reader, 8)

        # mail_id: u32
        mail_id = await read_int(reader, 4)

        # mail_template_id: u32
        mail_template_id = await read_int(reader, 4)

        return CMSG_MAIL_DELETE(
            mailbox_id=mailbox_id,
            mail_id=mail_id,
            mail_template_id=mail_template_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x0249))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.mailbox_id, self.mail_id, self.mail_template_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MAIL_CREATE_TEXT_ITEM:
    mailbox: int
    mail_id: int
    mail_template_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MAIL_CREATE_TEXT_ITEM:
        # mailbox: Guid
        mailbox = await read_int(reader, 8)

        # mail_id: u32
        mail_id = await read_int(reader, 4)

        # mail_template_id: u32
        mail_template_id = await read_int(reader, 4)

        return CMSG_MAIL_CREATE_TEXT_ITEM(
            mailbox=mailbox,
            mail_id=mail_id,
            mail_template_id=mail_template_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x024A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.mailbox, self.mail_id, self.mail_template_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELLLOGMISS:
    id: int
    caster: int
    unknown1: int
    targets: typing.List[SpellLogMiss]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLLOGMISS:
        # id: Spell
        id = await read_int(reader, 4)

        # caster: Guid
        caster = await read_int(reader, 8)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # amount_of_targets: u32
        amount_of_targets = await read_int(reader, 4)

        # targets: SpellLogMiss[amount_of_targets]
        targets = []
        for _ in range(0, amount_of_targets):
            targets.append(await SpellLogMiss.read(reader))

        return SMSG_SPELLLOGMISS(
            id=id,
            caster=caster,
            unknown1=unknown1,
            targets=targets,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x024B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IQBI'
        _data.extend([self.id, self.caster, self.unknown1, len(self.targets)])
        # targets: SpellLogMiss[amount_of_targets]
        for i in self.targets:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 17 + 9 * len(self.targets)


@dataclasses.dataclass
class SMSG_SPELLLOGEXECUTE:
    caster: int
    spell: int
    logs: typing.List[SpellLog]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLLOGEXECUTE:
        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # spell: Spell
        spell = await read_int(reader, 4)

        # amount_of_effects: u32
        amount_of_effects = await read_int(reader, 4)

        # logs: SpellLog[amount_of_effects]
        logs = []
        for _ in range(0, amount_of_effects):
            logs.append(await SpellLog.read(reader))

        return SMSG_SPELLLOGEXECUTE(
            caster=caster,
            spell=spell,
            logs=logs,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x024C))
        _fmt = "<4s"
        _data = [_data]

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # amount_of_effects: u32
        _fmt += 'I'
        _data.append(len(self.logs))

        # logs: SpellLog[amount_of_effects]
        for i in self.logs:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.caster) + sum([i.size() for i in self.logs])


@dataclasses.dataclass
class SMSG_PERIODICAURALOG:
    target: int
    caster: int
    spell: int
    auras: typing.List[AuraLog]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PERIODICAURALOG:
        # target: PackedGuid
        target = await read_packed_guid(reader)

        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # spell: Spell
        spell = await read_int(reader, 4)

        # amount_of_auras: u32
        amount_of_auras = await read_int(reader, 4)

        # auras: AuraLog[amount_of_auras]
        auras = []
        for _ in range(0, amount_of_auras):
            auras.append(await AuraLog.read(reader))

        return SMSG_PERIODICAURALOG(
            target=target,
            caster=caster,
            spell=spell,
            auras=auras,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x024E))
        _fmt = "<4s"
        _data = [_data]

        # target: PackedGuid
        _fmt, _data = packed_guid_write(self.target, _fmt, _data)

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # amount_of_auras: u32
        _fmt += 'I'
        _data.append(len(self.auras))

        # auras: AuraLog[amount_of_auras]
        for i in self.auras:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.target) + packed_guid_size(self.caster) + sum([i.size() for i in self.auras])


@dataclasses.dataclass
class SMSG_SPELLDAMAGESHIELD:
    victim: int
    caster: int
    spell: int
    damage: int
    school: SpellSchool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLDAMAGESHIELD:
        # victim: Guid
        victim = await read_int(reader, 8)

        # caster: Guid
        caster = await read_int(reader, 8)

        # spell: Spell
        spell = await read_int(reader, 4)

        # damage: u32
        damage = await read_int(reader, 4)

        # school: SpellSchool
        school = SpellSchool(await read_int(reader, 4))

        return SMSG_SPELLDAMAGESHIELD(
            victim=victim,
            caster=caster,
            spell=spell,
            damage=damage,
            school=school,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(28 + 2, 0x024F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQIII'
        _data.extend([self.victim, self.caster, self.spell, self.damage, self.school.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELLNONMELEEDAMAGELOG:
    target: int
    attacker: int
    spell: int
    damage: int
    school: SpellSchool
    absorbed_damage: int
    resisted: int
    periodic_log: bool
    unused: int
    blocked: int
    hit_info: HitInfo
    extend_flag: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLNONMELEEDAMAGELOG:
        # target: PackedGuid
        target = await read_packed_guid(reader)

        # attacker: PackedGuid
        attacker = await read_packed_guid(reader)

        # spell: Spell
        spell = await read_int(reader, 4)

        # damage: u32
        damage = await read_int(reader, 4)

        # school: SpellSchool
        school = SpellSchool(await read_int(reader, 1))

        # absorbed_damage: u32
        absorbed_damage = await read_int(reader, 4)

        # resisted: u32
        resisted = await read_int(reader, 4)

        # periodic_log: Bool8
        periodic_log = await read_bool(reader, 1)

        # unused: u8
        unused = await read_int(reader, 1)

        # blocked: u32
        blocked = await read_int(reader, 4)

        # hit_info: HitInfo
        hit_info = HitInfo(await read_int(reader, 4))

        # extend_flag: u8
        extend_flag = await read_int(reader, 1)

        return SMSG_SPELLNONMELEEDAMAGELOG(
            target=target,
            attacker=attacker,
            spell=spell,
            damage=damage,
            school=school,
            absorbed_damage=absorbed_damage,
            resisted=resisted,
            periodic_log=periodic_log,
            unused=unused,
            blocked=blocked,
            hit_info=hit_info,
            extend_flag=extend_flag,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0250))
        _fmt = "<4s"
        _data = [_data]

        # target: PackedGuid
        _fmt, _data = packed_guid_write(self.target, _fmt, _data)

        # attacker: PackedGuid
        _fmt, _data = packed_guid_write(self.attacker, _fmt, _data)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # damage: u32
        _fmt += 'I'
        _data.append(self.damage)

        # school: SpellSchool
        _fmt += 'B'
        _data.append(self.school.value)

        # absorbed_damage: u32
        _fmt += 'I'
        _data.append(self.absorbed_damage)

        # resisted: u32
        _fmt += 'I'
        _data.append(self.resisted)

        # periodic_log: Bool8
        _fmt += 'B'
        _data.append(self.periodic_log)

        # unused: u8
        _fmt += 'B'
        _data.append(self.unused)

        # blocked: u32
        _fmt += 'I'
        _data.append(self.blocked)

        # hit_info: HitInfo
        _fmt += 'I'
        _data.append(self.hit_info.value)

        # extend_flag: u8
        _fmt += 'B'
        _data.append(self.extend_flag)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 28 + packed_guid_size(self.target) + packed_guid_size(self.attacker)


@dataclasses.dataclass
class CMSG_LEARN_TALENT:
    talent: Talent
    requested_rank: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LEARN_TALENT:
        # talent: Talent
        talent = Talent(await read_int(reader, 4))

        # requested_rank: u32
        requested_rank = await read_int(reader, 4)

        return CMSG_LEARN_TALENT(
            talent=talent,
            requested_rank=requested_rank,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0251))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.talent.value, self.requested_rank])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_RESURRECT_FAILED:
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RESURRECT_FAILED:
        # unknown: u32
        unknown = await read_int(reader, 4)

        return SMSG_RESURRECT_FAILED(
            unknown=unknown,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0252))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.unknown)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TOGGLE_PVP:
    enable_pvp: typing.Optional[bool] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TOGGLE_PVP:
        enable_pvp = None
        _size = 0

        # set: optional
        if _size < body_size:
            # enable_pvp: Bool8
            enable_pvp = await read_bool(reader, 1)
            _size += 1

        return CMSG_TOGGLE_PVP(
            enable_pvp=enable_pvp,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0253))
        _fmt = "<6s"
        _data = [_data]

        # set: optional
        if self.enable_pvp is not None:
            _fmt += 'B'
            _data.append(self.enable_pvp)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 0

        # set: optional
        if self.enable_pvp is not None:
            _size += 1

        return _size


@dataclasses.dataclass
class SMSG_ZONE_UNDER_ATTACK:
    zone_id: Area

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ZONE_UNDER_ATTACK:
        # zone_id: Area
        zone_id = Area(await read_int(reader, 4))

        return SMSG_ZONE_UNDER_ATTACK(
            zone_id=zone_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0254))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.zone_id.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_AUCTION_HELLO_Client:
    auctioneer: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_AUCTION_HELLO_Client:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        return MSG_AUCTION_HELLO_Client(
            auctioneer=auctioneer,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0255))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.auctioneer)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_AUCTION_HELLO_Server:
    auctioneer: int
    auction_house: AuctionHouse

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_AUCTION_HELLO_Server:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        # auction_house: AuctionHouse
        auction_house = AuctionHouse(await read_int(reader, 4))

        return MSG_AUCTION_HELLO_Server(
            auctioneer=auctioneer,
            auction_house=auction_house,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0255))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.auctioneer, self.auction_house.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUCTION_SELL_ITEM:
    auctioneer: int
    item: int
    starting_bid: int
    buyout: int
    auction_duration_in_minutes: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUCTION_SELL_ITEM:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        # item: Guid
        item = await read_int(reader, 8)

        # starting_bid: u32
        starting_bid = await read_int(reader, 4)

        # buyout: u32
        buyout = await read_int(reader, 4)

        # auction_duration_in_minutes: u32
        auction_duration_in_minutes = await read_int(reader, 4)

        return CMSG_AUCTION_SELL_ITEM(
            auctioneer=auctioneer,
            item=item,
            starting_bid=starting_bid,
            buyout=buyout,
            auction_duration_in_minutes=auction_duration_in_minutes,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(28 + 4, 0x0256))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QQIII'
        _data.extend([self.auctioneer, self.item, self.starting_bid, self.buyout, self.auction_duration_in_minutes])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUCTION_REMOVE_ITEM:
    auctioneer: int
    auction_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUCTION_REMOVE_ITEM:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        # auction_id: u32
        auction_id = await read_int(reader, 4)

        return CMSG_AUCTION_REMOVE_ITEM(
            auctioneer=auctioneer,
            auction_id=auction_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0257))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.auctioneer, self.auction_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUCTION_LIST_ITEMS:
    auctioneer: int
    list_start_item: int
    searched_name: str
    minimum_level: int
    maximum_level: int
    auction_slot_id: int
    auction_main_category: int
    auction_sub_category: int
    auction_quality: ItemQuality
    usable: int
    is_full: int
    sorted_auctions: typing.List[AuctionSort]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUCTION_LIST_ITEMS:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        # list_start_item: u32
        list_start_item = await read_int(reader, 4)

        # searched_name: CString
        searched_name = await read_cstring(reader)

        # minimum_level: u8
        minimum_level = await read_int(reader, 1)

        # maximum_level: u8
        maximum_level = await read_int(reader, 1)

        # auction_slot_id: u32
        auction_slot_id = await read_int(reader, 4)

        # auction_main_category: u32
        auction_main_category = await read_int(reader, 4)

        # auction_sub_category: u32
        auction_sub_category = await read_int(reader, 4)

        # auction_quality: ItemQuality
        auction_quality = ItemQuality(await read_int(reader, 4))

        # usable: u8
        usable = await read_int(reader, 1)

        # is_full: u8
        is_full = await read_int(reader, 1)

        # amount_of_sorted_auctions: u8
        amount_of_sorted_auctions = await read_int(reader, 1)

        # sorted_auctions: AuctionSort[amount_of_sorted_auctions]
        sorted_auctions = []
        for _ in range(0, amount_of_sorted_auctions):
            sorted_auctions.append(await AuctionSort.read(reader))

        return CMSG_AUCTION_LIST_ITEMS(
            auctioneer=auctioneer,
            list_start_item=list_start_item,
            searched_name=searched_name,
            minimum_level=minimum_level,
            maximum_level=maximum_level,
            auction_slot_id=auction_slot_id,
            auction_main_category=auction_main_category,
            auction_sub_category=auction_sub_category,
            auction_quality=auction_quality,
            usable=usable,
            is_full=is_full,
            sorted_auctions=sorted_auctions,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0258))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'QI{len(self.searched_name)}sBBBIIIIBBB'
        _data.extend([self.auctioneer, self.list_start_item, self.searched_name.encode('utf-8'), 0, self.minimum_level, self.maximum_level, self.auction_slot_id, self.auction_main_category, self.auction_sub_category, self.auction_quality.value, self.usable, self.is_full, len(self.sorted_auctions)])
        # sorted_auctions: AuctionSort[amount_of_sorted_auctions]
        for i in self.sorted_auctions:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 34 + len(self.searched_name) + 2 * len(self.sorted_auctions)


@dataclasses.dataclass
class CMSG_AUCTION_LIST_OWNER_ITEMS:
    auctioneer: int
    list_from: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUCTION_LIST_OWNER_ITEMS:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        # list_from: u32
        list_from = await read_int(reader, 4)

        return CMSG_AUCTION_LIST_OWNER_ITEMS(
            auctioneer=auctioneer,
            list_from=list_from,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0259))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.auctioneer, self.list_from])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUCTION_PLACE_BID:
    auctioneer: int
    auction_id: int
    price: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUCTION_PLACE_BID:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        # auction_id: u32
        auction_id = await read_int(reader, 4)

        # price: Gold
        price = await read_int(reader, 4)

        return CMSG_AUCTION_PLACE_BID(
            auctioneer=auctioneer,
            auction_id=auction_id,
            price=price,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x025A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.auctioneer, self.auction_id, self.price])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AUCTION_COMMAND_RESULT:
    auction_id: int
    action: AuctionCommandAction
    result: typing.Optional[AuctionCommandResult] = None
    auction_outbid1: typing.Optional[int] = None
    inventory_result: typing.Optional[InventoryResult] = None
    higher_bidder: typing.Optional[int] = None
    new_bid: typing.Optional[int] = None
    auction_outbid2: typing.Optional[int] = None
    result2: typing.Optional[AuctionCommandResultTwo] = None
    inventory_result2: typing.Optional[InventoryResult] = None
    higher_bidder2: typing.Optional[int] = None
    new_bid2: typing.Optional[int] = None
    auction_outbid3: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_COMMAND_RESULT:
        result = None
        auction_outbid1 = None
        inventory_result = None
        higher_bidder = None
        new_bid = None
        auction_outbid2 = None
        result2 = None
        inventory_result2 = None
        higher_bidder2 = None
        new_bid2 = None
        auction_outbid3 = None
        # auction_id: u32
        auction_id = await read_int(reader, 4)

        # action: AuctionCommandAction
        action = AuctionCommandAction(await read_int(reader, 4))

        if action == AuctionCommandAction.BID_PLACED:
            # result: AuctionCommandResult
            result = AuctionCommandResult(await read_int(reader, 4))

            if result == AuctionCommandResult.OK:
                # auction_outbid1: u32
                auction_outbid1 = await read_int(reader, 4)

            elif result == AuctionCommandResult.ERR_INVENTORY:
                # inventory_result: InventoryResult
                inventory_result = InventoryResult(await read_int(reader, 1))

            elif result == AuctionCommandResult.ERR_HIGHER_BID:
                # higher_bidder: Guid
                higher_bidder = await read_int(reader, 8)

                # new_bid: u32
                new_bid = await read_int(reader, 4)

                # auction_outbid2: u32
                auction_outbid2 = await read_int(reader, 4)

        elif action in {AuctionCommandAction.STARTED, AuctionCommandAction.REMOVED}:
            # result2: AuctionCommandResultTwo
            result2 = AuctionCommandResultTwo(await read_int(reader, 4))

            if result2 == AuctionCommandResultTwo.ERR_INVENTORY:
                # inventory_result2: InventoryResult
                inventory_result2 = InventoryResult(await read_int(reader, 1))

            elif result2 == AuctionCommandResultTwo.ERR_HIGHER_BID:
                # higher_bidder2: Guid
                higher_bidder2 = await read_int(reader, 8)

                # new_bid2: u32
                new_bid2 = await read_int(reader, 4)

                # auction_outbid3: u32
                auction_outbid3 = await read_int(reader, 4)

        return SMSG_AUCTION_COMMAND_RESULT(
            auction_id=auction_id,
            action=action,
            result=result,
            auction_outbid1=auction_outbid1,
            inventory_result=inventory_result,
            higher_bidder=higher_bidder,
            new_bid=new_bid,
            auction_outbid2=auction_outbid2,
            result2=result2,
            inventory_result2=inventory_result2,
            higher_bidder2=higher_bidder2,
            new_bid2=new_bid2,
            auction_outbid3=auction_outbid3,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x025B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.auction_id, self.action.value])
        if self.action == AuctionCommandAction.BID_PLACED:
            _fmt += 'I'
            _data.append(self.result.value)
            if self.result == AuctionCommandResult.OK:
                _fmt += 'I'
                _data.append(self.auction_outbid1)
            elif self.result == AuctionCommandResult.ERR_INVENTORY:
                _fmt += 'B'
                _data.append(self.inventory_result.value)
            elif self.result == AuctionCommandResult.ERR_HIGHER_BID:
                _fmt += 'QII'
                _data.extend([self.higher_bidder, self.new_bid, self.auction_outbid2])
        elif self.action in {AuctionCommandAction.STARTED, AuctionCommandAction.REMOVED}:
            _fmt += 'I'
            _data.append(self.result2.value)
            if self.result2 == AuctionCommandResultTwo.ERR_INVENTORY:
                _fmt += 'B'
                _data.append(self.inventory_result2.value)
            elif self.result2 == AuctionCommandResultTwo.ERR_HIGHER_BID:
                _fmt += 'QII'
                _data.extend([self.higher_bidder2, self.new_bid2, self.auction_outbid3])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 8

        if self.action == AuctionCommandAction.BID_PLACED:
            _size += 4

            if self.result == AuctionCommandResult.OK:
                _size += 4
            elif self.result == AuctionCommandResult.ERR_INVENTORY:
                _size += 1
            elif self.result == AuctionCommandResult.ERR_HIGHER_BID:
                _size += 16

        elif self.action in {AuctionCommandAction.STARTED, AuctionCommandAction.REMOVED}:
            _size += 4

            if self.result2 == AuctionCommandResultTwo.ERR_INVENTORY:
                _size += 1
            elif self.result2 == AuctionCommandResultTwo.ERR_HIGHER_BID:
                _size += 16


        return _size


@dataclasses.dataclass
class SMSG_AUCTION_LIST_RESULT:
    auctions: typing.List[AuctionListItem]
    total_amount_of_auctions: int
    auction_search_delay: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_LIST_RESULT:
        # count: u32
        count = await read_int(reader, 4)

        # auctions: AuctionListItem[count]
        auctions = []
        for _ in range(0, count):
            auctions.append(await AuctionListItem.read(reader))

        # total_amount_of_auctions: u32
        total_amount_of_auctions = await read_int(reader, 4)

        # auction_search_delay: Milliseconds
        auction_search_delay = await read_int(reader, 4)

        return SMSG_AUCTION_LIST_RESULT(
            auctions=auctions,
            total_amount_of_auctions=total_amount_of_auctions,
            auction_search_delay=auction_search_delay,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x025C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.auctions))
        # auctions: AuctionListItem[count]
        for i in self.auctions:
            _fmt, _data = i.write(_fmt, _data)

        # total_amount_of_auctions: u32
        _fmt += 'I'
        _data.append(self.total_amount_of_auctions)

        # auction_search_delay: Milliseconds
        _fmt += 'I'
        _data.append(self.auction_search_delay)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + 136 * len(self.auctions)


@dataclasses.dataclass
class SMSG_AUCTION_OWNER_LIST_RESULT:
    auctions: typing.List[AuctionListItem]
    total_amount_of_auctions: int
    auction_search_delay: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_OWNER_LIST_RESULT:
        # count: u32
        count = await read_int(reader, 4)

        # auctions: AuctionListItem[count]
        auctions = []
        for _ in range(0, count):
            auctions.append(await AuctionListItem.read(reader))

        # total_amount_of_auctions: u32
        total_amount_of_auctions = await read_int(reader, 4)

        # auction_search_delay: Milliseconds
        auction_search_delay = await read_int(reader, 4)

        return SMSG_AUCTION_OWNER_LIST_RESULT(
            auctions=auctions,
            total_amount_of_auctions=total_amount_of_auctions,
            auction_search_delay=auction_search_delay,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x025D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.auctions))
        # auctions: AuctionListItem[count]
        for i in self.auctions:
            _fmt, _data = i.write(_fmt, _data)

        # total_amount_of_auctions: u32
        _fmt += 'I'
        _data.append(self.total_amount_of_auctions)

        # auction_search_delay: Milliseconds
        _fmt += 'I'
        _data.append(self.auction_search_delay)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + 136 * len(self.auctions)


@dataclasses.dataclass
class SMSG_AUCTION_BIDDER_NOTIFICATION:
    auction_house: AuctionHouse
    auction_id: int
    bidder: int
    won: int
    out_bid: int
    item_template: int
    item_random_property_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_BIDDER_NOTIFICATION:
        # auction_house: AuctionHouse
        auction_house = AuctionHouse(await read_int(reader, 4))

        # auction_id: u32
        auction_id = await read_int(reader, 4)

        # bidder: Guid
        bidder = await read_int(reader, 8)

        # won: u32
        won = await read_int(reader, 4)

        # out_bid: u32
        out_bid = await read_int(reader, 4)

        # item_template: u32
        item_template = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        return SMSG_AUCTION_BIDDER_NOTIFICATION(
            auction_house=auction_house,
            auction_id=auction_id,
            bidder=bidder,
            won=won,
            out_bid=out_bid,
            item_template=item_template,
            item_random_property_id=item_random_property_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(32 + 2, 0x025E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIQIIII'
        _data.extend([self.auction_house.value, self.auction_id, self.bidder, self.won, self.out_bid, self.item_template, self.item_random_property_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AUCTION_OWNER_NOTIFICATION:
    auction_id: int
    bid: int
    auction_out_bid: int
    bidder: int
    item: int
    item_random_property_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_OWNER_NOTIFICATION:
        # auction_id: u32
        auction_id = await read_int(reader, 4)

        # bid: u32
        bid = await read_int(reader, 4)

        # auction_out_bid: u32
        auction_out_bid = await read_int(reader, 4)

        # bidder: Guid
        bidder = await read_int(reader, 8)

        # item: Item
        item = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        return SMSG_AUCTION_OWNER_NOTIFICATION(
            auction_id=auction_id,
            bid=bid,
            auction_out_bid=auction_out_bid,
            bidder=bidder,
            item=item,
            item_random_property_id=item_random_property_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(28 + 2, 0x025F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIQII'
        _data.extend([self.auction_id, self.bid, self.auction_out_bid, self.bidder, self.item, self.item_random_property_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PROCRESIST:
    caster: int
    target: int
    id: int
    log_format: LogFormat

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PROCRESIST:
        # caster: Guid
        caster = await read_int(reader, 8)

        # target: Guid
        target = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        # log_format: LogFormat
        log_format = LogFormat(await read_int(reader, 1))

        return SMSG_PROCRESIST(
            caster=caster,
            target=target,
            id=id,
            log_format=log_format,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(21 + 2, 0x0260))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQIB'
        _data.extend([self.caster, self.target, self.id, self.log_format.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DISPEL_FAILED:
    caster: int
    target: int
    spells: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DISPEL_FAILED:
        _size = 0

        # caster: Guid
        caster = await read_int(reader, 8)
        _size += 8

        # target: Guid
        target = await read_int(reader, 8)
        _size += 8

        # spells: Spell[-]
        spells = []
        while _size < body_size:
            spells.append(await read_int(reader, 4))
            _size += 4

        return SMSG_DISPEL_FAILED(
            caster=caster,
            target=target,
            spells=spells,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0262))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQ'
        _data.extend([self.caster, self.target])
        # spells: Spell[-]
        _fmt += f'len({self.spells})I'
        _data.extend(self.spells)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + 4 * len(self.spells)


@dataclasses.dataclass
class SMSG_SPELLORDAMAGE_IMMUNE:
    caster: int
    target: int
    id: int
    debug_log_format: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLORDAMAGE_IMMUNE:
        # caster: Guid
        caster = await read_int(reader, 8)

        # target: Guid
        target = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        # debug_log_format: Bool8
        debug_log_format = await read_bool(reader, 1)

        return SMSG_SPELLORDAMAGE_IMMUNE(
            caster=caster,
            target=target,
            id=id,
            debug_log_format=debug_log_format,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(21 + 2, 0x0263))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQIB'
        _data.extend([self.caster, self.target, self.id, self.debug_log_format])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUCTION_LIST_BIDDER_ITEMS:
    auctioneer: int
    start_from_page: int
    outbid_item_ids: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUCTION_LIST_BIDDER_ITEMS:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        # start_from_page: u32
        start_from_page = await read_int(reader, 4)

        # amount_of_outbid_items: u32
        amount_of_outbid_items = await read_int(reader, 4)

        # outbid_item_ids: u32[amount_of_outbid_items]
        outbid_item_ids = []
        for _ in range(0, amount_of_outbid_items):
            outbid_item_ids.append(await read_int(reader, 4))

        return CMSG_AUCTION_LIST_BIDDER_ITEMS(
            auctioneer=auctioneer,
            start_from_page=start_from_page,
            outbid_item_ids=outbid_item_ids,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0264))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'QII{len(self.outbid_item_ids)}I'
        _data.extend([self.auctioneer, self.start_from_page, len(self.outbid_item_ids), *self.outbid_item_ids])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + 4 * len(self.outbid_item_ids)


@dataclasses.dataclass
class SMSG_AUCTION_BIDDER_LIST_RESULT:
    auctions: typing.List[AuctionListItem]
    total_amount_of_auctions: int
    auction_search_delay: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_BIDDER_LIST_RESULT:
        # count: u32
        count = await read_int(reader, 4)

        # auctions: AuctionListItem[count]
        auctions = []
        for _ in range(0, count):
            auctions.append(await AuctionListItem.read(reader))

        # total_amount_of_auctions: u32
        total_amount_of_auctions = await read_int(reader, 4)

        # auction_search_delay: Milliseconds
        auction_search_delay = await read_int(reader, 4)

        return SMSG_AUCTION_BIDDER_LIST_RESULT(
            auctions=auctions,
            total_amount_of_auctions=total_amount_of_auctions,
            auction_search_delay=auction_search_delay,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0265))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.auctions))
        # auctions: AuctionListItem[count]
        for i in self.auctions:
            _fmt, _data = i.write(_fmt, _data)

        # total_amount_of_auctions: u32
        _fmt += 'I'
        _data.append(self.total_amount_of_auctions)

        # auction_search_delay: Milliseconds
        _fmt += 'I'
        _data.append(self.auction_search_delay)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + 136 * len(self.auctions)


@dataclasses.dataclass
class SMSG_SET_FLAT_SPELL_MODIFIER:
    eff: int
    op: int
    value: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_FLAT_SPELL_MODIFIER:
        # eff: u8
        eff = await read_int(reader, 1)

        # op: u8
        op = await read_int(reader, 1)

        # value: u32
        value = await read_int(reader, 4)

        return SMSG_SET_FLAT_SPELL_MODIFIER(
            eff=eff,
            op=op,
            value=value,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(6 + 2, 0x0266))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BBI'
        _data.extend([self.eff, self.op, self.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SET_PCT_SPELL_MODIFIER:
    eff: int
    op: int
    value: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_PCT_SPELL_MODIFIER:
        # eff: u8
        eff = await read_int(reader, 1)

        # op: u8
        op = await read_int(reader, 1)

        # value: u32
        value = await read_int(reader, 4)

        return SMSG_SET_PCT_SPELL_MODIFIER(
            eff=eff,
            op=op,
            value=value,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(6 + 2, 0x0267))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BBI'
        _data.extend([self.eff, self.op, self.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_AMMO:
    item: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_AMMO:
        # item: Item
        item = await read_int(reader, 4)

        return CMSG_SET_AMMO(
            item=item,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0268))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.item)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CORPSE_RECLAIM_DELAY:
    delay: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CORPSE_RECLAIM_DELAY:
        # delay: Seconds
        delay = await read_int(reader, 4)

        return SMSG_CORPSE_RECLAIM_DELAY(
            delay=delay,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0269))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.delay)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_ACTIVE_MOVER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_ACTIVE_MOVER:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_SET_ACTIVE_MOVER(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x026A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PET_CANCEL_AURA:
    guid: int
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_CANCEL_AURA:
        # guid: Guid
        guid = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        return CMSG_PET_CANCEL_AURA(
            guid=guid,
            id=id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x026B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CANCEL_AUTO_REPEAT_SPELL:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_AUTO_REPEAT_SPELL:
        return CMSG_CANCEL_AUTO_REPEAT_SPELL()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x026D))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_LIST_STABLED_PETS_Client:
    npc: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_LIST_STABLED_PETS_Client:
        # npc: Guid
        npc = await read_int(reader, 8)

        return MSG_LIST_STABLED_PETS_Client(
            npc=npc,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x026F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.npc)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_LIST_STABLED_PETS_Server:
    npc: int
    stable_slots: int
    pets: typing.List[StabledPet]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_LIST_STABLED_PETS_Server:
        # npc: Guid
        npc = await read_int(reader, 8)

        # amount_of_pets: u8
        amount_of_pets = await read_int(reader, 1)

        # stable_slots: u8
        stable_slots = await read_int(reader, 1)

        # pets: StabledPet[amount_of_pets]
        pets = []
        for _ in range(0, amount_of_pets):
            pets.append(await StabledPet.read(reader))

        return MSG_LIST_STABLED_PETS_Server(
            npc=npc,
            stable_slots=stable_slots,
            pets=pets,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x026F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QBB'
        _data.extend([self.npc, len(self.pets), self.stable_slots])
        # pets: StabledPet[amount_of_pets]
        for i in self.pets:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 10 + sum([i.size() for i in self.pets])


@dataclasses.dataclass
class CMSG_STABLE_PET:
    stable_master: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_STABLE_PET:
        # stable_master: Guid
        stable_master = await read_int(reader, 8)

        return CMSG_STABLE_PET(
            stable_master=stable_master,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0270))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.stable_master)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_UNSTABLE_PET:
    stable_master: int
    pet_number: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_UNSTABLE_PET:
        # stable_master: Guid
        stable_master = await read_int(reader, 8)

        # pet_number: u32
        pet_number = await read_int(reader, 4)

        return CMSG_UNSTABLE_PET(
            stable_master=stable_master,
            pet_number=pet_number,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0271))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.stable_master, self.pet_number])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BUY_STABLE_SLOT:
    npc: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BUY_STABLE_SLOT:
        # npc: Guid
        npc = await read_int(reader, 8)

        return CMSG_BUY_STABLE_SLOT(
            npc=npc,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0272))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.npc)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_STABLE_RESULT:
    result: StableResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_STABLE_RESULT:
        # result: StableResult
        result = StableResult(await read_int(reader, 1))

        return SMSG_STABLE_RESULT(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x0273))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_STABLE_SWAP_PET:
    npc: int
    pet_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_STABLE_SWAP_PET:
        # npc: Guid
        npc = await read_int(reader, 8)

        # pet_slot: u32
        pet_slot = await read_int(reader, 4)

        return CMSG_STABLE_SWAP_PET(
            npc=npc,
            pet_slot=pet_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0275))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.npc, self.pet_slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_QUEST_PUSH_RESULT:
    guid: int
    message: QuestPartyMessage

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_QUEST_PUSH_RESULT:
        # guid: Guid
        guid = await read_int(reader, 8)

        # message: QuestPartyMessage
        message = QuestPartyMessage(await read_int(reader, 1))

        return MSG_QUEST_PUSH_RESULT(
            guid=guid,
            message=message,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x0276))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.message.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x0276))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.message.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PLAY_MUSIC:
    sound_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAY_MUSIC:
        # sound_id: u32
        sound_id = await read_int(reader, 4)

        return SMSG_PLAY_MUSIC(
            sound_id=sound_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0277))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.sound_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PLAY_OBJECT_SOUND:
    sound_id: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAY_OBJECT_SOUND:
        # sound_id: u32
        sound_id = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_PLAY_OBJECT_SOUND(
            sound_id=sound_id,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0278))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.sound_id, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_REQUEST_PET_INFO:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REQUEST_PET_INFO:
        return CMSG_REQUEST_PET_INFO()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0279))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_FAR_SIGHT:
    operation: FarSightOperation

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FAR_SIGHT:
        # operation: FarSightOperation
        operation = FarSightOperation(await read_int(reader, 1))

        return CMSG_FAR_SIGHT(
            operation=operation,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x027A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.operation.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELLDISPELLOG:
    victim: int
    caster: int
    dispell_spell: int
    unknown: int
    spells: typing.List[DispelledSpell]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLDISPELLOG:
        # victim: PackedGuid
        victim = await read_packed_guid(reader)

        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # dispell_spell: Spell
        dispell_spell = await read_int(reader, 4)

        # unknown: u8
        unknown = await read_int(reader, 1)

        # amount_of_spells: u32
        amount_of_spells = await read_int(reader, 4)

        # spells: DispelledSpell[amount_of_spells]
        spells = []
        for _ in range(0, amount_of_spells):
            spells.append(await DispelledSpell.read(reader))

        return SMSG_SPELLDISPELLOG(
            victim=victim,
            caster=caster,
            dispell_spell=dispell_spell,
            unknown=unknown,
            spells=spells,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x027B))
        _fmt = "<4s"
        _data = [_data]

        # victim: PackedGuid
        _fmt, _data = packed_guid_write(self.victim, _fmt, _data)

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # dispell_spell: Spell
        _fmt += 'I'
        _data.append(self.dispell_spell)

        # unknown: u8
        _fmt += 'B'
        _data.append(self.unknown)

        # amount_of_spells: u32
        _fmt += 'I'
        _data.append(len(self.spells))

        # spells: DispelledSpell[amount_of_spells]
        for i in self.spells:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + packed_guid_size(self.victim) + packed_guid_size(self.caster) + 5 * len(self.spells)


@dataclasses.dataclass
class CMSG_GROUP_CHANGE_SUB_GROUP:
    name: str
    group_number: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_CHANGE_SUB_GROUP:
        # name: CString
        name = await read_cstring(reader)

        # group_number: u8
        group_number = await read_int(reader, 1)

        return CMSG_GROUP_CHANGE_SUB_GROUP(
            name=name,
            group_number=group_number,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x027E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sBB'
        _data.extend([self.name.encode('utf-8'), 0, self.group_number])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.name)


@dataclasses.dataclass
class CMSG_REQUEST_PARTY_MEMBER_STATS:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REQUEST_PARTY_MEMBER_STATS:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_REQUEST_PARTY_MEMBER_STATS(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x027F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_SWAP_SUB_GROUP:
    name: str
    swap_with_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_SWAP_SUB_GROUP:
        # name: CString
        name = await read_cstring(reader)

        # swap_with_name: CString
        swap_with_name = await read_cstring(reader)

        return CMSG_GROUP_SWAP_SUB_GROUP(
            name=name,
            swap_with_name=swap_with_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0280))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB{len(self.swap_with_name)}sB'
        _data.extend([self.name.encode('utf-8'), 0, self.swap_with_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.name) + len(self.swap_with_name)


@dataclasses.dataclass
class CMSG_AUTOSTORE_BANK_ITEM:
    bag_index: int
    slot_index: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUTOSTORE_BANK_ITEM:
        # bag_index: u8
        bag_index = await read_int(reader, 1)

        # slot_index: u8
        slot_index = await read_int(reader, 1)

        return CMSG_AUTOSTORE_BANK_ITEM(
            bag_index=bag_index,
            slot_index=slot_index,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x0282))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.bag_index, self.slot_index])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUTOBANK_ITEM:
    bag_index: int
    slot_index: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUTOBANK_ITEM:
        # bag_index: u8
        bag_index = await read_int(reader, 1)

        # slot_index: u8
        slot_index = await read_int(reader, 1)

        return CMSG_AUTOBANK_ITEM(
            bag_index=bag_index,
            slot_index=slot_index,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x0283))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.bag_index, self.slot_index])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_QUERY_NEXT_MAIL_TIME_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_QUERY_NEXT_MAIL_TIME_Client:
        return MSG_QUERY_NEXT_MAIL_TIME_Client()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0284))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_QUERY_NEXT_MAIL_TIME_Server:
    float: int
    mails: typing.List[ReceivedMail]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_QUERY_NEXT_MAIL_TIME_Server:
        # float: u32
        float = await read_int(reader, 4)

        # amount_of_mails: u32
        amount_of_mails = await read_int(reader, 4)

        # mails: ReceivedMail[amount_of_mails]
        mails = []
        for _ in range(0, amount_of_mails):
            mails.append(await ReceivedMail.read(reader))

        return MSG_QUERY_NEXT_MAIL_TIME_Server(
            float=float,
            mails=mails,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0284))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.float, len(self.mails)])
        # mails: ReceivedMail[amount_of_mails]
        for i in self.mails:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + 24 * len(self.mails)


@dataclasses.dataclass
class SMSG_RECEIVED_MAIL:
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RECEIVED_MAIL:
        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return SMSG_RECEIVED_MAIL(
            unknown1=unknown1,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0285))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.unknown1)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_RAID_GROUP_ONLY:
    homebind_timer: int
    error: RaidGroupError

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RAID_GROUP_ONLY:
        # homebind_timer: u32
        homebind_timer = await read_int(reader, 4)

        # error: RaidGroupError
        error = RaidGroupError(await read_int(reader, 4))

        return SMSG_RAID_GROUP_ONLY(
            homebind_timer=homebind_timer,
            error=error,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0286))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.homebind_timer, self.error.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PVP_CREDIT:
    honor_points: int
    victim: int
    rank: PvpRank

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PVP_CREDIT:
        # honor_points: u32
        honor_points = await read_int(reader, 4)

        # victim: Guid
        victim = await read_int(reader, 8)

        # rank: PvpRank
        rank = PvpRank(await read_int(reader, 4))

        return SMSG_PVP_CREDIT(
            honor_points=honor_points,
            victim=victim,
            rank=rank,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x028C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IQI'
        _data.extend([self.honor_points, self.victim, self.rank.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AUCTION_REMOVED_NOTIFICATION:
    item: int
    item_template: int
    random_property_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_REMOVED_NOTIFICATION:
        # item: Item
        item = await read_int(reader, 4)

        # item_template: u32
        item_template = await read_int(reader, 4)

        # random_property_id: u32
        random_property_id = await read_int(reader, 4)

        return SMSG_AUCTION_REMOVED_NOTIFICATION(
            item=item,
            item_template=item_template,
            random_property_id=random_property_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x028D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'III'
        _data.extend([self.item, self.item_template, self.random_property_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_RAID_CONVERT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_RAID_CONVERT:
        return CMSG_GROUP_RAID_CONVERT()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x028E))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_ASSISTANT_LEADER:
    guid: int
    set_assistant: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_ASSISTANT_LEADER:
        # guid: Guid
        guid = await read_int(reader, 8)

        # set_assistant: Bool8
        set_assistant = await read_bool(reader, 1)

        return CMSG_GROUP_ASSISTANT_LEADER(
            guid=guid,
            set_assistant=set_assistant,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x028F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.set_assistant])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BUYBACK_ITEM:
    guid: int
    slot: BuybackSlot

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BUYBACK_ITEM:
        # guid: Guid
        guid = await read_int(reader, 8)

        # slot: BuybackSlot
        slot = BuybackSlot(await read_int(reader, 4))

        return CMSG_BUYBACK_ITEM(
            guid=guid,
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0290))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.slot.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SERVER_MESSAGE:
    message_type: ServerMessageType
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SERVER_MESSAGE:
        # message_type: ServerMessageType
        message_type = ServerMessageType(await read_int(reader, 4))

        # message: CString
        message = await read_cstring(reader)

        return SMSG_SERVER_MESSAGE(
            message_type=message_type,
            message=message,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0291))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.message)}sB'
        _data.extend([self.message_type.value, self.message.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + len(self.message)


@dataclasses.dataclass
class SMSG_MEETINGSTONE_SETQUEUE:
    area: Area
    status: MeetingStoneStatus

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MEETINGSTONE_SETQUEUE:
        # area: Area
        area = Area(await read_int(reader, 4))

        # status: MeetingStoneStatus
        status = MeetingStoneStatus(await read_int(reader, 1))

        return SMSG_MEETINGSTONE_SETQUEUE(
            area=area,
            status=status,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x0295))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([self.area.value, self.status.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MEETINGSTONE_INFO:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MEETINGSTONE_INFO:
        return CMSG_MEETINGSTONE_INFO()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0296))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GMTICKETSYSTEM_TOGGLE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GMTICKETSYSTEM_TOGGLE:
        return CMSG_GMTICKETSYSTEM_TOGGLE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x029A))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CANCEL_GROWTH_AURA:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_GROWTH_AURA:
        return CMSG_CANCEL_GROWTH_AURA()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x029B))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CANCEL_AUTO_REPEAT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CANCEL_AUTO_REPEAT:
        return SMSG_CANCEL_AUTO_REPEAT()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x029C))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_STANDSTATE_UPDATE:
    state: UnitStandState

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_STANDSTATE_UPDATE:
        # state: UnitStandState
        state = UnitStandState(await read_int(reader, 1))

        return SMSG_STANDSTATE_UPDATE(
            state=state,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x029D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.state.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_ALL_PASSED:
    looted_target: int
    loot_slot: int
    item: int
    item_random_property_id: int
    item_random_suffix_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_ALL_PASSED:
        # looted_target: Guid
        looted_target = await read_int(reader, 8)

        # loot_slot: u32
        loot_slot = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # item_random_suffix_id: u32
        item_random_suffix_id = await read_int(reader, 4)

        return SMSG_LOOT_ALL_PASSED(
            looted_target=looted_target,
            loot_slot=loot_slot,
            item=item,
            item_random_property_id=item_random_property_id,
            item_random_suffix_id=item_random_suffix_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(24 + 2, 0x029E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIIII'
        _data.extend([self.looted_target, self.loot_slot, self.item, self.item_random_property_id, self.item_random_suffix_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_ROLL_WON:
    looted_target: int
    loot_slot: int
    item: int
    item_random_suffix: int
    item_random_property_id: int
    winning_player: int
    winning_roll: int
    vote: RollVote

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_ROLL_WON:
        # looted_target: Guid
        looted_target = await read_int(reader, 8)

        # loot_slot: u32
        loot_slot = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        # item_random_suffix: u32
        item_random_suffix = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # winning_player: Guid
        winning_player = await read_int(reader, 8)

        # winning_roll: u8
        winning_roll = await read_int(reader, 1)

        # vote: RollVote
        vote = RollVote(await read_int(reader, 1))

        return SMSG_LOOT_ROLL_WON(
            looted_target=looted_target,
            loot_slot=loot_slot,
            item=item,
            item_random_suffix=item_random_suffix,
            item_random_property_id=item_random_property_id,
            winning_player=winning_player,
            winning_roll=winning_roll,
            vote=vote,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(34 + 2, 0x029F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIIIIQBB'
        _data.extend([self.looted_target, self.loot_slot, self.item, self.item_random_suffix, self.item_random_property_id, self.winning_player, self.winning_roll, self.vote.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LOOT_ROLL:
    item: int
    item_slot: int
    vote: RollVote

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOOT_ROLL:
        # item: Guid
        item = await read_int(reader, 8)

        # item_slot: u32
        item_slot = await read_int(reader, 4)

        # vote: RollVote
        vote = RollVote(await read_int(reader, 1))

        return CMSG_LOOT_ROLL(
            item=item,
            item_slot=item_slot,
            vote=vote,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(13 + 4, 0x02A0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIB'
        _data.extend([self.item, self.item_slot, self.vote.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_START_ROLL:
    creature: int
    loot_slot: int
    item: int
    item_random_suffix: int
    item_random_property_id: int
    countdown_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_START_ROLL:
        # creature: Guid
        creature = await read_int(reader, 8)

        # loot_slot: u32
        loot_slot = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        # item_random_suffix: u32
        item_random_suffix = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # countdown_time: Milliseconds
        countdown_time = await read_int(reader, 4)

        return SMSG_LOOT_START_ROLL(
            creature=creature,
            loot_slot=loot_slot,
            item=item,
            item_random_suffix=item_random_suffix,
            item_random_property_id=item_random_property_id,
            countdown_time=countdown_time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(28 + 2, 0x02A1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIIIII'
        _data.extend([self.creature, self.loot_slot, self.item, self.item_random_suffix, self.item_random_property_id, self.countdown_time])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_ROLL:
    creature: int
    loot_slot: int
    player: int
    item: int
    item_random_suffix: int
    item_random_property_id: int
    roll_number: int
    vote: RollVote
    auto_pass: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_ROLL:
        # creature: Guid
        creature = await read_int(reader, 8)

        # loot_slot: u32
        loot_slot = await read_int(reader, 4)

        # player: Guid
        player = await read_int(reader, 8)

        # item: Item
        item = await read_int(reader, 4)

        # item_random_suffix: u32
        item_random_suffix = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # roll_number: u8
        roll_number = await read_int(reader, 1)

        # vote: RollVote
        vote = RollVote(await read_int(reader, 1))

        # auto_pass: u8
        auto_pass = await read_int(reader, 1)

        return SMSG_LOOT_ROLL(
            creature=creature,
            loot_slot=loot_slot,
            player=player,
            item=item,
            item_random_suffix=item_random_suffix,
            item_random_property_id=item_random_property_id,
            roll_number=roll_number,
            vote=vote,
            auto_pass=auto_pass,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(35 + 2, 0x02A2))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIQIIIBBB'
        _data.extend([self.creature, self.loot_slot, self.player, self.item, self.item_random_suffix, self.item_random_property_id, self.roll_number, self.vote.value, self.auto_pass])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LOOT_MASTER_GIVE:
    loot: int
    slot_id: int
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOOT_MASTER_GIVE:
        # loot: Guid
        loot = await read_int(reader, 8)

        # slot_id: u8
        slot_id = await read_int(reader, 1)

        # player: Guid
        player = await read_int(reader, 8)

        return CMSG_LOOT_MASTER_GIVE(
            loot=loot,
            slot_id=slot_id,
            player=player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(17 + 4, 0x02A3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QBQ'
        _data.extend([self.loot, self.slot_id, self.player])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_MASTER_LIST:
    guids: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_MASTER_LIST:
        # amount_of_players: u8
        amount_of_players = await read_int(reader, 1)

        # guids: Guid[amount_of_players]
        guids = []
        for _ in range(0, amount_of_players):
            guids.append(await read_int(reader, 8))

        return SMSG_LOOT_MASTER_LIST(
            guids=guids,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02A4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'B{len(self.guids)}Q'
        _data.extend([len(self.guids), *self.guids])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + 8 * len(self.guids)


@dataclasses.dataclass
class SMSG_SET_FORCED_REACTIONS:
    reactions: typing.List[ForcedReaction]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_FORCED_REACTIONS:
        # amount_of_reactions: u32
        amount_of_reactions = await read_int(reader, 4)

        # reactions: ForcedReaction[amount_of_reactions]
        reactions = []
        for _ in range(0, amount_of_reactions):
            reactions.append(await ForcedReaction.read(reader))

        return SMSG_SET_FORCED_REACTIONS(
            reactions=reactions,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02A5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.reactions))
        # reactions: ForcedReaction[amount_of_reactions]
        for i in self.reactions:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + 6 * len(self.reactions)


@dataclasses.dataclass
class SMSG_SPELL_FAILED_OTHER:
    caster: int
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELL_FAILED_OTHER:
        # caster: Guid
        caster = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        return SMSG_SPELL_FAILED_OTHER(
            caster=caster,
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x02A6))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.caster, self.id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_REPAIR_ITEM:
    npc: int
    item: int
    from_guild_bank: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REPAIR_ITEM:
        # npc: Guid
        npc = await read_int(reader, 8)

        # item: Guid
        item = await read_int(reader, 8)

        # from_guild_bank: Bool8
        from_guild_bank = await read_bool(reader, 1)

        return CMSG_REPAIR_ITEM(
            npc=npc,
            item=item,
            from_guild_bank=from_guild_bank,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(17 + 4, 0x02A8))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QQB'
        _data.extend([self.npc, self.item, self.from_guild_bank])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CHAT_PLAYER_NOT_FOUND:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAT_PLAYER_NOT_FOUND:
        # name: CString
        name = await read_cstring(reader)

        return SMSG_CHAT_PLAYER_NOT_FOUND(
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02A9))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class MSG_TALENT_WIPE_CONFIRM_Client:
    wiping_npc: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_TALENT_WIPE_CONFIRM_Client:
        # wiping_npc: Guid
        wiping_npc = await read_int(reader, 8)

        return MSG_TALENT_WIPE_CONFIRM_Client(
            wiping_npc=wiping_npc,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02AA))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.wiping_npc)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_TALENT_WIPE_CONFIRM_Server:
    wiping_npc: int
    cost_in_copper: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_TALENT_WIPE_CONFIRM_Server:
        # wiping_npc: Guid
        wiping_npc = await read_int(reader, 8)

        # cost_in_copper: u32
        cost_in_copper = await read_int(reader, 4)

        return MSG_TALENT_WIPE_CONFIRM_Server(
            wiping_npc=wiping_npc,
            cost_in_copper=cost_in_copper,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x02AA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.wiping_npc, self.cost_in_copper])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SUMMON_REQUEST:
    summoner: int
    area: Area
    auto_decline_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SUMMON_REQUEST:
        # summoner: Guid
        summoner = await read_int(reader, 8)

        # area: Area
        area = Area(await read_int(reader, 4))

        # auto_decline_time: Milliseconds
        auto_decline_time = await read_int(reader, 4)

        return SMSG_SUMMON_REQUEST(
            summoner=summoner,
            area=area,
            auto_decline_time=auto_decline_time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x02AB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.summoner, self.area.value, self.auto_decline_time])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SUMMON_RESPONSE:
    summoner: int
    agree: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SUMMON_RESPONSE:
        # summoner: Guid
        summoner = await read_int(reader, 8)

        # agree: Bool8
        agree = await read_bool(reader, 1)

        return CMSG_SUMMON_RESPONSE(
            summoner=summoner,
            agree=agree,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x02AC))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.summoner, self.agree])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MONSTER_MOVE_TRANSPORT:
    guid: int
    transport: int
    spline_point: Vector3d
    spline_id: int
    move_type: MonsterMoveType
    spline_flags: SplineFlag
    duration: int
    splines: MonsterMoveSpline
    target: typing.Optional[int] = None
    angle: typing.Optional[float] = None
    position: typing.Optional[Vector3d] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MONSTER_MOVE_TRANSPORT:
        target = None
        angle = None
        position = None
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # transport: PackedGuid
        transport = await read_packed_guid(reader)

        # spline_point: Vector3d
        spline_point = await Vector3d.read(reader)

        # spline_id: u32
        spline_id = await read_int(reader, 4)

        # move_type: MonsterMoveType
        move_type = MonsterMoveType(await read_int(reader, 1))

        if move_type == MonsterMoveType.FACING_TARGET:
            # target: Guid
            target = await read_int(reader, 8)

        elif move_type == MonsterMoveType.FACING_ANGLE:
            # angle: f32
            angle = await read_float(reader)

        elif move_type == MonsterMoveType.FACING_SPOT:
            # position: Vector3d
            position = await Vector3d.read(reader)

        # spline_flags: SplineFlag
        spline_flags = SplineFlag(await read_int(reader, 4))

        # duration: u32
        duration = await read_int(reader, 4)

        # splines: MonsterMoveSpline
        splines = await MonsterMoveSpline.read(reader)

        return SMSG_MONSTER_MOVE_TRANSPORT(
            guid=guid,
            transport=transport,
            spline_point=spline_point,
            spline_id=spline_id,
            move_type=move_type,
            target=target,
            angle=angle,
            position=position,
            spline_flags=spline_flags,
            duration=duration,
            splines=splines,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02AE))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # transport: PackedGuid
        _fmt, _data = packed_guid_write(self.transport, _fmt, _data)

        # spline_point: Vector3d
        _fmt, _data = self.spline_point.write(_fmt, _data)

        # spline_id: u32
        _fmt += 'I'
        _data.append(self.spline_id)

        # move_type: MonsterMoveType
        _fmt += 'B'
        _data.append(self.move_type.value)

        if self.move_type == MonsterMoveType.FACING_TARGET:
            _fmt += 'Q'
            _data.append(self.target)
        elif self.move_type == MonsterMoveType.FACING_ANGLE:
            _fmt += 'f'
            _data.append(self.angle)
        elif self.move_type == MonsterMoveType.FACING_SPOT:
            # position: Vector3d
            _fmt, _data = self.position.write(_fmt, _data)

        # spline_flags: SplineFlag
        _fmt += 'I'
        _data.append(self.spline_flags.value)

        # duration: u32
        _fmt += 'I'
        _data.append(self.duration)

        # splines: MonsterMoveSpline
        _fmt, _data = self.splines.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 25 + packed_guid_size(self.guid) + packed_guid_size(self.transport) + self.splines.size()

        if self.move_type == MonsterMoveType.FACING_TARGET:
            _size += 8
        elif self.move_type == MonsterMoveType.FACING_ANGLE:
            _size += 4
        elif self.move_type == MonsterMoveType.FACING_SPOT:
            _size += 12

        return _size


@dataclasses.dataclass
class SMSG_PET_BROKEN:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_BROKEN:
        return SMSG_PET_BROKEN()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x02AF))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MOVE_FEATHER_FALL_Server:
    player: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_FEATHER_FALL_Server:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_FEATHER_FALL_Server(
            player=player,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02B0))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_WATER_WALK:
    player: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_WATER_WALK:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_WATER_WALK(
            player=player,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02B1))
        _fmt = "<6s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02B1))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class CMSG_SELF_RES:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SELF_RES:
        return CMSG_SELF_RES()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02B3))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_FEIGN_DEATH_RESISTED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FEIGN_DEATH_RESISTED:
        return SMSG_FEIGN_DEATH_RESISTED()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x02B4))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DUEL_COUNTDOWN:
    time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DUEL_COUNTDOWN:
        # time: Seconds
        time = await read_int(reader, 4)

        return SMSG_DUEL_COUNTDOWN(
            time=time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x02B7))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.time)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AREA_TRIGGER_MESSAGE:
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AREA_TRIGGER_MESSAGE:
        # message: SizedCString
        message = await read_sized_cstring(reader)

        return SMSG_AREA_TRIGGER_MESSAGE(
            message=message,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02B8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.message)}sB'
        _data.extend([len(self.message) + 1, self.message.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + len(self.message)


@dataclasses.dataclass
class CMSG_TOGGLE_HELM:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TOGGLE_HELM:
        return CMSG_TOGGLE_HELM()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02B9))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TOGGLE_CLOAK:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TOGGLE_CLOAK:
        return CMSG_TOGGLE_CLOAK()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02BA))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PLAYER_SKINNED:
    spirit_released: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAYER_SKINNED:
        # spirit_released: Bool8
        spirit_released = await read_bool(reader, 1)

        return SMSG_PLAYER_SKINNED(
            spirit_released=spirit_released,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x02BC))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.spirit_released)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DURABILITY_DAMAGE_DEATH:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DURABILITY_DAMAGE_DEATH:
        return SMSG_DURABILITY_DAMAGE_DEATH()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x02BD))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_ACTIONBAR_TOGGLES:
    action_bar: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_ACTIONBAR_TOGGLES:
        # action_bar: u8
        action_bar = await read_int(reader, 1)

        return CMSG_SET_ACTIONBAR_TOGGLES(
            action_bar=action_bar,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x02BF))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.action_bar)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_PETITION_RENAME:
    petition: int
    new_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_PETITION_RENAME:
        # petition: Guid
        petition = await read_int(reader, 8)

        # new_name: CString
        new_name = await read_cstring(reader)

        return MSG_PETITION_RENAME(
            petition=petition,
            new_name=new_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02C1))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.new_name)}sB'
        _data.extend([self.petition, self.new_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02C1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'Q{len(self.new_name)}sB'
        _data.extend([self.petition, self.new_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.new_name)


@dataclasses.dataclass
class SMSG_INIT_WORLD_STATES:
    map: Map
    area: Area
    states: typing.List[WorldState]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INIT_WORLD_STATES:
        # map: Map
        map = Map(await read_int(reader, 4))

        # area: Area
        area = Area(await read_int(reader, 4))

        # amount_of_states: u16
        amount_of_states = await read_int(reader, 2)

        # states: WorldState[amount_of_states]
        states = []
        for _ in range(0, amount_of_states):
            states.append(await WorldState.read(reader))

        return SMSG_INIT_WORLD_STATES(
            map=map,
            area=area,
            states=states,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02C2))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIH'
        _data.extend([self.map.value, self.area.value, len(self.states)])
        # states: WorldState[amount_of_states]
        for i in self.states:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 10 + 8 * len(self.states)


@dataclasses.dataclass
class SMSG_UPDATE_WORLD_STATE:
    state: WorldState

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_UPDATE_WORLD_STATE:
        # state: WorldState
        state = await WorldState.read(reader)

        return SMSG_UPDATE_WORLD_STATE(
            state=state,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x02C3))
        _fmt = "<4s"
        _data = [_data]

        # state: WorldState
        _fmt, _data = self.state.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ITEM_NAME_QUERY:
    item: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ITEM_NAME_QUERY:
        # item: Item
        item = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_ITEM_NAME_QUERY(
            item=item,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x02C4))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.item, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_NAME_QUERY_RESPONSE:
    item: int
    item_name: str
    inventory_type: InventoryType

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_NAME_QUERY_RESPONSE:
        # item: Item
        item = await read_int(reader, 4)

        # item_name: CString
        item_name = await read_cstring(reader)

        # inventory_type: InventoryType
        inventory_type = InventoryType(await read_int(reader, 1))

        return SMSG_ITEM_NAME_QUERY_RESPONSE(
            item=item,
            item_name=item_name,
            inventory_type=inventory_type,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02C5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.item_name)}sBB'
        _data.extend([self.item, self.item_name.encode('utf-8'), 0, self.inventory_type.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 6 + len(self.item_name)


@dataclasses.dataclass
class SMSG_PET_ACTION_FEEDBACK:
    feedback: PetFeedback

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_ACTION_FEEDBACK:
        # feedback: PetFeedback
        feedback = PetFeedback(await read_int(reader, 1))

        return SMSG_PET_ACTION_FEEDBACK(
            feedback=feedback,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x02C6))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.feedback.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CHAR_RENAME:
    character: int
    new_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHAR_RENAME:
        # character: Guid
        character = await read_int(reader, 8)

        # new_name: CString
        new_name = await read_cstring(reader)

        return CMSG_CHAR_RENAME(
            character=character,
            new_name=new_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02C7))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.new_name)}sB'
        _data.extend([self.character, self.new_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.new_name)


@dataclasses.dataclass
class SMSG_CHAR_RENAME:
    result: WorldResult
    character: typing.Optional[int] = None
    new_name: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAR_RENAME:
        character = None
        new_name = None
        # result: WorldResult
        result = WorldResult(await read_int(reader, 1))

        if result == WorldResult.RESPONSE_SUCCESS:
            # character: Guid
            character = await read_int(reader, 8)

            # new_name: CString
            new_name = await read_cstring(reader)

        return SMSG_CHAR_RENAME(
            result=result,
            character=character,
            new_name=new_name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02C8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        if self.result == WorldResult.RESPONSE_SUCCESS:
            _fmt += f'Q{len(self.new_name)}sB'
            _data.extend([self.character, self.new_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.result == WorldResult.RESPONSE_SUCCESS:
            _size += 9 + len(self.new_name)

        return _size


@dataclasses.dataclass
class CMSG_MOVE_SPLINE_DONE:
    info: MovementInfo
    movement_counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_SPLINE_DONE:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        return CMSG_MOVE_SPLINE_DONE(
            info=info,
            movement_counter=movement_counter,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02C9))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # movement_counter: u32
        _fmt += 'I'
        _data.append(self.movement_counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + self.info.size()


@dataclasses.dataclass
class CMSG_MOVE_FALL_RESET:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_FALL_RESET:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return CMSG_MOVE_FALL_RESET(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02CA))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class SMSG_INSTANCE_SAVE_CREATED:
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INSTANCE_SAVE_CREATED:
        # unknown: u32
        unknown = await read_int(reader, 4)

        return SMSG_INSTANCE_SAVE_CREATED(
            unknown=unknown,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x02CB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.unknown)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_RAID_INSTANCE_INFO:
    raid_infos: typing.List[RaidInfo]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RAID_INSTANCE_INFO:
        # amount_of_raid_infos: u32
        amount_of_raid_infos = await read_int(reader, 4)

        # raid_infos: RaidInfo[amount_of_raid_infos]
        raid_infos = []
        for _ in range(0, amount_of_raid_infos):
            raid_infos.append(await RaidInfo.read(reader))

        return SMSG_RAID_INSTANCE_INFO(
            raid_infos=raid_infos,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02CC))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.raid_infos))
        # raid_infos: RaidInfo[amount_of_raid_infos]
        for i in self.raid_infos:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + 16 * len(self.raid_infos)


@dataclasses.dataclass
class CMSG_REQUEST_RAID_INFO:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REQUEST_RAID_INFO:
        return CMSG_REQUEST_RAID_INFO()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02CD))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MOVE_TIME_SKIPPED:
    guid: int
    lag: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_TIME_SKIPPED:
        # guid: Guid
        guid = await read_int(reader, 8)

        # lag: u32
        lag = await read_int(reader, 4)

        return CMSG_MOVE_TIME_SKIPPED(
            guid=guid,
            lag=lag,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x02CE))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.lag])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MOVE_FEATHER_FALL_ACK:
    guid: int
    movement_counter: int
    info: MovementInfo
    apply: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_FEATHER_FALL_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # apply: u32
        apply = await read_int(reader, 4)

        return CMSG_MOVE_FEATHER_FALL_ACK(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
            apply=apply,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02CF))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.movement_counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # apply: u32
        _fmt += 'I'
        _data.append(self.apply)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class CMSG_MOVE_WATER_WALK_ACK:
    guid: int
    movement_counter: int
    info: MovementInfo
    apply: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_WATER_WALK_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # apply: u32
        apply = await read_int(reader, 4)

        return CMSG_MOVE_WATER_WALK_ACK(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
            apply=apply,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02D0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.movement_counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # apply: u32
        _fmt += 'I'
        _data.append(self.apply)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class CMSG_MOVE_NOT_ACTIVE_MOVER:
    old_mover: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_NOT_ACTIVE_MOVER:
        # old_mover: Guid
        old_mover = await read_int(reader, 8)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return CMSG_MOVE_NOT_ACTIVE_MOVER(
            old_mover=old_mover,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02D1))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.old_mover)
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + self.info.size()


@dataclasses.dataclass
class SMSG_PLAY_SOUND:
    sound_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAY_SOUND:
        # sound_id: u32
        sound_id = await read_int(reader, 4)

        return SMSG_PLAY_SOUND(
            sound_id=sound_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x02D2))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.sound_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BATTLEFIELD_STATUS:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BATTLEFIELD_STATUS:
        return CMSG_BATTLEFIELD_STATUS()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02D3))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BATTLEFIELD_STATUS:
    queue_slot: int
    arena_type: ArenaType
    unknown1: int
    battleground_type: BattlegroundType
    unknown2: int
    client_instance_id: int
    rated: bool
    status_id: StatusId
    average_wait_time_in_ms: typing.Optional[int] = None
    time_in_queue_in_ms: typing.Optional[int] = None
    time_to_remove_in_queue_in_ms: typing.Optional[int] = None
    time_to_bg_autoleave_in_ms: typing.Optional[int] = None
    time_to_bg_start_in_ms: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BATTLEFIELD_STATUS:
        average_wait_time_in_ms = None
        time_in_queue_in_ms = None
        time_to_remove_in_queue_in_ms = None
        time_to_bg_autoleave_in_ms = None
        time_to_bg_start_in_ms = None
        # queue_slot: u32
        queue_slot = await read_int(reader, 4)

        # arena_type: ArenaType
        arena_type = ArenaType(await read_int(reader, 1))

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # battleground_type: BattlegroundType
        battleground_type = BattlegroundType(await read_int(reader, 4))

        # unknown2: u16
        unknown2 = await read_int(reader, 2)

        # client_instance_id: u32
        client_instance_id = await read_int(reader, 4)

        # rated: Bool8
        rated = await read_bool(reader, 1)

        # status_id: StatusId
        status_id = StatusId(await read_int(reader, 1))

        if status_id == StatusId.WAIT_QUEUE:
            # average_wait_time_in_ms: u32
            average_wait_time_in_ms = await read_int(reader, 4)

            # time_in_queue_in_ms: u32
            time_in_queue_in_ms = await read_int(reader, 4)

        elif status_id == StatusId.WAIT_JOIN:
            # time_to_remove_in_queue_in_ms: u32
            time_to_remove_in_queue_in_ms = await read_int(reader, 4)

        elif status_id == StatusId.IN_PROGRESS:
            # time_to_bg_autoleave_in_ms: u32
            time_to_bg_autoleave_in_ms = await read_int(reader, 4)

            # time_to_bg_start_in_ms: u32
            time_to_bg_start_in_ms = await read_int(reader, 4)

        return SMSG_BATTLEFIELD_STATUS(
            queue_slot=queue_slot,
            arena_type=arena_type,
            unknown1=unknown1,
            battleground_type=battleground_type,
            unknown2=unknown2,
            client_instance_id=client_instance_id,
            rated=rated,
            status_id=status_id,
            average_wait_time_in_ms=average_wait_time_in_ms,
            time_in_queue_in_ms=time_in_queue_in_ms,
            time_to_remove_in_queue_in_ms=time_to_remove_in_queue_in_ms,
            time_to_bg_autoleave_in_ms=time_to_bg_autoleave_in_ms,
            time_to_bg_start_in_ms=time_to_bg_start_in_ms,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02D4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IBBIHIBB'
        _data.extend([self.queue_slot, self.arena_type.value, self.unknown1, self.battleground_type.value, self.unknown2, self.client_instance_id, self.rated, self.status_id.value])
        if self.status_id == StatusId.WAIT_QUEUE:
            _fmt += 'II'
            _data.extend([self.average_wait_time_in_ms, self.time_in_queue_in_ms])
        elif self.status_id == StatusId.WAIT_JOIN:
            _fmt += 'I'
            _data.append(self.time_to_remove_in_queue_in_ms)
        elif self.status_id == StatusId.IN_PROGRESS:
            _fmt += 'II'
            _data.extend([self.time_to_bg_autoleave_in_ms, self.time_to_bg_start_in_ms])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 18

        if self.status_id == StatusId.WAIT_QUEUE:
            _size += 8
        elif self.status_id == StatusId.WAIT_JOIN:
            _size += 4
        elif self.status_id == StatusId.IN_PROGRESS:
            _size += 8

        return _size


@dataclasses.dataclass
class CMSG_BATTLEFIELD_PORT:
    arena_type: int
    unknown1: int
    bg_type_id: int
    unknown2: int
    action: BattlefieldPortAction

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BATTLEFIELD_PORT:
        # arena_type: u8
        arena_type = await read_int(reader, 1)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # bg_type_id: u32
        bg_type_id = await read_int(reader, 4)

        # unknown2: u16
        unknown2 = await read_int(reader, 2)

        # action: BattlefieldPortAction
        action = BattlefieldPortAction(await read_int(reader, 1))

        return CMSG_BATTLEFIELD_PORT(
            arena_type=arena_type,
            unknown1=unknown1,
            bg_type_id=bg_type_id,
            unknown2=unknown2,
            action=action,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x02D5))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBIHB'
        _data.extend([self.arena_type, self.unknown1, self.bg_type_id, self.unknown2, self.action.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_INSPECT_HONOR_STATS_Client:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_INSPECT_HONOR_STATS_Client:
        # guid: Guid
        guid = await read_int(reader, 8)

        return MSG_INSPECT_HONOR_STATS_Client(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02D6))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_INSPECT_HONOR_STATS_Server:
    guid: int
    amount_of_honor: int
    kills: int
    honor_today: int
    honor_yesterday: int
    lifetime_honorable_kills: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_INSPECT_HONOR_STATS_Server:
        # guid: Guid
        guid = await read_int(reader, 8)

        # amount_of_honor: u8
        amount_of_honor = await read_int(reader, 1)

        # kills: u32
        kills = await read_int(reader, 4)

        # honor_today: u32
        honor_today = await read_int(reader, 4)

        # honor_yesterday: u32
        honor_yesterday = await read_int(reader, 4)

        # lifetime_honorable_kills: u32
        lifetime_honorable_kills = await read_int(reader, 4)

        return MSG_INSPECT_HONOR_STATS_Server(
            guid=guid,
            amount_of_honor=amount_of_honor,
            kills=kills,
            honor_today=honor_today,
            honor_yesterday=honor_yesterday,
            lifetime_honorable_kills=lifetime_honorable_kills,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(25 + 2, 0x02D6))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QBIIII'
        _data.extend([self.guid, self.amount_of_honor, self.kills, self.honor_today, self.honor_yesterday, self.lifetime_honorable_kills])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BATTLEMASTER_HELLO:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BATTLEMASTER_HELLO:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_BATTLEMASTER_HELLO(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02D7))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_FORCE_WALK_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_WALK_SPEED_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_WALK_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02DA))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_WALK_SPEED_CHANGE_ACK:
    guid: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_WALK_SPEED_CHANGE_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_WALK_SPEED_CHANGE_ACK(
            guid=guid,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02DB))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_SWIM_BACK_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_SWIM_BACK_SPEED_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_SWIM_BACK_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02DC))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK:
    guid: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK(
            guid=guid,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02DD))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_TURN_RATE_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_TURN_RATE_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_TURN_RATE_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02DE))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_TURN_RATE_CHANGE_ACK:
    guid: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_TURN_RATE_CHANGE_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_TURN_RATE_CHANGE_ACK(
            guid=guid,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02DF))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class MSG_PVP_LOG_DATA_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_PVP_LOG_DATA_Client:
        return MSG_PVP_LOG_DATA_Client()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02E0))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LEAVE_BATTLEFIELD:
    unknown1: int
    unknown2: int
    map: Map
    unknown3: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LEAVE_BATTLEFIELD:
        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # unknown2: u8
        unknown2 = await read_int(reader, 1)

        # map: Map
        map = Map(await read_int(reader, 4))

        # unknown3: u16
        unknown3 = await read_int(reader, 2)

        return CMSG_LEAVE_BATTLEFIELD(
            unknown1=unknown1,
            unknown2=unknown2,
            map=map,
            unknown3=unknown3,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02E1))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBIH'
        _data.extend([self.unknown1, self.unknown2, self.map.value, self.unknown3])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AREA_SPIRIT_HEALER_QUERY:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AREA_SPIRIT_HEALER_QUERY:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_AREA_SPIRIT_HEALER_QUERY(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02E2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AREA_SPIRIT_HEALER_QUEUE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AREA_SPIRIT_HEALER_QUEUE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_AREA_SPIRIT_HEALER_QUEUE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02E3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AREA_SPIRIT_HEALER_TIME:
    guid: int
    next_resurrect_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AREA_SPIRIT_HEALER_TIME:
        # guid: Guid
        guid = await read_int(reader, 8)

        # next_resurrect_time: u32
        next_resurrect_time = await read_int(reader, 4)

        return SMSG_AREA_SPIRIT_HEALER_TIME(
            guid=guid,
            next_resurrect_time=next_resurrect_time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x02E4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.next_resurrect_time])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_WARDEN_DATA:
    encrypted_data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_WARDEN_DATA:
        _size = 0

        # encrypted_data: u8[-]
        encrypted_data = []
        while _size < body_size:
            encrypted_data.append(await read_int(reader, 1))
            _size += 1

        return SMSG_WARDEN_DATA(
            encrypted_data=encrypted_data,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02E6))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.encrypted_data)}B'
        _data.extend([*self.encrypted_data])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + 1 * len(self.encrypted_data)


@dataclasses.dataclass
class CMSG_WARDEN_DATA:
    encrypted_data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_WARDEN_DATA:
        _size = 0

        # encrypted_data: u8[-]
        encrypted_data = []
        while _size < body_size:
            encrypted_data.append(await read_int(reader, 1))
            _size += 1

        return CMSG_WARDEN_DATA(
            encrypted_data=encrypted_data,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02E7))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.encrypted_data)}B'
        _data.extend([*self.encrypted_data])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + 1 * len(self.encrypted_data)


@dataclasses.dataclass
class SMSG_GROUP_JOINED_BATTLEGROUND:
    id: BgTypeId

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GROUP_JOINED_BATTLEGROUND:
        # id: BgTypeId
        id = BgTypeId(await read_int(reader, 4))

        return SMSG_GROUP_JOINED_BATTLEGROUND(
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x02E8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.id.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_BATTLEGROUND_PLAYER_POSITIONS_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_BATTLEGROUND_PLAYER_POSITIONS_Client:
        return MSG_BATTLEGROUND_PLAYER_POSITIONS_Client()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02E9))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_BATTLEGROUND_PLAYER_POSITIONS_Server:
    teammates: typing.List[BattlegroundPlayerPosition]
    carriers: typing.List[BattlegroundPlayerPosition]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_BATTLEGROUND_PLAYER_POSITIONS_Server:
        # amount_of_teammates: u32
        amount_of_teammates = await read_int(reader, 4)

        # teammates: BattlegroundPlayerPosition[amount_of_teammates]
        teammates = []
        for _ in range(0, amount_of_teammates):
            teammates.append(await BattlegroundPlayerPosition.read(reader))

        # amount_of_carriers: u8
        amount_of_carriers = await read_int(reader, 1)

        # carriers: BattlegroundPlayerPosition[amount_of_carriers]
        carriers = []
        for _ in range(0, amount_of_carriers):
            carriers.append(await BattlegroundPlayerPosition.read(reader))

        return MSG_BATTLEGROUND_PLAYER_POSITIONS_Server(
            teammates=teammates,
            carriers=carriers,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02E9))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.teammates))
        # teammates: BattlegroundPlayerPosition[amount_of_teammates]
        for i in self.teammates:
            _fmt, _data = i.write(_fmt, _data)

        # amount_of_carriers: u8
        _fmt += 'B'
        _data.append(len(self.carriers))

        # carriers: BattlegroundPlayerPosition[amount_of_carriers]
        for i in self.carriers:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + 16 * len(self.teammates) + 16 * len(self.carriers)


@dataclasses.dataclass
class CMSG_PET_STOP_ATTACK:
    pet: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_STOP_ATTACK:
        # pet: Guid
        pet = await read_int(reader, 8)

        return CMSG_PET_STOP_ATTACK(
            pet=pet,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02EA))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.pet)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BINDER_CONFIRM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BINDER_CONFIRM:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_BINDER_CONFIRM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x02EB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BATTLEGROUND_PLAYER_JOINED:
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BATTLEGROUND_PLAYER_JOINED:
        # player: Guid
        player = await read_int(reader, 8)

        return SMSG_BATTLEGROUND_PLAYER_JOINED(
            player=player,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x02EC))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.player)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BATTLEGROUND_PLAYER_LEFT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BATTLEGROUND_PLAYER_LEFT:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_BATTLEGROUND_PLAYER_LEFT(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x02ED))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BATTLEMASTER_JOIN:
    guid: int
    map: Map
    instance_id: int
    join_as_group: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BATTLEMASTER_JOIN:
        # guid: Guid
        guid = await read_int(reader, 8)

        # map: Map
        map = Map(await read_int(reader, 4))

        # instance_id: u32
        instance_id = await read_int(reader, 4)

        # join_as_group: Bool8
        join_as_group = await read_bool(reader, 1)

        return CMSG_BATTLEMASTER_JOIN(
            guid=guid,
            map=map,
            instance_id=instance_id,
            join_as_group=join_as_group,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(17 + 4, 0x02EE))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIIB'
        _data.extend([self.guid, self.map.value, self.instance_id, self.join_as_group])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ADDON_INFO:
    addons: AddonArray

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ADDON_INFO:
        # addons: AddonArray
        addons = await CacheMask.read(reader)

        # number_of_banned_addons: u32
        _number_of_banned_addons = await read_int(reader, 4)

        return SMSG_ADDON_INFO(
            addons=addons,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02EF))
        _fmt = "<4s"
        _data = [_data]

        # addons: AddonArray
        _fmt, _data = self.addons.write(_fmt, _data)

        # number_of_banned_addons: u32
        _fmt += 'I'
        _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + self.addons.size()


@dataclasses.dataclass
class CMSG_PET_UNLEARN:
    pet: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_UNLEARN:
        # pet: Guid
        pet = await read_int(reader, 8)

        return CMSG_PET_UNLEARN(
            pet=pet,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02F0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.pet)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PET_UNLEARN_CONFIRM:
    pet: int
    talent_reset_cost: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_UNLEARN_CONFIRM:
        # pet: Guid
        pet = await read_int(reader, 8)

        # talent_reset_cost: u32
        talent_reset_cost = await read_int(reader, 4)

        return SMSG_PET_UNLEARN_CONFIRM(
            pet=pet,
            talent_reset_cost=talent_reset_cost,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x02F1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.pet, self.talent_reset_cost])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PARTY_MEMBER_STATS_FULL:
    guid: int
    mask: GroupUpdateFlags
    status: typing.Optional[GroupMemberOnlineStatus] = None
    current_health: typing.Optional[int] = None
    max_health: typing.Optional[int] = None
    power: typing.Optional[Power] = None
    current_power: typing.Optional[int] = None
    max_power: typing.Optional[int] = None
    level: typing.Optional[int] = None
    area: typing.Optional[Area] = None
    position_x: typing.Optional[int] = None
    position_y: typing.Optional[int] = None
    auras: typing.Optional[AuraMask] = None
    pet: typing.Optional[int] = None
    pet_name: typing.Optional[str] = None
    pet_display_id: typing.Optional[int] = None
    pet_current_health: typing.Optional[int] = None
    pet_max_health: typing.Optional[int] = None
    pet_power_type: typing.Optional[Power] = None
    pet_current_power: typing.Optional[int] = None
    pet_max_power: typing.Optional[int] = None
    pet_auras: typing.Optional[AuraMask] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PARTY_MEMBER_STATS_FULL:
        status = None
        current_health = None
        max_health = None
        power = None
        current_power = None
        max_power = None
        level = None
        area = None
        position_x = None
        position_y = None
        auras = None
        pet = None
        pet_name = None
        pet_display_id = None
        pet_current_health = None
        pet_max_health = None
        pet_power_type = None
        pet_current_power = None
        pet_max_power = None
        pet_auras = None
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # mask: GroupUpdateFlags
        mask = GroupUpdateFlags(await read_int(reader, 4))

        if GroupUpdateFlags.STATUS in mask:
            # status: GroupMemberOnlineStatus
            status = GroupMemberOnlineStatus(await read_int(reader, 1))

        if GroupUpdateFlags.CUR_HP in mask:
            # current_health: u16
            current_health = await read_int(reader, 2)

        if GroupUpdateFlags.MAX_HP in mask:
            # max_health: u16
            max_health = await read_int(reader, 2)

        if GroupUpdateFlags.POWER_TYPE in mask:
            # power: Power
            power = Power(await read_int(reader, 1))

        if GroupUpdateFlags.CUR_POWER in mask:
            # current_power: u16
            current_power = await read_int(reader, 2)

        if GroupUpdateFlags.MAX_POWER in mask:
            # max_power: u16
            max_power = await read_int(reader, 2)

        if GroupUpdateFlags.LEVEL in mask:
            # level: Level16
            level = await read_int(reader, 2)

        if GroupUpdateFlags.ZONE in mask:
            # area: Area
            area = Area(await read_int(reader, 4))

        if GroupUpdateFlags.POSITION in mask:
            # position_x: u16
            position_x = await read_int(reader, 2)

            # position_y: u16
            position_y = await read_int(reader, 2)

        if GroupUpdateFlags.AURAS in mask:
            # auras: AuraMask
            auras = await AuraMask.read(reader)

        if GroupUpdateFlags.PET_GUID in mask:
            # pet: Guid
            pet = await read_int(reader, 8)

        if GroupUpdateFlags.PET_NAME in mask:
            # pet_name: CString
            pet_name = await read_cstring(reader)

        if GroupUpdateFlags.PET_MODEL_ID in mask:
            # pet_display_id: u16
            pet_display_id = await read_int(reader, 2)

        if GroupUpdateFlags.PET_CUR_HP in mask:
            # pet_current_health: u16
            pet_current_health = await read_int(reader, 2)

        if GroupUpdateFlags.PET_MAX_HP in mask:
            # pet_max_health: u16
            pet_max_health = await read_int(reader, 2)

        if GroupUpdateFlags.PET_POWER_TYPE in mask:
            # pet_power_type: Power
            pet_power_type = Power(await read_int(reader, 1))

        if GroupUpdateFlags.PET_CUR_POWER in mask:
            # pet_current_power: u16
            pet_current_power = await read_int(reader, 2)

        if GroupUpdateFlags.PET_MAX_POWER in mask:
            # pet_max_power: u16
            pet_max_power = await read_int(reader, 2)

        if GroupUpdateFlags.PET_AURAS in mask:
            # pet_auras: AuraMask
            pet_auras = await AuraMask.read(reader)

        return SMSG_PARTY_MEMBER_STATS_FULL(
            guid=guid,
            mask=mask,
            status=status,
            current_health=current_health,
            max_health=max_health,
            power=power,
            current_power=current_power,
            max_power=max_power,
            level=level,
            area=area,
            position_x=position_x,
            position_y=position_y,
            auras=auras,
            pet=pet,
            pet_name=pet_name,
            pet_display_id=pet_display_id,
            pet_current_health=pet_current_health,
            pet_max_health=pet_max_health,
            pet_power_type=pet_power_type,
            pet_current_power=pet_current_power,
            pet_max_power=pet_max_power,
            pet_auras=pet_auras,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02F2))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # mask: GroupUpdateFlags
        _fmt += 'I'
        _data.append(self.mask.value)

        if GroupUpdateFlags.STATUS in self.mask:
            _fmt += 'B'
            _data.append(self.status.value)
        if GroupUpdateFlags.CUR_HP in self.mask:
            _fmt += 'H'
            _data.append(self.current_health)
        if GroupUpdateFlags.MAX_HP in self.mask:
            _fmt += 'H'
            _data.append(self.max_health)
        if GroupUpdateFlags.POWER_TYPE in self.mask:
            _fmt += 'B'
            _data.append(self.power.value)
        if GroupUpdateFlags.CUR_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.current_power)
        if GroupUpdateFlags.MAX_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.max_power)
        if GroupUpdateFlags.LEVEL in self.mask:
            _fmt += 'H'
            _data.append(self.level)
        if GroupUpdateFlags.ZONE in self.mask:
            _fmt += 'I'
            _data.append(self.area.value)
        if GroupUpdateFlags.POSITION in self.mask:
            _fmt += 'HH'
            _data.extend([self.position_x, self.position_y])
        if GroupUpdateFlags.AURAS in self.mask:
            # auras: AuraMask
            _fmt, _data = self.auras.write(_fmt, _data)

        if GroupUpdateFlags.PET_GUID in self.mask:
            _fmt += 'Q'
            _data.append(self.pet)
        if GroupUpdateFlags.PET_NAME in self.mask:
            _fmt += f'{len(self.pet_name)}sB'
            _data.extend([self.pet_name.encode('utf-8'), 0])
        if GroupUpdateFlags.PET_MODEL_ID in self.mask:
            _fmt += 'H'
            _data.append(self.pet_display_id)
        if GroupUpdateFlags.PET_CUR_HP in self.mask:
            _fmt += 'H'
            _data.append(self.pet_current_health)
        if GroupUpdateFlags.PET_MAX_HP in self.mask:
            _fmt += 'H'
            _data.append(self.pet_max_health)
        if GroupUpdateFlags.PET_POWER_TYPE in self.mask:
            _fmt += 'B'
            _data.append(self.pet_power_type.value)
        if GroupUpdateFlags.PET_CUR_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.pet_current_power)
        if GroupUpdateFlags.PET_MAX_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.pet_max_power)
        if GroupUpdateFlags.PET_AURAS in self.mask:
            # pet_auras: AuraMask
            _fmt, _data = self.pet_auras.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4 + packed_guid_size(self.guid)

        if GroupUpdateFlags.STATUS in self.mask:
            _size += 1

        if GroupUpdateFlags.CUR_HP in self.mask:
            _size += 2

        if GroupUpdateFlags.MAX_HP in self.mask:
            _size += 2

        if GroupUpdateFlags.POWER_TYPE in self.mask:
            _size += 1

        if GroupUpdateFlags.CUR_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.MAX_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.LEVEL in self.mask:
            _size += 2

        if GroupUpdateFlags.ZONE in self.mask:
            _size += 4

        if GroupUpdateFlags.POSITION in self.mask:
            _size += 4

        if GroupUpdateFlags.AURAS in self.mask:
            _size += 0 + self.auras.size()

        if GroupUpdateFlags.PET_GUID in self.mask:
            _size += 8

        if GroupUpdateFlags.PET_NAME in self.mask:
            _size += 1 + len(self.pet_name)

        if GroupUpdateFlags.PET_MODEL_ID in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_CUR_HP in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_MAX_HP in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_POWER_TYPE in self.mask:
            _size += 1

        if GroupUpdateFlags.PET_CUR_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_MAX_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_AURAS in self.mask:
            _size += 0 + self.pet_auras.size()

        return _size


@dataclasses.dataclass
class CMSG_PET_SPELL_AUTOCAST:
    guid: int
    id: int
    autocast_enabled: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_SPELL_AUTOCAST:
        # guid: Guid
        guid = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        # autocast_enabled: Bool8
        autocast_enabled = await read_bool(reader, 1)

        return CMSG_PET_SPELL_AUTOCAST(
            guid=guid,
            id=id,
            autocast_enabled=autocast_enabled,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(13 + 4, 0x02F3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIB'
        _data.extend([self.guid, self.id, self.autocast_enabled])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_WEATHER:
    weather_type: WeatherType
    grade: float
    change: WeatherChangeType

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_WEATHER:
        # weather_type: WeatherType
        weather_type = WeatherType(await read_int(reader, 4))

        # grade: f32
        grade = await read_float(reader)

        # change: WeatherChangeType
        change = WeatherChangeType(await read_int(reader, 1))

        return SMSG_WEATHER(
            weather_type=weather_type,
            grade=grade,
            change=change,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x02F4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IfB'
        _data.extend([self.weather_type.value, self.grade, self.change.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_RAID_INSTANCE_MESSAGE:
    message_type: RaidInstanceMessage
    map: Map
    time_left: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RAID_INSTANCE_MESSAGE:
        # message_type: RaidInstanceMessage
        message_type = RaidInstanceMessage(await read_int(reader, 4))

        # map: Map
        map = Map(await read_int(reader, 4))

        # time_left: u32
        time_left = await read_int(reader, 4)

        return SMSG_RAID_INSTANCE_MESSAGE(
            message_type=message_type,
            map=map,
            time_left=time_left,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x02FA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'III'
        _data.extend([self.message_type.value, self.map.value, self.time_left])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_INFO_TEXT:
    guild_info: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_INFO_TEXT:
        # guild_info: CString
        guild_info = await read_cstring(reader)

        return CMSG_GUILD_INFO_TEXT(
            guild_info=guild_info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02FC))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.guild_info)}sB'
        _data.extend([self.guild_info.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.guild_info)


@dataclasses.dataclass
class SMSG_CHAT_RESTRICTED:
    restriction: ChatRestrictionType

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAT_RESTRICTED:
        # restriction: ChatRestrictionType
        restriction = ChatRestrictionType(await read_int(reader, 1))

        return SMSG_CHAT_RESTRICTED(
            restriction=restriction,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x02FD))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.restriction.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPLINE_SET_RUN_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_RUN_SPEED:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_RUN_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02FE))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_RUN_BACK_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_RUN_BACK_SPEED:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_RUN_BACK_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02FF))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_SWIM_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_SWIM_SPEED:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_SWIM_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0300))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_WALK_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_WALK_SPEED:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_WALK_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0301))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_SWIM_BACK_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_SWIM_BACK_SPEED:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_SWIM_BACK_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0302))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_TURN_RATE:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_TURN_RATE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_TURN_RATE(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0303))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_UNROOT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_UNROOT:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_UNROOT(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0304))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_FEATHER_FALL:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_FEATHER_FALL:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_FEATHER_FALL(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0305))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_NORMAL_FALL:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_NORMAL_FALL:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_NORMAL_FALL(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0306))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_SET_HOVER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_SET_HOVER:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_SET_HOVER(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0307))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_UNSET_HOVER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_UNSET_HOVER:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_UNSET_HOVER(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0308))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_WATER_WALK:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_WATER_WALK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_WATER_WALK(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0309))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_LAND_WALK:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_LAND_WALK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_LAND_WALK(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x030A))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_START_SWIM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_START_SWIM:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_START_SWIM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x030B))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_STOP_SWIM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_STOP_SWIM:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_STOP_SWIM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x030C))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_SET_RUN_MODE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_SET_RUN_MODE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_SET_RUN_MODE(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x030D))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_SET_WALK_MODE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_SET_WALK_MODE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_SET_WALK_MODE(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x030E))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_ACTIVATETAXIEXPRESS:
    guid: int
    total_cost: int
    nodes: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ACTIVATETAXIEXPRESS:
        # guid: Guid
        guid = await read_int(reader, 8)

        # total_cost: u32
        total_cost = await read_int(reader, 4)

        # node_count: u32
        node_count = await read_int(reader, 4)

        # nodes: u32[node_count]
        nodes = []
        for _ in range(0, node_count):
            nodes.append(await read_int(reader, 4))

        return CMSG_ACTIVATETAXIEXPRESS(
            guid=guid,
            total_cost=total_cost,
            nodes=nodes,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0312))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'QII{len(self.nodes)}I'
        _data.extend([self.guid, self.total_cost, len(self.nodes), *self.nodes])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + 4 * len(self.nodes)


@dataclasses.dataclass
class CMSG_SET_FACTION_INACTIVE:
    faction: Faction
    inactive: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_FACTION_INACTIVE:
        # faction: Faction
        faction = Faction(await read_int(reader, 2))

        # inactive: Bool8
        inactive = await read_bool(reader, 1)

        return CMSG_SET_FACTION_INACTIVE(
            faction=faction,
            inactive=inactive,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(3 + 4, 0x0317))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'HB'
        _data.extend([self.faction.value, self.inactive])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_WATCHED_FACTION:
    faction: Faction

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_WATCHED_FACTION:
        # faction: Faction
        faction = Faction(await read_int(reader, 2))

        return CMSG_SET_WATCHED_FACTION(
            faction=faction,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x0318))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'H'
        _data.append(self.faction.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MOVE_TIME_SKIPPED_Server:
    player: int
    time_skipped: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_TIME_SKIPPED_Server:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # time_skipped: u32
        time_skipped = await read_int(reader, 4)

        return MSG_MOVE_TIME_SKIPPED_Server(
            player=player,
            time_skipped=time_skipped,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0319))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # time_skipped: u32
        _fmt += 'I'
        _data.append(self.time_skipped)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.player)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_ROOT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_ROOT:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_SPLINE_MOVE_ROOT(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x031A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_INVALIDATE_PLAYER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INVALIDATE_PLAYER:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_INVALIDATE_PLAYER(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x031C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_RESET_INSTANCES:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_RESET_INSTANCES:
        return CMSG_RESET_INSTANCES()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x031D))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_INSTANCE_RESET:
    map: Map

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INSTANCE_RESET:
        # map: Map
        map = Map(await read_int(reader, 4))

        return SMSG_INSTANCE_RESET(
            map=map,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x031E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_INSTANCE_RESET_FAILED:
    reason: InstanceResetFailedReason
    map: Map

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INSTANCE_RESET_FAILED:
        # reason: InstanceResetFailedReason
        reason = InstanceResetFailedReason(await read_int(reader, 4))

        # map: Map
        map = Map(await read_int(reader, 4))

        return SMSG_INSTANCE_RESET_FAILED(
            reason=reason,
            map=map,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x031F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.reason.value, self.map.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_UPDATE_LAST_INSTANCE:
    map: Map

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_UPDATE_LAST_INSTANCE:
        # map: Map
        map = Map(await read_int(reader, 4))

        return SMSG_UPDATE_LAST_INSTANCE(
            map=map,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0320))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_RAID_TARGET_UPDATE_Client:
    target_index: RaidTargetIndex
    target: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RAID_TARGET_UPDATE_Client:
        target = None
        # target_index: RaidTargetIndex
        target_index = RaidTargetIndex(await read_int(reader, 1))

        if target_index in {RaidTargetIndex.UNKNOWN0, RaidTargetIndex.UNKNOWN1, RaidTargetIndex.UNKNOWN2, RaidTargetIndex.UNKNOWN3, RaidTargetIndex.UNKNOWN4, RaidTargetIndex.UNKNOWN5, RaidTargetIndex.UNKNOWN6, RaidTargetIndex.UNKNOWN7, RaidTargetIndex.UNKNOWN8}:
            # target: Guid
            target = await read_int(reader, 8)

        return MSG_RAID_TARGET_UPDATE_Client(
            target_index=target_index,
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0321))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.target_index.value)
        if self.target_index in {RaidTargetIndex.UNKNOWN0, RaidTargetIndex.UNKNOWN1, RaidTargetIndex.UNKNOWN2, RaidTargetIndex.UNKNOWN3, RaidTargetIndex.UNKNOWN4, RaidTargetIndex.UNKNOWN5, RaidTargetIndex.UNKNOWN6, RaidTargetIndex.UNKNOWN7, RaidTargetIndex.UNKNOWN8}:
            _fmt += 'Q'
            _data.append(self.target)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.target_index in {RaidTargetIndex.UNKNOWN0, RaidTargetIndex.UNKNOWN1, RaidTargetIndex.UNKNOWN2, RaidTargetIndex.UNKNOWN3, RaidTargetIndex.UNKNOWN4, RaidTargetIndex.UNKNOWN5, RaidTargetIndex.UNKNOWN6, RaidTargetIndex.UNKNOWN7, RaidTargetIndex.UNKNOWN8}:
            _size += 8

        return _size


@dataclasses.dataclass
class MSG_RAID_TARGET_UPDATE_Server:
    update_type: RaidTargetUpdateType
    raid_targets: typing.Optional[typing.List[RaidTargetUpdate]] = None
    raid_target: typing.Optional[RaidTargetUpdate] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RAID_TARGET_UPDATE_Server:
        raid_targets = None
        raid_target = None
        # update_type: RaidTargetUpdateType
        update_type = RaidTargetUpdateType(await read_int(reader, 1))

        if update_type == RaidTargetUpdateType.FULL:
            # raid_targets: RaidTargetUpdate[8]
            raid_targets = []
            for _ in range(0, 8):
                raid_targets.append(await RaidTargetUpdate.read(reader))

        elif update_type == RaidTargetUpdateType.PARTIAL:
            # raid_target: RaidTargetUpdate
            raid_target = await RaidTargetUpdate.read(reader)

        return MSG_RAID_TARGET_UPDATE_Server(
            update_type=update_type,
            raid_targets=raid_targets,
            raid_target=raid_target,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0321))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.update_type.value)
        if self.update_type == RaidTargetUpdateType.FULL:
            # raid_targets: RaidTargetUpdate[8]
            for i in self.raid_targets:
                _fmt, _data = i.write(_fmt, _data)

        elif self.update_type == RaidTargetUpdateType.PARTIAL:
            # raid_target: RaidTargetUpdate
            _fmt, _data = self.raid_target.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.update_type == RaidTargetUpdateType.FULL:
            _size += 72
        elif self.update_type == RaidTargetUpdateType.PARTIAL:
            _size += 9

        return _size


@dataclasses.dataclass
class MSG_RAID_READY_CHECK_Client:
    state: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RAID_READY_CHECK_Client:
        state = None
        _size = 0

        # answer: optional
        if _size < body_size:
            # state: u8
            state = await read_int(reader, 1)
            _size += 1

        return MSG_RAID_READY_CHECK_Client(
            state=state,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0322))
        _fmt = "<6s"
        _data = [_data]

        # answer: optional
        if self.state is not None:
            _fmt += 'B'
            _data.append(self.state)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 0

        # answer: optional
        if self.state is not None:
            _size += 1

        return _size


@dataclasses.dataclass
class MSG_RAID_READY_CHECK_Server:
    guid: typing.Optional[int] = None
    state: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RAID_READY_CHECK_Server:
        guid = None
        state = None
        _size = 0

        # state_check: optional
        if _size < body_size:
            # guid: Guid
            guid = await read_int(reader, 8)
            _size += 8

            # state: u8
            state = await read_int(reader, 1)
            _size += 1

        return MSG_RAID_READY_CHECK_Server(
            guid=guid,
            state=state,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0322))
        _fmt = "<4s"
        _data = [_data]

        # state_check: optional
        if self.guid is not None and self.state is not None:
            _fmt += 'QB'
            _data.extend([self.guid, self.state])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 0

        # state_check: optional
        if self.guid is not None and self.state is not None:
            _size += 9

        return _size


@dataclasses.dataclass
class SMSG_PET_ACTION_SOUND:
    guid: int
    reason: PetTalkReason

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_ACTION_SOUND:
        # guid: Guid
        guid = await read_int(reader, 8)

        # reason: PetTalkReason
        reason = PetTalkReason(await read_int(reader, 4))

        return SMSG_PET_ACTION_SOUND(
            guid=guid,
            reason=reason,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0324))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.reason.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PET_DISMISS_SOUND:
    sound_id: int
    position: Vector3d

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_DISMISS_SOUND:
        # sound_id: u32
        sound_id = await read_int(reader, 4)

        # position: Vector3d
        position = await Vector3d.read(reader)

        return SMSG_PET_DISMISS_SOUND(
            sound_id=sound_id,
            position=position,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x0325))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.sound_id)
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GM_TICKET_STATUS_UPDATE:
    response: GmTicketStatusResponse

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GM_TICKET_STATUS_UPDATE:
        # response: GmTicketStatusResponse
        response = GmTicketStatusResponse(await read_int(reader, 4))

        return SMSG_GM_TICKET_STATUS_UPDATE(
            response=response,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0328))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.response.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_SET_DUNGEON_DIFFICULTY_Client:
    difficulty: DungeonDifficulty

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_SET_DUNGEON_DIFFICULTY_Client:
        # difficulty: DungeonDifficulty
        difficulty = DungeonDifficulty(await read_int(reader, 4))

        return MSG_SET_DUNGEON_DIFFICULTY_Client(
            difficulty=difficulty,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0329))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.difficulty.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_SET_DUNGEON_DIFFICULTY_Server:
    difficulty: DungeonDifficulty
    unknown1: int
    is_in_group: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_SET_DUNGEON_DIFFICULTY_Server:
        # difficulty: DungeonDifficulty
        difficulty = DungeonDifficulty(await read_int(reader, 4))

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # is_in_group: Bool32
        is_in_group = await read_bool(reader, 4)

        return MSG_SET_DUNGEON_DIFFICULTY_Server(
            difficulty=difficulty,
            unknown1=unknown1,
            is_in_group=is_in_group,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0329))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'III'
        _data.extend([self.difficulty.value, self.unknown1, self.is_in_group])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GMSURVEY_SUBMIT:
    survey_id: int
    questions: typing.List[GmSurveyQuestion]
    answer_comment: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GMSURVEY_SUBMIT:
        # survey_id: u32
        survey_id = await read_int(reader, 4)

        # questions: GmSurveyQuestion[10]
        questions = []
        for _ in range(0, 10):
            questions.append(await GmSurveyQuestion.read(reader))

        # answer_comment: CString
        answer_comment = await read_cstring(reader)

        return CMSG_GMSURVEY_SUBMIT(
            survey_id=survey_id,
            questions=questions,
            answer_comment=answer_comment,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x032A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.survey_id)
        # questions: GmSurveyQuestion[10]
        for i in self.questions:
            _fmt, _data = i.write(_fmt, _data)

        # answer_comment: CString
        _fmt += f'{len(self.answer_comment)}sB'
        _data.extend([self.answer_comment.encode('utf-8'), 0])

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + sum([i.size() for i in self.questions]) + len(self.answer_comment)


@dataclasses.dataclass
class SMSG_UPDATE_INSTANCE_OWNERSHIP:
    player_is_saved_to_a_raid: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_UPDATE_INSTANCE_OWNERSHIP:
        # player_is_saved_to_a_raid: Bool32
        player_is_saved_to_a_raid = await read_bool(reader, 4)

        return SMSG_UPDATE_INSTANCE_OWNERSHIP(
            player_is_saved_to_a_raid=player_is_saved_to_a_raid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x032B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.player_is_saved_to_a_raid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CHAT_PLAYER_AMBIGUOUS:
    player: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAT_PLAYER_AMBIGUOUS:
        # player: CString
        player = await read_cstring(reader)

        return SMSG_CHAT_PLAYER_AMBIGUOUS(
            player=player,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x032D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.player)}sB'
        _data.extend([self.player.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.player)


@dataclasses.dataclass
class SMSG_SPELLINSTAKILLLOG:
    caster: int
    target: int
    spell: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLINSTAKILLLOG:
        # caster: Guid
        caster = await read_int(reader, 8)

        # target: Guid
        target = await read_int(reader, 8)

        # spell: Spell
        spell = await read_int(reader, 4)

        return SMSG_SPELLINSTAKILLLOG(
            caster=caster,
            target=target,
            spell=spell,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x032F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQI'
        _data.extend([self.caster, self.target, self.spell])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELL_UPDATE_CHAIN_TARGETS:
    caster: int
    spell: int
    targets: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELL_UPDATE_CHAIN_TARGETS:
        # caster: Guid
        caster = await read_int(reader, 8)

        # spell: Spell
        spell = await read_int(reader, 4)

        # amount_of_targets: u32
        amount_of_targets = await read_int(reader, 4)

        # targets: Guid[amount_of_targets]
        targets = []
        for _ in range(0, amount_of_targets):
            targets.append(await read_int(reader, 8))

        return SMSG_SPELL_UPDATE_CHAIN_TARGETS(
            caster=caster,
            spell=spell,
            targets=targets,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0330))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QII{len(self.targets)}Q'
        _data.extend([self.caster, self.spell, len(self.targets), *self.targets])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + 8 * len(self.targets)


@dataclasses.dataclass
class SMSG_SPELLSTEALLOG:
    victim: int
    caster: int
    spell: int
    unknown: int
    spell_steals: typing.List[SpellSteal]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLSTEALLOG:
        # victim: PackedGuid
        victim = await read_packed_guid(reader)

        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # spell: Spell
        spell = await read_int(reader, 4)

        # unknown: u8
        unknown = await read_int(reader, 1)

        # amount_of_spell_steals: u32
        amount_of_spell_steals = await read_int(reader, 4)

        # spell_steals: SpellSteal[amount_of_spell_steals]
        spell_steals = []
        for _ in range(0, amount_of_spell_steals):
            spell_steals.append(await SpellSteal.read(reader))

        return SMSG_SPELLSTEALLOG(
            victim=victim,
            caster=caster,
            spell=spell,
            unknown=unknown,
            spell_steals=spell_steals,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0333))
        _fmt = "<4s"
        _data = [_data]

        # victim: PackedGuid
        _fmt, _data = packed_guid_write(self.victim, _fmt, _data)

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # unknown: u8
        _fmt += 'B'
        _data.append(self.unknown)

        # amount_of_spell_steals: u32
        _fmt += 'I'
        _data.append(len(self.spell_steals))

        # spell_steals: SpellSteal[amount_of_spell_steals]
        for i in self.spell_steals:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + packed_guid_size(self.victim) + packed_guid_size(self.caster) + 5 * len(self.spell_steals)


@dataclasses.dataclass
class SMSG_DEFENSE_MESSAGE:
    area: Area
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DEFENSE_MESSAGE:
        # area: Area
        area = Area(await read_int(reader, 4))

        # message: SizedCString
        message = await read_sized_cstring(reader)

        return SMSG_DEFENSE_MESSAGE(
            area=area,
            message=message,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x033A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'II{len(self.message)}sB'
        _data.extend([self.area.value, len(self.message) + 1, self.message.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.message)


@dataclasses.dataclass
class SMSG_INSTANCE_DIFFICULTY:
    difficulty: int
    dynamic_difficulty: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INSTANCE_DIFFICULTY:
        # difficulty: u32
        difficulty = await read_int(reader, 4)

        # dynamic_difficulty: Bool32
        dynamic_difficulty = await read_bool(reader, 4)

        return SMSG_INSTANCE_DIFFICULTY(
            difficulty=difficulty,
            dynamic_difficulty=dynamic_difficulty,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x033B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.difficulty, self.dynamic_difficulty])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MOTD:
    motds: typing.List[str]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOTD:
        # amount_of_motds: u32
        amount_of_motds = await read_int(reader, 4)

        # motds: CString[amount_of_motds]
        motds = []
        for _ in range(0, amount_of_motds):
            motds.append(await read_cstring(reader))

        return SMSG_MOTD(
            motds=motds,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x033D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.motds))
        # motds: CString[amount_of_motds]
        for i in self.motds:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + sum([len(i) + 1 for i in self.motds])


@dataclasses.dataclass
class SMSG_MOVE_SET_FLIGHT:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_SET_FLIGHT:
        # guid: Guid
        guid = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_SET_FLIGHT(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x033E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.counter])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MOVE_UNSET_FLIGHT:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_UNSET_FLIGHT:
        # guid: Guid
        guid = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_UNSET_FLIGHT(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x033F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.counter])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MOVE_SET_CAN_FLY:
    player: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_SET_CAN_FLY:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_SET_CAN_FLY(
            player=player,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0343))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.player)


@dataclasses.dataclass
class SMSG_MOVE_UNSET_CAN_FLY:
    player: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_UNSET_CAN_FLY:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_UNSET_CAN_FLY(
            player=player,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0344))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.player)


@dataclasses.dataclass
class CMSG_MOVE_SET_CAN_FLY_ACK:
    player: int
    counter: int
    info: MovementInfo
    applied: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_SET_CAN_FLY_ACK:
        # player: Guid
        player = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # applied: Bool32
        applied = await read_bool(reader, 4)

        return CMSG_MOVE_SET_CAN_FLY_ACK(
            player=player,
            counter=counter,
            info=info,
            applied=applied,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0345))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.player, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # applied: Bool32
        _fmt += 'I'
        _data.append(self.applied)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class CMSG_MOVE_SET_FLY:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_SET_FLY:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return CMSG_MOVE_SET_FLY(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0346))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class CMSG_SOCKET_GEMS:
    item: int
    gems: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SOCKET_GEMS:
        # item: Guid
        item = await read_int(reader, 8)

        # gems: Guid[3]
        gems = []
        for _ in range(0, 3):
            gems.append(await read_int(reader, 8))

        return CMSG_SOCKET_GEMS(
            item=item,
            gems=gems,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(32 + 4, 0x0347))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.gems)}Q'
        _data.extend([self.item, *self.gems])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ARENA_TEAM_COMMAND_RESULT:
    command: ArenaTeamCommand
    team: str
    player: str
    error: ArenaTeamCommandError

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ARENA_TEAM_COMMAND_RESULT:
        # command: ArenaTeamCommand
        command = ArenaTeamCommand(await read_int(reader, 4))

        # team: CString
        team = await read_cstring(reader)

        # player: CString
        player = await read_cstring(reader)

        # error: ArenaTeamCommandError
        error = ArenaTeamCommandError(await read_int(reader, 4))

        return SMSG_ARENA_TEAM_COMMAND_RESULT(
            command=command,
            team=team,
            player=player,
            error=error,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0349))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.team)}sB{len(self.player)}sBI'
        _data.extend([self.command.value, self.team.encode('utf-8'), 0, self.player.encode('utf-8'), 0, self.error.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 10 + len(self.team) + len(self.player)


@dataclasses.dataclass
class SMSG_ARENA_TEAM_QUERY_RESPONSE:
    arena_team: int
    team_name: str
    team_type: ArenaType
    background_color: int
    emblem_style: int
    emblem_color: int
    border_style: int
    border_color: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ARENA_TEAM_QUERY_RESPONSE:
        # arena_team: u32
        arena_team = await read_int(reader, 4)

        # team_name: CString
        team_name = await read_cstring(reader)

        # team_type: ArenaType
        team_type = ArenaType(await read_int(reader, 1))

        # background_color: u32
        background_color = await read_int(reader, 4)

        # emblem_style: u32
        emblem_style = await read_int(reader, 4)

        # emblem_color: u32
        emblem_color = await read_int(reader, 4)

        # border_style: u32
        border_style = await read_int(reader, 4)

        # border_color: u32
        border_color = await read_int(reader, 4)

        return SMSG_ARENA_TEAM_QUERY_RESPONSE(
            arena_team=arena_team,
            team_name=team_name,
            team_type=team_type,
            background_color=background_color,
            emblem_style=emblem_style,
            emblem_color=emblem_color,
            border_style=border_style,
            border_color=border_color,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x034C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.team_name)}sBBIIIII'
        _data.extend([self.arena_team, self.team_name.encode('utf-8'), 0, self.team_type.value, self.background_color, self.emblem_style, self.emblem_color, self.border_style, self.border_color])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 26 + len(self.team_name)


@dataclasses.dataclass
class CMSG_ARENA_TEAM_ROSTER:
    arena_team: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ARENA_TEAM_ROSTER:
        # arena_team: u32
        arena_team = await read_int(reader, 4)

        return CMSG_ARENA_TEAM_ROSTER(
            arena_team=arena_team,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x034D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.arena_team)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ARENA_TEAM_ROSTER:
    arena_team: int
    arena_type: ArenaType
    members: typing.List[ArenaTeamMember]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ARENA_TEAM_ROSTER:
        # arena_team: u32
        arena_team = await read_int(reader, 4)

        # amount_of_members: u32
        amount_of_members = await read_int(reader, 4)

        # arena_type: ArenaType
        arena_type = ArenaType(await read_int(reader, 1))

        # members: ArenaTeamMember[amount_of_members]
        members = []
        for _ in range(0, amount_of_members):
            members.append(await ArenaTeamMember.read(reader))

        return SMSG_ARENA_TEAM_ROSTER(
            arena_team=arena_team,
            arena_type=arena_type,
            members=members,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x034E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIB'
        _data.extend([self.arena_team, len(self.members), self.arena_type.value])
        # members: ArenaTeamMember[amount_of_members]
        for i in self.members:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + sum([i.size() for i in self.members])


@dataclasses.dataclass
class CMSG_ARENA_TEAM_INVITE:
    arena_team: int
    player: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ARENA_TEAM_INVITE:
        # arena_team: u32
        arena_team = await read_int(reader, 4)

        # player: CString
        player = await read_cstring(reader)

        return CMSG_ARENA_TEAM_INVITE(
            arena_team=arena_team,
            player=player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x034F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'I{len(self.player)}sB'
        _data.extend([self.arena_team, self.player.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + len(self.player)


@dataclasses.dataclass
class SMSG_ARENA_TEAM_INVITE:
    player_name: str
    team_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ARENA_TEAM_INVITE:
        # player_name: CString
        player_name = await read_cstring(reader)

        # team_name: CString
        team_name = await read_cstring(reader)

        return SMSG_ARENA_TEAM_INVITE(
            player_name=player_name,
            team_name=team_name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0350))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.player_name)}sB{len(self.team_name)}sB'
        _data.extend([self.player_name.encode('utf-8'), 0, self.team_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.player_name) + len(self.team_name)


@dataclasses.dataclass
class CMSG_ARENA_TEAM_ACCEPT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ARENA_TEAM_ACCEPT:
        return CMSG_ARENA_TEAM_ACCEPT()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0351))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ARENA_TEAM_DECLINE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ARENA_TEAM_DECLINE:
        return CMSG_ARENA_TEAM_DECLINE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0352))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ARENA_TEAM_LEAVE:
    arena_team: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ARENA_TEAM_LEAVE:
        # arena_team: u32
        arena_team = await read_int(reader, 4)

        return CMSG_ARENA_TEAM_LEAVE(
            arena_team=arena_team,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0353))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.arena_team)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ARENA_TEAM_REMOVE:
    arena_team: int
    player: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ARENA_TEAM_REMOVE:
        # arena_team: u32
        arena_team = await read_int(reader, 4)

        # player: CString
        player = await read_cstring(reader)

        return CMSG_ARENA_TEAM_REMOVE(
            arena_team=arena_team,
            player=player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0354))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'I{len(self.player)}sB'
        _data.extend([self.arena_team, self.player.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + len(self.player)


@dataclasses.dataclass
class CMSG_ARENA_TEAM_DISBAND:
    arena_team: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ARENA_TEAM_DISBAND:
        # arena_team: u32
        arena_team = await read_int(reader, 4)

        return CMSG_ARENA_TEAM_DISBAND(
            arena_team=arena_team,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0355))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.arena_team)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ARENA_TEAM_LEADER:
    arena_team: int
    player: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ARENA_TEAM_LEADER:
        # arena_team: u32
        arena_team = await read_int(reader, 4)

        # player: CString
        player = await read_cstring(reader)

        return CMSG_ARENA_TEAM_LEADER(
            arena_team=arena_team,
            player=player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0356))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'I{len(self.player)}sB'
        _data.extend([self.arena_team, self.player.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + len(self.player)


@dataclasses.dataclass
class SMSG_ARENA_TEAM_EVENT:
    event: ArenaTeamEvent
    string: typing.List[str]
    joiner_name: typing.Optional[str] = None
    arena_team_name1: typing.Optional[str] = None
    joiner: typing.Optional[int] = None
    leaver_name: typing.Optional[str] = None
    leaver: typing.Optional[int] = None
    kicked_player_name: typing.Optional[str] = None
    arena_team_name2: typing.Optional[str] = None
    kicker_name: typing.Optional[str] = None
    leader_name: typing.Optional[str] = None
    arena_team_name3: typing.Optional[str] = None
    old_leader: typing.Optional[str] = None
    new_leader: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ARENA_TEAM_EVENT:
        joiner_name = None
        arena_team_name1 = None
        joiner = None
        leaver_name = None
        leaver = None
        kicked_player_name = None
        arena_team_name2 = None
        kicker_name = None
        leader_name = None
        arena_team_name3 = None
        old_leader = None
        new_leader = None
        # event: ArenaTeamEvent
        event = ArenaTeamEvent(await read_int(reader, 1))

        if event == ArenaTeamEvent.JOIN:
            # joiner_name: CString
            joiner_name = await read_cstring(reader)

            # arena_team_name1: CString
            arena_team_name1 = await read_cstring(reader)

            # joiner: Guid
            joiner = await read_int(reader, 8)

        elif event == ArenaTeamEvent.LEAVE:
            # leaver_name: CString
            leaver_name = await read_cstring(reader)

            # leaver: Guid
            leaver = await read_int(reader, 8)

        elif event == ArenaTeamEvent.REMOVE:
            # kicked_player_name: CString
            kicked_player_name = await read_cstring(reader)

            # arena_team_name2: CString
            arena_team_name2 = await read_cstring(reader)

            # kicker_name: CString
            kicker_name = await read_cstring(reader)

        elif event in {ArenaTeamEvent.LEADER_IS, ArenaTeamEvent.DISBANDED}:
            # leader_name: CString
            leader_name = await read_cstring(reader)

            # arena_team_name3: CString
            arena_team_name3 = await read_cstring(reader)

        elif event == ArenaTeamEvent.LEADER_CHANGED:
            # old_leader: CString
            old_leader = await read_cstring(reader)

            # new_leader: CString
            new_leader = await read_cstring(reader)

        # amount_of_strings: u8
        amount_of_strings = await read_int(reader, 1)

        # string: CString[amount_of_strings]
        string = []
        for _ in range(0, amount_of_strings):
            string.append(await read_cstring(reader))

        return SMSG_ARENA_TEAM_EVENT(
            event=event,
            joiner_name=joiner_name,
            arena_team_name1=arena_team_name1,
            joiner=joiner,
            leaver_name=leaver_name,
            leaver=leaver,
            kicked_player_name=kicked_player_name,
            arena_team_name2=arena_team_name2,
            kicker_name=kicker_name,
            leader_name=leader_name,
            arena_team_name3=arena_team_name3,
            old_leader=old_leader,
            new_leader=new_leader,
            string=string,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0357))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.event.value)
        if self.event == ArenaTeamEvent.JOIN:
            _fmt += f'{len(self.joiner_name)}sB{len(self.arena_team_name1)}sBQ'
            _data.extend([self.joiner_name.encode('utf-8'), 0, self.arena_team_name1.encode('utf-8'), 0, self.joiner])
        elif self.event == ArenaTeamEvent.LEAVE:
            _fmt += f'{len(self.leaver_name)}sBQ'
            _data.extend([self.leaver_name.encode('utf-8'), 0, self.leaver])
        elif self.event == ArenaTeamEvent.REMOVE:
            _fmt += f'{len(self.kicked_player_name)}sB{len(self.arena_team_name2)}sB{len(self.kicker_name)}sB'
            _data.extend([self.kicked_player_name.encode('utf-8'), 0, self.arena_team_name2.encode('utf-8'), 0, self.kicker_name.encode('utf-8'), 0])
        elif self.event in {ArenaTeamEvent.LEADER_IS, ArenaTeamEvent.DISBANDED}:
            _fmt += f'{len(self.leader_name)}sB{len(self.arena_team_name3)}sB'
            _data.extend([self.leader_name.encode('utf-8'), 0, self.arena_team_name3.encode('utf-8'), 0])
        elif self.event == ArenaTeamEvent.LEADER_CHANGED:
            _fmt += f'{len(self.old_leader)}sB{len(self.new_leader)}sB'
            _data.extend([self.old_leader.encode('utf-8'), 0, self.new_leader.encode('utf-8'), 0])
        # amount_of_strings: u8
        _fmt += 'B'
        _data.append(len(self.string))

        # string: CString[amount_of_strings]
        for i in self.string:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 2 + sum([len(i) + 1 for i in self.string])

        if self.event == ArenaTeamEvent.JOIN:
            _size += 10 + len(self.joiner_name) + len(self.arena_team_name1)
        elif self.event == ArenaTeamEvent.LEAVE:
            _size += 9 + len(self.leaver_name)
        elif self.event == ArenaTeamEvent.REMOVE:
            _size += 3 + len(self.kicked_player_name) + len(self.arena_team_name2) + len(self.kicker_name)
        elif self.event in {ArenaTeamEvent.LEADER_IS, ArenaTeamEvent.DISBANDED}:
            _size += 2 + len(self.leader_name) + len(self.arena_team_name3)
        elif self.event == ArenaTeamEvent.LEADER_CHANGED:
            _size += 2 + len(self.old_leader) + len(self.new_leader)

        return _size


@dataclasses.dataclass
class CMSG_BATTLEMASTER_JOIN_ARENA:
    battlemaster: int
    arena_type: JoinArenaType
    as_group: bool
    rated: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BATTLEMASTER_JOIN_ARENA:
        # battlemaster: Guid
        battlemaster = await read_int(reader, 8)

        # arena_type: JoinArenaType
        arena_type = JoinArenaType(await read_int(reader, 1))

        # as_group: Bool8
        as_group = await read_bool(reader, 1)

        # rated: Bool8
        rated = await read_bool(reader, 1)

        return CMSG_BATTLEMASTER_JOIN_ARENA(
            battlemaster=battlemaster,
            arena_type=arena_type,
            as_group=as_group,
            rated=rated,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(11 + 4, 0x0358))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QBBB'
        _data.extend([self.battlemaster, self.arena_type.value, self.as_group, self.rated])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MOVE_START_ASCEND_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_ASCEND_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_ASCEND_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0359))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_ASCEND_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_ASCEND_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_ASCEND_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0359))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_ASCEND_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_ASCEND_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_ASCEND_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x035A))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_ASCEND_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_ASCEND_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_ASCEND_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x035A))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class SMSG_ARENA_TEAM_STATS:
    arena_team: int
    rating: int
    games_played_this_week: int
    games_won_this_week: int
    games_played_this_season: int
    games_won_this_season: int
    ranking: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ARENA_TEAM_STATS:
        # arena_team: u32
        arena_team = await read_int(reader, 4)

        # rating: u32
        rating = await read_int(reader, 4)

        # games_played_this_week: u32
        games_played_this_week = await read_int(reader, 4)

        # games_won_this_week: u32
        games_won_this_week = await read_int(reader, 4)

        # games_played_this_season: u32
        games_played_this_season = await read_int(reader, 4)

        # games_won_this_season: u32
        games_won_this_season = await read_int(reader, 4)

        # ranking: u32
        ranking = await read_int(reader, 4)

        return SMSG_ARENA_TEAM_STATS(
            arena_team=arena_team,
            rating=rating,
            games_played_this_week=games_played_this_week,
            games_won_this_week=games_won_this_week,
            games_played_this_season=games_played_this_season,
            games_won_this_season=games_won_this_season,
            ranking=ranking,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(28 + 2, 0x035B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIIIII'
        _data.extend([self.arena_team, self.rating, self.games_played_this_week, self.games_won_this_week, self.games_played_this_season, self.games_won_this_season, self.ranking])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LFG_SET_AUTOJOIN:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LFG_SET_AUTOJOIN:
        return CMSG_LFG_SET_AUTOJOIN()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x035C))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LFG_CLEAR_AUTOJOIN:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LFG_CLEAR_AUTOJOIN:
        return CMSG_LFG_CLEAR_AUTOJOIN()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x035D))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LFM_SET_AUTOFILL:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LFM_SET_AUTOFILL:
        return CMSG_LFM_SET_AUTOFILL()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x035E))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LFM_CLEAR_AUTOFILL:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LFM_CLEAR_AUTOFILL:
        return CMSG_LFM_CLEAR_AUTOFILL()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x035F))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CLEAR_LOOKING_FOR_GROUP:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CLEAR_LOOKING_FOR_GROUP:
        return CMSG_CLEAR_LOOKING_FOR_GROUP()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0363))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CLEAR_LOOKING_FOR_MORE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CLEAR_LOOKING_FOR_MORE:
        return CMSG_CLEAR_LOOKING_FOR_MORE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0364))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_LOOKING_FOR_MORE:
    data: LfgData

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_LOOKING_FOR_MORE:
        # data: LfgData
        data = await LfgData.read(reader)

        return CMSG_SET_LOOKING_FOR_MORE(
            data=data,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0365))
        _fmt = "<6s"
        _data = [_data]

        # data: LfgData
        _fmt, _data = self.data.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_LFG_COMMENT:
    comment: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_LFG_COMMENT:
        # comment: CString
        comment = await read_cstring(reader)

        return CMSG_SET_LFG_COMMENT(
            comment=comment,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0366))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.comment)}sB'
        _data.extend([self.comment.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.comment)


@dataclasses.dataclass
class SMSG_LFG_LEADER_IS_LFM:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LFG_LEADER_IS_LFM:
        return SMSG_LFG_LEADER_IS_LFM()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x036B))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LFG_UPDATE:
    queued: bool
    is_looking_for_group: bool
    looking_for_more: LfgUpdateLookingForMore
    data: typing.Optional[LfgData] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LFG_UPDATE:
        data = None
        # queued: Bool8
        queued = await read_bool(reader, 1)

        # is_looking_for_group: Bool8
        is_looking_for_group = await read_bool(reader, 1)

        # looking_for_more: LfgUpdateLookingForMore
        looking_for_more = LfgUpdateLookingForMore(await read_int(reader, 1))

        if looking_for_more == LfgUpdateLookingForMore.LOOKING_FOR_MORE:
            # data: LfgData
            data = await LfgData.read(reader)

        return SMSG_LFG_UPDATE(
            queued=queued,
            is_looking_for_group=is_looking_for_group,
            looking_for_more=looking_for_more,
            data=data,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x036C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BBB'
        _data.extend([self.queued, self.is_looking_for_group, self.looking_for_more.value])
        if self.looking_for_more == LfgUpdateLookingForMore.LOOKING_FOR_MORE:
            # data: LfgData
            _fmt, _data = self.data.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 3

        if self.looking_for_more == LfgUpdateLookingForMore.LOOKING_FOR_MORE:
            _size += 4

        return _size


@dataclasses.dataclass
class SMSG_LFG_UPDATE_LFM:
    looking_for_more: LfgUpdateLookingForMore
    data: typing.Optional[LfgData] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LFG_UPDATE_LFM:
        data = None
        # looking_for_more: LfgUpdateLookingForMore
        looking_for_more = LfgUpdateLookingForMore(await read_int(reader, 1))

        if looking_for_more == LfgUpdateLookingForMore.LOOKING_FOR_MORE:
            # data: LfgData
            data = await LfgData.read(reader)

        return SMSG_LFG_UPDATE_LFM(
            looking_for_more=looking_for_more,
            data=data,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x036D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.looking_for_more.value)
        if self.looking_for_more == LfgUpdateLookingForMore.LOOKING_FOR_MORE:
            # data: LfgData
            _fmt, _data = self.data.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.looking_for_more == LfgUpdateLookingForMore.LOOKING_FOR_MORE:
            _size += 4

        return _size


@dataclasses.dataclass
class SMSG_LFG_UPDATE_LFG:
    data: typing.List[LfgData]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LFG_UPDATE_LFG:
        # data: LfgData[3]
        data = []
        for _ in range(0, 3):
            data.append(await LfgData.read(reader))

        return SMSG_LFG_UPDATE_LFG(
            data=data,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x036E))
        _fmt = "<4s"
        _data = [_data]

        # data: LfgData[3]
        for i in self.data:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LFG_UPDATE_QUEUED:
    queued: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LFG_UPDATE_QUEUED:
        # queued: Bool8
        queued = await read_bool(reader, 1)

        return SMSG_LFG_UPDATE_QUEUED(
            queued=queued,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x036F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.queued)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TITLE_EARNED:
    title: int
    status: TitleEarnStatus

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TITLE_EARNED:
        # title: u32
        title = await read_int(reader, 4)

        # status: TitleEarnStatus
        status = TitleEarnStatus(await read_int(reader, 4))

        return SMSG_TITLE_EARNED(
            title=title,
            status=status,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0373))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.title, self.status.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_TITLE:
    title: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_TITLE:
        # title: u32
        title = await read_int(reader, 4)

        return CMSG_SET_TITLE(
            title=title,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0374))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.title)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CANCEL_MOUNT_AURA:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_MOUNT_AURA:
        return CMSG_CANCEL_MOUNT_AURA()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0375))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ARENA_ERROR:
    unknown: int
    arena_type: ArenaType

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ARENA_ERROR:
        # unknown: u32
        unknown = await read_int(reader, 4)

        # arena_type: ArenaType
        arena_type = ArenaType(await read_int(reader, 1))

        return SMSG_ARENA_ERROR(
            unknown=unknown,
            arena_type=arena_type,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x0376))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([self.unknown, self.arena_type.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_INSPECT_ARENA_TEAMS_Client:
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_INSPECT_ARENA_TEAMS_Client:
        # player: Guid
        player = await read_int(reader, 8)

        return MSG_INSPECT_ARENA_TEAMS_Client(
            player=player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0377))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.player)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_INSPECT_ARENA_TEAMS_Server:
    player: int
    slot: int
    arena_team: int
    rating: int
    games_played_this_season: int
    wins_this_season: int
    total_games_played: int
    personal_rating: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_INSPECT_ARENA_TEAMS_Server:
        # player: Guid
        player = await read_int(reader, 8)

        # slot: u8
        slot = await read_int(reader, 1)

        # arena_team: u32
        arena_team = await read_int(reader, 4)

        # rating: u32
        rating = await read_int(reader, 4)

        # games_played_this_season: u32
        games_played_this_season = await read_int(reader, 4)

        # wins_this_season: u32
        wins_this_season = await read_int(reader, 4)

        # total_games_played: u32
        total_games_played = await read_int(reader, 4)

        # personal_rating: u32
        personal_rating = await read_int(reader, 4)

        return MSG_INSPECT_ARENA_TEAMS_Server(
            player=player,
            slot=slot,
            arena_team=arena_team,
            rating=rating,
            games_played_this_season=games_played_this_season,
            wins_this_season=wins_this_season,
            total_games_played=total_games_played,
            personal_rating=personal_rating,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(33 + 2, 0x0377))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QBIIIIII'
        _data.extend([self.player, self.slot, self.arena_team, self.rating, self.games_played_this_season, self.wins_this_season, self.total_games_played, self.personal_rating])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DEATH_RELEASE_LOC:
    map: Map
    position: Vector3d

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DEATH_RELEASE_LOC:
        # map: Map
        map = Map(await read_int(reader, 4))

        # position: Vector3d
        position = await Vector3d.read(reader)

        return SMSG_DEATH_RELEASE_LOC(
            map=map,
            position=position,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x0378))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CANCEL_TEMP_ENCHANTMENT:
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_TEMP_ENCHANTMENT:
        # slot: u32
        slot = await read_int(reader, 4)

        return CMSG_CANCEL_TEMP_ENCHANTMENT(
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0379))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.slot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_FORCED_DEATH_UPDATE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCED_DEATH_UPDATE:
        return SMSG_FORCED_DEATH_UPDATE()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x037A))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MOVE_SET_FLIGHT_SPEED_Server:
    player: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_FLIGHT_SPEED_Server:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return MSG_MOVE_SET_FLIGHT_SPEED_Server(
            player=player,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x037E))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_FLIGHT_BACK_SPEED:
    player: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_FLIGHT_BACK_SPEED:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return MSG_MOVE_SET_FLIGHT_BACK_SPEED(
            player=player,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0380))
        _fmt = "<6s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0380))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_FLIGHT_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_FLIGHT_SPEED_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_FLIGHT_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0381))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_FLIGHT_SPEED_CHANGE_ACK:
    player: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_FLIGHT_SPEED_CHANGE_ACK:
        # player: Guid
        player = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_FLIGHT_SPEED_CHANGE_ACK(
            player=player,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0382))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.player, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0383))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE_ACK:
    player: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE_ACK:
        # player: Guid
        player = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE_ACK(
            player=player,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0384))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.player, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class SMSG_SPLINE_SET_FLIGHT_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_FLIGHT_SPEED:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_FLIGHT_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0385))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_FLIGHT_BACK_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_FLIGHT_BACK_SPEED:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_FLIGHT_BACK_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0386))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_FLIGHT_SPLINE_SYNC:
    elapsed_value: float
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FLIGHT_SPLINE_SYNC:
        # elapsed_value: f32
        elapsed_value = await read_float(reader)

        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_FLIGHT_SPLINE_SYNC(
            elapsed_value=elapsed_value,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0388))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'fQ'
        _data.extend([self.elapsed_value, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_TAXI_BENCHMARK_MODE:
    mode: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_TAXI_BENCHMARK_MODE:
        # mode: u8
        mode = await read_int(reader, 1)

        return CMSG_SET_TAXI_BENCHMARK_MODE(
            mode=mode,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x0389))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.mode)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_REALM_SPLIT:
    realm_id: int
    state: RealmSplitState
    split_date: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_REALM_SPLIT:
        # realm_id: u32
        realm_id = await read_int(reader, 4)

        # state: RealmSplitState
        state = RealmSplitState(await read_int(reader, 4))

        # split_date: CString
        split_date = await read_cstring(reader)

        return SMSG_REALM_SPLIT(
            realm_id=realm_id,
            state=state,
            split_date=split_date,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x038B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'II{len(self.split_date)}sB'
        _data.extend([self.realm_id, self.state.value, self.split_date.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.split_date)


@dataclasses.dataclass
class CMSG_REALM_SPLIT:
    realm_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REALM_SPLIT:
        # realm_id: u32
        realm_id = await read_int(reader, 4)

        return CMSG_REALM_SPLIT(
            realm_id=realm_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x038C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.realm_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MOVE_CHNG_TRANSPORT:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_CHNG_TRANSPORT:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return CMSG_MOVE_CHNG_TRANSPORT(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x038D))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_PARTY_ASSIGNMENT_Client:
    role: PartyRole
    apply: bool
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_PARTY_ASSIGNMENT_Client:
        # role: PartyRole
        role = PartyRole(await read_int(reader, 1))

        # apply: Bool8
        apply = await read_bool(reader, 1)

        # player: Guid
        player = await read_int(reader, 8)

        return MSG_PARTY_ASSIGNMENT_Client(
            role=role,
            apply=apply,
            player=player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(10 + 4, 0x038E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBQ'
        _data.extend([self.role.value, self.apply, self.player])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TIME_SYNC_REQ:
    time_sync: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TIME_SYNC_REQ:
        # time_sync: u32
        time_sync = await read_int(reader, 4)

        return SMSG_TIME_SYNC_REQ(
            time_sync=time_sync,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0390))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.time_sync)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TIME_SYNC_RESP:
    time_sync: int
    client_ticks: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TIME_SYNC_RESP:
        # time_sync: u32
        time_sync = await read_int(reader, 4)

        # client_ticks: u32
        client_ticks = await read_int(reader, 4)

        return CMSG_TIME_SYNC_RESP(
            time_sync=time_sync,
            client_ticks=client_ticks,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0391))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.time_sync, self.client_ticks])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_RESET_FAILED_NOTIFY:
    map: Map

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RESET_FAILED_NOTIFY:
        # map: Map
        map = Map(await read_int(reader, 4))

        return SMSG_RESET_FAILED_NOTIFY(
            map=map,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0396))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LFG_DISABLED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LFG_DISABLED:
        return SMSG_LFG_DISABLED()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0398))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_UPDATE_COMBO_POINTS:
    target: int
    combo_points: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_UPDATE_COMBO_POINTS:
        # target: PackedGuid
        target = await read_packed_guid(reader)

        # combo_points: u8
        combo_points = await read_int(reader, 1)

        return SMSG_UPDATE_COMBO_POINTS(
            target=target,
            combo_points=combo_points,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x039D))
        _fmt = "<4s"
        _data = [_data]

        # target: PackedGuid
        _fmt, _data = packed_guid_write(self.target, _fmt, _data)

        # combo_points: u8
        _fmt += 'B'
        _data.append(self.combo_points)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + packed_guid_size(self.target)


@dataclasses.dataclass
class SMSG_SET_EXTRA_AURA_INFO:
    unit: int
    slot: typing.Optional[int] = None
    spell: typing.Optional[int] = None
    max_duration: typing.Optional[int] = None
    remaining_duration: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_EXTRA_AURA_INFO:
        slot = None
        spell = None
        max_duration = None
        remaining_duration = None
        _size = 0

        # unit: PackedGuid
        unit = await read_packed_guid(reader)
        _size += packed_guid_size(unit)

        # aura: optional
        if _size < body_size:
            # slot: u8
            slot = await read_int(reader, 1)
            _size += 1

            # spell: Spell
            spell = await read_int(reader, 4)
            _size += 4

            # max_duration: u32
            max_duration = await read_int(reader, 4)
            _size += 4

            # remaining_duration: u32
            remaining_duration = await read_int(reader, 4)
            _size += 4

        return SMSG_SET_EXTRA_AURA_INFO(
            unit=unit,
            slot=slot,
            spell=spell,
            max_duration=max_duration,
            remaining_duration=remaining_duration,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03A4))
        _fmt = "<4s"
        _data = [_data]

        # unit: PackedGuid
        _fmt, _data = packed_guid_write(self.unit, _fmt, _data)

        # aura: optional
        if self.slot is not None and self.spell is not None and self.max_duration is not None and self.remaining_duration is not None:
            _fmt += 'BIII'
            _data.extend([self.slot, self.spell, self.max_duration, self.remaining_duration])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 0 + packed_guid_size(self.unit)

        # aura: optional
        if self.slot is not None and self.spell is not None and self.max_duration is not None and self.remaining_duration is not None:
            _size += 13

        return _size


@dataclasses.dataclass
class SMSG_SET_EXTRA_AURA_INFO_NEED_UPDATE:
    unit: int
    slot: int
    spell: int
    max_duration: int
    remaining_duration: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_EXTRA_AURA_INFO_NEED_UPDATE:
        # unit: PackedGuid
        unit = await read_packed_guid(reader)

        # slot: u8
        slot = await read_int(reader, 1)

        # spell: Spell
        spell = await read_int(reader, 4)

        # max_duration: u32
        max_duration = await read_int(reader, 4)

        # remaining_duration: u32
        remaining_duration = await read_int(reader, 4)

        return SMSG_SET_EXTRA_AURA_INFO_NEED_UPDATE(
            unit=unit,
            slot=slot,
            spell=spell,
            max_duration=max_duration,
            remaining_duration=remaining_duration,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03A5))
        _fmt = "<4s"
        _data = [_data]

        # unit: PackedGuid
        _fmt, _data = packed_guid_write(self.unit, _fmt, _data)

        # slot: u8
        _fmt += 'B'
        _data.append(self.slot)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # max_duration: u32
        _fmt += 'I'
        _data.append(self.max_duration)

        # remaining_duration: u32
        _fmt += 'I'
        _data.append(self.remaining_duration)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 13 + packed_guid_size(self.unit)


@dataclasses.dataclass
class SMSG_CLEAR_EXTRA_AURA_INFO:
    unit: int
    spell: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CLEAR_EXTRA_AURA_INFO:
        # unit: PackedGuid
        unit = await read_packed_guid(reader)

        # spell: Spell
        spell = await read_int(reader, 4)

        return SMSG_CLEAR_EXTRA_AURA_INFO(
            unit=unit,
            spell=spell,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03A6))
        _fmt = "<4s"
        _data = [_data]

        # unit: PackedGuid
        _fmt, _data = packed_guid_write(self.unit, _fmt, _data)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.unit)


@dataclasses.dataclass
class MSG_MOVE_START_DESCEND_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_DESCEND_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_DESCEND_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x03A7))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_DESCEND_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_DESCEND_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_DESCEND_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03A7))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class SMSG_DISMOUNT:
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DISMOUNT:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        return SMSG_DISMOUNT(
            player=player,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03AC))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player)


@dataclasses.dataclass
class MSG_MOVE_UPDATE_CAN_FLY_Server:
    player: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_UPDATE_CAN_FLY_Server:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_UPDATE_CAN_FLY_Server(
            player=player,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03AD))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class MSG_RAID_READY_CHECK_CONFIRM_Client:
    state: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RAID_READY_CHECK_CONFIRM_Client:
        state = None
        _size = 0

        # set: optional
        if _size < body_size:
            # state: u8
            state = await read_int(reader, 1)
            _size += 1

        return MSG_RAID_READY_CHECK_CONFIRM_Client(
            state=state,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x03AE))
        _fmt = "<6s"
        _data = [_data]

        # set: optional
        if self.state is not None:
            _fmt += 'B'
            _data.append(self.state)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 0

        # set: optional
        if self.state is not None:
            _size += 1

        return _size


@dataclasses.dataclass
class MSG_RAID_READY_CHECK_CONFIRM_Server:
    player: int
    state: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RAID_READY_CHECK_CONFIRM_Server:
        # player: Guid
        player = await read_int(reader, 8)

        # state: u8
        state = await read_int(reader, 1)

        return MSG_RAID_READY_CHECK_CONFIRM_Server(
            player=player,
            state=state,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x03AE))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.player, self.state])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_VOICE_SESSION_ENABLE:
    voice_enabled: bool
    microphone_enabled: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_VOICE_SESSION_ENABLE:
        # voice_enabled: Bool8
        voice_enabled = await read_bool(reader, 1)

        # microphone_enabled: Bool8
        microphone_enabled = await read_bool(reader, 1)

        return CMSG_VOICE_SESSION_ENABLE(
            voice_enabled=voice_enabled,
            microphone_enabled=microphone_enabled,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x03AF))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.voice_enabled, self.microphone_enabled])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GM_MESSAGECHAT:
    chat_type: ChatType
    language: Language
    sender: typing.Optional[str] = None
    target1: typing.Optional[NamedGUID] = None
    message1: typing.Optional[str] = None
    chat_tag1: typing.Optional[PlayerChatTag] = None
    target2: typing.Optional[NamedGUID] = None
    message2: typing.Optional[str] = None
    chat_tag2: typing.Optional[PlayerChatTag] = None
    channel_name: typing.Optional[str] = None
    target4: typing.Optional[int] = None
    message3: typing.Optional[str] = None
    chat_tag3: typing.Optional[PlayerChatTag] = None
    target5: typing.Optional[int] = None
    message4: typing.Optional[str] = None
    chat_tag4: typing.Optional[PlayerChatTag] = None
    sender_name: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GM_MESSAGECHAT:
        sender = None
        target1 = None
        message1 = None
        chat_tag1 = None
        target2 = None
        message2 = None
        chat_tag2 = None
        channel_name = None
        target4 = None
        message3 = None
        chat_tag3 = None
        target5 = None
        message4 = None
        chat_tag4 = None
        sender_name = None
        # chat_type: ChatType
        chat_type = ChatType(await read_int(reader, 1))

        # language: Language
        language = Language(await read_int(reader, 4))

        if chat_type in {ChatType.MONSTER_SAY, ChatType.MONSTER_PARTY, ChatType.MONSTER_YELL, ChatType.MONSTER_WHISPER, ChatType.RAID_BOSS_WHISPER, ChatType.RAID_BOSS_EMOTE, ChatType.MONSTER_EMOTE}:
            # sender: SizedCString
            sender = await read_sized_cstring(reader)

            # target1: NamedGuid
            target1 = await NamedGuid.read(reader)

            # message1: SizedCString
            message1 = await read_sized_cstring(reader)

            # chat_tag1: PlayerChatTag
            chat_tag1 = PlayerChatTag(await read_int(reader, 1))

        elif chat_type in {ChatType.BG_SYSTEM_NEUTRAL, ChatType.BG_SYSTEM_ALLIANCE, ChatType.BG_SYSTEM_HORDE}:
            # target2: NamedGuid
            target2 = await NamedGuid.read(reader)

            # message2: SizedCString
            message2 = await read_sized_cstring(reader)

            # chat_tag2: PlayerChatTag
            chat_tag2 = PlayerChatTag(await read_int(reader, 1))

        elif chat_type == ChatType.CHANNEL:
            # channel_name: CString
            channel_name = await read_cstring(reader)

            # target4: Guid
            target4 = await read_int(reader, 8)

            # message3: SizedCString
            message3 = await read_sized_cstring(reader)

            # chat_tag3: PlayerChatTag
            chat_tag3 = PlayerChatTag(await read_int(reader, 1))

        elif chat_type in {ChatType.SYSTEM, ChatType.SAY, ChatType.PARTY, ChatType.RAID, ChatType.GUILD, ChatType.OFFICER, ChatType.YELL, ChatType.WHISPER, ChatType.WHISPER_INFORM, ChatType.REPLY, ChatType.EMOTE, ChatType.TEXT_EMOTE, ChatType.CHANNEL_JOIN, ChatType.CHANNEL_LEAVE, ChatType.CHANNEL_LIST, ChatType.CHANNEL_NOTICE, ChatType.CHANNEL_NOTICE_USER, ChatType.AFK, ChatType.DND, ChatType.IGNORED, ChatType.SKILL, ChatType.LOOT, ChatType.MONEY, ChatType.OPENING, ChatType.TRADESKILLS, ChatType.PET_INFO, ChatType.COMBAT_MISC_INFO, ChatType.COMBAT_XP_GAIN, ChatType.COMBAT_HONOR_GAIN, ChatType.COMBAT_FACTION_CHANGE, ChatType.RAID_LEADER, ChatType.RAID_WARNING, ChatType.FILTERED, ChatType.BATTLEGROUND, ChatType.BATTLEGROUND_LEADER, ChatType.RESTRICTED}:
            # target5: Guid
            target5 = await read_int(reader, 8)

            # message4: SizedCString
            message4 = await read_sized_cstring(reader)

            # chat_tag4: PlayerChatTag
            chat_tag4 = PlayerChatTag(await read_int(reader, 1))

            # sender_name: SizedCString
            sender_name = await read_sized_cstring(reader)

        return SMSG_GM_MESSAGECHAT(
            chat_type=chat_type,
            language=language,
            sender=sender,
            target1=target1,
            message1=message1,
            chat_tag1=chat_tag1,
            target2=target2,
            message2=message2,
            chat_tag2=chat_tag2,
            channel_name=channel_name,
            target4=target4,
            message3=message3,
            chat_tag3=chat_tag3,
            target5=target5,
            message4=message4,
            chat_tag4=chat_tag4,
            sender_name=sender_name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03B2))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BI'
        _data.extend([self.chat_type.value, self.language.value])
        if self.chat_type in {ChatType.MONSTER_SAY, ChatType.MONSTER_PARTY, ChatType.MONSTER_YELL, ChatType.MONSTER_WHISPER, ChatType.RAID_BOSS_WHISPER, ChatType.RAID_BOSS_EMOTE, ChatType.MONSTER_EMOTE}:
            _fmt += f'I{len(self.sender)}sB'
            _data.extend([len(self.sender) + 1, self.sender.encode('utf-8'), 0])
            # target1: NamedGuid
            _fmt, _data = self.target1.write(_fmt, _data)

            # message1: SizedCString
            _fmt += f'I{len(self.message1)}sB'
            _data.extend([len(self.message1) + 1, self.message1.encode('utf-8'), 0])

            # chat_tag1: PlayerChatTag
            _fmt += 'B'
            _data.append(self.chat_tag1.value)

        elif self.chat_type in {ChatType.BG_SYSTEM_NEUTRAL, ChatType.BG_SYSTEM_ALLIANCE, ChatType.BG_SYSTEM_HORDE}:
            # target2: NamedGuid
            _fmt, _data = self.target2.write(_fmt, _data)

            # message2: SizedCString
            _fmt += f'I{len(self.message2)}sB'
            _data.extend([len(self.message2) + 1, self.message2.encode('utf-8'), 0])

            # chat_tag2: PlayerChatTag
            _fmt += 'B'
            _data.append(self.chat_tag2.value)

        elif self.chat_type == ChatType.CHANNEL:
            _fmt += f'{len(self.channel_name)}sBQI{len(self.message3)}sBB'
            _data.extend([self.channel_name.encode('utf-8'), 0, self.target4, len(self.message3) + 1, self.message3.encode('utf-8'), 0, self.chat_tag3.value])
        elif self.chat_type in {ChatType.SYSTEM, ChatType.SAY, ChatType.PARTY, ChatType.RAID, ChatType.GUILD, ChatType.OFFICER, ChatType.YELL, ChatType.WHISPER, ChatType.WHISPER_INFORM, ChatType.REPLY, ChatType.EMOTE, ChatType.TEXT_EMOTE, ChatType.CHANNEL_JOIN, ChatType.CHANNEL_LEAVE, ChatType.CHANNEL_LIST, ChatType.CHANNEL_NOTICE, ChatType.CHANNEL_NOTICE_USER, ChatType.AFK, ChatType.DND, ChatType.IGNORED, ChatType.SKILL, ChatType.LOOT, ChatType.MONEY, ChatType.OPENING, ChatType.TRADESKILLS, ChatType.PET_INFO, ChatType.COMBAT_MISC_INFO, ChatType.COMBAT_XP_GAIN, ChatType.COMBAT_HONOR_GAIN, ChatType.COMBAT_FACTION_CHANGE, ChatType.RAID_LEADER, ChatType.RAID_WARNING, ChatType.FILTERED, ChatType.BATTLEGROUND, ChatType.BATTLEGROUND_LEADER, ChatType.RESTRICTED}:
            _fmt += f'QI{len(self.message4)}sBBI{len(self.sender_name)}sB'
            _data.extend([self.target5, len(self.message4) + 1, self.message4.encode('utf-8'), 0, self.chat_tag4.value, len(self.sender_name) + 1, self.sender_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 5

        if self.chat_type in {ChatType.MONSTER_SAY, ChatType.MONSTER_PARTY, ChatType.MONSTER_YELL, ChatType.MONSTER_WHISPER, ChatType.RAID_BOSS_WHISPER, ChatType.RAID_BOSS_EMOTE, ChatType.MONSTER_EMOTE}:
            _size += 11 + len(self.sender) + self.target1.size() + len(self.message1)
        elif self.chat_type in {ChatType.BG_SYSTEM_NEUTRAL, ChatType.BG_SYSTEM_ALLIANCE, ChatType.BG_SYSTEM_HORDE}:
            _size += 6 + self.target2.size() + len(self.message2)
        elif self.chat_type == ChatType.CHANNEL:
            _size += 15 + len(self.channel_name) + len(self.message3)
        elif self.chat_type in {ChatType.SYSTEM, ChatType.SAY, ChatType.PARTY, ChatType.RAID, ChatType.GUILD, ChatType.OFFICER, ChatType.YELL, ChatType.WHISPER, ChatType.WHISPER_INFORM, ChatType.REPLY, ChatType.EMOTE, ChatType.TEXT_EMOTE, ChatType.CHANNEL_JOIN, ChatType.CHANNEL_LEAVE, ChatType.CHANNEL_LIST, ChatType.CHANNEL_NOTICE, ChatType.CHANNEL_NOTICE_USER, ChatType.AFK, ChatType.DND, ChatType.IGNORED, ChatType.SKILL, ChatType.LOOT, ChatType.MONEY, ChatType.OPENING, ChatType.TRADESKILLS, ChatType.PET_INFO, ChatType.COMBAT_MISC_INFO, ChatType.COMBAT_XP_GAIN, ChatType.COMBAT_HONOR_GAIN, ChatType.COMBAT_FACTION_CHANGE, ChatType.RAID_LEADER, ChatType.RAID_WARNING, ChatType.FILTERED, ChatType.BATTLEGROUND, ChatType.BATTLEGROUND_LEADER, ChatType.RESTRICTED}:
            _size += 19 + len(self.message4) + len(self.sender_name)

        return _size


@dataclasses.dataclass
class CMSG_COMMENTATOR_ENABLE:
    option: CommentatorEnableOption

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_COMMENTATOR_ENABLE:
        # option: CommentatorEnableOption
        option = CommentatorEnableOption(await read_int(reader, 4))

        return CMSG_COMMENTATOR_ENABLE(
            option=option,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x03B4))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.option.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CLEAR_TARGET:
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CLEAR_TARGET:
        # target: Guid
        target = await read_int(reader, 8)

        return SMSG_CLEAR_TARGET(
            target=target,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x03BE))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.target)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CROSSED_INEBRIATION_THRESHOLD:
    player: int
    state: int
    item: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CROSSED_INEBRIATION_THRESHOLD:
        # player: Guid
        player = await read_int(reader, 8)

        # state: u32
        state = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        return SMSG_CROSSED_INEBRIATION_THRESHOLD(
            player=player,
            state=state,
            item=item,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x03C0))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.player, self.state, self.item])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_KICK_REASON:
    reason: int
    text: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_KICK_REASON:
        # reason: u8
        reason = await read_int(reader, 1)

        # text: CString
        text = await read_cstring(reader)

        return SMSG_KICK_REASON(
            reason=reason,
            text=text,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03C4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'B{len(self.text)}sB'
        _data.extend([self.reason, self.text.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.text)


@dataclasses.dataclass
class MSG_RAID_READY_CHECK_FINISHED_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RAID_READY_CHECK_FINISHED_Client:
        return MSG_RAID_READY_CHECK_FINISHED_Client()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x03C5))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_COMPLAIN:
    complaint_type: SpamType
    offender: int
    unknown1: typing.Optional[int] = None
    mail_id: typing.Optional[int] = None
    unknown2: typing.Optional[int] = None
    language: typing.Optional[int] = None
    message_type: typing.Optional[int] = None
    channel_id: typing.Optional[int] = None
    time: typing.Optional[int] = None
    description: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_COMPLAIN:
        unknown1 = None
        mail_id = None
        unknown2 = None
        language = None
        message_type = None
        channel_id = None
        time = None
        description = None
        # complaint_type: SpamType
        complaint_type = SpamType(await read_int(reader, 1))

        # offender: Guid
        offender = await read_int(reader, 8)

        if complaint_type == SpamType.MAIL:
            # unknown1: u32
            unknown1 = await read_int(reader, 4)

            # mail_id: u32
            mail_id = await read_int(reader, 4)

            # unknown2: u32
            unknown2 = await read_int(reader, 4)

        elif complaint_type == SpamType.CHAT:
            # language: u32
            language = await read_int(reader, 4)

            # message_type: u32
            message_type = await read_int(reader, 4)

            # channel_id: u32
            channel_id = await read_int(reader, 4)

            # time: u32
            time = await read_int(reader, 4)

            # description: CString
            description = await read_cstring(reader)

        return CMSG_COMPLAIN(
            complaint_type=complaint_type,
            offender=offender,
            unknown1=unknown1,
            mail_id=mail_id,
            unknown2=unknown2,
            language=language,
            message_type=message_type,
            channel_id=channel_id,
            time=time,
            description=description,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x03C6))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BQ'
        _data.extend([self.complaint_type.value, self.offender])
        if self.complaint_type == SpamType.MAIL:
            _fmt += 'III'
            _data.extend([self.unknown1, self.mail_id, self.unknown2])
        elif self.complaint_type == SpamType.CHAT:
            _fmt += f'IIII{len(self.description)}sB'
            _data.extend([self.language, self.message_type, self.channel_id, self.time, self.description.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 9

        if self.complaint_type == SpamType.MAIL:
            _size += 12
        elif self.complaint_type == SpamType.CHAT:
            _size += 17 + len(self.description)

        return _size


@dataclasses.dataclass
class SMSG_COMPLAIN_RESULT:
    unknown: int
    window_result: ComplainResultWindow

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_COMPLAIN_RESULT:
        # unknown: u8
        unknown = await read_int(reader, 1)

        # window_result: ComplainResultWindow
        window_result = ComplainResultWindow(await read_int(reader, 1))

        return SMSG_COMPLAIN_RESULT(
            unknown=unknown,
            window_result=window_result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 2, 0x03C7))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.unknown, self.window_result.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_FEATURE_SYSTEM_STATUS:
    complaint_status: ComplaintStatus
    voice_chat_enabled: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FEATURE_SYSTEM_STATUS:
        # complaint_status: ComplaintStatus
        complaint_status = ComplaintStatus(await read_int(reader, 1))

        # voice_chat_enabled: Bool8
        voice_chat_enabled = await read_bool(reader, 1)

        return SMSG_FEATURE_SYSTEM_STATUS(
            complaint_status=complaint_status,
            voice_chat_enabled=voice_chat_enabled,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 2, 0x03C8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.complaint_status.value, self.voice_chat_enabled])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CHANNEL_DISPLAY_LIST:
    channel: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_DISPLAY_LIST:
        # channel: CString
        channel = await read_cstring(reader)

        return CMSG_CHANNEL_DISPLAY_LIST(
            channel=channel,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x03D1))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel)}sB'
        _data.extend([self.channel.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.channel)


@dataclasses.dataclass
class CMSG_SET_ACTIVE_VOICE_CHANNEL:
    unknown1: int
    unknown2: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_ACTIVE_VOICE_CHANNEL:
        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # unknown2: CString
        unknown2 = await read_cstring(reader)

        return CMSG_SET_ACTIVE_VOICE_CHANNEL(
            unknown1=unknown1,
            unknown2=unknown2,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x03D2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'I{len(self.unknown2)}sB'
        _data.extend([self.unknown1, self.unknown2.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + len(self.unknown2)


@dataclasses.dataclass
class CMSG_GET_CHANNEL_MEMBER_COUNT:
    channel: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GET_CHANNEL_MEMBER_COUNT:
        # channel: CString
        channel = await read_cstring(reader)

        return CMSG_GET_CHANNEL_MEMBER_COUNT(
            channel=channel,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x03D3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel)}sB'
        _data.extend([self.channel.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.channel)


@dataclasses.dataclass
class SMSG_CHANNEL_MEMBER_COUNT:
    channel: str
    flags: int
    amount_of_members: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHANNEL_MEMBER_COUNT:
        # channel: CString
        channel = await read_cstring(reader)

        # flags: u8
        flags = await read_int(reader, 1)

        # amount_of_members: u32
        amount_of_members = await read_int(reader, 4)

        return SMSG_CHANNEL_MEMBER_COUNT(
            channel=channel,
            flags=flags,
            amount_of_members=amount_of_members,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03D4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.channel)}sBBI'
        _data.extend([self.channel.encode('utf-8'), 0, self.flags, self.amount_of_members])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 6 + len(self.channel)


@dataclasses.dataclass
class CMSG_CHANNEL_VOICE_ON:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_VOICE_ON:
        return CMSG_CHANNEL_VOICE_ON()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x03D5))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_REPORT_PVP_AFK:
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REPORT_PVP_AFK:
        # player: Guid
        player = await read_int(reader, 8)

        return CMSG_REPORT_PVP_AFK(
            player=player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x03E3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.player)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_BANKER_ACTIVATE:
    bank: int
    full_update: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_BANKER_ACTIVATE:
        # bank: Guid
        bank = await read_int(reader, 8)

        # full_update: Bool8
        full_update = await read_bool(reader, 1)

        return CMSG_GUILD_BANKER_ACTIVATE(
            bank=bank,
            full_update=full_update,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x03E5))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.bank, self.full_update])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_BANK_QUERY_TAB:
    bank: int
    tab: int
    full_update: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_BANK_QUERY_TAB:
        # bank: Guid
        bank = await read_int(reader, 8)

        # tab: u8
        tab = await read_int(reader, 1)

        # full_update: Bool8
        full_update = await read_bool(reader, 1)

        return CMSG_GUILD_BANK_QUERY_TAB(
            bank=bank,
            tab=tab,
            full_update=full_update,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(10 + 4, 0x03E6))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QBB'
        _data.extend([self.bank, self.tab, self.full_update])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GUILD_BANK_LIST:
    bank_balance: int
    tab_id: int
    amount_of_allowed_item_withdraws: int
    tab_result: GuildBankTabResult
    slot_updates: typing.List[GuildBankSlot]
    tabs: typing.Optional[typing.List[GuildBankTab]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_BANK_LIST:
        amount_of_bank_tabs = None
        tabs = None
        # bank_balance: u64
        bank_balance = await read_int(reader, 8)

        # tab_id: u8
        tab_id = await read_int(reader, 1)

        # amount_of_allowed_item_withdraws: u32
        amount_of_allowed_item_withdraws = await read_int(reader, 4)

        # tab_result: GuildBankTabResult
        tab_result = GuildBankTabResult(await read_int(reader, 1))

        if tab_result == GuildBankTabResult.PRESENT:
            # amount_of_bank_tabs: u8
            amount_of_bank_tabs = await read_int(reader, 1)

            # tabs: GuildBankTab[amount_of_bank_tabs]
            tabs = []
            for _ in range(0, amount_of_bank_tabs):
                tabs.append(await GuildBankTab.read(reader))

        # amount_of_slot_updates: u8
        amount_of_slot_updates = await read_int(reader, 1)

        # slot_updates: GuildBankSlot[amount_of_slot_updates]
        slot_updates = []
        for _ in range(0, amount_of_slot_updates):
            slot_updates.append(await GuildBankSlot.read(reader))

        return SMSG_GUILD_BANK_LIST(
            bank_balance=bank_balance,
            tab_id=tab_id,
            amount_of_allowed_item_withdraws=amount_of_allowed_item_withdraws,
            tab_result=tab_result,
            tabs=tabs,
            slot_updates=slot_updates,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03E7))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QBIB'
        _data.extend([self.bank_balance, self.tab_id, self.amount_of_allowed_item_withdraws, self.tab_result.value])
        if self.tab_result == GuildBankTabResult.PRESENT:
            _fmt += 'B'
            _data.append(len(self.tabs))
            # tabs: GuildBankTab[amount_of_bank_tabs]
            for i in self.tabs:
                _fmt, _data = i.write(_fmt, _data)

        # amount_of_slot_updates: u8
        _fmt += 'B'
        _data.append(len(self.slot_updates))

        # slot_updates: GuildBankSlot[amount_of_slot_updates]
        for i in self.slot_updates:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 15 + sum([i.size() for i in self.slot_updates])

        if self.tab_result == GuildBankTabResult.PRESENT:
            _size += 1 + sum([i.size() for i in self.tabs])

        return _size


@dataclasses.dataclass
class CMSG_GUILD_BANK_SWAP_ITEMS:
    bank: int
    source: BankSwapSource
    unknown5: typing.List[int]
    bank_destination_tab: typing.Optional[int] = None
    bank_destination_slot: typing.Optional[int] = None
    unknown1: typing.Optional[int] = None
    bank_source_tab: typing.Optional[int] = None
    bank_source_slot: typing.Optional[int] = None
    item1: typing.Optional[int] = None
    unknown2: typing.Optional[int] = None
    amount: typing.Optional[int] = None
    bank_tab: typing.Optional[int] = None
    bank_slot: typing.Optional[int] = None
    item2: typing.Optional[int] = None
    mode: typing.Optional[BankSwapStoreMode] = None
    auto_count: typing.Optional[int] = None
    unknown3: typing.Optional[int] = None
    unknown4: typing.Optional[int] = None
    player_bag: typing.Optional[int] = None
    player_bag_slot: typing.Optional[int] = None
    bank_to_character_transfer: typing.Optional[bool] = None
    split_amount: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_BANK_SWAP_ITEMS:
        bank_destination_tab = None
        bank_destination_slot = None
        unknown1 = None
        bank_source_tab = None
        bank_source_slot = None
        item1 = None
        unknown2 = None
        amount = None
        bank_tab = None
        bank_slot = None
        item2 = None
        mode = None
        auto_count = None
        unknown3 = None
        unknown4 = None
        player_bag = None
        player_bag_slot = None
        bank_to_character_transfer = None
        split_amount = None
        _size = 0

        # bank: Guid
        bank = await read_int(reader, 8)
        _size += 8

        # source: BankSwapSource
        source = BankSwapSource(await read_int(reader, 1))
        _size += 1

        if source == BankSwapSource.BANK:
            # bank_destination_tab: u8
            bank_destination_tab = await read_int(reader, 1)
            _size += 1

            # bank_destination_slot: u8
            bank_destination_slot = await read_int(reader, 1)
            _size += 1

            # unknown1: u32
            unknown1 = await read_int(reader, 4)
            _size += 4

            # bank_source_tab: u8
            bank_source_tab = await read_int(reader, 1)
            _size += 1

            # bank_source_slot: u8
            bank_source_slot = await read_int(reader, 1)
            _size += 1

            # item1: Item
            item1 = await read_int(reader, 4)
            _size += 4

            # unknown2: u8
            unknown2 = await read_int(reader, 1)
            _size += 1

            # amount: u8
            amount = await read_int(reader, 1)
            _size += 1

        elif source == BankSwapSource.INVENTORY:
            # bank_tab: u8
            bank_tab = await read_int(reader, 1)
            _size += 1

            # bank_slot: u8
            bank_slot = await read_int(reader, 1)
            _size += 1

            # item2: Item
            item2 = await read_int(reader, 4)
            _size += 4

            # mode: BankSwapStoreMode
            mode = BankSwapStoreMode(await read_int(reader, 1))
            _size += 1

            if mode == BankSwapStoreMode.AUTOMATIC:
                # auto_count: u32
                auto_count = await read_int(reader, 4)
                _size += 4

                # unknown3: u8
                unknown3 = await read_int(reader, 1)
                _size += 1

                # unknown4: u8
                unknown4 = await read_int(reader, 1)
                _size += 1

            elif mode == BankSwapStoreMode.MANUAL:
                # player_bag: u8
                player_bag = await read_int(reader, 1)
                _size += 1

                # player_bag_slot: u8
                player_bag_slot = await read_int(reader, 1)
                _size += 1

                # bank_to_character_transfer: Bool8
                bank_to_character_transfer = await read_bool(reader, 1)
                _size += 1

                # split_amount: u8
                split_amount = await read_int(reader, 1)
                _size += 1

        # unknown5: u8[-]
        unknown5 = []
        while _size < body_size:
            unknown5.append(await read_int(reader, 1))
            _size += 1

        return CMSG_GUILD_BANK_SWAP_ITEMS(
            bank=bank,
            source=source,
            bank_destination_tab=bank_destination_tab,
            bank_destination_slot=bank_destination_slot,
            unknown1=unknown1,
            bank_source_tab=bank_source_tab,
            bank_source_slot=bank_source_slot,
            item1=item1,
            unknown2=unknown2,
            amount=amount,
            bank_tab=bank_tab,
            bank_slot=bank_slot,
            item2=item2,
            mode=mode,
            auto_count=auto_count,
            unknown3=unknown3,
            unknown4=unknown4,
            player_bag=player_bag,
            player_bag_slot=player_bag_slot,
            bank_to_character_transfer=bank_to_character_transfer,
            split_amount=split_amount,
            unknown5=unknown5,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x03E8))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.bank, self.source.value])
        if self.source == BankSwapSource.BANK:
            _fmt += 'BBIBBIBB'
            _data.extend([self.bank_destination_tab, self.bank_destination_slot, self.unknown1, self.bank_source_tab, self.bank_source_slot, self.item1, self.unknown2, self.amount])
        elif self.source == BankSwapSource.INVENTORY:
            _fmt += 'BBIB'
            _data.extend([self.bank_tab, self.bank_slot, self.item2, self.mode.value])
            if self.mode == BankSwapStoreMode.AUTOMATIC:
                _fmt += 'IBB'
                _data.extend([self.auto_count, self.unknown3, self.unknown4])
            elif self.mode == BankSwapStoreMode.MANUAL:
                _fmt += 'BBBB'
                _data.extend([self.player_bag, self.player_bag_slot, self.bank_to_character_transfer, self.split_amount])
        # unknown5: u8[-]
        _fmt += f'{len(self.unknown5)}B'
        _data.extend([*self.unknown5])

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 9 + 1 * len(self.unknown5)

        if self.source == BankSwapSource.BANK:
            _size += 14
        elif self.source == BankSwapSource.INVENTORY:
            _size += 7

            if self.mode == BankSwapStoreMode.AUTOMATIC:
                _size += 6
            elif self.mode == BankSwapStoreMode.MANUAL:
                _size += 4


        return _size


@dataclasses.dataclass
class CMSG_GUILD_BANK_BUY_TAB:
    banker: int
    tab: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_BANK_BUY_TAB:
        # banker: Guid
        banker = await read_int(reader, 8)

        # tab: u8
        tab = await read_int(reader, 1)

        return CMSG_GUILD_BANK_BUY_TAB(
            banker=banker,
            tab=tab,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x03E9))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.banker, self.tab])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_BANK_UPDATE_TAB:
    bank: int
    tab: int
    name: str
    icon: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_BANK_UPDATE_TAB:
        # bank: Guid
        bank = await read_int(reader, 8)

        # tab: u8
        tab = await read_int(reader, 1)

        # name: CString
        name = await read_cstring(reader)

        # icon: CString
        icon = await read_cstring(reader)

        return CMSG_GUILD_BANK_UPDATE_TAB(
            bank=bank,
            tab=tab,
            name=name,
            icon=icon,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x03EA))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'QB{len(self.name)}sB{len(self.icon)}sB'
        _data.extend([self.bank, self.tab, self.name.encode('utf-8'), 0, self.icon.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 11 + len(self.name) + len(self.icon)


@dataclasses.dataclass
class CMSG_GUILD_BANK_DEPOSIT_MONEY:
    bank: int
    money: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_BANK_DEPOSIT_MONEY:
        # bank: Guid
        bank = await read_int(reader, 8)

        # money: Gold
        money = await read_int(reader, 4)

        return CMSG_GUILD_BANK_DEPOSIT_MONEY(
            bank=bank,
            money=money,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x03EB))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.bank, self.money])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_BANK_WITHDRAW_MONEY:
    bank: int
    money: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_BANK_WITHDRAW_MONEY:
        # bank: Guid
        bank = await read_int(reader, 8)

        # money: Gold
        money = await read_int(reader, 4)

        return CMSG_GUILD_BANK_WITHDRAW_MONEY(
            bank=bank,
            money=money,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x03EC))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.bank, self.money])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_GUILD_BANK_LOG_QUERY_Client:
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_GUILD_BANK_LOG_QUERY_Client:
        # slot: u8
        slot = await read_int(reader, 1)

        return MSG_GUILD_BANK_LOG_QUERY_Client(
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x03ED))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.slot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_GUILD_BANK_LOG_QUERY_Server:
    unix_time: int
    slot: int
    money_logs: typing.List[MoneyLogItem]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_GUILD_BANK_LOG_QUERY_Server:
        # unix_time: u32
        unix_time = await read_int(reader, 4)

        # slot: u8
        slot = await read_int(reader, 1)

        # amount_of_money_logs: u8
        amount_of_money_logs = await read_int(reader, 1)

        # money_logs: MoneyLogItem[amount_of_money_logs]
        money_logs = []
        for _ in range(0, amount_of_money_logs):
            money_logs.append(await MoneyLogItem.read(reader))

        return MSG_GUILD_BANK_LOG_QUERY_Server(
            unix_time=unix_time,
            slot=slot,
            money_logs=money_logs,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03ED))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IBB'
        _data.extend([self.unix_time, self.slot, len(self.money_logs)])
        # money_logs: MoneyLogItem[amount_of_money_logs]
        for i in self.money_logs:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 6 + 17 * len(self.money_logs)


@dataclasses.dataclass
class CMSG_SET_CHANNEL_WATCH:
    channel: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_CHANNEL_WATCH:
        # channel: CString
        channel = await read_cstring(reader)

        return CMSG_SET_CHANNEL_WATCH(
            channel=channel,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x03EE))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel)}sB'
        _data.extend([self.channel.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.channel)


@dataclasses.dataclass
class SMSG_USERLIST_ADD:
    player: int
    player_flags: int
    flags: int
    amount_of_players: int
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_USERLIST_ADD:
        # player: Guid
        player = await read_int(reader, 8)

        # player_flags: u8
        player_flags = await read_int(reader, 1)

        # flags: u8
        flags = await read_int(reader, 1)

        # amount_of_players: u32
        amount_of_players = await read_int(reader, 4)

        # name: CString
        name = await read_cstring(reader)

        return SMSG_USERLIST_ADD(
            player=player,
            player_flags=player_flags,
            flags=flags,
            amount_of_players=amount_of_players,
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03EF))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QBBI{len(self.name)}sB'
        _data.extend([self.player, self.player_flags, self.flags, self.amount_of_players, self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 15 + len(self.name)


@dataclasses.dataclass
class SMSG_USERLIST_REMOVE:
    player: int
    flags: int
    amount_of_players: int
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_USERLIST_REMOVE:
        # player: Guid
        player = await read_int(reader, 8)

        # flags: u8
        flags = await read_int(reader, 1)

        # amount_of_players: u32
        amount_of_players = await read_int(reader, 4)

        # name: CString
        name = await read_cstring(reader)

        return SMSG_USERLIST_REMOVE(
            player=player,
            flags=flags,
            amount_of_players=amount_of_players,
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03F0))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QBI{len(self.name)}sB'
        _data.extend([self.player, self.flags, self.amount_of_players, self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 14 + len(self.name)


@dataclasses.dataclass
class SMSG_USERLIST_UPDATE:
    player: int
    player_flags: int
    flags: int
    amount_of_players: int
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_USERLIST_UPDATE:
        # player: Guid
        player = await read_int(reader, 8)

        # player_flags: u8
        player_flags = await read_int(reader, 1)

        # flags: u8
        flags = await read_int(reader, 1)

        # amount_of_players: u32
        amount_of_players = await read_int(reader, 4)

        # name: CString
        name = await read_cstring(reader)

        return SMSG_USERLIST_UPDATE(
            player=player,
            player_flags=player_flags,
            flags=flags,
            amount_of_players=amount_of_players,
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03F1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QBBI{len(self.name)}sB'
        _data.extend([self.player, self.player_flags, self.flags, self.amount_of_players, self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 15 + len(self.name)


@dataclasses.dataclass
class CMSG_CLEAR_CHANNEL_WATCH:
    channel: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CLEAR_CHANNEL_WATCH:
        # channel: CString
        channel = await read_cstring(reader)

        return CMSG_CLEAR_CHANNEL_WATCH(
            channel=channel,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x03F2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel)}sB'
        _data.extend([self.channel.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.channel)


@dataclasses.dataclass
class SMSG_INSPECT_TALENT:
    player: int
    talent_data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INSPECT_TALENT:
        _size = 0

        # player: PackedGuid
        player = await read_packed_guid(reader)
        _size += packed_guid_size(player)

        # talent_data: u8[-]
        talent_data = []
        while _size < body_size:
            talent_data.append(await read_int(reader, 1))
            _size += 1

        return SMSG_INSPECT_TALENT(
            player=player,
            talent_data=talent_data,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03F3))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # talent_data: u8[-]
        _fmt += f'{len(self.talent_data)}B'
        _data.extend([*self.talent_data])

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player) + 1 * len(self.talent_data)


@dataclasses.dataclass
class CMSG_SPELLCLICK:
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SPELLCLICK:
        # target: Guid
        target = await read_int(reader, 8)

        return CMSG_SPELLCLICK(
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x03F7))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.target)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_LIST:
    creature: int
    master_looter: int
    group_looter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_LIST:
        # creature: Guid
        creature = await read_int(reader, 8)

        # master_looter: PackedGuid
        master_looter = await read_packed_guid(reader)

        # group_looter: PackedGuid
        group_looter = await read_packed_guid(reader)

        return SMSG_LOOT_LIST(
            creature=creature,
            master_looter=master_looter,
            group_looter=group_looter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03F8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.creature)
        # master_looter: PackedGuid
        _fmt, _data = packed_guid_write(self.master_looter, _fmt, _data)

        # group_looter: PackedGuid
        _fmt, _data = packed_guid_write(self.group_looter, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.master_looter) + packed_guid_size(self.group_looter)


@dataclasses.dataclass
class MSG_GUILD_PERMISSIONS_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_GUILD_PERMISSIONS_Client:
        return MSG_GUILD_PERMISSIONS_Client()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x03FC))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_GUILD_PERMISSIONS_Server:
    id: int
    rights: int
    gold_limit_per_day: int
    purchased_bank_tabs: int
    bank_tabs: typing.List[BankTab]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_GUILD_PERMISSIONS_Server:
        # id: u32
        id = await read_int(reader, 4)

        # rights: u32
        rights = await read_int(reader, 4)

        # gold_limit_per_day: Gold
        gold_limit_per_day = await read_int(reader, 4)

        # purchased_bank_tabs: u8
        purchased_bank_tabs = await read_int(reader, 1)

        # bank_tabs: BankTab[6]
        bank_tabs = []
        for _ in range(0, 6):
            bank_tabs.append(await BankTab.read(reader))

        return MSG_GUILD_PERMISSIONS_Server(
            id=id,
            rights=rights,
            gold_limit_per_day=gold_limit_per_day,
            purchased_bank_tabs=purchased_bank_tabs,
            bank_tabs=bank_tabs,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(61 + 2, 0x03FC))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIB'
        _data.extend([self.id, self.rights, self.gold_limit_per_day, self.purchased_bank_tabs])
        # bank_tabs: BankTab[6]
        for i in self.bank_tabs:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_GUILD_BANK_MONEY_WITHDRAWN_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_GUILD_BANK_MONEY_WITHDRAWN_Client:
        return MSG_GUILD_BANK_MONEY_WITHDRAWN_Client()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x03FD))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_GUILD_BANK_MONEY_WITHDRAWN_Server:
    remaining_withdraw_amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_GUILD_BANK_MONEY_WITHDRAWN_Server:
        # remaining_withdraw_amount: u32
        remaining_withdraw_amount = await read_int(reader, 4)

        return MSG_GUILD_BANK_MONEY_WITHDRAWN_Server(
            remaining_withdraw_amount=remaining_withdraw_amount,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x03FD))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.remaining_withdraw_amount)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_GUILD_EVENT_LOG_QUERY_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_GUILD_EVENT_LOG_QUERY_Client:
        return MSG_GUILD_EVENT_LOG_QUERY_Client()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x03FE))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_GUILD_EVENT_LOG_QUERY_Server:
    events: typing.List[GuildLogEvent]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_GUILD_EVENT_LOG_QUERY_Server:
        # amount_of_events: u8
        amount_of_events = await read_int(reader, 1)

        # events: GuildLogEvent[amount_of_events]
        events = []
        for _ in range(0, amount_of_events):
            events.append(await GuildLogEvent.read(reader))

        return MSG_GUILD_EVENT_LOG_QUERY_Server(
            events=events,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03FE))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(len(self.events))
        # events: GuildLogEvent[amount_of_events]
        for i in self.events:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + sum([i.size() for i in self.events])


@dataclasses.dataclass
class CMSG_GET_MIRRORIMAGE_DATA:
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GET_MIRRORIMAGE_DATA:
        # target: Guid
        target = await read_int(reader, 8)

        return CMSG_GET_MIRRORIMAGE_DATA(
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0400))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.target)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MIRRORIMAGE_DATA:
    guid: int
    display_id: int
    race: Race
    gender: Gender
    skin_color: int
    face: int
    hair_style: int
    hair_color: int
    facial_hair: int
    guild_id: int
    display_ids: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MIRRORIMAGE_DATA:
        # guid: Guid
        guid = await read_int(reader, 8)

        # display_id: u32
        display_id = await read_int(reader, 4)

        # race: Race
        race = Race(await read_int(reader, 1))

        # gender: Gender
        gender = Gender(await read_int(reader, 1))

        # skin_color: u8
        skin_color = await read_int(reader, 1)

        # face: u8
        face = await read_int(reader, 1)

        # hair_style: u8
        hair_style = await read_int(reader, 1)

        # hair_color: u8
        hair_color = await read_int(reader, 1)

        # facial_hair: u8
        facial_hair = await read_int(reader, 1)

        # guild_id: u32
        guild_id = await read_int(reader, 4)

        # display_ids: u32[11]
        display_ids = []
        for _ in range(0, 11):
            display_ids.append(await read_int(reader, 4))

        return SMSG_MIRRORIMAGE_DATA(
            guid=guid,
            display_id=display_id,
            race=race,
            gender=gender,
            skin_color=skin_color,
            face=face,
            hair_style=hair_style,
            hair_color=hair_color,
            facial_hair=facial_hair,
            guild_id=guild_id,
            display_ids=display_ids,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(67 + 2, 0x0401))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QIBBBBBBBI{len(self.display_ids)}I'
        _data.extend([self.guid, self.display_id, self.race.value, self.gender.value, self.skin_color, self.face, self.hair_style, self.hair_color, self.facial_hair, self.guild_id, *self.display_ids])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_KEEP_ALIVE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_KEEP_ALIVE:
        return CMSG_KEEP_ALIVE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0406))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_OPT_OUT_OF_LOOT:
    pass_on_loot: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_OPT_OUT_OF_LOOT:
        # pass_on_loot: Bool32
        pass_on_loot = await read_bool(reader, 4)

        return CMSG_OPT_OUT_OF_LOOT(
            pass_on_loot=pass_on_loot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0408))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.pass_on_loot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_QUERY_GUILD_BANK_TEXT_Client:
    tab: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_QUERY_GUILD_BANK_TEXT_Client:
        # tab: u8
        tab = await read_int(reader, 1)

        return MSG_QUERY_GUILD_BANK_TEXT_Client(
            tab=tab,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x0409))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.tab)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_QUERY_GUILD_BANK_TEXT_Server:
    tab: int
    text: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_QUERY_GUILD_BANK_TEXT_Server:
        # tab: u8
        tab = await read_int(reader, 1)

        # text: CString
        text = await read_cstring(reader)

        return MSG_QUERY_GUILD_BANK_TEXT_Server(
            tab=tab,
            text=text,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0409))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'B{len(self.text)}sB'
        _data.extend([self.tab, self.text.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.text)


@dataclasses.dataclass
class CMSG_SET_GUILD_BANK_TEXT:
    tab: int
    text: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_GUILD_BANK_TEXT:
        # tab: u8
        tab = await read_int(reader, 1)

        # text: CString
        text = await read_cstring(reader)

        return CMSG_SET_GUILD_BANK_TEXT(
            tab=tab,
            text=text,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x040A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'B{len(self.text)}sB'
        _data.extend([self.tab, self.text.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.text)


@dataclasses.dataclass
class CMSG_GRANT_LEVEL:
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GRANT_LEVEL:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        return CMSG_GRANT_LEVEL(
            player=player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x040C))
        _fmt = "<6s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player)


@dataclasses.dataclass
class SMSG_OVERRIDE_LIGHT:
    default_id: int
    id_override: int
    fade_in_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_OVERRIDE_LIGHT:
        # default_id: u32
        default_id = await read_int(reader, 4)

        # id_override: u32
        id_override = await read_int(reader, 4)

        # fade_in_time: Seconds
        fade_in_time = await read_int(reader, 4)

        return SMSG_OVERRIDE_LIGHT(
            default_id=default_id,
            id_override=id_override,
            fade_in_time=fade_in_time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0411))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'III'
        _data.extend([self.default_id, self.id_override, self.fade_in_time])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TOTEM_CREATED:
    slot: int
    totem: int
    duration: int
    spell: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TOTEM_CREATED:
        # slot: u8
        slot = await read_int(reader, 1)

        # totem: Guid
        totem = await read_int(reader, 8)

        # duration: u32
        duration = await read_int(reader, 4)

        # spell: Spell
        spell = await read_int(reader, 4)

        return SMSG_TOTEM_CREATED(
            slot=slot,
            totem=totem,
            duration=duration,
            spell=spell,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(17 + 2, 0x0412))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BQII'
        _data.extend([self.slot, self.totem, self.duration, self.spell])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TOTEM_DESTROYED:
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TOTEM_DESTROYED:
        # slot: u8
        slot = await read_int(reader, 1)

        return CMSG_TOTEM_DESTROYED(
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x0413))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.slot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUESTGIVER_STATUS_MULTIPLE_QUERY:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_STATUS_MULTIPLE_QUERY:
        return CMSG_QUESTGIVER_STATUS_MULTIPLE_QUERY()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0416))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_STATUS_MULTIPLE:
    statuses: typing.List[QuestGiverStatusReport]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_STATUS_MULTIPLE:
        # amount_of_statuses: u32
        amount_of_statuses = await read_int(reader, 4)

        # statuses: QuestGiverStatusReport[amount_of_statuses]
        statuses = []
        for _ in range(0, amount_of_statuses):
            statuses.append(await QuestGiverStatusReport.read(reader))

        return SMSG_QUESTGIVER_STATUS_MULTIPLE(
            statuses=statuses,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0417))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.statuses))
        # statuses: QuestGiverStatusReport[amount_of_statuses]
        for i in self.statuses:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + 9 * len(self.statuses)


@dataclasses.dataclass
class CMSG_SET_PLAYER_DECLINED_NAMES:
    player: int
    name: str
    declined_names: typing.List[str]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_PLAYER_DECLINED_NAMES:
        # player: Guid
        player = await read_int(reader, 8)

        # name: CString
        name = await read_cstring(reader)

        # declined_names: CString[5]
        declined_names = []
        for _ in range(0, 5):
            declined_names.append(await read_cstring(reader))

        return CMSG_SET_PLAYER_DECLINED_NAMES(
            player=player,
            name=name,
            declined_names=declined_names,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0418))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.name)}sB'
        _data.extend([self.player, self.name.encode('utf-8'), 0])
        # declined_names: CString[5]
        for i in self.declined_names:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.name) + sum([len(i) + 1 for i in self.declined_names])


@dataclasses.dataclass
class SMSG_SET_PLAYER_DECLINED_NAMES_RESULT:
    result: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_PLAYER_DECLINED_NAMES_RESULT:
        # result: u32
        result = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_SET_PLAYER_DECLINED_NAMES_RESULT(
            result=result,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0419))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.result, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SEND_UNLEARN_SPELLS:
    spells: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SEND_UNLEARN_SPELLS:
        # amount_of_spells: u32
        amount_of_spells = await read_int(reader, 4)

        # spells: Spell[amount_of_spells]
        spells = []
        for _ in range(0, amount_of_spells):
            spells.append(await read_int(reader, 4))

        return SMSG_SEND_UNLEARN_SPELLS(
            spells=spells,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x041D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.spells))
        # spells: Spell[amount_of_spells]
        _fmt += f'len({self.spells})I'
        _data.extend(self.spells)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + 4 * len(self.spells)


@dataclasses.dataclass
class SMSG_PROPOSE_LEVEL_GRANT:
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PROPOSE_LEVEL_GRANT:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        return SMSG_PROPOSE_LEVEL_GRANT(
            player=player,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x041E))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player)


@dataclasses.dataclass
class CMSG_ACCEPT_LEVEL_GRANT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ACCEPT_LEVEL_GRANT:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return CMSG_ACCEPT_LEVEL_GRANT(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x041F))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_REFER_A_FRIEND_FAILURE:
    error: ReferAFriendError
    target_name: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_REFER_A_FRIEND_FAILURE:
        target_name = None
        # error: ReferAFriendError
        error = ReferAFriendError(await read_int(reader, 4))

        if error == ReferAFriendError.NOT_IN_GROUP:
            # target_name: CString
            target_name = await read_cstring(reader)

        return SMSG_REFER_A_FRIEND_FAILURE(
            error=error,
            target_name=target_name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0420))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.error.value)
        if self.error == ReferAFriendError.NOT_IN_GROUP:
            _fmt += f'{len(self.target_name)}sB'
            _data.extend([self.target_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        if self.error == ReferAFriendError.NOT_IN_GROUP:
            _size += 1 + len(self.target_name)

        return _size


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_SET_FLYING:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_SET_FLYING:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_SET_FLYING(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0421))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_UNSET_FLYING:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_UNSET_FLYING:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_UNSET_FLYING(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0422))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


ClientOpcode = typing.Union[
    CMSG_BOOTME,
    CMSG_DBLOOKUP,
    CMSG_WORLD_TELEPORT,
    CMSG_TELEPORT_TO_UNIT,
    CMSG_CHAR_CREATE,
    CMSG_CHAR_ENUM,
    CMSG_CHAR_DELETE,
    CMSG_PLAYER_LOGIN,
    CMSG_PLAYER_LOGOUT,
    CMSG_LOGOUT_REQUEST,
    CMSG_LOGOUT_CANCEL,
    CMSG_NAME_QUERY,
    CMSG_PET_NAME_QUERY,
    CMSG_GUILD_QUERY,
    CMSG_ITEM_QUERY_SINGLE,
    CMSG_PAGE_TEXT_QUERY,
    CMSG_QUEST_QUERY,
    CMSG_GAMEOBJECT_QUERY,
    CMSG_CREATURE_QUERY,
    CMSG_WHO,
    CMSG_WHOIS,
    CMSG_CONTACT_LIST,
    CMSG_ADD_FRIEND,
    CMSG_DEL_FRIEND,
    CMSG_SET_CONTACT_NOTES,
    CMSG_ADD_IGNORE,
    CMSG_DEL_IGNORE,
    CMSG_GROUP_INVITE,
    CMSG_GROUP_CANCEL,
    CMSG_GROUP_ACCEPT,
    CMSG_GROUP_DECLINE,
    CMSG_GROUP_UNINVITE,
    CMSG_GROUP_UNINVITE_GUID,
    CMSG_GROUP_SET_LEADER,
    CMSG_LOOT_METHOD,
    CMSG_GROUP_DISBAND,
    CMSG_GUILD_CREATE,
    CMSG_GUILD_INVITE,
    CMSG_GUILD_ACCEPT,
    CMSG_GUILD_DECLINE,
    CMSG_GUILD_INFO,
    CMSG_GUILD_ROSTER,
    CMSG_GUILD_PROMOTE,
    CMSG_GUILD_DEMOTE,
    CMSG_GUILD_LEAVE,
    CMSG_GUILD_REMOVE,
    CMSG_GUILD_DISBAND,
    CMSG_GUILD_LEADER,
    CMSG_GUILD_MOTD,
    CMSG_MESSAGECHAT,
    CMSG_JOIN_CHANNEL,
    CMSG_LEAVE_CHANNEL,
    CMSG_CHANNEL_LIST,
    CMSG_CHANNEL_PASSWORD,
    CMSG_CHANNEL_SET_OWNER,
    CMSG_CHANNEL_OWNER,
    CMSG_CHANNEL_MODERATOR,
    CMSG_CHANNEL_UNMODERATOR,
    CMSG_CHANNEL_MUTE,
    CMSG_CHANNEL_UNMUTE,
    CMSG_CHANNEL_INVITE,
    CMSG_CHANNEL_KICK,
    CMSG_CHANNEL_BAN,
    CMSG_CHANNEL_UNBAN,
    CMSG_CHANNEL_ANNOUNCEMENTS,
    CMSG_CHANNEL_MODERATE,
    CMSG_USE_ITEM,
    CMSG_OPEN_ITEM,
    CMSG_READ_ITEM,
    CMSG_GAMEOBJ_USE,
    CMSG_AREATRIGGER,
    MSG_MOVE_START_FORWARD_Client,
    MSG_MOVE_START_BACKWARD_Client,
    MSG_MOVE_STOP_Client,
    MSG_MOVE_START_STRAFE_LEFT_Client,
    MSG_MOVE_START_STRAFE_RIGHT_Client,
    MSG_MOVE_STOP_STRAFE_Client,
    MSG_MOVE_JUMP_Client,
    MSG_MOVE_START_TURN_LEFT_Client,
    MSG_MOVE_START_TURN_RIGHT_Client,
    MSG_MOVE_STOP_TURN_Client,
    MSG_MOVE_START_PITCH_UP_Client,
    MSG_MOVE_START_PITCH_DOWN_Client,
    MSG_MOVE_STOP_PITCH_Client,
    MSG_MOVE_SET_RUN_MODE_Client,
    MSG_MOVE_SET_WALK_MODE_Client,
    MSG_MOVE_TELEPORT_Server,
    MSG_MOVE_TELEPORT_ACK_Client,
    MSG_MOVE_FALL_LAND_Client,
    MSG_MOVE_START_SWIM_Client,
    MSG_MOVE_STOP_SWIM_Client,
    MSG_MOVE_SET_FACING_Client,
    MSG_MOVE_SET_PITCH_Client,
    MSG_MOVE_WORLDPORT_ACK,
    CMSG_MOVE_SET_RAW_POSITION,
    CMSG_FORCE_RUN_SPEED_CHANGE_ACK,
    CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK,
    CMSG_FORCE_SWIM_SPEED_CHANGE_ACK,
    CMSG_FORCE_MOVE_ROOT_ACK,
    CMSG_FORCE_MOVE_UNROOT_ACK,
    MSG_MOVE_HEARTBEAT_Client,
    CMSG_MOVE_KNOCK_BACK_ACK,
    CMSG_MOVE_HOVER_ACK,
    MSG_MOVE_HOVER,
    CMSG_NEXT_CINEMATIC_CAMERA,
    CMSG_COMPLETE_CINEMATIC,
    CMSG_TUTORIAL_FLAG,
    CMSG_TUTORIAL_CLEAR,
    CMSG_TUTORIAL_RESET,
    CMSG_STANDSTATECHANGE,
    CMSG_EMOTE,
    CMSG_TEXT_EMOTE,
    CMSG_AUTOSTORE_LOOT_ITEM,
    CMSG_AUTOEQUIP_ITEM,
    CMSG_AUTOSTORE_BAG_ITEM,
    CMSG_SWAP_ITEM,
    CMSG_SWAP_INV_ITEM,
    CMSG_SPLIT_ITEM,
    CMSG_AUTOEQUIP_ITEM_SLOT,
    CMSG_DESTROYITEM,
    CMSG_INSPECT,
    CMSG_INITIATE_TRADE,
    CMSG_BEGIN_TRADE,
    CMSG_BUSY_TRADE,
    CMSG_IGNORE_TRADE,
    CMSG_ACCEPT_TRADE,
    CMSG_UNACCEPT_TRADE,
    CMSG_CANCEL_TRADE,
    CMSG_SET_TRADE_ITEM,
    CMSG_CLEAR_TRADE_ITEM,
    CMSG_SET_TRADE_GOLD,
    CMSG_SET_FACTION_ATWAR,
    CMSG_SET_ACTION_BUTTON,
    CMSG_CAST_SPELL,
    CMSG_CANCEL_CAST,
    CMSG_CANCEL_AURA,
    CMSG_CANCEL_CHANNELLING,
    CMSG_SET_SELECTION,
    CMSG_SET_TARGET_OBSOLETE,
    CMSG_ATTACKSWING,
    CMSG_ATTACKSTOP,
    CMSG_REPOP_REQUEST,
    CMSG_RESURRECT_RESPONSE,
    CMSG_LOOT,
    CMSG_LOOT_MONEY,
    CMSG_LOOT_RELEASE,
    CMSG_DUEL_ACCEPTED,
    CMSG_DUEL_CANCELLED,
    CMSG_MOUNTSPECIAL_ANIM,
    CMSG_PET_SET_ACTION,
    CMSG_PET_ACTION,
    CMSG_PET_ABANDON,
    CMSG_PET_RENAME,
    CMSG_GOSSIP_HELLO,
    CMSG_GOSSIP_SELECT_OPTION,
    CMSG_NPC_TEXT_QUERY,
    CMSG_QUESTGIVER_STATUS_QUERY,
    CMSG_QUESTGIVER_HELLO,
    CMSG_QUESTGIVER_QUERY_QUEST,
    CMSG_QUESTGIVER_QUEST_AUTOLAUNCH,
    CMSG_QUESTGIVER_ACCEPT_QUEST,
    CMSG_QUESTGIVER_COMPLETE_QUEST,
    CMSG_QUESTGIVER_REQUEST_REWARD,
    CMSG_QUESTGIVER_CHOOSE_REWARD,
    CMSG_QUESTGIVER_CANCEL,
    CMSG_QUESTLOG_SWAP_QUEST,
    CMSG_QUESTLOG_REMOVE_QUEST,
    CMSG_QUEST_CONFIRM_ACCEPT,
    CMSG_PUSHQUESTTOPARTY,
    CMSG_LIST_INVENTORY,
    CMSG_SELL_ITEM,
    CMSG_BUY_ITEM,
    CMSG_BUY_ITEM_IN_SLOT,
    CMSG_TAXINODE_STATUS_QUERY,
    CMSG_TAXIQUERYAVAILABLENODES,
    CMSG_ACTIVATETAXI,
    CMSG_TRAINER_LIST,
    CMSG_TRAINER_BUY_SPELL,
    CMSG_BINDER_ACTIVATE,
    CMSG_BANKER_ACTIVATE,
    CMSG_BUY_BANK_SLOT,
    CMSG_PETITION_SHOWLIST,
    CMSG_PETITION_BUY,
    CMSG_PETITION_SHOW_SIGNATURES,
    CMSG_PETITION_SIGN,
    MSG_PETITION_DECLINE,
    CMSG_OFFER_PETITION,
    CMSG_TURN_IN_PETITION,
    CMSG_PETITION_QUERY,
    CMSG_BUG,
    CMSG_PLAYED_TIME,
    CMSG_QUERY_TIME,
    CMSG_RECLAIM_CORPSE,
    CMSG_WRAP_ITEM,
    MSG_MINIMAP_PING_Client,
    CMSG_PING,
    CMSG_SETSHEATHED,
    CMSG_AUTH_SESSION,
    CMSG_PET_CAST_SPELL,
    MSG_SAVE_GUILD_EMBLEM_Client,
    MSG_TABARDVENDOR_ACTIVATE,
    CMSG_ZONEUPDATE,
    MSG_RANDOM_ROLL_Client,
    MSG_LOOKING_FOR_GROUP_Client,
    CMSG_SET_LOOKING_FOR_GROUP,
    CMSG_UNLEARN_SKILL,
    CMSG_GMTICKET_CREATE,
    CMSG_GMTICKET_UPDATETEXT,
    CMSG_REQUEST_ACCOUNT_DATA,
    CMSG_UPDATE_ACCOUNT_DATA,
    CMSG_GMTICKET_GETTICKET,
    CMSG_UNLEARN_TALENTS,
    MSG_CORPSE_QUERY_Client,
    CMSG_GMTICKET_DELETETICKET,
    CMSG_GMTICKET_SYSTEMSTATUS,
    CMSG_SPIRIT_HEALER_ACTIVATE,
    CMSG_CHAT_IGNORED,
    CMSG_GUILD_RANK,
    CMSG_GUILD_ADD_RANK,
    CMSG_GUILD_DEL_RANK,
    CMSG_GUILD_SET_PUBLIC_NOTE,
    CMSG_GUILD_SET_OFFICER_NOTE,
    CMSG_SEND_MAIL,
    CMSG_GET_MAIL_LIST,
    CMSG_BATTLEFIELD_LIST,
    CMSG_ITEM_TEXT_QUERY,
    CMSG_MAIL_TAKE_MONEY,
    CMSG_MAIL_TAKE_ITEM,
    CMSG_MAIL_MARK_AS_READ,
    CMSG_MAIL_RETURN_TO_SENDER,
    CMSG_MAIL_DELETE,
    CMSG_MAIL_CREATE_TEXT_ITEM,
    CMSG_LEARN_TALENT,
    CMSG_TOGGLE_PVP,
    MSG_AUCTION_HELLO_Client,
    CMSG_AUCTION_SELL_ITEM,
    CMSG_AUCTION_REMOVE_ITEM,
    CMSG_AUCTION_LIST_ITEMS,
    CMSG_AUCTION_LIST_OWNER_ITEMS,
    CMSG_AUCTION_PLACE_BID,
    CMSG_AUCTION_LIST_BIDDER_ITEMS,
    CMSG_SET_AMMO,
    CMSG_SET_ACTIVE_MOVER,
    CMSG_PET_CANCEL_AURA,
    CMSG_CANCEL_AUTO_REPEAT_SPELL,
    MSG_LIST_STABLED_PETS_Client,
    CMSG_STABLE_PET,
    CMSG_UNSTABLE_PET,
    CMSG_BUY_STABLE_SLOT,
    CMSG_STABLE_SWAP_PET,
    MSG_QUEST_PUSH_RESULT,
    CMSG_REQUEST_PET_INFO,
    CMSG_FAR_SIGHT,
    CMSG_GROUP_CHANGE_SUB_GROUP,
    CMSG_REQUEST_PARTY_MEMBER_STATS,
    CMSG_GROUP_SWAP_SUB_GROUP,
    CMSG_AUTOSTORE_BANK_ITEM,
    CMSG_AUTOBANK_ITEM,
    MSG_QUERY_NEXT_MAIL_TIME_Client,
    CMSG_GROUP_RAID_CONVERT,
    CMSG_GROUP_ASSISTANT_LEADER,
    CMSG_BUYBACK_ITEM,
    CMSG_MEETINGSTONE_INFO,
    CMSG_GMTICKETSYSTEM_TOGGLE,
    CMSG_CANCEL_GROWTH_AURA,
    CMSG_LOOT_ROLL,
    CMSG_LOOT_MASTER_GIVE,
    CMSG_REPAIR_ITEM,
    MSG_TALENT_WIPE_CONFIRM_Client,
    CMSG_SUMMON_RESPONSE,
    MSG_MOVE_WATER_WALK,
    CMSG_SELF_RES,
    CMSG_TOGGLE_HELM,
    CMSG_TOGGLE_CLOAK,
    CMSG_SET_ACTIONBAR_TOGGLES,
    MSG_PETITION_RENAME,
    CMSG_ITEM_NAME_QUERY,
    CMSG_CHAR_RENAME,
    CMSG_MOVE_SPLINE_DONE,
    CMSG_MOVE_FALL_RESET,
    CMSG_REQUEST_RAID_INFO,
    CMSG_MOVE_TIME_SKIPPED,
    CMSG_MOVE_FEATHER_FALL_ACK,
    CMSG_MOVE_WATER_WALK_ACK,
    CMSG_MOVE_NOT_ACTIVE_MOVER,
    CMSG_BATTLEFIELD_STATUS,
    CMSG_BATTLEFIELD_PORT,
    MSG_INSPECT_HONOR_STATS_Client,
    CMSG_BATTLEMASTER_HELLO,
    CMSG_FORCE_WALK_SPEED_CHANGE_ACK,
    CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK,
    CMSG_FORCE_TURN_RATE_CHANGE_ACK,
    MSG_PVP_LOG_DATA_Client,
    CMSG_LEAVE_BATTLEFIELD,
    CMSG_AREA_SPIRIT_HEALER_QUERY,
    CMSG_AREA_SPIRIT_HEALER_QUEUE,
    CMSG_WARDEN_DATA,
    MSG_BATTLEGROUND_PLAYER_POSITIONS_Client,
    CMSG_PET_STOP_ATTACK,
    CMSG_BATTLEMASTER_JOIN,
    CMSG_PET_UNLEARN,
    CMSG_PET_SPELL_AUTOCAST,
    CMSG_GUILD_INFO_TEXT,
    CMSG_ACTIVATETAXIEXPRESS,
    CMSG_SET_FACTION_INACTIVE,
    CMSG_SET_WATCHED_FACTION,
    CMSG_RESET_INSTANCES,
    MSG_RAID_TARGET_UPDATE_Client,
    MSG_RAID_READY_CHECK_Client,
    MSG_SET_DUNGEON_DIFFICULTY_Client,
    CMSG_GMSURVEY_SUBMIT,
    CMSG_MOVE_SET_CAN_FLY_ACK,
    CMSG_MOVE_SET_FLY,
    CMSG_SOCKET_GEMS,
    CMSG_ARENA_TEAM_ROSTER,
    CMSG_ARENA_TEAM_INVITE,
    CMSG_ARENA_TEAM_ACCEPT,
    CMSG_ARENA_TEAM_DECLINE,
    CMSG_ARENA_TEAM_LEAVE,
    CMSG_ARENA_TEAM_REMOVE,
    CMSG_ARENA_TEAM_DISBAND,
    CMSG_ARENA_TEAM_LEADER,
    CMSG_BATTLEMASTER_JOIN_ARENA,
    MSG_MOVE_START_ASCEND_Client,
    MSG_MOVE_STOP_ASCEND_Client,
    CMSG_LFG_SET_AUTOJOIN,
    CMSG_LFG_CLEAR_AUTOJOIN,
    CMSG_LFM_SET_AUTOFILL,
    CMSG_LFM_CLEAR_AUTOFILL,
    CMSG_CLEAR_LOOKING_FOR_GROUP,
    CMSG_CLEAR_LOOKING_FOR_MORE,
    CMSG_SET_LOOKING_FOR_MORE,
    CMSG_SET_LFG_COMMENT,
    CMSG_SET_TITLE,
    CMSG_CANCEL_MOUNT_AURA,
    MSG_INSPECT_ARENA_TEAMS_Client,
    CMSG_CANCEL_TEMP_ENCHANTMENT,
    MSG_MOVE_SET_FLIGHT_BACK_SPEED,
    CMSG_FORCE_FLIGHT_SPEED_CHANGE_ACK,
    CMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE_ACK,
    CMSG_SET_TAXI_BENCHMARK_MODE,
    CMSG_REALM_SPLIT,
    CMSG_MOVE_CHNG_TRANSPORT,
    MSG_PARTY_ASSIGNMENT_Client,
    CMSG_TIME_SYNC_RESP,
    MSG_MOVE_START_DESCEND_Client,
    MSG_RAID_READY_CHECK_CONFIRM_Client,
    CMSG_VOICE_SESSION_ENABLE,
    CMSG_COMMENTATOR_ENABLE,
    MSG_RAID_READY_CHECK_FINISHED_Client,
    CMSG_COMPLAIN,
    CMSG_CHANNEL_DISPLAY_LIST,
    CMSG_SET_ACTIVE_VOICE_CHANNEL,
    CMSG_GET_CHANNEL_MEMBER_COUNT,
    CMSG_CHANNEL_VOICE_ON,
    CMSG_REPORT_PVP_AFK,
    CMSG_GUILD_BANKER_ACTIVATE,
    CMSG_GUILD_BANK_QUERY_TAB,
    CMSG_GUILD_BANK_SWAP_ITEMS,
    CMSG_GUILD_BANK_BUY_TAB,
    CMSG_GUILD_BANK_UPDATE_TAB,
    CMSG_GUILD_BANK_DEPOSIT_MONEY,
    CMSG_GUILD_BANK_WITHDRAW_MONEY,
    MSG_GUILD_BANK_LOG_QUERY_Client,
    CMSG_SET_CHANNEL_WATCH,
    CMSG_CLEAR_CHANNEL_WATCH,
    CMSG_SPELLCLICK,
    MSG_GUILD_PERMISSIONS_Client,
    MSG_GUILD_BANK_MONEY_WITHDRAWN_Client,
    MSG_GUILD_EVENT_LOG_QUERY_Client,
    CMSG_GET_MIRRORIMAGE_DATA,
    CMSG_KEEP_ALIVE,
    CMSG_OPT_OUT_OF_LOOT,
    MSG_QUERY_GUILD_BANK_TEXT_Client,
    CMSG_SET_GUILD_BANK_TEXT,
    CMSG_GRANT_LEVEL,
    CMSG_TOTEM_DESTROYED,
    CMSG_QUESTGIVER_STATUS_MULTIPLE_QUERY,
    CMSG_SET_PLAYER_DECLINED_NAMES,
    CMSG_ACCEPT_LEVEL_GRANT,
]

ServerOpcode = typing.Union[
    SMSG_CHAR_CREATE,
    SMSG_CHAR_ENUM,
    SMSG_CHAR_DELETE,
    SMSG_NEW_WORLD,
    SMSG_TRANSFER_PENDING,
    SMSG_TRANSFER_ABORTED,
    SMSG_CHARACTER_LOGIN_FAILED,
    SMSG_LOGIN_SETTIMESPEED,
    SMSG_LOGOUT_RESPONSE,
    SMSG_LOGOUT_COMPLETE,
    SMSG_LOGOUT_CANCEL_ACK,
    SMSG_NAME_QUERY_RESPONSE,
    SMSG_PET_NAME_QUERY_RESPONSE,
    SMSG_GUILD_QUERY_RESPONSE,
    SMSG_ITEM_QUERY_SINGLE_RESPONSE,
    SMSG_PAGE_TEXT_QUERY_RESPONSE,
    SMSG_QUEST_QUERY_RESPONSE,
    SMSG_GAMEOBJECT_QUERY_RESPONSE,
    SMSG_CREATURE_QUERY_RESPONSE,
    SMSG_WHO,
    SMSG_WHOIS,
    SMSG_CONTACT_LIST,
    SMSG_FRIEND_STATUS,
    SMSG_GROUP_INVITE,
    SMSG_GROUP_DECLINE,
    SMSG_GROUP_UNINVITE,
    SMSG_GROUP_SET_LEADER,
    SMSG_GROUP_DESTROYED,
    SMSG_GROUP_LIST,
    SMSG_PARTY_MEMBER_STATS,
    SMSG_PARTY_COMMAND_RESULT,
    SMSG_GUILD_INVITE,
    SMSG_GUILD_DECLINE,
    SMSG_GUILD_INFO,
    SMSG_GUILD_ROSTER,
    SMSG_GUILD_EVENT,
    SMSG_GUILD_COMMAND_RESULT,
    SMSG_MESSAGECHAT,
    SMSG_CHANNEL_NOTIFY,
    SMSG_CHANNEL_LIST,
    SMSG_UPDATE_OBJECT,
    SMSG_DESTROY_OBJECT,
    SMSG_READ_ITEM_OK,
    SMSG_READ_ITEM_FAILED,
    SMSG_ITEM_COOLDOWN,
    SMSG_GAMEOBJECT_CUSTOM_ANIM,
    MSG_MOVE_START_FORWARD_Server,
    MSG_MOVE_START_BACKWARD_Server,
    MSG_MOVE_STOP_Server,
    MSG_MOVE_START_STRAFE_LEFT_Server,
    MSG_MOVE_START_STRAFE_RIGHT_Server,
    MSG_MOVE_STOP_STRAFE_Server,
    MSG_MOVE_JUMP_Server,
    MSG_MOVE_START_TURN_LEFT_Server,
    MSG_MOVE_START_TURN_RIGHT_Server,
    MSG_MOVE_STOP_TURN_Server,
    MSG_MOVE_START_PITCH_UP_Server,
    MSG_MOVE_START_PITCH_DOWN_Server,
    MSG_MOVE_STOP_PITCH_Server,
    MSG_MOVE_SET_RUN_MODE_Server,
    MSG_MOVE_SET_WALK_MODE_Server,
    MSG_MOVE_TELEPORT_CHEAT_Server,
    MSG_MOVE_TELEPORT_ACK_Server,
    MSG_MOVE_FALL_LAND_Server,
    MSG_MOVE_START_SWIM_Server,
    MSG_MOVE_STOP_SWIM_Server,
    MSG_MOVE_SET_FACING_Server,
    MSG_MOVE_SET_PITCH_Server,
    MSG_MOVE_WORLDPORT_ACK,
    SMSG_MONSTER_MOVE,
    SMSG_MOVE_WATER_WALK,
    SMSG_MOVE_LAND_WALK,
    SMSG_FORCE_RUN_SPEED_CHANGE,
    SMSG_FORCE_RUN_BACK_SPEED_CHANGE,
    SMSG_FORCE_SWIM_SPEED_CHANGE,
    SMSG_FORCE_MOVE_ROOT,
    SMSG_FORCE_MOVE_UNROOT,
    MSG_MOVE_ROOT_Server,
    MSG_MOVE_UNROOT_Server,
    MSG_MOVE_HEARTBEAT_Server,
    SMSG_MOVE_KNOCK_BACK,
    MSG_MOVE_KNOCK_BACK_Server,
    SMSG_MOVE_FEATHER_FALL,
    SMSG_MOVE_NORMAL_FALL,
    SMSG_MOVE_SET_HOVER,
    SMSG_MOVE_UNSET_HOVER,
    MSG_MOVE_HOVER,
    SMSG_TRIGGER_CINEMATIC,
    SMSG_TUTORIAL_FLAGS,
    SMSG_EMOTE,
    SMSG_TEXT_EMOTE,
    SMSG_INVENTORY_CHANGE_FAILURE,
    SMSG_TRADE_STATUS,
    SMSG_TRADE_STATUS_EXTENDED,
    SMSG_INITIALIZE_FACTIONS,
    SMSG_SET_FACTION_VISIBLE,
    SMSG_SET_FACTION_STANDING,
    SMSG_SET_PROFICIENCY,
    SMSG_ACTION_BUTTONS,
    SMSG_INITIAL_SPELLS,
    SMSG_LEARNED_SPELL,
    SMSG_SUPERCEDED_SPELL,
    SMSG_CAST_FAILED,
    SMSG_SPELL_START,
    SMSG_SPELL_GO,
    SMSG_SPELL_FAILURE,
    SMSG_SPELL_COOLDOWN,
    SMSG_COOLDOWN_EVENT,
    SMSG_UPDATE_AURA_DURATION,
    SMSG_PET_CAST_FAILED,
    MSG_CHANNEL_START_Server,
    MSG_CHANNEL_UPDATE_Server,
    SMSG_AI_REACTION,
    SMSG_ATTACKSTART,
    SMSG_ATTACKSTOP,
    SMSG_ATTACKSWING_NOTINRANGE,
    SMSG_ATTACKSWING_BADFACING,
    SMSG_ATTACKSWING_NOTSTANDING,
    SMSG_ATTACKSWING_DEADTARGET,
    SMSG_ATTACKSWING_CANT_ATTACK,
    SMSG_ATTACKERSTATEUPDATE,
    SMSG_CANCEL_COMBAT,
    SMSG_SPELLHEALLOG,
    SMSG_SPELLENERGIZELOG,
    SMSG_BINDPOINTUPDATE,
    SMSG_PLAYERBOUND,
    SMSG_CLIENT_CONTROL_UPDATE,
    SMSG_RESURRECT_REQUEST,
    SMSG_LOOT_RESPONSE,
    SMSG_LOOT_RELEASE_RESPONSE,
    SMSG_LOOT_REMOVED,
    SMSG_LOOT_MONEY_NOTIFY,
    SMSG_LOOT_CLEAR_MONEY,
    SMSG_ITEM_PUSH_RESULT,
    SMSG_DUEL_REQUESTED,
    SMSG_DUEL_OUTOFBOUNDS,
    SMSG_DUEL_INBOUNDS,
    SMSG_DUEL_COMPLETE,
    SMSG_DUEL_WINNER,
    SMSG_MOUNTRESULT,
    SMSG_MOUNTSPECIAL_ANIM,
    SMSG_PET_TAME_FAILURE,
    SMSG_PET_NAME_INVALID,
    SMSG_PET_SPELLS,
    SMSG_PET_MODE,
    SMSG_GOSSIP_MESSAGE,
    SMSG_GOSSIP_COMPLETE,
    SMSG_NPC_TEXT_UPDATE,
    SMSG_QUESTGIVER_STATUS,
    SMSG_QUESTGIVER_QUEST_LIST,
    SMSG_QUESTGIVER_QUEST_DETAILS,
    SMSG_QUESTGIVER_REQUEST_ITEMS,
    SMSG_QUESTGIVER_OFFER_REWARD,
    SMSG_QUESTGIVER_QUEST_INVALID,
    SMSG_QUESTGIVER_QUEST_COMPLETE,
    SMSG_QUESTGIVER_QUEST_FAILED,
    SMSG_QUESTLOG_FULL,
    SMSG_QUESTUPDATE_FAILED,
    SMSG_QUESTUPDATE_FAILEDTIMER,
    SMSG_QUESTUPDATE_COMPLETE,
    SMSG_QUESTUPDATE_ADD_KILL,
    SMSG_QUESTUPDATE_ADD_ITEM,
    SMSG_QUEST_CONFIRM_ACCEPT,
    SMSG_LIST_INVENTORY,
    SMSG_SELL_ITEM,
    SMSG_BUY_ITEM,
    SMSG_BUY_FAILED,
    SMSG_SHOWTAXINODES,
    SMSG_TAXINODE_STATUS,
    SMSG_ACTIVATETAXIREPLY,
    SMSG_NEW_TAXI_PATH,
    SMSG_TRAINER_LIST,
    SMSG_TRAINER_BUY_SUCCEEDED,
    SMSG_TRAINER_BUY_FAILED,
    SMSG_SHOW_BANK,
    SMSG_BUY_BANK_SLOT_RESULT,
    SMSG_PETITION_SHOWLIST,
    SMSG_PETITION_SHOW_SIGNATURES,
    SMSG_PETITION_SIGN_RESULTS,
    MSG_PETITION_DECLINE,
    SMSG_TURN_IN_PETITION_RESULTS,
    SMSG_PETITION_QUERY_RESPONSE,
    SMSG_FISH_NOT_HOOKED,
    SMSG_FISH_ESCAPED,
    SMSG_NOTIFICATION,
    SMSG_PLAYED_TIME,
    SMSG_QUERY_TIME_RESPONSE,
    SMSG_LOG_XPGAIN,
    SMSG_LEVELUP_INFO,
    MSG_MINIMAP_PING_Server,
    SMSG_ENCHANTMENTLOG,
    SMSG_START_MIRROR_TIMER,
    SMSG_PAUSE_MIRROR_TIMER,
    SMSG_STOP_MIRROR_TIMER,
    SMSG_PONG,
    SMSG_CLEAR_COOLDOWN,
    SMSG_GAMEOBJECT_PAGETEXT,
    SMSG_SPELL_DELAYED,
    SMSG_ITEM_TIME_UPDATE,
    SMSG_ITEM_ENCHANT_TIME_UPDATE,
    SMSG_AUTH_CHALLENGE,
    SMSG_AUTH_RESPONSE,
    MSG_SAVE_GUILD_EMBLEM_Server,
    MSG_TABARDVENDOR_ACTIVATE,
    SMSG_PLAY_SPELL_VISUAL,
    SMSG_PARTYKILLLOG,
    SMSG_COMPRESSED_UPDATE_OBJECT,
    SMSG_PLAY_SPELL_IMPACT,
    SMSG_EXPLORATION_EXPERIENCE,
    MSG_RANDOM_ROLL_Server,
    SMSG_ENVIRONMENTAL_DAMAGE_LOG,
    MSG_LOOKING_FOR_GROUP_Server,
    SMSG_REMOVED_SPELL,
    SMSG_GMTICKET_CREATE,
    SMSG_GMTICKET_UPDATETEXT,
    SMSG_ACCOUNT_DATA_TIMES,
    SMSG_UPDATE_ACCOUNT_DATA,
    SMSG_GMTICKET_GETTICKET,
    SMSG_GAMEOBJECT_SPAWN_ANIM,
    SMSG_GAMEOBJECT_DESPAWN_ANIM,
    MSG_CORPSE_QUERY_Server,
    SMSG_GMTICKET_DELETETICKET,
    SMSG_CHAT_WRONG_FACTION,
    SMSG_GMTICKET_SYSTEMSTATUS,
    SMSG_SET_REST_START,
    SMSG_SPIRIT_HEALER_CONFIRM,
    SMSG_GOSSIP_POI,
    SMSG_LOGIN_VERIFY_WORLD,
    SMSG_SEND_MAIL_RESULT,
    SMSG_MAIL_LIST_RESULT,
    SMSG_BATTLEFIELD_LIST,
    SMSG_ITEM_TEXT_QUERY_RESPONSE,
    SMSG_SPELLLOGMISS,
    SMSG_SPELLLOGEXECUTE,
    SMSG_PERIODICAURALOG,
    SMSG_SPELLDAMAGESHIELD,
    SMSG_SPELLNONMELEEDAMAGELOG,
    SMSG_RESURRECT_FAILED,
    SMSG_ZONE_UNDER_ATTACK,
    MSG_AUCTION_HELLO_Server,
    SMSG_AUCTION_COMMAND_RESULT,
    SMSG_AUCTION_LIST_RESULT,
    SMSG_AUCTION_OWNER_LIST_RESULT,
    SMSG_AUCTION_BIDDER_NOTIFICATION,
    SMSG_AUCTION_OWNER_NOTIFICATION,
    SMSG_PROCRESIST,
    SMSG_DISPEL_FAILED,
    SMSG_SPELLORDAMAGE_IMMUNE,
    SMSG_AUCTION_BIDDER_LIST_RESULT,
    SMSG_SET_FLAT_SPELL_MODIFIER,
    SMSG_SET_PCT_SPELL_MODIFIER,
    SMSG_CORPSE_RECLAIM_DELAY,
    MSG_LIST_STABLED_PETS_Server,
    SMSG_STABLE_RESULT,
    MSG_QUEST_PUSH_RESULT,
    SMSG_PLAY_MUSIC,
    SMSG_PLAY_OBJECT_SOUND,
    SMSG_SPELLDISPELLOG,
    MSG_QUERY_NEXT_MAIL_TIME_Server,
    SMSG_RECEIVED_MAIL,
    SMSG_RAID_GROUP_ONLY,
    SMSG_PVP_CREDIT,
    SMSG_AUCTION_REMOVED_NOTIFICATION,
    SMSG_SERVER_MESSAGE,
    SMSG_MEETINGSTONE_SETQUEUE,
    SMSG_CANCEL_AUTO_REPEAT,
    SMSG_STANDSTATE_UPDATE,
    SMSG_LOOT_ALL_PASSED,
    SMSG_LOOT_ROLL_WON,
    SMSG_LOOT_START_ROLL,
    SMSG_LOOT_ROLL,
    SMSG_LOOT_MASTER_LIST,
    SMSG_SET_FORCED_REACTIONS,
    SMSG_SPELL_FAILED_OTHER,
    SMSG_CHAT_PLAYER_NOT_FOUND,
    MSG_TALENT_WIPE_CONFIRM_Server,
    SMSG_SUMMON_REQUEST,
    SMSG_MONSTER_MOVE_TRANSPORT,
    SMSG_PET_BROKEN,
    MSG_MOVE_FEATHER_FALL_Server,
    MSG_MOVE_WATER_WALK,
    SMSG_FEIGN_DEATH_RESISTED,
    SMSG_DUEL_COUNTDOWN,
    SMSG_AREA_TRIGGER_MESSAGE,
    SMSG_PLAYER_SKINNED,
    SMSG_DURABILITY_DAMAGE_DEATH,
    MSG_PETITION_RENAME,
    SMSG_INIT_WORLD_STATES,
    SMSG_UPDATE_WORLD_STATE,
    SMSG_ITEM_NAME_QUERY_RESPONSE,
    SMSG_PET_ACTION_FEEDBACK,
    SMSG_CHAR_RENAME,
    SMSG_INSTANCE_SAVE_CREATED,
    SMSG_RAID_INSTANCE_INFO,
    SMSG_PLAY_SOUND,
    SMSG_BATTLEFIELD_STATUS,
    MSG_INSPECT_HONOR_STATS_Server,
    SMSG_FORCE_WALK_SPEED_CHANGE,
    SMSG_FORCE_SWIM_BACK_SPEED_CHANGE,
    SMSG_FORCE_TURN_RATE_CHANGE,
    SMSG_AREA_SPIRIT_HEALER_TIME,
    SMSG_WARDEN_DATA,
    SMSG_GROUP_JOINED_BATTLEGROUND,
    MSG_BATTLEGROUND_PLAYER_POSITIONS_Server,
    SMSG_BINDER_CONFIRM,
    SMSG_BATTLEGROUND_PLAYER_JOINED,
    SMSG_BATTLEGROUND_PLAYER_LEFT,
    SMSG_ADDON_INFO,
    SMSG_PET_UNLEARN_CONFIRM,
    SMSG_PARTY_MEMBER_STATS_FULL,
    SMSG_WEATHER,
    SMSG_RAID_INSTANCE_MESSAGE,
    SMSG_CHAT_RESTRICTED,
    SMSG_SPLINE_SET_RUN_SPEED,
    SMSG_SPLINE_SET_RUN_BACK_SPEED,
    SMSG_SPLINE_SET_SWIM_SPEED,
    SMSG_SPLINE_SET_WALK_SPEED,
    SMSG_SPLINE_SET_SWIM_BACK_SPEED,
    SMSG_SPLINE_SET_TURN_RATE,
    SMSG_SPLINE_MOVE_UNROOT,
    SMSG_SPLINE_MOVE_FEATHER_FALL,
    SMSG_SPLINE_MOVE_NORMAL_FALL,
    SMSG_SPLINE_MOVE_SET_HOVER,
    SMSG_SPLINE_MOVE_UNSET_HOVER,
    SMSG_SPLINE_MOVE_WATER_WALK,
    SMSG_SPLINE_MOVE_LAND_WALK,
    SMSG_SPLINE_MOVE_START_SWIM,
    SMSG_SPLINE_MOVE_STOP_SWIM,
    SMSG_SPLINE_MOVE_SET_RUN_MODE,
    SMSG_SPLINE_MOVE_SET_WALK_MODE,
    MSG_MOVE_TIME_SKIPPED_Server,
    SMSG_SPLINE_MOVE_ROOT,
    SMSG_INVALIDATE_PLAYER,
    SMSG_INSTANCE_RESET,
    SMSG_INSTANCE_RESET_FAILED,
    SMSG_UPDATE_LAST_INSTANCE,
    MSG_RAID_TARGET_UPDATE_Server,
    MSG_RAID_READY_CHECK_Server,
    SMSG_PET_ACTION_SOUND,
    SMSG_PET_DISMISS_SOUND,
    SMSG_GM_TICKET_STATUS_UPDATE,
    MSG_SET_DUNGEON_DIFFICULTY_Server,
    SMSG_UPDATE_INSTANCE_OWNERSHIP,
    SMSG_CHAT_PLAYER_AMBIGUOUS,
    SMSG_SPELLINSTAKILLLOG,
    SMSG_SPELL_UPDATE_CHAIN_TARGETS,
    SMSG_SPELLSTEALLOG,
    SMSG_DEFENSE_MESSAGE,
    SMSG_INSTANCE_DIFFICULTY,
    SMSG_MOTD,
    SMSG_MOVE_SET_FLIGHT,
    SMSG_MOVE_UNSET_FLIGHT,
    SMSG_MOVE_SET_CAN_FLY,
    SMSG_MOVE_UNSET_CAN_FLY,
    SMSG_ARENA_TEAM_COMMAND_RESULT,
    SMSG_ARENA_TEAM_QUERY_RESPONSE,
    SMSG_ARENA_TEAM_ROSTER,
    SMSG_ARENA_TEAM_INVITE,
    SMSG_ARENA_TEAM_EVENT,
    MSG_MOVE_START_ASCEND_Server,
    MSG_MOVE_STOP_ASCEND_Server,
    SMSG_ARENA_TEAM_STATS,
    SMSG_LFG_LEADER_IS_LFM,
    SMSG_LFG_UPDATE,
    SMSG_LFG_UPDATE_LFM,
    SMSG_LFG_UPDATE_LFG,
    SMSG_LFG_UPDATE_QUEUED,
    SMSG_TITLE_EARNED,
    SMSG_ARENA_ERROR,
    MSG_INSPECT_ARENA_TEAMS_Server,
    SMSG_DEATH_RELEASE_LOC,
    SMSG_FORCED_DEATH_UPDATE,
    MSG_MOVE_SET_FLIGHT_SPEED_Server,
    MSG_MOVE_SET_FLIGHT_BACK_SPEED,
    SMSG_FORCE_FLIGHT_SPEED_CHANGE,
    SMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE,
    SMSG_SPLINE_SET_FLIGHT_SPEED,
    SMSG_SPLINE_SET_FLIGHT_BACK_SPEED,
    SMSG_FLIGHT_SPLINE_SYNC,
    SMSG_REALM_SPLIT,
    SMSG_TIME_SYNC_REQ,
    SMSG_RESET_FAILED_NOTIFY,
    SMSG_LFG_DISABLED,
    SMSG_UPDATE_COMBO_POINTS,
    SMSG_SET_EXTRA_AURA_INFO,
    SMSG_SET_EXTRA_AURA_INFO_NEED_UPDATE,
    SMSG_CLEAR_EXTRA_AURA_INFO,
    MSG_MOVE_START_DESCEND_Server,
    SMSG_DISMOUNT,
    MSG_MOVE_UPDATE_CAN_FLY_Server,
    MSG_RAID_READY_CHECK_CONFIRM_Server,
    SMSG_GM_MESSAGECHAT,
    SMSG_CLEAR_TARGET,
    SMSG_CROSSED_INEBRIATION_THRESHOLD,
    SMSG_KICK_REASON,
    SMSG_COMPLAIN_RESULT,
    SMSG_FEATURE_SYSTEM_STATUS,
    SMSG_CHANNEL_MEMBER_COUNT,
    SMSG_GUILD_BANK_LIST,
    MSG_GUILD_BANK_LOG_QUERY_Server,
    SMSG_USERLIST_ADD,
    SMSG_USERLIST_REMOVE,
    SMSG_USERLIST_UPDATE,
    SMSG_INSPECT_TALENT,
    SMSG_LOOT_LIST,
    MSG_GUILD_PERMISSIONS_Server,
    MSG_GUILD_BANK_MONEY_WITHDRAWN_Server,
    MSG_GUILD_EVENT_LOG_QUERY_Server,
    SMSG_MIRRORIMAGE_DATA,
    MSG_QUERY_GUILD_BANK_TEXT_Server,
    SMSG_OVERRIDE_LIGHT,
    SMSG_TOTEM_CREATED,
    SMSG_QUESTGIVER_STATUS_MULTIPLE,
    SMSG_SET_PLAYER_DECLINED_NAMES_RESULT,
    SMSG_SEND_UNLEARN_SPELLS,
    SMSG_PROPOSE_LEVEL_GRANT,
    SMSG_REFER_A_FRIEND_FAILURE,
    SMSG_SPLINE_MOVE_SET_FLYING,
    SMSG_SPLINE_MOVE_UNSET_FLYING,
]


client_opcodes: dict[int, ClientOpcode] = {
    0x0001: CMSG_BOOTME,
    0x0002: CMSG_DBLOOKUP,
    0x0008: CMSG_WORLD_TELEPORT,
    0x0009: CMSG_TELEPORT_TO_UNIT,
    0x0036: CMSG_CHAR_CREATE,
    0x0037: CMSG_CHAR_ENUM,
    0x0038: CMSG_CHAR_DELETE,
    0x003D: CMSG_PLAYER_LOGIN,
    0x004A: CMSG_PLAYER_LOGOUT,
    0x004B: CMSG_LOGOUT_REQUEST,
    0x004E: CMSG_LOGOUT_CANCEL,
    0x0050: CMSG_NAME_QUERY,
    0x0052: CMSG_PET_NAME_QUERY,
    0x0054: CMSG_GUILD_QUERY,
    0x0056: CMSG_ITEM_QUERY_SINGLE,
    0x005A: CMSG_PAGE_TEXT_QUERY,
    0x005C: CMSG_QUEST_QUERY,
    0x005E: CMSG_GAMEOBJECT_QUERY,
    0x0060: CMSG_CREATURE_QUERY,
    0x0062: CMSG_WHO,
    0x0064: CMSG_WHOIS,
    0x0066: CMSG_CONTACT_LIST,
    0x0069: CMSG_ADD_FRIEND,
    0x006A: CMSG_DEL_FRIEND,
    0x006B: CMSG_SET_CONTACT_NOTES,
    0x006C: CMSG_ADD_IGNORE,
    0x006D: CMSG_DEL_IGNORE,
    0x006E: CMSG_GROUP_INVITE,
    0x0070: CMSG_GROUP_CANCEL,
    0x0072: CMSG_GROUP_ACCEPT,
    0x0073: CMSG_GROUP_DECLINE,
    0x0075: CMSG_GROUP_UNINVITE,
    0x0076: CMSG_GROUP_UNINVITE_GUID,
    0x0078: CMSG_GROUP_SET_LEADER,
    0x007A: CMSG_LOOT_METHOD,
    0x007B: CMSG_GROUP_DISBAND,
    0x0081: CMSG_GUILD_CREATE,
    0x0082: CMSG_GUILD_INVITE,
    0x0084: CMSG_GUILD_ACCEPT,
    0x0085: CMSG_GUILD_DECLINE,
    0x0087: CMSG_GUILD_INFO,
    0x0089: CMSG_GUILD_ROSTER,
    0x008B: CMSG_GUILD_PROMOTE,
    0x008C: CMSG_GUILD_DEMOTE,
    0x008D: CMSG_GUILD_LEAVE,
    0x008E: CMSG_GUILD_REMOVE,
    0x008F: CMSG_GUILD_DISBAND,
    0x0090: CMSG_GUILD_LEADER,
    0x0091: CMSG_GUILD_MOTD,
    0x0095: CMSG_MESSAGECHAT,
    0x0097: CMSG_JOIN_CHANNEL,
    0x0098: CMSG_LEAVE_CHANNEL,
    0x009A: CMSG_CHANNEL_LIST,
    0x009C: CMSG_CHANNEL_PASSWORD,
    0x009D: CMSG_CHANNEL_SET_OWNER,
    0x009E: CMSG_CHANNEL_OWNER,
    0x009F: CMSG_CHANNEL_MODERATOR,
    0x00A0: CMSG_CHANNEL_UNMODERATOR,
    0x00A1: CMSG_CHANNEL_MUTE,
    0x00A2: CMSG_CHANNEL_UNMUTE,
    0x00A3: CMSG_CHANNEL_INVITE,
    0x00A4: CMSG_CHANNEL_KICK,
    0x00A5: CMSG_CHANNEL_BAN,
    0x00A6: CMSG_CHANNEL_UNBAN,
    0x00A7: CMSG_CHANNEL_ANNOUNCEMENTS,
    0x00A8: CMSG_CHANNEL_MODERATE,
    0x00AB: CMSG_USE_ITEM,
    0x00AC: CMSG_OPEN_ITEM,
    0x00AD: CMSG_READ_ITEM,
    0x00B1: CMSG_GAMEOBJ_USE,
    0x00B4: CMSG_AREATRIGGER,
    0x00B5: MSG_MOVE_START_FORWARD_Client,
    0x00B6: MSG_MOVE_START_BACKWARD_Client,
    0x00B7: MSG_MOVE_STOP_Client,
    0x00B8: MSG_MOVE_START_STRAFE_LEFT_Client,
    0x00B9: MSG_MOVE_START_STRAFE_RIGHT_Client,
    0x00BA: MSG_MOVE_STOP_STRAFE_Client,
    0x00BB: MSG_MOVE_JUMP_Client,
    0x00BC: MSG_MOVE_START_TURN_LEFT_Client,
    0x00BD: MSG_MOVE_START_TURN_RIGHT_Client,
    0x00BE: MSG_MOVE_STOP_TURN_Client,
    0x00BF: MSG_MOVE_START_PITCH_UP_Client,
    0x00C0: MSG_MOVE_START_PITCH_DOWN_Client,
    0x00C1: MSG_MOVE_STOP_PITCH_Client,
    0x00C2: MSG_MOVE_SET_RUN_MODE_Client,
    0x00C3: MSG_MOVE_SET_WALK_MODE_Client,
    0x00C5: MSG_MOVE_TELEPORT_Server,
    0x00C7: MSG_MOVE_TELEPORT_ACK_Client,
    0x00C9: MSG_MOVE_FALL_LAND_Client,
    0x00CA: MSG_MOVE_START_SWIM_Client,
    0x00CB: MSG_MOVE_STOP_SWIM_Client,
    0x00DA: MSG_MOVE_SET_FACING_Client,
    0x00DB: MSG_MOVE_SET_PITCH_Client,
    0x00DC: MSG_MOVE_WORLDPORT_ACK,
    0x00E1: CMSG_MOVE_SET_RAW_POSITION,
    0x00E3: CMSG_FORCE_RUN_SPEED_CHANGE_ACK,
    0x00E5: CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK,
    0x00E7: CMSG_FORCE_SWIM_SPEED_CHANGE_ACK,
    0x00E9: CMSG_FORCE_MOVE_ROOT_ACK,
    0x00EB: CMSG_FORCE_MOVE_UNROOT_ACK,
    0x00EE: MSG_MOVE_HEARTBEAT_Client,
    0x00F0: CMSG_MOVE_KNOCK_BACK_ACK,
    0x00F6: CMSG_MOVE_HOVER_ACK,
    0x00F7: MSG_MOVE_HOVER,
    0x00FB: CMSG_NEXT_CINEMATIC_CAMERA,
    0x00FC: CMSG_COMPLETE_CINEMATIC,
    0x00FE: CMSG_TUTORIAL_FLAG,
    0x00FF: CMSG_TUTORIAL_CLEAR,
    0x0100: CMSG_TUTORIAL_RESET,
    0x0101: CMSG_STANDSTATECHANGE,
    0x0102: CMSG_EMOTE,
    0x0104: CMSG_TEXT_EMOTE,
    0x0108: CMSG_AUTOSTORE_LOOT_ITEM,
    0x010A: CMSG_AUTOEQUIP_ITEM,
    0x010B: CMSG_AUTOSTORE_BAG_ITEM,
    0x010C: CMSG_SWAP_ITEM,
    0x010D: CMSG_SWAP_INV_ITEM,
    0x010E: CMSG_SPLIT_ITEM,
    0x010F: CMSG_AUTOEQUIP_ITEM_SLOT,
    0x0111: CMSG_DESTROYITEM,
    0x0114: CMSG_INSPECT,
    0x0116: CMSG_INITIATE_TRADE,
    0x0117: CMSG_BEGIN_TRADE,
    0x0118: CMSG_BUSY_TRADE,
    0x0119: CMSG_IGNORE_TRADE,
    0x011A: CMSG_ACCEPT_TRADE,
    0x011B: CMSG_UNACCEPT_TRADE,
    0x011C: CMSG_CANCEL_TRADE,
    0x011D: CMSG_SET_TRADE_ITEM,
    0x011E: CMSG_CLEAR_TRADE_ITEM,
    0x011F: CMSG_SET_TRADE_GOLD,
    0x0125: CMSG_SET_FACTION_ATWAR,
    0x0128: CMSG_SET_ACTION_BUTTON,
    0x012E: CMSG_CAST_SPELL,
    0x012F: CMSG_CANCEL_CAST,
    0x0136: CMSG_CANCEL_AURA,
    0x013B: CMSG_CANCEL_CHANNELLING,
    0x013D: CMSG_SET_SELECTION,
    0x013E: CMSG_SET_TARGET_OBSOLETE,
    0x0141: CMSG_ATTACKSWING,
    0x0142: CMSG_ATTACKSTOP,
    0x015A: CMSG_REPOP_REQUEST,
    0x015C: CMSG_RESURRECT_RESPONSE,
    0x015D: CMSG_LOOT,
    0x015E: CMSG_LOOT_MONEY,
    0x015F: CMSG_LOOT_RELEASE,
    0x016C: CMSG_DUEL_ACCEPTED,
    0x016D: CMSG_DUEL_CANCELLED,
    0x0171: CMSG_MOUNTSPECIAL_ANIM,
    0x0174: CMSG_PET_SET_ACTION,
    0x0175: CMSG_PET_ACTION,
    0x0176: CMSG_PET_ABANDON,
    0x0177: CMSG_PET_RENAME,
    0x017B: CMSG_GOSSIP_HELLO,
    0x017C: CMSG_GOSSIP_SELECT_OPTION,
    0x017F: CMSG_NPC_TEXT_QUERY,
    0x0182: CMSG_QUESTGIVER_STATUS_QUERY,
    0x0184: CMSG_QUESTGIVER_HELLO,
    0x0186: CMSG_QUESTGIVER_QUERY_QUEST,
    0x0187: CMSG_QUESTGIVER_QUEST_AUTOLAUNCH,
    0x0189: CMSG_QUESTGIVER_ACCEPT_QUEST,
    0x018A: CMSG_QUESTGIVER_COMPLETE_QUEST,
    0x018C: CMSG_QUESTGIVER_REQUEST_REWARD,
    0x018E: CMSG_QUESTGIVER_CHOOSE_REWARD,
    0x0190: CMSG_QUESTGIVER_CANCEL,
    0x0193: CMSG_QUESTLOG_SWAP_QUEST,
    0x0194: CMSG_QUESTLOG_REMOVE_QUEST,
    0x019B: CMSG_QUEST_CONFIRM_ACCEPT,
    0x019D: CMSG_PUSHQUESTTOPARTY,
    0x019E: CMSG_LIST_INVENTORY,
    0x01A0: CMSG_SELL_ITEM,
    0x01A2: CMSG_BUY_ITEM,
    0x01A3: CMSG_BUY_ITEM_IN_SLOT,
    0x01AA: CMSG_TAXINODE_STATUS_QUERY,
    0x01AC: CMSG_TAXIQUERYAVAILABLENODES,
    0x01AD: CMSG_ACTIVATETAXI,
    0x01B0: CMSG_TRAINER_LIST,
    0x01B2: CMSG_TRAINER_BUY_SPELL,
    0x01B5: CMSG_BINDER_ACTIVATE,
    0x01B7: CMSG_BANKER_ACTIVATE,
    0x01B9: CMSG_BUY_BANK_SLOT,
    0x01BB: CMSG_PETITION_SHOWLIST,
    0x01BD: CMSG_PETITION_BUY,
    0x01BE: CMSG_PETITION_SHOW_SIGNATURES,
    0x01C0: CMSG_PETITION_SIGN,
    0x01C2: MSG_PETITION_DECLINE,
    0x01C3: CMSG_OFFER_PETITION,
    0x01C4: CMSG_TURN_IN_PETITION,
    0x01C6: CMSG_PETITION_QUERY,
    0x01CA: CMSG_BUG,
    0x01CC: CMSG_PLAYED_TIME,
    0x01CE: CMSG_QUERY_TIME,
    0x01D2: CMSG_RECLAIM_CORPSE,
    0x01D3: CMSG_WRAP_ITEM,
    0x01D5: MSG_MINIMAP_PING_Client,
    0x01DC: CMSG_PING,
    0x01E0: CMSG_SETSHEATHED,
    0x01ED: CMSG_AUTH_SESSION,
    0x01F0: CMSG_PET_CAST_SPELL,
    0x01F1: MSG_SAVE_GUILD_EMBLEM_Client,
    0x01F2: MSG_TABARDVENDOR_ACTIVATE,
    0x01F4: CMSG_ZONEUPDATE,
    0x01FB: MSG_RANDOM_ROLL_Client,
    0x01FF: MSG_LOOKING_FOR_GROUP_Client,
    0x0200: CMSG_SET_LOOKING_FOR_GROUP,
    0x0202: CMSG_UNLEARN_SKILL,
    0x0205: CMSG_GMTICKET_CREATE,
    0x0207: CMSG_GMTICKET_UPDATETEXT,
    0x020A: CMSG_REQUEST_ACCOUNT_DATA,
    0x020B: CMSG_UPDATE_ACCOUNT_DATA,
    0x0211: CMSG_GMTICKET_GETTICKET,
    0x0213: CMSG_UNLEARN_TALENTS,
    0x0216: MSG_CORPSE_QUERY_Client,
    0x0217: CMSG_GMTICKET_DELETETICKET,
    0x021A: CMSG_GMTICKET_SYSTEMSTATUS,
    0x021C: CMSG_SPIRIT_HEALER_ACTIVATE,
    0x0225: CMSG_CHAT_IGNORED,
    0x0231: CMSG_GUILD_RANK,
    0x0232: CMSG_GUILD_ADD_RANK,
    0x0233: CMSG_GUILD_DEL_RANK,
    0x0234: CMSG_GUILD_SET_PUBLIC_NOTE,
    0x0235: CMSG_GUILD_SET_OFFICER_NOTE,
    0x0238: CMSG_SEND_MAIL,
    0x023A: CMSG_GET_MAIL_LIST,
    0x023C: CMSG_BATTLEFIELD_LIST,
    0x0243: CMSG_ITEM_TEXT_QUERY,
    0x0245: CMSG_MAIL_TAKE_MONEY,
    0x0246: CMSG_MAIL_TAKE_ITEM,
    0x0247: CMSG_MAIL_MARK_AS_READ,
    0x0248: CMSG_MAIL_RETURN_TO_SENDER,
    0x0249: CMSG_MAIL_DELETE,
    0x024A: CMSG_MAIL_CREATE_TEXT_ITEM,
    0x0251: CMSG_LEARN_TALENT,
    0x0253: CMSG_TOGGLE_PVP,
    0x0255: MSG_AUCTION_HELLO_Client,
    0x0256: CMSG_AUCTION_SELL_ITEM,
    0x0257: CMSG_AUCTION_REMOVE_ITEM,
    0x0258: CMSG_AUCTION_LIST_ITEMS,
    0x0259: CMSG_AUCTION_LIST_OWNER_ITEMS,
    0x025A: CMSG_AUCTION_PLACE_BID,
    0x0264: CMSG_AUCTION_LIST_BIDDER_ITEMS,
    0x0268: CMSG_SET_AMMO,
    0x026A: CMSG_SET_ACTIVE_MOVER,
    0x026B: CMSG_PET_CANCEL_AURA,
    0x026D: CMSG_CANCEL_AUTO_REPEAT_SPELL,
    0x026F: MSG_LIST_STABLED_PETS_Client,
    0x0270: CMSG_STABLE_PET,
    0x0271: CMSG_UNSTABLE_PET,
    0x0272: CMSG_BUY_STABLE_SLOT,
    0x0275: CMSG_STABLE_SWAP_PET,
    0x0276: MSG_QUEST_PUSH_RESULT,
    0x0279: CMSG_REQUEST_PET_INFO,
    0x027A: CMSG_FAR_SIGHT,
    0x027E: CMSG_GROUP_CHANGE_SUB_GROUP,
    0x027F: CMSG_REQUEST_PARTY_MEMBER_STATS,
    0x0280: CMSG_GROUP_SWAP_SUB_GROUP,
    0x0282: CMSG_AUTOSTORE_BANK_ITEM,
    0x0283: CMSG_AUTOBANK_ITEM,
    0x0284: MSG_QUERY_NEXT_MAIL_TIME_Client,
    0x028E: CMSG_GROUP_RAID_CONVERT,
    0x028F: CMSG_GROUP_ASSISTANT_LEADER,
    0x0290: CMSG_BUYBACK_ITEM,
    0x0296: CMSG_MEETINGSTONE_INFO,
    0x029A: CMSG_GMTICKETSYSTEM_TOGGLE,
    0x029B: CMSG_CANCEL_GROWTH_AURA,
    0x02A0: CMSG_LOOT_ROLL,
    0x02A3: CMSG_LOOT_MASTER_GIVE,
    0x02A8: CMSG_REPAIR_ITEM,
    0x02AA: MSG_TALENT_WIPE_CONFIRM_Client,
    0x02AC: CMSG_SUMMON_RESPONSE,
    0x02B1: MSG_MOVE_WATER_WALK,
    0x02B3: CMSG_SELF_RES,
    0x02B9: CMSG_TOGGLE_HELM,
    0x02BA: CMSG_TOGGLE_CLOAK,
    0x02BF: CMSG_SET_ACTIONBAR_TOGGLES,
    0x02C1: MSG_PETITION_RENAME,
    0x02C4: CMSG_ITEM_NAME_QUERY,
    0x02C7: CMSG_CHAR_RENAME,
    0x02C9: CMSG_MOVE_SPLINE_DONE,
    0x02CA: CMSG_MOVE_FALL_RESET,
    0x02CD: CMSG_REQUEST_RAID_INFO,
    0x02CE: CMSG_MOVE_TIME_SKIPPED,
    0x02CF: CMSG_MOVE_FEATHER_FALL_ACK,
    0x02D0: CMSG_MOVE_WATER_WALK_ACK,
    0x02D1: CMSG_MOVE_NOT_ACTIVE_MOVER,
    0x02D3: CMSG_BATTLEFIELD_STATUS,
    0x02D5: CMSG_BATTLEFIELD_PORT,
    0x02D6: MSG_INSPECT_HONOR_STATS_Client,
    0x02D7: CMSG_BATTLEMASTER_HELLO,
    0x02DB: CMSG_FORCE_WALK_SPEED_CHANGE_ACK,
    0x02DD: CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK,
    0x02DF: CMSG_FORCE_TURN_RATE_CHANGE_ACK,
    0x02E0: MSG_PVP_LOG_DATA_Client,
    0x02E1: CMSG_LEAVE_BATTLEFIELD,
    0x02E2: CMSG_AREA_SPIRIT_HEALER_QUERY,
    0x02E3: CMSG_AREA_SPIRIT_HEALER_QUEUE,
    0x02E7: CMSG_WARDEN_DATA,
    0x02E9: MSG_BATTLEGROUND_PLAYER_POSITIONS_Client,
    0x02EA: CMSG_PET_STOP_ATTACK,
    0x02EE: CMSG_BATTLEMASTER_JOIN,
    0x02F0: CMSG_PET_UNLEARN,
    0x02F3: CMSG_PET_SPELL_AUTOCAST,
    0x02FC: CMSG_GUILD_INFO_TEXT,
    0x0312: CMSG_ACTIVATETAXIEXPRESS,
    0x0317: CMSG_SET_FACTION_INACTIVE,
    0x0318: CMSG_SET_WATCHED_FACTION,
    0x031D: CMSG_RESET_INSTANCES,
    0x0321: MSG_RAID_TARGET_UPDATE_Client,
    0x0322: MSG_RAID_READY_CHECK_Client,
    0x0329: MSG_SET_DUNGEON_DIFFICULTY_Client,
    0x032A: CMSG_GMSURVEY_SUBMIT,
    0x0345: CMSG_MOVE_SET_CAN_FLY_ACK,
    0x0346: CMSG_MOVE_SET_FLY,
    0x0347: CMSG_SOCKET_GEMS,
    0x034D: CMSG_ARENA_TEAM_ROSTER,
    0x034F: CMSG_ARENA_TEAM_INVITE,
    0x0351: CMSG_ARENA_TEAM_ACCEPT,
    0x0352: CMSG_ARENA_TEAM_DECLINE,
    0x0353: CMSG_ARENA_TEAM_LEAVE,
    0x0354: CMSG_ARENA_TEAM_REMOVE,
    0x0355: CMSG_ARENA_TEAM_DISBAND,
    0x0356: CMSG_ARENA_TEAM_LEADER,
    0x0358: CMSG_BATTLEMASTER_JOIN_ARENA,
    0x0359: MSG_MOVE_START_ASCEND_Client,
    0x035A: MSG_MOVE_STOP_ASCEND_Client,
    0x035C: CMSG_LFG_SET_AUTOJOIN,
    0x035D: CMSG_LFG_CLEAR_AUTOJOIN,
    0x035E: CMSG_LFM_SET_AUTOFILL,
    0x035F: CMSG_LFM_CLEAR_AUTOFILL,
    0x0363: CMSG_CLEAR_LOOKING_FOR_GROUP,
    0x0364: CMSG_CLEAR_LOOKING_FOR_MORE,
    0x0365: CMSG_SET_LOOKING_FOR_MORE,
    0x0366: CMSG_SET_LFG_COMMENT,
    0x0374: CMSG_SET_TITLE,
    0x0375: CMSG_CANCEL_MOUNT_AURA,
    0x0377: MSG_INSPECT_ARENA_TEAMS_Client,
    0x0379: CMSG_CANCEL_TEMP_ENCHANTMENT,
    0x0380: MSG_MOVE_SET_FLIGHT_BACK_SPEED,
    0x0382: CMSG_FORCE_FLIGHT_SPEED_CHANGE_ACK,
    0x0384: CMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE_ACK,
    0x0389: CMSG_SET_TAXI_BENCHMARK_MODE,
    0x038C: CMSG_REALM_SPLIT,
    0x038D: CMSG_MOVE_CHNG_TRANSPORT,
    0x038E: MSG_PARTY_ASSIGNMENT_Client,
    0x0391: CMSG_TIME_SYNC_RESP,
    0x03A7: MSG_MOVE_START_DESCEND_Client,
    0x03AE: MSG_RAID_READY_CHECK_CONFIRM_Client,
    0x03AF: CMSG_VOICE_SESSION_ENABLE,
    0x03B4: CMSG_COMMENTATOR_ENABLE,
    0x03C5: MSG_RAID_READY_CHECK_FINISHED_Client,
    0x03C6: CMSG_COMPLAIN,
    0x03D1: CMSG_CHANNEL_DISPLAY_LIST,
    0x03D2: CMSG_SET_ACTIVE_VOICE_CHANNEL,
    0x03D3: CMSG_GET_CHANNEL_MEMBER_COUNT,
    0x03D5: CMSG_CHANNEL_VOICE_ON,
    0x03E3: CMSG_REPORT_PVP_AFK,
    0x03E5: CMSG_GUILD_BANKER_ACTIVATE,
    0x03E6: CMSG_GUILD_BANK_QUERY_TAB,
    0x03E8: CMSG_GUILD_BANK_SWAP_ITEMS,
    0x03E9: CMSG_GUILD_BANK_BUY_TAB,
    0x03EA: CMSG_GUILD_BANK_UPDATE_TAB,
    0x03EB: CMSG_GUILD_BANK_DEPOSIT_MONEY,
    0x03EC: CMSG_GUILD_BANK_WITHDRAW_MONEY,
    0x03ED: MSG_GUILD_BANK_LOG_QUERY_Client,
    0x03EE: CMSG_SET_CHANNEL_WATCH,
    0x03F2: CMSG_CLEAR_CHANNEL_WATCH,
    0x03F7: CMSG_SPELLCLICK,
    0x03FC: MSG_GUILD_PERMISSIONS_Client,
    0x03FD: MSG_GUILD_BANK_MONEY_WITHDRAWN_Client,
    0x03FE: MSG_GUILD_EVENT_LOG_QUERY_Client,
    0x0400: CMSG_GET_MIRRORIMAGE_DATA,
    0x0406: CMSG_KEEP_ALIVE,
    0x0408: CMSG_OPT_OUT_OF_LOOT,
    0x0409: MSG_QUERY_GUILD_BANK_TEXT_Client,
    0x040A: CMSG_SET_GUILD_BANK_TEXT,
    0x040C: CMSG_GRANT_LEVEL,
    0x0413: CMSG_TOTEM_DESTROYED,
    0x0416: CMSG_QUESTGIVER_STATUS_MULTIPLE_QUERY,
    0x0418: CMSG_SET_PLAYER_DECLINED_NAMES,
    0x041F: CMSG_ACCEPT_LEVEL_GRANT,
}


async def read_client_opcode_body(
    reader: asyncio.StreamReader,
    opcode: int,
    body_size: int,
) -> ClientOpcode:
    return await client_opcodes[opcode].read(reader, body_size)


server_opcodes: dict[int, ServerOpcode] = {
    0x003A: SMSG_CHAR_CREATE,
    0x003B: SMSG_CHAR_ENUM,
    0x003C: SMSG_CHAR_DELETE,
    0x003E: SMSG_NEW_WORLD,
    0x003F: SMSG_TRANSFER_PENDING,
    0x0040: SMSG_TRANSFER_ABORTED,
    0x0041: SMSG_CHARACTER_LOGIN_FAILED,
    0x0042: SMSG_LOGIN_SETTIMESPEED,
    0x004C: SMSG_LOGOUT_RESPONSE,
    0x004D: SMSG_LOGOUT_COMPLETE,
    0x004F: SMSG_LOGOUT_CANCEL_ACK,
    0x0051: SMSG_NAME_QUERY_RESPONSE,
    0x0053: SMSG_PET_NAME_QUERY_RESPONSE,
    0x0055: SMSG_GUILD_QUERY_RESPONSE,
    0x0058: SMSG_ITEM_QUERY_SINGLE_RESPONSE,
    0x005B: SMSG_PAGE_TEXT_QUERY_RESPONSE,
    0x005D: SMSG_QUEST_QUERY_RESPONSE,
    0x005F: SMSG_GAMEOBJECT_QUERY_RESPONSE,
    0x0061: SMSG_CREATURE_QUERY_RESPONSE,
    0x0063: SMSG_WHO,
    0x0065: SMSG_WHOIS,
    0x0067: SMSG_CONTACT_LIST,
    0x0068: SMSG_FRIEND_STATUS,
    0x006F: SMSG_GROUP_INVITE,
    0x0074: SMSG_GROUP_DECLINE,
    0x0077: SMSG_GROUP_UNINVITE,
    0x0079: SMSG_GROUP_SET_LEADER,
    0x007C: SMSG_GROUP_DESTROYED,
    0x007D: SMSG_GROUP_LIST,
    0x007E: SMSG_PARTY_MEMBER_STATS,
    0x007F: SMSG_PARTY_COMMAND_RESULT,
    0x0083: SMSG_GUILD_INVITE,
    0x0086: SMSG_GUILD_DECLINE,
    0x0088: SMSG_GUILD_INFO,
    0x008A: SMSG_GUILD_ROSTER,
    0x0092: SMSG_GUILD_EVENT,
    0x0093: SMSG_GUILD_COMMAND_RESULT,
    0x0096: SMSG_MESSAGECHAT,
    0x0099: SMSG_CHANNEL_NOTIFY,
    0x009B: SMSG_CHANNEL_LIST,
    0x00A9: SMSG_UPDATE_OBJECT,
    0x00AA: SMSG_DESTROY_OBJECT,
    0x00AE: SMSG_READ_ITEM_OK,
    0x00AF: SMSG_READ_ITEM_FAILED,
    0x00B0: SMSG_ITEM_COOLDOWN,
    0x00B3: SMSG_GAMEOBJECT_CUSTOM_ANIM,
    0x00B5: MSG_MOVE_START_FORWARD_Server,
    0x00B6: MSG_MOVE_START_BACKWARD_Server,
    0x00B7: MSG_MOVE_STOP_Server,
    0x00B8: MSG_MOVE_START_STRAFE_LEFT_Server,
    0x00B9: MSG_MOVE_START_STRAFE_RIGHT_Server,
    0x00BA: MSG_MOVE_STOP_STRAFE_Server,
    0x00BB: MSG_MOVE_JUMP_Server,
    0x00BC: MSG_MOVE_START_TURN_LEFT_Server,
    0x00BD: MSG_MOVE_START_TURN_RIGHT_Server,
    0x00BE: MSG_MOVE_STOP_TURN_Server,
    0x00BF: MSG_MOVE_START_PITCH_UP_Server,
    0x00C0: MSG_MOVE_START_PITCH_DOWN_Server,
    0x00C1: MSG_MOVE_STOP_PITCH_Server,
    0x00C2: MSG_MOVE_SET_RUN_MODE_Server,
    0x00C3: MSG_MOVE_SET_WALK_MODE_Server,
    0x00C6: MSG_MOVE_TELEPORT_CHEAT_Server,
    0x00C7: MSG_MOVE_TELEPORT_ACK_Server,
    0x00C9: MSG_MOVE_FALL_LAND_Server,
    0x00CA: MSG_MOVE_START_SWIM_Server,
    0x00CB: MSG_MOVE_STOP_SWIM_Server,
    0x00DA: MSG_MOVE_SET_FACING_Server,
    0x00DB: MSG_MOVE_SET_PITCH_Server,
    0x00DC: MSG_MOVE_WORLDPORT_ACK,
    0x00DD: SMSG_MONSTER_MOVE,
    0x00DE: SMSG_MOVE_WATER_WALK,
    0x00DF: SMSG_MOVE_LAND_WALK,
    0x00E2: SMSG_FORCE_RUN_SPEED_CHANGE,
    0x00E4: SMSG_FORCE_RUN_BACK_SPEED_CHANGE,
    0x00E6: SMSG_FORCE_SWIM_SPEED_CHANGE,
    0x00E8: SMSG_FORCE_MOVE_ROOT,
    0x00EA: SMSG_FORCE_MOVE_UNROOT,
    0x00EC: MSG_MOVE_ROOT_Server,
    0x00ED: MSG_MOVE_UNROOT_Server,
    0x00EE: MSG_MOVE_HEARTBEAT_Server,
    0x00EF: SMSG_MOVE_KNOCK_BACK,
    0x00F1: MSG_MOVE_KNOCK_BACK_Server,
    0x00F2: SMSG_MOVE_FEATHER_FALL,
    0x00F3: SMSG_MOVE_NORMAL_FALL,
    0x00F4: SMSG_MOVE_SET_HOVER,
    0x00F5: SMSG_MOVE_UNSET_HOVER,
    0x00F7: MSG_MOVE_HOVER,
    0x00FA: SMSG_TRIGGER_CINEMATIC,
    0x00FD: SMSG_TUTORIAL_FLAGS,
    0x0103: SMSG_EMOTE,
    0x0105: SMSG_TEXT_EMOTE,
    0x0112: SMSG_INVENTORY_CHANGE_FAILURE,
    0x0120: SMSG_TRADE_STATUS,
    0x0121: SMSG_TRADE_STATUS_EXTENDED,
    0x0122: SMSG_INITIALIZE_FACTIONS,
    0x0123: SMSG_SET_FACTION_VISIBLE,
    0x0124: SMSG_SET_FACTION_STANDING,
    0x0127: SMSG_SET_PROFICIENCY,
    0x0129: SMSG_ACTION_BUTTONS,
    0x012A: SMSG_INITIAL_SPELLS,
    0x012B: SMSG_LEARNED_SPELL,
    0x012C: SMSG_SUPERCEDED_SPELL,
    0x0130: SMSG_CAST_FAILED,
    0x0131: SMSG_SPELL_START,
    0x0132: SMSG_SPELL_GO,
    0x0133: SMSG_SPELL_FAILURE,
    0x0134: SMSG_SPELL_COOLDOWN,
    0x0135: SMSG_COOLDOWN_EVENT,
    0x0137: SMSG_UPDATE_AURA_DURATION,
    0x0138: SMSG_PET_CAST_FAILED,
    0x0139: MSG_CHANNEL_START_Server,
    0x013A: MSG_CHANNEL_UPDATE_Server,
    0x013C: SMSG_AI_REACTION,
    0x0143: SMSG_ATTACKSTART,
    0x0144: SMSG_ATTACKSTOP,
    0x0145: SMSG_ATTACKSWING_NOTINRANGE,
    0x0146: SMSG_ATTACKSWING_BADFACING,
    0x0147: SMSG_ATTACKSWING_NOTSTANDING,
    0x0148: SMSG_ATTACKSWING_DEADTARGET,
    0x0149: SMSG_ATTACKSWING_CANT_ATTACK,
    0x014A: SMSG_ATTACKERSTATEUPDATE,
    0x014E: SMSG_CANCEL_COMBAT,
    0x0150: SMSG_SPELLHEALLOG,
    0x0151: SMSG_SPELLENERGIZELOG,
    0x0155: SMSG_BINDPOINTUPDATE,
    0x0158: SMSG_PLAYERBOUND,
    0x0159: SMSG_CLIENT_CONTROL_UPDATE,
    0x015B: SMSG_RESURRECT_REQUEST,
    0x0160: SMSG_LOOT_RESPONSE,
    0x0161: SMSG_LOOT_RELEASE_RESPONSE,
    0x0162: SMSG_LOOT_REMOVED,
    0x0163: SMSG_LOOT_MONEY_NOTIFY,
    0x0165: SMSG_LOOT_CLEAR_MONEY,
    0x0166: SMSG_ITEM_PUSH_RESULT,
    0x0167: SMSG_DUEL_REQUESTED,
    0x0168: SMSG_DUEL_OUTOFBOUNDS,
    0x0169: SMSG_DUEL_INBOUNDS,
    0x016A: SMSG_DUEL_COMPLETE,
    0x016B: SMSG_DUEL_WINNER,
    0x016E: SMSG_MOUNTRESULT,
    0x0172: SMSG_MOUNTSPECIAL_ANIM,
    0x0173: SMSG_PET_TAME_FAILURE,
    0x0178: SMSG_PET_NAME_INVALID,
    0x0179: SMSG_PET_SPELLS,
    0x017A: SMSG_PET_MODE,
    0x017D: SMSG_GOSSIP_MESSAGE,
    0x017E: SMSG_GOSSIP_COMPLETE,
    0x0180: SMSG_NPC_TEXT_UPDATE,
    0x0183: SMSG_QUESTGIVER_STATUS,
    0x0185: SMSG_QUESTGIVER_QUEST_LIST,
    0x0188: SMSG_QUESTGIVER_QUEST_DETAILS,
    0x018B: SMSG_QUESTGIVER_REQUEST_ITEMS,
    0x018D: SMSG_QUESTGIVER_OFFER_REWARD,
    0x018F: SMSG_QUESTGIVER_QUEST_INVALID,
    0x0191: SMSG_QUESTGIVER_QUEST_COMPLETE,
    0x0192: SMSG_QUESTGIVER_QUEST_FAILED,
    0x0195: SMSG_QUESTLOG_FULL,
    0x0196: SMSG_QUESTUPDATE_FAILED,
    0x0197: SMSG_QUESTUPDATE_FAILEDTIMER,
    0x0198: SMSG_QUESTUPDATE_COMPLETE,
    0x0199: SMSG_QUESTUPDATE_ADD_KILL,
    0x019A: SMSG_QUESTUPDATE_ADD_ITEM,
    0x019C: SMSG_QUEST_CONFIRM_ACCEPT,
    0x019F: SMSG_LIST_INVENTORY,
    0x01A1: SMSG_SELL_ITEM,
    0x01A4: SMSG_BUY_ITEM,
    0x01A5: SMSG_BUY_FAILED,
    0x01A9: SMSG_SHOWTAXINODES,
    0x01AB: SMSG_TAXINODE_STATUS,
    0x01AE: SMSG_ACTIVATETAXIREPLY,
    0x01AF: SMSG_NEW_TAXI_PATH,
    0x01B1: SMSG_TRAINER_LIST,
    0x01B3: SMSG_TRAINER_BUY_SUCCEEDED,
    0x01B4: SMSG_TRAINER_BUY_FAILED,
    0x01B8: SMSG_SHOW_BANK,
    0x01BA: SMSG_BUY_BANK_SLOT_RESULT,
    0x01BC: SMSG_PETITION_SHOWLIST,
    0x01BF: SMSG_PETITION_SHOW_SIGNATURES,
    0x01C1: SMSG_PETITION_SIGN_RESULTS,
    0x01C2: MSG_PETITION_DECLINE,
    0x01C5: SMSG_TURN_IN_PETITION_RESULTS,
    0x01C7: SMSG_PETITION_QUERY_RESPONSE,
    0x01C8: SMSG_FISH_NOT_HOOKED,
    0x01C9: SMSG_FISH_ESCAPED,
    0x01CB: SMSG_NOTIFICATION,
    0x01CD: SMSG_PLAYED_TIME,
    0x01CF: SMSG_QUERY_TIME_RESPONSE,
    0x01D0: SMSG_LOG_XPGAIN,
    0x01D4: SMSG_LEVELUP_INFO,
    0x01D5: MSG_MINIMAP_PING_Server,
    0x01D7: SMSG_ENCHANTMENTLOG,
    0x01D9: SMSG_START_MIRROR_TIMER,
    0x01DA: SMSG_PAUSE_MIRROR_TIMER,
    0x01DB: SMSG_STOP_MIRROR_TIMER,
    0x01DD: SMSG_PONG,
    0x01DE: SMSG_CLEAR_COOLDOWN,
    0x01DF: SMSG_GAMEOBJECT_PAGETEXT,
    0x01E2: SMSG_SPELL_DELAYED,
    0x01EA: SMSG_ITEM_TIME_UPDATE,
    0x01EB: SMSG_ITEM_ENCHANT_TIME_UPDATE,
    0x01EC: SMSG_AUTH_CHALLENGE,
    0x01EE: SMSG_AUTH_RESPONSE,
    0x01F1: MSG_SAVE_GUILD_EMBLEM_Server,
    0x01F2: MSG_TABARDVENDOR_ACTIVATE,
    0x01F3: SMSG_PLAY_SPELL_VISUAL,
    0x01F5: SMSG_PARTYKILLLOG,
    0x01F6: SMSG_COMPRESSED_UPDATE_OBJECT,
    0x01F7: SMSG_PLAY_SPELL_IMPACT,
    0x01F8: SMSG_EXPLORATION_EXPERIENCE,
    0x01FB: MSG_RANDOM_ROLL_Server,
    0x01FC: SMSG_ENVIRONMENTAL_DAMAGE_LOG,
    0x01FF: MSG_LOOKING_FOR_GROUP_Server,
    0x0203: SMSG_REMOVED_SPELL,
    0x0206: SMSG_GMTICKET_CREATE,
    0x0208: SMSG_GMTICKET_UPDATETEXT,
    0x0209: SMSG_ACCOUNT_DATA_TIMES,
    0x020C: SMSG_UPDATE_ACCOUNT_DATA,
    0x0212: SMSG_GMTICKET_GETTICKET,
    0x0214: SMSG_GAMEOBJECT_SPAWN_ANIM,
    0x0215: SMSG_GAMEOBJECT_DESPAWN_ANIM,
    0x0216: MSG_CORPSE_QUERY_Server,
    0x0218: SMSG_GMTICKET_DELETETICKET,
    0x0219: SMSG_CHAT_WRONG_FACTION,
    0x021B: SMSG_GMTICKET_SYSTEMSTATUS,
    0x021E: SMSG_SET_REST_START,
    0x0222: SMSG_SPIRIT_HEALER_CONFIRM,
    0x0224: SMSG_GOSSIP_POI,
    0x0236: SMSG_LOGIN_VERIFY_WORLD,
    0x0239: SMSG_SEND_MAIL_RESULT,
    0x023B: SMSG_MAIL_LIST_RESULT,
    0x023D: SMSG_BATTLEFIELD_LIST,
    0x0244: SMSG_ITEM_TEXT_QUERY_RESPONSE,
    0x024B: SMSG_SPELLLOGMISS,
    0x024C: SMSG_SPELLLOGEXECUTE,
    0x024E: SMSG_PERIODICAURALOG,
    0x024F: SMSG_SPELLDAMAGESHIELD,
    0x0250: SMSG_SPELLNONMELEEDAMAGELOG,
    0x0252: SMSG_RESURRECT_FAILED,
    0x0254: SMSG_ZONE_UNDER_ATTACK,
    0x0255: MSG_AUCTION_HELLO_Server,
    0x025B: SMSG_AUCTION_COMMAND_RESULT,
    0x025C: SMSG_AUCTION_LIST_RESULT,
    0x025D: SMSG_AUCTION_OWNER_LIST_RESULT,
    0x025E: SMSG_AUCTION_BIDDER_NOTIFICATION,
    0x025F: SMSG_AUCTION_OWNER_NOTIFICATION,
    0x0260: SMSG_PROCRESIST,
    0x0262: SMSG_DISPEL_FAILED,
    0x0263: SMSG_SPELLORDAMAGE_IMMUNE,
    0x0265: SMSG_AUCTION_BIDDER_LIST_RESULT,
    0x0266: SMSG_SET_FLAT_SPELL_MODIFIER,
    0x0267: SMSG_SET_PCT_SPELL_MODIFIER,
    0x0269: SMSG_CORPSE_RECLAIM_DELAY,
    0x026F: MSG_LIST_STABLED_PETS_Server,
    0x0273: SMSG_STABLE_RESULT,
    0x0276: MSG_QUEST_PUSH_RESULT,
    0x0277: SMSG_PLAY_MUSIC,
    0x0278: SMSG_PLAY_OBJECT_SOUND,
    0x027B: SMSG_SPELLDISPELLOG,
    0x0284: MSG_QUERY_NEXT_MAIL_TIME_Server,
    0x0285: SMSG_RECEIVED_MAIL,
    0x0286: SMSG_RAID_GROUP_ONLY,
    0x028C: SMSG_PVP_CREDIT,
    0x028D: SMSG_AUCTION_REMOVED_NOTIFICATION,
    0x0291: SMSG_SERVER_MESSAGE,
    0x0295: SMSG_MEETINGSTONE_SETQUEUE,
    0x029C: SMSG_CANCEL_AUTO_REPEAT,
    0x029D: SMSG_STANDSTATE_UPDATE,
    0x029E: SMSG_LOOT_ALL_PASSED,
    0x029F: SMSG_LOOT_ROLL_WON,
    0x02A1: SMSG_LOOT_START_ROLL,
    0x02A2: SMSG_LOOT_ROLL,
    0x02A4: SMSG_LOOT_MASTER_LIST,
    0x02A5: SMSG_SET_FORCED_REACTIONS,
    0x02A6: SMSG_SPELL_FAILED_OTHER,
    0x02A9: SMSG_CHAT_PLAYER_NOT_FOUND,
    0x02AA: MSG_TALENT_WIPE_CONFIRM_Server,
    0x02AB: SMSG_SUMMON_REQUEST,
    0x02AE: SMSG_MONSTER_MOVE_TRANSPORT,
    0x02AF: SMSG_PET_BROKEN,
    0x02B0: MSG_MOVE_FEATHER_FALL_Server,
    0x02B1: MSG_MOVE_WATER_WALK,
    0x02B4: SMSG_FEIGN_DEATH_RESISTED,
    0x02B7: SMSG_DUEL_COUNTDOWN,
    0x02B8: SMSG_AREA_TRIGGER_MESSAGE,
    0x02BC: SMSG_PLAYER_SKINNED,
    0x02BD: SMSG_DURABILITY_DAMAGE_DEATH,
    0x02C1: MSG_PETITION_RENAME,
    0x02C2: SMSG_INIT_WORLD_STATES,
    0x02C3: SMSG_UPDATE_WORLD_STATE,
    0x02C5: SMSG_ITEM_NAME_QUERY_RESPONSE,
    0x02C6: SMSG_PET_ACTION_FEEDBACK,
    0x02C8: SMSG_CHAR_RENAME,
    0x02CB: SMSG_INSTANCE_SAVE_CREATED,
    0x02CC: SMSG_RAID_INSTANCE_INFO,
    0x02D2: SMSG_PLAY_SOUND,
    0x02D4: SMSG_BATTLEFIELD_STATUS,
    0x02D6: MSG_INSPECT_HONOR_STATS_Server,
    0x02DA: SMSG_FORCE_WALK_SPEED_CHANGE,
    0x02DC: SMSG_FORCE_SWIM_BACK_SPEED_CHANGE,
    0x02DE: SMSG_FORCE_TURN_RATE_CHANGE,
    0x02E4: SMSG_AREA_SPIRIT_HEALER_TIME,
    0x02E6: SMSG_WARDEN_DATA,
    0x02E8: SMSG_GROUP_JOINED_BATTLEGROUND,
    0x02E9: MSG_BATTLEGROUND_PLAYER_POSITIONS_Server,
    0x02EB: SMSG_BINDER_CONFIRM,
    0x02EC: SMSG_BATTLEGROUND_PLAYER_JOINED,
    0x02ED: SMSG_BATTLEGROUND_PLAYER_LEFT,
    0x02EF: SMSG_ADDON_INFO,
    0x02F1: SMSG_PET_UNLEARN_CONFIRM,
    0x02F2: SMSG_PARTY_MEMBER_STATS_FULL,
    0x02F4: SMSG_WEATHER,
    0x02FA: SMSG_RAID_INSTANCE_MESSAGE,
    0x02FD: SMSG_CHAT_RESTRICTED,
    0x02FE: SMSG_SPLINE_SET_RUN_SPEED,
    0x02FF: SMSG_SPLINE_SET_RUN_BACK_SPEED,
    0x0300: SMSG_SPLINE_SET_SWIM_SPEED,
    0x0301: SMSG_SPLINE_SET_WALK_SPEED,
    0x0302: SMSG_SPLINE_SET_SWIM_BACK_SPEED,
    0x0303: SMSG_SPLINE_SET_TURN_RATE,
    0x0304: SMSG_SPLINE_MOVE_UNROOT,
    0x0305: SMSG_SPLINE_MOVE_FEATHER_FALL,
    0x0306: SMSG_SPLINE_MOVE_NORMAL_FALL,
    0x0307: SMSG_SPLINE_MOVE_SET_HOVER,
    0x0308: SMSG_SPLINE_MOVE_UNSET_HOVER,
    0x0309: SMSG_SPLINE_MOVE_WATER_WALK,
    0x030A: SMSG_SPLINE_MOVE_LAND_WALK,
    0x030B: SMSG_SPLINE_MOVE_START_SWIM,
    0x030C: SMSG_SPLINE_MOVE_STOP_SWIM,
    0x030D: SMSG_SPLINE_MOVE_SET_RUN_MODE,
    0x030E: SMSG_SPLINE_MOVE_SET_WALK_MODE,
    0x0319: MSG_MOVE_TIME_SKIPPED_Server,
    0x031A: SMSG_SPLINE_MOVE_ROOT,
    0x031C: SMSG_INVALIDATE_PLAYER,
    0x031E: SMSG_INSTANCE_RESET,
    0x031F: SMSG_INSTANCE_RESET_FAILED,
    0x0320: SMSG_UPDATE_LAST_INSTANCE,
    0x0321: MSG_RAID_TARGET_UPDATE_Server,
    0x0322: MSG_RAID_READY_CHECK_Server,
    0x0324: SMSG_PET_ACTION_SOUND,
    0x0325: SMSG_PET_DISMISS_SOUND,
    0x0328: SMSG_GM_TICKET_STATUS_UPDATE,
    0x0329: MSG_SET_DUNGEON_DIFFICULTY_Server,
    0x032B: SMSG_UPDATE_INSTANCE_OWNERSHIP,
    0x032D: SMSG_CHAT_PLAYER_AMBIGUOUS,
    0x032F: SMSG_SPELLINSTAKILLLOG,
    0x0330: SMSG_SPELL_UPDATE_CHAIN_TARGETS,
    0x0333: SMSG_SPELLSTEALLOG,
    0x033A: SMSG_DEFENSE_MESSAGE,
    0x033B: SMSG_INSTANCE_DIFFICULTY,
    0x033D: SMSG_MOTD,
    0x033E: SMSG_MOVE_SET_FLIGHT,
    0x033F: SMSG_MOVE_UNSET_FLIGHT,
    0x0343: SMSG_MOVE_SET_CAN_FLY,
    0x0344: SMSG_MOVE_UNSET_CAN_FLY,
    0x0349: SMSG_ARENA_TEAM_COMMAND_RESULT,
    0x034C: SMSG_ARENA_TEAM_QUERY_RESPONSE,
    0x034E: SMSG_ARENA_TEAM_ROSTER,
    0x0350: SMSG_ARENA_TEAM_INVITE,
    0x0357: SMSG_ARENA_TEAM_EVENT,
    0x0359: MSG_MOVE_START_ASCEND_Server,
    0x035A: MSG_MOVE_STOP_ASCEND_Server,
    0x035B: SMSG_ARENA_TEAM_STATS,
    0x036B: SMSG_LFG_LEADER_IS_LFM,
    0x036C: SMSG_LFG_UPDATE,
    0x036D: SMSG_LFG_UPDATE_LFM,
    0x036E: SMSG_LFG_UPDATE_LFG,
    0x036F: SMSG_LFG_UPDATE_QUEUED,
    0x0373: SMSG_TITLE_EARNED,
    0x0376: SMSG_ARENA_ERROR,
    0x0377: MSG_INSPECT_ARENA_TEAMS_Server,
    0x0378: SMSG_DEATH_RELEASE_LOC,
    0x037A: SMSG_FORCED_DEATH_UPDATE,
    0x037E: MSG_MOVE_SET_FLIGHT_SPEED_Server,
    0x0380: MSG_MOVE_SET_FLIGHT_BACK_SPEED,
    0x0381: SMSG_FORCE_FLIGHT_SPEED_CHANGE,
    0x0383: SMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE,
    0x0385: SMSG_SPLINE_SET_FLIGHT_SPEED,
    0x0386: SMSG_SPLINE_SET_FLIGHT_BACK_SPEED,
    0x0388: SMSG_FLIGHT_SPLINE_SYNC,
    0x038B: SMSG_REALM_SPLIT,
    0x0390: SMSG_TIME_SYNC_REQ,
    0x0396: SMSG_RESET_FAILED_NOTIFY,
    0x0398: SMSG_LFG_DISABLED,
    0x039D: SMSG_UPDATE_COMBO_POINTS,
    0x03A4: SMSG_SET_EXTRA_AURA_INFO,
    0x03A5: SMSG_SET_EXTRA_AURA_INFO_NEED_UPDATE,
    0x03A6: SMSG_CLEAR_EXTRA_AURA_INFO,
    0x03A7: MSG_MOVE_START_DESCEND_Server,
    0x03AC: SMSG_DISMOUNT,
    0x03AD: MSG_MOVE_UPDATE_CAN_FLY_Server,
    0x03AE: MSG_RAID_READY_CHECK_CONFIRM_Server,
    0x03B2: SMSG_GM_MESSAGECHAT,
    0x03BE: SMSG_CLEAR_TARGET,
    0x03C0: SMSG_CROSSED_INEBRIATION_THRESHOLD,
    0x03C4: SMSG_KICK_REASON,
    0x03C7: SMSG_COMPLAIN_RESULT,
    0x03C8: SMSG_FEATURE_SYSTEM_STATUS,
    0x03D4: SMSG_CHANNEL_MEMBER_COUNT,
    0x03E7: SMSG_GUILD_BANK_LIST,
    0x03ED: MSG_GUILD_BANK_LOG_QUERY_Server,
    0x03EF: SMSG_USERLIST_ADD,
    0x03F0: SMSG_USERLIST_REMOVE,
    0x03F1: SMSG_USERLIST_UPDATE,
    0x03F3: SMSG_INSPECT_TALENT,
    0x03F8: SMSG_LOOT_LIST,
    0x03FC: MSG_GUILD_PERMISSIONS_Server,
    0x03FD: MSG_GUILD_BANK_MONEY_WITHDRAWN_Server,
    0x03FE: MSG_GUILD_EVENT_LOG_QUERY_Server,
    0x0401: SMSG_MIRRORIMAGE_DATA,
    0x0409: MSG_QUERY_GUILD_BANK_TEXT_Server,
    0x0411: SMSG_OVERRIDE_LIGHT,
    0x0412: SMSG_TOTEM_CREATED,
    0x0417: SMSG_QUESTGIVER_STATUS_MULTIPLE,
    0x0419: SMSG_SET_PLAYER_DECLINED_NAMES_RESULT,
    0x041D: SMSG_SEND_UNLEARN_SPELLS,
    0x041E: SMSG_PROPOSE_LEVEL_GRANT,
    0x0420: SMSG_REFER_A_FRIEND_FAILURE,
    0x0421: SMSG_SPLINE_MOVE_SET_FLYING,
    0x0422: SMSG_SPLINE_MOVE_UNSET_FLYING,
}


async def read_server_opcode_body(
    reader: asyncio.StreamReader,
    opcode: int,
    body_size: int,
) -> ServerOpcode:
    return await server_opcodes[opcode].read(reader, body_size)


async def read_client_opcodes_unencrypted(reader: asyncio.StreamReader) -> ClientOpcode:
    opcode_size = 2
    size_field_size = 4

    size = int.from_bytes(await reader.readexactly(opcode_size), "big")
    opcode = int.from_bytes(await reader.readexactly(size_field_size), "little")

    body_size = size - size_field_size
    body = await reader.readexactly(body_size)
    body_reader = asyncio.StreamReader()
    body_reader.feed_data(body)
    body_reader.feed_eof()

    return await read_client_opcode_body(body_reader, opcode, body_size)


async def read_client_opcodes_encrypted(
    reader: asyncio.StreamReader,
    header_crypto: wow_srp.TbcHeaderCrypto,
) -> ClientOpcode:
    size_field_size = 4
    header_size = 6

    data = await reader.readexactly(header_size)

    size, opcode = header_crypto.decrypt_client_header(data)

    body_size = size - size_field_size
    body = await reader.readexactly(body_size)
    body_reader = asyncio.StreamReader()
    body_reader.feed_data(body)
    body_reader.feed_eof()

    return await read_client_opcode_body(body_reader, opcode, body_size)


async def read_server_opcodes_unencrypted(reader: asyncio.StreamReader) -> ServerOpcode:
    opcode_size = 2
    size_field_size = 2

    size = int.from_bytes(await reader.readexactly(opcode_size), "big")
    opcode = int.from_bytes(await reader.readexactly(size_field_size), "little")

    body_size = size - size_field_size
    body = await reader.readexactly(body_size)
    body_reader = asyncio.StreamReader()
    body_reader.feed_data(body)
    body_reader.feed_eof()

    return await read_server_opcode_body(body_reader, opcode, body_size)


async def read_server_opcodes_encrypted(
    reader: asyncio.StreamReader,
    header_crypto: wow_srp.TbcHeaderCrypto,
) -> ServerOpcode:
    size_field_size = 2
    header_size = 4

    data = await reader.readexactly(header_size)

    size, opcode = header_crypto.decrypt_client_header(data)

    body_size = size - size_field_size
    body = await reader.readexactly(body_size)
    body_reader = asyncio.StreamReader()
    body_reader.feed_data(body)
    body_reader.feed_eof()

    return await read_server_opcode_body(body_reader, opcode, body_size)


async def expect_client_opcode_unencrypted(
    reader: asyncio.StreamReader,
    opcode: typing.Type[ClientOpcode],
) -> typing.Optional[ClientOpcode]:
    o = await read_client_opcodes_unencrypted(reader)
    if isinstance(o, opcode):
        return o
    else:
        return None


async def expect_client_opcode_encrypted(
    reader: asyncio.StreamReader,
    opcode: typing.Type[ClientOpcode],
    header_crypto: wow_srp.TbcHeaderCrypto,
) -> typing.Optional[ClientOpcode]:
    o = await read_client_opcodes_encrypted(reader, header_crypto)
    if isinstance(o, opcode):
        return o
    else:
        return None


async def expect_server_opcode_unencrypted(
    reader: asyncio.StreamReader,
    opcode: typing.Type[ServerOpcode],
) -> typing.Optional[ServerOpcode]:
    o = await read_server_opcodes_unencrypted(reader)
    if isinstance(o, opcode):
        return o
    else:
        return None


async def expect_server_opcode_encrypted(
    reader: asyncio.StreamReader,
    opcode: typing.Type[ServerOpcode],
    header_crypto: wow_srp.TbcHeaderCrypto,
) -> typing.Optional[ServerOpcode]:
    o = await read_server_opcodes_encrypted(reader, header_crypto)
    if isinstance(o, opcode):
        return o
    else:
        return None


