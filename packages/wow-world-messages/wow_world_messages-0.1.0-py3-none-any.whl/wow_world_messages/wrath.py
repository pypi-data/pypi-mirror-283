from __future__ import annotations
import asyncio
import dataclasses
import enum
import struct
import typing
import zlib

import wow_srp
from .util import packed_guid_size
from .util import packed_guid_write
from .util import read_packed_guid
from .util import read_sized_cstring
from .util import read_bool
from .util import read_int
from .util import read_cstring
from .util import read_float

__all__ = [
    "read_client_opcodes_unencrypted",
    "read_client_opcodes_encrypted",
    "read_server_opcodes_unencrypted",
    "read_server_opcodes_encrypted",
    "expect_client_opcode_unencrypted",
    "expect_client_opcode_encrypted",
    "expect_server_opcode_unencrypted",
    "expect_server_opcode_encrypted",
    "NamedGuid",
    "VariableItemRandomProperty",
    "AddonArray",
    "AchievementDoneArray",
    "AchievementInProgressArray",
    "CacheMask",
    "AuraMask",
    "UpdateMask",
    "AchievementNameLinkType",
    "ActionBarBehavior",
    "ActivateTaxiReply",
    "AiReaction",
    "Area",
    "ArenaFaction",
    "ArenaTeamCommand",
    "ArenaTeamCommandError",
    "ArenaTeamEvent",
    "ArenaTeamRole",
    "ArenaType",
    "AuctionCommandAction",
    "AuctionCommandResult",
    "AuctionCommandResultTwo",
    "AuctionHouse",
    "AuraMod",
    "AuraType",
    "BankSwapSource",
    "BankSwapStoreMode",
    "BarberShopResult",
    "BattlefieldListLocation",
    "BattlefieldPortAction",
    "BattlegroundType",
    "BgTypeId",
    "Bonding",
    "BuyBankSlotResult",
    "BuyResult",
    "BuybackSlot",
    "CalendarModeratorRank",
    "CalendarStatus",
    "CalendarStatusTime",
    "CharterType",
    "ChatNotify",
    "ChatRestrictionType",
    "ChatType",
    "CinematicSequenceId",
    "Class",
    "ClientCastFlags",
    "ClientMovementData",
    "CommentatorEnableOption",
    "ComplainResultWindow",
    "ComplaintStatus",
    "CorpseQueryResult",
    "CreatureFamily",
    "DeclinedNames",
    "DeclinedPetNameIncluded",
    "DispelMethod",
    "DuelWinnerReason",
    "DungeonDifficulty",
    "Emote",
    "EncounterFrame",
    "EnvironmentalDamageType",
    "Expansion",
    "ExperienceAwardType",
    "Faction",
    "FarSightOperation",
    "FriendResult",
    "FriendStatus",
    "Gender",
    "GmTicketEscalationStatus",
    "GmTicketQueueStatus",
    "GmTicketResponse",
    "GmTicketStatus",
    "GmTicketStatusResponse",
    "GroupLootSetting",
    "GuildBankContentResult",
    "GuildBankTabResult",
    "GuildCommand",
    "GuildCommandResult",
    "GuildEmblemResult",
    "GuildEvent",
    "GuildMemberStatus",
    "InstanceResetFailedReason",
    "InventoryResult",
    "InventoryType",
    "ItemClass",
    "ItemClassAndSubClass",
    "ItemQuality",
    "ItemRefundResult",
    "ItemSet",
    "ItemSlot",
    "ItemTextQuery",
    "JoinArenaType",
    "Language",
    "LfgJoinStatus",
    "LfgListUpdateType",
    "LfgTeleportError",
    "LfgTeleportLocation",
    "LfgType",
    "LfgUpdateType",
    "LogFormat",
    "LogoutResult",
    "LogoutSpeed",
    "LootMethod",
    "LootMethodError",
    "LootSlotType",
    "MailAction",
    "MailMessageType",
    "MailResult",
    "MailResultTwo",
    "MailType",
    "Map",
    "MiniMoveOpcode",
    "MonsterMoveType",
    "MountResult",
    "NewItemChatAlert",
    "NewItemCreationType",
    "NewItemSource",
    "ObjectType",
    "PageTextMaterial",
    "PartyOperation",
    "PartyResult",
    "PartyRole",
    "PetCommandState",
    "PetEnabled",
    "PetFeedback",
    "PetNameInvalidReason",
    "PetQueryDisabledNames",
    "PetReactState",
    "PetTalkReason",
    "PetTameFailureReason",
    "PetitionResult",
    "PlayerChatTag",
    "PlayerInviteStatus",
    "Power",
    "PvpRank",
    "QuestCompletable",
    "QuestFailedReason",
    "QuestGiverStatus",
    "QuestPartyMessage",
    "Race",
    "RaidDifficulty",
    "RaidGroupError",
    "RaidInstanceMessage",
    "RaidTargetIndex",
    "RaidTargetUpdateType",
    "RandomBg",
    "RealmSplitState",
    "ReferAFriendError",
    "RollVote",
    "SellItemResult",
    "ServerMessageType",
    "SheathState",
    "SheatheType",
    "SizeClass",
    "Skill",
    "SkillCategory",
    "SpamType",
    "SpellCastResult",
    "SpellEffect",
    "SpellMissInfo",
    "SpellSchool",
    "SpellStealAction",
    "SpellTriggerType",
    "StableResult",
    "StatusId",
    "Talent",
    "TalentInfoType",
    "TextEmote",
    "TimerType",
    "TitleEarnStatus",
    "TradeStatus",
    "TrainerSpellState",
    "TrainingFailureReason",
    "TransferAbortReason",
    "UnitStandState",
    "UpdateType",
    "WeatherChangeType",
    "WeatherType",
    "WorldResult",
    "AllowedClass",
    "AllowedRace",
    "AuraFlag",
    "BagFamily",
    "BillingPlanFlags",
    "CastFlags",
    "ChannelFlags",
    "ChannelMemberFlags",
    "FactionFlag",
    "GameobjectCastFlags",
    "GroupMemberOnlineStatus",
    "GroupUpdateFlags",
    "HitInfo",
    "ItemFlag",
    "ItemFlag2",
    "LfgUpdateFlag",
    "MovementFlags",
    "RelationType",
    "RollFlags",
    "SpellCastTargetFlags",
    "SplineFlag",
    "UpdateFlag",
    "VictimState",
    "AchievementDone",
    "AchievementInProgress",
    "ActionButton",
    "Addon",
    "AddonInfo",
    "ArenaTeamMember",
    "AuctionEnchantment",
    "AuctionListItem",
    "AuctionSort",
    "Aura",
    "AuraLog",
    "AuraUpdate",
    "BankTab",
    "BattlegroundPlayerPosition",
    "CalendarInvitee",
    "CalendarMember",
    "CalendarSendInvitee",
    "ChannelMember",
    "Vector3d",
    "MonsterMoveSpline",
    "CharacterGear",
    "Character",
    "CooldownSpell",
    "DamageInfo",
    "DispelledSpell",
    "EquipmentSet",
    "EquipmentSetListItem",
    "FactionInitializer",
    "FactionStanding",
    "ForcedReaction",
    "GmSurveyQuestion",
    "GossipItem",
    "GroupListMember",
    "GuildBankRights",
    "GuildBankSocket",
    "GuildBankSlot",
    "GuildBankTab",
    "GuildLogEvent",
    "GuildMember",
    "GuildRights",
    "InitialSpell",
    "InspectTalent",
    "InspectTalentGear",
    "InspectTalentSpec",
    "ItemDamageType",
    "ItemRefundExtra",
    "ItemSocket",
    "ItemSpells",
    "ItemStat",
    "LfgQuestReward",
    "LfgAvailableDungeon",
    "LfgJoinLockedDungeon",
    "LfgJoinPlayer",
    "LfgListGroup",
    "LfgListPlayer",
    "LfgPartyInfo",
    "LfgProposal",
    "LfgRole",
    "ListInventoryItem",
    "LootItem",
    "MailListItemEnchant",
    "MailListItem",
    "Mail",
    "MailItem",
    "MiniMoveMessage",
    "MoneyLogItem",
    "TransportInfo",
    "MovementBlock",
    "MovementInfo",
    "NpcTextUpdateEmote",
    "NpcTextUpdate",
    "Object",
    "PendingAuctionSale",
    "PetSpellCooldown",
    "PetitionShowlist",
    "PetitionSignature",
    "PreviewTalent",
    "QuestDetailsEmote",
    "QuestGiverReward",
    "QuestGiverStatusReport",
    "QuestItem",
    "QuestItemRequirement",
    "QuestItemReward",
    "QuestObjective",
    "Vector2dUnsigned",
    "QuestPoi",
    "QuestPoiList",
    "RaidInfo",
    "RaidTargetUpdate",
    "ReceivedMail",
    "Relation",
    "ResyncRune",
    "SendCalendarEvent",
    "SendCalendarHoliday",
    "SendCalendarInstance",
    "SendCalendarInvite",
    "SendCalendarResetTime",
    "SpellCastTargets",
    "SpellCooldownStatus",
    "SpellLog",
    "SpellLogMiss",
    "SpellMiss",
    "SpellSteal",
    "StabledPet",
    "TalentInfoSpec",
    "ThreatUpdateUnit",
    "TradeSlot",
    "TrainerSpell",
    "Vector2d",
    "WhoPlayer",
    "WorldState",
    "CMSG_BOOTME",
    "CMSG_DBLOOKUP",
    "CMSG_WORLD_TELEPORT",
    "CMSG_TELEPORT_TO_UNIT",
    "CMSG_CHAR_CREATE",
    "CMSG_CHAR_ENUM",
    "CMSG_CHAR_DELETE",
    "SMSG_CHAR_CREATE",
    "SMSG_CHAR_ENUM",
    "SMSG_CHAR_DELETE",
    "CMSG_PLAYER_LOGIN",
    "SMSG_NEW_WORLD",
    "SMSG_TRANSFER_PENDING",
    "SMSG_TRANSFER_ABORTED",
    "SMSG_CHARACTER_LOGIN_FAILED",
    "SMSG_LOGIN_SETTIMESPEED",
    "CMSG_PLAYER_LOGOUT",
    "CMSG_LOGOUT_REQUEST",
    "SMSG_LOGOUT_RESPONSE",
    "SMSG_LOGOUT_COMPLETE",
    "CMSG_LOGOUT_CANCEL",
    "SMSG_LOGOUT_CANCEL_ACK",
    "CMSG_NAME_QUERY",
    "SMSG_NAME_QUERY_RESPONSE",
    "CMSG_PET_NAME_QUERY",
    "SMSG_PET_NAME_QUERY_RESPONSE",
    "CMSG_GUILD_QUERY",
    "SMSG_GUILD_QUERY_RESPONSE",
    "CMSG_ITEM_QUERY_SINGLE",
    "SMSG_ITEM_QUERY_SINGLE_RESPONSE",
    "CMSG_PAGE_TEXT_QUERY",
    "SMSG_PAGE_TEXT_QUERY_RESPONSE",
    "CMSG_QUEST_QUERY",
    "SMSG_QUEST_QUERY_RESPONSE",
    "CMSG_GAMEOBJECT_QUERY",
    "SMSG_GAMEOBJECT_QUERY_RESPONSE",
    "CMSG_CREATURE_QUERY",
    "SMSG_CREATURE_QUERY_RESPONSE",
    "CMSG_WHO",
    "SMSG_WHO",
    "CMSG_WHOIS",
    "SMSG_WHOIS",
    "CMSG_CONTACT_LIST",
    "SMSG_CONTACT_LIST",
    "SMSG_FRIEND_STATUS",
    "CMSG_ADD_FRIEND",
    "CMSG_DEL_FRIEND",
    "CMSG_SET_CONTACT_NOTES",
    "CMSG_ADD_IGNORE",
    "CMSG_DEL_IGNORE",
    "CMSG_GROUP_INVITE",
    "SMSG_GROUP_INVITE",
    "CMSG_GROUP_CANCEL",
    "CMSG_GROUP_ACCEPT",
    "CMSG_GROUP_DECLINE",
    "SMSG_GROUP_DECLINE",
    "CMSG_GROUP_UNINVITE",
    "CMSG_GROUP_UNINVITE_GUID",
    "SMSG_GROUP_UNINVITE",
    "CMSG_GROUP_SET_LEADER",
    "SMSG_GROUP_SET_LEADER",
    "CMSG_LOOT_METHOD",
    "CMSG_GROUP_DISBAND",
    "SMSG_GROUP_DESTROYED",
    "SMSG_GROUP_LIST",
    "SMSG_PARTY_MEMBER_STATS",
    "SMSG_PARTY_COMMAND_RESULT",
    "CMSG_GUILD_CREATE",
    "CMSG_GUILD_INVITE",
    "SMSG_GUILD_INVITE",
    "CMSG_GUILD_ACCEPT",
    "CMSG_GUILD_DECLINE",
    "SMSG_GUILD_DECLINE",
    "CMSG_GUILD_INFO",
    "SMSG_GUILD_INFO",
    "CMSG_GUILD_ROSTER",
    "SMSG_GUILD_ROSTER",
    "CMSG_GUILD_PROMOTE",
    "CMSG_GUILD_DEMOTE",
    "CMSG_GUILD_LEAVE",
    "CMSG_GUILD_REMOVE",
    "CMSG_GUILD_DISBAND",
    "CMSG_GUILD_LEADER",
    "CMSG_GUILD_MOTD",
    "SMSG_GUILD_EVENT",
    "SMSG_GUILD_COMMAND_RESULT",
    "CMSG_MESSAGECHAT",
    "SMSG_MESSAGECHAT",
    "CMSG_JOIN_CHANNEL",
    "CMSG_LEAVE_CHANNEL",
    "SMSG_CHANNEL_NOTIFY",
    "CMSG_CHANNEL_LIST",
    "SMSG_CHANNEL_LIST",
    "CMSG_CHANNEL_PASSWORD",
    "CMSG_CHANNEL_SET_OWNER",
    "CMSG_CHANNEL_OWNER",
    "CMSG_CHANNEL_MODERATOR",
    "CMSG_CHANNEL_UNMODERATOR",
    "CMSG_CHANNEL_MUTE",
    "CMSG_CHANNEL_UNMUTE",
    "CMSG_CHANNEL_INVITE",
    "CMSG_CHANNEL_KICK",
    "CMSG_CHANNEL_BAN",
    "CMSG_CHANNEL_UNBAN",
    "CMSG_CHANNEL_ANNOUNCEMENTS",
    "CMSG_CHANNEL_MODERATE",
    "SMSG_UPDATE_OBJECT",
    "SMSG_DESTROY_OBJECT",
    "CMSG_USE_ITEM",
    "CMSG_OPEN_ITEM",
    "CMSG_READ_ITEM",
    "SMSG_READ_ITEM_OK",
    "SMSG_READ_ITEM_FAILED",
    "SMSG_ITEM_COOLDOWN",
    "CMSG_GAMEOBJ_USE",
    "SMSG_GAMEOBJECT_CUSTOM_ANIM",
    "CMSG_AREATRIGGER",
    "MSG_MOVE_START_FORWARD",
    "MSG_MOVE_START_BACKWARD",
    "MSG_MOVE_STOP",
    "MSG_MOVE_START_STRAFE_LEFT",
    "MSG_MOVE_START_STRAFE_RIGHT",
    "MSG_MOVE_STOP_STRAFE",
    "MSG_MOVE_JUMP",
    "MSG_MOVE_START_TURN_LEFT",
    "MSG_MOVE_START_TURN_RIGHT",
    "MSG_MOVE_STOP_TURN",
    "MSG_MOVE_START_PITCH_UP",
    "MSG_MOVE_START_PITCH_DOWN",
    "MSG_MOVE_STOP_PITCH",
    "MSG_MOVE_SET_RUN_MODE",
    "MSG_MOVE_SET_WALK_MODE",
    "MSG_MOVE_TELEPORT_Server",
    "MSG_MOVE_TELEPORT_CHEAT_Server",
    "MSG_MOVE_TELEPORT_ACK_Client",
    "MSG_MOVE_TELEPORT_ACK_Server",
    "MSG_MOVE_FALL_LAND",
    "MSG_MOVE_START_SWIM",
    "MSG_MOVE_STOP_SWIM",
    "MSG_MOVE_SET_FACING",
    "MSG_MOVE_SET_PITCH",
    "MSG_MOVE_WORLDPORT_ACK",
    "SMSG_MONSTER_MOVE",
    "SMSG_MOVE_WATER_WALK",
    "SMSG_MOVE_LAND_WALK",
    "CMSG_MOVE_SET_RAW_POSITION",
    "SMSG_FORCE_RUN_SPEED_CHANGE",
    "CMSG_FORCE_RUN_SPEED_CHANGE_ACK",
    "SMSG_FORCE_RUN_BACK_SPEED_CHANGE",
    "CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK",
    "SMSG_FORCE_SWIM_SPEED_CHANGE",
    "CMSG_FORCE_SWIM_SPEED_CHANGE_ACK",
    "SMSG_FORCE_MOVE_ROOT",
    "CMSG_FORCE_MOVE_ROOT_ACK",
    "SMSG_FORCE_MOVE_UNROOT",
    "CMSG_FORCE_MOVE_UNROOT_ACK",
    "MSG_MOVE_ROOT_Server",
    "MSG_MOVE_UNROOT_Server",
    "MSG_MOVE_HEARTBEAT",
    "SMSG_MOVE_KNOCK_BACK",
    "CMSG_MOVE_KNOCK_BACK_ACK",
    "MSG_MOVE_KNOCK_BACK_Server",
    "SMSG_MOVE_FEATHER_FALL",
    "SMSG_MOVE_NORMAL_FALL",
    "SMSG_MOVE_SET_HOVER",
    "SMSG_MOVE_UNSET_HOVER",
    "CMSG_MOVE_HOVER_ACK",
    "MSG_MOVE_HOVER",
    "SMSG_TRIGGER_CINEMATIC",
    "CMSG_NEXT_CINEMATIC_CAMERA",
    "CMSG_COMPLETE_CINEMATIC",
    "SMSG_TUTORIAL_FLAGS",
    "CMSG_TUTORIAL_FLAG",
    "CMSG_TUTORIAL_CLEAR",
    "CMSG_TUTORIAL_RESET",
    "CMSG_STANDSTATECHANGE",
    "CMSG_EMOTE",
    "SMSG_EMOTE",
    "CMSG_TEXT_EMOTE",
    "SMSG_TEXT_EMOTE",
    "CMSG_AUTOSTORE_LOOT_ITEM",
    "CMSG_AUTOEQUIP_ITEM",
    "CMSG_AUTOSTORE_BAG_ITEM",
    "CMSG_SWAP_ITEM",
    "CMSG_SWAP_INV_ITEM",
    "CMSG_SPLIT_ITEM",
    "CMSG_AUTOEQUIP_ITEM_SLOT",
    "CMSG_DESTROYITEM",
    "SMSG_INVENTORY_CHANGE_FAILURE",
    "CMSG_INSPECT",
    "CMSG_INITIATE_TRADE",
    "CMSG_BEGIN_TRADE",
    "CMSG_BUSY_TRADE",
    "CMSG_IGNORE_TRADE",
    "CMSG_ACCEPT_TRADE",
    "CMSG_UNACCEPT_TRADE",
    "CMSG_CANCEL_TRADE",
    "CMSG_SET_TRADE_ITEM",
    "CMSG_CLEAR_TRADE_ITEM",
    "CMSG_SET_TRADE_GOLD",
    "SMSG_TRADE_STATUS",
    "SMSG_TRADE_STATUS_EXTENDED",
    "SMSG_INITIALIZE_FACTIONS",
    "SMSG_SET_FACTION_VISIBLE",
    "SMSG_SET_FACTION_STANDING",
    "CMSG_SET_FACTION_ATWAR",
    "SMSG_SET_PROFICIENCY",
    "CMSG_SET_ACTION_BUTTON",
    "SMSG_ACTION_BUTTONS",
    "SMSG_INITIAL_SPELLS",
    "SMSG_LEARNED_SPELL",
    "SMSG_SUPERCEDED_SPELL",
    "CMSG_CAST_SPELL",
    "CMSG_CANCEL_CAST",
    "SMSG_CAST_FAILED",
    "SMSG_SPELL_START",
    "SMSG_SPELL_GO",
    "SMSG_SPELL_FAILURE",
    "SMSG_SPELL_COOLDOWN",
    "SMSG_COOLDOWN_EVENT",
    "CMSG_CANCEL_AURA",
    "SMSG_PET_CAST_FAILED",
    "MSG_CHANNEL_START_Server",
    "MSG_CHANNEL_UPDATE_Server",
    "CMSG_CANCEL_CHANNELLING",
    "SMSG_AI_REACTION",
    "CMSG_SET_SELECTION",
    "CMSG_DELETEEQUIPMENT_SET",
    "CMSG_INSTANCE_LOCK_RESPONSE",
    "CMSG_ATTACKSWING",
    "CMSG_ATTACKSTOP",
    "SMSG_ATTACKSTART",
    "SMSG_ATTACKSTOP",
    "SMSG_ATTACKSWING_NOTINRANGE",
    "SMSG_ATTACKSWING_BADFACING",
    "SMSG_INSTANCE_LOCK_WARNING_QUERY",
    "SMSG_ATTACKSWING_DEADTARGET",
    "SMSG_ATTACKSWING_CANT_ATTACK",
    "SMSG_ATTACKERSTATEUPDATE",
    "SMSG_CANCEL_COMBAT",
    "SMSG_SPELLHEALLOG",
    "SMSG_SPELLENERGIZELOG",
    "SMSG_BREAK_TARGET",
    "SMSG_BINDPOINTUPDATE",
    "SMSG_PLAYERBOUND",
    "SMSG_CLIENT_CONTROL_UPDATE",
    "CMSG_REPOP_REQUEST",
    "SMSG_RESURRECT_REQUEST",
    "CMSG_RESURRECT_RESPONSE",
    "CMSG_LOOT",
    "CMSG_LOOT_MONEY",
    "CMSG_LOOT_RELEASE",
    "SMSG_LOOT_RESPONSE",
    "SMSG_LOOT_RELEASE_RESPONSE",
    "SMSG_LOOT_REMOVED",
    "SMSG_LOOT_MONEY_NOTIFY",
    "SMSG_LOOT_CLEAR_MONEY",
    "SMSG_ITEM_PUSH_RESULT",
    "SMSG_DUEL_REQUESTED",
    "SMSG_DUEL_OUTOFBOUNDS",
    "SMSG_DUEL_INBOUNDS",
    "SMSG_DUEL_COMPLETE",
    "SMSG_DUEL_WINNER",
    "CMSG_DUEL_ACCEPTED",
    "CMSG_DUEL_CANCELLED",
    "SMSG_MOUNTRESULT",
    "CMSG_MOUNTSPECIAL_ANIM",
    "SMSG_MOUNTSPECIAL_ANIM",
    "SMSG_PET_TAME_FAILURE",
    "CMSG_PET_SET_ACTION",
    "CMSG_PET_ACTION",
    "CMSG_PET_ABANDON",
    "CMSG_PET_RENAME",
    "SMSG_PET_NAME_INVALID",
    "SMSG_PET_SPELLS",
    "SMSG_PET_MODE",
    "CMSG_GOSSIP_HELLO",
    "CMSG_GOSSIP_SELECT_OPTION",
    "SMSG_GOSSIP_MESSAGE",
    "SMSG_GOSSIP_COMPLETE",
    "CMSG_NPC_TEXT_QUERY",
    "SMSG_NPC_TEXT_UPDATE",
    "CMSG_QUESTGIVER_STATUS_QUERY",
    "SMSG_QUESTGIVER_STATUS",
    "CMSG_QUESTGIVER_HELLO",
    "SMSG_QUESTGIVER_QUEST_LIST",
    "CMSG_QUESTGIVER_QUERY_QUEST",
    "CMSG_QUESTGIVER_QUEST_AUTOLAUNCH",
    "SMSG_QUESTGIVER_QUEST_DETAILS",
    "CMSG_QUESTGIVER_ACCEPT_QUEST",
    "CMSG_QUESTGIVER_COMPLETE_QUEST",
    "SMSG_QUESTGIVER_REQUEST_ITEMS",
    "CMSG_QUESTGIVER_REQUEST_REWARD",
    "SMSG_QUESTGIVER_OFFER_REWARD",
    "CMSG_QUESTGIVER_CHOOSE_REWARD",
    "SMSG_QUESTGIVER_QUEST_INVALID",
    "CMSG_QUESTGIVER_CANCEL",
    "SMSG_QUESTGIVER_QUEST_COMPLETE",
    "SMSG_QUESTGIVER_QUEST_FAILED",
    "CMSG_QUESTLOG_SWAP_QUEST",
    "CMSG_QUESTLOG_REMOVE_QUEST",
    "SMSG_QUESTLOG_FULL",
    "SMSG_QUESTUPDATE_FAILED",
    "SMSG_QUESTUPDATE_FAILEDTIMER",
    "SMSG_QUESTUPDATE_COMPLETE",
    "SMSG_QUESTUPDATE_ADD_KILL",
    "SMSG_QUESTUPDATE_ADD_ITEM",
    "CMSG_QUEST_CONFIRM_ACCEPT",
    "SMSG_QUEST_CONFIRM_ACCEPT",
    "CMSG_PUSHQUESTTOPARTY",
    "CMSG_LIST_INVENTORY",
    "SMSG_LIST_INVENTORY",
    "CMSG_SELL_ITEM",
    "SMSG_SELL_ITEM",
    "CMSG_BUY_ITEM",
    "CMSG_BUY_ITEM_IN_SLOT",
    "SMSG_BUY_ITEM",
    "SMSG_BUY_FAILED",
    "SMSG_SHOWTAXINODES",
    "CMSG_TAXINODE_STATUS_QUERY",
    "SMSG_TAXINODE_STATUS",
    "CMSG_TAXIQUERYAVAILABLENODES",
    "CMSG_ACTIVATETAXI",
    "SMSG_ACTIVATETAXIREPLY",
    "SMSG_NEW_TAXI_PATH",
    "CMSG_TRAINER_LIST",
    "SMSG_TRAINER_LIST",
    "CMSG_TRAINER_BUY_SPELL",
    "SMSG_TRAINER_BUY_SUCCEEDED",
    "SMSG_TRAINER_BUY_FAILED",
    "CMSG_BINDER_ACTIVATE",
    "CMSG_BANKER_ACTIVATE",
    "SMSG_SHOW_BANK",
    "CMSG_BUY_BANK_SLOT",
    "SMSG_BUY_BANK_SLOT_RESULT",
    "CMSG_PETITION_SHOWLIST",
    "SMSG_PETITION_SHOWLIST",
    "CMSG_PETITION_BUY",
    "CMSG_PETITION_SHOW_SIGNATURES",
    "SMSG_PETITION_SHOW_SIGNATURES",
    "CMSG_PETITION_SIGN",
    "SMSG_PETITION_SIGN_RESULTS",
    "MSG_PETITION_DECLINE",
    "CMSG_OFFER_PETITION",
    "CMSG_TURN_IN_PETITION",
    "SMSG_TURN_IN_PETITION_RESULTS",
    "CMSG_PETITION_QUERY",
    "SMSG_PETITION_QUERY_RESPONSE",
    "SMSG_FISH_NOT_HOOKED",
    "SMSG_FISH_ESCAPED",
    "CMSG_BUG",
    "SMSG_NOTIFICATION",
    "CMSG_PLAYED_TIME",
    "SMSG_PLAYED_TIME",
    "CMSG_QUERY_TIME",
    "SMSG_QUERY_TIME_RESPONSE",
    "SMSG_LOG_XPGAIN",
    "CMSG_RECLAIM_CORPSE",
    "CMSG_WRAP_ITEM",
    "SMSG_LEVELUP_INFO",
    "MSG_MINIMAP_PING_Client",
    "MSG_MINIMAP_PING_Server",
    "SMSG_ENCHANTMENTLOG",
    "SMSG_START_MIRROR_TIMER",
    "SMSG_PAUSE_MIRROR_TIMER",
    "SMSG_STOP_MIRROR_TIMER",
    "CMSG_PING",
    "SMSG_PONG",
    "SMSG_CLEAR_COOLDOWN",
    "SMSG_GAMEOBJECT_PAGETEXT",
    "CMSG_SETSHEATHED",
    "SMSG_SPELL_DELAYED",
    "CMSG_QUEST_POI_QUERY",
    "SMSG_QUEST_POI_QUERY_RESPONSE",
    "SMSG_ITEM_TIME_UPDATE",
    "SMSG_ITEM_ENCHANT_TIME_UPDATE",
    "SMSG_AUTH_CHALLENGE",
    "CMSG_AUTH_SESSION",
    "SMSG_AUTH_RESPONSE",
    "CMSG_PET_CAST_SPELL",
    "MSG_SAVE_GUILD_EMBLEM_Client",
    "MSG_SAVE_GUILD_EMBLEM_Server",
    "MSG_TABARDVENDOR_ACTIVATE",
    "SMSG_PLAY_SPELL_VISUAL",
    "CMSG_ZONEUPDATE",
    "SMSG_PARTYKILLLOG",
    "SMSG_COMPRESSED_UPDATE_OBJECT",
    "SMSG_PLAY_SPELL_IMPACT",
    "SMSG_EXPLORATION_EXPERIENCE",
    "MSG_RANDOM_ROLL_Client",
    "MSG_RANDOM_ROLL_Server",
    "SMSG_ENVIRONMENTAL_DAMAGE_LOG",
    "SMSG_LFG_PLAYER_REWARD",
    "SMSG_LFG_TELEPORT_DENIED",
    "CMSG_UNLEARN_SKILL",
    "SMSG_REMOVED_SPELL",
    "CMSG_GMTICKET_CREATE",
    "SMSG_GMTICKET_CREATE",
    "CMSG_GMTICKET_UPDATETEXT",
    "SMSG_GMTICKET_UPDATETEXT",
    "SMSG_ACCOUNT_DATA_TIMES",
    "CMSG_REQUEST_ACCOUNT_DATA",
    "CMSG_UPDATE_ACCOUNT_DATA",
    "SMSG_UPDATE_ACCOUNT_DATA",
    "CMSG_GMTICKET_GETTICKET",
    "SMSG_GMTICKET_GETTICKET",
    "CMSG_UNLEARN_TALENTS",
    "SMSG_UPDATE_INSTANCE_ENCOUNTER_UNIT",
    "SMSG_GAMEOBJECT_DESPAWN_ANIM",
    "MSG_CORPSE_QUERY_Client",
    "MSG_CORPSE_QUERY_Server",
    "CMSG_GMTICKET_DELETETICKET",
    "SMSG_GMTICKET_DELETETICKET",
    "SMSG_CHAT_WRONG_FACTION",
    "CMSG_GMTICKET_SYSTEMSTATUS",
    "SMSG_GMTICKET_SYSTEMSTATUS",
    "CMSG_SPIRIT_HEALER_ACTIVATE",
    "SMSG_QUEST_FORCE_REMOVE",
    "SMSG_SPIRIT_HEALER_CONFIRM",
    "SMSG_GOSSIP_POI",
    "CMSG_CHAT_IGNORED",
    "CMSG_GUILD_RANK",
    "CMSG_GUILD_ADD_RANK",
    "CMSG_GUILD_DEL_RANK",
    "CMSG_GUILD_SET_PUBLIC_NOTE",
    "CMSG_GUILD_SET_OFFICER_NOTE",
    "SMSG_LOGIN_VERIFY_WORLD",
    "CMSG_SEND_MAIL",
    "SMSG_SEND_MAIL_RESULT",
    "CMSG_GET_MAIL_LIST",
    "SMSG_MAIL_LIST_RESULT",
    "CMSG_BATTLEFIELD_LIST",
    "SMSG_BATTLEFIELD_LIST",
    "CMSG_ITEM_TEXT_QUERY",
    "SMSG_ITEM_TEXT_QUERY_RESPONSE",
    "CMSG_MAIL_TAKE_MONEY",
    "CMSG_MAIL_TAKE_ITEM",
    "CMSG_MAIL_MARK_AS_READ",
    "CMSG_MAIL_RETURN_TO_SENDER",
    "CMSG_MAIL_DELETE",
    "CMSG_MAIL_CREATE_TEXT_ITEM",
    "SMSG_SPELLLOGMISS",
    "SMSG_SPELLLOGEXECUTE",
    "SMSG_PERIODICAURALOG",
    "SMSG_SPELLDAMAGESHIELD",
    "SMSG_SPELLNONMELEEDAMAGELOG",
    "CMSG_LEARN_TALENT",
    "SMSG_RESURRECT_FAILED",
    "CMSG_TOGGLE_PVP",
    "SMSG_ZONE_UNDER_ATTACK",
    "MSG_AUCTION_HELLO_Client",
    "MSG_AUCTION_HELLO_Server",
    "CMSG_AUCTION_SELL_ITEM",
    "CMSG_AUCTION_REMOVE_ITEM",
    "CMSG_AUCTION_LIST_ITEMS",
    "CMSG_AUCTION_LIST_OWNER_ITEMS",
    "CMSG_AUCTION_PLACE_BID",
    "SMSG_AUCTION_COMMAND_RESULT",
    "SMSG_AUCTION_LIST_RESULT",
    "SMSG_AUCTION_OWNER_LIST_RESULT",
    "SMSG_AUCTION_BIDDER_NOTIFICATION",
    "SMSG_AUCTION_OWNER_NOTIFICATION",
    "SMSG_PROCRESIST",
    "SMSG_DISPEL_FAILED",
    "SMSG_SPELLORDAMAGE_IMMUNE",
    "CMSG_AUCTION_LIST_BIDDER_ITEMS",
    "SMSG_AUCTION_BIDDER_LIST_RESULT",
    "SMSG_SET_FLAT_SPELL_MODIFIER",
    "SMSG_SET_PCT_SPELL_MODIFIER",
    "CMSG_SET_AMMO",
    "SMSG_CORPSE_RECLAIM_DELAY",
    "CMSG_SET_ACTIVE_MOVER",
    "CMSG_PET_CANCEL_AURA",
    "CMSG_CANCEL_AUTO_REPEAT_SPELL",
    "MSG_LIST_STABLED_PETS_Client",
    "MSG_LIST_STABLED_PETS_Server",
    "CMSG_STABLE_PET",
    "CMSG_UNSTABLE_PET",
    "CMSG_BUY_STABLE_SLOT",
    "SMSG_STABLE_RESULT",
    "CMSG_STABLE_SWAP_PET",
    "MSG_QUEST_PUSH_RESULT",
    "SMSG_PLAY_MUSIC",
    "SMSG_PLAY_OBJECT_SOUND",
    "CMSG_REQUEST_PET_INFO",
    "CMSG_FAR_SIGHT",
    "SMSG_SPELLDISPELLOG",
    "CMSG_GROUP_CHANGE_SUB_GROUP",
    "CMSG_REQUEST_PARTY_MEMBER_STATS",
    "CMSG_GROUP_SWAP_SUB_GROUP",
    "CMSG_AUTOSTORE_BANK_ITEM",
    "CMSG_AUTOBANK_ITEM",
    "MSG_QUERY_NEXT_MAIL_TIME_Client",
    "MSG_QUERY_NEXT_MAIL_TIME_Server",
    "SMSG_RECEIVED_MAIL",
    "SMSG_RAID_GROUP_ONLY",
    "SMSG_PVP_CREDIT",
    "SMSG_AUCTION_REMOVED_NOTIFICATION",
    "CMSG_GROUP_RAID_CONVERT",
    "CMSG_GROUP_ASSISTANT_LEADER",
    "CMSG_BUYBACK_ITEM",
    "SMSG_SERVER_MESSAGE",
    "CMSG_SET_SAVED_INSTANCE_EXTEND",
    "SMSG_LFG_OFFER_CONTINUE",
    "CMSG_LFG_GET_STATUS",
    "SMSG_SHOW_MAILBOX",
    "CMSG_GMTICKETSYSTEM_TOGGLE",
    "CMSG_CANCEL_GROWTH_AURA",
    "SMSG_CANCEL_AUTO_REPEAT",
    "SMSG_STANDSTATE_UPDATE",
    "SMSG_LOOT_ALL_PASSED",
    "SMSG_LOOT_ROLL_WON",
    "CMSG_LOOT_ROLL",
    "SMSG_LOOT_START_ROLL",
    "SMSG_LOOT_ROLL",
    "CMSG_LOOT_MASTER_GIVE",
    "SMSG_LOOT_MASTER_LIST",
    "SMSG_SET_FORCED_REACTIONS",
    "SMSG_SPELL_FAILED_OTHER",
    "CMSG_REPAIR_ITEM",
    "SMSG_CHAT_PLAYER_NOT_FOUND",
    "MSG_TALENT_WIPE_CONFIRM_Client",
    "MSG_TALENT_WIPE_CONFIRM_Server",
    "SMSG_SUMMON_REQUEST",
    "CMSG_SUMMON_RESPONSE",
    "SMSG_MONSTER_MOVE_TRANSPORT",
    "SMSG_PET_BROKEN",
    "MSG_MOVE_FEATHER_FALL_Server",
    "MSG_MOVE_WATER_WALK",
    "CMSG_SELF_RES",
    "SMSG_FEIGN_DEATH_RESISTED",
    "SMSG_DUEL_COUNTDOWN",
    "SMSG_AREA_TRIGGER_MESSAGE",
    "CMSG_TOGGLE_HELM",
    "CMSG_TOGGLE_CLOAK",
    "SMSG_LFG_ROLE_CHOSEN",
    "SMSG_PLAYER_SKINNED",
    "SMSG_DURABILITY_DAMAGE_DEATH",
    "CMSG_SET_ACTIONBAR_TOGGLES",
    "MSG_PETITION_RENAME",
    "SMSG_INIT_WORLD_STATES",
    "SMSG_UPDATE_WORLD_STATE",
    "CMSG_ITEM_NAME_QUERY",
    "SMSG_ITEM_NAME_QUERY_RESPONSE",
    "SMSG_PET_ACTION_FEEDBACK",
    "CMSG_CHAR_RENAME",
    "SMSG_CHAR_RENAME",
    "CMSG_MOVE_SPLINE_DONE",
    "CMSG_MOVE_FALL_RESET",
    "SMSG_INSTANCE_SAVE_CREATED",
    "SMSG_RAID_INSTANCE_INFO",
    "CMSG_REQUEST_RAID_INFO",
    "CMSG_MOVE_TIME_SKIPPED",
    "CMSG_MOVE_FEATHER_FALL_ACK",
    "CMSG_MOVE_WATER_WALK_ACK",
    "CMSG_MOVE_NOT_ACTIVE_MOVER",
    "SMSG_PLAY_SOUND",
    "CMSG_BATTLEFIELD_STATUS",
    "SMSG_BATTLEFIELD_STATUS",
    "CMSG_BATTLEFIELD_PORT",
    "MSG_INSPECT_HONOR_STATS_Client",
    "MSG_INSPECT_HONOR_STATS_Server",
    "CMSG_BATTLEMASTER_HELLO",
    "SMSG_FORCE_WALK_SPEED_CHANGE",
    "CMSG_FORCE_WALK_SPEED_CHANGE_ACK",
    "SMSG_FORCE_SWIM_BACK_SPEED_CHANGE",
    "CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK",
    "SMSG_FORCE_TURN_RATE_CHANGE",
    "CMSG_FORCE_TURN_RATE_CHANGE_ACK",
    "MSG_PVP_LOG_DATA_Client",
    "CMSG_LEAVE_BATTLEFIELD",
    "CMSG_AREA_SPIRIT_HEALER_QUERY",
    "CMSG_AREA_SPIRIT_HEALER_QUEUE",
    "SMSG_AREA_SPIRIT_HEALER_TIME",
    "SMSG_WARDEN_DATA",
    "CMSG_WARDEN_DATA",
    "SMSG_GROUP_JOINED_BATTLEGROUND",
    "MSG_BATTLEGROUND_PLAYER_POSITIONS_Client",
    "MSG_BATTLEGROUND_PLAYER_POSITIONS_Server",
    "CMSG_PET_STOP_ATTACK",
    "SMSG_BINDER_CONFIRM",
    "SMSG_BATTLEGROUND_PLAYER_JOINED",
    "SMSG_BATTLEGROUND_PLAYER_LEFT",
    "CMSG_BATTLEMASTER_JOIN",
    "SMSG_ADDON_INFO",
    "CMSG_PET_UNLEARN",
    "SMSG_PET_UNLEARN_CONFIRM",
    "SMSG_PARTY_MEMBER_STATS_FULL",
    "CMSG_PET_SPELL_AUTOCAST",
    "SMSG_WEATHER",
    "SMSG_RAID_INSTANCE_MESSAGE",
    "SMSG_COMPRESSED_MOVES",
    "CMSG_GUILD_INFO_TEXT",
    "SMSG_CHAT_RESTRICTED",
    "SMSG_SPLINE_SET_RUN_SPEED",
    "SMSG_SPLINE_SET_RUN_BACK_SPEED",
    "SMSG_SPLINE_SET_SWIM_SPEED",
    "SMSG_SPLINE_SET_WALK_SPEED",
    "SMSG_SPLINE_SET_SWIM_BACK_SPEED",
    "SMSG_SPLINE_SET_TURN_RATE",
    "SMSG_SPLINE_MOVE_UNROOT",
    "SMSG_SPLINE_MOVE_FEATHER_FALL",
    "SMSG_SPLINE_MOVE_NORMAL_FALL",
    "SMSG_SPLINE_MOVE_SET_HOVER",
    "SMSG_SPLINE_MOVE_UNSET_HOVER",
    "SMSG_SPLINE_MOVE_WATER_WALK",
    "SMSG_SPLINE_MOVE_LAND_WALK",
    "SMSG_SPLINE_MOVE_START_SWIM",
    "SMSG_SPLINE_MOVE_STOP_SWIM",
    "SMSG_SPLINE_MOVE_SET_RUN_MODE",
    "SMSG_SPLINE_MOVE_SET_WALK_MODE",
    "CMSG_ACTIVATETAXIEXPRESS",
    "CMSG_SET_FACTION_INACTIVE",
    "CMSG_SET_WATCHED_FACTION",
    "MSG_MOVE_TIME_SKIPPED_Server",
    "SMSG_SPLINE_MOVE_ROOT",
    "SMSG_INVALIDATE_PLAYER",
    "CMSG_RESET_INSTANCES",
    "SMSG_INSTANCE_RESET",
    "SMSG_INSTANCE_RESET_FAILED",
    "SMSG_UPDATE_LAST_INSTANCE",
    "MSG_RAID_TARGET_UPDATE_Client",
    "MSG_RAID_TARGET_UPDATE_Server",
    "MSG_RAID_READY_CHECK_Client",
    "MSG_RAID_READY_CHECK_Server",
    "SMSG_PET_ACTION_SOUND",
    "SMSG_PET_DISMISS_SOUND",
    "SMSG_GM_TICKET_STATUS_UPDATE",
    "MSG_SET_DUNGEON_DIFFICULTY_Client",
    "MSG_SET_DUNGEON_DIFFICULTY_Server",
    "CMSG_GMSURVEY_SUBMIT",
    "SMSG_UPDATE_INSTANCE_OWNERSHIP",
    "SMSG_CHAT_PLAYER_AMBIGUOUS",
    "SMSG_SPELLINSTAKILLLOG",
    "SMSG_SPELL_UPDATE_CHAIN_TARGETS",
    "SMSG_SPELLSTEALLOG",
    "SMSG_DEFENSE_MESSAGE",
    "SMSG_INSTANCE_DIFFICULTY",
    "SMSG_MOTD",
    "CMSG_MOVE_SET_CAN_TRANSITION_BETWEEN_SWIM_AND_FLY_ACK",
    "SMSG_MOVE_SET_CAN_FLY",
    "SMSG_MOVE_UNSET_CAN_FLY",
    "CMSG_MOVE_SET_CAN_FLY_ACK",
    "CMSG_MOVE_SET_FLY",
    "CMSG_SOCKET_GEMS",
    "SMSG_ARENA_TEAM_COMMAND_RESULT",
    "SMSG_ARENA_TEAM_QUERY_RESPONSE",
    "CMSG_ARENA_TEAM_ROSTER",
    "SMSG_ARENA_TEAM_ROSTER",
    "CMSG_ARENA_TEAM_INVITE",
    "SMSG_ARENA_TEAM_INVITE",
    "CMSG_ARENA_TEAM_ACCEPT",
    "CMSG_ARENA_TEAM_DECLINE",
    "CMSG_ARENA_TEAM_LEAVE",
    "CMSG_ARENA_TEAM_REMOVE",
    "CMSG_ARENA_TEAM_DISBAND",
    "CMSG_ARENA_TEAM_LEADER",
    "SMSG_ARENA_TEAM_EVENT",
    "CMSG_BATTLEMASTER_JOIN_ARENA",
    "MSG_MOVE_START_ASCEND",
    "MSG_MOVE_STOP_ASCEND",
    "SMSG_ARENA_TEAM_STATS",
    "CMSG_LFG_JOIN",
    "CMSG_LFG_LEAVE",
    "CMSG_SEARCH_LFG_JOIN",
    "CMSG_SEARCH_LFG_LEAVE",
    "SMSG_UPDATE_LFG_LIST",
    "SMSG_LFG_PROPOSAL_UPDATE",
    "CMSG_LFG_PROPOSAL_RESULT",
    "SMSG_LFG_ROLE_CHECK_UPDATE",
    "SMSG_LFG_JOIN_RESULT",
    "SMSG_LFG_QUEUE_STATUS",
    "CMSG_SET_LFG_COMMENT",
    "SMSG_LFG_UPDATE_PLAYER",
    "SMSG_LFG_UPDATE_PARTY",
    "SMSG_LFG_UPDATE_SEARCH",
    "CMSG_LFG_SET_ROLES",
    "CMSG_LFG_SET_BOOT_VOTE",
    "SMSG_LFG_BOOT_PROPOSAL_UPDATE",
    "CMSG_LFD_PLAYER_LOCK_INFO_REQUEST",
    "SMSG_LFG_PLAYER_INFO",
    "CMSG_LFG_TELEPORT",
    "CMSG_LFD_PARTY_LOCK_INFO_REQUEST",
    "SMSG_LFG_PARTY_INFO",
    "SMSG_TITLE_EARNED",
    "CMSG_SET_TITLE",
    "CMSG_CANCEL_MOUNT_AURA",
    "SMSG_ARENA_ERROR",
    "MSG_INSPECT_ARENA_TEAMS_Client",
    "MSG_INSPECT_ARENA_TEAMS_Server",
    "SMSG_DEATH_RELEASE_LOC",
    "CMSG_CANCEL_TEMP_ENCHANTMENT",
    "SMSG_FORCED_DEATH_UPDATE",
    "MSG_MOVE_SET_FLIGHT_SPEED_Server",
    "MSG_MOVE_SET_FLIGHT_BACK_SPEED",
    "SMSG_FORCE_FLIGHT_SPEED_CHANGE",
    "CMSG_FORCE_FLIGHT_SPEED_CHANGE_ACK",
    "SMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE",
    "CMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE_ACK",
    "SMSG_SPLINE_SET_FLIGHT_SPEED",
    "SMSG_SPLINE_SET_FLIGHT_BACK_SPEED",
    "SMSG_FLIGHT_SPLINE_SYNC",
    "CMSG_SET_TAXI_BENCHMARK_MODE",
    "SMSG_REALM_SPLIT",
    "CMSG_REALM_SPLIT",
    "CMSG_MOVE_CHNG_TRANSPORT",
    "MSG_PARTY_ASSIGNMENT_Client",
    "SMSG_TIME_SYNC_REQ",
    "CMSG_TIME_SYNC_RESP",
    "SMSG_RESET_FAILED_NOTIFY",
    "SMSG_LFG_DISABLED",
    "SMSG_UPDATE_COMBO_POINTS",
    "MSG_MOVE_START_DESCEND",
    "SMSG_DISMOUNT",
    "MSG_MOVE_UPDATE_CAN_FLY_Server",
    "MSG_RAID_READY_CHECK_CONFIRM_Client",
    "MSG_RAID_READY_CHECK_CONFIRM_Server",
    "CMSG_VOICE_SESSION_ENABLE",
    "SMSG_GM_MESSAGECHAT",
    "CMSG_COMMENTATOR_ENABLE",
    "SMSG_CLEAR_TARGET",
    "SMSG_CROSSED_INEBRIATION_THRESHOLD",
    "SMSG_KICK_REASON",
    "MSG_RAID_READY_CHECK_FINISHED_Client",
    "CMSG_COMPLAIN",
    "SMSG_COMPLAIN_RESULT",
    "SMSG_FEATURE_SYSTEM_STATUS",
    "CMSG_CHANNEL_DISPLAY_LIST",
    "CMSG_SET_ACTIVE_VOICE_CHANNEL",
    "CMSG_GET_CHANNEL_MEMBER_COUNT",
    "SMSG_CHANNEL_MEMBER_COUNT",
    "CMSG_CHANNEL_VOICE_ON",
    "CMSG_REPORT_PVP_AFK",
    "CMSG_GUILD_BANKER_ACTIVATE",
    "CMSG_GUILD_BANK_QUERY_TAB",
    "SMSG_GUILD_BANK_LIST",
    "CMSG_GUILD_BANK_SWAP_ITEMS",
    "CMSG_GUILD_BANK_BUY_TAB",
    "CMSG_GUILD_BANK_UPDATE_TAB",
    "CMSG_GUILD_BANK_DEPOSIT_MONEY",
    "CMSG_GUILD_BANK_WITHDRAW_MONEY",
    "MSG_GUILD_BANK_LOG_QUERY_Client",
    "MSG_GUILD_BANK_LOG_QUERY_Server",
    "CMSG_SET_CHANNEL_WATCH",
    "SMSG_USERLIST_ADD",
    "SMSG_USERLIST_REMOVE",
    "SMSG_USERLIST_UPDATE",
    "CMSG_CLEAR_CHANNEL_WATCH",
    "SMSG_INSPECT_TALENT",
    "CMSG_SPELLCLICK",
    "SMSG_LOOT_LIST",
    "MSG_GUILD_PERMISSIONS_Client",
    "MSG_GUILD_PERMISSIONS_Server",
    "MSG_GUILD_BANK_MONEY_WITHDRAWN_Client",
    "MSG_GUILD_BANK_MONEY_WITHDRAWN_Server",
    "MSG_GUILD_EVENT_LOG_QUERY_Client",
    "MSG_GUILD_EVENT_LOG_QUERY_Server",
    "CMSG_GET_MIRRORIMAGE_DATA",
    "SMSG_MIRRORIMAGE_DATA",
    "CMSG_KEEP_ALIVE",
    "CMSG_OPT_OUT_OF_LOOT",
    "MSG_QUERY_GUILD_BANK_TEXT_Client",
    "MSG_QUERY_GUILD_BANK_TEXT_Server",
    "CMSG_SET_GUILD_BANK_TEXT",
    "CMSG_GRANT_LEVEL",
    "SMSG_OVERRIDE_LIGHT",
    "SMSG_TOTEM_CREATED",
    "CMSG_TOTEM_DESTROYED",
    "CMSG_QUESTGIVER_STATUS_MULTIPLE_QUERY",
    "SMSG_QUESTGIVER_STATUS_MULTIPLE",
    "CMSG_SET_PLAYER_DECLINED_NAMES",
    "SMSG_SET_PLAYER_DECLINED_NAMES_RESULT",
    "SMSG_SEND_UNLEARN_SPELLS",
    "SMSG_PROPOSE_LEVEL_GRANT",
    "CMSG_ACCEPT_LEVEL_GRANT",
    "SMSG_REFER_A_FRIEND_FAILURE",
    "SMSG_SPLINE_MOVE_SET_FLYING",
    "SMSG_SPLINE_MOVE_UNSET_FLYING",
    "CMSG_ALTER_APPEARANCE",
    "SMSG_ENABLE_BARBER_SHOP",
    "SMSG_BARBER_SHOP_RESULT",
    "CMSG_CALENDAR_GET_CALENDAR",
    "CMSG_CALENDAR_GET_EVENT",
    "CMSG_CALENDAR_GUILD_FILTER",
    "CMSG_CALENDAR_ARENA_TEAM",
    "CMSG_CALENDAR_ADD_EVENT",
    "CMSG_CALENDAR_UPDATE_EVENT",
    "CMSG_CALENDAR_REMOVE_EVENT",
    "CMSG_CALENDAR_COPY_EVENT",
    "CMSG_CALENDAR_EVENT_INVITE",
    "CMSG_CALENDAR_EVENT_RSVP",
    "CMSG_CALENDAR_EVENT_REMOVE_INVITE",
    "CMSG_CALENDAR_EVENT_STATUS",
    "CMSG_CALENDAR_EVENT_MODERATOR_STATUS",
    "SMSG_CALENDAR_SEND_CALENDAR",
    "SMSG_CALENDAR_SEND_EVENT",
    "SMSG_CALENDAR_FILTER_GUILD",
    "SMSG_CALENDAR_ARENA_TEAM",
    "SMSG_CALENDAR_EVENT_INVITE",
    "SMSG_CALENDAR_EVENT_INVITE_REMOVED",
    "SMSG_CALENDAR_EVENT_STATUS",
    "SMSG_CALENDAR_COMMAND_RESULT",
    "SMSG_CALENDAR_RAID_LOCKOUT_ADDED",
    "SMSG_CALENDAR_RAID_LOCKOUT_REMOVED",
    "SMSG_CALENDAR_EVENT_INVITE_ALERT",
    "SMSG_CALENDAR_EVENT_INVITE_REMOVED_ALERT",
    "SMSG_CALENDAR_EVENT_REMOVED_ALERT",
    "SMSG_CALENDAR_EVENT_UPDATED_ALERT",
    "SMSG_CALENDAR_EVENT_MODERATOR_STATUS_ALERT",
    "CMSG_CALENDAR_COMPLAIN",
    "CMSG_CALENDAR_GET_NUM_PENDING",
    "SMSG_CALENDAR_SEND_NUM_PENDING",
    "MSG_MOVE_SET_PITCH_RATE_Server",
    "SMSG_FORCE_PITCH_RATE_CHANGE",
    "SMSG_CALENDAR_EVENT_INVITE_NOTES",
    "SMSG_CALENDAR_EVENT_INVITE_NOTES_ALERT",
    "CMSG_UPDATE_MISSILE_TRAJECTORY",
    "SMSG_UPDATE_ACCOUNT_DATA_COMPLETE",
    "SMSG_TRIGGER_MOVIE",
    "CMSG_COMPLETE_MOVIE",
    "SMSG_ACHIEVEMENT_EARNED",
    "SMSG_CRITERIA_UPDATE",
    "CMSG_QUERY_INSPECT_ACHIEVEMENTS",
    "SMSG_RESPOND_INSPECT_ACHIEVEMENTS",
    "CMSG_DISMISS_CONTROLLED_VEHICLE",
    "SMSG_QUESTUPDATE_ADD_PVP_KILL",
    "SMSG_CALENDAR_RAID_LOCKOUT_UPDATED",
    "CMSG_CHAR_CUSTOMIZE",
    "SMSG_CHAR_CUSTOMIZE",
    "CMSG_REQUEST_VEHICLE_EXIT",
    "CMSG_REQUEST_VEHICLE_PREV_SEAT",
    "CMSG_REQUEST_VEHICLE_NEXT_SEAT",
    "CMSG_REQUEST_VEHICLE_SWITCH_SEAT",
    "CMSG_PET_LEARN_TALENT",
    "SMSG_SET_PHASE_SHIFT",
    "SMSG_ALL_ACHIEVEMENT_DATA",
    "SMSG_POWER_UPDATE",
    "CMSG_GAMEOBJ_REPORT_USE",
    "SMSG_HIGHEST_THREAT_UPDATE",
    "SMSG_THREAT_UPDATE",
    "SMSG_THREAT_REMOVE",
    "SMSG_THREAT_CLEAR",
    "SMSG_CONVERT_RUNE",
    "SMSG_RESYNC_RUNES",
    "SMSG_ADD_RUNE_POWER",
    "CMSG_REMOVE_GLYPH",
    "CMSG_DISMISS_CRITTER",
    "CMSG_AUCTION_LIST_PENDING_SALES",
    "SMSG_AUCTION_LIST_PENDING_SALES",
    "SMSG_MODIFY_COOLDOWN",
    "SMSG_PET_UPDATE_COMBO_POINTS",
    "CMSG_ENABLETAXI",
    "SMSG_PRE_RESURRECT",
    "SMSG_AURA_UPDATE_ALL",
    "SMSG_AURA_UPDATE",
    "SMSG_SERVER_FIRST_ACHIEVEMENT",
    "SMSG_PET_LEARNED_SPELL",
    "SMSG_PET_UNLEARNED_SPELL",
    "CMSG_CHANGE_SEATS_ON_CONTROLLED_VEHICLE",
    "CMSG_HEARTH_AND_RESURRECT",
    "SMSG_ON_CANCEL_EXPECTED_RIDE_VEHICLE_AURA",
    "SMSG_CRITERIA_DELETED",
    "SMSG_ACHIEVEMENT_DELETED",
    "SMSG_BATTLEGROUND_INFO_THROTTLED",
    "SMSG_PLAYER_VEHICLE_DATA",
    "CMSG_PLAYER_VEHICLE_ENTER",
    "CMSG_CONTROLLER_EJECT_PASSENGER",
    "SMSG_PET_GUIDS",
    "SMSG_CLIENTCACHE_VERSION",
    "SMSG_ITEM_REFUND_INFO_RESPONSE",
    "CMSG_ITEM_REFUND_INFO",
    "CMSG_ITEM_REFUND",
    "SMSG_ITEM_REFUND_RESULT",
    "CMSG_CORPSE_MAP_POSITION_QUERY",
    "SMSG_CORPSE_MAP_POSITION_QUERY_RESPONSE",
    "CMSG_CALENDAR_EVENT_SIGNUP",
    "SMSG_CALENDAR_CLEAR_PENDING_ACTION",
    "SMSG_EQUIPMENT_SET_LIST",
    "CMSG_EQUIPMENT_SET_SAVE",
    "CMSG_UPDATE_PROJECTILE_POSITION",
    "SMSG_SET_PROJECTILE_POSITION",
    "SMSG_TALENTS_INFO",
    "CMSG_LEARN_PREVIEW_TALENTS",
    "CMSG_LEARN_PREVIEW_TALENTS_PET",
    "SMSG_ARENA_UNIT_DESTROYED",
    "SMSG_ARENA_TEAM_CHANGE_FAILED_QUEUED",
    "SMSG_MOVE_GRAVITY_DISABLE",
    "CMSG_MOVE_GRAVITY_DISABLE_ACK",
    "SMSG_MOVE_GRAVITY_ENABLE",
    "CMSG_MOVE_GRAVITY_ENABLE_ACK",
    "MSG_MOVE_GRAVITY_CHNG_Server",
    "SMSG_SPLINE_MOVE_GRAVITY_DISABLE",
    "SMSG_SPLINE_MOVE_GRAVITY_ENABLE",
    "CMSG_EQUIPMENT_SET_USE",
    "SMSG_EQUIPMENT_SET_USE_RESULT",
    "CMSG_CHAR_FACTION_CHANGE",
    "SMSG_CHAR_FACTION_CHANGE",
    "SMSG_BATTLEFIELD_MGR_ENTRY_INVITE",
    "CMSG_BATTLEFIELD_MGR_ENTRY_INVITE_RESPONSE",
    "SMSG_BATTLEFIELD_MGR_ENTERED",
    "SMSG_BATTLEFIELD_MGR_QUEUE_INVITE",
    "CMSG_BATTLEFIELD_MGR_QUEUE_INVITE_RESPONSE",
    "SMSG_BATTLEFIELD_MGR_QUEUE_REQUEST_RESPONSE",
    "SMSG_BATTLEFIELD_MGR_EJECT_PENDING",
    "SMSG_BATTLEFIELD_MGR_EJECTED",
    "CMSG_BATTLEFIELD_MGR_EXIT_REQUEST",
    "SMSG_BATTLEFIELD_MGR_STATE_CHANGE",
    "MSG_SET_RAID_DIFFICULTY_Client",
    "MSG_SET_RAID_DIFFICULTY_Server",
    "SMSG_TOGGLE_XP_GAIN",
    "SMSG_GMRESPONSE_DB_ERROR",
    "SMSG_GMRESPONSE_RECEIVED",
    "CMSG_GMRESPONSE_RESOLVE",
    "SMSG_GMRESPONSE_STATUS_UPDATE",
    "CMSG_WORLD_STATE_UI_TIMER_UPDATE",
    "SMSG_WORLD_STATE_UI_TIMER_UPDATE",
    "CMSG_CHAR_RACE_CHANGE",
    "SMSG_TALENTS_INVOLUNTARILY_RESET",
    "CMSG_READY_FOR_ACCOUNT_DATA_TIMES",
    "CMSG_QUERY_QUESTS_COMPLETED",
    "SMSG_QUERY_QUESTS_COMPLETED_RESPONSE",
    "CMSG_GM_REPORT_LAG",
    "SMSG_CORPSE_NOT_IN_INSTANCE",
    "SMSG_CAMERA_SHAKE",
    "SMSG_SOCKET_GEMS_RESULT",
    "SMSG_REDIRECT_CLIENT",
    "SMSG_MOVE_SET_COLLISION_HGT",
    "CMSG_MOVE_SET_COLLISION_HGT_ACK",
    "SMSG_MULTIPLE_MOVES",
]


@dataclasses.dataclass
class NamedGuid:
    guid: int
    name: typing.Optional[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Aura:
        guid = await read_int(reader, 4)

        if guid != 0:
            name = await read_cstring(reader)

        return Aura(
            guid=guid,
            name=name,
        )

    def write(self, _fmt, _data):
        if self.guid != 0:
            _fmt += f"Q{len(self.name)}sB"
            _data.extend([self.guid, self.name, 0])
        else:
            _fmt += 'Q'
            _data.append(self.guid)

        return _fmt, _data

    def size(self) -> int:
        if guid != 0:
            return len(self.name) + 8
        else:
            return 8



@dataclasses.dataclass
class VariableItemRandomProperty:
    first: int
    second: typing.Optional[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        first = await read_int(reader, 4)

        second = None
        if first != 0:
            second = await read_int(reader, 4)

        return VariableItemRandomProperty(first=first, second=second)

    def write(self, fmt, data):
        fmt += 'I'
        data.append(first)

        if second is not None:
            fmt += 'I'
            data.append(second)

        return fmt, data

    def size(self):
        if second is not None:
            return 8
        else:
            return 4


@dataclasses.dataclass
class AddonArray:
    data: list[Addon]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        raise Exception('read for AddonArray is unimplemented. Create an issue on Github if this is relevant for you.')

    def write(self, fmt, data):
        for d in self.data:
            fmt, data = d.write(fmt, data)

        return fmt, data

    def size(self):
        size = 0
        for d in self.data:
            size += d.size()

        return size


@dataclasses.dataclass
class AchievementDoneArray:
    data: list[AchievementDone]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        data = []
        achievement = await read_int(reader, 4)

        while achievement != -1:
            time = await read_int(reader, 4)
            data.append(AchievementDone(achievement=achievement, time=time))

            achievement = await read_int(reader, 4)

        return AchievementDoneArray(data=data)

    def write(self, fmt, data):
        for d in self.data:
            fmt, data = d.write(fmt, data)

        fmt += "i"
        data.append(-1)

        return fmt, data

    def size(self):
        size = 4
        for d in self.data:
            size += d.size()
        return size


@dataclasses.dataclass
class AchievementInProgressArray:
    data: list[AchievementInProgress]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        data = []
        achievement = await read_int(reader, 4)

        while achievement != -1:
            counter = await read_packed_guid(reader)

            player = await read_packed_guid(reader)

            timed_criteria_failed = await read_bool(reader, 4)

            progress_date = await read_int(reader, 4)

            time_since_progress = await read_int(reader, 4)

            time_since_progress2 = await read_int(reader, 4)

            data.append(AchievementInProgress(
                                              achievement=achievement,
                                              counter=counter,
                                              player=player,
                                              timed_criteria_failed=timed_criteria_failed,
                                              progress_date=progress_date,
                                              time_since_progress=time_since_progress,
                                              time_since_progress2=time_since_progress2,
                                              ))

            achievement = await read_int(reader, 4)

        return AchievementInProgressArray(data=data)

    def write(self, fmt, data):
        for d in self.data:
            fmt, data = d.write(fmt, data)

        fmt += "i"
        data.append(-1)

        return fmt, data

    def size(self):
        size = 4
        for d in self.data:
            size += d.size()
        return size


@dataclasses.dataclass
class CacheMask:
    fields: dict[int, int]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        mask = await read_int(reader, 4)

        fields = {}
        for index in range(0, 32):
            if mask & 1 << index:
                fields[index] = await read_int(reader, 2)

        return AuraMask(fields=fields)

    def write(self, fmt, data):
        mask = 0
        for key in self.fields:
            mask |= 1 << key

        fmt += 'I'
        data.append(mask)

        fmt += f"{len(self.fields)}H"
        data.extend(list(self.fields.values()))

        return fmt, data

    def size(self):
        return 4 + len(self.fields) * 2


@dataclasses.dataclass
class UpdateMask:
    fields: dict[int, int]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        amount_of_blocks = await read_int(reader, 1)

        blocks = []
        for _ in range(0, amount_of_blocks):
            blocks.append(await read_int(reader, 4))

        fields = {}
        for block_index, block in enumerate(blocks):
            for bit in range(0, 32):
                if block & 1 << bit:
                    value = await read_int(reader, 4)
                    key = block_index * 32 + bit
                    fields[key] = value

        return UpdateMask(fields=fields)

    def write(self, fmt, data):
        highest_key = max(self.fields, default=0)
        amount_of_blocks = highest_key // 32
        if highest_key % 32 != 0:
            amount_of_blocks += 1

        fmt += 'B'
        data.append(amount_of_blocks)

        blocks = [0] * amount_of_blocks

        for key in self.fields:
            block = key // 32
            index = key % 32
            blocks[block] |= 1 << index

        fmt += f'{len(blocks)}I'
        data.extend(blocks)

        for key in sorted(self.fields):
            if isinstance(self.fields[key], float):
                fmt += 'f'
            else:
                fmt += 'I'
            data.append(self.fields[key])

        return fmt, data

    def size(self):
        highest_key = max(self.fields, default=0)
        amount_of_blocks = highest_key // 32

        extra = highest_key % 32
        if extra != 0:
            extra = 1
        else:
            extra = 0

        return 1 + (extra + amount_of_blocks + len(self.fields)) * 4


class UpdateMaskValue(enum.IntEnum):
    OBJECT_GUID = 0
    OBJECT_TYPE = 2
    OBJECT_ENTRY = 3
    OBJECT_SCALE_X = 4
    ITEM_OWNER = 6
    ITEM_CONTAINED = 8
    ITEM_CREATOR = 10
    ITEM_GIFTCREATOR = 12
    ITEM_STACK_COUNT = 14
    ITEM_DURATION = 15
    ITEM_SPELL_CHARGES = 16
    ITEM_FLAGS = 21
    ITEM_ENCHANTMENT_1_1 = 22
    ITEM_ENCHANTMENT_1_3 = 24
    ITEM_ENCHANTMENT_2_1 = 25
    ITEM_ENCHANTMENT_2_3 = 27
    ITEM_ENCHANTMENT_3_1 = 28
    ITEM_ENCHANTMENT_3_3 = 30
    ITEM_ENCHANTMENT_4_1 = 31
    ITEM_ENCHANTMENT_4_3 = 33
    ITEM_ENCHANTMENT_5_1 = 34
    ITEM_ENCHANTMENT_5_3 = 36
    ITEM_ENCHANTMENT_6_1 = 37
    ITEM_ENCHANTMENT_6_3 = 39
    ITEM_ENCHANTMENT_7_1 = 40
    ITEM_ENCHANTMENT_7_3 = 42
    ITEM_ENCHANTMENT_8_1 = 43
    ITEM_ENCHANTMENT_8_3 = 45
    ITEM_ENCHANTMENT_9_1 = 46
    ITEM_ENCHANTMENT_9_3 = 48
    ITEM_ENCHANTMENT_10_1 = 49
    ITEM_ENCHANTMENT_10_3 = 51
    ITEM_ENCHANTMENT_11_1 = 52
    ITEM_ENCHANTMENT_11_3 = 54
    ITEM_ENCHANTMENT_12_1 = 55
    ITEM_ENCHANTMENT_12_3 = 57
    ITEM_PROPERTY_SEED = 58
    ITEM_RANDOM_PROPERTIES_ID = 59
    ITEM_DURABILITY = 60
    ITEM_MAXDURABILITY = 61
    ITEM_CREATE_PLAYED_TIME = 62
    CONTAINER_NUM_SLOTS = 64
    CONTAINER_SLOT_1 = 66
    UNIT_CHARM = 6
    UNIT_SUMMON = 8
    UNIT_CRITTER = 10
    UNIT_CHARMEDBY = 12
    UNIT_SUMMONEDBY = 14
    UNIT_CREATEDBY = 16
    UNIT_TARGET = 18
    UNIT_CHANNEL_OBJECT = 20
    UNIT_CHANNEL_SPELL = 22
    UNIT_BYTES_0 = 23
    UNIT_HEALTH = 24
    UNIT_POWER1 = 25
    UNIT_POWER2 = 26
    UNIT_POWER3 = 27
    UNIT_POWER4 = 28
    UNIT_POWER5 = 29
    UNIT_POWER6 = 30
    UNIT_POWER7 = 31
    UNIT_MAXHEALTH = 32
    UNIT_MAXPOWER1 = 33
    UNIT_MAXPOWER2 = 34
    UNIT_MAXPOWER3 = 35
    UNIT_MAXPOWER4 = 36
    UNIT_MAXPOWER5 = 37
    UNIT_MAXPOWER6 = 38
    UNIT_MAXPOWER7 = 39
    UNIT_POWER_REGEN_FLAT_MODIFIER = 40
    UNIT_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER = 47
    UNIT_LEVEL = 54
    UNIT_FACTIONTEMPLATE = 55
    UNIT_VIRTUAL_ITEM_SLOT_ID = 56
    UNIT_FLAGS = 59
    UNIT_FLAGS_2 = 60
    UNIT_AURASTATE = 61
    UNIT_BASEATTACKTIME = 62
    UNIT_RANGEDATTACKTIME = 64
    UNIT_BOUNDINGRADIUS = 65
    UNIT_COMBATREACH = 66
    UNIT_DISPLAYID = 67
    UNIT_NATIVEDISPLAYID = 68
    UNIT_MOUNTDISPLAYID = 69
    UNIT_MINDAMAGE = 70
    UNIT_MAXDAMAGE = 71
    UNIT_MINOFFHANDDAMAGE = 72
    UNIT_MAXOFFHANDDAMAGE = 73
    UNIT_BYTES_1 = 74
    UNIT_PETNUMBER = 75
    UNIT_PET_NAME_TIMESTAMP = 76
    UNIT_PETEXPERIENCE = 77
    UNIT_PETNEXTLEVELEXP = 78
    UNIT_DYNAMIC_FLAGS = 79
    UNIT_MOD_CAST_SPEED = 80
    UNIT_CREATED_BY_SPELL = 81
    UNIT_NPC_FLAGS = 82
    UNIT_NPC_EMOTESTATE = 83
    UNIT_STRENGTH = 84
    UNIT_AGILITY = 85
    UNIT_STAMINA = 86
    UNIT_INTELLECT = 87
    UNIT_SPIRIT = 88
    UNIT_POSSTAT0 = 89
    UNIT_POSSTAT1 = 90
    UNIT_POSSTAT2 = 91
    UNIT_POSSTAT3 = 92
    UNIT_POSSTAT4 = 93
    UNIT_NEGSTAT0 = 94
    UNIT_NEGSTAT1 = 95
    UNIT_NEGSTAT2 = 96
    UNIT_NEGSTAT3 = 97
    UNIT_NEGSTAT4 = 98
    UNIT_RESISTANCES = 99
    UNIT_RESISTANCEBUFFMODSPOSITIVE = 106
    UNIT_RESISTANCEBUFFMODSNEGATIVE = 113
    UNIT_BASE_MANA = 120
    UNIT_BASE_HEALTH = 121
    UNIT_BYTES_2 = 122
    UNIT_ATTACK_POWER = 123
    UNIT_ATTACK_POWER_MODS = 124
    UNIT_ATTACK_POWER_MULTIPLIER = 125
    UNIT_RANGED_ATTACK_POWER = 126
    UNIT_RANGED_ATTACK_POWER_MODS = 127
    UNIT_RANGED_ATTACK_POWER_MULTIPLIER = 128
    UNIT_MINRANGEDDAMAGE = 129
    UNIT_MAXRANGEDDAMAGE = 130
    UNIT_POWER_COST_MODIFIER = 131
    UNIT_POWER_COST_MULTIPLIER = 138
    UNIT_MAXHEALTHMODIFIER = 145
    UNIT_HOVERHEIGHT = 146
    PLAYER_DUEL_ARBITER = 148
    PLAYER_FLAGS = 150
    PLAYER_GUILDID = 151
    PLAYER_GUILDRANK = 152
    PLAYER_FIELD_BYTES = 153
    PLAYER_BYTES_2 = 154
    PLAYER_BYTES_3 = 155
    PLAYER_DUEL_TEAM = 156
    PLAYER_GUILD_TIMESTAMP = 157
    PLAYER_QUEST_LOG_1_1 = 158
    PLAYER_QUEST_LOG_1_2 = 159
    PLAYER_QUEST_LOG_1_3 = 160
    PLAYER_QUEST_LOG_1_4 = 162
    PLAYER_QUEST_LOG_2_1 = 163
    PLAYER_QUEST_LOG_2_2 = 164
    PLAYER_QUEST_LOG_2_3 = 165
    PLAYER_QUEST_LOG_2_5 = 167
    PLAYER_QUEST_LOG_3_1 = 168
    PLAYER_QUEST_LOG_3_2 = 169
    PLAYER_QUEST_LOG_3_3 = 170
    PLAYER_QUEST_LOG_3_5 = 172
    PLAYER_QUEST_LOG_4_1 = 173
    PLAYER_QUEST_LOG_4_2 = 174
    PLAYER_QUEST_LOG_4_3 = 175
    PLAYER_QUEST_LOG_4_5 = 177
    PLAYER_QUEST_LOG_5_1 = 178
    PLAYER_QUEST_LOG_5_2 = 179
    PLAYER_QUEST_LOG_5_3 = 180
    PLAYER_QUEST_LOG_5_5 = 182
    PLAYER_QUEST_LOG_6_1 = 183
    PLAYER_QUEST_LOG_6_2 = 184
    PLAYER_QUEST_LOG_6_3 = 185
    PLAYER_QUEST_LOG_6_5 = 187
    PLAYER_QUEST_LOG_7_1 = 188
    PLAYER_QUEST_LOG_7_2 = 189
    PLAYER_QUEST_LOG_7_3 = 190
    PLAYER_QUEST_LOG_7_5 = 192
    PLAYER_QUEST_LOG_8_1 = 193
    PLAYER_QUEST_LOG_8_2 = 194
    PLAYER_QUEST_LOG_8_3 = 195
    PLAYER_QUEST_LOG_8_5 = 197
    PLAYER_QUEST_LOG_9_1 = 198
    PLAYER_QUEST_LOG_9_2 = 199
    PLAYER_QUEST_LOG_9_3 = 200
    PLAYER_QUEST_LOG_9_5 = 202
    PLAYER_QUEST_LOG_10_1 = 203
    PLAYER_QUEST_LOG_10_2 = 204
    PLAYER_QUEST_LOG_10_3 = 205
    PLAYER_QUEST_LOG_10_5 = 207
    PLAYER_QUEST_LOG_11_1 = 208
    PLAYER_QUEST_LOG_11_2 = 209
    PLAYER_QUEST_LOG_11_3 = 210
    PLAYER_QUEST_LOG_11_5 = 212
    PLAYER_QUEST_LOG_12_1 = 213
    PLAYER_QUEST_LOG_12_2 = 214
    PLAYER_QUEST_LOG_12_3 = 215
    PLAYER_QUEST_LOG_12_5 = 217
    PLAYER_QUEST_LOG_13_1 = 218
    PLAYER_QUEST_LOG_13_2 = 219
    PLAYER_QUEST_LOG_13_3 = 220
    PLAYER_QUEST_LOG_13_5 = 222
    PLAYER_QUEST_LOG_14_1 = 223
    PLAYER_QUEST_LOG_14_2 = 224
    PLAYER_QUEST_LOG_14_3 = 225
    PLAYER_QUEST_LOG_14_5 = 227
    PLAYER_QUEST_LOG_15_1 = 228
    PLAYER_QUEST_LOG_15_2 = 229
    PLAYER_QUEST_LOG_15_3 = 230
    PLAYER_QUEST_LOG_15_5 = 232
    PLAYER_QUEST_LOG_16_1 = 233
    PLAYER_QUEST_LOG_16_2 = 234
    PLAYER_QUEST_LOG_16_3 = 235
    PLAYER_QUEST_LOG_16_5 = 237
    PLAYER_QUEST_LOG_17_1 = 238
    PLAYER_QUEST_LOG_17_2 = 239
    PLAYER_QUEST_LOG_17_3 = 240
    PLAYER_QUEST_LOG_17_5 = 242
    PLAYER_QUEST_LOG_18_1 = 243
    PLAYER_QUEST_LOG_18_2 = 244
    PLAYER_QUEST_LOG_18_3 = 245
    PLAYER_QUEST_LOG_18_5 = 247
    PLAYER_QUEST_LOG_19_1 = 248
    PLAYER_QUEST_LOG_19_2 = 249
    PLAYER_QUEST_LOG_19_3 = 250
    PLAYER_QUEST_LOG_19_5 = 252
    PLAYER_QUEST_LOG_20_1 = 253
    PLAYER_QUEST_LOG_20_2 = 254
    PLAYER_QUEST_LOG_20_3 = 255
    PLAYER_QUEST_LOG_20_5 = 257
    PLAYER_QUEST_LOG_21_1 = 258
    PLAYER_QUEST_LOG_21_2 = 259
    PLAYER_QUEST_LOG_21_3 = 260
    PLAYER_QUEST_LOG_21_5 = 262
    PLAYER_QUEST_LOG_22_1 = 263
    PLAYER_QUEST_LOG_22_2 = 264
    PLAYER_QUEST_LOG_22_3 = 265
    PLAYER_QUEST_LOG_22_5 = 267
    PLAYER_QUEST_LOG_23_1 = 268
    PLAYER_QUEST_LOG_23_2 = 269
    PLAYER_QUEST_LOG_23_3 = 270
    PLAYER_QUEST_LOG_23_5 = 272
    PLAYER_QUEST_LOG_24_1 = 273
    PLAYER_QUEST_LOG_24_2 = 274
    PLAYER_QUEST_LOG_24_3 = 275
    PLAYER_QUEST_LOG_24_5 = 277
    PLAYER_QUEST_LOG_25_1 = 278
    PLAYER_QUEST_LOG_25_2 = 279
    PLAYER_QUEST_LOG_25_3 = 280
    PLAYER_QUEST_LOG_25_5 = 282
    PLAYER_VISIBLE_ITEM_0_ITEM = 283
    PLAYER_VISIBLE_ITEM_0_ENCHANTS = 284
    PLAYER_VISIBLE_ITEM_1_ITEM = 285
    PLAYER_VISIBLE_ITEM_1_ENCHANTS = 286
    PLAYER_VISIBLE_ITEM_2_ITEM = 287
    PLAYER_VISIBLE_ITEM_2_ENCHANTS = 288
    PLAYER_VISIBLE_ITEM_3_ITEM = 289
    PLAYER_VISIBLE_ITEM_3_ENCHANTS = 290
    PLAYER_VISIBLE_ITEM_4_ITEM = 291
    PLAYER_VISIBLE_ITEM_4_ENCHANTS = 292
    PLAYER_VISIBLE_ITEM_5_ITEM = 293
    PLAYER_VISIBLE_ITEM_5_ENCHANTS = 294
    PLAYER_VISIBLE_ITEM_6_ITEM = 295
    PLAYER_VISIBLE_ITEM_6_ENCHANTS = 296
    PLAYER_VISIBLE_ITEM_7_ITEM = 297
    PLAYER_VISIBLE_ITEM_7_ENCHANTS = 298
    PLAYER_VISIBLE_ITEM_8_ITEM = 299
    PLAYER_VISIBLE_ITEM_8_ENCHANTS = 300
    PLAYER_VISIBLE_ITEM_9_ITEM = 301
    PLAYER_VISIBLE_ITEM_9_ENCHANTS = 302
    PLAYER_VISIBLE_ITEM_10_ITEM = 303
    PLAYER_VISIBLE_ITEM_10_ENCHANTS = 304
    PLAYER_VISIBLE_ITEM_11_ITEM = 305
    PLAYER_VISIBLE_ITEM_11_ENCHANTS = 306
    PLAYER_VISIBLE_ITEM_12_ITEM = 307
    PLAYER_VISIBLE_ITEM_12_ENCHANTS = 308
    PLAYER_VISIBLE_ITEM_13_ITEM = 309
    PLAYER_VISIBLE_ITEM_13_ENCHANTS = 310
    PLAYER_VISIBLE_ITEM_14_ITEM = 311
    PLAYER_VISIBLE_ITEM_14_ENCHANTS = 312
    PLAYER_VISIBLE_ITEM_15_ITEM = 313
    PLAYER_VISIBLE_ITEM_15_ENCHANTS = 314
    PLAYER_VISIBLE_ITEM_16_ITEM = 315
    PLAYER_VISIBLE_ITEM_16_ENCHANTS = 316
    PLAYER_VISIBLE_ITEM_17_ITEM = 317
    PLAYER_VISIBLE_ITEM_17_ENCHANTS = 318
    PLAYER_VISIBLE_ITEM_18_ITEM = 319
    PLAYER_VISIBLE_ITEM_18_ENCHANTS = 320
    PLAYER_CHOSEN_TITLE = 321
    PLAYER_FAKE_INEBRIATION = 322
    PLAYER_FIELD_INV_HEAD = 324
    PLAYER_FIELD_INV_NECK = 326
    PLAYER_FIELD_INV_SHOULDERS = 328
    PLAYER_FIELD_INV_SHIRT = 330
    PLAYER_FIELD_INV_CHEST = 332
    PLAYER_FIELD_INV_WAIST = 334
    PLAYER_FIELD_INV_LEGS = 336
    PLAYER_FIELD_INV_BOOTS = 338
    PLAYER_FIELD_INV_WRIST = 340
    PLAYER_FIELD_INV_HANDS = 342
    PLAYER_FIELD_INV_RING1 = 344
    PLAYER_FIELD_INV_RING2 = 346
    PLAYER_FIELD_INV_TRINKET1 = 348
    PLAYER_FIELD_INV_TRINKET2 = 350
    PLAYER_FIELD_INV_BACK = 352
    PLAYER_FIELD_INV_MAIN_HAND = 354
    PLAYER_FIELD_INV_OFF_HAND = 356
    PLAYER_FIELD_INV_RANGED_OR_RELIC = 358
    PLAYER_FIELD_INV_TABARD = 360
    PLAYER_FIELD_INV_BAG1 = 362
    PLAYER_FIELD_INV_BAG2 = 364
    PLAYER_FIELD_INV_BAG3 = 366
    PLAYER_FIELD_INV_BAG4 = 368
    PLAYER_FIELD_INV_INVENTORY_0 = 370
    PLAYER_FIELD_INV_INVENTORY_1 = 372
    PLAYER_FIELD_INV_INVENTORY_2 = 374
    PLAYER_FIELD_INV_INVENTORY_3 = 376
    PLAYER_FIELD_INV_INVENTORY_4 = 378
    PLAYER_FIELD_INV_INVENTORY_5 = 380
    PLAYER_FIELD_INV_INVENTORY_6 = 382
    PLAYER_FIELD_INV_INVENTORY_7 = 384
    PLAYER_FIELD_INV_INVENTORY_8 = 386
    PLAYER_FIELD_INV_INVENTORY_9 = 388
    PLAYER_FIELD_INV_INVENTORY_10 = 390
    PLAYER_FIELD_INV_INVENTORY_11 = 392
    PLAYER_FIELD_INV_INVENTORY_12 = 394
    PLAYER_FIELD_INV_INVENTORY_13 = 396
    PLAYER_FIELD_INV_INVENTORY_14 = 398
    PLAYER_FIELD_INV_INVENTORY_15 = 400
    PLAYER_FIELD_INV_BANK_1 = 402
    PLAYER_FIELD_INV_BANK_2 = 404
    PLAYER_FIELD_INV_BANK_3 = 406
    PLAYER_FIELD_INV_BANK_4 = 408
    PLAYER_FIELD_INV_BANK_5 = 410
    PLAYER_FIELD_INV_BANK_6 = 412
    PLAYER_FIELD_INV_BANK_7 = 414
    PLAYER_FIELD_INV_BANK_8 = 416
    PLAYER_FIELD_INV_BANK_9 = 418
    PLAYER_FIELD_INV_BANK_10 = 420
    PLAYER_FIELD_INV_BANK_11 = 422
    PLAYER_FIELD_INV_BANK_12 = 424
    PLAYER_FIELD_INV_BANK_13 = 426
    PLAYER_FIELD_INV_BANK_14 = 428
    PLAYER_FIELD_INV_BANK_15 = 430
    PLAYER_FIELD_INV_BANK_16 = 432
    PLAYER_FIELD_INV_BANK_17 = 434
    PLAYER_FIELD_INV_BANK_18 = 436
    PLAYER_FIELD_INV_BANK_19 = 438
    PLAYER_FIELD_INV_BANK_20 = 440
    PLAYER_FIELD_INV_BANK_21 = 442
    PLAYER_FIELD_INV_BANK_22 = 444
    PLAYER_FIELD_INV_BANK_23 = 446
    PLAYER_FIELD_INV_BANK_24 = 448
    PLAYER_FIELD_INV_BANK_25 = 450
    PLAYER_FIELD_INV_BANK_26 = 452
    PLAYER_FIELD_INV_BANK_27 = 454
    PLAYER_FIELD_INV_BANK_28 = 456
    PLAYER_FIELD_INV_BANK_BAG_SLOT_1 = 458
    PLAYER_FIELD_INV_BANK_BAG_SLOT_2 = 460
    PLAYER_FIELD_INV_BANK_BAG_SLOT_3 = 462
    PLAYER_FIELD_INV_BANK_BAG_SLOT_4 = 464
    PLAYER_FIELD_INV_BANK_BAG_SLOT_5 = 466
    PLAYER_FIELD_INV_BANK_BAG_SLOT_6 = 468
    PLAYER_FIELD_INV_BANK_BAG_SLOT_7 = 470
    PLAYER_FIELD_INV_VENDOR_BUYBACK_1 = 472
    PLAYER_FIELD_INV_VENDOR_BUYBACK_2 = 474
    PLAYER_FIELD_INV_VENDOR_BUYBACK_3 = 476
    PLAYER_FIELD_INV_VENDOR_BUYBACK_4 = 478
    PLAYER_FIELD_INV_VENDOR_BUYBACK_5 = 480
    PLAYER_FIELD_INV_VENDOR_BUYBACK_6 = 482
    PLAYER_FIELD_INV_VENDOR_BUYBACK_7 = 484
    PLAYER_FIELD_INV_VENDOR_BUYBACK_8 = 486
    PLAYER_FIELD_INV_VENDOR_BUYBACK_9 = 488
    PLAYER_FIELD_INV_VENDOR_BUYBACK_10 = 490
    PLAYER_FIELD_INV_VENDOR_BUYBACK_11 = 492
    PLAYER_FIELD_INV_VENDOR_BUYBACK_12 = 494
    PLAYER_FIELD_INV_KEYRING_1 = 496
    PLAYER_FIELD_INV_KEYRING_2 = 498
    PLAYER_FIELD_INV_KEYRING_3 = 500
    PLAYER_FIELD_INV_KEYRING_4 = 502
    PLAYER_FIELD_INV_KEYRING_5 = 504
    PLAYER_FIELD_INV_KEYRING_6 = 506
    PLAYER_FIELD_INV_KEYRING_7 = 508
    PLAYER_FIELD_INV_KEYRING_8 = 510
    PLAYER_FIELD_INV_KEYRING_9 = 512
    PLAYER_FIELD_INV_KEYRING_10 = 514
    PLAYER_FIELD_INV_KEYRING_11 = 516
    PLAYER_FIELD_INV_KEYRING_12 = 518
    PLAYER_FIELD_INV_KEYRING_13 = 520
    PLAYER_FIELD_INV_KEYRING_14 = 522
    PLAYER_FIELD_INV_KEYRING_15 = 524
    PLAYER_FIELD_INV_KEYRING_16 = 526
    PLAYER_FIELD_INV_KEYRING_17 = 528
    PLAYER_FIELD_INV_KEYRING_18 = 530
    PLAYER_FIELD_INV_KEYRING_19 = 532
    PLAYER_FIELD_INV_KEYRING_20 = 534
    PLAYER_FIELD_INV_KEYRING_21 = 536
    PLAYER_FIELD_INV_KEYRING_22 = 538
    PLAYER_FIELD_INV_KEYRING_23 = 540
    PLAYER_FIELD_INV_KEYRING_24 = 542
    PLAYER_FIELD_INV_KEYRING_25 = 544
    PLAYER_FIELD_INV_KEYRING_26 = 546
    PLAYER_FIELD_INV_KEYRING_27 = 548
    PLAYER_FIELD_INV_KEYRING_28 = 550
    PLAYER_FIELD_INV_KEYRING_29 = 552
    PLAYER_FIELD_INV_KEYRING_30 = 554
    PLAYER_FIELD_INV_KEYRING_31 = 556
    PLAYER_FIELD_INV_KEYRING_32 = 558
    PLAYER_FIELD_INV_CURRENCY_TOKEN_1 = 560
    PLAYER_FIELD_INV_CURRENCY_TOKEN_2 = 562
    PLAYER_FIELD_INV_CURRENCY_TOKEN_3 = 564
    PLAYER_FIELD_INV_CURRENCY_TOKEN_4 = 566
    PLAYER_FIELD_INV_CURRENCY_TOKEN_5 = 568
    PLAYER_FIELD_INV_CURRENCY_TOKEN_6 = 570
    PLAYER_FIELD_INV_CURRENCY_TOKEN_7 = 572
    PLAYER_FIELD_INV_CURRENCY_TOKEN_8 = 574
    PLAYER_FIELD_INV_CURRENCY_TOKEN_9 = 576
    PLAYER_FIELD_INV_CURRENCY_TOKEN_10 = 578
    PLAYER_FIELD_INV_CURRENCY_TOKEN_11 = 580
    PLAYER_FIELD_INV_CURRENCY_TOKEN_12 = 582
    PLAYER_FIELD_INV_CURRENCY_TOKEN_13 = 584
    PLAYER_FIELD_INV_CURRENCY_TOKEN_14 = 586
    PLAYER_FIELD_INV_CURRENCY_TOKEN_15 = 588
    PLAYER_FIELD_INV_CURRENCY_TOKEN_16 = 590
    PLAYER_FIELD_INV_CURRENCY_TOKEN_17 = 592
    PLAYER_FIELD_INV_CURRENCY_TOKEN_18 = 594
    PLAYER_FIELD_INV_CURRENCY_TOKEN_19 = 596
    PLAYER_FIELD_INV_CURRENCY_TOKEN_20 = 598
    PLAYER_FIELD_INV_CURRENCY_TOKEN_21 = 600
    PLAYER_FIELD_INV_CURRENCY_TOKEN_22 = 602
    PLAYER_FIELD_INV_CURRENCY_TOKEN_23 = 604
    PLAYER_FIELD_INV_CURRENCY_TOKEN_24 = 606
    PLAYER_FIELD_INV_CURRENCY_TOKEN_25 = 608
    PLAYER_FIELD_INV_CURRENCY_TOKEN_26 = 610
    PLAYER_FIELD_INV_CURRENCY_TOKEN_27 = 612
    PLAYER_FIELD_INV_CURRENCY_TOKEN_28 = 614
    PLAYER_FIELD_INV_CURRENCY_TOKEN_29 = 616
    PLAYER_FIELD_INV_CURRENCY_TOKEN_30 = 618
    PLAYER_FIELD_INV_CURRENCY_TOKEN_31 = 620
    PLAYER_FIELD_INV_CURRENCY_TOKEN_32 = 622
    PLAYER_FARSIGHT = 624
    PLAYER_KNOWN_TITLES = 626
    PLAYER_KNOWN_TITLES1 = 628
    PLAYER_KNOWN_TITLES2 = 630
    PLAYER_KNOWN_CURRENCIES = 632
    PLAYER_XP = 634
    PLAYER_NEXT_LEVEL_XP = 635
    PLAYER_SKILL_INFO_0_SKILL_0 = 636
    PLAYER_SKILL_INFO_0_SKILL_STEP_1 = 636
    PLAYER_SKILL_INFO_0_MINIMUM_0 = 637
    PLAYER_SKILL_INFO_0_MAXIMUM_1 = 637
    PLAYER_SKILL_INFO_0_PERMANENT_BONUS_0 = 638
    PLAYER_SKILL_INFO_0_TEMPORARY_BONUS_1 = 638
    PLAYER_SKILL_INFO_1_SKILL_0 = 639
    PLAYER_SKILL_INFO_1_SKILL_STEP_1 = 639
    PLAYER_SKILL_INFO_1_MINIMUM_0 = 640
    PLAYER_SKILL_INFO_1_MAXIMUM_1 = 640
    PLAYER_SKILL_INFO_1_PERMANENT_BONUS_0 = 641
    PLAYER_SKILL_INFO_1_TEMPORARY_BONUS_1 = 641
    PLAYER_SKILL_INFO_2_SKILL_0 = 642
    PLAYER_SKILL_INFO_2_SKILL_STEP_1 = 642
    PLAYER_SKILL_INFO_2_MINIMUM_0 = 643
    PLAYER_SKILL_INFO_2_MAXIMUM_1 = 643
    PLAYER_SKILL_INFO_2_PERMANENT_BONUS_0 = 644
    PLAYER_SKILL_INFO_2_TEMPORARY_BONUS_1 = 644
    PLAYER_SKILL_INFO_3_SKILL_0 = 645
    PLAYER_SKILL_INFO_3_SKILL_STEP_1 = 645
    PLAYER_SKILL_INFO_3_MINIMUM_0 = 646
    PLAYER_SKILL_INFO_3_MAXIMUM_1 = 646
    PLAYER_SKILL_INFO_3_PERMANENT_BONUS_0 = 647
    PLAYER_SKILL_INFO_3_TEMPORARY_BONUS_1 = 647
    PLAYER_SKILL_INFO_4_SKILL_0 = 648
    PLAYER_SKILL_INFO_4_SKILL_STEP_1 = 648
    PLAYER_SKILL_INFO_4_MINIMUM_0 = 649
    PLAYER_SKILL_INFO_4_MAXIMUM_1 = 649
    PLAYER_SKILL_INFO_4_PERMANENT_BONUS_0 = 650
    PLAYER_SKILL_INFO_4_TEMPORARY_BONUS_1 = 650
    PLAYER_SKILL_INFO_5_SKILL_0 = 651
    PLAYER_SKILL_INFO_5_SKILL_STEP_1 = 651
    PLAYER_SKILL_INFO_5_MINIMUM_0 = 652
    PLAYER_SKILL_INFO_5_MAXIMUM_1 = 652
    PLAYER_SKILL_INFO_5_PERMANENT_BONUS_0 = 653
    PLAYER_SKILL_INFO_5_TEMPORARY_BONUS_1 = 653
    PLAYER_SKILL_INFO_6_SKILL_0 = 654
    PLAYER_SKILL_INFO_6_SKILL_STEP_1 = 654
    PLAYER_SKILL_INFO_6_MINIMUM_0 = 655
    PLAYER_SKILL_INFO_6_MAXIMUM_1 = 655
    PLAYER_SKILL_INFO_6_PERMANENT_BONUS_0 = 656
    PLAYER_SKILL_INFO_6_TEMPORARY_BONUS_1 = 656
    PLAYER_SKILL_INFO_7_SKILL_0 = 657
    PLAYER_SKILL_INFO_7_SKILL_STEP_1 = 657
    PLAYER_SKILL_INFO_7_MINIMUM_0 = 658
    PLAYER_SKILL_INFO_7_MAXIMUM_1 = 658
    PLAYER_SKILL_INFO_7_PERMANENT_BONUS_0 = 659
    PLAYER_SKILL_INFO_7_TEMPORARY_BONUS_1 = 659
    PLAYER_SKILL_INFO_8_SKILL_0 = 660
    PLAYER_SKILL_INFO_8_SKILL_STEP_1 = 660
    PLAYER_SKILL_INFO_8_MINIMUM_0 = 661
    PLAYER_SKILL_INFO_8_MAXIMUM_1 = 661
    PLAYER_SKILL_INFO_8_PERMANENT_BONUS_0 = 662
    PLAYER_SKILL_INFO_8_TEMPORARY_BONUS_1 = 662
    PLAYER_SKILL_INFO_9_SKILL_0 = 663
    PLAYER_SKILL_INFO_9_SKILL_STEP_1 = 663
    PLAYER_SKILL_INFO_9_MINIMUM_0 = 664
    PLAYER_SKILL_INFO_9_MAXIMUM_1 = 664
    PLAYER_SKILL_INFO_9_PERMANENT_BONUS_0 = 665
    PLAYER_SKILL_INFO_9_TEMPORARY_BONUS_1 = 665
    PLAYER_SKILL_INFO_10_SKILL_0 = 666
    PLAYER_SKILL_INFO_10_SKILL_STEP_1 = 666
    PLAYER_SKILL_INFO_10_MINIMUM_0 = 667
    PLAYER_SKILL_INFO_10_MAXIMUM_1 = 667
    PLAYER_SKILL_INFO_10_PERMANENT_BONUS_0 = 668
    PLAYER_SKILL_INFO_10_TEMPORARY_BONUS_1 = 668
    PLAYER_SKILL_INFO_11_SKILL_0 = 669
    PLAYER_SKILL_INFO_11_SKILL_STEP_1 = 669
    PLAYER_SKILL_INFO_11_MINIMUM_0 = 670
    PLAYER_SKILL_INFO_11_MAXIMUM_1 = 670
    PLAYER_SKILL_INFO_11_PERMANENT_BONUS_0 = 671
    PLAYER_SKILL_INFO_11_TEMPORARY_BONUS_1 = 671
    PLAYER_SKILL_INFO_12_SKILL_0 = 672
    PLAYER_SKILL_INFO_12_SKILL_STEP_1 = 672
    PLAYER_SKILL_INFO_12_MINIMUM_0 = 673
    PLAYER_SKILL_INFO_12_MAXIMUM_1 = 673
    PLAYER_SKILL_INFO_12_PERMANENT_BONUS_0 = 674
    PLAYER_SKILL_INFO_12_TEMPORARY_BONUS_1 = 674
    PLAYER_SKILL_INFO_13_SKILL_0 = 675
    PLAYER_SKILL_INFO_13_SKILL_STEP_1 = 675
    PLAYER_SKILL_INFO_13_MINIMUM_0 = 676
    PLAYER_SKILL_INFO_13_MAXIMUM_1 = 676
    PLAYER_SKILL_INFO_13_PERMANENT_BONUS_0 = 677
    PLAYER_SKILL_INFO_13_TEMPORARY_BONUS_1 = 677
    PLAYER_SKILL_INFO_14_SKILL_0 = 678
    PLAYER_SKILL_INFO_14_SKILL_STEP_1 = 678
    PLAYER_SKILL_INFO_14_MINIMUM_0 = 679
    PLAYER_SKILL_INFO_14_MAXIMUM_1 = 679
    PLAYER_SKILL_INFO_14_PERMANENT_BONUS_0 = 680
    PLAYER_SKILL_INFO_14_TEMPORARY_BONUS_1 = 680
    PLAYER_SKILL_INFO_15_SKILL_0 = 681
    PLAYER_SKILL_INFO_15_SKILL_STEP_1 = 681
    PLAYER_SKILL_INFO_15_MINIMUM_0 = 682
    PLAYER_SKILL_INFO_15_MAXIMUM_1 = 682
    PLAYER_SKILL_INFO_15_PERMANENT_BONUS_0 = 683
    PLAYER_SKILL_INFO_15_TEMPORARY_BONUS_1 = 683
    PLAYER_SKILL_INFO_16_SKILL_0 = 684
    PLAYER_SKILL_INFO_16_SKILL_STEP_1 = 684
    PLAYER_SKILL_INFO_16_MINIMUM_0 = 685
    PLAYER_SKILL_INFO_16_MAXIMUM_1 = 685
    PLAYER_SKILL_INFO_16_PERMANENT_BONUS_0 = 686
    PLAYER_SKILL_INFO_16_TEMPORARY_BONUS_1 = 686
    PLAYER_SKILL_INFO_17_SKILL_0 = 687
    PLAYER_SKILL_INFO_17_SKILL_STEP_1 = 687
    PLAYER_SKILL_INFO_17_MINIMUM_0 = 688
    PLAYER_SKILL_INFO_17_MAXIMUM_1 = 688
    PLAYER_SKILL_INFO_17_PERMANENT_BONUS_0 = 689
    PLAYER_SKILL_INFO_17_TEMPORARY_BONUS_1 = 689
    PLAYER_SKILL_INFO_18_SKILL_0 = 690
    PLAYER_SKILL_INFO_18_SKILL_STEP_1 = 690
    PLAYER_SKILL_INFO_18_MINIMUM_0 = 691
    PLAYER_SKILL_INFO_18_MAXIMUM_1 = 691
    PLAYER_SKILL_INFO_18_PERMANENT_BONUS_0 = 692
    PLAYER_SKILL_INFO_18_TEMPORARY_BONUS_1 = 692
    PLAYER_SKILL_INFO_19_SKILL_0 = 693
    PLAYER_SKILL_INFO_19_SKILL_STEP_1 = 693
    PLAYER_SKILL_INFO_19_MINIMUM_0 = 694
    PLAYER_SKILL_INFO_19_MAXIMUM_1 = 694
    PLAYER_SKILL_INFO_19_PERMANENT_BONUS_0 = 695
    PLAYER_SKILL_INFO_19_TEMPORARY_BONUS_1 = 695
    PLAYER_SKILL_INFO_20_SKILL_0 = 696
    PLAYER_SKILL_INFO_20_SKILL_STEP_1 = 696
    PLAYER_SKILL_INFO_20_MINIMUM_0 = 697
    PLAYER_SKILL_INFO_20_MAXIMUM_1 = 697
    PLAYER_SKILL_INFO_20_PERMANENT_BONUS_0 = 698
    PLAYER_SKILL_INFO_20_TEMPORARY_BONUS_1 = 698
    PLAYER_SKILL_INFO_21_SKILL_0 = 699
    PLAYER_SKILL_INFO_21_SKILL_STEP_1 = 699
    PLAYER_SKILL_INFO_21_MINIMUM_0 = 700
    PLAYER_SKILL_INFO_21_MAXIMUM_1 = 700
    PLAYER_SKILL_INFO_21_PERMANENT_BONUS_0 = 701
    PLAYER_SKILL_INFO_21_TEMPORARY_BONUS_1 = 701
    PLAYER_SKILL_INFO_22_SKILL_0 = 702
    PLAYER_SKILL_INFO_22_SKILL_STEP_1 = 702
    PLAYER_SKILL_INFO_22_MINIMUM_0 = 703
    PLAYER_SKILL_INFO_22_MAXIMUM_1 = 703
    PLAYER_SKILL_INFO_22_PERMANENT_BONUS_0 = 704
    PLAYER_SKILL_INFO_22_TEMPORARY_BONUS_1 = 704
    PLAYER_SKILL_INFO_23_SKILL_0 = 705
    PLAYER_SKILL_INFO_23_SKILL_STEP_1 = 705
    PLAYER_SKILL_INFO_23_MINIMUM_0 = 706
    PLAYER_SKILL_INFO_23_MAXIMUM_1 = 706
    PLAYER_SKILL_INFO_23_PERMANENT_BONUS_0 = 707
    PLAYER_SKILL_INFO_23_TEMPORARY_BONUS_1 = 707
    PLAYER_SKILL_INFO_24_SKILL_0 = 708
    PLAYER_SKILL_INFO_24_SKILL_STEP_1 = 708
    PLAYER_SKILL_INFO_24_MINIMUM_0 = 709
    PLAYER_SKILL_INFO_24_MAXIMUM_1 = 709
    PLAYER_SKILL_INFO_24_PERMANENT_BONUS_0 = 710
    PLAYER_SKILL_INFO_24_TEMPORARY_BONUS_1 = 710
    PLAYER_SKILL_INFO_25_SKILL_0 = 711
    PLAYER_SKILL_INFO_25_SKILL_STEP_1 = 711
    PLAYER_SKILL_INFO_25_MINIMUM_0 = 712
    PLAYER_SKILL_INFO_25_MAXIMUM_1 = 712
    PLAYER_SKILL_INFO_25_PERMANENT_BONUS_0 = 713
    PLAYER_SKILL_INFO_25_TEMPORARY_BONUS_1 = 713
    PLAYER_SKILL_INFO_26_SKILL_0 = 714
    PLAYER_SKILL_INFO_26_SKILL_STEP_1 = 714
    PLAYER_SKILL_INFO_26_MINIMUM_0 = 715
    PLAYER_SKILL_INFO_26_MAXIMUM_1 = 715
    PLAYER_SKILL_INFO_26_PERMANENT_BONUS_0 = 716
    PLAYER_SKILL_INFO_26_TEMPORARY_BONUS_1 = 716
    PLAYER_SKILL_INFO_27_SKILL_0 = 717
    PLAYER_SKILL_INFO_27_SKILL_STEP_1 = 717
    PLAYER_SKILL_INFO_27_MINIMUM_0 = 718
    PLAYER_SKILL_INFO_27_MAXIMUM_1 = 718
    PLAYER_SKILL_INFO_27_PERMANENT_BONUS_0 = 719
    PLAYER_SKILL_INFO_27_TEMPORARY_BONUS_1 = 719
    PLAYER_SKILL_INFO_28_SKILL_0 = 720
    PLAYER_SKILL_INFO_28_SKILL_STEP_1 = 720
    PLAYER_SKILL_INFO_28_MINIMUM_0 = 721
    PLAYER_SKILL_INFO_28_MAXIMUM_1 = 721
    PLAYER_SKILL_INFO_28_PERMANENT_BONUS_0 = 722
    PLAYER_SKILL_INFO_28_TEMPORARY_BONUS_1 = 722
    PLAYER_SKILL_INFO_29_SKILL_0 = 723
    PLAYER_SKILL_INFO_29_SKILL_STEP_1 = 723
    PLAYER_SKILL_INFO_29_MINIMUM_0 = 724
    PLAYER_SKILL_INFO_29_MAXIMUM_1 = 724
    PLAYER_SKILL_INFO_29_PERMANENT_BONUS_0 = 725
    PLAYER_SKILL_INFO_29_TEMPORARY_BONUS_1 = 725
    PLAYER_SKILL_INFO_30_SKILL_0 = 726
    PLAYER_SKILL_INFO_30_SKILL_STEP_1 = 726
    PLAYER_SKILL_INFO_30_MINIMUM_0 = 727
    PLAYER_SKILL_INFO_30_MAXIMUM_1 = 727
    PLAYER_SKILL_INFO_30_PERMANENT_BONUS_0 = 728
    PLAYER_SKILL_INFO_30_TEMPORARY_BONUS_1 = 728
    PLAYER_SKILL_INFO_31_SKILL_0 = 729
    PLAYER_SKILL_INFO_31_SKILL_STEP_1 = 729
    PLAYER_SKILL_INFO_31_MINIMUM_0 = 730
    PLAYER_SKILL_INFO_31_MAXIMUM_1 = 730
    PLAYER_SKILL_INFO_31_PERMANENT_BONUS_0 = 731
    PLAYER_SKILL_INFO_31_TEMPORARY_BONUS_1 = 731
    PLAYER_SKILL_INFO_32_SKILL_0 = 732
    PLAYER_SKILL_INFO_32_SKILL_STEP_1 = 732
    PLAYER_SKILL_INFO_32_MINIMUM_0 = 733
    PLAYER_SKILL_INFO_32_MAXIMUM_1 = 733
    PLAYER_SKILL_INFO_32_PERMANENT_BONUS_0 = 734
    PLAYER_SKILL_INFO_32_TEMPORARY_BONUS_1 = 734
    PLAYER_SKILL_INFO_33_SKILL_0 = 735
    PLAYER_SKILL_INFO_33_SKILL_STEP_1 = 735
    PLAYER_SKILL_INFO_33_MINIMUM_0 = 736
    PLAYER_SKILL_INFO_33_MAXIMUM_1 = 736
    PLAYER_SKILL_INFO_33_PERMANENT_BONUS_0 = 737
    PLAYER_SKILL_INFO_33_TEMPORARY_BONUS_1 = 737
    PLAYER_SKILL_INFO_34_SKILL_0 = 738
    PLAYER_SKILL_INFO_34_SKILL_STEP_1 = 738
    PLAYER_SKILL_INFO_34_MINIMUM_0 = 739
    PLAYER_SKILL_INFO_34_MAXIMUM_1 = 739
    PLAYER_SKILL_INFO_34_PERMANENT_BONUS_0 = 740
    PLAYER_SKILL_INFO_34_TEMPORARY_BONUS_1 = 740
    PLAYER_SKILL_INFO_35_SKILL_0 = 741
    PLAYER_SKILL_INFO_35_SKILL_STEP_1 = 741
    PLAYER_SKILL_INFO_35_MINIMUM_0 = 742
    PLAYER_SKILL_INFO_35_MAXIMUM_1 = 742
    PLAYER_SKILL_INFO_35_PERMANENT_BONUS_0 = 743
    PLAYER_SKILL_INFO_35_TEMPORARY_BONUS_1 = 743
    PLAYER_SKILL_INFO_36_SKILL_0 = 744
    PLAYER_SKILL_INFO_36_SKILL_STEP_1 = 744
    PLAYER_SKILL_INFO_36_MINIMUM_0 = 745
    PLAYER_SKILL_INFO_36_MAXIMUM_1 = 745
    PLAYER_SKILL_INFO_36_PERMANENT_BONUS_0 = 746
    PLAYER_SKILL_INFO_36_TEMPORARY_BONUS_1 = 746
    PLAYER_SKILL_INFO_37_SKILL_0 = 747
    PLAYER_SKILL_INFO_37_SKILL_STEP_1 = 747
    PLAYER_SKILL_INFO_37_MINIMUM_0 = 748
    PLAYER_SKILL_INFO_37_MAXIMUM_1 = 748
    PLAYER_SKILL_INFO_37_PERMANENT_BONUS_0 = 749
    PLAYER_SKILL_INFO_37_TEMPORARY_BONUS_1 = 749
    PLAYER_SKILL_INFO_38_SKILL_0 = 750
    PLAYER_SKILL_INFO_38_SKILL_STEP_1 = 750
    PLAYER_SKILL_INFO_38_MINIMUM_0 = 751
    PLAYER_SKILL_INFO_38_MAXIMUM_1 = 751
    PLAYER_SKILL_INFO_38_PERMANENT_BONUS_0 = 752
    PLAYER_SKILL_INFO_38_TEMPORARY_BONUS_1 = 752
    PLAYER_SKILL_INFO_39_SKILL_0 = 753
    PLAYER_SKILL_INFO_39_SKILL_STEP_1 = 753
    PLAYER_SKILL_INFO_39_MINIMUM_0 = 754
    PLAYER_SKILL_INFO_39_MAXIMUM_1 = 754
    PLAYER_SKILL_INFO_39_PERMANENT_BONUS_0 = 755
    PLAYER_SKILL_INFO_39_TEMPORARY_BONUS_1 = 755
    PLAYER_SKILL_INFO_40_SKILL_0 = 756
    PLAYER_SKILL_INFO_40_SKILL_STEP_1 = 756
    PLAYER_SKILL_INFO_40_MINIMUM_0 = 757
    PLAYER_SKILL_INFO_40_MAXIMUM_1 = 757
    PLAYER_SKILL_INFO_40_PERMANENT_BONUS_0 = 758
    PLAYER_SKILL_INFO_40_TEMPORARY_BONUS_1 = 758
    PLAYER_SKILL_INFO_41_SKILL_0 = 759
    PLAYER_SKILL_INFO_41_SKILL_STEP_1 = 759
    PLAYER_SKILL_INFO_41_MINIMUM_0 = 760
    PLAYER_SKILL_INFO_41_MAXIMUM_1 = 760
    PLAYER_SKILL_INFO_41_PERMANENT_BONUS_0 = 761
    PLAYER_SKILL_INFO_41_TEMPORARY_BONUS_1 = 761
    PLAYER_SKILL_INFO_42_SKILL_0 = 762
    PLAYER_SKILL_INFO_42_SKILL_STEP_1 = 762
    PLAYER_SKILL_INFO_42_MINIMUM_0 = 763
    PLAYER_SKILL_INFO_42_MAXIMUM_1 = 763
    PLAYER_SKILL_INFO_42_PERMANENT_BONUS_0 = 764
    PLAYER_SKILL_INFO_42_TEMPORARY_BONUS_1 = 764
    PLAYER_SKILL_INFO_43_SKILL_0 = 765
    PLAYER_SKILL_INFO_43_SKILL_STEP_1 = 765
    PLAYER_SKILL_INFO_43_MINIMUM_0 = 766
    PLAYER_SKILL_INFO_43_MAXIMUM_1 = 766
    PLAYER_SKILL_INFO_43_PERMANENT_BONUS_0 = 767
    PLAYER_SKILL_INFO_43_TEMPORARY_BONUS_1 = 767
    PLAYER_SKILL_INFO_44_SKILL_0 = 768
    PLAYER_SKILL_INFO_44_SKILL_STEP_1 = 768
    PLAYER_SKILL_INFO_44_MINIMUM_0 = 769
    PLAYER_SKILL_INFO_44_MAXIMUM_1 = 769
    PLAYER_SKILL_INFO_44_PERMANENT_BONUS_0 = 770
    PLAYER_SKILL_INFO_44_TEMPORARY_BONUS_1 = 770
    PLAYER_SKILL_INFO_45_SKILL_0 = 771
    PLAYER_SKILL_INFO_45_SKILL_STEP_1 = 771
    PLAYER_SKILL_INFO_45_MINIMUM_0 = 772
    PLAYER_SKILL_INFO_45_MAXIMUM_1 = 772
    PLAYER_SKILL_INFO_45_PERMANENT_BONUS_0 = 773
    PLAYER_SKILL_INFO_45_TEMPORARY_BONUS_1 = 773
    PLAYER_SKILL_INFO_46_SKILL_0 = 774
    PLAYER_SKILL_INFO_46_SKILL_STEP_1 = 774
    PLAYER_SKILL_INFO_46_MINIMUM_0 = 775
    PLAYER_SKILL_INFO_46_MAXIMUM_1 = 775
    PLAYER_SKILL_INFO_46_PERMANENT_BONUS_0 = 776
    PLAYER_SKILL_INFO_46_TEMPORARY_BONUS_1 = 776
    PLAYER_SKILL_INFO_47_SKILL_0 = 777
    PLAYER_SKILL_INFO_47_SKILL_STEP_1 = 777
    PLAYER_SKILL_INFO_47_MINIMUM_0 = 778
    PLAYER_SKILL_INFO_47_MAXIMUM_1 = 778
    PLAYER_SKILL_INFO_47_PERMANENT_BONUS_0 = 779
    PLAYER_SKILL_INFO_47_TEMPORARY_BONUS_1 = 779
    PLAYER_SKILL_INFO_48_SKILL_0 = 780
    PLAYER_SKILL_INFO_48_SKILL_STEP_1 = 780
    PLAYER_SKILL_INFO_48_MINIMUM_0 = 781
    PLAYER_SKILL_INFO_48_MAXIMUM_1 = 781
    PLAYER_SKILL_INFO_48_PERMANENT_BONUS_0 = 782
    PLAYER_SKILL_INFO_48_TEMPORARY_BONUS_1 = 782
    PLAYER_SKILL_INFO_49_SKILL_0 = 783
    PLAYER_SKILL_INFO_49_SKILL_STEP_1 = 783
    PLAYER_SKILL_INFO_49_MINIMUM_0 = 784
    PLAYER_SKILL_INFO_49_MAXIMUM_1 = 784
    PLAYER_SKILL_INFO_49_PERMANENT_BONUS_0 = 785
    PLAYER_SKILL_INFO_49_TEMPORARY_BONUS_1 = 785
    PLAYER_SKILL_INFO_50_SKILL_0 = 786
    PLAYER_SKILL_INFO_50_SKILL_STEP_1 = 786
    PLAYER_SKILL_INFO_50_MINIMUM_0 = 787
    PLAYER_SKILL_INFO_50_MAXIMUM_1 = 787
    PLAYER_SKILL_INFO_50_PERMANENT_BONUS_0 = 788
    PLAYER_SKILL_INFO_50_TEMPORARY_BONUS_1 = 788
    PLAYER_SKILL_INFO_51_SKILL_0 = 789
    PLAYER_SKILL_INFO_51_SKILL_STEP_1 = 789
    PLAYER_SKILL_INFO_51_MINIMUM_0 = 790
    PLAYER_SKILL_INFO_51_MAXIMUM_1 = 790
    PLAYER_SKILL_INFO_51_PERMANENT_BONUS_0 = 791
    PLAYER_SKILL_INFO_51_TEMPORARY_BONUS_1 = 791
    PLAYER_SKILL_INFO_52_SKILL_0 = 792
    PLAYER_SKILL_INFO_52_SKILL_STEP_1 = 792
    PLAYER_SKILL_INFO_52_MINIMUM_0 = 793
    PLAYER_SKILL_INFO_52_MAXIMUM_1 = 793
    PLAYER_SKILL_INFO_52_PERMANENT_BONUS_0 = 794
    PLAYER_SKILL_INFO_52_TEMPORARY_BONUS_1 = 794
    PLAYER_SKILL_INFO_53_SKILL_0 = 795
    PLAYER_SKILL_INFO_53_SKILL_STEP_1 = 795
    PLAYER_SKILL_INFO_53_MINIMUM_0 = 796
    PLAYER_SKILL_INFO_53_MAXIMUM_1 = 796
    PLAYER_SKILL_INFO_53_PERMANENT_BONUS_0 = 797
    PLAYER_SKILL_INFO_53_TEMPORARY_BONUS_1 = 797
    PLAYER_SKILL_INFO_54_SKILL_0 = 798
    PLAYER_SKILL_INFO_54_SKILL_STEP_1 = 798
    PLAYER_SKILL_INFO_54_MINIMUM_0 = 799
    PLAYER_SKILL_INFO_54_MAXIMUM_1 = 799
    PLAYER_SKILL_INFO_54_PERMANENT_BONUS_0 = 800
    PLAYER_SKILL_INFO_54_TEMPORARY_BONUS_1 = 800
    PLAYER_SKILL_INFO_55_SKILL_0 = 801
    PLAYER_SKILL_INFO_55_SKILL_STEP_1 = 801
    PLAYER_SKILL_INFO_55_MINIMUM_0 = 802
    PLAYER_SKILL_INFO_55_MAXIMUM_1 = 802
    PLAYER_SKILL_INFO_55_PERMANENT_BONUS_0 = 803
    PLAYER_SKILL_INFO_55_TEMPORARY_BONUS_1 = 803
    PLAYER_SKILL_INFO_56_SKILL_0 = 804
    PLAYER_SKILL_INFO_56_SKILL_STEP_1 = 804
    PLAYER_SKILL_INFO_56_MINIMUM_0 = 805
    PLAYER_SKILL_INFO_56_MAXIMUM_1 = 805
    PLAYER_SKILL_INFO_56_PERMANENT_BONUS_0 = 806
    PLAYER_SKILL_INFO_56_TEMPORARY_BONUS_1 = 806
    PLAYER_SKILL_INFO_57_SKILL_0 = 807
    PLAYER_SKILL_INFO_57_SKILL_STEP_1 = 807
    PLAYER_SKILL_INFO_57_MINIMUM_0 = 808
    PLAYER_SKILL_INFO_57_MAXIMUM_1 = 808
    PLAYER_SKILL_INFO_57_PERMANENT_BONUS_0 = 809
    PLAYER_SKILL_INFO_57_TEMPORARY_BONUS_1 = 809
    PLAYER_SKILL_INFO_58_SKILL_0 = 810
    PLAYER_SKILL_INFO_58_SKILL_STEP_1 = 810
    PLAYER_SKILL_INFO_58_MINIMUM_0 = 811
    PLAYER_SKILL_INFO_58_MAXIMUM_1 = 811
    PLAYER_SKILL_INFO_58_PERMANENT_BONUS_0 = 812
    PLAYER_SKILL_INFO_58_TEMPORARY_BONUS_1 = 812
    PLAYER_SKILL_INFO_59_SKILL_0 = 813
    PLAYER_SKILL_INFO_59_SKILL_STEP_1 = 813
    PLAYER_SKILL_INFO_59_MINIMUM_0 = 814
    PLAYER_SKILL_INFO_59_MAXIMUM_1 = 814
    PLAYER_SKILL_INFO_59_PERMANENT_BONUS_0 = 815
    PLAYER_SKILL_INFO_59_TEMPORARY_BONUS_1 = 815
    PLAYER_SKILL_INFO_60_SKILL_0 = 816
    PLAYER_SKILL_INFO_60_SKILL_STEP_1 = 816
    PLAYER_SKILL_INFO_60_MINIMUM_0 = 817
    PLAYER_SKILL_INFO_60_MAXIMUM_1 = 817
    PLAYER_SKILL_INFO_60_PERMANENT_BONUS_0 = 818
    PLAYER_SKILL_INFO_60_TEMPORARY_BONUS_1 = 818
    PLAYER_SKILL_INFO_61_SKILL_0 = 819
    PLAYER_SKILL_INFO_61_SKILL_STEP_1 = 819
    PLAYER_SKILL_INFO_61_MINIMUM_0 = 820
    PLAYER_SKILL_INFO_61_MAXIMUM_1 = 820
    PLAYER_SKILL_INFO_61_PERMANENT_BONUS_0 = 821
    PLAYER_SKILL_INFO_61_TEMPORARY_BONUS_1 = 821
    PLAYER_SKILL_INFO_62_SKILL_0 = 822
    PLAYER_SKILL_INFO_62_SKILL_STEP_1 = 822
    PLAYER_SKILL_INFO_62_MINIMUM_0 = 823
    PLAYER_SKILL_INFO_62_MAXIMUM_1 = 823
    PLAYER_SKILL_INFO_62_PERMANENT_BONUS_0 = 824
    PLAYER_SKILL_INFO_62_TEMPORARY_BONUS_1 = 824
    PLAYER_SKILL_INFO_63_SKILL_0 = 825
    PLAYER_SKILL_INFO_63_SKILL_STEP_1 = 825
    PLAYER_SKILL_INFO_63_MINIMUM_0 = 826
    PLAYER_SKILL_INFO_63_MAXIMUM_1 = 826
    PLAYER_SKILL_INFO_63_PERMANENT_BONUS_0 = 827
    PLAYER_SKILL_INFO_63_TEMPORARY_BONUS_1 = 827
    PLAYER_SKILL_INFO_64_SKILL_0 = 828
    PLAYER_SKILL_INFO_64_SKILL_STEP_1 = 828
    PLAYER_SKILL_INFO_64_MINIMUM_0 = 829
    PLAYER_SKILL_INFO_64_MAXIMUM_1 = 829
    PLAYER_SKILL_INFO_64_PERMANENT_BONUS_0 = 830
    PLAYER_SKILL_INFO_64_TEMPORARY_BONUS_1 = 830
    PLAYER_SKILL_INFO_65_SKILL_0 = 831
    PLAYER_SKILL_INFO_65_SKILL_STEP_1 = 831
    PLAYER_SKILL_INFO_65_MINIMUM_0 = 832
    PLAYER_SKILL_INFO_65_MAXIMUM_1 = 832
    PLAYER_SKILL_INFO_65_PERMANENT_BONUS_0 = 833
    PLAYER_SKILL_INFO_65_TEMPORARY_BONUS_1 = 833
    PLAYER_SKILL_INFO_66_SKILL_0 = 834
    PLAYER_SKILL_INFO_66_SKILL_STEP_1 = 834
    PLAYER_SKILL_INFO_66_MINIMUM_0 = 835
    PLAYER_SKILL_INFO_66_MAXIMUM_1 = 835
    PLAYER_SKILL_INFO_66_PERMANENT_BONUS_0 = 836
    PLAYER_SKILL_INFO_66_TEMPORARY_BONUS_1 = 836
    PLAYER_SKILL_INFO_67_SKILL_0 = 837
    PLAYER_SKILL_INFO_67_SKILL_STEP_1 = 837
    PLAYER_SKILL_INFO_67_MINIMUM_0 = 838
    PLAYER_SKILL_INFO_67_MAXIMUM_1 = 838
    PLAYER_SKILL_INFO_67_PERMANENT_BONUS_0 = 839
    PLAYER_SKILL_INFO_67_TEMPORARY_BONUS_1 = 839
    PLAYER_SKILL_INFO_68_SKILL_0 = 840
    PLAYER_SKILL_INFO_68_SKILL_STEP_1 = 840
    PLAYER_SKILL_INFO_68_MINIMUM_0 = 841
    PLAYER_SKILL_INFO_68_MAXIMUM_1 = 841
    PLAYER_SKILL_INFO_68_PERMANENT_BONUS_0 = 842
    PLAYER_SKILL_INFO_68_TEMPORARY_BONUS_1 = 842
    PLAYER_SKILL_INFO_69_SKILL_0 = 843
    PLAYER_SKILL_INFO_69_SKILL_STEP_1 = 843
    PLAYER_SKILL_INFO_69_MINIMUM_0 = 844
    PLAYER_SKILL_INFO_69_MAXIMUM_1 = 844
    PLAYER_SKILL_INFO_69_PERMANENT_BONUS_0 = 845
    PLAYER_SKILL_INFO_69_TEMPORARY_BONUS_1 = 845
    PLAYER_SKILL_INFO_70_SKILL_0 = 846
    PLAYER_SKILL_INFO_70_SKILL_STEP_1 = 846
    PLAYER_SKILL_INFO_70_MINIMUM_0 = 847
    PLAYER_SKILL_INFO_70_MAXIMUM_1 = 847
    PLAYER_SKILL_INFO_70_PERMANENT_BONUS_0 = 848
    PLAYER_SKILL_INFO_70_TEMPORARY_BONUS_1 = 848
    PLAYER_SKILL_INFO_71_SKILL_0 = 849
    PLAYER_SKILL_INFO_71_SKILL_STEP_1 = 849
    PLAYER_SKILL_INFO_71_MINIMUM_0 = 850
    PLAYER_SKILL_INFO_71_MAXIMUM_1 = 850
    PLAYER_SKILL_INFO_71_PERMANENT_BONUS_0 = 851
    PLAYER_SKILL_INFO_71_TEMPORARY_BONUS_1 = 851
    PLAYER_SKILL_INFO_72_SKILL_0 = 852
    PLAYER_SKILL_INFO_72_SKILL_STEP_1 = 852
    PLAYER_SKILL_INFO_72_MINIMUM_0 = 853
    PLAYER_SKILL_INFO_72_MAXIMUM_1 = 853
    PLAYER_SKILL_INFO_72_PERMANENT_BONUS_0 = 854
    PLAYER_SKILL_INFO_72_TEMPORARY_BONUS_1 = 854
    PLAYER_SKILL_INFO_73_SKILL_0 = 855
    PLAYER_SKILL_INFO_73_SKILL_STEP_1 = 855
    PLAYER_SKILL_INFO_73_MINIMUM_0 = 856
    PLAYER_SKILL_INFO_73_MAXIMUM_1 = 856
    PLAYER_SKILL_INFO_73_PERMANENT_BONUS_0 = 857
    PLAYER_SKILL_INFO_73_TEMPORARY_BONUS_1 = 857
    PLAYER_SKILL_INFO_74_SKILL_0 = 858
    PLAYER_SKILL_INFO_74_SKILL_STEP_1 = 858
    PLAYER_SKILL_INFO_74_MINIMUM_0 = 859
    PLAYER_SKILL_INFO_74_MAXIMUM_1 = 859
    PLAYER_SKILL_INFO_74_PERMANENT_BONUS_0 = 860
    PLAYER_SKILL_INFO_74_TEMPORARY_BONUS_1 = 860
    PLAYER_SKILL_INFO_75_SKILL_0 = 861
    PLAYER_SKILL_INFO_75_SKILL_STEP_1 = 861
    PLAYER_SKILL_INFO_75_MINIMUM_0 = 862
    PLAYER_SKILL_INFO_75_MAXIMUM_1 = 862
    PLAYER_SKILL_INFO_75_PERMANENT_BONUS_0 = 863
    PLAYER_SKILL_INFO_75_TEMPORARY_BONUS_1 = 863
    PLAYER_SKILL_INFO_76_SKILL_0 = 864
    PLAYER_SKILL_INFO_76_SKILL_STEP_1 = 864
    PLAYER_SKILL_INFO_76_MINIMUM_0 = 865
    PLAYER_SKILL_INFO_76_MAXIMUM_1 = 865
    PLAYER_SKILL_INFO_76_PERMANENT_BONUS_0 = 866
    PLAYER_SKILL_INFO_76_TEMPORARY_BONUS_1 = 866
    PLAYER_SKILL_INFO_77_SKILL_0 = 867
    PLAYER_SKILL_INFO_77_SKILL_STEP_1 = 867
    PLAYER_SKILL_INFO_77_MINIMUM_0 = 868
    PLAYER_SKILL_INFO_77_MAXIMUM_1 = 868
    PLAYER_SKILL_INFO_77_PERMANENT_BONUS_0 = 869
    PLAYER_SKILL_INFO_77_TEMPORARY_BONUS_1 = 869
    PLAYER_SKILL_INFO_78_SKILL_0 = 870
    PLAYER_SKILL_INFO_78_SKILL_STEP_1 = 870
    PLAYER_SKILL_INFO_78_MINIMUM_0 = 871
    PLAYER_SKILL_INFO_78_MAXIMUM_1 = 871
    PLAYER_SKILL_INFO_78_PERMANENT_BONUS_0 = 872
    PLAYER_SKILL_INFO_78_TEMPORARY_BONUS_1 = 872
    PLAYER_SKILL_INFO_79_SKILL_0 = 873
    PLAYER_SKILL_INFO_79_SKILL_STEP_1 = 873
    PLAYER_SKILL_INFO_79_MINIMUM_0 = 874
    PLAYER_SKILL_INFO_79_MAXIMUM_1 = 874
    PLAYER_SKILL_INFO_79_PERMANENT_BONUS_0 = 875
    PLAYER_SKILL_INFO_79_TEMPORARY_BONUS_1 = 875
    PLAYER_SKILL_INFO_80_SKILL_0 = 876
    PLAYER_SKILL_INFO_80_SKILL_STEP_1 = 876
    PLAYER_SKILL_INFO_80_MINIMUM_0 = 877
    PLAYER_SKILL_INFO_80_MAXIMUM_1 = 877
    PLAYER_SKILL_INFO_80_PERMANENT_BONUS_0 = 878
    PLAYER_SKILL_INFO_80_TEMPORARY_BONUS_1 = 878
    PLAYER_SKILL_INFO_81_SKILL_0 = 879
    PLAYER_SKILL_INFO_81_SKILL_STEP_1 = 879
    PLAYER_SKILL_INFO_81_MINIMUM_0 = 880
    PLAYER_SKILL_INFO_81_MAXIMUM_1 = 880
    PLAYER_SKILL_INFO_81_PERMANENT_BONUS_0 = 881
    PLAYER_SKILL_INFO_81_TEMPORARY_BONUS_1 = 881
    PLAYER_SKILL_INFO_82_SKILL_0 = 882
    PLAYER_SKILL_INFO_82_SKILL_STEP_1 = 882
    PLAYER_SKILL_INFO_82_MINIMUM_0 = 883
    PLAYER_SKILL_INFO_82_MAXIMUM_1 = 883
    PLAYER_SKILL_INFO_82_PERMANENT_BONUS_0 = 884
    PLAYER_SKILL_INFO_82_TEMPORARY_BONUS_1 = 884
    PLAYER_SKILL_INFO_83_SKILL_0 = 885
    PLAYER_SKILL_INFO_83_SKILL_STEP_1 = 885
    PLAYER_SKILL_INFO_83_MINIMUM_0 = 886
    PLAYER_SKILL_INFO_83_MAXIMUM_1 = 886
    PLAYER_SKILL_INFO_83_PERMANENT_BONUS_0 = 887
    PLAYER_SKILL_INFO_83_TEMPORARY_BONUS_1 = 887
    PLAYER_SKILL_INFO_84_SKILL_0 = 888
    PLAYER_SKILL_INFO_84_SKILL_STEP_1 = 888
    PLAYER_SKILL_INFO_84_MINIMUM_0 = 889
    PLAYER_SKILL_INFO_84_MAXIMUM_1 = 889
    PLAYER_SKILL_INFO_84_PERMANENT_BONUS_0 = 890
    PLAYER_SKILL_INFO_84_TEMPORARY_BONUS_1 = 890
    PLAYER_SKILL_INFO_85_SKILL_0 = 891
    PLAYER_SKILL_INFO_85_SKILL_STEP_1 = 891
    PLAYER_SKILL_INFO_85_MINIMUM_0 = 892
    PLAYER_SKILL_INFO_85_MAXIMUM_1 = 892
    PLAYER_SKILL_INFO_85_PERMANENT_BONUS_0 = 893
    PLAYER_SKILL_INFO_85_TEMPORARY_BONUS_1 = 893
    PLAYER_SKILL_INFO_86_SKILL_0 = 894
    PLAYER_SKILL_INFO_86_SKILL_STEP_1 = 894
    PLAYER_SKILL_INFO_86_MINIMUM_0 = 895
    PLAYER_SKILL_INFO_86_MAXIMUM_1 = 895
    PLAYER_SKILL_INFO_86_PERMANENT_BONUS_0 = 896
    PLAYER_SKILL_INFO_86_TEMPORARY_BONUS_1 = 896
    PLAYER_SKILL_INFO_87_SKILL_0 = 897
    PLAYER_SKILL_INFO_87_SKILL_STEP_1 = 897
    PLAYER_SKILL_INFO_87_MINIMUM_0 = 898
    PLAYER_SKILL_INFO_87_MAXIMUM_1 = 898
    PLAYER_SKILL_INFO_87_PERMANENT_BONUS_0 = 899
    PLAYER_SKILL_INFO_87_TEMPORARY_BONUS_1 = 899
    PLAYER_SKILL_INFO_88_SKILL_0 = 900
    PLAYER_SKILL_INFO_88_SKILL_STEP_1 = 900
    PLAYER_SKILL_INFO_88_MINIMUM_0 = 901
    PLAYER_SKILL_INFO_88_MAXIMUM_1 = 901
    PLAYER_SKILL_INFO_88_PERMANENT_BONUS_0 = 902
    PLAYER_SKILL_INFO_88_TEMPORARY_BONUS_1 = 902
    PLAYER_SKILL_INFO_89_SKILL_0 = 903
    PLAYER_SKILL_INFO_89_SKILL_STEP_1 = 903
    PLAYER_SKILL_INFO_89_MINIMUM_0 = 904
    PLAYER_SKILL_INFO_89_MAXIMUM_1 = 904
    PLAYER_SKILL_INFO_89_PERMANENT_BONUS_0 = 905
    PLAYER_SKILL_INFO_89_TEMPORARY_BONUS_1 = 905
    PLAYER_SKILL_INFO_90_SKILL_0 = 906
    PLAYER_SKILL_INFO_90_SKILL_STEP_1 = 906
    PLAYER_SKILL_INFO_90_MINIMUM_0 = 907
    PLAYER_SKILL_INFO_90_MAXIMUM_1 = 907
    PLAYER_SKILL_INFO_90_PERMANENT_BONUS_0 = 908
    PLAYER_SKILL_INFO_90_TEMPORARY_BONUS_1 = 908
    PLAYER_SKILL_INFO_91_SKILL_0 = 909
    PLAYER_SKILL_INFO_91_SKILL_STEP_1 = 909
    PLAYER_SKILL_INFO_91_MINIMUM_0 = 910
    PLAYER_SKILL_INFO_91_MAXIMUM_1 = 910
    PLAYER_SKILL_INFO_91_PERMANENT_BONUS_0 = 911
    PLAYER_SKILL_INFO_91_TEMPORARY_BONUS_1 = 911
    PLAYER_SKILL_INFO_92_SKILL_0 = 912
    PLAYER_SKILL_INFO_92_SKILL_STEP_1 = 912
    PLAYER_SKILL_INFO_92_MINIMUM_0 = 913
    PLAYER_SKILL_INFO_92_MAXIMUM_1 = 913
    PLAYER_SKILL_INFO_92_PERMANENT_BONUS_0 = 914
    PLAYER_SKILL_INFO_92_TEMPORARY_BONUS_1 = 914
    PLAYER_SKILL_INFO_93_SKILL_0 = 915
    PLAYER_SKILL_INFO_93_SKILL_STEP_1 = 915
    PLAYER_SKILL_INFO_93_MINIMUM_0 = 916
    PLAYER_SKILL_INFO_93_MAXIMUM_1 = 916
    PLAYER_SKILL_INFO_93_PERMANENT_BONUS_0 = 917
    PLAYER_SKILL_INFO_93_TEMPORARY_BONUS_1 = 917
    PLAYER_SKILL_INFO_94_SKILL_0 = 918
    PLAYER_SKILL_INFO_94_SKILL_STEP_1 = 918
    PLAYER_SKILL_INFO_94_MINIMUM_0 = 919
    PLAYER_SKILL_INFO_94_MAXIMUM_1 = 919
    PLAYER_SKILL_INFO_94_PERMANENT_BONUS_0 = 920
    PLAYER_SKILL_INFO_94_TEMPORARY_BONUS_1 = 920
    PLAYER_SKILL_INFO_95_SKILL_0 = 921
    PLAYER_SKILL_INFO_95_SKILL_STEP_1 = 921
    PLAYER_SKILL_INFO_95_MINIMUM_0 = 922
    PLAYER_SKILL_INFO_95_MAXIMUM_1 = 922
    PLAYER_SKILL_INFO_95_PERMANENT_BONUS_0 = 923
    PLAYER_SKILL_INFO_95_TEMPORARY_BONUS_1 = 923
    PLAYER_SKILL_INFO_96_SKILL_0 = 924
    PLAYER_SKILL_INFO_96_SKILL_STEP_1 = 924
    PLAYER_SKILL_INFO_96_MINIMUM_0 = 925
    PLAYER_SKILL_INFO_96_MAXIMUM_1 = 925
    PLAYER_SKILL_INFO_96_PERMANENT_BONUS_0 = 926
    PLAYER_SKILL_INFO_96_TEMPORARY_BONUS_1 = 926
    PLAYER_SKILL_INFO_97_SKILL_0 = 927
    PLAYER_SKILL_INFO_97_SKILL_STEP_1 = 927
    PLAYER_SKILL_INFO_97_MINIMUM_0 = 928
    PLAYER_SKILL_INFO_97_MAXIMUM_1 = 928
    PLAYER_SKILL_INFO_97_PERMANENT_BONUS_0 = 929
    PLAYER_SKILL_INFO_97_TEMPORARY_BONUS_1 = 929
    PLAYER_SKILL_INFO_98_SKILL_0 = 930
    PLAYER_SKILL_INFO_98_SKILL_STEP_1 = 930
    PLAYER_SKILL_INFO_98_MINIMUM_0 = 931
    PLAYER_SKILL_INFO_98_MAXIMUM_1 = 931
    PLAYER_SKILL_INFO_98_PERMANENT_BONUS_0 = 932
    PLAYER_SKILL_INFO_98_TEMPORARY_BONUS_1 = 932
    PLAYER_SKILL_INFO_99_SKILL_0 = 933
    PLAYER_SKILL_INFO_99_SKILL_STEP_1 = 933
    PLAYER_SKILL_INFO_99_MINIMUM_0 = 934
    PLAYER_SKILL_INFO_99_MAXIMUM_1 = 934
    PLAYER_SKILL_INFO_99_PERMANENT_BONUS_0 = 935
    PLAYER_SKILL_INFO_99_TEMPORARY_BONUS_1 = 935
    PLAYER_SKILL_INFO_100_SKILL_0 = 936
    PLAYER_SKILL_INFO_100_SKILL_STEP_1 = 936
    PLAYER_SKILL_INFO_100_MINIMUM_0 = 937
    PLAYER_SKILL_INFO_100_MAXIMUM_1 = 937
    PLAYER_SKILL_INFO_100_PERMANENT_BONUS_0 = 938
    PLAYER_SKILL_INFO_100_TEMPORARY_BONUS_1 = 938
    PLAYER_SKILL_INFO_101_SKILL_0 = 939
    PLAYER_SKILL_INFO_101_SKILL_STEP_1 = 939
    PLAYER_SKILL_INFO_101_MINIMUM_0 = 940
    PLAYER_SKILL_INFO_101_MAXIMUM_1 = 940
    PLAYER_SKILL_INFO_101_PERMANENT_BONUS_0 = 941
    PLAYER_SKILL_INFO_101_TEMPORARY_BONUS_1 = 941
    PLAYER_SKILL_INFO_102_SKILL_0 = 942
    PLAYER_SKILL_INFO_102_SKILL_STEP_1 = 942
    PLAYER_SKILL_INFO_102_MINIMUM_0 = 943
    PLAYER_SKILL_INFO_102_MAXIMUM_1 = 943
    PLAYER_SKILL_INFO_102_PERMANENT_BONUS_0 = 944
    PLAYER_SKILL_INFO_102_TEMPORARY_BONUS_1 = 944
    PLAYER_SKILL_INFO_103_SKILL_0 = 945
    PLAYER_SKILL_INFO_103_SKILL_STEP_1 = 945
    PLAYER_SKILL_INFO_103_MINIMUM_0 = 946
    PLAYER_SKILL_INFO_103_MAXIMUM_1 = 946
    PLAYER_SKILL_INFO_103_PERMANENT_BONUS_0 = 947
    PLAYER_SKILL_INFO_103_TEMPORARY_BONUS_1 = 947
    PLAYER_SKILL_INFO_104_SKILL_0 = 948
    PLAYER_SKILL_INFO_104_SKILL_STEP_1 = 948
    PLAYER_SKILL_INFO_104_MINIMUM_0 = 949
    PLAYER_SKILL_INFO_104_MAXIMUM_1 = 949
    PLAYER_SKILL_INFO_104_PERMANENT_BONUS_0 = 950
    PLAYER_SKILL_INFO_104_TEMPORARY_BONUS_1 = 950
    PLAYER_SKILL_INFO_105_SKILL_0 = 951
    PLAYER_SKILL_INFO_105_SKILL_STEP_1 = 951
    PLAYER_SKILL_INFO_105_MINIMUM_0 = 952
    PLAYER_SKILL_INFO_105_MAXIMUM_1 = 952
    PLAYER_SKILL_INFO_105_PERMANENT_BONUS_0 = 953
    PLAYER_SKILL_INFO_105_TEMPORARY_BONUS_1 = 953
    PLAYER_SKILL_INFO_106_SKILL_0 = 954
    PLAYER_SKILL_INFO_106_SKILL_STEP_1 = 954
    PLAYER_SKILL_INFO_106_MINIMUM_0 = 955
    PLAYER_SKILL_INFO_106_MAXIMUM_1 = 955
    PLAYER_SKILL_INFO_106_PERMANENT_BONUS_0 = 956
    PLAYER_SKILL_INFO_106_TEMPORARY_BONUS_1 = 956
    PLAYER_SKILL_INFO_107_SKILL_0 = 957
    PLAYER_SKILL_INFO_107_SKILL_STEP_1 = 957
    PLAYER_SKILL_INFO_107_MINIMUM_0 = 958
    PLAYER_SKILL_INFO_107_MAXIMUM_1 = 958
    PLAYER_SKILL_INFO_107_PERMANENT_BONUS_0 = 959
    PLAYER_SKILL_INFO_107_TEMPORARY_BONUS_1 = 959
    PLAYER_SKILL_INFO_108_SKILL_0 = 960
    PLAYER_SKILL_INFO_108_SKILL_STEP_1 = 960
    PLAYER_SKILL_INFO_108_MINIMUM_0 = 961
    PLAYER_SKILL_INFO_108_MAXIMUM_1 = 961
    PLAYER_SKILL_INFO_108_PERMANENT_BONUS_0 = 962
    PLAYER_SKILL_INFO_108_TEMPORARY_BONUS_1 = 962
    PLAYER_SKILL_INFO_109_SKILL_0 = 963
    PLAYER_SKILL_INFO_109_SKILL_STEP_1 = 963
    PLAYER_SKILL_INFO_109_MINIMUM_0 = 964
    PLAYER_SKILL_INFO_109_MAXIMUM_1 = 964
    PLAYER_SKILL_INFO_109_PERMANENT_BONUS_0 = 965
    PLAYER_SKILL_INFO_109_TEMPORARY_BONUS_1 = 965
    PLAYER_SKILL_INFO_110_SKILL_0 = 966
    PLAYER_SKILL_INFO_110_SKILL_STEP_1 = 966
    PLAYER_SKILL_INFO_110_MINIMUM_0 = 967
    PLAYER_SKILL_INFO_110_MAXIMUM_1 = 967
    PLAYER_SKILL_INFO_110_PERMANENT_BONUS_0 = 968
    PLAYER_SKILL_INFO_110_TEMPORARY_BONUS_1 = 968
    PLAYER_SKILL_INFO_111_SKILL_0 = 969
    PLAYER_SKILL_INFO_111_SKILL_STEP_1 = 969
    PLAYER_SKILL_INFO_111_MINIMUM_0 = 970
    PLAYER_SKILL_INFO_111_MAXIMUM_1 = 970
    PLAYER_SKILL_INFO_111_PERMANENT_BONUS_0 = 971
    PLAYER_SKILL_INFO_111_TEMPORARY_BONUS_1 = 971
    PLAYER_SKILL_INFO_112_SKILL_0 = 972
    PLAYER_SKILL_INFO_112_SKILL_STEP_1 = 972
    PLAYER_SKILL_INFO_112_MINIMUM_0 = 973
    PLAYER_SKILL_INFO_112_MAXIMUM_1 = 973
    PLAYER_SKILL_INFO_112_PERMANENT_BONUS_0 = 974
    PLAYER_SKILL_INFO_112_TEMPORARY_BONUS_1 = 974
    PLAYER_SKILL_INFO_113_SKILL_0 = 975
    PLAYER_SKILL_INFO_113_SKILL_STEP_1 = 975
    PLAYER_SKILL_INFO_113_MINIMUM_0 = 976
    PLAYER_SKILL_INFO_113_MAXIMUM_1 = 976
    PLAYER_SKILL_INFO_113_PERMANENT_BONUS_0 = 977
    PLAYER_SKILL_INFO_113_TEMPORARY_BONUS_1 = 977
    PLAYER_SKILL_INFO_114_SKILL_0 = 978
    PLAYER_SKILL_INFO_114_SKILL_STEP_1 = 978
    PLAYER_SKILL_INFO_114_MINIMUM_0 = 979
    PLAYER_SKILL_INFO_114_MAXIMUM_1 = 979
    PLAYER_SKILL_INFO_114_PERMANENT_BONUS_0 = 980
    PLAYER_SKILL_INFO_114_TEMPORARY_BONUS_1 = 980
    PLAYER_SKILL_INFO_115_SKILL_0 = 981
    PLAYER_SKILL_INFO_115_SKILL_STEP_1 = 981
    PLAYER_SKILL_INFO_115_MINIMUM_0 = 982
    PLAYER_SKILL_INFO_115_MAXIMUM_1 = 982
    PLAYER_SKILL_INFO_115_PERMANENT_BONUS_0 = 983
    PLAYER_SKILL_INFO_115_TEMPORARY_BONUS_1 = 983
    PLAYER_SKILL_INFO_116_SKILL_0 = 984
    PLAYER_SKILL_INFO_116_SKILL_STEP_1 = 984
    PLAYER_SKILL_INFO_116_MINIMUM_0 = 985
    PLAYER_SKILL_INFO_116_MAXIMUM_1 = 985
    PLAYER_SKILL_INFO_116_PERMANENT_BONUS_0 = 986
    PLAYER_SKILL_INFO_116_TEMPORARY_BONUS_1 = 986
    PLAYER_SKILL_INFO_117_SKILL_0 = 987
    PLAYER_SKILL_INFO_117_SKILL_STEP_1 = 987
    PLAYER_SKILL_INFO_117_MINIMUM_0 = 988
    PLAYER_SKILL_INFO_117_MAXIMUM_1 = 988
    PLAYER_SKILL_INFO_117_PERMANENT_BONUS_0 = 989
    PLAYER_SKILL_INFO_117_TEMPORARY_BONUS_1 = 989
    PLAYER_SKILL_INFO_118_SKILL_0 = 990
    PLAYER_SKILL_INFO_118_SKILL_STEP_1 = 990
    PLAYER_SKILL_INFO_118_MINIMUM_0 = 991
    PLAYER_SKILL_INFO_118_MAXIMUM_1 = 991
    PLAYER_SKILL_INFO_118_PERMANENT_BONUS_0 = 992
    PLAYER_SKILL_INFO_118_TEMPORARY_BONUS_1 = 992
    PLAYER_SKILL_INFO_119_SKILL_0 = 993
    PLAYER_SKILL_INFO_119_SKILL_STEP_1 = 993
    PLAYER_SKILL_INFO_119_MINIMUM_0 = 994
    PLAYER_SKILL_INFO_119_MAXIMUM_1 = 994
    PLAYER_SKILL_INFO_119_PERMANENT_BONUS_0 = 995
    PLAYER_SKILL_INFO_119_TEMPORARY_BONUS_1 = 995
    PLAYER_SKILL_INFO_120_SKILL_0 = 996
    PLAYER_SKILL_INFO_120_SKILL_STEP_1 = 996
    PLAYER_SKILL_INFO_120_MINIMUM_0 = 997
    PLAYER_SKILL_INFO_120_MAXIMUM_1 = 997
    PLAYER_SKILL_INFO_120_PERMANENT_BONUS_0 = 998
    PLAYER_SKILL_INFO_120_TEMPORARY_BONUS_1 = 998
    PLAYER_SKILL_INFO_121_SKILL_0 = 999
    PLAYER_SKILL_INFO_121_SKILL_STEP_1 = 999
    PLAYER_SKILL_INFO_121_MINIMUM_0 = 1000
    PLAYER_SKILL_INFO_121_MAXIMUM_1 = 1000
    PLAYER_SKILL_INFO_121_PERMANENT_BONUS_0 = 1001
    PLAYER_SKILL_INFO_121_TEMPORARY_BONUS_1 = 1001
    PLAYER_SKILL_INFO_122_SKILL_0 = 1002
    PLAYER_SKILL_INFO_122_SKILL_STEP_1 = 1002
    PLAYER_SKILL_INFO_122_MINIMUM_0 = 1003
    PLAYER_SKILL_INFO_122_MAXIMUM_1 = 1003
    PLAYER_SKILL_INFO_122_PERMANENT_BONUS_0 = 1004
    PLAYER_SKILL_INFO_122_TEMPORARY_BONUS_1 = 1004
    PLAYER_SKILL_INFO_123_SKILL_0 = 1005
    PLAYER_SKILL_INFO_123_SKILL_STEP_1 = 1005
    PLAYER_SKILL_INFO_123_MINIMUM_0 = 1006
    PLAYER_SKILL_INFO_123_MAXIMUM_1 = 1006
    PLAYER_SKILL_INFO_123_PERMANENT_BONUS_0 = 1007
    PLAYER_SKILL_INFO_123_TEMPORARY_BONUS_1 = 1007
    PLAYER_SKILL_INFO_124_SKILL_0 = 1008
    PLAYER_SKILL_INFO_124_SKILL_STEP_1 = 1008
    PLAYER_SKILL_INFO_124_MINIMUM_0 = 1009
    PLAYER_SKILL_INFO_124_MAXIMUM_1 = 1009
    PLAYER_SKILL_INFO_124_PERMANENT_BONUS_0 = 1010
    PLAYER_SKILL_INFO_124_TEMPORARY_BONUS_1 = 1010
    PLAYER_SKILL_INFO_125_SKILL_0 = 1011
    PLAYER_SKILL_INFO_125_SKILL_STEP_1 = 1011
    PLAYER_SKILL_INFO_125_MINIMUM_0 = 1012
    PLAYER_SKILL_INFO_125_MAXIMUM_1 = 1012
    PLAYER_SKILL_INFO_125_PERMANENT_BONUS_0 = 1013
    PLAYER_SKILL_INFO_125_TEMPORARY_BONUS_1 = 1013
    PLAYER_SKILL_INFO_126_SKILL_0 = 1014
    PLAYER_SKILL_INFO_126_SKILL_STEP_1 = 1014
    PLAYER_SKILL_INFO_126_MINIMUM_0 = 1015
    PLAYER_SKILL_INFO_126_MAXIMUM_1 = 1015
    PLAYER_SKILL_INFO_126_PERMANENT_BONUS_0 = 1016
    PLAYER_SKILL_INFO_126_TEMPORARY_BONUS_1 = 1016
    PLAYER_SKILL_INFO_127_SKILL_0 = 1017
    PLAYER_SKILL_INFO_127_SKILL_STEP_1 = 1017
    PLAYER_SKILL_INFO_127_MINIMUM_0 = 1018
    PLAYER_SKILL_INFO_127_MAXIMUM_1 = 1018
    PLAYER_SKILL_INFO_127_PERMANENT_BONUS_0 = 1019
    PLAYER_SKILL_INFO_127_TEMPORARY_BONUS_1 = 1019
    PLAYER_CHARACTER_POINTS1 = 1020
    PLAYER_CHARACTER_POINTS2 = 1021
    PLAYER_TRACK_CREATURES = 1022
    PLAYER_TRACK_RESOURCES = 1023
    PLAYER_BLOCK_PERCENTAGE = 1024
    PLAYER_DODGE_PERCENTAGE = 1025
    PLAYER_PARRY_PERCENTAGE = 1026
    PLAYER_EXPERTISE = 1027
    PLAYER_OFFHAND_EXPERTISE = 1028
    PLAYER_CRIT_PERCENTAGE = 1029
    PLAYER_RANGED_CRIT_PERCENTAGE = 1030
    PLAYER_OFFHAND_CRIT_PERCENTAGE = 1031
    PLAYER_SPELL_CRIT_PERCENTAGE1 = 1032
    PLAYER_SHIELD_BLOCK = 1039
    PLAYER_SHIELD_BLOCK_CRIT_PERCENTAGE = 1040
    PLAYER_EXPLORED_ZONES_1 = 1041
    PLAYER_REST_STATE_EXPERIENCE = 1169
    PLAYER_COINAGE = 1170
    PLAYER_MOD_DAMAGE_DONE_POS = 1171
    PLAYER_MOD_DAMAGE_DONE_NEG = 1178
    PLAYER_MOD_DAMAGE_DONE_PCT = 1185
    PLAYER_MOD_HEALING_DONE_POS = 1192
    PLAYER_MOD_HEALING_PCT = 1193
    PLAYER_MOD_HEALING_DONE_PCT = 1194
    PLAYER_MOD_TARGET_RESISTANCE = 1195
    PLAYER_MOD_TARGET_PHYSICAL_RESISTANCE = 1196
    PLAYER_FEATURES = 1197
    PLAYER_AMMO_ID = 1198
    PLAYER_SELF_RES_SPELL = 1199
    PLAYER_PVP_MEDALS = 1200
    PLAYER_BUYBACK_PRICE_1 = 1201
    PLAYER_BUYBACK_TIMESTAMP_1 = 1213
    PLAYER_KILLS = 1225
    PLAYER_TODAY_CONTRIBUTION = 1226
    PLAYER_YESTERDAY_CONTRIBUTION = 1227
    PLAYER_LIFETIME_HONORBALE_KILLS = 1228
    PLAYER_BYTES2 = 1229
    PLAYER_WATCHED_FACTION_INDEX = 1230
    PLAYER_COMBAT_RATING_1 = 1231
    PLAYER_ARENA_TEAM_INFO_1_1 = 1256
    PLAYER_HONOR_CURRENCY = 1277
    PLAYER_ARENA_CURRENCY = 1278
    PLAYER_MAX_LEVEL = 1279
    PLAYER_DAILY_QUESTS_1 = 1280
    PLAYER_RUNE_REGEN_1 = 1305
    PLAYER_NO_REAGENT_COST_1 = 1309
    PLAYER_GLYPH_SLOTS_1 = 1312
    PLAYER_GLYPHS_1 = 1318
    PLAYER_GLYPHS_ENABLED = 1324
    PLAYER_PET_SPELL_POWER = 1325
    OBJECT_CREATED_BY = 6
    GAME_OBJECT_DISPLAYID = 8
    GAME_OBJECT_FLAGS = 9
    GAME_OBJECT_PARENTROTATION = 10
    GAME_OBJECT_DYNAMIC = 14
    GAME_OBJECT_FACTION = 15
    GAME_OBJECT_LEVEL = 16
    GAME_OBJECT_BYTES_1 = 17
    DYNAMIC_OBJECT_CASTER = 6
    DYNAMIC_OBJECT_BYTES = 8
    DYNAMIC_OBJECT_SPELLID = 9
    DYNAMIC_OBJECT_RADIUS = 10
    DYNAMIC_OBJECT_CASTTIME = 11
    CORPSE_OWNER = 6
    CORPSE_PARTY = 8
    CORPSE_DISPLAY_ID = 10
    CORPSE_ITEM = 11
    CORPSE_BYTES_1 = 30
    CORPSE_BYTES_2 = 31
    CORPSE_GUILD = 32
    CORPSE_FLAGS = 33
    CORPSE_DYNAMIC_FLAGS = 34


class AchievementNameLinkType(enum.Enum):
    NORMAL = 0
    CLICKABLE = 1


class ActionBarBehavior(enum.Enum):
    INITIAL = 0
    SET = 1
    CLEAR = 2


class ActivateTaxiReply(enum.Enum):
    OK = 0
    UNSPECIFIED_SERVER_ERROR = 1
    NO_SUCH_PATH = 2
    NOT_ENOUGH_MONEY = 3
    TOO_FAR_AWAY = 4
    NO_VENDOR_NEARBY = 5
    NOT_VISITED = 6
    PLAYER_BUSY = 7
    PLAYER_ALREADY_MOUNTED = 8
    PLAYER_SHAPE_SHIFTED = 9
    PLAYER_MOVING = 10
    SAME_NODE = 11
    NOT_STANDING = 12


class AiReaction(enum.Enum):
    ALERT = 0
    FRIENDLY = 1
    HOSTILE = 2
    AFRAID = 3
    DESTROY = 4


class Area(enum.Enum):
    NONE = 0
    DUN_MOROGH = 1
    LONGSHORE = 2
    BADLANDS = 3
    BLASTED_LANDS = 4
    BLACKWATER_COVE = 7
    SWAMP_OF_SORROWS = 8
    NORTHSHIRE_VALLEY = 9
    DUSKWOOD = 10
    WETLANDS = 11
    ELWYNN_FOREST = 12
    THE_WORLD_TREE = 13
    DUROTAR = 14
    DUSTWALLOW_MARSH = 15
    AZSHARA = 16
    THE_BARRENS = 17
    CRYSTAL_LAKE = 18
    ZUL_GURUB = 19
    MOONBROOK = 20
    KUL_TIRAS = 21
    PROGRAMMER_ISLE = 22
    NORTHSHIRE_RIVER = 23
    NORTHSHIRE_ABBEY = 24
    BLACKROCK_MOUNTAIN = 25
    LIGHTHOUSE = 26
    WESTERN_PLAGUELANDS = 28
    NINE = 30
    THE_CEMETARY = 32
    STRANGLETHORN_VALE = 33
    ECHO_RIDGE_MINE = 34
    BOOTY_BAY = 35
    ALTERAC_MOUNTAINS = 36
    LAKE_NAZFERITI = 37
    LOCH_MODAN = 38
    WESTFALL = 40
    DEADWIND_PASS = 41
    DARKSHIRE = 42
    WILD_SHORE = 43
    REDRIDGE_MOUNTAINS = 44
    ARATHI_HIGHLANDS = 45
    BURNING_STEPPES = 46
    THE_HINTERLANDS = 47
    DEAD_MANS_HOLE = 49
    SEARING_GORGE = 51
    THIEVES_CAMP = 53
    JASPERLODE_MINE = 54
    VALLEY_OF_HEROES_UNUSED = 55
    HEROES_VIGIL = 56
    FARGODEEP_MINE = 57
    NORTHSHIRE_VINEYARDS = 59
    FORESTS_EDGE = 60
    THUNDER_FALLS = 61
    BRACKWELL_PUMPKIN_PATCH = 62
    THE_STONEFIELD_FARM = 63
    THE_MACLURE_VINEYARDS = 64
    DRAGONBLIGHT = 65
    ZUL_DRAK = 66
    THE_STORM_PEAKS = 67
    LAKE_EVERSTILL = 68
    LAKESHIRE = 69
    STONEWATCH = 70
    STONEWATCH_FALLS = 71
    THE_DARK_PORTAL = 72
    THE_TAINTED_SCAR = 73
    POOL_OF_TEARS = 74
    STONARD = 75
    FALLOW_SANCTUARY = 76
    ANVILMAR = 77
    STORMWIND_MOUNTAINS = 80
    JEFF_NE_QUADRANT_CHANGED = 81
    JEFF_NW_QUADRANT = 82
    JEFF_SE_QUADRANT = 83
    JEFF_SW_QUADRANT = 84
    TIRISFAL_GLADES = 85
    STONE_CAIRN_LAKE = 86
    GOLDSHIRE = 87
    EASTVALE_LOGGING_CAMP = 88
    MIRROR_LAKE_ORCHARD = 89
    TOWER_OF_AZORA = 91
    MIRROR_LAKE = 92
    VUL_GOL_OGRE_MOUND = 93
    RAVEN_HILL = 94
    REDRIDGE_CANYONS = 95
    TOWER_OF_ILGALAR = 96
    ALTHERS_MILL = 97
    RETHBAN_CAVERNS = 98
    REBEL_CAMP = 99
    NESINGWARYS_EXPEDITION = 100
    KURZENS_COMPOUND = 101
    RUINS_OF_ZUL_KUNDA = 102
    RUINS_OF_ZUL_MAMWE = 103
    THE_VILE_REEF = 104
    MOSH_OGG_OGRE_MOUND = 105
    THE_STOCKPILE = 106
    SALDEANS_FARM = 107
    SENTINEL_HILL = 108
    FURLBROWS_PUMPKIN_FARM = 109
    JANGOLODE_MINE = 111
    GOLD_COAST_QUARRY = 113
    WESTFALL_LIGHTHOUSE = 115
    MISTY_VALLEY = 116
    GROM_GOL_BASE_CAMP = 117
    WHELGARS_EXCAVATION_SITE = 118
    WESTBROOK_GARRISON = 120
    TRANQUIL_GARDENS_CEMETERY = 121
    ZUULDAIA_RUINS = 122
    BAL_LAL_RUINS = 123
    KAL_AI_RUINS = 125
    TKASHI_RUINS = 126
    BALIA_MAH_RUINS = 127
    ZIATA_JAI_RUINS = 128
    MIZJAH_RUINS = 129
    SILVERPINE_FOREST = 130
    KHARANOS = 131
    COLDRIDGE_VALLEY = 132
    GNOMEREGAN = 133
    GOL_BOLAR_QUARRY = 134
    FROSTMANE_HOLD = 135
    THE_GRIZZLED_DEN = 136
    BREWNALL_VILLAGE = 137
    MISTY_PINE_REFUGE = 138
    EASTERN_PLAGUELANDS = 139
    TELDRASSIL = 141
    IRONBANDS_EXCAVATION_SITE = 142
    MO_GROSH_STRONGHOLD = 143
    THELSAMAR = 144
    ALGAZ_GATE = 145
    STONEWROUGHT_DAM = 146
    THE_FARSTRIDER_LODGE = 147
    DARKSHORE = 148
    SILVER_STREAM_MINE = 149
    MENETHIL_HARBOR = 150
    DESIGNER_ISLAND = 151
    THE_BULWARK = 152
    RUINS_OF_LORDAERON = 153
    DEATHKNELL = 154
    NIGHT_WEBS_HOLLOW = 155
    SOLLIDEN_FARMSTEAD = 156
    AGAMAND_MILLS = 157
    AGAMAND_FAMILY_CRYPT = 158
    BRILL = 159
    WHISPERING_GARDENS = 160
    TERRACE_OF_REPOSE = 161
    BRIGHTWATER_LAKE = 162
    GUNTHERS_RETREAT = 163
    GARRENS_HAUNT = 164
    BALNIR_FARMSTEAD = 165
    COLD_HEARTH_MANOR = 166
    CRUSADER_OUTPOST = 167
    THE_NORTH_COAST = 168
    WHISPERING_SHORE = 169
    LORDAMERE_LAKE = 170
    FENRIS_ISLE = 172
    FAOLS_REST = 173
    DOLANAAR = 186
    DARNASSUS_UNUSED = 187
    SHADOWGLEN = 188
    STEELGRILLS_DEPOT = 189
    HEARTHGLEN = 190
    NORTHRIDGE_LUMBER_CAMP = 192
    RUINS_OF_ANDORHAL = 193
    SCHOOL_OF_NECROMANCY = 195
    UTHERS_TOMB = 196
    SORROW_HILL = 197
    THE_WEEPING_CAVE = 198
    FELSTONE_FIELD = 199
    DALSONS_TEARS = 200
    GAHRRONS_WITHERING = 201
    THE_WRITHING_HAUNT = 202
    MARDENHOLDE_KEEP = 203
    PYREWOOD_VILLAGE = 204
    DUN_MODR = 205
    UTGARDE_KEEP = 206
    THE_GREAT_SEA = 207
    UNUSED_IRONCLADCOVE = 208
    SHADOWFANG_KEEP = 209
    ICECROWN = 210
    ICEFLOW_LAKE = 211
    HELMS_BED_LAKE = 212
    DEEP_ELEM_MINE = 213
    THE_GREAT_SEA1 = 214
    MULGORE = 215
    ALEXSTON_FARMSTEAD = 219
    RED_CLOUD_MESA = 220
    CAMP_NARACHE = 221
    BLOODHOOF_VILLAGE = 222
    STONEBULL_LAKE = 223
    RAVAGED_CARAVAN = 224
    RED_ROCKS = 225
    THE_SKITTERING_DARK = 226
    VALGANS_FIELD = 227
    THE_SEPULCHER = 228
    OLSENS_FARTHING = 229
    THE_GREYMANE_WALL = 230
    BERENS_PERIL = 231
    THE_DAWNING_ISLES = 232
    AMBERMILL = 233
    FENRIS_KEEP = 235
    SHADOWFANG_KEEP1 = 236
    THE_DECREPIT_FERRY = 237
    MALDENS_ORCHARD = 238
    THE_IVAR_PATCH = 239
    THE_DEAD_FIELD = 240
    THE_ROTTING_ORCHARD = 241
    BRIGHTWOOD_GROVE = 242
    FORLORN_ROWE = 243
    THE_WHIPPLE_ESTATE = 244
    THE_YORGEN_FARMSTEAD = 245
    THE_CAULDRON = 246
    GRIMESILT_DIG_SITE = 247
    DREADMAUL_ROCK = 249
    RUINS_OF_THAURISSAN = 250
    FLAME_CREST = 251
    BLACKROCK_STRONGHOLD = 252
    THE_PILLAR_OF_ASH = 253
    BLACKROCK_MOUNTAIN1 = 254
    ALTAR_OF_STORMS = 255
    ALDRASSIL = 256
    SHADOWTHREAD_CAVE = 257
    FEL_ROCK = 258
    LAKE_AL_AMETH = 259
    STARBREEZE_VILLAGE = 260
    GNARLPINE_HOLD = 261
    BAN_ETHIL_BARROW_DEN = 262
    THE_CLEFT = 263
    THE_ORACLE_GLADE = 264
    WELLSPRING_RIVER = 265
    WELLSPRING_LAKE = 266
    HILLSBRAD_FOOTHILLS = 267
    AZSHARA_CRATER = 268
    DUN_ALGAZ = 269
    SOUTHSHORE = 271
    TARREN_MILL = 272
    DURNHOLDE_KEEP = 275
    UNUSED_STONEWROUGHT_PASS = 276
    THE_FOOTHILL_CAVERNS = 277
    LORDAMERE_INTERNMENT_CAMP = 278
    DALARAN_CRATER = 279
    STRAHNBRAD = 280
    RUINS_OF_ALTERAC = 281
    CRUSHRIDGE_HOLD = 282
    SLAUGHTER_HOLLOW = 283
    THE_UPLANDS = 284
    SOUTHPOINT_TOWER = 285
    HILLSBRAD_FIELDS = 286
    HILLSBRAD = 287
    AZURELODE_MINE = 288
    NETHANDER_STEAD = 289
    DUN_GAROK = 290
    THORADINS_WALL = 293
    EASTERN_STRAND = 294
    WESTERN_STRAND = 295
    SOUTH_SEAS_UNUSED = 296
    JAGUERO_ISLE = 297
    BARADIN_BAY = 298
    MENETHIL_BAY = 299
    MISTY_REED_STRAND = 300
    THE_SAVAGE_COAST = 301
    THE_CRYSTAL_SHORE = 302
    SHELL_BEACH = 303
    NORTH_TIDES_RUN = 305
    SOUTH_TIDES_RUN = 306
    THE_OVERLOOK_CLIFFS = 307
    THE_FORBIDDING_SEA = 308
    IRONBEARDS_TOMB = 309
    CRYSTALVEIN_MINE = 310
    RUINS_OF_ABORAZ = 311
    JANEIROS_POINT = 312
    NORTHFOLD_MANOR = 313
    GOSHEK_FARM = 314
    DABYRIES_FARMSTEAD = 315
    BOULDERFIST_HALL = 316
    WITHERBARK_VILLAGE = 317
    DRYWHISKER_GORGE = 318
    REFUGE_POINTE = 320
    HAMMERFALL = 321
    BLACKWATER_SHIPWRECKS = 322
    O_BREENS_CAMP = 323
    STROMGARDE_KEEP = 324
    THE_TOWER_OF_ARATHOR = 325
    THE_SANCTUM = 326
    FALDIRS_COVE = 327
    THE_DROWNED_REEF = 328
    THANDOL_SPAN = 330
    ASHENVALE = 331
    THE_GREAT_SEA2 = 332
    CIRCLE_OF_EAST_BINDING = 333
    CIRCLE_OF_WEST_BINDING = 334
    CIRCLE_OF_INNER_BINDING = 335
    CIRCLE_OF_OUTER_BINDING = 336
    APOCRYPHANS_REST = 337
    ANGOR_FORTRESS = 338
    LETHLOR_RAVINE = 339
    KARGATH = 340
    CAMP_KOSH = 341
    CAMP_BOFF = 342
    CAMP_WURG = 343
    CAMP_CAGG = 344
    AGMONDS_END = 345
    HAMMERTOES_DIGSITE = 346
    DUSTBELCH_GROTTO = 347
    AERIE_PEAK = 348
    WILDHAMMER_KEEP = 349
    QUEL_DANIL_LODGE = 350
    SKULK_ROCK = 351
    ZUN_WATHA = 352
    SHADRA_ALOR = 353
    JINTHA_ALOR = 354
    THE_ALTAR_OF_ZUL = 355
    SERADANE = 356
    FERALAS = 357
    BRAMBLEBLADE_RAVINE = 358
    BAEL_MODAN = 359
    THE_VENTURE_CO_MINE = 360
    FELWOOD = 361
    RAZOR_HILL = 362
    VALLEY_OF_TRIALS = 363
    THE_DEN = 364
    BURNING_BLADE_COVEN = 365
    KOLKAR_CRAG = 366
    SEN_JIN_VILLAGE = 367
    ECHO_ISLES = 368
    THUNDER_RIDGE = 369
    DRYGULCH_RAVINE = 370
    DUSTWIND_CAVE = 371
    TIRAGARDE_KEEP = 372
    SCUTTLE_COAST = 373
    BLADEFIST_BAY = 374
    DEADEYE_SHORE = 375
    SOUTHFURY_RIVER = 377
    CAMP_TAURAJO = 378
    FAR_WATCH_POST = 379
    THE_CROSSROADS = 380
    BOULDER_LODE_MINE = 381
    THE_SLUDGE_FEN = 382
    THE_DRY_HILLS = 383
    DREADMIST_PEAK = 384
    NORTHWATCH_HOLD = 385
    THE_FORGOTTEN_POOLS = 386
    LUSHWATER_OASIS = 387
    THE_STAGNANT_OASIS = 388
    FIELD_OF_GIANTS = 390
    THE_MERCHANT_COAST = 391
    RATCHET = 392
    DARKSPEAR_STRAND = 393
    GRIZZLY_HILLS = 394
    GRIZZLEMAW = 395
    WINTERHOOF_WATER_WELL = 396
    THUNDERHORN_WATER_WELL = 397
    WILDMANE_WATER_WELL = 398
    SKYLINE_RIDGE = 399
    THOUSAND_NEEDLES = 400
    THE_TIDUS_STAIR = 401
    SHADY_REST_INN = 403
    BAEL_DUN_DIGSITE = 404
    DESOLACE = 405
    STONETALON_MOUNTAINS = 406
    ORGRIMMAR_UNUSED = 407
    GILLIJIMS_ISLE = 408
    ISLAND_OF_DOCTOR_LAPIDIS = 409
    RAZORWIND_CANYON = 410
    BATHRANS_HAUNT = 411
    THE_RUINS_OF_ORDIL_ARAN = 412
    MAESTRAS_POST = 413
    THE_ZORAM_STRAND = 414
    ASTRANAAR = 415
    THE_SHRINE_OF_AESSINA = 416
    FIRE_SCAR_SHRINE = 417
    THE_RUINS_OF_STARDUST = 418
    THE_HOWLING_VALE = 419
    SILVERWIND_REFUGE = 420
    MYSTRAL_LAKE = 421
    FALLEN_SKY_LAKE = 422
    IRIS_LAKE = 424
    MOONWELL = 425
    RAYNEWOOD_RETREAT = 426
    THE_SHADY_NOOK = 427
    NIGHT_RUN = 428
    XAVIAN = 429
    SATYRNAAR = 430
    SPLINTERTREE_POST = 431
    THE_DOR_DANIL_BARROW_DEN = 432
    FALFARREN_RIVER = 433
    FELFIRE_HILL = 434
    DEMON_FALL_CANYON = 435
    DEMON_FALL_RIDGE = 436
    WARSONG_LUMBER_CAMP = 437
    BOUGH_SHADOW = 438
    THE_SHIMMERING_FLATS = 439
    TANARIS = 440
    LAKE_FALATHIM = 441
    AUBERDINE = 442
    RUINS_OF_MATHYSTRA = 443
    TOWER_OF_ALTHALAXX = 444
    CLIFFSPRING_FALLS = 445
    BASHAL_ARAN = 446
    AMETH_ARAN = 447
    GROVE_OF_THE_ANCIENTS = 448
    THE_MASTERS_GLAIVE = 449
    REMTRAVELS_EXCAVATION = 450
    MISTS_EDGE = 452
    THE_LONG_WASH = 453
    WILDBEND_RIVER = 454
    BLACKWOOD_DEN = 455
    CLIFFSPRING_RIVER = 456
    THE_VEILED_SEA = 457
    GOLD_ROAD = 458
    SCARLET_WATCH_POST = 459
    SUN_ROCK_RETREAT = 460
    WINDSHEAR_CRAG = 461
    CRAGPOOL_LAKE = 463
    MIRKFALLON_LAKE = 464
    THE_CHARRED_VALE = 465
    VALLEY_OF_THE_BLOODFURIES = 466
    STONETALON_PEAK = 467
    THE_TALON_DEN = 468
    GREATWOOD_VALE = 469
    THUNDER_BLUFF_UNUSED = 470
    BRAVE_WIND_MESA = 471
    FIRE_STONE_MESA = 472
    MANTLE_ROCK = 473
    HUNTER_RISE_UNUSED = 474
    SPIRIT_RISEUNUSED = 475
    ELDER_RISEUNUSED = 476
    RUINS_OF_JUBUWAL = 477
    POOLS_OF_ARLITHRIEN = 478
    THE_RUSTMAUL_DIG_SITE = 479
    CAMP_E_THOK = 480
    SPLITHOOF_CRAG = 481
    HIGHPERCH = 482
    THE_SCREECHING_CANYON = 483
    FREEWIND_POST = 484
    THE_GREAT_LIFT = 485
    GALAK_HOLD = 486
    ROGUEFEATHER_DEN = 487
    THE_WEATHERED_NOOK = 488
    THALANAAR = 489
    UN_GORO_CRATER = 490
    RAZORFEN_KRAUL = 491
    RAVEN_HILL_CEMETERY = 492
    MOONGLADE = 493
    HOWLING_FJORD = 495
    BRACKENWALL_VILLAGE = 496
    SWAMPLIGHT_MANOR = 497
    BLOODFEN_BURROW = 498
    DARKMIST_CAVERN = 499
    MOGGLE_POINT = 500
    BEEZILS_WRECK = 501
    WITCH_HILL = 502
    SENTRY_POINT = 503
    NORTH_POINT_TOWER = 504
    WEST_POINT_TOWER = 505
    LOST_POINT = 506
    BLUEFEN = 507
    STONEMAUL_RUINS = 508
    THE_DEN_OF_FLAME = 509
    THE_DRAGONMURK = 510
    WYRMBOG = 511
    BLACKHOOF_VILLAGE = 512
    THERAMORE_ISLE = 513
    FOOTHOLD_CITADEL = 514
    IRONCLAD_PRISON = 515
    DUSTWALLOW_BAY = 516
    TIDEFURY_COVE = 517
    DREADMURK_SHORE = 518
    ADDLES_STEAD = 536
    FIRE_PLUME_RIDGE = 537
    LAKKARI_TAR_PITS = 538
    TERROR_RUN = 539
    THE_SLITHERING_SCAR = 540
    MARSHALS_REFUGE = 541
    FUNGAL_ROCK = 542
    GOLAKKA_HOT_SPRINGS = 543
    THE_LOCH = 556
    BEGGARS_HAUNT = 576
    KODO_GRAVEYARD = 596
    GHOST_WALKER_POST = 597
    SAR_THERIS_STRAND = 598
    THUNDER_AXE_FORTRESS = 599
    BOLGANS_HOLE = 600
    MANNOROC_COVEN = 602
    SARGERON = 603
    MAGRAM_VILLAGE = 604
    GELKIS_VILLAGE = 606
    VALLEY_OF_SPEARS = 607
    NIJELS_POINT = 608
    KOLKAR_VILLAGE = 609
    HYJAL = 616
    WINTERSPRING = 618
    BLACKWOLF_RIVER = 636
    KODO_ROCK = 637
    HIDDEN_PATH = 638
    SPIRIT_ROCK = 639
    SHRINE_OF_THE_DORMANT_FLAME = 640
    LAKE_ELUNE_ARA = 656
    THE_HARBORAGE = 657
    OUTLAND = 676
    CRAFTSMENS_TERRACE_UNUSED = 696
    TRADESMENS_TERRACE_UNUSED = 697
    THE_TEMPLE_GARDENS_UNUSED = 698
    TEMPLE_OF_ELUNE_UNUSED = 699
    CENARION_ENCLAVE_UNUSED = 700
    WARRIORS_TERRACE_UNUSED = 701
    RUT_THERAN_VILLAGE = 702
    IRONBANDS_COMPOUND = 716
    THE_STOCKADE = 717
    WAILING_CAVERNS = 718
    BLACKFATHOM_DEEPS = 719
    FRAY_ISLAND = 720
    GNOMEREGAN1 = 721
    RAZORFEN_DOWNS = 722
    BAN_ETHIL_HOLLOW = 736
    SCARLET_MONASTERY = 796
    JERODS_LANDING = 797
    RIDGEPOINT_TOWER = 798
    THE_DARKENED_BANK = 799
    COLDRIDGE_PASS = 800
    CHILL_BREEZE_VALLEY = 801
    SHIMMER_RIDGE = 802
    AMBERSTILL_RANCH = 803
    THE_TUNDRID_HILLS = 804
    SOUTH_GATE_PASS = 805
    SOUTH_GATE_OUTPOST = 806
    NORTH_GATE_PASS = 807
    NORTH_GATE_OUTPOST = 808
    GATES_OF_IRONFORGE = 809
    STILLWATER_POND = 810
    NIGHTMARE_VALE = 811
    VENOMWEB_VALE = 812
    THE_BULWARK1 = 813
    SOUTHFURY_RIVER1 = 814
    SOUTHFURY_RIVER2 = 815
    RAZORMANE_GROUNDS = 816
    SKULL_ROCK = 817
    PALEMANE_ROCK = 818
    WINDFURY_RIDGE = 819
    THE_GOLDEN_PLAINS = 820
    THE_ROLLING_PLAINS = 821
    DUN_ALGAZ1 = 836
    DUN_ALGAZ2 = 837
    NORTH_GATE_PASS1 = 838
    SOUTH_GATE_PASS1 = 839
    TWILIGHT_GROVE = 856
    GM_ISLAND = 876
    DELETE_ME = 877
    SOUTHFURY_RIVER3 = 878
    SOUTHFURY_RIVER4 = 879
    THANDOL_SPAN1 = 880
    THANDOL_SPAN2 = 881
    PURGATION_ISLE = 896
    THE_JANSEN_STEAD = 916
    THE_DEAD_ACRE = 917
    THE_MOLSEN_FARM = 918
    STENDELS_POND = 919
    THE_DAGGER_HILLS = 920
    DEMONTS_PLACE = 921
    THE_DUST_PLAINS = 922
    STONESPLINTER_VALLEY = 923
    VALLEY_OF_KINGS = 924
    ALGAZ_STATION = 925
    BUCKLEBREE_FARM = 926
    THE_SHINING_STRAND = 927
    NORTH_TIDES_HOLLOW = 928
    GRIZZLEPAW_RIDGE = 936
    THE_VERDANT_FIELDS = 956
    GADGETZAN = 976
    STEAMWHEEDLE_PORT = 977
    ZUL_FARRAK = 978
    SANDSORROW_WATCH = 979
    THISTLESHRUB_VALLEY = 980
    THE_GAPING_CHASM = 981
    THE_NOXIOUS_LAIR = 982
    DUNEMAUL_COMPOUND = 983
    EASTMOON_RUINS = 984
    WATERSPRING_FIELD = 985
    ZALASHJIS_DEN = 986
    LANDS_END_BEACH = 987
    WAVESTRIDER_BEACH = 988
    ULDUM = 989
    VALLEY_OF_THE_WATCHERS = 990
    GUNSTANS_POST = 991
    SOUTHMOON_RUINS = 992
    RENDERS_CAMP = 996
    RENDERS_VALLEY = 997
    RENDERS_ROCK = 998
    STONEWATCH_TOWER = 999
    GALARDELL_VALLEY = 1000
    LAKERIDGE_HIGHWAY = 1001
    THREE_CORNERS = 1002
    DIREFORGE_HILL = 1016
    RAPTOR_RIDGE = 1017
    BLACK_CHANNEL_MARSH = 1018
    THE_GREEN_BELT = 1019
    MOSSHIDE_FEN = 1020
    THELGEN_ROCK = 1021
    BLUEGILL_MARSH = 1022
    SALTSPRAY_GLEN = 1023
    SUNDOWN_MARSH = 1024
    THE_GREEN_BELT1 = 1025
    ANGERFANG_ENCAMPMENT = 1036
    GRIM_BATOL = 1037
    DRAGONMAW_GATES = 1038
    THE_LOST_FLEET = 1039
    DARROW_HILL = 1056
    THORADINS_WALL1 = 1057
    WEBWINDER_PATH = 1076
    THE_HUSHED_BANK = 1097
    MANOR_MISTMANTLE = 1098
    CAMP_MOJACHE = 1099
    GRIMTOTEM_COMPOUND = 1100
    THE_WRITHING_DEEP = 1101
    WILDWIND_LAKE = 1102
    GORDUNNI_OUTPOST = 1103
    MOK_GORDUN = 1104
    FERAL_SCAR_VALE = 1105
    FRAYFEATHER_HIGHLANDS = 1106
    IDLEWIND_LAKE = 1107
    THE_FORGOTTEN_COAST = 1108
    EAST_PILLAR = 1109
    WEST_PILLAR = 1110
    DREAM_BOUGH = 1111
    JADEMIR_LAKE = 1112
    ONEIROS = 1113
    RUINS_OF_RAVENWIND = 1114
    RAGE_SCAR_HOLD = 1115
    FEATHERMOON_STRONGHOLD = 1116
    RUINS_OF_SOLARSAL = 1117
    LOWER_WILDS_UNUSED = 1118
    THE_TWIN_COLOSSALS = 1119
    SARDOR_ISLE = 1120
    ISLE_OF_DREAD = 1121
    HIGH_WILDERNESS = 1136
    LOWER_WILDS = 1137
    SOUTHERN_BARRENS = 1156
    SOUTHERN_GOLD_ROAD = 1157
    ZUL_FARRAK1 = 1176
    UTGARDE_PINNACLE = 1196
    TIMBERMAW_HOLD = 1216
    VANNDIR_ENCAMPMENT = 1217
    TESTAZSHARA = 1218
    LEGASH_ENCAMPMENT = 1219
    THALASSIAN_BASE_CAMP = 1220
    RUINS_OF_ELDARATH = 1221
    HETAERAS_CLUTCH = 1222
    TEMPLE_OF_ZIN_MALOR = 1223
    BEARS_HEAD = 1224
    URSOLAN = 1225
    TEMPLE_OF_ARKKORAN = 1226
    BAY_OF_STORMS = 1227
    THE_SHATTERED_STRAND = 1228
    TOWER_OF_ELDARA = 1229
    JAGGED_REEF = 1230
    SOUTHRIDGE_BEACH = 1231
    RAVENCREST_MONUMENT = 1232
    FORLORN_RIDGE = 1233
    LAKE_MENNAR = 1234
    SHADOWSONG_SHRINE = 1235
    HALDARR_ENCAMPMENT = 1236
    VALORMOK = 1237
    THE_RUINED_REACHES = 1256
    THE_TALONDEEP_PATH = 1276
    THE_TALONDEEP_PATH1 = 1277
    ROCKTUSK_FARM = 1296
    JAGGEDSWINE_FARM = 1297
    RAZORFEN_DOWNS1 = 1316
    LOST_RIGGER_COVE = 1336
    ULDAMAN = 1337
    LORDAMERE_LAKE1 = 1338
    LORDAMERE_LAKE2 = 1339
    GALLOWS_CORNER = 1357
    SILITHUS = 1377
    EMERALD_FOREST = 1397
    SUNKEN_TEMPLE = 1417
    DREADMAUL_HOLD = 1437
    NETHERGARDE_KEEP = 1438
    DREADMAUL_POST = 1439
    SERPENTS_COIL = 1440
    ALTAR_OF_STORMS1 = 1441
    FIREWATCH_RIDGE = 1442
    THE_SLAG_PIT = 1443
    THE_SEA_OF_CINDERS = 1444
    BLACKROCK_MOUNTAIN2 = 1445
    THORIUM_POINT = 1446
    GARRISON_ARMORY = 1457
    THE_TEMPLE_OF_ATAL_HAKKAR = 1477
    UNDERCITY = 1497
    ULDAMAN1 = 1517
    NOT_USED_DEADMINES = 1518
    STORMWIND_CITY = 1519
    IRONFORGE = 1537
    SPLITHOOF_HOLD = 1557
    THE_CAPE_OF_STRANGLETHORN = 1577
    SOUTHERN_SAVAGE_COAST = 1578
    UNUSED_THE_DEADMINES_002 = 1579
    UNUSED_IRONCLAD_COVE_003 = 1580
    THE_DEADMINES = 1581
    IRONCLAD_COVE = 1582
    BLACKROCK_SPIRE = 1583
    BLACKROCK_DEPTHS = 1584
    RAPTOR_GROUNDS_UNUSED = 1597
    GROL_DOM_FARM_UNUSED = 1598
    MORSHAN_BASE_CAMP = 1599
    HONORS_STAND_UNUSED = 1600
    BLACKTHORN_RIDGE_UNUSED = 1601
    BRAMBLESCAR_UNUSED = 1602
    AGAMA_GOR_UNUSED = 1603
    VALLEY_OF_HEROES = 1617
    ORGRIMMAR = 1637
    THUNDER_BLUFF = 1638
    ELDER_RISE = 1639
    SPIRIT_RISE = 1640
    HUNTER_RISE = 1641
    DARNASSUS = 1657
    CENARION_ENCLAVE = 1658
    CRAFTSMENS_TERRACE = 1659
    WARRIORS_TERRACE = 1660
    THE_TEMPLE_GARDENS = 1661
    TRADESMENS_TERRACE = 1662
    GAVINS_NAZE = 1677
    SOFERAS_NAZE = 1678
    CORRAHNS_DAGGER = 1679
    THE_HEADLAND = 1680
    MISTY_SHORE = 1681
    DANDREDS_FOLD = 1682
    GROWLESS_CAVE = 1683
    CHILLWIND_POINT = 1684
    RAPTOR_GROUNDS = 1697
    BRAMBLESCAR = 1698
    THORN_HILL = 1699
    AGAMA_GOR = 1700
    BLACKTHORN_RIDGE = 1701
    HONORS_STAND = 1702
    THE_MORSHAN_RAMPART = 1703
    GROL_DOM_FARM = 1704
    RAZORFEN_KRAUL1 = 1717
    THE_GREAT_LIFT1 = 1718
    MISTVALE_VALLEY = 1737
    NEK_MANI_WELLSPRING = 1738
    BLOODSAIL_COMPOUND = 1739
    VENTURE_CO_BASE_CAMP = 1740
    GURUBASHI_ARENA = 1741
    SPIRIT_DEN = 1742
    THE_CRIMSON_VEIL = 1757
    THE_RIPTIDE = 1758
    THE_DAMSELS_LUCK = 1759
    VENTURE_CO_OPERATIONS_CENTER = 1760
    DEADWOOD_VILLAGE = 1761
    FELPAW_VILLAGE = 1762
    JAEDENAR = 1763
    BLOODVENOM_RIVER = 1764
    BLOODVENOM_FALLS = 1765
    SHATTER_SCAR_VALE = 1766
    IRONTREE_WOODS = 1767
    IRONTREE_CAVERN = 1768
    TIMBERMAW_HOLD1 = 1769
    SHADOW_HOLD = 1770
    SHRINE_OF_THE_DECEIVER = 1771
    ITHARIUSS_CAVE = 1777
    SORROWMURK = 1778
    DRAENIL_DUR_VILLAGE = 1779
    SPLINTERSPEAR_JUNCTION = 1780
    STAGALBOG = 1797
    THE_SHIFTING_MIRE = 1798
    STAGALBOG_CAVE = 1817
    WITHERBARK_CAVERNS = 1837
    THORADINS_WALL2 = 1857
    BOULDER_GOR = 1858
    VALLEY_OF_FANGS = 1877
    THE_DUSTBOWL = 1878
    MIRAGE_FLATS = 1879
    FEATHERBEARDS_HOVEL = 1880
    SHINDIGGERS_CAMP = 1881
    PLAGUEMIST_RAVINE = 1882
    VALORWIND_LAKE = 1883
    AGOL_WATHA = 1884
    HIRI_WATHA = 1885
    THE_CREEPING_RUIN = 1886
    BOGENS_LEDGE = 1887
    THE_MAKERS_TERRACE = 1897
    DUSTWIND_GULCH = 1898
    SHAOL_WATHA = 1917
    NOONSHADE_RUINS = 1937
    BROKEN_PILLAR = 1938
    ABYSSAL_SANDS = 1939
    SOUTHBREAK_SHORE = 1940
    CAVERNS_OF_TIME = 1941
    THE_MARSHLANDS = 1942
    IRONSTONE_PLATEAU = 1943
    BLACKCHAR_CAVE = 1957
    TANNER_CAMP = 1958
    DUSTFIRE_VALLEY = 1959
    ZUL_GURUB1 = 1977
    MISTY_REED_POST = 1978
    BLOODVENOM_POST = 1997
    TALONBRANCH_GLADE_ = 1998
    STRATHOLME = 2017
    QUEL_THALAS = 2037
    SCHOLOMANCE = 2057
    TWILIGHT_VALE = 2077
    TWILIGHT_SHORE = 2078
    ALCAZ_ISLAND = 2079
    DARKCLOUD_PINNACLE = 2097
    DAWNING_WOOD_CATACOMBS = 2098
    STONEWATCH_KEEP = 2099
    MARAUDON = 2100
    STOUTLAGER_INN = 2101
    THUNDERBREW_DISTILLERY = 2102
    MENETHIL_KEEP = 2103
    DEEPWATER_TAVERN = 2104
    SHADOW_GRAVE = 2117
    BRILL_TOWN_HALL = 2118
    GALLOWS_END_TAVERN = 2119
    THE_POOLS_OF_VISIONUNUSED = 2137
    DREADMIST_DEN = 2138
    BAEL_DUN_KEEP = 2157
    EMBERSTRIFES_DEN = 2158
    ONYXIAS_LAIR = 2159
    WINDSHEAR_MINE = 2160
    ROLANDS_DOOM = 2161
    BATTLE_RING = 2177
    THE_POOLS_OF_VISION = 2197
    SHADOWBREAK_RAVINE = 2198
    BROKEN_SPEAR_VILLAGE = 2217
    WHITEREACH_POST = 2237
    GORNIA = 2238
    ZANES_EYE_CRATER = 2239
    MIRAGE_RACEWAY = 2240
    FROSTSABER_ROCK = 2241
    THE_HIDDEN_GROVE = 2242
    TIMBERMAW_POST = 2243
    WINTERFALL_VILLAGE = 2244
    MAZTHORIL = 2245
    FROSTFIRE_HOT_SPRINGS = 2246
    ICE_THISTLE_HILLS = 2247
    DUN_MANDARR = 2248
    FROSTWHISPER_GORGE = 2249
    OWL_WING_THICKET = 2250
    LAKE_KEL_THERIL = 2251
    THE_RUINS_OF_KEL_THERIL = 2252
    STARFALL_VILLAGE = 2253
    BAN_THALLOW_BARROW_DEN = 2254
    EVERLOOK = 2255
    DARKWHISPER_GORGE = 2256
    DEEPRUN_TRAM = 2257
    THE_FUNGAL_VALE = 2258
    UNUSEDTHE_MARRIS_STEAD = 2259
    THE_MARRIS_STEAD = 2260
    THE_UNDERCROFT = 2261
    DARROWSHIRE = 2262
    CROWN_GUARD_TOWER = 2263
    CORINS_CROSSING = 2264
    SCARLET_BASE_CAMP = 2265
    TYRS_HAND = 2266
    THE_SCARLET_BASILICA = 2267
    LIGHTS_HOPE_CHAPEL = 2268
    BROWMAN_MILL = 2269
    THE_NOXIOUS_GLADE = 2270
    EASTWALL_TOWER = 2271
    NORTHDALE = 2272
    ZUL_MASHAR = 2273
    MAZRA_ALOR = 2274
    NORTHPASS_TOWER = 2275
    QUEL_LITHIEN_LODGE = 2276
    PLAGUEWOOD = 2277
    SCOURGEHOLD = 2278
    STRATHOLME1 = 2279
    DO_NOT_USE = 2280
    DARROWMERE_LAKE = 2297
    CAER_DARROW = 2298
    DARROWMERE_LAKE1 = 2299
    CAVERNS_OF_TIME1 = 2300
    THISTLEFUR_VILLAGE = 2301
    THE_QUAGMIRE = 2302
    WINDBREAK_CANYON = 2303
    SOUTH_SEAS = 2317
    THE_GREAT_SEA3 = 2318
    THE_GREAT_SEA4 = 2319
    THE_GREAT_SEA5 = 2320
    THE_GREAT_SEA6 = 2321
    THE_VEILED_SEA1 = 2322
    THE_VEILED_SEA2 = 2323
    THE_VEILED_SEA3 = 2324
    THE_VEILED_SEA4 = 2325
    THE_VEILED_SEA5 = 2326
    RAZOR_HILL_BARRACKS = 2337
    SOUTH_SEAS1 = 2338
    THE_GREAT_SEA7 = 2339
    BLOODTOOTH_CAMP = 2357
    FOREST_SONG = 2358
    GREENPAW_VILLAGE = 2359
    SILVERWING_OUTPOST = 2360
    NIGHTHAVEN = 2361
    SHRINE_OF_REMULOS = 2362
    STORMRAGE_BARROW_DENS = 2363
    THE_GREAT_SEA8 = 2364
    THE_GREAT_SEA9 = 2365
    THE_BLACK_MORASS = 2366
    OLD_HILLSBRAD_FOOTHILLS = 2367
    TARREN_MILL1 = 2368
    SOUTHSHORE1 = 2369
    DURNHOLDE_KEEP1 = 2370
    DUN_GAROK1 = 2371
    HILLSBRAD_FIELDS1 = 2372
    EASTERN_STRAND1 = 2373
    NETHANDER_STEAD1 = 2374
    DARROW_HILL1 = 2375
    SOUTHPOINT_TOWER1 = 2376
    THORADINS_WALL3 = 2377
    WESTERN_STRAND1 = 2378
    AZURELODE_MINE1 = 2379
    THE_GREAT_SEA10 = 2397
    THE_GREAT_SEA11 = 2398
    THE_GREAT_SEA12 = 2399
    THE_FORBIDDING_SEA1 = 2400
    THE_FORBIDDING_SEA2 = 2401
    THE_FORBIDDING_SEA3 = 2402
    THE_FORBIDDING_SEA4 = 2403
    TETHRIS_ARAN = 2404
    ETHEL_RETHOR = 2405
    RANAZJAR_ISLE = 2406
    KORMEKS_HUT = 2407
    SHADOWPREY_VILLAGE = 2408
    BLACKROCK_PASS = 2417
    MORGANS_VIGIL = 2418
    SLITHER_ROCK = 2419
    TERROR_WING_PATH = 2420
    DRACO_DAR = 2421
    RAGEFIRE_CHASM = 2437
    NIGHTSONG_WOODS = 2457
    THE_VEILED_SEA6 = 2477
    MORLOS_ARAN = 2478
    EMERALD_SANCTUARY = 2479
    JADEFIRE_GLEN = 2480
    RUINS_OF_CONSTELLAS = 2481
    BITTER_REACHES = 2497
    RISE_OF_THE_DEFILER = 2517
    LARISS_PAVILION = 2518
    WOODPAW_HILLS = 2519
    WOODPAW_DEN = 2520
    VERDANTIS_RIVER = 2521
    RUINS_OF_ISILDIEN = 2522
    GRIMTOTEM_POST = 2537
    CAMP_APARAJE = 2538
    MALAKA_JIN = 2539
    BOULDERSLIDE_RAVINE = 2540
    SISHIR_CANYON = 2541
    DIRE_MAUL = 2557
    DEADWIND_RAVINE = 2558
    DIAMONDHEAD_RIVER = 2559
    ARIDENS_CAMP = 2560
    THE_VICE = 2561
    KARAZHAN = 2562
    MORGANS_PLOT = 2563
    DIRE_MAUL1 = 2577
    ALTERAC_VALLEY = 2597
    SCRABBLESCREWS_CAMP = 2617
    JADEFIRE_RUN = 2618
    THONDRORIL_RIVER = 2619
    THONDRORIL_RIVER1 = 2620
    LAKE_MERELDAR = 2621
    PESTILENT_SCAR = 2622
    THE_INFECTIS_SCAR = 2623
    BLACKWOOD_LAKE = 2624
    EASTWALL_GATE = 2625
    TERRORWEB_TUNNEL = 2626
    TERRORDALE = 2627
    KARGATHIA_KEEP = 2637
    VALLEY_OF_BONES = 2657
    BLACKWING_LAIR = 2677
    DEADMANS_CROSSING = 2697
    MOLTEN_CORE = 2717
    THE_SCARAB_WALL = 2737
    SOUTHWIND_VILLAGE = 2738
    TWILIGHT_BASE_CAMP = 2739
    THE_CRYSTAL_VALE = 2740
    THE_SCARAB_DAIS = 2741
    HIVE_ASHI = 2742
    HIVE_ZORA = 2743
    HIVE_REGAL = 2744
    SHRINE_OF_THE_FALLEN_WARRIOR = 2757
    UNUSED_ALTERAC_VALLEY = 2777
    BLACKFATHOM_DEEPS1 = 2797
    CRYSTALSONG_FOREST = 2817
    THE_MASTERS_CELLAR = 2837
    STONEWROUGHT_PASS = 2838
    ALTERAC_VALLEY1 = 2839
    THE_RUMBLE_CAGE = 2857
    CHUNK_TEST = 2877
    ZORAM_GAR_OUTPOST = 2897
    HALL_OF_LEGENDS = 2917
    CHAMPIONS_HALL = 2918
    GROSH_GOK_COMPOUND = 2937
    SLEEPING_GORGE = 2938
    IRONDEEP_MINE = 2957
    STONEHEARTH_OUTPOST = 2958
    DUN_BALDAR = 2959
    ICEWING_PASS = 2960
    FROSTWOLF_VILLAGE = 2961
    TOWER_POINT = 2962
    COLDTOOTH_MINE = 2963
    WINTERAX_HOLD = 2964
    ICEBLOOD_GARRISON = 2977
    FROSTWOLF_KEEP = 2978
    TOR_KREN_FARM = 2979
    FROST_DAGGER_PASS = 3017
    IRONSTONE_CAMP = 3037
    WEAZELS_CRATER = 3038
    TAHONDA_RUINS = 3039
    FIELD_OF_STRIFE = 3057
    ICEWING_CAVERN = 3058
    VALORS_REST = 3077
    THE_SWARMING_PILLAR = 3097
    TWILIGHT_POST = 3098
    TWILIGHT_OUTPOST = 3099
    RAVAGED_TWILIGHT_CAMP = 3100
    SHALZARUS_LAIR = 3117
    TALRENDIS_POINT = 3137
    RETHRESS_SANCTUM = 3138
    MOON_HORROR_DEN = 3139
    SCALEBEARDS_CAVE = 3140
    BOULDERSLIDE_CAVERN = 3157
    WARSONG_LABOR_CAMP = 3177
    CHILLWIND_CAMP = 3197
    THE_MAUL = 3217
    THE_MAUL_UNUSED = 3237
    BONES_OF_GRAKKAROND = 3257
    WARSONG_GULCH = 3277
    FROSTWOLF_GRAVEYARD = 3297
    FROSTWOLF_PASS = 3298
    DUN_BALDAR_PASS = 3299
    ICEBLOOD_GRAVEYARD = 3300
    SNOWFALL_GRAVEYARD = 3301
    STONEHEARTH_GRAVEYARD = 3302
    STORMPIKE_GRAVEYARD = 3303
    ICEWING_BUNKER = 3304
    STONEHEARTH_BUNKER = 3305
    WILDPAW_RIDGE = 3306
    REVANTUSK_VILLAGE = 3317
    ROCK_OF_DUROTAN = 3318
    SILVERWING_GROVE = 3319
    WARSONG_LUMBER_MILL = 3320
    SILVERWING_HOLD = 3321
    WILDPAW_CAVERN = 3337
    THE_VEILED_CLEFT = 3338
    YOJAMBA_ISLE = 3357
    ARATHI_BASIN = 3358
    THE_COIL = 3377
    ALTAR_OF_HIR_EEK = 3378
    SHADRA_ZAAR = 3379
    HAKKARI_GROUNDS = 3380
    NAZE_OF_SHIRVALLAH = 3381
    TEMPLE_OF_BETHEKK = 3382
    THE_BLOODFIRE_PIT = 3383
    ALTAR_OF_THE_BLOOD_GOD = 3384
    ZANZAS_RISE = 3397
    EDGE_OF_MADNESS = 3398
    TROLLBANE_HALL = 3417
    DEFILERS_DEN = 3418
    PAGLES_POINTE = 3419
    FARM = 3420
    BLACKSMITH = 3421
    LUMBER_MILL = 3422
    GOLD_MINE = 3423
    STABLES = 3424
    CENARION_HOLD = 3425
    STAGHELM_POINT = 3426
    BRONZEBEARD_ENCAMPMENT = 3427
    AHN_QIRAJ = 3428
    RUINS_OF_AHN_QIRAJ = 3429
    EVERSONG_WOODS = 3430
    SUNSTRIDER_ISLE = 3431
    SHRINE_OF_DATH_REMAR = 3432
    GHOSTLANDS = 3433
    SCARAB_TERRACE = 3434
    GENERALS_TERRACE = 3435
    THE_RESERVOIR = 3436
    THE_HATCHERY = 3437
    THE_COMB = 3438
    WATCHERS_TERRACE = 3439
    SCARAB_TERRACE1 = 3440
    GENERALS_TERRACE1 = 3441
    THE_RESERVOIR1 = 3442
    THE_HATCHERY1 = 3443
    THE_COMB1 = 3444
    WATCHERS_TERRACE1 = 3445
    TWILIGHTS_RUN = 3446
    ORTELLS_HIDEOUT = 3447
    SCARAB_TERRACE2 = 3448
    GENERALS_TERRACE2 = 3449
    THE_RESERVOIR2 = 3450
    THE_HATCHERY2 = 3451
    THE_COMB2 = 3452
    WATCHERS_TERRACE2 = 3453
    RUINS_OF_AHN_QIRAJ1 = 3454
    THE_NORTH_SEA = 3455
    NAXXRAMAS = 3456
    KARAZHAN1 = 3457
    CITY = 3459
    GOLDEN_STRAND = 3460
    SUNSAIL_ANCHORAGE = 3461
    FAIRBREEZE_VILLAGE = 3462
    MAGISTERS_GATE = 3463
    FARSTRIDER_RETREAT = 3464
    NORTH_SANCTUM = 3465
    WEST_SANCTUM = 3466
    EAST_SANCTUM = 3467
    SALTHERILS_HAVEN = 3468
    THURONS_LIVERY = 3469
    STILLWHISPER_POND = 3470
    THE_LIVING_WOOD = 3471
    AZUREBREEZE_COAST = 3472
    LAKE_ELRENDAR = 3473
    THE_SCORCHED_GROVE = 3474
    ZEB_WATHA = 3475
    TOR_WATHA = 3476
    AZJOL_NERUB = 3477
    GATES_OF_AHN_QIRAJ = 3478
    THE_VEILED_SEA7 = 3479
    DUSKWITHER_GROUNDS = 3480
    DUSKWITHER_SPIRE = 3481
    THE_DEAD_SCAR = 3482
    HELLFIRE_PENINSULA = 3483
    THE_SUNSPIRE = 3484
    FALTHRIEN_ACADEMY = 3485
    RAVENHOLDT_MANOR = 3486
    SILVERMOON_CITY = 3487
    TRANQUILLIEN = 3488
    SUNCROWN_VILLAGE = 3489
    GOLDENMIST_VILLAGE = 3490
    WINDRUNNER_VILLAGE = 3491
    WINDRUNNER_SPIRE = 3492
    SANCTUM_OF_THE_SUN = 3493
    SANCTUM_OF_THE_MOON = 3494
    DAWNSTAR_SPIRE = 3495
    FARSTRIDER_ENCLAVE = 3496
    AN_DAROTH = 3497
    AN_TELAS = 3498
    AN_OWYN = 3499
    DEATHOLME = 3500
    BLEEDING_ZIGGURAT = 3501
    HOWLING_ZIGGURAT = 3502
    SHALANDIS_ISLE = 3503
    TORYL_ESTATE = 3504
    UNDERLIGHT_MINES = 3505
    ANDILIEN_ESTATE = 3506
    HATCHET_HILLS = 3507
    AMANI_PASS = 3508
    SUNGRAZE_PEAK = 3509
    AMANI_CATACOMBS = 3510
    TOWER_OF_THE_DAMNED = 3511
    ZEB_SORA = 3512
    LAKE_ELRENDAR1 = 3513
    THE_DEAD_SCAR1 = 3514
    ELRENDAR_RIVER = 3515
    ZEB_TELA = 3516
    ZEB_NOWA = 3517
    NAGRAND = 3518
    TEROKKAR_FOREST = 3519
    SHADOWMOON_VALLEY = 3520
    ZANGARMARSH = 3521
    BLADES_EDGE_MOUNTAINS = 3522
    NETHERSTORM = 3523
    AZUREMYST_ISLE = 3524
    BLOODMYST_ISLE = 3525
    AMMEN_VALE = 3526
    CRASH_SITE = 3527
    SILVERLINE_LAKE = 3528
    NESTLEWOOD_THICKET = 3529
    SHADOW_RIDGE = 3530
    SKULKING_ROW = 3531
    DAWNING_LANE = 3532
    RUINS_OF_SILVERMOON = 3533
    FETHS_WAY = 3534
    HELLFIRE_CITADEL = 3535
    THRALLMAR = 3536
    BOREAN_TUNDRA = 3537
    HONOR_HOLD = 3538
    THE_STAIR_OF_DESTINY = 3539
    TWISTING_NETHER = 3540
    FORGE_CAMP_MAGEDDON = 3541
    THE_PATH_OF_GLORY = 3542
    THE_GREAT_FISSURE = 3543
    PLAIN_OF_SHARDS = 3544
    HELLFIRE_CITADEL1 = 3545
    EXPEDITION_ARMORY = 3546
    THRONE_OF_KIL_JAEDEN = 3547
    FORGE_CAMP_RAGE = 3548
    INVASION_POINT_ANNIHILATOR = 3549
    BORUNE_RUINS = 3550
    RUINS_OF_SHA_NAAR = 3551
    TEMPLE_OF_TELHAMAT = 3552
    POOLS_OF_AGGONAR = 3553
    FALCON_WATCH = 3554
    MAG_HAR_POST = 3555
    DEN_OF_HAAL_ESH = 3556
    THE_EXODAR = 3557
    ELRENDAR_FALLS = 3558
    NESTLEWOOD_HILLS = 3559
    AMMEN_FIELDS = 3560
    THE_SACRED_GROVE = 3561
    HELLFIRE_RAMPARTS = 3562
    HELLFIRE_CITADEL2 = 3563
    EMBERGLADE = 3564
    CENARION_REFUGE = 3565
    MOONWING_DEN = 3566
    POD_CLUSTER = 3567
    POD_WRECKAGE = 3568
    TIDES_HOLLOW = 3569
    WRATHSCALE_POINT = 3570
    BRISTLELIMB_VILLAGE = 3571
    STILLPINE_HOLD = 3572
    ODESYUS_LANDING = 3573
    VALAARS_BERTH = 3574
    SILTING_SHORE = 3575
    AZURE_WATCH = 3576
    GEEZLES_CAMP = 3577
    MENAGERIE_WRECKAGE = 3578
    TRAITORS_COVE = 3579
    WILDWIND_PEAK = 3580
    WILDWIND_PATH = 3581
    ZETH_GOR = 3582
    BERYL_COAST = 3583
    BLOOD_WATCH = 3584
    BLADEWOOD = 3585
    THE_VECTOR_COIL = 3586
    THE_WARP_PISTON = 3587
    THE_CRYO_CORE = 3588
    THE_CRIMSON_REACH = 3589
    WRATHSCALE_LAIR = 3590
    RUINS_OF_LORETH_ARAN = 3591
    NAZZIVIAN = 3592
    AXXARIEN = 3593
    BLACKSILT_SHORE = 3594
    THE_FOUL_POOL = 3595
    THE_HIDDEN_REEF = 3596
    AMBERWEB_PASS = 3597
    WYRMSCAR_ISLAND = 3598
    TALON_STAND = 3599
    BRISTLELIMB_ENCLAVE = 3600
    RAGEFEATHER_RIDGE = 3601
    KESSELS_CROSSING = 3602
    TEL_ATHIONS_CAMP = 3603
    THE_BLOODCURSED_REEF = 3604
    HYJAL_PAST = 3605
    HYJAL_SUMMIT = 3606
    SERPENTSHRINE_CAVERN = 3607
    VINDICATORS_REST = 3608
    UNUSED3 = 3609
    BURNING_BLADE_RUINS = 3610
    CLAN_WATCH = 3611
    BLOODCURSE_ISLE = 3612
    GARADAR = 3613
    SKYSONG_LAKE = 3614
    THRONE_OF_THE_ELEMENTS = 3615
    LAUGHING_SKULL_RUINS = 3616
    WARMAUL_HILL = 3617
    GRUULS_LAIR = 3618
    AUREN_RIDGE = 3619
    AUREN_FALLS = 3620
    LAKE_SUNSPRING = 3621
    SUNSPRING_POST = 3622
    AERIS_LANDING = 3623
    FORGE_CAMP_FEAR = 3624
    FORGE_CAMP_HATE = 3625
    TELAAR = 3626
    NORTHWIND_CLEFT = 3627
    HALAA = 3628
    SOUTHWIND_CLEFT = 3629
    OSHU_GUN = 3630
    SPIRIT_FIELDS = 3631
    SHAMANAR = 3632
    ANCESTRAL_GROUNDS = 3633
    WINDYREED_VILLAGE = 3634
    UNUSED2 = 3635
    ELEMENTAL_PLATEAU = 3636
    KILSORROW_FORTRESS = 3637
    THE_RING_OF_TRIALS = 3638
    SILVERMYST_ISLE = 3639
    DAGGERFEN_VILLAGE = 3640
    UMBRAFEN_VILLAGE = 3641
    FERALFEN_VILLAGE = 3642
    BLOODSCALE_ENCLAVE = 3643
    TELREDOR = 3644
    ZABRA_JIN = 3645
    QUAGG_RIDGE = 3646
    THE_SPAWNING_GLEN = 3647
    THE_DEAD_MIRE = 3648
    SPOREGGAR = 3649
    ANGO_ROSH_GROUNDS = 3650
    ANGO_ROSH_STRONGHOLD = 3651
    FUNGGOR_CAVERN = 3652
    SERPENT_LAKE = 3653
    THE_DRAIN = 3654
    UMBRAFEN_LAKE = 3655
    MARSHLIGHT_LAKE = 3656
    PORTAL_CLEARING = 3657
    SPOREWIND_LAKE = 3658
    THE_LAGOON = 3659
    BLADES_RUN = 3660
    BLADE_TOOTH_CANYON = 3661
    COMMONS_HALL = 3662
    DERELICT_MANOR = 3663
    HUNTRESS_OF_THE_SUN = 3664
    FALCONWING_SQUARE = 3665
    HALAANI_BASIN = 3666
    HEWN_BOG = 3667
    BOHA_MU_RUINS = 3668
    THE_STADIUM = 3669
    THE_OVERLOOK = 3670
    BROKEN_HILL = 3671
    MAG_HARI_PROCESSION = 3672
    NESINGWARY_SAFARI = 3673
    CENARION_THICKET = 3674
    TUUREM = 3675
    VEIL_SHIENOR = 3676
    VEIL_SKITH = 3677
    VEIL_SHALAS = 3678
    SKETTIS = 3679
    BLACKWIND_VALLEY = 3680
    FIREWING_POINT = 3681
    GRANGOL_VAR_VILLAGE = 3682
    STONEBREAKER_HOLD = 3683
    ALLERIAN_STRONGHOLD = 3684
    BONECHEWER_RUINS = 3685
    VEIL_LITHIC = 3686
    OLEMBAS = 3687
    AUCHINDOUN = 3688
    VEIL_RESKK = 3689
    BLACKWIND_LAKE = 3690
    LAKE_ERE_NORU = 3691
    LAKE_JORUNE = 3692
    SKETHYL_MOUNTAINS = 3693
    MISTY_RIDGE = 3694
    THE_BROKEN_HILLS = 3695
    THE_BARRIER_HILLS = 3696
    THE_BONE_WASTES = 3697
    NAGRAND_ARENA = 3698
    LAUGHING_SKULL_COURTYARD = 3699
    THE_RING_OF_BLOOD = 3700
    ARENA_FLOOR = 3701
    BLADES_EDGE_ARENA = 3702
    SHATTRATH_CITY = 3703
    THE_SHEPHERDS_GATE = 3704
    TELAARI_BASIN = 3705
    THE_DARK_PORTAL1 = 3706
    ALLIANCE_BASE = 3707
    HORDE_ENCAMPMENT = 3708
    NIGHT_ELF_VILLAGE = 3709
    NORDRASSIL = 3710
    SHOLAZAR_BASIN = 3711
    AREA_52 = 3712
    THE_BLOOD_FURNACE = 3713
    THE_SHATTERED_HALLS = 3714
    THE_STEAMVAULT = 3715
    THE_UNDERBOG = 3716
    THE_SLAVE_PENS = 3717
    SWAMPRAT_POST = 3718
    BLEEDING_HOLLOW_RUINS = 3719
    TWIN_SPIRE_RUINS = 3720
    THE_CRUMBLING_WASTE = 3721
    MANAFORGE_ARA = 3722
    ARKLON_RUINS = 3723
    COSMOWRENCH = 3724
    RUINS_OF_ENKAAT = 3725
    MANAFORGE_B_NAAR = 3726
    THE_SCRAP_FIELD = 3727
    THE_VORTEX_FIELDS = 3728
    THE_HEAP = 3729
    MANAFORGE_CORUU = 3730
    THE_TEMPEST_RIFT = 3731
    KIRIN_VAR_VILLAGE = 3732
    THE_VIOLET_TOWER = 3733
    MANAFORGE_DURO = 3734
    VOIDWIND_PLATEAU = 3735
    MANAFORGE_ULTRIS = 3736
    CELESTIAL_RIDGE = 3737
    THE_STORMSPIRE = 3738
    FORGE_BASE_OBLIVION = 3739
    FORGE_BASE_GEHENNA = 3740
    RUINS_OF_FARAHLON = 3741
    SOCRETHARS_SEAT = 3742
    LEGION_HOLD = 3743
    SHADOWMOON_VILLAGE = 3744
    WILDHAMMER_STRONGHOLD = 3745
    THE_HAND_OF_GUL_DAN = 3746
    THE_FEL_PITS = 3747
    THE_DEATHFORGE = 3748
    COILSKAR_CISTERN = 3749
    COILSKAR_POINT = 3750
    SUNFIRE_POINT = 3751
    ILLIDARI_POINT = 3752
    RUINS_OF_BAA_RI = 3753
    ALTAR_OF_SHA_TAR = 3754
    THE_STAIR_OF_DOOM = 3755
    RUINS_OF_KARABOR = 3756
    ATA_MAL_TERRACE = 3757
    NETHERWING_FIELDS = 3758
    NETHERWING_LEDGE = 3759
    THE_BARRIER_HILLS1 = 3760
    THE_HIGH_PATH = 3761
    WINDYREED_PASS = 3762
    ZANGAR_RIDGE = 3763
    THE_TWILIGHT_RIDGE = 3764
    RAZORTHORN_TRAIL = 3765
    OREBOR_HARBORAGE = 3766
    BLADES_RUN1 = 3767
    JAGGED_RIDGE = 3768
    THUNDERLORD_STRONGHOLD = 3769
    BLADE_TOOTH_CANYON1 = 3770
    THE_LIVING_GROVE = 3771
    SYLVANAAR = 3772
    BLADESPIRE_HOLD = 3773
    GRUULS_LAIR1 = 3774
    CIRCLE_OF_BLOOD = 3775
    BLOODMAUL_OUTPOST = 3776
    BLOODMAUL_CAMP = 3777
    DRAENETHYST_MINE = 3778
    TROGMAS_CLAIM = 3779
    BLACKWING_COVEN = 3780
    GRISHNATH = 3781
    VEIL_LASHH = 3782
    VEIL_VEKH = 3783
    FORGE_CAMP_TERROR = 3784
    FORGE_CAMP_WRATH = 3785
    OGRI_LA = 3786
    FORGE_CAMP_ANGER = 3787
    THE_LOW_PATH = 3788
    SHADOW_LABYRINTH = 3789
    AUCHENAI_CRYPTS = 3790
    SETHEKK_HALLS = 3791
    MANA_TOMBS = 3792
    FELSPARK_RAVINE = 3793
    VALLEY_OF_BONES1 = 3794
    SHA_NAARI_WASTES = 3795
    THE_WARP_FIELDS = 3796
    FALLEN_SKY_RIDGE = 3797
    HAAL_ESHI_GORGE = 3798
    STONEWALL_CANYON = 3799
    THORNFANG_HILL = 3800
    MAG_HAR_GROUNDS = 3801
    VOID_RIDGE = 3802
    THE_ABYSSAL_SHELF = 3803
    THE_LEGION_FRONT = 3804
    ZUL_AMAN = 3805
    SUPPLY_CARAVAN = 3806
    REAVERS_FALL = 3807
    CENARION_POST = 3808
    SOUTHERN_RAMPART = 3809
    NORTHERN_RAMPART = 3810
    GOR_GAZ_OUTPOST = 3811
    SPINEBREAKER_POST = 3812
    THE_PATH_OF_ANGUISH = 3813
    EAST_SUPPLY_CARAVAN = 3814
    EXPEDITION_POINT = 3815
    ZEPPELIN_CRASH = 3816
    TESTING = 3817
    BLOODSCALE_GROUNDS = 3818
    DARKCREST_ENCLAVE = 3819
    EYE_OF_THE_STORM = 3820
    WARDENS_CAGE = 3821
    ECLIPSE_POINT = 3822
    ISLE_OF_TRIBULATIONS = 3823
    BLOODMAUL_RAVINE = 3824
    DRAGONS_END = 3825
    DAGGERMAW_CANYON = 3826
    VEKHAAR_STAND = 3827
    RUUAN_WEALD = 3828
    VEIL_RUUAN = 3829
    RAVENS_WOOD = 3830
    DEATHS_DOOR = 3831
    VORTEX_PINNACLE = 3832
    RAZOR_RIDGE = 3833
    RIDGE_OF_MADNESS = 3834
    DUSTQUILL_RAVINE = 3835
    MAGTHERIDONS_LAIR = 3836
    SUNFURY_HOLD = 3837
    SPINEBREAKER_MOUNTAINS = 3838
    ABANDONED_ARMORY = 3839
    THE_BLACK_TEMPLE = 3840
    DARKCREST_SHORE = 3841
    TEMPEST_KEEP = 3842
    MOK_NATHAL_VILLAGE = 3844
    TEMPEST_KEEP1 = 3845
    THE_ARCATRAZ = 3846
    THE_BOTANICA = 3847
    THE_ARCATRAZ1 = 3848
    THE_MECHANAR = 3849
    NETHERSTONE = 3850
    MIDREALM_POST = 3851
    TULUMANS_LANDING = 3852
    PROTECTORATE_WATCH_POST = 3854
    CIRCLE_OF_BLOOD_ARENA = 3855
    ELRENDAR_CROSSING = 3856
    AMMEN_FORD = 3857
    RAZORTHORN_SHELF = 3858
    SILMYR_LAKE = 3859
    RAASTOK_GLADE = 3860
    THALASSIAN_PASS = 3861
    CHURNING_GULCH = 3862
    BROKEN_WILDS = 3863
    BASH_IR_LANDING = 3864
    CRYSTAL_SPINE = 3865
    SKALD = 3866
    BLADED_GULCH = 3867
    GYRO_PLANK_BRIDGE = 3868
    MAGE_TOWER = 3869
    BLOOD_ELF_TOWER = 3870
    DRAENEI_RUINS = 3871
    FEL_REAVER_RUINS = 3872
    THE_PROVING_GROUNDS = 3873
    ECO_DOME_FARFIELD = 3874
    ECO_DOME_SKYPERCH = 3875
    ECO_DOME_SUTHERON = 3876
    ECO_DOME_MIDREALM = 3877
    ETHEREUM_STAGING_GROUNDS = 3878
    CHAPEL_YARD = 3879
    ACCESS_SHAFT_ZEON = 3880
    TRELLEUM_MINE = 3881
    INVASION_POINT_DESTROYER = 3882
    CAMP_OF_BOOM = 3883
    SPINEBREAKER_PASS = 3884
    NETHERWEB_RIDGE = 3885
    DERELICT_CARAVAN = 3886
    REFUGEE_CARAVAN = 3887
    SHADOW_TOMB = 3888
    VEIL_RHAZE = 3889
    TOMB_OF_LIGHTS = 3890
    CARRION_HILL = 3891
    WRITHING_MOUND = 3892
    RING_OF_OBSERVANCE = 3893
    AUCHENAI_GROUNDS = 3894
    CENARION_WATCHPOST = 3895
    ALDOR_RISE = 3896
    TERRACE_OF_LIGHT = 3897
    SCRYERS_TIER = 3898
    LOWER_CITY = 3899
    INVASION_POINT_OVERLORD = 3900
    ALLERIAN_POST = 3901
    STONEBREAKER_CAMP = 3902
    BOULDER_MOK = 3903
    CURSED_HOLLOW = 3904
    COILFANG_RESERVOIR = 3905
    THE_BLOODWASH = 3906
    VERIDIAN_POINT = 3907
    MIDDENVALE = 3908
    THE_LOST_FOLD = 3909
    MYSTWOOD = 3910
    TRANQUIL_SHORE = 3911
    GOLDENBOUGH_PASS = 3912
    RUNESTONE_FALITHAS = 3913
    RUNESTONE_SHAN_DOR = 3914
    FAIRBRIDGE_STRAND = 3915
    MOONGRAZE_WOODS = 3916
    AUCHINDOUN1 = 3917
    TOSHLEYS_STATION = 3918
    SINGING_RIDGE = 3919
    SHATTER_POINT = 3920
    ARKLONIS_RIDGE = 3921
    BLADESPIRE_OUTPOST = 3922
    GRUULS_LAIR2 = 3923
    NORTHMAUL_TOWER = 3924
    SOUTHMAUL_TOWER = 3925
    SHATTERED_PLAINS = 3926
    ORONOKS_FARM = 3927
    THE_ALTAR_OF_DAMNATION = 3928
    THE_PATH_OF_CONQUEST = 3929
    ECLIPSION_FIELDS = 3930
    BLADESPIRE_GROUNDS = 3931
    SKETH_LON_BASE_CAMP = 3932
    SKETH_LON_WRECKAGE = 3933
    TOWN_SQUARE = 3934
    WIZARD_ROW = 3935
    DEATHFORGE_TOWER = 3936
    SLAG_WATCH = 3937
    SANCTUM_OF_THE_STARS = 3938
    DRAGONMAW_FORTRESS = 3939
    THE_FETID_POOL = 3940
    TEST = 3941
    RAZAANS_LANDING = 3942
    INVASION_POINT_CATACLYSM = 3943
    THE_ALTAR_OF_SHADOWS = 3944
    NETHERWING_PASS = 3945
    WAYNES_REFUGE = 3946
    THE_SCALDING_POOLS = 3947
    BRIAN_AND_PAT_TEST = 3948
    MAGMA_FIELDS = 3949
    CRIMSON_WATCH = 3950
    EVERGROVE = 3951
    WYRMSKULL_BRIDGE = 3952
    SCALEWING_SHELF = 3953
    WYRMSKULL_TUNNEL = 3954
    HELLFIRE_BASIN = 3955
    THE_SHADOW_STAIR = 3956
    SHA_TARI_OUTPOST = 3957
    SHA_TARI_BASE_CAMP = 3958
    BLACK_TEMPLE = 3959
    SOULGRINDERS_BARROW = 3960
    SORROW_WING_POINT = 3961
    VIM_GOLS_CIRCLE = 3962
    DRAGONSPINE_RIDGE = 3963
    SKYGUARD_OUTPOST = 3964
    NETHERWING_MINES = 3965
    DRAGONMAW_BASE_CAMP = 3966
    DRAGONMAW_SKYWAY = 3967
    RUINS_OF_LORDAERON1 = 3968
    RIVENDARKS_PERCH = 3969
    OBSIDIAS_PERCH = 3970
    INSIDIONS_PERCH = 3971
    FURYWINGS_PERCH = 3972
    BLACKWIND_LANDING = 3973
    VEIL_HARR_IK = 3974
    TEROKKS_REST = 3975
    VEIL_ALA_RAK = 3976
    UPPER_VEIL_SHIL_AK = 3977
    LOWER_VEIL_SHIL_AK = 3978
    THE_FROZEN_SEA = 3979
    DAGGERCAP_BAY = 3980
    VALGARDE = 3981
    WYRMSKULL_VILLAGE = 3982
    UTGARDE_KEEP1 = 3983
    NIFFLEVAR = 3984
    FALLS_OF_YMIRON = 3985
    ECHO_REACH = 3986
    THE_ISLE_OF_SPEARS = 3987
    KAMAGUA = 3988
    GARVANS_REEF = 3989
    SCALAWAG_POINT = 3990
    NEW_AGAMAND = 3991
    THE_ANCIENT_LIFT = 3992
    WESTGUARD_TURRET = 3993
    HALGRIND = 3994
    THE_LAUGHING_STAND = 3995
    BAELGUNS_EXCAVATION_SITE = 3996
    EXPLORERS_LEAGUE_OUTPOST = 3997
    WESTGUARD_KEEP = 3998
    STEEL_GATE = 3999
    VENGEANCE_LANDING = 4000
    BALEHEIM = 4001
    SKORN = 4002
    FORT_WILDERVAR = 4003
    VILEPREY_VILLAGE = 4004
    IVALDS_RUIN = 4005
    GJALERBRON = 4006
    TOMB_OF_THE_LOST_KINGS = 4007
    SHARTUULS_TRANSPORTER = 4008
    ILLIDARI_TRAINING_GROUNDS = 4009
    MUDSPROCKET = 4010
    CAMP_WINTERHOOF = 4018
    DEVELOPMENT_LAND = 4019
    MIGHTSTONE_QUARRY = 4020
    BLOODSPORE_PLAINS = 4021
    GAMMOTH = 4022
    AMBER_LEDGE = 4023
    COLDARRA = 4024
    THE_WESTRIFT = 4025
    THE_TRANSITUS_STAIR = 4026
    COAST_OF_ECHOES = 4027
    RIPLASH_STRAND = 4028
    RIPLASH_RUINS = 4029
    COAST_OF_IDOLS = 4030
    PAL_EA = 4031
    VALIANCE_KEEP = 4032
    WINTERFIN_VILLAGE = 4033
    THE_BOREAN_WALL = 4034
    THE_GEYSER_FIELDS = 4035
    FIZZCRANK_PUMPING_STATION = 4036
    TAUNKA_LE_VILLAGE = 4037
    MAGNAMOTH_CAVERNS = 4038
    COLDROCK_QUARRY = 4039
    NJORDS_BREATH_BAY = 4040
    KASKALA = 4041
    TRANSBOREA = 4042
    THE_FLOOD_PLAINS = 4043
    DIREHORN_POST = 4046
    NATS_LANDING = 4047
    EMBER_CLUTCH = 4048
    TABETHAS_FARM = 4049
    DERELICT_STRAND = 4050
    THE_FROZEN_GLADE = 4051
    THE_VIBRANT_GLADE = 4052
    THE_TWISTED_GLADE = 4053
    RIVENWOOD = 4054
    CALDEMERE_LAKE = 4055
    UTGARDE_CATACOMBS = 4056
    SHIELD_HILL = 4057
    LAKE_CAULDROS = 4058
    CAULDROS_ISLE = 4059
    BLEEDING_VALE = 4060
    GIANTS_RUN = 4061
    APOTHECARY_CAMP = 4062
    EMBER_SPEAR_TOWER = 4063
    SHATTERED_STRAITS = 4064
    GJALERHORN = 4065
    FROSTBLADE_PEAK = 4066
    PLAGUEWOOD_TOWER = 4067
    WEST_SPEAR_TOWER = 4068
    NORTH_SPEAR_TOWER = 4069
    CHILLMERE_COAST = 4070
    WHISPER_GULCH = 4071
    SUB_ZONE = 4072
    WINTERS_TERRACE = 4073
    THE_WAKING_HALLS = 4074
    SUNWELL_PLATEAU = 4075
    REUSE_ME_SEVEN = 4076
    SORLOFS_STRAND = 4077
    RAZORTHORN_RISE = 4078
    FROSTBLADE_PASS = 4079
    ISLE_OF_QUEL_DANAS = 4080
    THE_DAWNCHASER = 4081
    THE_SIN_LOREN = 4082
    SILVERMOONS_PRIDE = 4083
    THE_BLOODOATH = 4084
    SHATTERED_SUN_STAGING_AREA = 4085
    SUNS_REACH_SANCTUM = 4086
    SUNS_REACH_HARBOR = 4087
    SUNS_REACH_ARMORY = 4088
    DAWNSTAR_VILLAGE = 4089
    THE_DAWNING_SQUARE = 4090
    GREENGILL_COAST = 4091
    THE_DEAD_SCAR2 = 4092
    THE_SUN_FORGE = 4093
    SUNWELL_PLATEAU1 = 4094
    MAGISTERS_TERRACE = 4095
    CLAYTONS_WOWEDIT_LAND = 4096
    WINTERFIN_CAVERNS = 4097
    GLIMMER_BAY = 4098
    WINTERFIN_RETREAT = 4099
    THE_CULLING_OF_STRATHOLME = 4100
    SANDS_OF_NASAM = 4101
    KROMS_LANDING = 4102
    NASAMS_TALON = 4103
    ECHO_COVE = 4104
    BERYL_POINT = 4105
    GARROSHS_LANDING = 4106
    WARSONG_JETTY = 4107
    FIZZCRANK_AIRSTRIP = 4108
    LAKE_KUM_UYA = 4109
    FARSHIRE_FIELDS = 4110
    FARSHIRE = 4111
    FARSHIRE_LIGHTHOUSE = 4112
    UNU_PE = 4113
    DEATHS_STAND = 4114
    THE_ABANDONED_REACH = 4115
    SCALDING_POOLS = 4116
    STEAM_SPRINGS = 4117
    TALRAMAS = 4118
    FESTERING_POOLS = 4119
    THE_NEXUS = 4120
    TRANSITUS_SHIELD = 4121
    BOR_GOROK_OUTPOST = 4122
    MAGMOTH = 4123
    THE_DENS_OF_DYING = 4124
    TEMPLE_CITY_OF_EN_KILAH = 4125
    THE_WAILING_ZIGGURAT = 4126
    STEELJAWS_CARAVAN = 4127
    NAXXANAR = 4128
    WARSONG_HOLD = 4129
    PLAINS_OF_NASAM = 4130
    MAGISTERS_TERRACE1 = 4131
    RUINS_OF_ELDRA_NATH = 4132
    CHARRED_RISE = 4133
    BLISTERING_POOL = 4134
    SPIRE_OF_BLOOD = 4135
    SPIRE_OF_DECAY = 4136
    SPIRE_OF_PAIN = 4137
    FROZEN_REACH = 4138
    PARHELION_PLAZA = 4139
    THE_DEAD_SCAR3 = 4140
    TORPS_FARM = 4141
    WARSONG_GRANARY = 4142
    WARSONG_SLAUGHTERHOUSE = 4143
    WARSONG_FARMS_OUTPOST = 4144
    WEST_POINT_STATION = 4145
    NORTH_POINT_STATION = 4146
    MID_POINT_STATION = 4147
    SOUTH_POINT_STATION = 4148
    DEHTA_ENCAMPMENT = 4149
    KAWS_ROOST = 4150
    WESTWIND_REFUGEE_CAMP = 4151
    MOA_KI_HARBOR = 4152
    INDU_LE_VILLAGE = 4153
    SNOWFALL_GLADE = 4154
    THE_HALF_SHELL = 4155
    SURGE_NEEDLE = 4156
    MOONREST_GARDENS = 4157
    STARS_REST = 4158
    WESTFALL_BRIGADE_ENCAMPMENT = 4159
    LOTHALOR_WOODLANDS = 4160
    WYRMREST_TEMPLE = 4161
    ICEMIST_FALLS = 4162
    ICEMIST_VILLAGE = 4163
    THE_PIT_OF_NARJUN = 4164
    AGMARS_HAMMER = 4165
    LAKE_INDU_LE = 4166
    OBSIDIAN_DRAGONSHRINE = 4167
    RUBY_DRAGONSHRINE = 4168
    FORDRAGON_HOLD = 4169
    KOR_KRON_VANGUARD = 4170
    THE_COURT_OF_SKULLS = 4171
    ANGRATHAR_THE_WRATHGATE = 4172
    GALAKRONDS_REST = 4173
    THE_WICKED_COIL = 4174
    BRONZE_DRAGONSHRINE = 4175
    THE_MIRROR_OF_DAWN = 4176
    WINTERGARDE_KEEP = 4177
    WINTERGARDE_MINE = 4178
    EMERALD_DRAGONSHRINE = 4179
    NEW_HEARTHGLEN = 4180
    CRUSADERS_LANDING = 4181
    SINNERS_FOLLY = 4182
    AZURE_DRAGONSHRINE = 4183
    PATH_OF_THE_TITANS = 4184
    THE_FORGOTTEN_SHORE = 4185
    VENOMSPITE = 4186
    THE_CRYSTAL_VICE = 4187
    THE_CARRION_FIELDS = 4188
    ONSLAUGHT_BASE_CAMP = 4189
    THORSONS_POST = 4190
    LIGHTS_TRUST = 4191
    FROSTMOURNE_CAVERN = 4192
    SCARLET_POINT = 4193
    JINTHA_KALAR = 4194
    ICE_HEART_CAVERN = 4195
    DRAK_THARON_KEEP = 4196
    WINTERGRASP = 4197
    KILI_UAS_ATOLL = 4198
    SILVERBROOK = 4199
    VORDRASSILS_HEART = 4200
    VORDRASSILS_TEARS = 4201
    VORDRASSILS_TEARS1 = 4202
    VORDRASSILS_LIMB = 4203
    AMBERPINE_LODGE = 4204
    SOLSTICE_VILLAGE = 4205
    CONQUEST_HOLD = 4206
    VOLDRUNE = 4207
    GRANITE_SPRINGS = 4208
    ZEB_HALAK = 4209
    DRAK_THARON_KEEP1 = 4210
    CAMP_ONEQWAH = 4211
    EASTWIND_SHORE = 4212
    THE_BROKEN_BLUFFS = 4213
    BOULDER_HILLS = 4214
    RAGE_FANG_SHRINE = 4215
    DRAKIL_JIN_RUINS = 4216
    BLACKRIVER_LOGGING_CAMP = 4217
    HEARTS_BLOOD_SHRINE = 4218
    HOLLOWSTONE_MINE = 4219
    DUN_ARGOL = 4220
    THOR_MODAN = 4221
    BLUE_SKY_LOGGING_GROUNDS = 4222
    MAW_OF_NELTHARION = 4223
    THE_BRINY_PINNACLE = 4224
    GLITTERING_STRAND = 4225
    ISKAAL = 4226
    DRAGONS_FALL = 4227
    THE_OCULUS = 4228
    PROSPECTORS_POINT = 4229
    COLDWIND_HEIGHTS = 4230
    REDWOOD_TRADING_POST = 4231
    VENGEANCE_PASS = 4232
    DAWNS_REACH = 4233
    NAXXRAMAS1 = 4234
    HEARTWOOD_TRADING_POST = 4235
    EVERGREEN_TRADING_POST = 4236
    SPRUCE_POINT_POST = 4237
    WHITE_PINE_TRADING_POST = 4238
    ASPEN_GROVE_POST = 4239
    FORESTS_EDGE_POST = 4240
    ELDRITCH_HEIGHTS = 4241
    VENTURE_BAY = 4242
    WINTERGARDE_CRYPT = 4243
    BLOODMOON_ISLE = 4244
    SHADOWFANG_TOWER = 4245
    WINTERGARDE_MAUSOLEUM = 4246
    DUSKHOWL_DEN = 4247
    THE_CONQUEST_PIT = 4248
    THE_PATH_OF_IRON = 4249
    RUINS_OF_TETHYS = 4250
    SILVERBROOK_HILLS = 4251
    THE_BROKEN_BLUFFS1 = 4252
    SEVENTH_LEGION_FRONT = 4253
    THE_DRAGON_WASTES = 4254
    RUINS_OF_DRAK_ZIN = 4255
    DRAK_MAR_LAKE = 4256
    DRAGONSPINE_TRIBUTARY = 4257
    THE_NORTH_SEA1 = 4258
    DRAK_URAL = 4259
    THORVALDS_CAMP = 4260
    GHOSTBLADE_POST = 4261
    ASHWOOD_POST = 4262
    LYDELLS_AMBUSH = 4263
    HALLS_OF_STONE = 4264
    THE_NEXUS1 = 4265
    HARKORS_CAMP = 4266
    VORDRASSIL_PASS = 4267
    RUUNAS_CAMP = 4268
    SHRINE_OF_SCALES = 4269
    DRAK_ATAL_PASSAGE = 4270
    UTGARDE_PINNACLE1 = 4271
    HALLS_OF_LIGHTNING = 4272
    ULDUAR = 4273
    THE_ARGENT_STAND = 4275
    ALTAR_OF_SSERATUS = 4276
    AZJOL_NERUB1 = 4277
    DRAKSOTRA_FIELDS = 4278
    DRAKSOTRA = 4279
    DRAK_AGAL = 4280
    ACHERUS_THE_EBON_HOLD = 4281
    THE_AVALANCHE = 4282
    THE_LOST_LANDS = 4283
    NESINGWARY_BASE_CAMP = 4284
    THE_SEABREACH_FLOW = 4285
    THE_BONES_OF_NOZRONN = 4286
    KARTAKS_HOLD = 4287
    SPARKTOUCHED_HAVEN = 4288
    THE_PATH_OF_THE_LIFEWARDEN = 4289
    RIVERS_HEART = 4290
    RAINSPEAKER_CANOPY = 4291
    FRENZYHEART_HILL = 4292
    WILDGROWTH_MANGAL = 4293
    HEB_VALOK = 4294
    THE_SUNDERED_SHARD = 4295
    THE_LIFEBLOOD_PILLAR = 4296
    MOSSWALKER_VILLAGE = 4297
    PLAGUELANDS_THE_SCARLET_ENCLAVE = 4298
    KOLRAMAS = 4299
    WAYGATE = 4300
    THE_SKYREACH_PILLAR = 4302
    HARDKNUCKLE_CLEARING = 4303
    SAPPHIRE_HIVE = 4304
    MISTWHISPER_REFUGE = 4306
    THE_GLIMMERING_PILLAR = 4307
    SPEARBORN_ENCAMPMENT = 4308
    DRAK_THARON_KEEP2 = 4309
    ZERAMAS = 4310
    RELIQUARY_OF_AGONY = 4311
    EBON_WATCH = 4312
    THRYMS_END = 4313
    VOLTARUS = 4314
    RELIQUARY_OF_PAIN = 4315
    RAGECLAW_DEN = 4316
    LIGHTS_BREACH = 4317
    POOLS_OF_ZHA_JIN = 4318
    ZIM_ABWA = 4319
    AMPHITHEATER_OF_ANGUISH = 4320
    ALTAR_OF_RHUNOK = 4321
    ALTAR_OF_HAR_KOA = 4322
    ZIM_TORGA = 4323
    POOLS_OF_JIN_ALAI = 4324
    ALTAR_OF_QUETZ_LUN = 4325
    HEB_DRAKKAR = 4326
    DRAK_MABWA = 4327
    ZIM_RHUK = 4328
    ALTAR_OF_MAM_TOTH = 4329
    ACHERUS_THE_EBON_HOLD1 = 4342
    NEW_AVALON = 4343
    NEW_AVALON_FIELDS = 4344
    NEW_AVALON_ORCHARD = 4345
    NEW_AVALON_TOWN_HALL = 4346
    HAVENSHIRE = 4347
    HAVENSHIRE_FARMS = 4348
    HAVENSHIRE_LUMBER_MILL = 4349
    HAVENSHIRE_STABLES = 4350
    SCARLET_HOLD = 4351
    CHAPEL_OF_THE_CRIMSON_FLAME = 4352
    LIGHTS_POINT_TOWER = 4353
    LIGHTS_POINT = 4354
    CRYPT_OF_REMEMBRANCE = 4355
    DEATHS_BREACH = 4356
    THE_NOXIOUS_GLADE1 = 4357
    TYRS_HAND1 = 4358
    KINGS_HARBOR = 4359
    SCARLET_OVERLOOK = 4360
    LIGHTS_HOPE_CHAPEL1 = 4361
    SINNERS_FOLLY1 = 4362
    PESTILENT_SCAR1 = 4363
    BROWMAN_MILL1 = 4364
    HAVENSHIRE_MINE = 4365
    URSOCS_DEN = 4366
    THE_BLIGHT_LINE = 4367
    THE_BONEFIELDS = 4368
    DORIANS_OUTPOST = 4369
    MAM_TOTH_CRATER = 4371
    ZOL_MAZ_STRONGHOLD = 4372
    ZOL_HEB = 4373
    RAGECLAW_LAKE = 4374
    GUNDRAK = 4375
    THE_SAVAGE_THICKET = 4376
    NEW_AVALON_FORGE = 4377
    DALARAN_ARENA = 4378
    VALGARDE1 = 4379
    WESTGUARD_INN = 4380
    WAYGATE1 = 4381
    THE_SHAPERS_TERRACE = 4382
    LAKESIDE_LANDING = 4383
    STRAND_OF_THE_ANCIENTS = 4384
    BITTERTIDE_LAKE = 4385
    RAINSPEAKER_RAPIDS = 4386
    FRENZYHEART_RIVER = 4387
    WINTERGRASP_RIVER = 4388
    THE_SUNTOUCHED_PILLAR = 4389
    FRIGID_BREACH = 4390
    SWINDLEGRINS_DIG = 4391
    THE_STORMWRIGHTS_SHELF = 4392
    DEATHS_HAND_ENCAMPMENT = 4393
    SCARLET_TAVERN = 4394
    DALARAN = 4395
    NOZZLERUST_POST = 4396
    FARSHIRE_MINE = 4399
    THE_MOSSLIGHT_PILLAR = 4400
    SARAGOSAS_LANDING = 4401
    VENGEANCE_LIFT = 4402
    BALEJAR_WATCH = 4403
    NEW_AGAMAND_INN = 4404
    PASSAGE_OF_LOST_FIENDS = 4405
    THE_RING_OF_VALOR = 4406
    HALL_OF_THE_FROSTWOLF = 4407
    HALL_OF_THE_STORMPIKE = 4408
    STORMWIND_HARBOR = 4411
    THE_MAKERS_OVERLOOK = 4412
    THE_MAKERS_PERCH = 4413
    SCARLET_TOWER = 4414
    THE_VIOLET_HOLD = 4415
    GUNDRAK1 = 4416
    ONSLAUGHT_HARBOR = 4417
    K3 = 4418
    SNOWBLIND_HILLS = 4419
    SNOWBLIND_TERRACE = 4420
    GARM = 4421
    BRUNNHILDAR_VILLAGE = 4422
    SIFRELDAR_VILLAGE = 4423
    VALKYRION = 4424
    THE_FORLORN_MINE = 4425
    BORS_BREATH_RIVER = 4426
    ARGENT_VANGUARD = 4427
    FROSTHOLD = 4428
    GROM_ARSH_CRASH_SITE = 4429
    TEMPLE_OF_STORMS = 4430
    ENGINE_OF_THE_MAKERS = 4431
    THE_FOOT_STEPPES = 4432
    DRAGONSPINE_PEAKS = 4433
    NIDAVELIR = 4434
    NARVIRS_CRADLE = 4435
    SNOWDRIFT_PLAINS = 4436
    VALLEY_OF_ANCIENT_WINTERS = 4437
    DUN_NIFFELEM = 4438
    FROSTFIELD_LAKE = 4439
    THUNDERFALL = 4440
    CAMP_TUNKA_LO = 4441
    BRANNS_BASE_CAMP = 4442
    GATE_OF_ECHOES = 4443
    PLAIN_OF_ECHOES = 4444
    ULDUAR1 = 4445
    TERRACE_OF_THE_MAKERS = 4446
    GATE_OF_LIGHTNING = 4447
    PATH_OF_THE_TITANS1 = 4448
    ULDIS = 4449
    LOKENS_BARGAIN = 4450
    BORS_FALL = 4451
    BORS_BREATH = 4452
    ROHEMDAL_PASS = 4453
    THE_STORM_FOUNDRY = 4454
    HIBERNAL_CAVERN = 4455
    VOLDRUNE_DWELLING = 4456
    TORSEGS_REST = 4457
    SPARKSOCKET_MINEFIELD = 4458
    RICKETS_FOLLY = 4459
    GARMS_BANE = 4460
    GARMS_RISE = 4461
    CRYSTALWEB_CAVERN = 4462
    TEMPLE_OF_LIFE = 4463
    TEMPLE_OF_ORDER = 4464
    TEMPLE_OF_WINTER = 4465
    TEMPLE_OF_INVENTION = 4466
    DEATHS_RISE = 4467
    THE_DEAD_FIELDS = 4468
    DARGATHS_DEMISE = 4469
    THE_HIDDEN_HOLLOW = 4470
    BERNAUS_HAPPY_FUN_LAND = 4471
    FROSTGRIPS_HOLLOW = 4472
    THE_FRIGID_TOMB = 4473
    TWIN_SHORES = 4474
    ZIM_BOS_HIDEOUT = 4475
    ABANDONED_CAMP = 4476
    THE_SHADOW_VAULT = 4477
    COLDWIND_PASS = 4478
    WINTERS_BREATH_LAKE = 4479
    THE_FORGOTTEN_OVERLOOK = 4480
    JINTHA_KALAR_PASSAGE = 4481
    ARRIGA_FOOTBRIDGE = 4482
    THE_LOST_PASSAGE = 4483
    BOULDERCRAGS_REFUGE = 4484
    THE_INVENTORS_LIBRARY = 4485
    THE_FROZEN_MINE = 4486
    FROSTFLOE_DEEP = 4487
    THE_HOWLING_HOLLOW = 4488
    CRUSADER_FORWARD_CAMP = 4489
    STORMCREST = 4490
    BONESNAPS_CAMP = 4491
    UFRANGS_HALL = 4492
    THE_OBSIDIAN_SANCTUM = 4493
    AHN_KAHET_THE_OLD_KINGDOM = 4494
    FJORNS_ANVIL = 4495
    JOTUNHEIM = 4496
    SAVAGE_LEDGE = 4497
    HALLS_OF_THE_ANCESTORS = 4498
    THE_BLIGHTED_POOL = 4499
    THE_EYE_OF_ETERNITY = 4500
    THE_ARGENT_VANGUARD = 4501
    MIMIRS_WORKSHOP = 4502
    IRONWALL_DAM = 4503
    VALLEY_OF_ECHOES = 4504
    THE_BREACH = 4505
    SCOURGEHOLME = 4506
    THE_BROKEN_FRONT = 4507
    MORD_RETHAR_THE_DEATH_GATE = 4508
    THE_BOMBARDMENT = 4509
    ALDUR_THAR_THE_DESOLATION_GATE = 4510
    THE_SKYBREAKER = 4511
    ORGRIMS_HAMMER = 4512
    YMIRHEIM = 4513
    SARONITE_MINES = 4514
    THE_CONFLAGRATION = 4515
    IRONWALL_RAMPART = 4516
    WEEPING_QUARRY = 4517
    CORP_RETHAR_THE_HORROR_GATE = 4518
    THE_COURT_OF_BONES = 4519
    MALYKRISS_THE_VILE_HOLD = 4520
    CATHEDRAL_OF_DARKNESS = 4521
    ICECROWN_CITADEL = 4522
    ICECROWN_GLACIER = 4523
    VALHALAS = 4524
    THE_UNDERHALLS = 4525
    NJORNDAR_VILLAGE = 4526
    BALARGARDE_FORTRESS = 4527
    KUL_GALAR_KEEP = 4528
    THE_CRIMSON_CATHEDRAL = 4529
    SANCTUM_OF_REANIMATION = 4530
    THE_FLESHWERKS = 4531
    VENGEANCE_LANDING_INN = 4532
    SINDRAGOSAS_FALL = 4533
    WILDERVAR_MINE = 4534
    THE_PIT_OF_THE_FANG = 4535
    FROSTHOWL_CAVERN = 4536
    THE_VALLEY_OF_LOST_HOPE = 4537
    THE_SUNKEN_RING = 4538
    THE_BROKEN_TEMPLE = 4539
    THE_VALLEY_OF_FALLEN_HEROES = 4540
    VANGUARD_INFIRMARY = 4541
    HALL_OF_THE_SHAPER = 4542
    TEMPLE_OF_WISDOM = 4543
    DEATHS_BREACH1 = 4544
    ABANDONED_MINE = 4545
    RUINS_OF_THE_SCARLET_ENCLAVE = 4546
    HALLS_OF_STONE1 = 4547
    HALLS_OF_LIGHTNING1 = 4548
    THE_GREAT_TREE = 4549
    THE_MIRROR_OF_TWILIGHT = 4550
    THE_TWILIGHT_RIVULET = 4551
    THE_DECREPIT_FLOW = 4552
    FORLORN_WOODS = 4553
    RUINS_OF_SHANDARAL = 4554
    THE_AZURE_FRONT = 4555
    VIOLET_STAND = 4556
    THE_UNBOUND_THICKET = 4557
    SUNREAVERS_COMMAND = 4558
    WINDRUNNERS_OVERLOOK = 4559
    THE_UNDERBELLY = 4560
    KRASUS_LANDING = 4564
    THE_VIOLET_HOLD1 = 4567
    THE_EVENTIDE = 4568
    SEWER_EXIT_PIPE = 4569
    CIRCLE_OF_WILLS = 4570
    SILVERWING_FLAG_ROOM = 4571
    WARSONG_FLAG_ROOM = 4572
    WINTERGRASP_FORTRESS = 4575
    CENTRAL_BRIDGE = 4576
    EASTERN_BRIDGE = 4577
    WESTERN_BRIDGE = 4578
    DUBRA_JIN = 4579
    CRUSADERS_PINNACLE = 4580
    FLAMEWATCH_TOWER = 4581
    WINTERS_EDGE_TOWER = 4582
    SHADOWSIGHT_TOWER = 4583
    THE_CAULDRON_OF_FLAMES = 4584
    GLACIAL_FALLS = 4585
    WINDY_BLUFFS = 4586
    THE_FOREST_OF_SHADOWS = 4587
    BLACKWATCH = 4588
    THE_CHILLED_QUAGMIRE = 4589
    THE_STEPPE_OF_LIFE = 4590
    SILENT_VIGIL = 4591
    GIMORAKS_DEN = 4592
    THE_PIT_OF_FIENDS = 4593
    BATTLESCAR_SPIRE = 4594
    HALL_OF_HORRORS = 4595
    THE_CIRCLE_OF_SUFFERING = 4596
    RISE_OF_SUFFERING = 4597
    KRASUS_LANDING1 = 4598
    SEWER_EXIT_PIPE1 = 4599
    DALARAN_ISLAND = 4601
    FORCE_INTERIOR = 4602
    VAULT_OF_ARCHAVON = 4603
    GATE_OF_THE_RED_SUN = 4604
    GATE_OF_THE_BLUE_SAPPHIRE = 4605
    GATE_OF_THE_GREEN_EMERALD = 4606
    GATE_OF_THE_PURPLE_AMETHYST = 4607
    GATE_OF_THE_YELLOW_MOON = 4608
    COURTYARD_OF_THE_ANCIENTS = 4609
    LANDING_BEACH = 4610
    WESTSPARK_WORKSHOP = 4611
    EASTSPARK_WORKSHOP = 4612
    DALARAN_CITY = 4613
    THE_VIOLET_CITADEL_SPIRE = 4614
    NAZ_ANAK_THE_FORGOTTEN_DEPTHS = 4615
    SUNREAVERS_SANCTUARY = 4616
    ELEVATOR = 4617
    ANTONIDAS_MEMORIAL = 4618
    THE_VIOLET_CITADEL = 4619
    MAGUS_COMMERCE_EXCHANGE = 4620
    UNUSED = 4621
    FIRST_LEGION_FORWARD_CAMP = 4622
    HALL_OF_THE_CONQUERED_KINGS = 4623
    BEFOULED_TERRACE = 4624
    THE_DESECRATED_ALTAR = 4625
    SHIMMERING_BOG = 4626
    FALLEN_TEMPLE_OF_AHN_KAHET = 4627
    HALLS_OF_BINDING = 4628
    WINTERS_HEART = 4629
    THE_NORTH_SEA2 = 4630
    THE_BROODMOTHERS_NEST = 4631
    DALARAN_FLOATING_ROCKS = 4632
    RAPTOR_PENS = 4633
    DRAK_THARON_KEEP3 = 4635
    THE_NOXIOUS_PASS = 4636
    VARGOTHS_RETREAT = 4637
    VIOLET_CITADEL_BALCONY = 4638
    BAND_OF_VARIANCE = 4639
    BAND_OF_ACCELERATION = 4640
    BAND_OF_TRANSMUTATION = 4641
    BAND_OF_ALIGNMENT = 4642
    ASHWOOD_LAKE = 4646
    IRON_CONCOURSE = 4650
    FORMATION_GROUNDS = 4652
    RAZORSCALES_AERIE = 4653
    THE_COLOSSAL_FORGE = 4654
    THE_SCRAPYARD = 4655
    THE_CONSERVATORY_OF_LIFE = 4656
    THE_ARCHIVUM = 4657
    ARGENT_TOURNAMENT_GROUNDS = 4658
    EXPEDITION_BASE_CAMP = 4665
    SUNREAVER_PAVILION = 4666
    SILVER_COVENANT_PAVILION = 4667
    THE_COOPER_RESIDENCE = 4668
    THE_RING_OF_CHAMPIONS = 4669
    THE_ASPIRANTS_RING = 4670
    THE_ARGENT_VALIANTS_RING = 4671
    THE_ALLIANCE_VALIANTS_RING = 4672
    THE_HORDE_VALIANTS_RING = 4673
    ARGENT_PAVILION = 4674
    SUNREAVER_PAVILION1 = 4676
    SILVER_COVENANT_PAVILION1 = 4677
    THE_FORLORN_CAVERN = 4679
    CLAYTONIO_TEST_AREA = 4688
    QUEL_DELARS_REST = 4692
    ISLE_OF_CONQUEST = 4710
    TRIAL_OF_THE_CRUSADER = 4722
    TRIAL_OF_THE_CHAMPION = 4723
    RUNEWEAVER_SQUARE = 4739
    THE_SILVER_ENCLAVE = 4740
    ISLE_OF_CONQUEST_NO_MANS_LAND = 4741
    HROTHGARS_LANDING = 4742
    DEATHSPEAKERS_WATCH = 4743
    WORKSHOP = 4747
    QUARRY = 4748
    DOCKS = 4749
    HANGAR = 4750
    REFINERY = 4751
    HORDE_KEEP = 4752
    ALLIANCE_KEEP = 4753
    THE_SEA_REAVERS_RUN = 4760
    TRANSPORT_ALLIANCE_GUNSHIP = 4763
    TRANSPORT_HORDE_GUNSHIP = 4764
    HROTHGARS_LANDING1 = 4769
    THE_FORGE_OF_SOULS = 4809
    ICECROWN_CITADEL1 = 4812
    PIT_OF_SARON = 4813
    HALLS_OF_REFLECTION = 4820
    TRANSPORT_ALLIANCE_GUNSHIP_IGB = 4832
    TRANSPORT_HORDE_GUNSHIP_IGB = 4833
    THE_FROZEN_THRONE = 4859
    THE_FROZEN_HALLS = 4862
    THE_FROST_QUEENS_LAIR = 4889
    PUTRICIDES_LABORATORY_OF_ALCHEMICAL_HORRORS_AND_FUN = 4890
    THE_SANCTUM_OF_BLOOD = 4891
    THE_CRIMSON_HALL = 4892
    THE_FROST_QUEENS_LAIR1 = 4893
    PUTRICIDES_LABORATORY_OF_ALCHEMICAL_HORRORS_AND_FUN1 = 4894
    THE_CRIMSON_HALL1 = 4895
    THE_FROZEN_THRONE1 = 4896
    THE_SANCTUM_OF_BLOOD1 = 4897
    FROSTMOURNE = 4898
    THE_DARK_APPROACH = 4904
    SCOURGELORDS_COMMAND = 4905
    THE_SHADOW_THRONE = 4906
    THE_HIDDEN_PASSAGE = 4908
    FROSTMOURNE1 = 4910
    THE_RUBY_SANCTUM = 4987


class ArenaFaction(enum.Enum):
    HORDE = 0
    ALLIANCE = 1


class ArenaTeamCommand(enum.Enum):
    TEAM_CREATE_S = 0
    TEAM_INVITE_SS = 1
    TEAM_QUIT_S = 3
    TEAM_FOUNDER_S = 14


class ArenaTeamCommandError(enum.Enum):
    ARENA_TEAM_INTERNAL = 1
    ALREADY_IN_ARENA_TEAM = 2
    ALREADY_IN_ARENA_TEAM_S = 3
    INVITED_TO_ARENA_TEAM = 4
    ALREADY_INVITED_TO_ARENA_TEAM_S = 5
    ARENA_TEAM_NAME_INVALID = 6
    ARENA_TEAM_NAME_EXISTS_S = 7
    ARENA_TEAM_LEADER_LEAVE_S = 8
    ARENA_TEAM_PLAYER_NOT_IN_TEAM = 9
    ARENA_TEAM_PLAYER_NOT_IN_TEAM_SS = 10
    ARENA_TEAM_PLAYER_NOT_FOUND_S = 11
    ARENA_TEAM_NOT_ALLIED = 12
    ARENA_TEAM_IGNORING_YOU_S = 19
    ARENA_TEAM_TARGET_TOO_LOW_S = 21
    ARENA_TEAM_TOO_MANY_MEMBERS_S = 22


class ArenaTeamEvent(enum.Enum):
    JOIN = 3
    LEAVE = 4
    REMOVE = 5
    LEADER_IS = 6
    LEADER_CHANGED = 7
    DISBANDED = 8


class ArenaTeamRole(enum.Enum):
    CAPTAIN = 0
    MEMBER = 1


class ArenaType(enum.Enum):
    NOT_ARENA = 0
    TWO_VS_TWO = 2
    THREE_VS_THREE = 3
    FIVE_VS_FIVE = 5


class AuctionCommandAction(enum.Enum):
    STARTED = 0
    REMOVED = 1
    BID_PLACED = 2


class AuctionCommandResult(enum.Enum):
    OK = 0
    ERR_INVENTORY = 1
    ERR_DATABASE = 2
    ERR_NOT_ENOUGH_MONEY = 3
    ERR_ITEM_NOT_FOUND = 4
    ERR_HIGHER_BID = 5
    ERR_BID_INCREMENT = 7
    ERR_BID_OWN = 10
    ERR_RESTRICTED_ACCOUNT = 13


class AuctionCommandResultTwo(enum.Enum):
    OK = 0
    ERR_INVENTORY = 1
    ERR_DATABASE = 2
    ERR_NOT_ENOUGH_MONEY = 3
    ERR_ITEM_NOT_FOUND = 4
    ERR_HIGHER_BID = 5
    ERR_BID_INCREMENT = 7
    ERR_BID_OWN = 10
    ERR_RESTRICTED_ACCOUNT = 13


class AuctionHouse(enum.Enum):
    STORMWIND = 1
    ALLIANCE = 2
    DARNASSUS = 3
    UNDERCITY = 4
    THUNDER_BLUFF = 5
    HORDE = 6
    GOBLIN = 7


class AuraMod(enum.Enum):
    NONE = 0
    BIND_SIGHT = 1
    MOD_POSSESS = 2
    PERIODIC_DAMAGE = 3
    DUMMY = 4
    MOD_CONFUSE = 5
    MOD_CHARM = 6
    MOD_FEAR = 7
    PERIODIC_HEAL = 8
    MOD_ATTACKSPEED = 9
    MOD_THREAT = 10
    MOD_TAUNT = 11
    MOD_STUN = 12
    MOD_DAMAGE_DONE = 13
    MOD_DAMAGE_TAKEN = 14
    DAMAGE_SHIELD = 15
    MOD_STEALTH = 16
    MOD_STEALTH_DETECT = 17
    MOD_INVISIBILITY = 18
    MOD_INVISIBILITY_DETECT = 19
    OBS_MOD_HEALTH = 20
    OBS_MOD_POWER = 21
    MOD_RESISTANCE = 22
    PERIODIC_TRIGGER_SPELL = 23
    PERIODIC_ENERGIZE = 24
    MOD_PACIFY = 25
    MOD_ROOT = 26
    MOD_SILENCE = 27
    REFLECT_SPELLS = 28
    MOD_STAT = 29
    MOD_SKILL = 30
    MOD_INCREASE_SPEED = 31
    MOD_INCREASE_MOUNTED_SPEED = 32
    MOD_DECREASE_SPEED = 33
    MOD_INCREASE_HEALTH = 34
    MOD_INCREASE_ENERGY = 35
    MOD_SHAPESHIFT = 36
    EFFECT_IMMUNITY = 37
    STATE_IMMUNITY = 38
    SCHOOL_IMMUNITY = 39
    DAMAGE_IMMUNITY = 40
    DISPEL_IMMUNITY = 41
    PROC_TRIGGER_SPELL = 42
    PROC_TRIGGER_DAMAGE = 43
    TRACK_CREATURES = 44
    TRACK_RESOURCES = 45
    UNKNOWN46 = 46
    MOD_PARRY_PERCENT = 47
    PERIODIC_TRIGGER_SPELL_FROM_CLIENT = 48
    MOD_DODGE_PERCENT = 49
    MOD_CRITICAL_HEALING_AMOUNT = 50
    MOD_BLOCK_PERCENT = 51
    MOD_WEAPON_CRIT_PERCENT = 52
    PERIODIC_LEECH = 53
    MOD_HIT_CHANCE = 54
    MOD_SPELL_HIT_CHANCE = 55
    TRANSFORM = 56
    MOD_SPELL_CRIT_CHANCE = 57
    MOD_INCREASE_SWIM_SPEED = 58
    MOD_DAMAGE_DONE_CREATURE = 59
    MOD_PACIFY_SILENCE = 60
    MOD_SCALE = 61
    PERIODIC_HEALTH_FUNNEL = 62
    UNKNOWN63 = 63
    PERIODIC_MANA_LEECH = 64
    MOD_CASTING_SPEED_NOT_STACK = 65
    FEIGN_DEATH = 66
    MOD_DISARM = 67
    MOD_STALKED = 68
    SCHOOL_ABSORB = 69
    EXTRA_ATTACKS = 70
    MOD_SPELL_CRIT_CHANCE_SCHOOL = 71
    MOD_POWER_COST_SCHOOL_PCT = 72
    MOD_POWER_COST_SCHOOL = 73
    REFLECT_SPELLS_SCHOOL = 74
    MOD_LANGUAGE = 75
    FAR_SIGHT = 76
    MECHANIC_IMMUNITY = 77
    MOUNTED = 78
    MOD_DAMAGE_PERCENT_DONE = 79
    MOD_PERCENT_STAT = 80
    SPLIT_DAMAGE_PCT = 81
    WATER_BREATHING = 82
    MOD_BASE_RESISTANCE = 83
    MOD_REGEN = 84
    MOD_POWER_REGEN = 85
    CHANNEL_DEATH_ITEM = 86
    MOD_DAMAGE_PERCENT_TAKEN = 87
    MOD_HEALTH_REGEN_PERCENT = 88
    PERIODIC_DAMAGE_PERCENT = 89
    UNKNOWN90 = 90
    MOD_DETECT_RANGE = 91
    PREVENTS_FLEEING = 92
    MOD_UNATTACKABLE = 93
    INTERRUPT_REGEN = 94
    GHOST = 95
    SPELL_MAGNET = 96
    MANA_SHIELD = 97
    MOD_SKILL_TALENT = 98
    MOD_ATTACK_POWER = 99
    AURAS_VISIBLE = 100
    MOD_RESISTANCE_PCT = 101
    MOD_MELEE_ATTACK_POWER_VERSUS = 102
    MOD_TOTAL_THREAT = 103
    WATER_WALK = 104
    FEATHER_FALL = 105
    HOVER = 106
    ADD_FLAT_MODIFIER = 107
    ADD_PCT_MODIFIER = 108
    ADD_TARGET_TRIGGER = 109
    MOD_POWER_REGEN_PERCENT = 110
    ADD_CASTER_HIT_TRIGGER = 111
    OVERRIDE_CLASS_SCRIPTS = 112
    MOD_RANGED_DAMAGE_TAKEN = 113
    MOD_RANGED_DAMAGE_TAKEN_PCT = 114
    MOD_HEALING = 115
    MOD_REGEN_DURING_COMBAT = 116
    MOD_MECHANIC_RESISTANCE = 117
    MOD_HEALING_PCT = 118
    UNKNOWN119 = 119
    UNTRACKABLE = 120
    EMPATHY = 121
    MOD_OFFHAND_DAMAGE_PCT = 122
    MOD_TARGET_RESISTANCE = 123
    MOD_RANGED_ATTACK_POWER = 124
    MOD_MELEE_DAMAGE_TAKEN = 125
    MOD_MELEE_DAMAGE_TAKEN_PCT = 126
    RANGED_ATTACK_POWER_ATTACKER_BONUS = 127
    MOD_POSSESS_PET = 128
    MOD_SPEED_ALWAYS = 129
    MOD_MOUNTED_SPEED_ALWAYS = 130
    MOD_RANGED_ATTACK_POWER_VERSUS = 131
    MOD_INCREASE_ENERGY_PERCENT = 132
    MOD_INCREASE_HEALTH_PERCENT = 133
    MOD_MANA_REGEN_INTERRUPT = 134
    MOD_HEALING_DONE = 135
    MOD_HEALING_DONE_PERCENT = 136
    MOD_TOTAL_STAT_PERCENTAGE = 137
    MOD_MELEE_HASTE = 138
    FORCE_REACTION = 139
    MOD_RANGED_HASTE = 140
    MOD_RANGED_AMMO_HASTE = 141
    MOD_BASE_RESISTANCE_PCT = 142
    MOD_RESISTANCE_EXCLUSIVE = 143
    SAFE_FALL = 144
    MOD_PET_TALENT_POINTS = 145
    ALLOW_TAME_PET_TYPE = 146
    MECHANIC_IMMUNITY_MASK = 147
    RETAIN_COMBO_POINTS = 148
    REDUCE_PUSHBACK = 149
    MOD_SHIELD_BLOCKVALUE_PCT = 150
    TRACK_STEALTHED = 151
    MOD_DETECTED_RANGE = 152
    SPLIT_DAMAGE_FLAT = 153
    MOD_STEALTH_LEVEL = 154
    MOD_WATER_BREATHING = 155
    MOD_REPUTATION_GAIN = 156
    PET_DAMAGE_MULTI = 157
    MOD_SHIELD_BLOCKVALUE = 158
    NO_PVP_CREDIT = 159
    MOD_AOE_AVOIDANCE = 160
    MOD_HEALTH_REGEN_IN_COMBAT = 161
    POWER_BURN = 162
    MOD_CRIT_DAMAGE_BONUS = 163
    UNKNOWN164 = 164
    MELEE_ATTACK_POWER_ATTACKER_BONUS = 165
    MOD_ATTACK_POWER_PCT = 166
    MOD_RANGED_ATTACK_POWER_PCT = 167
    MOD_DAMAGE_DONE_VERSUS = 168
    MOD_CRIT_PERCENT_VERSUS = 169
    DETECT_AMORE = 170
    MOD_SPEED_NOT_STACK = 171
    MOD_MOUNTED_SPEED_NOT_STACK = 172
    UNKNOWN173 = 173
    MOD_SPELL_DAMAGE_OF_STAT_PERCENT = 174
    MOD_SPELL_HEALING_OF_STAT_PERCENT = 175
    SPIRIT_OF_REDEMPTION = 176
    AOE_CHARM = 177
    MOD_DEBUFF_RESISTANCE = 178
    MOD_ATTACKER_SPELL_CRIT_CHANCE = 179
    MOD_FLAT_SPELL_DAMAGE_VERSUS = 180
    UNKNOWN181 = 181
    MOD_RESISTANCE_OF_STAT_PERCENT = 182
    MOD_CRITICAL_THREAT = 183
    MOD_ATTACKER_MELEE_HIT_CHANCE = 184
    MOD_ATTACKER_RANGED_HIT_CHANCE = 185
    MOD_ATTACKER_SPELL_HIT_CHANCE = 186
    MOD_ATTACKER_MELEE_CRIT_CHANCE = 187
    MOD_ATTACKER_RANGED_CRIT_CHANCE = 188
    MOD_RATING = 189
    MOD_FACTION_REPUTATION_GAIN = 190
    USE_NORMAL_MOVEMENT_SPEED = 191
    MOD_MELEE_RANGED_HASTE = 192
    MELEE_SLOW = 193
    MOD_TARGET_ABSORB_SCHOOL = 194
    MOD_TARGET_ABILITY_ABSORB_SCHOOL = 195
    MOD_COOLDOWN = 196
    MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE = 197
    UNKNOWN198 = 198
    MOD_INCREASES_SPELL_PCT_TO_HIT = 199
    MOD_XP_PCT = 200
    FLY = 201
    IGNORE_COMBAT_RESULT = 202
    MOD_ATTACKER_MELEE_CRIT_DAMAGE = 203
    MOD_ATTACKER_RANGED_CRIT_DAMAGE = 204
    MOD_SCHOOL_CRIT_DMG_TAKEN = 205
    MOD_INCREASE_VEHICLE_FLIGHT_SPEED = 206
    MOD_INCREASE_MOUNTED_FLIGHT_SPEED = 207
    MOD_INCREASE_FLIGHT_SPEED = 208
    MOD_MOUNTED_FLIGHT_SPEED_ALWAYS = 209
    MOD_VEHICLE_SPEED_ALWAYS = 210
    MOD_FLIGHT_SPEED_NOT_STACK = 211
    MOD_RANGED_ATTACK_POWER_OF_STAT_PERCENT = 212
    MOD_RAGE_FROM_DAMAGE_DEALT = 213
    UNKNOWN214 = 214
    ARENA_PREPARATION = 215
    HASTE_SPELLS = 216
    MOD_MELEE_HASTE_2 = 217
    HASTE_RANGED = 218
    MOD_MANA_REGEN_FROM_STAT = 219
    MOD_RATING_FROM_STAT = 220
    MOD_DETAUNT = 221
    UNKNOWN222 = 222
    RAID_PROC_FROM_CHARGE = 223
    UNKNOWN224 = 224
    RAID_PROC_FROM_CHARGE_WITH_VALUE = 225
    PERIODIC_DUMMY = 226
    PERIODIC_TRIGGER_SPELL_WITH_VALUE = 227
    DETECT_STEALTH = 228
    MOD_AOE_DAMAGE_AVOIDANCE = 229
    UNKNOWN230 = 230
    PROC_TRIGGER_SPELL_WITH_VALUE = 231
    MECHANIC_DURATION_MOD = 232
    CHANGE_MODEL_FOR_ALL_HUMANOIDS = 233
    MECHANIC_DURATION_MOD_NOT_STACK = 234
    MOD_DISPEL_RESIST = 235
    CONTROL_VEHICLE = 236
    MOD_SPELL_DAMAGE_OF_ATTACK_POWER = 237
    MOD_SPELL_HEALING_OF_ATTACK_POWER = 238
    MOD_SCALE_2 = 239
    MOD_EXPERTISE = 240
    FORCE_MOVE_FORWARD = 241
    MOD_SPELL_DAMAGE_FROM_HEALING = 242
    MOD_FACTION = 243
    COMPREHEND_LANGUAGE = 244
    MOD_AURA_DURATION_BY_DISPEL = 245
    MOD_AURA_DURATION_BY_DISPEL_NOT_STACK = 246
    CLONE_CASTER = 247
    MOD_COMBAT_RESULT_CHANCE = 248
    CONVERT_RUNE = 249
    MOD_INCREASE_HEALTH_2 = 250
    MOD_ENEMY_DODGE = 251
    MOD_SPEED_SLOW_ALL = 252
    MOD_BLOCK_CRIT_CHANCE = 253
    MOD_DISARM_OFFHAND = 254
    MOD_MECHANIC_DAMAGE_TAKEN_PERCENT = 255
    NO_REAGENT_USE = 256
    MOD_TARGET_RESIST_BY_SPELL_CLASS = 257
    UNKNOWN258 = 258
    MOD_HOT_PCT = 259
    SCREEN_EFFECT = 260
    PHASE = 261
    ABILITY_IGNORE_AURASTATE = 262
    ALLOW_ONLY_ABILITY = 263
    UNKNOWN264 = 264
    UNKNOWN265 = 265
    UNKNOWN266 = 266
    MOD_IMMUNE_AURA_APPLY_SCHOOL = 267
    MOD_ATTACK_POWER_OF_STAT_PERCENT = 268
    MOD_IGNORE_TARGET_RESIST = 269
    MOD_ABILITY_IGNORE_TARGET_RESIST = 270
    MOD_DAMAGE_FROM_CASTER = 271
    IGNORE_MELEE_RESET = 272
    X_RAY = 273
    ABILITY_CONSUME_NO_AMMO = 274
    MOD_IGNORE_SHAPESHIFT = 275
    MOD_DAMAGE_DONE_FOR_MECHANIC = 276
    MOD_MAX_AFFECTED_TARGETS = 277
    MOD_DISARM_RANGED = 278
    INITIALIZE_IMAGES = 279
    MOD_ARMOR_PENETRATION_PCT = 280
    MOD_HONOR_GAIN_PCT = 281
    MOD_BASE_HEALTH_PCT = 282
    MOD_HEALING_RECEIVED = 283
    LINKED = 284
    MOD_ATTACK_POWER_OF_ARMOR = 285
    ABILITY_PERIODIC_CRIT = 286
    DEFLECT_SPELLS = 287
    IGNORE_HIT_DIRECTION = 288
    PREVENT_DURABILITY_LOSS = 289
    MOD_CRIT_PCT = 290
    MOD_XP_QUEST_PCT = 291
    OPEN_STABLE = 292
    OVERRIDE_SPELLS = 293
    PREVENT_REGENERATE_POWER = 294
    UNKNOWN295 = 295
    SET_VEHICLE_ID = 296
    BLOCK_SPELL_FAMILY = 297
    STRANGULATE = 298
    UNKNOWN299 = 299
    SHARE_DAMAGE_PCT = 300
    SCHOOL_HEAL_ABSORB = 301
    UNKNOWN302 = 302
    MOD_DAMAGE_DONE_VERSUS_AURASTATE = 303
    MOD_FAKE_INEBRIATE = 304
    MOD_MINIMUM_SPEED = 305
    UNKNOWN306 = 306
    HEAL_ABSORB_TEST = 307
    MOD_CRIT_CHANCE_FOR_CASTER = 308
    UNKNOWN309 = 309
    MOD_CREATURE_AOE_DAMAGE_AVOIDANCE = 310
    UNKNOWN311 = 311
    UNKNOWN312 = 312
    UNKNOWN313 = 313
    PREVENT_RESURRECTION = 314
    UNDERWATER_WALKING = 315
    PERIODIC_HASTE = 316


class AuraType(enum.Enum):
    NONE = 0
    BIND_SIGHT = 1
    MOD_POSSESS = 2
    PERIODIC_DAMAGE = 3
    DUMMY = 4
    MOD_CONFUSE = 5
    MOD_CHARM = 6
    MOD_FEAR = 7
    PERIODIC_HEAL = 8
    MOD_ATTACKSPEED = 9
    MOD_THREAT = 10
    MOD_TAUNT = 11
    MOD_STUN = 12
    MOD_DAMAGE_DONE = 13
    MOD_DAMAGE_TAKEN = 14
    DAMAGE_SHIELD = 15
    MOD_STEALTH = 16
    MOD_STEALTH_DETECT = 17
    MOD_INVISIBILITY = 18
    MOD_INVISIBILITY_DETECT = 19
    OBS_MOD_HEALTH = 20
    OBS_MOD_POWER = 21
    MOD_RESISTANCE = 22
    PERIODIC_TRIGGER_SPELL = 23
    PERIODIC_ENERGIZE = 24
    MOD_PACIFY = 25
    MOD_ROOT = 26
    MOD_SILENCE = 27
    REFLECT_SPELLS = 28
    MOD_STAT = 29
    MOD_SKILL = 30
    MOD_INCREASE_SPEED = 31
    MOD_INCREASE_MOUNTED_SPEED = 32
    MOD_DECREASE_SPEED = 33
    MOD_INCREASE_HEALTH = 34
    MOD_INCREASE_ENERGY = 35
    MOD_SHAPESHIFT = 36
    EFFECT_IMMUNITY = 37
    STATE_IMMUNITY = 38
    SCHOOL_IMMUNITY = 39
    DAMAGE_IMMUNITY = 40
    DISPEL_IMMUNITY = 41
    PROC_TRIGGER_SPELL = 42
    PROC_TRIGGER_DAMAGE = 43
    TRACK_CREATURES = 44
    TRACK_RESOURCES = 45
    UNKNOWN46 = 46
    MOD_PARRY_PERCENT = 47
    PERIODIC_TRIGGER_SPELL_FROM_CLIENT = 48
    MOD_DODGE_PERCENT = 49
    MOD_CRITICAL_HEALING_AMOUNT = 50
    MOD_BLOCK_PERCENT = 51
    MOD_WEAPON_CRIT_PERCENT = 52
    PERIODIC_LEECH = 53
    MOD_HIT_CHANCE = 54
    MOD_SPELL_HIT_CHANCE = 55
    TRANSFORM = 56
    MOD_SPELL_CRIT_CHANCE = 57
    MOD_INCREASE_SWIM_SPEED = 58
    MOD_DAMAGE_DONE_CREATURE = 59
    MOD_PACIFY_SILENCE = 60
    MOD_SCALE = 61
    PERIODIC_HEALTH_FUNNEL = 62
    UNKNOWN63 = 63
    PERIODIC_MANA_LEECH = 64
    MOD_CASTING_SPEED_NOT_STACK = 65
    FEIGN_DEATH = 66
    MOD_DISARM = 67
    MOD_STALKED = 68
    SCHOOL_ABSORB = 69
    EXTRA_ATTACKS = 70
    MOD_SPELL_CRIT_CHANCE_SCHOOL = 71
    MOD_POWER_COST_SCHOOL_PCT = 72
    MOD_POWER_COST_SCHOOL = 73
    REFLECT_SPELLS_SCHOOL = 74
    MOD_LANGUAGE = 75
    FAR_SIGHT = 76
    MECHANIC_IMMUNITY = 77
    MOUNTED = 78
    MOD_DAMAGE_PERCENT_DONE = 79
    MOD_PERCENT_STAT = 80
    SPLIT_DAMAGE_PCT = 81
    WATER_BREATHING = 82
    MOD_BASE_RESISTANCE = 83
    MOD_REGEN = 84
    MOD_POWER_REGEN = 85
    CHANNEL_DEATH_ITEM = 86
    MOD_DAMAGE_PERCENT_TAKEN = 87
    MOD_HEALTH_REGEN_PERCENT = 88
    PERIODIC_DAMAGE_PERCENT = 89
    UNKNOWN90 = 90
    MOD_DETECT_RANGE = 91
    PREVENTS_FLEEING = 92
    MOD_UNATTACKABLE = 93
    INTERRUPT_REGEN = 94
    GHOST = 95
    SPELL_MAGNET = 96
    MANA_SHIELD = 97
    MOD_SKILL_TALENT = 98
    MOD_ATTACK_POWER = 99
    AURAS_VISIBLE = 100
    MOD_RESISTANCE_PCT = 101
    MOD_MELEE_ATTACK_POWER_VERSUS = 102
    MOD_TOTAL_THREAT = 103
    WATER_WALK = 104
    FEATHER_FALL = 105
    HOVER = 106
    ADD_FLAT_MODIFIER = 107
    ADD_PCT_MODIFIER = 108
    ADD_TARGET_TRIGGER = 109
    MOD_POWER_REGEN_PERCENT = 110
    ADD_CASTER_HIT_TRIGGER = 111
    OVERRIDE_CLASS_SCRIPTS = 112
    MOD_RANGED_DAMAGE_TAKEN = 113
    MOD_RANGED_DAMAGE_TAKEN_PCT = 114
    MOD_HEALING = 115
    MOD_REGEN_DURING_COMBAT = 116
    MOD_MECHANIC_RESISTANCE = 117
    MOD_HEALING_PCT = 118
    UNKNOWN119 = 119
    UNTRACKABLE = 120
    EMPATHY = 121
    MOD_OFFHAND_DAMAGE_PCT = 122
    MOD_TARGET_RESISTANCE = 123
    MOD_RANGED_ATTACK_POWER = 124
    MOD_MELEE_DAMAGE_TAKEN = 125
    MOD_MELEE_DAMAGE_TAKEN_PCT = 126
    RANGED_ATTACK_POWER_ATTACKER_BONUS = 127
    MOD_POSSESS_PET = 128
    MOD_SPEED_ALWAYS = 129
    MOD_MOUNTED_SPEED_ALWAYS = 130
    MOD_RANGED_ATTACK_POWER_VERSUS = 131
    MOD_INCREASE_ENERGY_PERCENT = 132
    MOD_INCREASE_HEALTH_PERCENT = 133
    MOD_MANA_REGEN_INTERRUPT = 134
    MOD_HEALING_DONE = 135
    MOD_HEALING_DONE_PERCENT = 136
    MOD_TOTAL_STAT_PERCENTAGE = 137
    MOD_MELEE_HASTE = 138
    FORCE_REACTION = 139
    MOD_RANGED_HASTE = 140
    MOD_RANGED_AMMO_HASTE = 141
    MOD_BASE_RESISTANCE_PCT = 142
    MOD_RESISTANCE_EXCLUSIVE = 143
    SAFE_FALL = 144
    MOD_PET_TALENT_POINTS = 145
    ALLOW_TAME_PET_TYPE = 146
    MECHANIC_IMMUNITY_MASK = 147
    RETAIN_COMBO_POINTS = 148
    REDUCE_PUSHBACK = 149
    MOD_SHIELD_BLOCKVALUE_PCT = 150
    TRACK_STEALTHED = 151
    MOD_DETECTED_RANGE = 152
    SPLIT_DAMAGE_FLAT = 153
    MOD_STEALTH_LEVEL = 154
    MOD_WATER_BREATHING = 155
    MOD_REPUTATION_GAIN = 156
    PET_DAMAGE_MULTI = 157
    MOD_SHIELD_BLOCKVALUE = 158
    NO_PVP_CREDIT = 159
    MOD_AOE_AVOIDANCE = 160
    MOD_HEALTH_REGEN_IN_COMBAT = 161
    POWER_BURN = 162
    MOD_CRIT_DAMAGE_BONUS = 163
    UNKNOWN164 = 164
    MELEE_ATTACK_POWER_ATTACKER_BONUS = 165
    MOD_ATTACK_POWER_PCT = 166
    MOD_RANGED_ATTACK_POWER_PCT = 167
    MOD_DAMAGE_DONE_VERSUS = 168
    MOD_CRIT_PERCENT_VERSUS = 169
    DETECT_AMORE = 170
    MOD_SPEED_NOT_STACK = 171
    MOD_MOUNTED_SPEED_NOT_STACK = 172
    UNKNOWN173 = 173
    MOD_SPELL_DAMAGE_OF_STAT_PERCENT = 174
    MOD_SPELL_HEALING_OF_STAT_PERCENT = 175
    SPIRIT_OF_REDEMPTION = 176
    AOE_CHARM = 177
    MOD_DEBUFF_RESISTANCE = 178
    MOD_ATTACKER_SPELL_CRIT_CHANCE = 179
    MOD_FLAT_SPELL_DAMAGE_VERSUS = 180
    UNKNOWN181 = 181
    MOD_RESISTANCE_OF_STAT_PERCENT = 182
    MOD_CRITICAL_THREAT = 183
    MOD_ATTACKER_MELEE_HIT_CHANCE = 184
    MOD_ATTACKER_RANGED_HIT_CHANCE = 185
    MOD_ATTACKER_SPELL_HIT_CHANCE = 186
    MOD_ATTACKER_MELEE_CRIT_CHANCE = 187
    MOD_ATTACKER_RANGED_CRIT_CHANCE = 188
    MOD_RATING = 189
    MOD_FACTION_REPUTATION_GAIN = 190
    USE_NORMAL_MOVEMENT_SPEED = 191
    MOD_MELEE_RANGED_HASTE = 192
    MELEE_SLOW = 193
    MOD_TARGET_ABSORB_SCHOOL = 194
    MOD_TARGET_ABILITY_ABSORB_SCHOOL = 195
    MOD_COOLDOWN = 196
    MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE = 197
    UNKNOWN198 = 198
    MOD_INCREASES_SPELL_PCT_TO_HIT = 199
    MOD_XP_PCT = 200
    FLY = 201
    IGNORE_COMBAT_RESULT = 202
    MOD_ATTACKER_MELEE_CRIT_DAMAGE = 203
    MOD_ATTACKER_RANGED_CRIT_DAMAGE = 204
    MOD_SCHOOL_CRIT_DMG_TAKEN = 205
    MOD_INCREASE_VEHICLE_FLIGHT_SPEED = 206
    MOD_INCREASE_MOUNTED_FLIGHT_SPEED = 207
    MOD_INCREASE_FLIGHT_SPEED = 208
    MOD_MOUNTED_FLIGHT_SPEED_ALWAYS = 209
    MOD_VEHICLE_SPEED_ALWAYS = 210
    MOD_FLIGHT_SPEED_NOT_STACK = 211
    MOD_RANGED_ATTACK_POWER_OF_STAT_PERCENT = 212
    MOD_RAGE_FROM_DAMAGE_DEALT = 213
    UNKNOWN214 = 214
    ARENA_PREPARATION = 215
    HASTE_SPELLS = 216
    MOD_MELEE_HASTE_2 = 217
    HASTE_RANGED = 218
    MOD_MANA_REGEN_FROM_STAT = 219
    MOD_RATING_FROM_STAT = 220
    MOD_DETAUNT = 221
    UNKNOWN222 = 222
    RAID_PROC_FROM_CHARGE = 223
    UNKNOWN224 = 224
    RAID_PROC_FROM_CHARGE_WITH_VALUE = 225
    PERIODIC_DUMMY = 226
    PERIODIC_TRIGGER_SPELL_WITH_VALUE = 227
    DETECT_STEALTH = 228
    MOD_AOE_DAMAGE_AVOIDANCE = 229
    UNKNOWN230 = 230
    PROC_TRIGGER_SPELL_WITH_VALUE = 231
    MECHANIC_DURATION_MOD = 232
    CHANGE_MODEL_FOR_ALL_HUMANOIDS = 233
    MECHANIC_DURATION_MOD_NOT_STACK = 234
    MOD_DISPEL_RESIST = 235
    CONTROL_VEHICLE = 236
    MOD_SPELL_DAMAGE_OF_ATTACK_POWER = 237
    MOD_SPELL_HEALING_OF_ATTACK_POWER = 238
    MOD_SCALE_2 = 239
    MOD_EXPERTISE = 240
    FORCE_MOVE_FORWARD = 241
    MOD_SPELL_DAMAGE_FROM_HEALING = 242
    MOD_FACTION = 243
    COMPREHEND_LANGUAGE = 244
    MOD_AURA_DURATION_BY_DISPEL = 245
    MOD_AURA_DURATION_BY_DISPEL_NOT_STACK = 246
    CLONE_CASTER = 247
    MOD_COMBAT_RESULT_CHANCE = 248
    CONVERT_RUNE = 249
    MOD_INCREASE_HEALTH_2 = 250
    MOD_ENEMY_DODGE = 251
    MOD_SPEED_SLOW_ALL = 252
    MOD_BLOCK_CRIT_CHANCE = 253
    MOD_DISARM_OFFHAND = 254
    MOD_MECHANIC_DAMAGE_TAKEN_PERCENT = 255
    NO_REAGENT_USE = 256
    MOD_TARGET_RESIST_BY_SPELL_CLASS = 257
    UNKNOWN258 = 258
    MOD_HOT_PCT = 259
    SCREEN_EFFECT = 260
    PHASE = 261
    ABILITY_IGNORE_AURASTATE = 262
    ALLOW_ONLY_ABILITY = 263
    UNKNOWN264 = 264
    UNKNOWN265 = 265
    UNKNOWN266 = 266
    MOD_IMMUNE_AURA_APPLY_SCHOOL = 267
    MOD_ATTACK_POWER_OF_STAT_PERCENT = 268
    MOD_IGNORE_TARGET_RESIST = 269
    MOD_ABILITY_IGNORE_TARGET_RESIST = 270
    MOD_DAMAGE_FROM_CASTER = 271
    IGNORE_MELEE_RESET = 272
    X_RAY = 273
    ABILITY_CONSUME_NO_AMMO = 274
    MOD_IGNORE_SHAPESHIFT = 275
    MOD_DAMAGE_DONE_FOR_MECHANIC = 276
    MOD_MAX_AFFECTED_TARGETS = 277
    MOD_DISARM_RANGED = 278
    INITIALIZE_IMAGES = 279
    MOD_ARMOR_PENETRATION_PCT = 280
    MOD_HONOR_GAIN_PCT = 281
    MOD_BASE_HEALTH_PCT = 282
    MOD_HEALING_RECEIVED = 283
    LINKED = 284
    MOD_ATTACK_POWER_OF_ARMOR = 285
    ABILITY_PERIODIC_CRIT = 286
    DEFLECT_SPELLS = 287
    IGNORE_HIT_DIRECTION = 288
    PREVENT_DURABILITY_LOSS = 289
    MOD_CRIT_PCT = 290
    MOD_XP_QUEST_PCT = 291
    OPEN_STABLE = 292
    OVERRIDE_SPELLS = 293
    PREVENT_REGENERATE_POWER = 294
    UNKNOWN295 = 295
    SET_VEHICLE_ID = 296
    BLOCK_SPELL_FAMILY = 297
    STRANGULATE = 298
    UNKNOWN299 = 299
    SHARE_DAMAGE_PCT = 300
    SCHOOL_HEAL_ABSORB = 301
    UNKNOWN302 = 302
    MOD_DAMAGE_DONE_VERSUS_AURASTATE = 303
    MOD_FAKE_INEBRIATE = 304
    MOD_MINIMUM_SPEED = 305
    UNKNOWN306 = 306
    HEAL_ABSORB_TEST = 307
    MOD_CRIT_CHANCE_FOR_CASTER = 308
    UNKNOWN309 = 309
    MOD_CREATURE_AOE_DAMAGE_AVOIDANCE = 310
    UNKNOWN311 = 311
    UNKNOWN312 = 312
    UNKNOWN313 = 313
    PREVENT_RESURRECTION = 314
    UNDERWATER_WALKING = 315
    PERIODIC_HASTE = 316


class BankSwapSource(enum.Enum):
    INVENTORY = 0
    BANK = 1


class BankSwapStoreMode(enum.Enum):
    MANUAL = 0
    AUTOMATIC = 1


class BarberShopResult(enum.Enum):
    OK = 0
    NOT_ENOUGH_MONEY = 1
    MUST_BE_SEATED_IN_BARBER_CHAIR = 2
    NOT_ENOUGH_MONEY2 = 3


class BattlefieldListLocation(enum.Enum):
    BATTLEMASTER = 0
    UI = 1


class BattlefieldPortAction(enum.Enum):
    LEAVE_QUEUE = 0
    ENTER_BATTLE = 1


class BattlegroundType(enum.Enum):
    NONE = 0
    ALTERAC_VALLEY = 1
    WARSONG_GULCH = 2
    ARATHI_BASIN = 3
    NAGRAND_ARENA = 4
    BLADES_EDGE_ARENA = 5
    ARENA = 6
    EYE_OF_THE_STORM = 7
    RUINS_OF_LORDAERON = 8
    STRAND_OF_THE_ANCIENT = 9
    DALARAN_SEWERS = 10
    RING_OF_VALOR = 11
    ISLE_OF_CONQUEST = 30
    RANDOM = 32


class BgTypeId(enum.Enum):
    NOT_ELIGIBLE = 0
    QUEUED_FOR_AV = 1
    QUEUED_FOR_WSG = 2
    QUEUED_FOR_AB = 3
    QUEUED_FOR_NETHERSTORM = 4
    QUEUED_FOR_BLADES_EDGE_ARENA = 5
    QUEUED_FOR_ARENA = 6
    QUEUED_FOR_EYE_OF_THE_STORM = 7
    QUEUED_FOR_RUINS_OF_LORDAERON = 8
    QUEUED_FOR_STRAND_OF_THE_ANCIENT = 9
    QUEUED_FOR_DALARAN_SEWERS = 10
    QUEUED_FOR_RING_OF_VALOR = 11
    QUEUED_FOR_ISLE_OF_CONQUEST = 30
    REMOVE_FROM_QUEUE = 4294967294


class Bonding(enum.Enum):
    NO_BIND = 0
    PICK_UP = 1
    EQUIP = 2
    USE = 3
    QUEST_ITEM = 4
    QUEST_ITEM1 = 5


class BuyBankSlotResult(enum.Enum):
    FAILED_TOO_MANY = 0
    INSUFFICIENT_FUNDS = 1
    NOT_BANKER = 2
    OK = 3


class BuyResult(enum.Enum):
    CANT_FIND_ITEM = 0
    ITEM_ALREADY_SOLD = 1
    NOT_ENOUGH_MONEY = 2
    SELLER_DONT_LIKE_YOU = 4
    DISTANCE_TOO_FAR = 5
    ITEM_SOLD_OUT = 7
    CANT_CARRY_MORE = 8
    RANK_REQUIRE = 11
    REPUTATION_REQUIRE = 12


class BuybackSlot(enum.Enum):
    SLOT1 = 69
    SLOT2 = 70
    SLOT3 = 71
    SLOT4 = 72
    SLOT5 = 73
    SLOT6 = 74
    SLOT7 = 75
    SLOT8 = 76
    SLOT9 = 77
    SLOT10 = 78
    SLOT11 = 79
    SLOT12 = 80
    SLOT13 = 81


class CalendarModeratorRank(enum.Enum):
    PLAYER = 0
    MODERATOR = 1
    OWNER = 2


class CalendarStatus(enum.Enum):
    INVITED = 0
    ACCEPTED = 1
    DECLINED = 2
    CONFIRMED = 3
    OUT = 4
    STANDBY = 5
    SIGNED_UP = 6
    NOT_SIGNED_UP = 7
    TENTATIVE = 8
    REMOVED = 9


class CalendarStatusTime(enum.Enum):
    NOT_PRESENT = 0
    PRESENT = 1


class CharterType(enum.Enum):
    GUILD = 0
    ARENA = 1


class ChatNotify(enum.Enum):
    JOINED_NOTICE = 0
    LEFT_NOTICE = 1
    YOU_JOINED_NOTICE = 2
    YOU_LEFT_NOTICE = 3
    WRONG_PASSWORD_NOTICE = 4
    NOT_MEMBER_NOTICE = 5
    NOT_MODERATOR_NOTICE = 6
    PASSWORD_CHANGED_NOTICE = 7
    OWNER_CHANGED_NOTICE = 8
    PLAYER_NOT_FOUND_NOTICE = 9
    NOT_OWNER_NOTICE = 10
    CHANNEL_OWNER_NOTICE = 11
    MODE_CHANGE_NOTICE = 12
    ANNOUNCEMENTS_ON_NOTICE = 13
    ANNOUNCEMENTS_OFF_NOTICE = 14
    MODERATION_ON_NOTICE = 15
    MODERATION_OFF_NOTICE = 16
    MUTED_NOTICE = 17
    PLAYER_KICKED_NOTICE = 18
    BANNED_NOTICE = 19
    PLAYER_BANNED_NOTICE = 20
    PLAYER_UNBANNED_NOTICE = 21
    PLAYER_NOT_BANNED_NOTICE = 22
    PLAYER_ALREADY_MEMBER_NOTICE = 23
    INVITE_NOTICE = 24
    INVITE_WRONG_FACTION_NOTICE = 25
    WRONG_FACTION_NOTICE = 26
    INVALID_NAME_NOTICE = 27
    NOT_MODERATED_NOTICE = 28
    PLAYER_INVITED_NOTICE = 29
    PLAYER_INVITE_BANNED_NOTICE = 30
    THROTTLED_NOTICE = 31
    NOT_IN_AREA_NOTICE = 32
    NOT_IN_LFG_NOTICE = 33
    VOICE_ON_NOTICE = 34
    VOICE_OFF_NOTICE = 35


class ChatRestrictionType(enum.Enum):
    CHAT_RESTRICTED = 0
    CHAT_THROTTLED = 1
    USER_SQUELCHED = 2
    YELL_RESTRICTED = 3


class ChatType(enum.Enum):
    SYSTEM = 0
    SAY = 1
    PARTY = 2
    RAID = 3
    GUILD = 4
    OFFICER = 5
    YELL = 6
    WHISPER = 7
    WHISPER_FOREIGN = 8
    WHISPER_INFORM = 9
    EMOTE = 10
    TEXT_EMOTE = 11
    MONSTER_SAY = 12
    MONSTER_PARTY = 13
    MONSTER_YELL = 14
    MONSTER_WHISPER = 15
    MONSTER_EMOTE = 16
    CHANNEL = 17
    CHANNEL_JOIN = 18
    CHANNEL_LEAVE = 19
    CHANNEL_LIST = 20
    CHANNEL_NOTICE = 21
    CHANNEL_NOTICE_USER = 22
    AFK = 23
    DND = 24
    IGNORED = 25
    SKILL = 26
    LOOT = 27
    MONEY = 28
    OPENING = 29
    TRADESKILLS = 30
    PET_INFO = 31
    COMBAT_MISC_INFO = 32
    COMBAT_XP_GAIN = 33
    COMBAT_HONOR_GAIN = 34
    COMBAT_FACTION_CHANGE = 35
    BG_SYSTEM_NEUTRAL = 36
    BG_SYSTEM_ALLIANCE = 37
    BG_SYSTEM_HORDE = 38
    RAID_LEADER = 39
    RAID_WARNING = 40
    RAID_BOSS_EMOTE = 41
    RAID_BOSS_WHISPER = 42
    FILTERED = 43
    BATTLEGROUND = 44
    BATTLEGROUND_LEADER = 45
    RESTRICTED = 46
    BATTLENET = 47
    ACHIEVEMENT = 48
    GUILD_ACHIEVEMENT = 49
    ARENA_POINTS = 50
    PARTY_LEADER = 51


class CinematicSequenceId(enum.Enum):
    GOBLIN = 0
    PALANTIR_OF_AZORA = 1
    UNDEAD = 2
    ORC = 21
    DWARF = 41
    NIGHT_ELF = 61
    HUMAN = 81
    GNOME = 101
    TROLL = 121
    TAUREN = 141
    SCRY_CAM = 161
    BLOOD_ELF = 162
    DRAENEI = 163
    SUNWELL_FIVE_MAN = 164
    DEATH_KNIGHT = 165


class Class(enum.Enum):
    WARRIOR = 1
    PALADIN = 2
    HUNTER = 3
    ROGUE = 4
    PRIEST = 5
    DEATH_KNIGHT = 6
    SHAMAN = 7
    MAGE = 8
    WARLOCK = 9
    DRUID = 11


class ClientCastFlags(enum.Enum):
    NONE = 0
    EXTRA = 2


class ClientMovementData(enum.Enum):
    NOT_PRESENT = 0
    PRESENT = 1


class CommentatorEnableOption(enum.Enum):
    DISABLE = 0
    ENABLE = 1
    TOGGLE = 2


class ComplainResultWindow(enum.Enum):
    DO_NOT_SHOW = 0
    SHOW = 1


class ComplaintStatus(enum.Enum):
    DISABLED = 0
    ENABLED_WITHOUT_AUTO_IGNORE = 1
    ENABLED_WITH_AUTO_IGNORE = 2


class CorpseQueryResult(enum.Enum):
    NOT_FOUND = 0
    FOUND = 1


class CreatureFamily(enum.Enum):
    NONE = 0
    WOLF = 1
    CAT = 2
    SPIDER = 3
    BEAR = 4
    BOAR = 5
    CROCOLISK = 6
    CARRION_BIRD = 7
    CRAB = 8
    GORILLA = 9
    RAPTOR = 11
    TALLSTRIDER = 12
    FELHUNTER = 15
    VOIDWALKER = 16
    SUCCUBUS = 17
    DOOMGUARD = 19
    SCORPID = 20
    TURTLE = 21
    IMP = 23
    BAT = 24
    HYENA = 25
    BIRD_OF_PREY = 26
    WIND_SERPENT = 27
    REMOTE_CONTROL = 28
    FELGUARD = 29
    DRAGONHAWK = 30
    RAVAGER = 31
    WARP_STALKER = 32
    SPOREBAT = 33
    NETHER_RAY = 34
    SERPENT = 35
    MOTH = 37
    CHIMAERA = 38
    DEVILSAUR = 39
    GHOUL = 40
    SILITHID = 41
    WORM = 42
    RHINO = 43
    WASP = 44
    CORE_HOUND = 45
    SPIRIT_BEAST = 46


class DeclinedNames(enum.Enum):
    NO = 0
    YES = 1


class DeclinedPetNameIncluded(enum.Enum):
    NOT_INCLUDED = 0
    INCLUDED = 1


class DispelMethod(enum.Enum):
    DISPELLED = 0
    CLEANSED = 1


class DuelWinnerReason(enum.Enum):
    WON = 0
    FLED = 1


class DungeonDifficulty(enum.Enum):
    NORMAL = 0
    HEROIC = 1


class Emote(enum.Enum):
    ONESHOT_NONE = 0
    ONESHOT_TALK = 1
    ONESHOT_BOW = 2
    ONESHOT_WAVE = 3
    ONESHOT_CHEER = 4
    ONESHOT_EXCLAMATION = 5
    ONESHOT_QUESTION = 6
    ONESHOT_EAT = 7
    STATE_DANCE = 10
    ONESHOT_LAUGH = 11
    STATE_SLEEP = 12
    STATE_SIT = 13
    ONESHOT_RUDE = 14
    ONESHOT_ROAR = 15
    ONESHOT_KNEEL = 16
    ONESHOT_KISS = 17
    ONESHOT_CRY = 18
    ONESHOT_CHICKEN = 19
    ONESHOT_BEG = 20
    ONESHOT_APPLAUD = 21
    ONESHOT_SHOUT = 22
    ONESHOT_FLEX = 23
    ONESHOT_SHY = 24
    ONESHOT_POINT = 25
    STATE_STAND = 26
    STATE_READY_UNARMED = 27
    STATE_WORK_SHEATHED = 28
    STATE_POINT = 29
    STATE_NONE = 30
    ONESHOT_WOUND = 33
    ONESHOT_WOUND_CRITICAL = 34
    ONESHOT_ATTACK_UNARMED = 35
    ONESHOT_ATTACK1H = 36
    ONESHOT_ATTACK2HTIGHT = 37
    ONESHOT_ATTACK2H_LOOSE = 38
    ONESHOT_PARRY_UNARMED = 39
    ONESHOT_PARRY_SHIELD = 43
    ONESHOT_READY_UNARMED = 44
    ONESHOT_READY1H = 45
    ONESHOT_READY_BOW = 48
    ONESHOT_SPELL_PRECAST = 50
    ONESHOT_SPELL_CAST = 51
    ONESHOT_BATTLE_ROAR = 53
    ONESHOT_SPECIALATTACK1H = 54
    ONESHOT_KICK = 60
    ONESHOT_ATTACK_THROWN = 61
    STATE_STUN = 64
    STATE_DEAD = 65
    ONESHOT_SALUTE = 66
    STATE_KNEEL = 68
    STATE_USE_STANDING = 69
    ONESHOT_WAVE_NO_SHEATHE = 70
    ONESHOT_CHEER_NO_SHEATHE = 71
    ONESHOT_EAT_NO_SHEATHE = 92
    STATE_STUN_NO_SHEATHE = 93
    ONESHOT_DANCE = 94
    ONESHOT_SALUTE_NO_SHEATH = 113
    STATE_USE_STANDING_NO_SHEATHE = 133
    ONESHOT_LAUGH_NO_SHEATHE = 153
    STATE_WORK = 173
    STATE_SPELL_PRECAST = 193
    ONESHOT_READY_RIFLE = 213
    STATE_READY_RIFLE = 214
    STATE_WORK_MINING = 233
    STATE_WORK_CHOPWOOD = 234
    STATE_APPLAUD = 253
    ONESHOT_LIFTOFF = 254
    ONESHOT_YES = 273
    ONESHOT_NO = 274
    ONESHOT_TRAIN = 275
    ONESHOT_LAND = 293
    STATE_AT_EASE = 313
    STATE_READY1H = 333
    STATE_SPELL_KNEEL_START = 353
    STATE_SUBMERGED = 373
    ONESHOT_SUBMERGE = 374
    STATE_READY2H = 375
    STATE_READY_BOW = 376
    ONESHOT_MOUNT_SPECIAL = 377
    STATE_TALK = 378
    STATE_FISHING = 379
    ONESHOT_FISHING = 380
    ONESHOT_LOOT = 381
    STATE_WHIRLWIND = 382
    STATE_DROWNED = 383
    STATE_HOLD_BOW = 384
    STATE_HOLD_RIFLE = 385
    STATE_HOLD_THROWN = 386
    ONESHOT_DROWN = 387
    ONESHOT_STOMP = 388
    ONESHOT_ATTACK_OFF = 389
    ONESHOT_ATTACK_OFF_PIERCE = 390
    STATE_ROAR = 391
    STATE_LAUGH = 392
    ONESHOT_CREATURE_SPECIAL = 393
    ONESHOT_JUMPLANDRUN = 394
    ONESHOT_JUMPEND = 395
    ONESHOT_TALK_NO_SHEATHE = 396
    ONESHOT_POINT_NO_SHEATHE = 397
    STATE_CANNIBALIZE = 398
    ONESHOT_JUMPSTART = 399
    STATE_DANCESPECIAL = 400
    ONESHOT_DANCESPECIAL = 401
    ONESHOT_CUSTOM_SPELL_01 = 402
    ONESHOT_CUSTOM_SPELL_02 = 403
    ONESHOT_CUSTOM_SPELL_03 = 404
    ONESHOT_CUSTOM_SPELL_04 = 405
    ONESHOT_CUSTOM_SPELL_05 = 406
    ONESHOT_CUSTOM_SPELL_06 = 407
    ONESHOT_CUSTOM_SPELL_07 = 408
    ONESHOT_CUSTOM_SPELL_08 = 409
    ONESHOT_CUSTOM_SPELL_09 = 410
    ONESHOT_CUSTOM_SPELL_10 = 411
    STATE_EXCLAIM = 412
    STATE_DANCE_CUSTOM = 413
    STATE_SIT_CHAIR_MED = 415
    STATE_CUSTOM_SPELL_01 = 416
    STATE_CUSTOM_SPELL_02 = 417
    STATE_EAT = 418
    STATE_CUSTOM_SPELL_04 = 419
    STATE_CUSTOM_SPELL_03 = 420
    STATE_CUSTOM_SPELL_05 = 421
    STATE_SPELLEFFECT_HOLD = 422
    STATE_EAT_NO_SHEATHE = 423
    STATE_MOUNT = 424
    STATE_READY2HL = 425
    STATE_SIT_CHAIR_HIGH = 426
    STATE_FALL = 427
    STATE_LOOT = 428
    STATE_SUBMERGED_NEW = 429
    ONESHOT_COWER = 430
    STATE_COWER = 431
    ONESHOT_USE_STANDING = 432
    STATE_STEALTH_STAND = 433
    ONESHOT_OMNICAST_GHOUL = 434
    ONESHOT_ATTACK_BOW = 435
    ONESHOT_ATTACK_RIFLE = 436
    STATE_SWIM_IDLE = 437
    STATE_ATTACK_UNARMED = 438
    ONESHOT_SPELL_CAST_W_SOUND = 439
    ONESHOT_DODGE = 440
    ONESHOT_PARRY1H = 441
    ONESHOT_PARRY2H = 442
    ONESHOT_PARRY2HL = 443
    STATE_FLYFALL = 444
    ONESHOT_FLYDEATH = 445
    STATE_FLY_FALL = 446
    ONESHOT_FLY_SIT_GROUND_DOWN = 447
    ONESHOT_FLY_SIT_GROUND_UP = 448
    ONESHOT_EMERGE = 449
    ONESHOT_DRAGON_SPIT = 450
    STATE_SPECIAL_UNARMED = 451
    ONESHOT_FLYGRAB = 452
    STATE_FLYGRABCLOSED = 453
    ONESHOT_FLYGRABTHROWN = 454
    STATE_FLY_SIT_GROUND = 455
    STATE_WALK_BACKWARDS = 456
    ONESHOT_FLYTALK = 457
    ONESHOT_FLYATTACK1H = 458
    STATE_CUSTOM_SPELL_08 = 459
    ONESHOT_FLY_DRAGON_SPIT = 460
    STATE_SIT_CHAIR_LOW = 461
    ONESHOT_STUN = 462
    ONESHOT_SPELL_CAST_OMNI = 463
    STATE_READY_THROWN = 465
    ONESHOT_WORK_CHOPWOOD = 466
    ONESHOT_WORK_MINING = 467
    STATE_SPELL_CHANNEL_OMNI = 468
    STATE_SPELL_CHANNEL_DIRECTED = 469
    STAND_STATE_NONE = 470
    STATE_READYJOUST = 471
    STATE_STRANGULATE = 473
    STATE_READY_SPELL_OMNI = 474
    STATE_HOLD_JOUST = 475
    ONESHOT_CRY_JAINA = 476


class EncounterFrame(enum.Enum):
    ENGAGE = 0
    DISENGAGE = 1
    UPDATE_PRIORITY = 2
    ADD_TIMER = 3
    ENABLE_OBJECTIVE = 4
    UPDATE_OBJECTIVE = 5
    DISABLE_OBJECTIVE = 6
    REFRESH_FRAMES = 7


class EnvironmentalDamageType(enum.Enum):
    EXHAUSTED = 0
    DROWNING = 1
    FALL = 2
    LAVA = 3
    SLIME = 4
    FIRE = 5


class Expansion(enum.Enum):
    VANILLA = 0
    THE_BURNING_CRUSADE = 1
    WRATH_OF_THE_LICH_KING = 2


class ExperienceAwardType(enum.Enum):
    KILL = 0
    NON_KILL = 1


class Faction(enum.Enum):
    NONE = 0
    PLAYER_HUMAN = 1
    PLAYER_ORC = 2
    PLAYER_DWARF = 3
    PLAYER_NIGHT_ELF = 4
    PLAYER_UNDEAD = 5
    PLAYER_TAUREN = 6
    CREATURE = 7
    PLAYER_GNOME = 8
    PLAYER_TROLL = 9
    MONSTER = 14
    DEFIAS_BROTHERHOOD = 15
    GNOLL_RIVERPAW = 16
    GNOLL_REDRIDGE = 17
    GNOLL_SHADOWHIDE = 18
    MURLOC = 19
    UNDEAD_SCOURGE = 20
    BOOTY_BAY = 21
    BEAST_SPIDER = 22
    BEAST_BOAR = 23
    WORGEN = 24
    KOBOLD = 25
    TROLL_BLOODSCALP = 26
    TROLL_SKULLSPLITTER = 27
    PREY = 28
    BEAST_WOLF = 29
    DEFIAS_BROTHERHOOD_TRAITOR = 30
    FRIENDLY = 31
    TROGG = 32
    TROLL_FROSTMANE = 33
    ORC_BLACKROCK = 34
    VILLIAN = 35
    VICTIM = 36
    BEAST_BEAR = 37
    OGRE = 38
    KURZENS_MERCENARIES = 39
    ESCORTEE = 40
    VENTURE_COMPANY = 41
    BEAST_RAPTOR = 42
    BASILISK = 43
    DRAGONFLIGHT_GREEN = 44
    LOST_ONES = 45
    BLACKSMITHING_ARMORSMITHING = 46
    IRONFORGE = 47
    DARK_IRON_DWARVES = 48
    HUMAN_NIGHT_WATCH = 49
    DRAGONFLIGHT_RED = 50
    GNOLL_MOSSHIDE = 51
    ORC_DRAGONMAW = 52
    GNOME_LEPER = 53
    GNOMEREGAN_EXILES = 54
    LEOPARD = 55
    SCARLET_CRUSADE = 56
    GNOLL_ROTHIDE = 57
    BEAST_GORILLA = 58
    THORIUM_BROTHERHOOD = 59
    NAGA = 60
    DALARAN = 61
    FORLORN_SPIRIT = 62
    DARKHOWL = 63
    GRELL = 64
    FURBOLG = 65
    HORDE_GENERIC = 66
    HORDE = 67
    UNDERCITY = 68
    DARNASSUS = 69
    SYNDICATE = 70
    HILLSBRAD_MILITIA = 71
    STORMWIND = 72
    DEMON = 73
    ELEMENTAL = 74
    SPIRIT = 75
    ORGRIMMAR = 76
    TREASURE = 77
    GNOLL_MUDSNOUT = 78
    HILLSBRAD_SOUTHSHORE_MAYOR = 79
    DRAGONFLIGHT_BLACK = 80
    THUNDER_BLUFF = 81
    TROLL_WITHERBARK = 82
    LEATHERWORKING_ELEMENTAL = 83
    QUILBOAR_RAZORMANE = 84
    QUILBOAR_BRISTLEBACK = 85
    LEATHERWORKING_DRAGONSCALE = 86
    BLOODSAIL_BUCCANEERS = 87
    BLACKFATHOM = 88
    MAKRURA = 89
    CENTAUR_KOLKAR = 90
    CENTAUR_GALAK = 91
    GELKIS_CLAN_CENTAUR = 92
    MAGRAM_CLAN_CENTAUR = 93
    MARAUDINE = 94
    THERAMORE = 108
    QUILBOAR_RAZORFEN = 109
    QUILBOAR_RAZORMANE_2 = 110
    QUILBOAR_DEATHSHEAD = 111
    ENEMY = 128
    AMBIENT = 148
    NETHERGARDE_CARAVAN = 168
    STEAMWHEEDLE_CARTEL = 169
    ALLIANCE_GENERIC = 189
    NETHERGARDE = 209
    WAILING_CAVERNS = 229
    SILITHID = 249
    SILVERMOON_REMNANT = 269
    ZANDALAR_TRIBE = 270
    BLACKSMITHING_WEAPONSMITHING = 289
    SCORPID = 309
    BEAST_BAT = 310
    TITAN = 311
    TASKMASTER_FIZZULE = 329
    RAVENHOLDT = 349
    GADGETZAN = 369
    GNOMEREGAN_BUG = 389
    HARPY = 409
    BURNING_BLADE = 429
    SHADOWSILK_POACHER = 449
    SEARING_SPIDER = 450
    ALLIANCE = 469
    RATCHET = 470
    WILDHAMMER_CLAN = 471
    GOBLIN_DARK_IRON_BAR_PATRON = 489
    THE_LEAGUE_OF_ARATHOR = 509
    THE_DEFILERS = 510
    GIANT = 511
    ARGENT_DAWN = 529
    DARKSPEAR_TROLLS = 530
    DRAGONFLIGHT_BRONZE = 531
    DRAGONFLIGHT_BLUE = 532
    LEATHERWORKING_TRIBAL = 549
    ENGINEERING_GOBLIN = 550
    ENGINEERING_GNOME = 551
    BLACKSMITHING_HAMMERSMITHING = 569
    BLACKSMITHING_AXESMITHING = 570
    BLACKSMITHING_SWORDSMITHING = 571
    TROLL_VILEBRANCH = 572
    SOUTHSEA_FREEBOOTERS = 573
    CAER_DARROW = 574
    FURBOLG_UNCORRUPTED = 575
    TIMBERMAW_HOLD = 576
    EVERLOOK = 577
    WINTERSABER_TRAINERS = 589
    CENARION_CIRCLE = 609
    SHATTERSPEAR_TROLLS = 629
    RAVASAUR_TRAINERS = 630
    MAJORDOMO_EXECUTUS = 649
    BEAST_CARRION_BIRD = 669
    BEAST_CAT = 670
    BEAST_CRAB = 671
    BEAST_CROCILISK = 672
    BEAST_HYENA = 673
    BEAST_OWL = 674
    BEAST_SCORPID = 675
    BEAST_TALLSTRIDER = 676
    BEAST_TURTLE = 677
    BEAST_WIND_SERPENT = 678
    TRAINING_DUMMY = 679
    DRAGONFLIGHT_BLACK_BAIT = 689
    BATTLEGROUND_NEUTRAL = 709
    FROSTWOLF_CLAN = 729
    STORMPIKE_GUARD = 730
    HYDRAXIAN_WATERLORDS = 749
    SULFURON_FIRELORDS = 750
    GIZLOCKS_DUMMY = 769
    GIZLOCKS_CHARM = 770
    GIZLOCK = 771
    MORO_GAI = 789
    SPIRIT_GUIDE_ALLIANCE = 790
    SHEN_DRALAR = 809
    OGRE_CAPTAIN_KROMCRUSH = 829
    SPIRIT_GUIDE_HORDE = 849
    JAEDENAR = 869
    WARSONG_OUTRIDERS = 889
    SILVERWING_SENTINELS = 890
    ALLIANCE_FORCES = 891
    HORDE_FORCES = 892
    REVANTUSK_TROLLS = 893
    DARKMOON_FAIRE = 909
    BROOD_OF_NOZDORMU = 910
    SILVERMOON_CITY = 911
    MIGHT_OF_KALIMDOR = 912
    PLAYER_BLOOD_ELF = 914
    ARMIES_OF_C_THUN = 915
    SILITHID_ATTACKERS = 916
    THE_IRONFORGE_BRIGADE = 917
    RC_ENEMIES = 918
    RC_OBJECTS = 919
    RED = 920
    BLUE = 921
    TRANQUILLIEN = 922
    FARSTRIDERS = 923
    DEPRECATED = 924
    SUNSTRIDERS = 925
    MAGISTERS_GUILD = 926
    PLAYER_DRAENEI = 927
    SCOURGE_INVADERS = 928
    BLOODMAUL_CLAN = 929
    EXODAR = 930
    TEST_FACTION_NOT_A_REAL_FACTION = 931
    THE_ALDOR = 932
    THE_CONSORTIUM = 933
    THE_SCRYERS = 934
    THE_SHA_TAR = 935
    SHATTRATH_CITY = 936
    TROLL_FOREST = 937
    THE_OMENAI = 938
    DEPRECATED1 = 939
    THE_SONS_OF_LOTHAR = 940
    THE_MAG_HAR = 941
    CENARION_EXPEDITION = 942
    FEL_ORC = 943
    FEL_ORC_GHOST = 944
    SONS_OF_LOTHAR_GHOSTS = 945
    HONOR_HOLD = 946
    THRALLMAR = 947
    TEST_FACTION_2 = 948
    TEST_FACTION_1 = 949
    TOWOW_FLAG = 950
    TOWOW_FLAG_TRIGGER_ALLIANCE_DND = 951
    TEST_FACTION_3 = 952
    TEST_FACTION_4 = 953
    TOWOW_FLAG_TRIGGER_HORDE_DND = 954
    BROKEN = 955
    ETHEREUM = 956
    EARTH_ELEMENTAL = 957
    FIGHTING_ROBOTS = 958
    ACTOR_GOOD = 959
    ACTOR_EVIL = 960
    STILLPINE_FURBOLG = 961
    CRAZED_OWLKIN = 962
    CHESS_ALLIANCE = 963
    CHESS_HORDE = 964
    MONSTER_SPAR = 965
    MONSTER_SPAR_BUDDY = 966
    THE_VIOLET_EYE = 967
    SUNHAWKS = 968
    HAND_OF_ARGUS = 969
    SPOREGGAR = 970
    FUNGAL_GIANT = 971
    SPORE_BAT = 972
    MONSTER_PREDATOR = 973
    MONSTER_PREY = 974
    VOID_ANOMALY = 975
    HYJAL_DEFENDERS = 976
    HYJAL_INVADERS = 977
    KURENAI = 978
    EARTHEN_RING = 979
    THE_BURNING_CRUSADE = 980
    ARAKKOA = 981
    ZANGARMARSH_BANNER_ALLIANCE = 982
    ZANGARMARSH_BANNER_HORDE = 983
    ZANGARMARSH_BANNER_NEUTRAL = 984
    CAVERNS_OF_TIME_THRALL = 985
    CAVERNS_OF_TIME_DURNHOLDE = 986
    CAVERNS_OF_TIME_SOUTHSHORE_GUARDS = 987
    SHADOW_COUNCIL_COVERT = 988
    KEEPERS_OF_TIME = 989
    THE_SCALE_OF_THE_SANDS = 990
    DARK_PORTAL_DEFENDER_ALLIANCE = 991
    DARK_PORTAL_DEFENDER_HORDE = 992
    DARK_PORTAL_ATTACKER_LEGION = 993
    INCITER_TRIGGER = 994
    INCITER_TRIGGER_2 = 995
    INCITER_TRIGGER_3 = 996
    INCITER_TRIGGER_4 = 997
    INCITER_TRIGGER_5 = 998
    MANA_CREATURE = 999
    KHADGARS_SERVANT = 1000
    BLADESPIRE_CLAN = 1001
    ETHEREUM_SPARBUDDY = 1002
    PROTECTORATE = 1003
    ARCANE_ANNIHILATOR_DNR = 1004
    FRIENDLY_HIDDEN = 1005
    KIRIN_VAR_DATHRIC = 1006
    KIRIN_VAR_BELMARA = 1007
    KIRIN_VAR_LUMINRATH = 1008
    KIRIN_VAR_COHLIEN = 1009
    SERVANT_OF_ILLIDAN = 1010
    LOWER_CITY = 1011
    ASHTONGUE_DEATHSWORN = 1012
    SPIRITS_OF_SHADOWMOON_1 = 1013
    SPIRITS_OF_SHADOWMOON_2 = 1014
    NETHERWING = 1015
    WYRMCULT = 1016
    TREANT = 1017
    LEOTHERAS_DEMON_I = 1018
    LEOTHERAS_DEMON_II = 1019
    LEOTHERAS_DEMON_III = 1020
    LEOTHERAS_DEMON_IV = 1021
    LEOTHERAS_DEMON_V = 1022
    AZALOTH = 1023
    ROCK_FLAYER = 1024
    FLAYER_HUNTER = 1025
    SHADOWMOON_SHADE = 1026
    LEGION_COMMUNICATOR = 1027
    RAVENSWOOD_ANCIENTS = 1028
    CHESS_FRIENDLY_TO_ALL_CHESS = 1029
    BLACK_TEMPLE_GATES_ILLIDARI = 1030
    SHA_TARI_SKYGUARD = 1031
    AREA_52 = 1032
    MAIEV = 1033
    SKETTIS_SHADOWY_ARAKKOA = 1034
    SKETTIS_ARAKKOA = 1035
    DRAGONMAW_ENEMY = 1036
    ALLIANCE_VANGUARD = 1037
    OGRI_LA = 1038
    RAVAGER = 1039
    REUSE = 1040
    FRENZY = 1041
    SKYGUARD_ENEMY = 1042
    SKUNK_PETUNIA = 1043
    THERAMORE_DESERTER = 1044
    VRYKUL = 1045
    NORTHSEA_PIRATES = 1046
    TUSKARR = 1047
    UNUSED = 1048
    TROLL_AMANI = 1049
    VALIANCE_EXPEDITION = 1050
    UNUSED1 = 1051
    HORDE_EXPEDITION = 1052
    WESTGUARD = 1053
    SPOTTED_GRYPHON = 1054
    TAMED_PLAGUEHOUND = 1055
    VRYKUL_ANCIENT_SPIRIT_1 = 1056
    VRYKUL_ANCIENT_SIPRIT_2 = 1057
    VRYKUL_ANCIENT_SIPRIT_3 = 1058
    CTF_FLAG_ALLIANCE = 1059
    TEST = 1060
    VRYKUL1 = 1061
    VRYKUL_GLADIATOR = 1062
    VALGARDE_COMBATANT = 1063
    THE_TAUNKA = 1064
    MONSTER_ZONE_FORCE_REACTION_1 = 1065
    MONSTER_ZONE_FORCE_REACTION_2 = 1066
    THE_HAND_OF_VENGEANCE = 1067
    EXPLORERS__LEAGUE = 1068
    RAM_RACING_POWERUP_DND = 1069
    RAM_RACING_TRAP_DND = 1070
    CRAIGS_SQUIRRELS = 1071
    REUSE1 = 1072
    THE_KALU_AK = 1073
    HOLIDAY_WATER_BARREL = 1074
    HOLIDAY_GENERIC = 1075
    IRON_DWARVES = 1076
    SHATTERED_SUN_OFFENSIVE = 1077
    FIGHTING_VANITY_PET = 1078
    MURLOC_WINTERFIN = 1079
    FRIENDLY_FORCE_REACTION = 1080
    OBJECT_FORCE_REACTION = 1081
    REUSE2 = 1082
    REUSE4 = 1083
    VRYKUL_SEA = 1084
    WARSONG_OFFENSIVE = 1085
    POACHER = 1086
    HOLIDAY_MONSTER = 1087
    FURBOLG_REDFANG = 1088
    FURBOLG_FROSTPAW = 1089
    KIRIN_TOR = 1090
    THE_WYRMREST_ACCORD = 1091
    AZJOL_NERUB = 1092
    REUSE8 = 1093
    THE_SILVER_COVENANT = 1094
    GRIZZLY_HILLS_TRAPPER = 1095
    REUSE16 = 1096
    WRATH_OF_THE_LICH_KING = 1097
    KNIGHTS_OF_THE_EBON_BLADE = 1098
    WRATHGATE_SCOURGE = 1099
    WRATHGATE_ALLIANCE = 1100
    WRATHGATE_HORDE = 1101
    CTF_FLAG_HORDE = 1102
    CTF_FLAG_NEUTRAL = 1103
    FRENZYHEART_TRIBE = 1104
    THE_ORACLES = 1105
    ARGENT_CRUSADE = 1106
    TROLL_DRAKKARI = 1107
    COT_ARTHAS = 1108
    COT_STRATHOLME_CITIZEN = 1109
    COT_SCOURGE = 1110
    FREYA = 1111
    MOUNT_TAXI_ALLIANCE = 1112
    MOUNT_TAXI_HORDE = 1113
    MOUNT_TAXI_NEUTRAL = 1114
    ELEMENTAL_WATER = 1115
    ELEMENTAL_AIR = 1116
    SHOLAZAR_BASIN = 1117
    CLASSIC = 1118
    THE_SONS_OF_HODIR = 1119
    IRON_GIANTS = 1120
    FROST_VRYKUL = 1121
    EARTHEN = 1122
    MONSTER_REFEREE = 1123
    THE_SUNREAVERS = 1124
    HYLDSMEET = 1125
    THE_FROSTBORN = 1126
    ORGRIMMAR_ALEX_TEST = 1127
    TRANQUILLIEN_CONVERSION = 1136
    WINTERSABER_CONVERSION = 1137
    HATES_EVERYTHING = 1145
    SILVER_COVENANT_CONVERSION = 1154
    SUNREAVERS_CONVERSION = 1155
    THE_ASHEN_VERDICT = 1156
    CTF_FLAG_ALLIANCE_2 = 1159
    CTF_FLAG_HORDE_2 = 1160


class FarSightOperation(enum.Enum):
    REMOVE = 0
    ADD = 1


class FriendResult(enum.Enum):
    DB_ERROR = 0
    LIST_FULL = 1
    ONLINE = 2
    OFFLINE = 3
    NOT_FOUND = 4
    REMOVED = 5
    ADDED_ONLINE = 6
    ADDED_OFFLINE = 7
    ALREADY = 8
    SELF = 9
    ENEMY = 10
    IGNORE_FULL = 11
    IGNORE_SELF = 12
    IGNORE_NOT_FOUND = 13
    IGNORE_ALREADY = 14
    IGNORE_ADDED = 15
    IGNORE_REMOVED = 16


class FriendStatus(enum.Enum):
    OFFLINE = 0
    ONLINE = 1
    AFK = 2
    UNKNOWN3 = 3
    DND = 4


class Gender(enum.Enum):
    MALE = 0
    FEMALE = 1
    NONE = 2


class GmTicketEscalationStatus(enum.Enum):
    GMTICKET_ASSIGNEDTOGM_STATUS_NOT_ASSIGNED = 0
    GMTICKET_ASSIGNEDTOGM_STATUS_ASSIGNED = 1
    GMTICKET_ASSIGNEDTOGM_STATUS_ESCALATED = 2


class GmTicketQueueStatus(enum.Enum):
    ENABLED = 1
    DISABLED = 0


class GmTicketResponse(enum.Enum):
    NOT_EXIST = 0
    ALREADY_EXIST = 1
    CREATE_SUCCESS = 2
    CREATE_ERROR = 3
    UPDATE_SUCCESS = 4
    UPDATE_ERROR = 5
    TICKET_DELETED = 9


class GmTicketStatus(enum.Enum):
    DB_ERROR = 0
    HAS_TEXT = 6
    DEFAULT = 10


class GmTicketStatusResponse(enum.Enum):
    UPDATED = 1
    CLOSED = 2
    SURVEY = 3


class GroupLootSetting(enum.Enum):
    FREE_FOR_ALL = 0
    ROUND_ROBIN = 1
    MASTER_LOOT = 2
    GROUP_LOOT = 3
    NEED_BEFORE_GREED = 4


class GuildBankContentResult(enum.Enum):
    NOT_PRESENT = 0
    PRESENT = 1


class GuildBankTabResult(enum.Enum):
    NOT_PRESENT = 0
    PRESENT = 1


class GuildCommand(enum.Enum):
    CREATE = 0
    INVITE = 1
    QUIT = 2
    PROMOTE = 3
    FOUNDER = 12
    MEMBER = 13
    PUBLIC_NOTE_CHANGED = 19
    OFFICER_NOTE_CHANGED = 20


class GuildCommandResult(enum.Enum):
    PLAYER_NO_MORE_IN_GUILD = 0
    GUILD_INTERNAL = 1
    ALREADY_IN_GUILD = 2
    ALREADY_IN_GUILD_S = 3
    INVITED_TO_GUILD = 4
    ALREADY_INVITED_TO_GUILD_S = 5
    GUILD_NAME_INVALID = 6
    GUILD_NAME_EXISTS_S = 7
    GUILD_LEADER_LEAVE_OR_PERMISSIONS = 8
    GUILD_PLAYER_NOT_IN_GUILD = 9
    GUILD_PLAYER_NOT_IN_GUILD_S = 10
    GUILD_PLAYER_NOT_FOUND_S = 11
    GUILD_NOT_ALLIED = 12
    GUILD_RANK_TOO_HIGH_S = 13
    GUILD_RANK_TOO_LOW_S = 14
    GUILD_RANKS_LOCKED = 17
    GUILD_RANK_IN_USE = 18
    GUILD_IGNORING_YOU_S = 19
    GUILD_UNK1 = 20
    GUILD_WITHDRAW_LIMIT = 25
    GUILD_NOT_ENOUGH_MONEY = 26
    GUILD_BANK_FULL = 28
    GUILD_ITEM_NOT_FOUND = 29


class GuildEmblemResult(enum.Enum):
    SUCCESS = 0
    INVALID_TABARD_COLORS = 1
    NO_GUILD = 2
    NOT_GUILD_MASTER = 3
    NOT_ENOUGH_MONEY = 4
    INVALID_VENDOR = 5


class GuildEvent(enum.Enum):
    PROMOTION = 0
    DEMOTION = 1
    MOTD = 2
    JOINED = 3
    LEFT = 4
    REMOVED = 5
    LEADER_IS = 6
    LEADER_CHANGED = 7
    DISBANDED = 8
    TABARD_CHANGED = 9
    UNK1 = 10
    UNK2 = 11
    SIGNED_ON = 12
    SIGNED_OFF = 13
    GUILD_BANK_BAG_SLOTS_CHANGED = 14
    BANKTAB_PURCHASED = 15
    UNK5 = 16
    GUILD_BANK_UPDATE_MONEY = 17
    GUILD_BANK_MONEY_WITHDRAWN = 18
    GUILD_BANK_TEXT_CHANGED = 19


class GuildMemberStatus(enum.Enum):
    OFFLINE = 0
    ONLINE = 1


class InstanceResetFailedReason(enum.Enum):
    GENERAL = 0
    OFFLINE = 1
    ZONING = 2
    SILENTLY = 3


class InventoryResult(enum.Enum):
    OK = 0
    CANT_EQUIP_LEVEL_I = 1
    CANT_EQUIP_SKILL = 2
    ITEM_DOESNT_GO_TO_SLOT = 3
    BAG_FULL = 4
    NONEMPTY_BAG_OVER_OTHER_BAG = 5
    CANT_TRADE_EQUIP_BAGS = 6
    ONLY_AMMO_CAN_GO_HERE = 7
    NO_REQUIRED_PROFICIENCY = 8
    NO_EQUIPMENT_SLOT_AVAILABLE = 9
    YOU_CAN_NEVER_USE_THAT_ITEM = 10
    YOU_CAN_NEVER_USE_THAT_ITEM2 = 11
    NO_EQUIPMENT_SLOT_AVAILABLE2 = 12
    CANT_EQUIP_WITH_TWOHANDED = 13
    CANT_DUAL_WIELD = 14
    ITEM_DOESNT_GO_INTO_BAG = 15
    ITEM_DOESNT_GO_INTO_BAG2 = 16
    CANT_CARRY_MORE_OF_THIS = 17
    NO_EQUIPMENT_SLOT_AVAILABLE3 = 18
    ITEM_CANT_STACK = 19
    ITEM_CANT_BE_EQUIPPED = 20
    ITEMS_CANT_BE_SWAPPED = 21
    SLOT_IS_EMPTY = 22
    ITEM_NOT_FOUND = 23
    CANT_DROP_SOULBOUND = 24
    OUT_OF_RANGE = 25
    TRIED_TO_SPLIT_MORE_THAN_COUNT = 26
    COULDNT_SPLIT_ITEMS = 27
    MISSING_REAGENT = 28
    NOT_ENOUGH_MONEY = 29
    NOT_A_BAG = 30
    CAN_ONLY_DO_WITH_EMPTY_BAGS = 31
    DONT_OWN_THAT_ITEM = 32
    CAN_EQUIP_ONLY1_QUIVER = 33
    MUST_PURCHASE_THAT_BAG_SLOT = 34
    TOO_FAR_AWAY_FROM_BANK = 35
    ITEM_LOCKED = 36
    YOU_ARE_STUNNED = 37
    YOU_ARE_DEAD = 38
    CANT_DO_RIGHT_NOW = 39
    INT_BAG_ERROR = 40
    CAN_EQUIP_ONLY1_BOLT = 41
    CAN_EQUIP_ONLY1_AMMOPOUCH = 42
    STACKABLE_CANT_BE_WRAPPED = 43
    EQUIPPED_CANT_BE_WRAPPED = 44
    WRAPPED_CANT_BE_WRAPPED = 45
    BOUND_CANT_BE_WRAPPED = 46
    UNIQUE_CANT_BE_WRAPPED = 47
    BAGS_CANT_BE_WRAPPED = 48
    ALREADY_LOOTED = 49
    INVENTORY_FULL = 50
    BANK_FULL = 51
    ITEM_IS_CURRENTLY_SOLD_OUT = 52
    BAG_FULL3 = 53
    ITEM_NOT_FOUND2 = 54
    ITEM_CANT_STACK2 = 55
    BAG_FULL4 = 56
    ITEM_SOLD_OUT = 57
    OBJECT_IS_BUSY = 58
    NONE = 59
    NOT_IN_COMBAT = 60
    NOT_WHILE_DISARMED = 61
    BAG_FULL6 = 62
    CANT_EQUIP_RANK = 63
    CANT_EQUIP_REPUTATION = 64
    TOO_MANY_SPECIAL_BAGS = 65
    LOOT_CANT_LOOT_THAT_NOW = 66
    ITEM_UNIQUE_EQUIPABLE = 67
    VENDOR_MISSING_TURNINS = 68
    NOT_ENOUGH_HONOR_POINTS = 69
    NOT_ENOUGH_ARENA_POINTS = 70
    ITEM_MAX_COUNT_SOCKETED = 71
    MAIL_BOUND_ITEM = 72
    NO_SPLIT_WHILE_PROSPECTING = 73
    ITEM_MAX_COUNT_EQUIPPED_SOCKETED = 75
    ITEM_UNIQUE_EQUIPPABLE_SOCKETED = 76
    TOO_MUCH_GOLD = 77
    NOT_DURING_ARENA_MATCH = 78
    CANNOT_TRADE_THAT = 79
    PERSONAL_ARENA_RATING_TOO_LOW = 80
    EVENT_AUTOEQUIP_BIND_CONFIRM = 81
    ARTEFACTS_ONLY_FOR_OWN_CHARACTERS = 82
    ITEM_MAX_LIMIT_CATEGORY_COUNT_EXCEEDED = 84
    ITEM_MAX_LIMIT_CATEGORY_SOCKETED_EXCEEDED = 85
    SCALING_STAT_ITEM_LEVEL_EXCEEDED = 86
    PURCHASE_LEVEL_TOO_LOW = 87
    CANT_EQUIP_NEED_TALENT = 88
    ITEM_MAX_LIMIT_CATEGORY_EQUIPPED_EXCEEDED = 89


class InventoryType(enum.Enum):
    NON_EQUIP = 0
    HEAD = 1
    NECK = 2
    SHOULDERS = 3
    BODY = 4
    CHEST = 5
    WAIST = 6
    LEGS = 7
    FEET = 8
    WRISTS = 9
    HANDS = 10
    FINGER = 11
    TRINKET = 12
    WEAPON = 13
    SHIELD = 14
    RANGED = 15
    CLOAK = 16
    TWO_HANDED_WEAPON = 17
    BAG = 18
    TABARD = 19
    ROBE = 20
    WEAPON_MAIN_HAND = 21
    WEAPON_OFF_HAND = 22
    HOLDABLE = 23
    AMMO = 24
    THROWN = 25
    RANGED_RIGHT = 26
    QUIVER = 27
    RELIC = 28


class ItemClass(enum.Enum):
    CONSUMABLE = 0
    CONTAINER = 1
    WEAPON = 2
    GEM = 3
    ARMOR = 4
    REAGENT = 5
    PROJECTILE = 6
    TRADE_GOODS = 7
    GENERIC = 8
    RECIPE = 9
    MONEY = 10
    QUIVER = 11
    QUEST = 12
    KEY = 13
    PERMANENT = 14
    MISC = 15
    GLYPH = 16


class ItemClassAndSubClass(enum.Enum):
    CONSUMABLE = 0
    FOOD_AND_DRINK = 21474836480
    POTION = 4294967296
    ELIXIR = 8589934592
    FLASK = 12884901888
    BANDAGE = 30064771072
    ITEM_ENHANCEMENT = 25769803776
    SCROLL = 17179869184
    OTHER_CONSUMABLE = 34359738368
    BAG = 1
    SOUL_BAG = 4294967297
    HERB_BAG = 8589934593
    ENCHANTING_BAG = 12884901889
    ENGINEERING_BAG = 17179869185
    GEM_BAG = 21474836481
    MINING_BAG = 25769803777
    LEATHERWORKING_BAG = 30064771073
    INSCRIPTION_BAG = 34359738369
    ONE_HANDED_AXE = 2
    TWO_HANDED_AXE = 4294967298
    BOW = 8589934594
    GUN = 12884901890
    ONE_HANDED_MACE = 17179869186
    TWO_HANDED_MACE = 21474836482
    POLEARM = 25769803778
    ONE_HANDED_SWORD = 30064771074
    TWO_HANDED_SWORD = 34359738370
    OBSOLETE_WEAPON = 38654705666
    STAFF = 42949672962
    ONE_HANDED_EXOTIC = 47244640258
    TWO_HANDED_EXOTIC = 51539607554
    FIST_WEAPON = 55834574850
    MISCELLANEOUS_WEAPON = 60129542146
    DAGGER = 64424509442
    THROWN = 68719476738
    SPEAR = 73014444034
    CROSSBOW = 77309411330
    WAND = 81604378626
    FISHING_POLE = 85899345922
    GEM_RED = 3
    GEM_BLUE = 4294967299
    GEM_YELLOW = 8589934595
    GEM_PURPLE = 12884901891
    GEM_GREEN = 17179869187
    GEM_ORANGE = 21474836483
    GEM_META = 25769803779
    GEM_SIMPLE = 30064771075
    GEM_PRISMATIC = 34359738371
    MISCELLANEOUS_ARMOR = 4
    CLOTH_ARMOR = 4294967300
    LEATHER_ARMOR = 8589934596
    MAIL_ARMOR = 12884901892
    PLATE_ARMOR = 17179869188
    BUCKLER_OBSOLETE = 21474836484
    SHIELD = 25769803780
    LIBRAM = 30064771076
    IDOL = 34359738372
    TOTEM = 38654705668
    SIGIL = 42949672964
    REAGENT = 5
    WAND_OBSOLETE = 6
    BOLT_OBSOLETE = 4294967302
    ARROW = 8589934598
    BULLET = 12884901894
    THROWN_OBSOLETE = 17179869190
    TRADE_GOOD = 7
    ELEMENTAL_TRADE_GOOD = 42949672967
    CLOTH_TRADE_GOOD = 21474836487
    LEATHER_TRADE_GOOD = 25769803783
    METAL_AND_STONE_TRADE_GOOD = 30064771079
    MEAT_TRADE_GOOD = 34359738375
    HERB_TRADE_GOOD = 38654705671
    ENCHANTING_TRADE_GOOD = 51539607559
    JEWELCRAFTING_TRADE_GOOD = 17179869191
    PART_TRADE_GOOD = 4294967303
    DEVICE_TRADE_GOOD = 12884901895
    EXPLOSIVE_TRADE_GOOD = 8589934599
    MATERIAL_TRADE_GOOD = 55834574855
    OTHER_TRADE_GOOD = 47244640263
    ARMOR_ENCHANTMENT_TRADE_GOOD = 60129542151
    WEAPON_ENCHANTMENT_TRADE_GOOD = 64424509447
    GENERIC_OBSOLETE = 8
    BOOK = 9
    LEATHERWORKING_RECIPE = 4294967305
    TAILORING_RECIPE = 8589934601
    ENGINEERING_RECIPE = 12884901897
    BLACKSMITHING_RECIPE = 17179869193
    COOKING_RECIPE = 21474836489
    ALCHEMY_RECIPE = 25769803785
    FIRST_AID_RECIPE = 30064771081
    ENCHANTING_RECIPE = 34359738377
    FISHING_RECIPE = 38654705673
    JEWELCRAFTING_RECIPE = 42949672969
    INSCRIPTION_RECIPE = 47244640265
    MONEY_OBSOLETE = 10
    QUIVER_OBSOLETE = 11
    QUIVER_OBSOLETE1 = 4294967307
    QUIVER = 8589934603
    AMMO_POUCH = 12884901899
    QUEST = 12
    KEY = 13
    LOCKPICK = 4294967309
    PERMANENT_OBSOLETE = 14
    MISCELLANEOUS_JUNK = 15
    MISCELLANEOUS_REAGENT = 4294967311
    MISCELLANEOUS_PET = 8589934607
    MISCELLANEOUS_HOLIDAY = 12884901903
    MISCELLANEOUS_OTHER = 17179869199
    MISCELLANEOUS_MOUNT = 21474836495
    WARRIOR_GLYPH = 4294967312
    PALADIN_GLYPH = 8589934608
    HUNTER_GLYPH = 12884901904
    ROGUE_GLYPH = 17179869200
    PRIEST_GLYPH = 21474836496
    DEATH_KNIGHT_GLYPH = 25769803792
    SHAMAN_GLYPH = 30064771088
    MAGE_GLYPH = 34359738384
    WARLOCK_GLYPH = 38654705680
    DRUID_GLYPH = 47244640272


class ItemQuality(enum.Enum):
    POOR = 0
    NORMAL = 1
    UNCOMMON = 2
    RARE = 3
    EPIC = 4
    LEGENDARY = 5
    ARTIFACT = 6
    HEIRLOOM = 7


class ItemRefundResult(enum.Enum):
    SUCCESS = 0
    FAILURE = 10


class ItemSet(enum.Enum):
    NONE = 0
    THE_GLADIATOR = 1
    DAL_RENDS_ARMS = 41
    SPIDERS_KISS = 65
    THE_POSTMASTER = 81
    CADAVEROUS_GARB = 121
    NECROPILE_RAIMENT = 122
    BLOODMAIL_REGALIA = 123
    DEATHBONE_GUARDIAN = 124
    VOLCANIC_ARMOR = 141
    STORMSHROUD_ARMOR = 142
    DEVILSAUR_ARMOR = 143
    IRONFEATHER_ARMOR = 144
    DEFIAS_LEATHER = 161
    EMBRACE_OF_THE_VIPER = 162
    CHAIN_OF_THE_SCARLET_CRUSADE = 163
    MAGISTERS_REGALIA = 181
    VESTMENTS_OF_THE_DEVOUT = 182
    DREADMIST_RAIMENT = 183
    SHADOWCRAFT_ARMOR = 184
    WILDHEART_RAIMENT = 185
    BEASTSTALKER_ARMOR = 186
    THE_ELEMENTS = 187
    LIGHTFORGE_ARMOR = 188
    BATTLEGEAR_OF_VALOR = 189
    ARCANIST_REGALIA = 201
    VESTMENTS_OF_PROPHECY = 202
    FELHEART_RAIMENT = 203
    NIGHTSLAYER_ARMOR = 204
    CENARION_RAIMENT = 205
    GIANTSTALKER_ARMOR = 206
    THE_EARTHFURY = 207
    LAWBRINGER_ARMOR = 208
    BATTLEGEAR_OF_MIGHT = 209
    NETHERWIND_REGALIA = 210
    VESTMENTS_OF_TRANSCENDENCE = 211
    NEMESIS_RAIMENT = 212
    BLOODFANG_ARMOR = 213
    STORMRAGE_RAIMENT = 214
    DRAGONSTALKER_ARMOR = 215
    THE_TEN_STORMS = 216
    JUDGEMENT_ARMOR = 217
    BATTLEGEAR_OF_WRATH = 218
    GARB_OF_THERO_SHAN = 221
    SHARD_OF_THE_GODS = 241
    SPIRIT_OF_ESKHANDAR = 261
    CHAMPIONS_BATTLEGEAR = 281
    LIEUTENANT_COMMANDERS_BATTLEGEAR = 282
    CHAMPIONS_EARTHSHAKER = 301
    IMPERIAL_PLATE = 321
    CHAMPIONS_REGALIA = 341
    CHAMPIONS_RAIMENT = 342
    LIEUTENANT_COMMANDERS_REGALIA = 343
    LIEUTENANT_COMMANDERS_RAIMENT = 344
    CHAMPIONS_THREADS = 345
    LIEUTENANT_COMMANDERS_THREADS = 346
    CHAMPIONS_VESTMENTS = 347
    LIEUTENANT_COMMANDERS_VESTMENTS = 348
    CHAMPIONS_PURSUIT = 361
    LIEUTENANT_COMMANDERS_PURSUIT = 362
    LIEUTENANT_COMMANDERS_SANCTUARY = 381
    CHAMPIONS_SANCTUARY = 382
    WARLORDS_BATTLEGEAR = 383
    FIELD_MARSHALS_BATTLEGEAR = 384
    WARLORDS_EARTHSHAKER = 386
    WARLORDS_REGALIA = 387
    FIELD_MARSHALS_REGALIA = 388
    FIELD_MARSHALS_RAIMENT = 389
    WARLORDS_RAIMENT = 390
    WARLORDS_THREADS = 391
    FIELD_MARSHALS_THREADS = 392
    WARLORDS_VESTMENTS = 393
    FIELD_MARSHALS_VESTMENTS = 394
    FIELD_MARSHALS_PURSUIT = 395
    WARLORDS_PURSUIT = 396
    FIELD_MARSHALS_SANCTUARY = 397
    WARLORDS_SANCTUARY = 398
    LIEUTENANT_COMMANDERS_AEGIS = 401
    FIELD_MARSHALS_AEGIS = 402
    BLOODVINE_GARB = 421
    PRIMAL_BATSKIN = 441
    BLOOD_TIGER_HARNESS = 442
    BLOODSOUL_EMBRACE = 443
    THE_DARKSOUL = 444
    THE_TWIN_BLADES_OF_HAKKARI = 461
    ZANZILS_CONCENTRATION = 462
    PRIMAL_BLESSING = 463
    OVERLORDS_RESOLUTION = 464
    PRAYER_OF_THE_PRIMAL = 465
    MAJOR_MOJO_INFUSION = 466
    THE_HIGHLANDERS_RESOLUTION = 467
    THE_HIGHLANDERS_RESOLVE = 468
    THE_HIGHLANDERS_DETERMINATION = 469
    THE_HIGHLANDERS_FORTITUDE = 470
    THE_HIGHLANDERS_PURPOSE = 471
    THE_HIGHLANDERS_WILL = 472
    THE_HIGHLANDERS_INTENT = 473
    VINDICATORS_BATTLEGEAR = 474
    FREETHINKERS_ARMOR = 475
    AUGURS_REGALIA = 476
    PREDATORS_ARMOR = 477
    MADCAPS_OUTFIT = 478
    HARUSPEXS_GARB = 479
    CONFESSORS_RAIMENT = 480
    DEMONIACS_THREADS = 481
    ILLUSIONISTS_ATTIRE = 482
    THE_DEFILERS_DETERMINATION = 483
    THE_DEFILERS_FORTITUDE = 484
    THE_DEFILERS_INTENT = 485
    THE_DEFILERS_PURPOSE = 486
    THE_DEFILERS_RESOLUTION = 487
    THE_DEFILERS_WILL = 488
    BLACK_DRAGON_MAIL = 489
    GREEN_DRAGON_MAIL = 490
    BLUE_DRAGON_MAIL = 491
    TWILIGHT_TRAPPINGS = 492
    GENESIS_RAIMENT = 493
    SYMBOLS_OF_UNENDING_LIFE = 494
    BATTLEGEAR_OF_UNYIELDING_STRENGTH = 495
    CONQUERORS_BATTLEGEAR = 496
    DEATHDEALERS_EMBRACE = 497
    EMBLEMS_OF_VEILED_SHADOWS = 498
    DOOMCALLERS_ATTIRE = 499
    IMPLEMENTS_OF_UNSPOKEN_NAMES = 500
    STORMCALLERS_GARB = 501
    GIFT_OF_THE_GATHERING_STORM = 502
    ENIGMA_VESTMENTS = 503
    TRAPPINGS_OF_VAULTED_SECRETS = 504
    AVENGERS_BATTLEGEAR = 505
    BATTLEGEAR_OF_ETERNAL_JUSTICE = 506
    GARMENTS_OF_THE_ORACLE = 507
    FINERY_OF_INFINITE_WISDOM = 508
    STRIKERS_GARB = 509
    TRAPPINGS_OF_THE_UNSEEN_PATH = 510
    BATTLEGEAR_OF_HEROISM = 511
    DARKMANTLE_ARMOR = 512
    FERALHEART_RAIMENT = 513
    VESTMENTS_OF_THE_VIRTUOUS = 514
    BEASTMASTER_ARMOR = 515
    SOULFORGE_ARMOR = 516
    SORCERERS_REGALIA = 517
    DEATHMIST_RAIMENT = 518
    THE_FIVE_THUNDERS = 519
    IRONWEAVE_BATTLESUIT = 520
    DREAMWALKER_RAIMENT = 521
    CHAMPIONS_GUARD = 522
    DREADNAUGHTS_BATTLEGEAR = 523
    BONESCYTHE_ARMOR = 524
    VESTMENTS_OF_FAITH = 525
    FROSTFIRE_REGALIA = 526
    THE_EARTHSHATTERER = 527
    REDEMPTION_ARMOR = 528
    PLAGUEHEART_RAIMENT = 529
    CRYPTSTALKER_ARMOR = 530
    BATTLEGEAR_OF_UNDEAD_SLAYING = 533
    UNDEAD_SLAYERS_ARMOR = 534
    GARB_OF_THE_UNDEAD_SLAYER = 535
    REGALIA_OF_UNDEAD_CLEANSING = 536
    CHAMPIONS_BATTLEARMOR = 537
    CHAMPIONS_STORMCALLER = 538
    CHAMPIONS_REFUGE = 539
    CHAMPIONS_INVESTITURE = 540
    CHAMPIONS_DREADGEAR = 541
    CHAMPIONS_ARCANUM = 542
    CHAMPIONS_PURSUANCE = 543
    LIEUTENANT_COMMANDERS_REDOUBT = 544
    LIEUTENANT_COMMANDERS_BATTLEARMOR = 545
    LIEUTENANT_COMMANDERS_ARCANUM = 546
    LIEUTENANT_COMMANDERS_DREADGEAR = 547
    LIEUTENANT_COMMANDERS_GUARD = 548
    LIEUTENANT_COMMANDERS_INVESTITURE = 549
    LIEUTENANT_COMMANDERS_PURSUANCE = 550
    LIEUTENANT_COMMANDERS_REFUGE = 551
    WRATH_OF_SPELLFIRE = 552
    SHADOWS_EMBRACE = 553
    PRIMAL_MOONCLOTH = 554
    NETHERWEAVE_VESTMENTS = 555
    IMBUED_NETHERWEAVE = 556
    SOULCLOTH_EMBRACE = 557
    ARCANOWEAVE_VESTMENTS = 558
    SPELLSTRIKE_INFUSION = 559
    FEL_IRON_PLATE = 560
    FEL_IRON_CHAIN = 561
    ADAMANTITE_BATTLEGEAR = 562
    ENCHANTED_ADAMANTITE_ARMOR = 563
    FLAME_GUARD = 564
    KHORIUM_WARD = 565
    BURNING_RAGE = 566
    GLADIATORS_BATTLEGEAR = 567
    GLADIATORS_DREADGEAR = 568
    FAITH_IN_FELSTEEL = 569
    THE_UNYIELDING = 570
    WHITEMEND_WISDOM = 571
    BATTLECAST_GARB = 572
    FEL_SKIN = 573
    STRENGTH_OF_THE_CLEFTHOOF = 574
    FELSTALKER_ARMOR = 575
    FURY_OF_THE_NETHER = 576
    GLADIATORS_VESTMENTS = 577
    GLADIATORS_EARTHSHAKER = 578
    GLADIATORS_REGALIA = 579
    GLADIATORS_THUNDERFIST = 580
    GLADIATORS_RAIMENT = 581
    GLADIATORS_AEGIS = 582
    GLADIATORS_VINDICATION = 583
    GLADIATORS_SANCTUARY = 584
    GLADIATORS_WILDHIDE = 585
    GLADIATORS_PURSUIT = 586
    HIGH_WARLORDS_AEGIS = 587
    HIGH_WARLORDS_BATTLEGEAR = 588
    GRAND_MARSHALS_AEGIS = 589
    GRAND_MARSHALS_BATTLEGEAR = 590
    GRAND_MARSHALS_DREADGEAR = 591
    HIGH_WARLORDS_DREADGEAR = 592
    GRAND_MARSHALS_EARTHSHAKER = 593
    HIGH_WARLORDS_EARTHSHAKER = 594
    GRAND_MARSHALS_PURSUIT = 595
    HIGH_WARLORDS_PURSUIT = 596
    GRAND_MARSHALS_RAIMENT = 597
    HIGH_WARLORDS_RAIMENT = 598
    GRAND_MARSHALS_REGALIA = 599
    HIGH_WARLORDS_REGALIA = 600
    GRAND_MARSHALS_SANCTUARY = 601
    HIGH_WARLORDS_SANCTUARY = 602
    GRAND_MARSHALS_THUNDERFIST = 603
    HIGH_WARLORDS_THUNDERFIST = 604
    GRAND_MARSHALS_VESTMENTS = 605
    HIGH_WARLORDS_VESTMENTS = 606
    GRAND_MARSHALS_VINDICATION = 607
    HIGH_WARLORDS_VINDICATION = 608
    GRAND_MARSHALS_WILDHIDE = 609
    HIGH_WARLORDS_WILDHIDE = 610
    FELSCALE_ARMOR = 611
    SCALED_DRAENIC_ARMOR = 612
    THICK_DRAENIC_ARMOR = 613
    WILD_DRAENISH_ARMOR = 614
    GLADIATORS_FELSHROUD = 615
    NETHERSCALE_ARMOR = 616
    NETHERSTRIKE_ARMOR = 617
    WINDHAWK_ARMOR = 618
    PRIMAL_INTENT = 619
    ASSASSINATION_ARMOR = 620
    NETHERBLADE = 621
    DEATHMANTLE = 622
    RIGHTEOUS_ARMOR = 623
    JUSTICAR_RAIMENT = 624
    JUSTICAR_ARMOR = 625
    JUSTICAR_BATTLEGEAR = 626
    CRYSTALFORGE_RAIMENT = 627
    CRYSTALFORGE_ARMOR = 628
    CRYSTALFORGE_BATTLEGEAR = 629
    TIDEFURY_RAIMENT = 630
    CYCLONE_RAIMENT = 631
    CYCLONE_REGALIA = 632
    CYCLONE_HARNESS = 633
    CATACLYSM_RAIMENT = 634
    CATACLYSM_REGALIA = 635
    CATACLYSM_HARNESS = 636
    MOONGLADE_RAIMENT = 637
    MALORNE_RAIMENT = 638
    MALORNE_REGALIA = 639
    MALORNE_HARNESS = 640
    NORDRASSIL_HARNESS = 641
    NORDRASSIL_RAIMENT = 642
    NORDRASSIL_REGALIA = 643
    OBLIVION_RAIMENT = 644
    VOIDHEART_RAIMENT = 645
    CORRUPTOR_RAIMENT = 646
    INCANTERS_REGALIA = 647
    ALDOR_REGALIA = 648
    TIRISFAL_REGALIA = 649
    BEAST_LORD_ARMOR = 650
    DEMON_STALKER_ARMOR = 651
    RIFT_STALKER_ARMOR = 652
    BOLD_ARMOR = 653
    WARBRINGER_ARMOR = 654
    WARBRINGER_BATTLEGEAR = 655
    DESTROYER_ARMOR = 656
    DESTROYER_BATTLEGEAR = 657
    MANA_ETCHED_REGALIA = 658
    WASTEWALKER_ARMOR = 659
    DESOLATION_BATTLEGEAR = 660
    DOOMPLATE_BATTLEGEAR = 661
    HALLOWED_RAIMENT = 662
    INCARNATE_RAIMENT = 663
    INCARNATE_REGALIA = 664
    AVATAR_RAIMENT = 665
    AVATAR_REGALIA = 666
    THE_TWIN_STARS = 667
    SLAYERS_ARMOR = 668
    GRONNSTALKERS_ARMOR = 669
    MALEFIC_RAIMENT = 670
    TEMPEST_REGALIA = 671
    ONSLAUGHT_BATTLEGEAR = 672
    ONSLAUGHT_ARMOR = 673
    ABSOLUTION_REGALIA = 674
    VESTMENTS_OF_ABSOLUTION = 675
    THUNDERHEART_HARNESS = 676
    THUNDERHEART_REGALIA = 677
    THUNDERHEART_RAIMENT = 678
    LIGHTBRINGER_ARMOR = 679
    LIGHTBRINGER_BATTLEGEAR = 680
    LIGHTBRINGER_RAIMENT = 681
    SKYSHATTER_HARNESS = 682
    SKYSHATTER_RAIMENT = 683
    SKYSHATTER_REGALIA = 684
    GLADIATORS_REFUGE = 685
    GLADIATORS_WARTIDE = 686
    GLADIATORS_INVESTITURE = 687
    GRAND_MARSHALS_REFUGE = 688
    HIGH_WARLORDS_REFUGE = 689
    GLADIATORS_REDEMPTION = 690
    GRAND_MARSHALS_INVESTITURE = 691
    HIGH_WARLORDS_INVESTITURE = 692
    GRAND_MARSHALS_REDEMPTION = 693
    HIGH_WARLORDS_REDEMPTION = 694
    GRAND_MARSHALS_WARTIDE = 695
    HIGH_WARLORDS_WARTIDE = 696
    CHAMPIONS_REDOUBT = 697
    WARLORDS_AEGIS = 698
    THE_TWIN_BLADES_OF_AZZINOTH = 699
    MERCILESS_GLADIATORS_AEGIS = 700
    MERCILESS_GLADIATORS_BATTLEGEAR = 701
    MERCILESS_GLADIATORS_DREADGEAR = 702
    MERCILESS_GLADIATORS_EARTHSHAKER = 703
    MERCILESS_GLADIATORS_FELSHROUD = 704
    MERCILESS_GLADIATORS_INVESTITURE = 705
    MERCILESS_GLADIATORS_PURSUIT = 706
    MERCILESS_GLADIATORS_RAIMENT = 707
    MERCILESS_GLADIATORS_REDEMPTION = 708
    MERCILESS_GLADIATORS_REFUGE = 709
    MERCILESS_GLADIATORS_REGALIA = 710
    MERCILESS_GLADIATORS_SANCTUARY = 711
    MERCILESS_GLADIATORS_THUNDERFIST = 712
    MERCILESS_GLADIATORS_VESTMENTS = 713
    MERCILESS_GLADIATORS_VINDICATION = 714
    MERCILESS_GLADIATORS_WARTIDE = 715
    MERCILESS_GLADIATORS_WILDHIDE = 716
    FIELD_MARSHALS_EARTHSHAKER = 717
    LIEUTENANT_COMMANDERS_EARTHSHAKER = 718
    THE_FISTS_OF_FURY = 719
    VENGEFUL_GLADIATORS_REFUGE = 720
    VENGEFUL_GLADIATORS_SANCTUARY = 721
    VENGEFUL_GLADIATORS_WILDHIDE = 722
    VENGEFUL_GLADIATORS_PURSUIT = 723
    VENGEFUL_GLADIATORS_REGALIA = 724
    VENGEFUL_GLADIATORS_REDEMPTION = 725
    VENGEFUL_GLADIATORS_VINDICATION = 726
    VENGEFUL_GLADIATORS_AEGIS = 727
    VENGEFUL_GLADIATORS_INVESTITURE = 728
    VENGEFUL_GLADIATORS_RAIMENT = 729
    VENGEFUL_GLADIATORS_VESTMENTS = 730
    VENGEFUL_GLADIATORS_WARTIDE = 731
    VENGEFUL_GLADIATORS_EARTHSHAKER = 732
    VENGEFUL_GLADIATORS_THUNDERFIST = 733
    VENGEFUL_GLADIATORS_DREADGEAR = 734
    VENGEFUL_GLADIATORS_FELSHROUD = 735
    VENGEFUL_GLADIATORS_BATTLEGEAR = 736
    LATROS_FLURRY = 737
    DREADWEAVE_BATTLEGEAR = 738
    MOONCLOTH_BATTLEGEAR = 739
    SATIN_BATTLEGEAR = 740
    EVOKERS_SILK_BATTLEGEAR = 741
    DRAGONHIDE_BATTLEGEAR = 742
    WYRMHIDE_BATTLEGEAR = 743
    KODOHIDE_BATTLEGEAR = 744
    OPPORTUNISTS_BATTLEGEAR = 745
    SEERS_MAIL_BATTLEGEAR = 746
    SEERS_RINGMAIL_BATTLEGEAR = 747
    SEERS_LINKED_BATTLEGEAR = 748
    STALKERS_CHAIN_BATTLEGEAR = 749
    SAVAGE_PLATE_BATTLEGEAR = 750
    CRUSADERS_ORNAMENTED_BATTLEGEAR = 751
    CRUSADERS_SCALED_BATTLEGEAR = 752
    BOREAN_EMBRACE = 754
    NERUBIAN_HIVE = 755
    FROSTSCALE_BINDING = 756
    ICEBORNE_EMBRACE = 757
    RAINES_REVENGE = 759
    GLADIATORS_DREADPLATE = 760
    WINTER_GARB = 761
    BREWFEST_GARB = 762
    FROSTWOVEN_POWER = 763
    DUSKWEAVER = 764
    GLADIATORS_BATTLEGEAR2 = 765
    GLADIATORS_VINDICATION2 = 766
    GLADIATORS_REDEMPTION2 = 767
    GLADIATORS_DESECRATION = 768
    GLADIATORS_THUNDERFIST2 = 769
    GLADIATORS_EARTHSHAKER2 = 770
    GLADIATORS_WARTIDE2 = 771
    GLADIATORS_PURSUIT2 = 772
    GLADIATORS_REFUGE2 = 773
    GLADIATORS_WILDHIDE2 = 774
    GLADIATORS_SANCTUARY2 = 775
    GLADIATORS_VESTMENTS2 = 776
    GLADIATORS_INVESTITURE2 = 777
    GLADIATORS_RAIMENT2 = 778
    GLADIATORS_REGALIA2 = 779
    GLADIATORS_FELSHROUD2 = 780
    BLESSED_REGALIA_OF_UNDEAD_CLEANSING = 781
    UNDEAD_SLAYERS_BLESSED_ARMOR = 782
    BLESSED_GARB_OF_THE_UNDEAD_SLAYER = 783
    BLESSED_BATTLEGEAR_OF_UNDEAD_SLAYING = 784
    MIDSUMMER_REVELER = 785
    DREADNAUGHT_PLATE = 787
    DREADNAUGHT_BATTLEGEAR = 788
    REDEMPTION_BATTLEGEAR = 789
    REDEMPTION_REGALIA = 790
    REDEMPTION_PLATE = 791
    SCOURGEBORNE_BATTLEGEAR = 792
    SCOURGEBORNE_PLATE = 793
    CRYPTSTALKER_BATTLEGEAR = 794
    EARTHSHATTER_BATTLEGEAR = 795
    EARTHSHATTER_GARB = 796
    EARTHSHATTER_REGALIA = 797
    DREAMWALKER_BATTLEGEAR = 798
    DREAMWALKER_REGALIA = 799
    DREAMWALKER_GARB = 800
    BONESCYTHE_BATTLEGEAR = 801
    PLAGUEHEART_GARB = 802
    FROSTFIRE_GARB = 803
    REGALIA_OF_FAITH = 804
    GARB_OF_FAITH = 805
    SPRING_TUXEDO = 812
    EVISCERATORS_BATTLEGEAR = 813
    ORNATE_SARONITE_BATTLEGEAR = 814
    OVERCASTER_BATTLEGEAR = 815
    SAVAGE_SARONITE_BATTLEGEAR = 816
    STORMHIDE_BATTLEGEAR = 817
    SWIFTARROW_BATTLEGEAR = 818
    FROSTSAVAGE_BATTLEGEAR = 819
    AEGIS_BATTLEGEAR = 820
    AEGIS_PLATE = 821
    AEGIS_REGALIA = 822
    WORLDBREAKER_BATTLEGEAR = 823
    WORLDBREAKER_GARB = 824
    WORLDBREAKER_REGALIA = 825
    TERRORBLADE_BATTLEGEAR = 826
    NIGHTSONG_BATTLEGEAR = 827
    NIGHTSONG_GARB = 828
    NIGHTSONG_REGALIA = 829
    SIEGEBREAKER_BATTLEGEAR = 830
    SIEGEBREAKER_PLATE = 831
    SANCTIFICATION_GARB = 832
    SANCTIFICATION_REGALIA = 833
    DARKRUNED_BATTLEGEAR = 834
    DARKRUNED_PLATE = 835
    KIRIN_TOR_GARB = 836
    DEATHBRINGER_GARB = 837
    SCOURGESTALKER_BATTLEGEAR = 838
    KHADGARS_REGALIA = 843
    SUNSTRIDERS_REGALIA = 844
    GUL_DANS_REGALIA = 845
    KEL_THUZADS_REGALIA = 846
    VELENS_RAIMENT = 847
    ZABRAS_RAIMENT = 848
    VELENS_REGALIA = 849
    ZABRAS_REGALIA = 850
    MALFURIONS_GARB = 851
    RUNETOTEMS_GARB = 852
    MALFURIONS_REGALIA = 853
    RUNETOTEMS_REGALIA = 854
    MALFURIONS_BATTLEGEAR = 855
    RUNETOTEMS_BATTLEGEAR = 856
    VANCLEEFS_BATTLEGEAR = 857
    GARONAS_BATTLEGEAR = 858
    WINDRUNNERS_BATTLEGEAR = 859
    WINDRUNNERS_PURSUIT = 860
    NOBUNDOS_GARB = 861
    THRALLS_GARB = 862
    THRALLS_REGALIA = 863
    NOBUNDOS_REGALIA = 864
    NOBUNDOS_BATTLEGEAR = 865
    THRALLS_BATTLEGEAR = 866
    WRYNNS_BATTLEGEAR = 867
    HELLSCREAMS_BATTLEGEAR = 868
    WRYNNS_PLATE = 869
    HELLSCREAMS_PLATE = 870
    THASSARIANS_BATTLEGEAR = 871
    KOLTIRAS_BATTLEGEAR = 872
    THASSARIANS_PLATE = 873
    KOLTIRAS_PLATE = 874
    TURALYONS_GARB = 875
    LIADRINS_GARB = 876
    TURALYONS_BATTLEGEAR = 877
    LIADRINS_BATTLEGEAR = 878
    TURALYONS_PLATE = 879
    LIADRINS_PLATE = 880
    PURIFIED_SHARD_OF_THE_GODS = 881
    SHINY_SHARD_OF_THE_GODS = 882
    BLOODMAGES_REGALIA = 883
    DARK_COVENS_REGALIA = 884
    CRIMSON_ACOLYTES_RAIMENT = 885
    CRIMSON_ACOLYTES_REGALIA = 886
    LASHERWEAVE_GARB = 887
    LASHERWEAVE_REGALIA = 888
    LASHERWEAVE_BATTLEGEAR = 889
    SHADOWBLADES_BATTLEGEAR = 890
    AHN_KAHAR_BLOOD_HUNTERS_BATTLEGEAR = 891
    FROST_WITCHS_GARB = 892
    FROST_WITCHS_REGALIA = 893
    FROST_WITCHS_BATTLEGEAR = 894
    YMIRJAR_LORDS_BATTLEGEAR = 895
    YMIRJAR_LORDS_PLATE = 896
    SCOURGELORDS_BATTLEGEAR = 897
    SCOURGELORDS_PLATE = 898
    LIGHTSWORN_GARB = 899
    LIGHTSWORN_BATTLEGEAR = 900
    LIGHTSWORN_PLATE = 901


class ItemSlot(enum.Enum):
    HEAD = 0
    NECK = 1
    SHOULDERS = 2
    SHIRT = 3
    CHEST = 4
    WAIST = 5
    LEGS = 6
    BOOTS = 7
    WRIST = 8
    HANDS = 9
    RING1 = 10
    RING2 = 11
    TRINKET1 = 12
    TRINKET2 = 13
    BACK = 14
    MAIN_HAND = 15
    OFF_HAND = 16
    RANGED_OR_RELIC = 17
    TABARD = 18
    BAG1 = 19
    BAG2 = 20
    BAG3 = 21
    BAG4 = 22
    INVENTORY_0 = 23
    INVENTORY_1 = 24
    INVENTORY_2 = 25
    INVENTORY_3 = 26
    INVENTORY_4 = 27
    INVENTORY_5 = 28
    INVENTORY_6 = 29
    INVENTORY_7 = 30
    INVENTORY_8 = 31
    INVENTORY_9 = 32
    INVENTORY_10 = 33
    INVENTORY_11 = 34
    INVENTORY_12 = 35
    INVENTORY_13 = 36
    INVENTORY_14 = 37
    INVENTORY_15 = 38
    BANK_1 = 39
    BANK_2 = 40
    BANK_3 = 41
    BANK_4 = 42
    BANK_5 = 43
    BANK_6 = 44
    BANK_7 = 45
    BANK_8 = 46
    BANK_9 = 47
    BANK_10 = 48
    BANK_11 = 49
    BANK_12 = 50
    BANK_13 = 51
    BANK_14 = 52
    BANK_15 = 53
    BANK_16 = 54
    BANK_17 = 55
    BANK_18 = 56
    BANK_19 = 57
    BANK_20 = 58
    BANK_21 = 59
    BANK_22 = 60
    BANK_23 = 61
    BANK_24 = 62
    BANK_25 = 63
    BANK_26 = 64
    BANK_27 = 65
    BANK_28 = 66
    BANK_BAG_SLOT_1 = 67
    BANK_BAG_SLOT_2 = 68
    BANK_BAG_SLOT_3 = 69
    BANK_BAG_SLOT_4 = 70
    BANK_BAG_SLOT_5 = 71
    BANK_BAG_SLOT_6 = 72
    BANK_BAG_SLOT_7 = 73
    VENDOR_BUYBACK_1 = 74
    VENDOR_BUYBACK_2 = 75
    VENDOR_BUYBACK_3 = 76
    VENDOR_BUYBACK_4 = 77
    VENDOR_BUYBACK_5 = 78
    VENDOR_BUYBACK_6 = 79
    VENDOR_BUYBACK_7 = 80
    VENDOR_BUYBACK_8 = 81
    VENDOR_BUYBACK_9 = 82
    VENDOR_BUYBACK_10 = 83
    VENDOR_BUYBACK_11 = 84
    VENDOR_BUYBACK_12 = 85
    KEYRING_1 = 86
    KEYRING_2 = 87
    KEYRING_3 = 88
    KEYRING_4 = 89
    KEYRING_5 = 90
    KEYRING_6 = 91
    KEYRING_7 = 92
    KEYRING_8 = 93
    KEYRING_9 = 94
    KEYRING_10 = 95
    KEYRING_11 = 96
    KEYRING_12 = 97
    KEYRING_13 = 98
    KEYRING_14 = 99
    KEYRING_15 = 100
    KEYRING_16 = 101
    KEYRING_17 = 102
    KEYRING_18 = 103
    KEYRING_19 = 104
    KEYRING_20 = 105
    KEYRING_21 = 106
    KEYRING_22 = 107
    KEYRING_23 = 108
    KEYRING_24 = 109
    KEYRING_25 = 110
    KEYRING_26 = 111
    KEYRING_27 = 112
    KEYRING_28 = 113
    KEYRING_29 = 114
    KEYRING_30 = 115
    KEYRING_31 = 116
    KEYRING_32 = 117
    CURRENCY_TOKEN_1 = 118
    CURRENCY_TOKEN_2 = 119
    CURRENCY_TOKEN_3 = 120
    CURRENCY_TOKEN_4 = 121
    CURRENCY_TOKEN_5 = 122
    CURRENCY_TOKEN_6 = 123
    CURRENCY_TOKEN_7 = 124
    CURRENCY_TOKEN_8 = 125
    CURRENCY_TOKEN_9 = 126
    CURRENCY_TOKEN_10 = 127
    CURRENCY_TOKEN_11 = 128
    CURRENCY_TOKEN_12 = 129
    CURRENCY_TOKEN_13 = 130
    CURRENCY_TOKEN_14 = 131
    CURRENCY_TOKEN_15 = 132
    CURRENCY_TOKEN_16 = 133
    CURRENCY_TOKEN_17 = 134
    CURRENCY_TOKEN_18 = 135
    CURRENCY_TOKEN_19 = 136
    CURRENCY_TOKEN_20 = 137
    CURRENCY_TOKEN_21 = 138
    CURRENCY_TOKEN_22 = 139
    CURRENCY_TOKEN_23 = 140
    CURRENCY_TOKEN_24 = 141
    CURRENCY_TOKEN_25 = 142
    CURRENCY_TOKEN_26 = 143
    CURRENCY_TOKEN_27 = 144
    CURRENCY_TOKEN_28 = 145
    CURRENCY_TOKEN_29 = 146
    CURRENCY_TOKEN_30 = 147
    CURRENCY_TOKEN_31 = 148
    CURRENCY_TOKEN_32 = 149


class ItemTextQuery(enum.Enum):
    HAS_TEXT = 0
    NO_TEXT = 1


class JoinArenaType(enum.Enum):
    TWO_VS_TWO = 0
    THREE_VS_THREE = 1
    FIVE_VS_FIVE = 2


class Language(enum.Enum):
    UNIVERSAL = 0
    ORCISH = 1
    DARNASSIAN = 2
    TAURAHE = 3
    DWARVISH = 6
    COMMON = 7
    DEMONIC = 8
    TITAN = 9
    THALASSIAN = 10
    DRACONIC = 11
    KALIMAG = 12
    GNOMISH = 13
    TROLL = 14
    GUTTERSPEAK = 33
    DRAENEI = 35
    ZOMBIE = 36
    GNOMISH_BINARY = 37
    GOBLIN_BINARY = 38


class LfgJoinStatus(enum.Enum):
    NOT_JOINED = 0
    JOINED = 1


class LfgListUpdateType(enum.Enum):
    PARTIAL = 0
    FULL = 1


class LfgTeleportError(enum.Enum):
    PLAYER_DEAD = 1
    FALLING = 2
    IN_VEHICLE = 3
    FATIGUE = 4
    INVALID_LOCATION = 6
    COMBAT = 8


class LfgTeleportLocation(enum.Enum):
    IN = 0
    OUT = 1


class LfgType(enum.Enum):
    NONE = 0
    DUNGEON = 1
    RAID = 2
    ZONE = 4
    HEROIC = 5
    RANDOM = 6


class LfgUpdateType(enum.Enum):
    DEFAULT = 0
    LEADER_LEAVE = 1
    ROLECHECK_ABORTED = 4
    JOIN = 5
    ROLECHECK_FAILED = 6
    LEAVE = 7
    PROPOSAL_FAILED = 8
    PROPOSAL_DECLINED = 9
    GROUP_FOUND = 10
    ADDED_TO_QUEUE = 12
    PROPOSAL_BEGIN = 13
    STATUS = 14
    GROUP_MEMBER_OFFLINE = 15
    GROUP_DISBAND = 16


class LogFormat(enum.Enum):
    DEFAULT = 0
    DEBUG = 1


class LogoutResult(enum.Enum):
    SUCCESS = 0
    FAILURE_IN_COMBAT = 1
    FAILURE_FROZEN_BY_GM = 2
    FAILURE_JUMPING_OR_FALLING = 3


class LogoutSpeed(enum.Enum):
    DELAYED = 0
    INSTANT = 1


class LootMethod(enum.Enum):
    ERROR = 0
    CORPSE = 1
    PICKPOCKETING = 2
    FISHING = 3
    DISENCHANTING = 4
    SKINNING = 6
    FISHINGHOLE = 20
    FISHING_FAIL = 21
    INSIGNIA = 22


class LootMethodError(enum.Enum):
    DIDNT_KILL = 0
    TOO_FAR = 4
    BAD_FACING = 5
    LOCKED = 6
    NOTSTANDING = 8
    STUNNED = 9
    PLAYER_NOT_FOUND = 10
    PLAY_TIME_EXCEEDED = 11
    MASTER_INV_FULL = 12
    MASTER_UNIQUE_ITEM = 13
    MASTER_OTHER = 14
    ALREADY_PICKPOCKETED = 15
    NOT_WHILE_SHAPESHIFTED = 16


class LootSlotType(enum.Enum):
    TYPE_ALLOW_LOOT = 0
    TYPE_ROLL_ONGOING = 1
    TYPE_MASTER = 2
    TYPE_LOCKED = 3
    TYPE_OWNER = 4


class MailAction(enum.Enum):
    SEND = 0
    MONEY_TAKEN = 1
    ITEM_TAKEN = 2
    RETURNED_TO_SENDER = 3
    DELETED = 4
    MADE_PERMANENT = 5


class MailMessageType(enum.Enum):
    NORMAL = 0
    AUCTION = 2
    CREATURE = 3
    GAMEOBJECT = 4
    ITEM = 5


class MailResult(enum.Enum):
    OK = 0
    ERR_EQUIP_ERROR = 1
    ERR_CANNOT_SEND_TO_SELF = 2
    ERR_NOT_ENOUGH_MONEY = 3
    ERR_RECIPIENT_NOT_FOUND = 4
    ERR_NOT_YOUR_TEAM = 5
    ERR_INTERNAL_ERROR = 6
    ERR_DISABLED_FOR_TRIAL_ACC = 14
    ERR_RECIPIENT_CAP_REACHED = 15
    ERR_CANT_SEND_WRAPPED_COD = 16
    ERR_MAIL_AND_CHAT_SUSPENDED = 17
    ERR_TOO_MANY_ATTACHMENTS = 18
    ERR_MAIL_ATTACHMENT_INVALID = 19
    ERR_ITEM_HAS_EXPIRED = 21


class MailResultTwo(enum.Enum):
    OK = 0
    ERR_EQUIP_ERROR = 1
    ERR_CANNOT_SEND_TO_SELF = 2
    ERR_NOT_ENOUGH_MONEY = 3
    ERR_RECIPIENT_NOT_FOUND = 4
    ERR_NOT_YOUR_TEAM = 5
    ERR_INTERNAL_ERROR = 6
    ERR_DISABLED_FOR_TRIAL_ACC = 14
    ERR_RECIPIENT_CAP_REACHED = 15
    ERR_CANT_SEND_WRAPPED_COD = 16
    ERR_MAIL_AND_CHAT_SUSPENDED = 17
    ERR_TOO_MANY_ATTACHMENTS = 18
    ERR_MAIL_ATTACHMENT_INVALID = 19
    ERR_ITEM_HAS_EXPIRED = 21


class MailType(enum.Enum):
    NORMAL = 0
    AUCTION = 2
    CREATURE = 3
    GAMEOBJECT = 4
    ITEM = 5


class Map(enum.Enum):
    EASTERN_KINGDOMS = 0
    KALIMDOR = 1
    TESTING = 13
    SCOTT_TEST = 25
    ALTERAC_VALLEY = 30
    SHADOWFANG_KEEP = 33
    STORMWIND_STOCKADE = 34
    STORMWIND_PRISON = 35
    DEADMINES = 36
    AZSHARA_CRATER = 37
    COLLINS_TEST = 42
    WAILING_CAVERNS = 43
    MONASTERY_UNUSED = 44
    RAZORFEN_KRAUL = 47
    BLACKFATHOM_DEEPS = 48
    ULDAMAN = 70
    GNOMEREGAN = 90
    SUNKEN_TEMPLE = 109
    RAZORFEN_DOWNS = 129
    EMERALD_DREAM = 169
    SCARLET_MONASTERY = 189
    ZUL_FARRAK = 209
    BLACKROCK_SPIRE = 229
    BLACKROCK_DEPTHS = 230
    ONYXIAS_LAIR = 249
    OPENING_OF_THE_DARK_PORTAL = 269
    SCHOLOMANCE = 289
    ZUL_GURUB = 309
    STRATHOLME = 329
    MARAUDON = 349
    DEEPRUN_TRAM = 369
    RAGEFIRE_CHASM = 389
    MOLTEN_CORE = 409
    DIRE_MAUL = 429
    ALLIANCE_PVP_BARRACKS = 449
    HORDE_PVP_BARRACKS = 450
    DEVELOPMENT_LAND = 451
    BLACKWING_LAIR = 469
    WARSONG_GULCH = 489
    RUINS_OF_AHN_QIRAJ = 509
    ARATHI_BASIN = 529
    OUTLAND = 530
    AHN_QIRAJ_TEMPLE = 531
    KARAZHAN = 532
    NAXXRAMAS = 533
    THE_BATTLE_FOR_MOUNT_HYJAL = 534
    HELLFIRE_CITADEL_THE_SHATTERED_HALLS = 540
    HELLFIRE_CITADEL_THE_BLOOD_FURNACE = 542
    HELLFIRE_CITADEL_RAMPARTS = 543
    MAGTHERIDONS_LAIR = 544
    COILFANG_THE_STEAMVAULT = 545
    COILFANG_THE_UNDERBOG = 546
    COILFANG_THE_SLAVE_PENS = 547
    COILFANG_SERPENTSHRINE_CAVERN = 548
    TEMPEST_KEEP = 550
    TEMPEST_KEEP_THE_ARCATRAZ = 552
    TEMPEST_KEEP_THE_BOTANICA = 553
    TEMPEST_KEEP_THE_MECHANAR = 554
    AUCHINDOUN_SHADOW_LABYRINTH = 555
    AUCHINDOUN_SETHEKK_HALLS = 556
    AUCHINDOUN_MANA_TOMBS = 557
    AUCHINDOUN_AUCHENAI_CRYPTS = 558
    NAGRAND_ARENA = 559
    THE_ESCAPE_FROM_DURNHOLDE = 560
    BLADES_EDGE_ARENA = 562
    BLACK_TEMPLE = 564
    GRUULS_LAIR = 565
    EYE_OF_THE_STORM = 566
    ZUL_AMAN = 568
    NORTHREND = 571
    RUINS_OF_LORDAERON = 572
    EXTERIORTEST = 573
    UTGARDE_KEEP = 574
    UTGARDE_PINNACLE = 575
    THE_NEXUS = 576
    THE_OCULUS = 578
    THE_SUNWELL = 580
    TRANSPORT_RUT_THERAN_TO_AUBERDINE = 582
    TRANSPORT_MENETHIL_TO_THERAMORE = 584
    MAGISTERS_TERRACE = 585
    TRANSPORT_EXODAR_TO_AUBERDINE = 586
    TRANSPORT_FEATHERMOON_FERRY = 587
    TRANSPORT_MENETHIL_TO_AUBERDINE = 588
    TRANSPORT_ORGRIMMAR_TO_GROM_GOL = 589
    TRANSPORT_GROM_GOL_TO_UNDERCITY = 590
    TRANSPORT_UNDERCITY_TO_ORGRIMMAR = 591
    TRANSPORT_BOREAN_TUNDRA_TEST = 592
    TRANSPORT_BOOTY_BAY_TO_RATCHET = 593
    TRANSPORT_HOWLING_FJORD_SISTER_MERCY_QUEST = 594
    THE_CULLING_OF_STRATHOLME = 595
    TRANSPORT_NAGLFAR = 596
    CRAIG_TEST = 597
    SUNWELL_FIX_UNUSED = 598
    HALLS_OF_STONE = 599
    DRAK_THARON_KEEP = 600
    AZJOL_NERUB = 601
    HALLS_OF_LIGHTNING = 602
    ULDUAR = 603
    GUNDRAK = 604
    DEVELOPMENT_LAND_NON_WEIGHTED_TEXTURES = 605
    QA_AND_DVD = 606
    STRAND_OF_THE_ANCIENTS = 607
    VIOLET_HOLD = 608
    EBON_HOLD = 609
    TRANSPORT_TIRISFAL_TO_VENGEANCE_LANDING = 610
    TRANSPORT_MENETHIL_TO_VALGARDE = 612
    TRANSPORT_ORGRIMMAR_TO_WARSONG_HOLD = 613
    TRANSPORT_STORMWIND_TO_VALIANCE_KEEP = 614
    THE_OBSIDIAN_SANCTUM = 615
    THE_EYE_OF_ETERNITY = 616
    DALARAN_SEWERS = 617
    THE_RING_OF_VALOR = 618
    AHN_KAHET_THE_OLD_KINGDOM = 619
    TRANSPORT_MOA_KI_TO_UNU_PE = 620
    TRANSPORT_MOA_KI_TO_KAMAGUA = 621
    TRANSPORT_ORGRIMS_HAMMER = 622
    TRANSPORT_THE_SKYBREAKER = 623
    VAULT_OF_ARCHAVON = 624
    ISLE_OF_CONQUEST = 628
    ICECROWN_CITADEL = 631
    THE_FORGE_OF_SOULS = 632
    TRANSPORT_ALLIANCE_AIRSHIP_BG = 641
    TRANSPORT_HORDEAIRSHIPBG = 642
    TRANSPORT_ORGRIMMAR_TO_THUNDER_BLUFF = 647
    TRIAL_OF_THE_CRUSADER = 649
    TRIAL_OF_THE_CHAMPION = 650
    PIT_OF_SARON = 658
    HALLS_OF_REFLECTION = 668
    TRANSPORT_THE_SKYBREAKER_ICECROWN_CITADEL_RAID = 672
    TRANSPORT_ORGRIMS_HAMMER_ICECROWN_CITADEL_RAID = 673
    TRANSPORT_THE_SKYBREAKER_IC_DUNGEON = 712
    TRANSPORT_ORGRIMS_HAMMER_IC_DUNGEON = 713
    TRANSPORT_THE_MIGHTY_WIND_ICECROWN_CITADEL_RAID = 718
    STORMWIND = 723
    THE_RUBY_SANCTUM = 724


class MiniMoveOpcode(enum.Enum):
    SMSG_FORCE_MOVE_ROOT = 232
    SMSG_MOVE_FEATHER_FALL = 242
    SMSG_MOVE_WATER_WALK = 222
    SMSG_MOVE_SET_HOVER = 244


class MonsterMoveType(enum.Enum):
    NORMAL = 0
    STOP = 1
    FACING_SPOT = 2
    FACING_TARGET = 3
    FACING_ANGLE = 4


class MountResult(enum.Enum):
    INVALID_MOUNTEE = 0
    TOO_FAR_AWAY = 1
    ALREADY_MOUNTED = 2
    NOT_MOUNTABLE = 3
    NOT_YOUR_PET = 4
    OTHER = 5
    LOOTING = 6
    RACE_CANT_MOUNT = 7
    SHAPESHIFTED = 8
    FORCED_DISMOUNT = 9
    OK = 10


class NewItemChatAlert(enum.Enum):
    DO_NOT_SHOW = 0
    SHOW = 1


class NewItemCreationType(enum.Enum):
    RECEIVED = 0
    CREATED = 1


class NewItemSource(enum.Enum):
    LOOTED = 0
    FROM_NPC = 1


class ObjectType(enum.Enum):
    OBJECT = 0
    ITEM = 1
    CONTAINER = 2
    UNIT = 3
    PLAYER = 4
    GAME_OBJECT = 5
    DYNAMIC_OBJECT = 6
    CORPSE = 7


class PageTextMaterial(enum.Enum):
    NONE = 0
    PARCHMENT = 1
    STONE = 2
    MARBLE = 3
    SILVER = 4
    BRONZE = 5
    VALENTINE = 6
    ILLIDAN = 7


class PartyOperation(enum.Enum):
    INVITE = 0
    LEAVE = 2


class PartyResult(enum.Enum):
    SUCCESS = 0
    BAD_PLAYER_NAME = 1
    TARGET_NOT_IN_GROUP = 2
    TARGET_NOT_IN_INSTANCE = 3
    GROUP_FULL = 4
    ALREADY_IN_GROUP = 5
    NOT_IN_GROUP = 6
    NOT_LEADER = 7
    PLAYER_WRONG_FACTION = 8
    IGNORING_YOU = 9
    LFG_PENDING = 12
    INVITE_RESTRICTED = 13


class PartyRole(enum.Enum):
    MAIN_TANK = 0
    ASSISTANT = 1


class PetCommandState(enum.Enum):
    STAY = 0
    FOLLOW = 1
    ATTACK = 2
    DISMISS = 3


class PetEnabled(enum.Enum):
    ENABLED = 8
    DISABLED = 0


class PetFeedback(enum.Enum):
    PET_DEAD = 1
    NOTHING_TO_ATTACK = 2
    CANT_ATTACK_TARGET = 3
    NO_PATH_TO = 4


class PetNameInvalidReason(enum.Enum):
    INVALID = 1
    NO_NAME = 2
    TOO_SHORT = 3
    TOO_LONG = 4
    MIXED_LANGUAGES = 6
    PROFANE = 7
    RESERVED = 8
    THREE_CONSECUTIVE = 11
    INVALID_SPACE = 12
    CONSECUTIVE_SPACES = 13
    RUSSIAN_CONSECUTIVE_SILENT_CHARACTERS = 14
    RUSSIAN_SILENT_CHARACTER_AT_BEGINNING_OR_END = 15
    DECLENSION_DOESNT_MATCH_BASE_NAME = 16


class PetQueryDisabledNames(enum.Enum):
    PRESENT = 1
    NOT_PRESENT = 0


class PetReactState(enum.Enum):
    PASSIVE = 0
    DEFENSIVE = 1
    AGGRESSIVE = 2


class PetTalkReason(enum.Enum):
    SPECIAL_SPELL = 0
    ATTACK = 1


class PetTameFailureReason(enum.Enum):
    INVALID_CREATURE = 1
    TOO_MANY = 2
    CREATURE_ALREADY_OWNED = 3
    NOT_TAMEABLE = 4
    ANOTHER_SUMMON_ACTIVE = 5
    UNITS_CANT_TAME = 6
    NO_PET_AVAILABLE = 7
    INTERNA_LERROR = 8
    TOO_HIGH_LEVEL = 9
    DEAD = 10
    NOT_DEAD = 11
    CANT_CONTROL_EXOTIC = 12
    UNKNOWN_ERROR = 13


class PetitionResult(enum.Enum):
    OK = 0
    ALREADY_SIGNED = 1
    ALREADY_IN_GUILD = 2
    CANT_SIGN_OWN = 3
    NOT_SERVER = 4


class PlayerChatTag(enum.Enum):
    NONE = 0
    AFK = 1
    DND = 2
    GM = 3
    COMMENTATOR = 4
    DEVELOPER = 5


class PlayerInviteStatus(enum.Enum):
    ALREADY_IN_GROUP = 0
    NOT_IN_GROUP = 1


class Power(enum.Enum):
    MANA = 0
    RAGE = 1
    FOCUS = 2
    ENERGY = 3
    HAPPINESS = 4
    RUNE = 5
    RUNIC_POWER = 6
    HEALTH = 254


class PvpRank(enum.Enum):
    NO_RANK = 0
    PARIAH = 1
    OUTLAW = 2
    EXILED = 3
    DISHONORED = 4
    RANK1 = 5
    RANK2 = 6
    RANK3 = 7
    RANK4 = 8
    RANK5 = 9
    RANK6 = 10
    RANK7 = 11
    RANK8 = 12
    RANK9 = 13
    RANK10 = 14
    RANK11 = 15
    RANK12 = 16
    RANK13 = 17
    RANK14 = 18
    FACTION_LEADER = 19


class QuestCompletable(enum.Enum):
    NOT_COMPLETABLE = 0
    COMPLETEABLE = 3


class QuestFailedReason(enum.Enum):
    DONT_HAVE_REQ = 0
    QUEST_FAILED_LOW_LEVEL = 1
    QUEST_FAILED_WRONG_RACE = 6
    QUEST_ALREADY_DONE = 7
    QUEST_ONLY_ONE_TIMED = 12
    QUEST_ALREADY_ON = 13
    QUEST_FAILED_EXPANSION = 16
    QUEST_ALREADY_ON2 = 18
    QUEST_FAILED_MISSING_ITEMS = 21
    QUEST_FAILED_NOT_ENOUGH_MONEY = 23
    DAILY_QUESTS_REMAINING = 26
    QUEST_FAILED_CAIS = 27
    DAILY_QUEST_COMPLETED_TODAY = 29


class QuestGiverStatus(enum.Enum):
    NONE = 0
    UNAVAILABLE = 1
    LOW_LEVEL_AVAILABLE = 2
    LOW_LEVEL_REWARD_REP = 3
    LOW_LEVEL_AVAILABLE_REP = 4
    INCOMPLETE = 5
    REWARD_REP = 6
    AVAILABLE_REP = 7
    AVAILABLE = 8
    REWARD2 = 9
    REWARD = 10


class QuestPartyMessage(enum.Enum):
    MSG_SHARING_QUEST = 0
    MSG_CANT_TAKE_QUEST = 1
    MSG_ACCEPT_QUEST = 2
    MSG_REFUSE_QUEST = 3
    MSG_BUSY = 4
    MSG_LOG_FULL = 5
    MSG_HAVE_QUEST = 6
    MSG_FINISH_QUEST = 7
    MSG_CANT_BE_SHARED_TODAY = 8
    MSG_SHARING_TIMER_EXPIRED = 9
    MSG_NOT_IN_PARTY = 10
    MSG_DIFFERENT_SERVER_DAILY = 11


class Race(enum.Enum):
    HUMAN = 1
    ORC = 2
    DWARF = 3
    NIGHT_ELF = 4
    UNDEAD = 5
    TAUREN = 6
    GNOME = 7
    TROLL = 8
    GOBLIN = 9
    BLOOD_ELF = 10
    DRAENEI = 11
    FEL_ORC = 12
    NAGA = 13
    BROKEN = 14
    SKELETON = 15
    VRYKUL = 16
    TUSKARR = 17
    FOREST_TROLL = 18
    TAUNKA = 19
    NORTHREND_SKELETON = 20
    ICE_TROLL = 21


class RaidDifficulty(enum.Enum):
    TEN_MAN_NORMAL = 0
    TWENTY_FIVE_MAN_NORMAL = 1
    TEN_MAN_HEROIC = 2
    TWENTY_FIVE_MAN_HEROIC = 3


class RaidGroupError(enum.Enum):
    REQUIRED = 1
    FULL = 2


class RaidInstanceMessage(enum.Enum):
    WARNING_HOURS = 1
    WARNING_MIN = 2
    WARNING_MIN_SOON = 3
    WELCOME = 4
    EXPIRED = 5


class RaidTargetIndex(enum.Enum):
    UNKNOWN0 = 0
    UNKNOWN1 = 1
    UNKNOWN2 = 2
    UNKNOWN3 = 3
    UNKNOWN4 = 4
    UNKNOWN5 = 5
    UNKNOWN6 = 6
    UNKNOWN7 = 7
    UNKNOWN8 = 8
    REQUEST_ICONS = 255


class RaidTargetUpdateType(enum.Enum):
    PARTIAL = 0
    FULL = 1


class RandomBg(enum.Enum):
    NOT_RANDOM = 0
    RANDOM = 1


class RealmSplitState(enum.Enum):
    NORMAL = 0
    SPLIT = 1
    SPLIT_PENDING = 2


class ReferAFriendError(enum.Enum):
    NONE = 0
    NOT_REFERRED_BY = 1
    TARGET_TOO_HIGH = 2
    INSUFFICIENT_GRANTABLE_LEVELS = 3
    TOO_FAR = 4
    DIFFERENT_FACTION = 5
    NOT_NOW = 6
    GRANT_LEVEL_MAX = 7
    NO_TARGET = 8
    NOT_IN_GROUP = 9
    SUMMON_LEVEL_MAX = 10
    SUMMON_COOLDOWN = 11
    INSUFFICIENT_EXPANSION_LEVEL = 12
    SUMMON_OFFLINE = 13


class RollVote(enum.Enum):
    PASS = 0
    NEED = 1
    GREED = 2
    DISENCHANT = 3


class SellItemResult(enum.Enum):
    ERR_CANT_FIND_ITEM = 1
    ERR_CANT_SELL_ITEM = 2
    ERR_CANT_FIND_VENDOR = 3
    ERR_YOU_DONT_OWN_THAT_ITEM = 4
    ERR_UNK = 5
    ERR_ONLY_EMPTY_BAG = 6
    ERR_CANT_SELL_TO_THIS_MERCHANT = 7
    ERR_MUST_REPAIR_ITEM_DURABILITY_TO_USE = 8
    INTERNAL_BAG_ERROR = 9


class ServerMessageType(enum.Enum):
    SHUTDOWN_TIME = 1
    RESTART_TIME = 2
    CUSTOM = 3
    SHUTDOWN_CANCELLED = 4
    RESTART_CANCELLED = 5
    BATTLEGROUND_SHUTDOWN = 6
    BATTLEGROUND_RESTART = 7
    INSTANCE_SHUTDOWN = 8
    INSTANCE_RESTART = 9


class SheathState(enum.Enum):
    UNARMED = 0
    MELEE = 1
    RANGED = 2


class SheatheType(enum.Enum):
    NONE = 0
    MAIN_HAND = 1
    OFF_HAND = 2
    LARGE_WEAPON_LEFT = 3
    LARGE_WEAPON_RIGHT = 4
    HIP_WEAPON_LEFT = 5
    HIP_WEAPON_RIGHT = 6
    SHIELD = 7


class SizeClass(enum.Enum):
    NONE = -1
    SMALL = 0
    MEDIUM = 1
    LARGE = 2
    GIANT = 3
    COLOSSAL = 4


class Skill(enum.Enum):
    NONE = 0
    FROST = 6
    FIRE = 8
    ARMS = 26
    COMBAT = 38
    SUBTLETY = 39
    SWORDS = 43
    AXES = 44
    BOWS = 45
    GUNS = 46
    BEAST_MASTERY = 50
    SURVIVAL = 51
    MACES = 54
    TWO_HANDED_SWORDS = 55
    HOLY = 56
    SHADOW = 78
    DEFENSE = 95
    LANGUAGE_COMMON = 98
    RACIAL_DWARVEN = 101
    LANGUAGE_ORCISH = 109
    LANGUAGE_DWARVEN = 111
    LANGUAGE_DARNASSIAN = 113
    LANGUAGE_TAURAHE = 115
    DUAL_WIELD = 118
    RACIAL_TAUREN = 124
    ORC_RACIAL = 125
    RACIAL_NIGHT_ELF = 126
    FIRST_AID = 129
    FERAL_COMBAT = 134
    STAVES = 136
    LANGUAGE_THALASSIAN = 137
    LANGUAGE_DRACONIC = 138
    LANGUAGE_DEMON_TONGUE = 139
    LANGUAGE_TITAN = 140
    LANGUAGE_OLD_TONGUE = 141
    SURVIVAL2 = 142
    RIDING_HORSE = 148
    RIDING_WOLF = 149
    RIDING_TIGER = 150
    RIDING_RAM = 152
    SWIMMING = 155
    TWO_HANDED_MACES = 160
    UNARMED = 162
    MARKSMANSHIP = 163
    BLACKSMITHING = 164
    LEATHERWORKING = 165
    ALCHEMY = 171
    TWO_HANDED_AXES = 172
    DAGGERS = 173
    THROWN = 176
    HERBALISM = 182
    GENERIC_DND = 183
    RETRIBUTION = 184
    COOKING = 185
    MINING = 186
    PET_IMP = 188
    PET_FELHUNTER = 189
    TAILORING = 197
    ENGINEERING = 202
    PET_SPIDER = 203
    PET_VOIDWALKER = 204
    PET_SUCCUBUS = 205
    PET_INFERNAL = 206
    PET_DOOMGUARD = 207
    PET_WOLF = 208
    PET_CAT = 209
    PET_BEAR = 210
    PET_BOAR = 211
    PET_CROCILISK = 212
    PET_CARRION_BIRD = 213
    PET_CRAB = 214
    PET_GORILLA = 215
    PET_RAPTOR = 217
    PET_TALLSTRIDER = 218
    RACIAL_UNDED = 220
    CROSSBOWS = 226
    WANDS = 228
    POLEARMS = 229
    PET_SCORPID = 236
    ARCANE = 237
    PET_TURTLE = 251
    ASSASSINATION = 253
    FURY = 256
    PROTECTION = 257
    PROTECTION2 = 267
    PET_TALENTS = 270
    PLATE_MAIL = 293
    LANGUAGE_GNOMISH = 313
    LANGUAGE_TROLL = 315
    ENCHANTING = 333
    DEMONOLOGY = 354
    AFFLICTION = 355
    FISHING = 356
    ENHANCEMENT = 373
    RESTORATION = 374
    ELEMENTAL_COMBAT = 375
    SKINNING = 393
    MAIL = 413
    LEATHER = 414
    CLOTH = 415
    SHIELD = 433
    FIST_WEAPONS = 473
    RIDING_RAPTOR = 533
    RIDING_MECHANOSTRIDER = 553
    RIDING_UNDEAD_HORSE = 554
    RESTORATION2 = 573
    BALANCE = 574
    DESTRUCTION = 593
    HOLY2 = 594
    DISCIPLINE = 613
    LOCKPICKING = 633
    PET_BAT = 653
    PET_HYENA = 654
    PET_BIRD_OF_PREY = 655
    PET_WIND_SERPENT = 656
    LANGUAGE_GUTTERSPEAK = 673
    RIDING_KODO = 713
    RACIAL_TROLL = 733
    RACIAL_GNOME = 753
    RACIAL_HUMAN = 754
    JEWELCRAFTING = 755
    RACIAL_BLOODELF = 756
    PET_EVENT_RC = 758
    LANGUAGE_DRAENEI = 759
    RACIAL_DRAENEI = 760
    PET_FELGUARD = 761
    RIDING = 762
    PET_DRAGONHAWK = 763
    PET_NETHER_RAY = 764
    PET_SPOREBAT = 765
    PET_WARP_STALKER = 766
    PET_RAVAGER = 767
    PET_SERPENT = 768
    INTERNAL = 769
    DK_BLOOD = 770
    DK_FROST = 771
    DK_UNHOLY = 772
    INSCRIPTION = 773
    PET_MOTH = 775
    RUNEFORGING = 776
    MOUNTS = 777
    COMPANIONS = 778
    PET_EXOTIC_CHIMAERA = 780
    PET_EXOTIC_DEVILSAUR = 781
    PET_GHOUL = 782
    PET_EXOTIC_SILITHID = 783
    PET_EXOTIC_WORM = 784
    PET_WASP = 785
    PET_EXOTIC_RHINO = 786
    PET_EXOTIC_CORE_HOUND = 787
    PET_EXOTIC_SPIRIT_BEAST = 788


class SkillCategory(enum.Enum):
    ATTRIBUTE = 5
    WEAPON = 6
    CLASS = 7
    ARMOR = 8
    SECONDARY_PROFESSION = 9
    LANGUAGE = 10
    PRIMARY_PROFESSION = 11
    GENERIC = 12


class SpamType(enum.Enum):
    MAIL = 0
    CHAT = 1


class SpellCastResult(enum.Enum):
    SUCCESS = 0
    AFFECTING_COMBAT = 1
    ALREADY_AT_FULL_HEALTH = 2
    ALREADY_AT_FULL_MANA = 3
    ALREADY_AT_FULL_POWER = 4
    ALREADY_BEING_TAMED = 5
    ALREADY_HAVE_CHARM = 6
    ALREADY_HAVE_SUMMON = 7
    ALREADY_OPEN = 8
    AURA_BOUNCED = 9
    AUTOTRACK_INTERRUPTED = 10
    BAD_IMPLICIT_TARGETS = 11
    BAD_TARGETS = 12
    CANT_BE_CHARMED = 13
    CANT_BE_DISENCHANTED = 14
    CANT_BE_DISENCHANTED_SKILL = 15
    CANT_BE_MILLED = 16
    CANT_BE_PROSPECTED = 17
    CANT_CAST_ON_TAPPED = 18
    CANT_DUEL_WHILE_INVISIBLE = 19
    CANT_DUEL_WHILE_STEALTHED = 20
    CANT_STEALTH = 21
    CASTER_AURASTATE = 22
    CASTER_DEAD = 23
    CHARMED = 24
    CHEST_IN_USE = 25
    CONFUSED = 26
    DONT_REPORT = 27
    EQUIPPED_ITEM = 28
    EQUIPPED_ITEM_CLASS = 29
    EQUIPPED_ITEM_CLASS_MAINHAND = 30
    EQUIPPED_ITEM_CLASS_OFFHAND = 31
    ERROR = 32
    FIZZLE = 33
    FLEEING = 34
    FOOD_LOWLEVEL = 35
    HIGHLEVEL = 36
    HUNGER_SATIATED = 37
    IMMUNE = 38
    INCORRECT_AREA = 39
    INTERRUPTED = 40
    INTERRUPTED_COMBAT = 41
    ITEM_ALREADY_ENCHANTED = 42
    ITEM_GONE = 43
    ITEM_NOT_FOUND = 44
    ITEM_NOT_READY = 45
    LEVEL_REQUIREMENT = 46
    LINE_OF_SIGHT = 47
    LOWLEVEL = 48
    LOW_CASTLEVEL = 49
    MAINHAND_EMPTY = 50
    MOVING = 51
    NEED_AMMO = 52
    NEED_AMMO_POUCH = 53
    NEED_EXOTIC_AMMO = 54
    NEED_MORE_ITEMS = 55
    NOPATH = 56
    NOT_BEHIND = 57
    NOT_FISHABLE = 58
    NOT_FLYING = 59
    NOT_HERE = 60
    NOT_INFRONT = 61
    NOT_IN_CONTROL = 62
    NOT_KNOWN = 63
    NOT_MOUNTED = 64
    NOT_ON_TAXI = 65
    NOT_ON_TRANSPORT = 66
    NOT_READY = 67
    NOT_SHAPESHIFT = 68
    NOT_STANDING = 69
    NOT_TRADEABLE = 70
    NOT_TRADING = 71
    NOT_UNSHEATHED = 72
    NOT_WHILE_GHOST = 73
    NOT_WHILE_LOOTING = 74
    NO_AMMO = 75
    NO_CHARGES_REMAIN = 76
    NO_CHAMPION = 77
    NO_COMBO_POINTS = 78
    NO_DUELING = 79
    NO_ENDURANCE = 80
    NO_FISH = 81
    NO_ITEMS_WHILE_SHAPESHIFTED = 82
    NO_MOUNTS_ALLOWED = 83
    NO_PET = 84
    NO_POWER = 85
    NOTHING_TO_DISPEL = 86
    NOTHING_TO_STEAL = 87
    ONLY_ABOVEWATER = 88
    ONLY_DAYTIME = 89
    ONLY_INDOORS = 90
    ONLY_MOUNTED = 91
    ONLY_NIGHTTIME = 92
    ONLY_OUTDOORS = 93
    ONLY_SHAPESHIFT = 94
    ONLY_STEALTHED = 95
    ONLY_UNDERWATER = 96
    OUT_OF_RANGE = 97
    PACIFIED = 98
    POSSESSED = 99
    REAGENTS = 100
    REQUIRES_AREA = 101
    REQUIRES_SPELL_FOCUS = 102
    ROOTED = 103
    SILENCED = 104
    SPELL_IN_PROGRESS = 105
    SPELL_LEARNED = 106
    SPELL_UNAVAILABLE = 107
    STUNNED = 108
    TARGETS_DEAD = 109
    TARGET_AFFECTING_COMBAT = 110
    TARGET_AURASTATE = 111
    TARGET_DUELING = 112
    TARGET_ENEMY = 113
    TARGET_ENRAGED = 114
    TARGET_FRIENDLY = 115
    TARGET_IN_COMBAT = 116
    TARGET_IS_PLAYER = 117
    TARGET_IS_PLAYER_CONTROLLED = 118
    TARGET_NOT_DEAD = 119
    TARGET_NOT_IN_PARTY = 120
    TARGET_NOT_LOOTED = 121
    TARGET_NOT_PLAYER = 122
    TARGET_NO_POCKETS = 123
    TARGET_NO_WEAPONS = 124
    TARGET_NO_RANGED_WEAPONS = 125
    TARGET_UNSKINNABLE = 126
    THIRST_SATIATED = 127
    TOO_CLOSE = 128
    TOO_MANY_OF_ITEM = 129
    TOTEM_CATEGORY = 130
    TOTEMS = 131
    TRY_AGAIN = 132
    UNIT_NOT_BEHIND = 133
    UNIT_NOT_INFRONT = 134
    WRONG_PET_FOOD = 135
    NOT_WHILE_FATIGUED = 136
    TARGET_NOT_IN_INSTANCE = 137
    NOT_WHILE_TRADING = 138
    TARGET_NOT_IN_RAID = 139
    TARGET_FREEFORALL = 140
    NO_EDIBLE_CORPSES = 141
    ONLY_BATTLEGROUNDS = 142
    TARGET_NOT_GHOST = 143
    TRANSFORM_UNUSABLE = 144
    WRONG_WEATHER = 145
    DAMAGE_IMMUNE = 146
    PREVENTED_BY_MECHANIC = 147
    PLAY_TIME = 148
    REPUTATION = 149
    MIN_SKILL = 150
    NOT_IN_ARENA = 151
    NOT_ON_SHAPESHIFT = 152
    NOT_ON_STEALTHED = 153
    NOT_ON_DAMAGE_IMMUNE = 154
    NOT_ON_MOUNTED = 155
    TOO_SHALLOW = 156
    TARGET_NOT_IN_SANCTUARY = 157
    TARGET_IS_TRIVIAL = 158
    BM_OR_INVISGOD = 159
    EXPERT_RIDING_REQUIREMENT = 160
    ARTISAN_RIDING_REQUIREMENT = 161
    NOT_IDLE = 162
    NOT_INACTIVE = 163
    PARTIAL_PLAYTIME = 164
    NO_PLAYTIME = 165
    NOT_IN_BATTLEGROUND = 166
    NOT_IN_RAID_INSTANCE = 167
    ONLY_IN_ARENA = 168
    TARGET_LOCKED_TO_RAID_INSTANCE = 169
    ON_USE_ENCHANT = 170
    NOT_ON_GROUND = 171
    CUSTOM_ERROR = 172
    CANT_DO_THAT_RIGHT_NOW = 173
    TOO_MANY_SOCKETS = 174
    INVALID_GLYPH = 175
    UNIQUE_GLYPH = 176
    GLYPH_SOCKET_LOCKED = 177
    NO_VALID_TARGETS = 178
    ITEM_AT_MAX_CHARGES = 179
    NOT_IN_BARBERSHOP = 180
    FISHING_TOO_LOW = 181
    ITEM_ENCHANT_TRADE_WINDOW = 182
    SUMMON_PENDING = 183
    MAX_SOCKETS = 184
    PET_CAN_RENAME = 185
    TARGET_CANNOT_BE_RESURRECTED = 186
    UNKNOWN = 187


class SpellEffect(enum.Enum):
    NONE = 0
    INSTAKILL = 1
    SCHOOL_DAMAGE = 2
    DUMMY = 3
    PORTAL_TELEPORT = 4
    TELEPORT_UNITS = 5
    APPLY_AURA = 6
    ENVIRONMENTAL_DAMAGE = 7
    POWER_DRAIN = 8
    HEALTH_LEECH = 9
    HEAL = 10
    BIND = 11
    PORTAL = 12
    RITUAL_BASE = 13
    RITUAL_SPECIALIZE = 14
    RITUAL_ACTIVATE_PORTAL = 15
    QUEST_COMPLETE = 16
    WEAPON_DAMAGE_NOSCHOOL = 17
    RESURRECT = 18
    ADD_EXTRA_ATTACKS = 19
    DODGE = 20
    EVADE = 21
    PARRY = 22
    BLOCK = 23
    CREATE_ITEM = 24
    WEAPON = 25
    DEFENSE = 26
    PERSISTENT_AREA_AURA = 27
    SUMMON = 28
    LEAP = 29
    ENERGIZE = 30
    WEAPON_PERCENT_DAMAGE = 31
    TRIGGER_MISSILE = 32
    OPEN_LOCK = 33
    SUMMON_CHANGE_ITEM = 34
    APPLY_AREA_AURA_PARTY = 35
    LEARN_SPELL = 36
    SPELL_DEFENSE = 37
    DISPEL = 38
    LANGUAGE = 39
    DUAL_WIELD = 40
    JUMP = 41
    JUMP2 = 42
    TELEPORT_UNITS_FACE_CASTER = 43
    SKILL_STEP = 44
    ADD_HONOR = 45
    SPAWN = 46
    TRADE_SKILL = 47
    STEALTH = 48
    DETECT = 49
    TRANS_DOOR = 50
    FORCE_CRITICAL_HIT = 51
    GUARANTEE_HIT = 52
    ENCHANT_ITEM = 53
    ENCHANT_ITEM_TEMPORARY = 54
    TAMECREATURE = 55
    SUMMON_PET = 56
    LEARN_PET_SPELL = 57
    WEAPON_DAMAGE = 58
    OPEN_LOCK_ITEM = 59
    PROFICIENCY = 60
    SEND_EVENT = 61
    POWER_BURN = 62
    THREAT = 63
    TRIGGER_SPELL = 64
    APPLY_AREA_AURA_RAID = 65
    RESTORE_ITEM_CHARGES = 66
    HEAL_MAX_HEALTH = 67
    INTERRUPT_CAST = 68
    DISTRACT = 69
    PULL = 70
    PICKPOCKET = 71
    ADD_FARSIGHT = 72
    UNTRAIN_TALENTS = 73
    APPLY_GLYPH = 74
    HEAL_MECHANICAL = 75
    SUMMON_OBJECT_WILD = 76
    SCRIPT_EFFECT = 77
    ATTACK = 78
    SANCTUARY = 79
    ADD_COMBO_POINTS = 80
    CREATE_HOUSE = 81
    BIND_SIGHT = 82
    DUEL = 83
    STUCK = 84
    SUMMON_PLAYER = 85
    ACTIVATE_OBJECT = 86
    WMO_DAMAGE = 87
    WMO_REPAIR = 88
    WMO_CHANGE = 89
    KILL_CREDIT_PERSONAL = 90
    THREAT_ALL = 91
    ENCHANT_HELD_ITEM = 92
    BREAK_PLAYER_TARGETING = 93
    SELF_RESURRECT = 94
    SKINNING = 95
    CHARGE = 96
    SUMMON_ALL_TOTEMS = 97
    KNOCK_BACK = 98
    DISENCHANT = 99
    INEBRIATE = 100
    FEED_PET = 101
    DISMISS_PET = 102
    REPUTATION = 103
    SUMMON_OBJECT_SLOT1 = 104
    SUMMON_OBJECT_SLOT2 = 105
    SUMMON_OBJECT_SLOT3 = 106
    SUMMON_OBJECT_SLOT4 = 107
    DISPEL_MECHANIC = 108
    SUMMON_DEAD_PET = 109
    DESTROY_ALL_TOTEMS = 110
    DURABILITY_DAMAGE = 111
    UNKNOWN112 = 112
    RESURRECT_NEW = 113
    ATTACK_ME = 114
    DURABILITY_DAMAGE_PCT = 115
    SKIN_PLAYER_CORPSE = 116
    SPIRIT_HEAL = 117
    SKILL = 118
    APPLY_AREA_AURA_PET = 119
    TELEPORT_GRAVEYARD = 120
    NORMALIZED_WEAPON_DMG = 121
    UNKNOWN122 = 122
    SEND_TAXI = 123
    PLAYER_PULL = 124
    MODIFY_THREAT_PERCENT = 125
    STEAL_BENEFICIAL_BUFF = 126
    PROSPECTING = 127
    APPLY_AREA_AURA_FRIEND = 128
    APPLY_AREA_AURA_ENEMY = 129
    REDIRECT_THREAT = 130
    PLAY_SOUND = 131
    PLAY_MUSIC = 132
    UNLEARN_SPECIALIZATION = 133
    KILL_CREDIT_GROUP = 134
    CALL_PET = 135
    HEAL_PCT = 136
    ENERGIZE_PCT = 137
    LEAP_BACK = 138
    CLEAR_QUEST = 139
    FORCE_CAST = 140
    FORCE_CAST_WITH_VALUE = 141
    TRIGGER_SPELL_WITH_VALUE = 142
    APPLY_AREA_AURA_OWNER = 143
    KNOCKBACK_FROM_POSITION = 144
    GRAVITY_PULL = 145
    ACTIVATE_RUNE = 146
    QUEST_FAIL = 147
    UNKNOWN148 = 148
    CHARGE2 = 149
    QUEST_OFFER = 150
    TRIGGER_SPELL_2 = 151
    UNKNOWN152 = 152
    CREATE_PET = 153
    TEACH_TAXI_NODE = 154
    TITAN_GRIP = 155
    ENCHANT_ITEM_PRISMATIC = 156
    CREATE_ITEM2 = 157
    MILLING = 158
    ALLOW_RENAME_PET = 159
    UNKNOWN160 = 160
    TALENT_SPEC_COUNT = 161
    TALENT_SPEC_SELECT = 162
    UNKNOWN163 = 163
    CANCEL_AURA = 164


class SpellMissInfo(enum.Enum):
    NONE = 0
    MISS = 1
    RESIST = 2
    DODGE = 3
    PARRY = 4
    BLOCK = 5
    EVADE = 6
    IMMUNE = 7
    IMMUNE2 = 8
    DEFLECT = 9
    ABSORB = 10
    REFLECT = 11


class SpellSchool(enum.Enum):
    NORMAL = 0
    HOLY = 1
    FIRE = 2
    NATURE = 3
    FROST = 4
    SHADOW = 5
    ARCANE = 6


class SpellStealAction(enum.Enum):
    STEAL = 0
    CLEANSE = 1


class SpellTriggerType(enum.Enum):
    ON_USE = 0
    ON_EQUIP = 1
    CHANCE_ON_HIT = 2
    SERVER_SIDE_SCRIPT = 3
    SOULSTONE = 4
    NO_EQUIP_COOLDOWN = 5
    LEARN_SPELL_ID = 6


class StableResult(enum.Enum):
    ERR_MONEY = 1
    ERR_STABLE = 6
    SUCCESS_STABLE = 8
    SUCCESS_UNSTABLE = 9
    SUCCESS_BUY_SLOT = 10
    ERR_EXOTIC = 12


class StatusId(enum.Enum):
    NONE = 0
    WAIT_QUEUE = 1
    WAIT_JOIN = 2
    IN_PROGRESS = 3
    WAIT_LEAVE = 4


class Talent(enum.Enum):
    BURNING_SOUL = 23
    MOLTEN_SHIELDS = 24
    IMPROVED_SCORCH = 25
    IMPROVED_FIREBALL = 26
    IMPROVED_FIRE_BLAST = 27
    FLAME_THROWING = 28
    PYROBLAST = 29
    IMPACT = 30
    WORLD_IN_FLAMES = 31
    BLAST_WAVE = 32
    CRITICAL_MASS = 33
    IGNITE = 34
    FIRE_POWER = 35
    COMBUSTION = 36
    IMPROVED_FROSTBOLT = 37
    FROSTBITE = 38
    PIERCING_ICE = 61
    ICE_FLOES = 62
    IMPROVED_BLIZZARD = 63
    IMPROVED_CONE_OF_COLD = 64
    PERMAFROST = 65
    FROST_CHANNELING = 66
    SHATTER = 67
    WINTERS_CHILL = 68
    ICY_VEINS = 69
    FROST_WARDING = 70
    ICE_BARRIER = 71
    COLD_SNAP = 72
    ICE_SHARDS = 73
    ARCANE_SUBTLETY = 74
    ARCANE_CONCENTRATION = 75
    ARCANE_FOCUS = 76
    ARCANE_MIND = 77
    ARCANE_STABILITY = 80
    SPELL_IMPACT = 81
    MAGIC_ATTUNEMENT = 82
    ARCANE_SHIELDING = 83
    ARCANE_FORTITUDE = 85
    PRESENCE_OF_MIND = 86
    ARCANE_POWER = 87
    IMPROVED_COUNTERSPELL = 88
    DEEP_WOUNDS = 121
    SWORD_SPECIALIZATION = 123
    IMPROVED_HEROIC_STRIKE = 124
    WARRIOR_MACE_SPECIALIZATION = 125
    IMPROVED_CHARGE = 126
    IMPROVED_REND = 127
    TACTICAL_MASTERY = 128
    IMPROVED_HAMSTRING = 129
    WARRIOR_DEFLECTION = 130
    IMPROVED_OVERPOWER = 131
    POLEAXE_SPECIALIZATION = 132
    SWEEPING_STRIKES = 133
    WARRIOR_WEAPON_MASTERY = 134
    MORTAL_STRIKE = 135
    WARRIOR_TWO_HANDED_WEAPON_SPECIALIZATION = 136
    ANGER_MANAGEMENT = 137
    WARRIOR_ANTICIPATION = 138
    WARRIOR_TOUGHNESS = 140
    IMPROVED_THUNDER_CLAP = 141
    IMPROVED_BLOODRAGE = 142
    INCITE = 144
    PUNCTURE = 146
    IMPROVED_REVENGE = 147
    VIGILANCE = 148
    GAG_ORDER = 149
    IMPROVED_DISCIPLINES = 150
    IMPROVED_DISARM = 151
    CONCUSSION_BLOW = 152
    WARRIOR_LAST_STAND = 153
    COMMANDING_PRESENCE = 154
    ENRAGE = 155
    WARRIOR_FLURRY = 156
    CRUELTY = 157
    BOOMING_VOICE = 158
    UNBRIDLED_WRATH = 159
    PIERCING_HOWL = 160
    IMPROVED_DEMORALIZING_SHOUT = 161
    DEATH_WISH = 165
    IMPROVED_CLEAVE = 166
    BLOODTHIRST = 167
    ROGUE_PRECISION = 181
    CLOSE_QUARTERS_COMBAT = 182
    ROGUE_MACE_SPECIALIZATION = 184
    ROGUE_LIGHTNING_REFLEXES = 186
    ROGUE_DEFLECTION = 187
    IMPROVED_SINISTER_STRIKE = 201
    IMPROVED_GOUGE = 203
    ENDURANCE = 204
    ADRENALINE_RUSH = 205
    IMPROVED_KICK = 206
    ROGUE_DUAL_WIELD_SPECIALIZATION = 221
    IMPROVED_SPRINT = 222
    BLADE_FLURRY = 223
    MASTER_OF_DECEPTION = 241
    HACK_AND_SLASH = 242
    CAMOUFLAGE = 244
    INITIATIVE = 245
    SETUP = 246
    ELUSIVENESS = 247
    OPPORTUNITY = 261
    DIRTY_TRICKS = 262
    IMPROVED_AMBUSH = 263
    DIRTY_DEEDS = 265
    IMPROVED_POISONS = 268
    LETHALITY = 269
    MALICE = 270
    REMORSELESS_ATTACKS = 272
    RUTHLESSNESS = 273
    MURDER = 274
    IMPROVED_EVISCERATE = 276
    PUNCTURING_WOUNDS = 277
    IMPROVED_EXPOSE_ARMOR = 278
    IMPROVED_KIDNEY_SHOT = 279
    COLD_BLOOD = 280
    OVERKILL = 281
    SEAL_FATE = 283
    PREPARATION = 284
    RIPOSTE = 301
    GHOSTLY_STRIKE = 303
    MARTYRDOM = 321
    POWER_INFUSION = 322
    MENTAL_AGILITY = 341
    UNBREAKABLE_WILL = 342
    IMPROVED_POWER_WORD_SHIELD = 343
    IMPROVED_POWER_WORD_FORTITUDE = 344
    IMPROVED_INNER_FIRE = 346
    MEDITATION = 347
    INNER_FOCUS = 348
    IMPROVED_MANA_BURN = 350
    SOUL_WARDING = 351
    SILENT_RESOLVE = 352
    INSPIRATION = 361
    PREMEDITATION = 381
    VIGOR = 382
    HOLY_SPECIALIZATION = 401
    SPIRITUAL_GUIDANCE = 402
    SEARING_LIGHT = 403
    SPIRITUAL_HEALING = 404
    IMPROVED_RENEW = 406
    IMPROVED_HEALING = 408
    PRIEST_HEALING_FOCUS = 410
    SPELL_WARDING = 411
    HEALING_PRAYERS = 413
    ARCANE_INSTABILITY = 421
    DESPERATE_PRAYER = 442
    SHADOW_WEAVING = 461
    DARKNESS = 462
    SHADOW_FOCUS = 463
    SPIRIT_TAP = 465
    SHADOW_AFFINITY = 466
    IMPROVED_MIND_BLAST = 481
    IMPROVED_SHADOW_WORD_PAIN = 482
    VEILED_SHADOWS = 483
    VAMPIRIC_EMBRACE = 484
    MIND_FLAY = 501
    SHADOWFORM = 521
    SILENCE = 541
    IMPROVED_PSYCHIC_SCREAM = 542
    CALL_OF_FLAME = 561
    CALL_OF_THUNDER = 562
    CONCUSSION = 563
    CONVECTION = 564
    ELEMENTAL_FURY = 565
    IMPROVED_FIRE_NOVA = 567
    ELEMENTAL_MASTERY = 573
    ELEMENTAL_FOCUS = 574
    REVERBERATION = 575
    ANCESTRAL_HEALING = 581
    TIDAL_FORCE = 582
    IMPROVED_WATER_SHIELD = 583
    IMPROVED_HEALING_WAVE = 586
    SHAMAN_HEALING_FOCUS = 587
    RESTORATIVE_TOTEMS = 588
    IMPROVED_REINCARNATION = 589
    MANA_TIDE_TOTEM = 590
    SHAMAN_NATURES_SWIFTNESS = 591
    PURIFICATION = 592
    TIDAL_FOCUS = 593
    TIDAL_MASTERY = 594
    TOTEMIC_FOCUS = 595
    SHAMAN_ANTICIPATION = 601
    SHAMAN_FLURRY = 602
    IMPROVED_GHOST_WOLF = 605
    IMPROVED_SHIELDS = 607
    GUARDIAN_TOTEMS = 609
    ENHANCING_TOTEMS = 610
    ELEMENTAL_WEAPONS = 611
    THUNDERING_STRIKES = 613
    ANCESTRAL_KNOWLEDGE = 614
    SHAMAN_TOUGHNESS = 615
    SPIRIT_WEAPONS = 616
    SHAMANISTIC_FOCUS = 617
    IRON_WILL = 641
    BLOOD_CRAZE = 661
    IMPALE = 662
    HEMORRHAGE = 681
    VILE_POISONS = 682
    WARRIOR_ONE_HANDED_WEAPON_SPECIALIZATION = 702
    LIGHTNING_MASTERY = 721
    ARCTIC_REACH = 741
    STARLIGHT_WRATH = 762
    IMPROVED_MOONFIRE = 763
    NATURES_REACH = 764
    BRAMBLES = 782
    MOONGLOW = 783
    CELESTIAL_FOCUS = 784
    INSECT_SWARM = 788
    NATURES_GRACE = 789
    MOONFURY = 790
    DRUID_VENGEANCE = 792
    MOONKIN_FORM = 793
    DRUID_THICK_HIDE = 794
    FERAL_AGGRESSION = 795
    DRUID_FEROCITY = 796
    BRUTAL_IMPACT = 797
    SHARPENED_CLAWS = 798
    FERAL_INSTINCT = 799
    PRIMAL_FURY = 801
    SHREDDING_ATTACKS = 802
    PREDATORY_STRIKES = 803
    FERAL_CHARGE = 804
    SAVAGE_FURY = 805
    FERAL_SWIFTNESS = 807
    HEART_OF_THE_WILD = 808
    LEADER_OF_THE_PACK = 809
    IMPROVED_MARK_OF_THE_WILD = 821
    FUROR = 822
    NATURES_FOCUS = 823
    NATURALIST = 824
    NATURES_BOUNTY = 825
    NATURAL_SHAPESHIFTER = 826
    OMEN_OF_CLARITY = 827
    GIFT_OF_NATURE = 828
    DRUID_INTENSITY = 829
    IMPROVED_REJUVENATION = 830
    DRUID_NATURES_SWIFTNESS = 831
    SUBTLETY = 841
    IMPROVED_TRANQUILITY = 842
    TRANQUIL_SPIRIT = 843
    SWIFTMEND = 844
    SHADOW_REACH = 881
    STORMSTRIKE = 901
    CATACLYSM = 941
    BANE = 943
    IMPROVED_SHADOW_BOLT = 944
    IMPROVED_IMMOLATE = 961
    SHADOWBURN = 963
    DESTRUCTIVE_REACH = 964
    IMPROVED_SEARING_PAIN = 965
    EMBERSTORM = 966
    RUIN = 967
    CONFLAGRATE = 968
    DEVASTATION = 981
    AFTERMATH = 982
    DEMONIC_POWER = 983
    WARLOCK_INTENSITY = 985
    PYROCLASM = 986
    FEL_CONCENTRATION = 1001
    NIGHTFALL = 1002
    IMPROVED_CORRUPTION = 1003
    SOUL_SIPHON = 1004
    SUPPRESSION = 1005
    IMPROVED_CURSE_OF_WEAKNESS = 1006
    IMPROVED_LIFE_TAP = 1007
    GRIM_REACH = 1021
    DARK_PACT = 1022
    SIPHON_LIFE = 1041
    SHADOW_MASTERY = 1042
    AMPLIFY_CURSE = 1061
    CURSE_OF_EXHAUSTION = 1081
    IMPROVED_DRAIN_SOUL = 1101
    AGGRESSION = 1122
    SERRATED_BLADES = 1123
    INCINERATION = 1141
    ARCANE_MEDITATION = 1142
    DRUID_SURVIVAL_INSTINCTS = 1162
    DIVINE_FURY = 1181
    MENTAL_STRENGTH = 1201
    BORROWED_TIME = 1202
    IMPROVED_HEALTHSTONE = 1221
    IMPROVED_IMP = 1222
    DEMONIC_EMBRACE = 1223
    IMPROVED_HEALTH_FUNNEL = 1224
    DEMONIC_BRUTALITY = 1225
    FEL_DOMINATION = 1226
    MASTER_SUMMONER = 1227
    FEL_VITALITY = 1242
    IMPROVED_SUCCUBUS = 1243
    MASTER_DEMONOLOGIST = 1244
    MASTER_CONJUROR = 1261
    UNHOLY_POWER = 1262
    DEMONIC_KNOWLEDGE = 1263
    MANA_FEED = 1281
    SOUL_LINK = 1282
    MOLTEN_CORE = 1283
    IMPROVED_CURSE_OF_AGONY = 1284
    HUNTER_LIGHTNING_REFLEXES = 1303
    ENTRAPMENT = 1304
    TRAP_MASTERY = 1305
    LOCK_AND_LOAD = 1306
    SURVIVAL_TACTICS = 1309
    SUREFOOTED = 1310
    HUNTER_DEFLECTION = 1311
    COUNTERATTACK = 1312
    KILLER_INSTINCT = 1321
    BLACK_ARROW = 1322
    WYVERN_STING = 1325
    IMPROVED_CONCUSSIVE_SHOT = 1341
    EFFICIENCY = 1342
    IMPROVED_HUNTERS_MARK = 1343
    LETHAL_SHOTS = 1344
    AIMED_SHOT = 1345
    IMPROVED_ARCANE_SHOT = 1346
    BARRAGE = 1347
    IMPROVED_STINGS = 1348
    MORTAL_SHOTS = 1349
    CONCUSSIVE_BARRAGE = 1351
    READINESS = 1353
    TRUESHOT_AURA = 1361
    RANGED_WEAPON_SPECIALIZATION = 1362
    IMPROVED_ASPECT_OF_THE_MONKEY = 1381
    IMPROVED_ASPECT_OF_THE_HAWK = 1382
    PATHFINDING = 1384
    IMPROVED_MEND_PET = 1385
    BESTIAL_WRATH = 1386
    INTIMIDATION = 1387
    SPIRIT_BOND = 1388
    ENDURANCE_TRAINING = 1389
    BESTIAL_DISCIPLINE = 1390
    HUNTER_FEROCITY = 1393
    HUNTER_THICK_HIDE = 1395
    UNLEASHED_FURY = 1396
    FRENZY = 1397
    IMPROVED_BLESSING_OF_MIGHT = 1401
    PALADIN_VENGEANCE = 1402
    PALADIN_DEFLECTION = 1403
    BENEDICTION = 1407
    PALADIN_TWO_HANDED_WEAPON_SPECIALIZATION = 1410
    CONVICTION = 1411
    REDOUBT = 1421
    IMPROVED_DEVOTION_AURA = 1422
    PALADIN_TOUGHNESS = 1423
    GUARDIANS_FAVOR = 1425
    RECKONING = 1426
    PALADIN_ONE_HANDED_WEAPON_SPECIALIZATION = 1429
    HOLY_SHIELD = 1430
    BLESSING_OF_SANCTUARY = 1431
    SPIRITUAL_FOCUS = 1432
    DIVINE_FAVOR = 1433
    AURA_MASTERY = 1435
    REPENTANCE = 1441
    DIVINITY = 1442
    IMPROVED_LAY_ON_HANDS = 1443
    HEALING_LIGHT = 1444
    IMPROVED_BLESSING_OF_WISDOM = 1446
    DIVINE_INTELLECT = 1449
    IMPROVED_CONCENTRATION_AURA = 1450
    ILLUMINATION = 1461
    SEALS_OF_THE_PURE = 1463
    HEART_OF_THE_CRUSADER = 1464
    SANCTIFIED_LIGHT = 1465
    SEAL_OF_COMMAND = 1481
    IMPROVED_RIGHTEOUS_FURY = 1501
    HOLY_SHOCK = 1502
    IMPROVED_HAMMER_OF_JUSTICE = 1521
    IMPROVED_BERSERKER_RAGE = 1541
    IMPROVED_EXECUTE = 1542
    IMPROVED_INTERCEPT = 1543
    SPIRIT_OF_REDEMPTION = 1561
    WARRIOR_DUAL_WIELD_SPECIALIZATION = 1581
    SHIELD_SPECIALIZATION = 1601
    SAVAGE_STRIKES = 1621
    SURVIVALIST = 1622
    IMPROVED_TRACKING = 1623
    FOCUSED_FIRE = 1624
    IMPROVED_REVIVE_PET = 1625
    HOLY_POWER = 1627
    UNYIELDING_FAITH = 1628
    PALADIN_ANTICIPATION = 1629
    IMPROVED_JUDGEMENTS = 1631
    EYE_FOR_AN_EYE = 1632
    VINDICATION = 1633
    PURSUIT_OF_JUSTICE = 1634
    HOLY_REACH = 1635
    BLESSED_RECOVERY = 1636
    LIGHTWELL = 1637
    IMPROVED_VAMPIRIC_EMBRACE = 1638
    MASTER_OF_ELEMENTS = 1639
    ELEMENTAL_WARDING = 1640
    ELEMENTAL_REACH = 1641
    EYE_OF_THE_STORM = 1642
    SHAMAN_WEAPON_MASTERY = 1643
    ELEMENTAL_DEVASTATION = 1645
    HEALING_GRACE = 1646
    IMPROVED_WINDFURY_TOTEM = 1647
    HEALING_WAY = 1648
    MAGE_PRECISION = 1649
    MAGIC_ABSORPTION = 1650
    IMPROVED_DEFENSIVE_STANCE = 1652
    WARRIOR_VITALITY = 1653
    SHIELD_MASTERY = 1654
    IMPROVED_WHIRLWIND = 1655
    WARRIOR_PRECISION = 1657
    IMPROVED_BERSERKER_STANCE = 1658
    RAMPAGE = 1659
    FOCUSED_RAGE = 1660
    ENDLESS_RAGE = 1661
    SUDDEN_DEATH = 1662
    SECOND_WIND = 1663
    BLOOD_FRENZY = 1664
    DEVASTATE = 1666
    MALEDICTION = 1667
    IMPROVED_HOWL_OF_TERROR = 1668
    CONTAGION = 1669
    UNSTABLE_AFFLICTION = 1670
    DEMONIC_AEGIS = 1671
    SUMMON_FELGUARD = 1672
    DEMONIC_TACTICS = 1673
    SHADOWFURY = 1676
    SHADOW_AND_FLAME = 1677
    SOUL_LEECH = 1678
    NETHER_PROTECTION = 1679
    DEMONIC_RESILIENCE = 1680
    UNRELENTING_STORM = 1682
    ELEMENTAL_PRECISION = 1685
    LIGHTNING_OVERLOAD = 1686
    TOTEM_OF_WRATH = 1687
    UNLEASHED_RAGE = 1689
    DUAL_WIELD = 1690
    MENTAL_QUICKNESS = 1691
    SHAMAN_DUAL_WIELD_SPECIALIZATION = 1692
    SHAMANISTIC_RAGE = 1693
    SHAMAN_FOCUSED_MIND = 1695
    NATURES_BLESSING = 1696
    IMPROVED_CHAIN_HEAL = 1697
    EARTH_SHIELD = 1698
    NATURES_GUARDIAN = 1699
    SLEIGHT_OF_HAND = 1700
    HEIGHTENED_SENSES = 1701
    DEADLINESS = 1702
    WEAPON_EXPERTISE = 1703
    ROGUE_VITALITY = 1705
    BLADE_TWISTING = 1706
    NERVES_OF_STEEL = 1707
    SURPRISE_ATTACKS = 1709
    ENVELOPING_SHADOWS = 1711
    SINISTER_CALLING = 1712
    MASTER_OF_SUBTLETY = 1713
    SHADOWSTEP = 1714
    MASTER_POISONER = 1715
    FIND_WEAKNESS = 1718
    MUTILATE = 1719
    FLEET_FOOTED = 1721
    CHEAT_DEATH = 1722
    DEADENED_NERVES = 1723
    IMPROVED_BLINK = 1724
    ARCANE_POTENCY = 1725
    PRISMATIC_CLOAK = 1726
    ARCANE_EMPOWERMENT = 1727
    MIND_MASTERY = 1728
    SLOW = 1729
    PLAYING_WITH_FIRE = 1730
    BLAZING_SPEED = 1731
    MOLTEN_FURY = 1732
    PYROMANIAC = 1733
    EMPOWERED_FIRE = 1734
    DRAGONS_BREATH = 1735
    FROZEN_CORE = 1736
    COLD_AS_ICE = 1737
    ARCTIC_WINDS = 1738
    EMPOWERED_FROSTBOLT = 1740
    SUMMON_WATER_ELEMENTAL = 1741
    PURE_OF_HEART = 1742
    PURIFYING_POWER = 1743
    BLESSED_LIFE = 1744
    LIGHTS_GRACE = 1745
    HOLY_GUIDANCE = 1746
    DIVINE_ILLUMINATION = 1747
    STOICISM = 1748
    SACRED_DUTY = 1750
    ARDENT_DEFENDER = 1751
    COMBAT_EXPERTISE = 1753
    AVENGERS_SHIELD = 1754
    CRUSADE = 1755
    SANCTIFIED_RETRIBUTION = 1756
    DIVINE_PURPOSE = 1757
    JUDGEMENTS_OF_THE_WISE = 1758
    FANATICISM = 1759
    SANCTITY_OF_BATTLE = 1761
    QUICK_RECOVERY = 1762
    SHADOW_EMBRACE = 1763
    EMPOWERED_CORRUPTION = 1764
    BLESSED_RESILIENCE = 1765
    SURGE_OF_LIGHT = 1766
    EMPOWERED_HEALING = 1767
    HOLY_CONCENTRATION = 1768
    ABSOLUTION = 1769
    FOCUSED_POWER = 1771
    ENLIGHTENMENT = 1772
    IMPROVED_FLASH_HEAL = 1773
    PAIN_SUPPRESSION = 1774
    PRIEST_FOCUSED_MIND = 1777
    SHADOW_POWER = 1778
    VAMPIRIC_TOUCH = 1779
    MIND_MELT = 1781
    LUNAR_GUIDANCE = 1782
    BALANCE_OF_POWER = 1783
    DREAMSTATE = 1784
    IMPROVED_FAERIE_FIRE = 1785
    WRATH_OF_CENARIUS = 1786
    FORCE_OF_NATURE = 1787
    EMPOWERED_TOUCH = 1788
    EMPOWERED_REJUVENATION = 1789
    NATURAL_PERFECTION = 1790
    TREE_OF_LIFE = 1791
    NURTURING_INSTINCT = 1792
    PRIMAL_TENACITY = 1793
    SURVIVAL_OF_THE_FITTEST = 1794
    PREDATORY_INSTINCTS = 1795
    MANGLE = 1796
    LIVING_SPIRIT = 1797
    IMPROVED_LEADER_OF_THE_PACK = 1798
    ANIMAL_HANDLER = 1799
    FEROCIOUS_INSPIRATION = 1800
    CATLIKE_REFLEXES = 1801
    SERPENTS_SWIFTNESS = 1802
    THE_BEAST_WITHIN = 1803
    COMBAT_EXPERIENCE = 1804
    CAREFUL_AIM = 1806
    MASTER_MARKSMAN = 1807
    SILENCING_SHOT = 1808
    RESOURCEFULNESS = 1809
    HUNTER_SURVIVAL_INSTINCTS = 1810
    THRILL_OF_THE_HUNT = 1811
    EXPOSE_WEAKNESS = 1812
    MASTER_TACTICIAN = 1813
    SCATTER_SHOT = 1814
    CIRCLE_OF_HEALING = 1815
    MISERY = 1816
    BACKLASH = 1817
    GO_FOR_THE_THROAT = 1818
    RAPID_KILLING = 1819
    HAWK_EYE = 1820
    IMPROVED_BARRAGE = 1821
    NATURES_MAJESTY = 1822
    CRUSADER_STRIKE = 1823
    IMPROVED_MORTAL_STRIKE = 1824
    COMBAT_POTENCY = 1825
    SPELL_POWER = 1826
    IMPROVED_SLICE_AND_DICE = 1827
    ARCANE_FLOWS = 1843
    INCANTERS_ABSORPTION = 1844
    STUDENT_OF_THE_MIND = 1845
    NETHERWIND_PRESENCE = 1846
    ARCANE_BARRAGE = 1847
    FIERY_PAYBACK = 1848
    FIRESTARTER = 1849
    HOT_STREAK = 1850
    BURNOUT = 1851
    LIVING_BOMB = 1852
    FINGERS_OF_FROST = 1853
    BRAIN_FREEZE = 1854
    ENDURING_WINTER = 1855
    CHILLED_TO_THE_BONE = 1856
    DEEP_FREEZE = 1857
    FOCUSED_WILL = 1858
    TRAUMA = 1859
    UNRELENTING_ASSAULT = 1860
    STRENGTH_OF_ARMS = 1862
    BLADESTORM = 1863
    INTENSIFY_RAGE = 1864
    FURIOUS_ATTACKS = 1865
    BLOODSURGE = 1866
    TITANS_GRIP = 1867
    HEROIC_FURY = 1868
    SAFEGUARD = 1870
    SWORD_AND_BOARD = 1871
    SHOCKWAVE = 1872
    IMPROVED_FELHUNTER = 1873
    DEATHS_EMBRACE = 1875
    EVERLASTING_AFFLICTION = 1876
    ERADICATION = 1878
    DEMONIC_EMPOWERMENT = 1880
    IMPROVED_DEMONIC_TACTICS = 1882
    FEL_SYNERGY = 1883
    NEMESIS = 1884
    DEMONIC_PACT = 1885
    METAMORPHOSIS = 1886
    MOLTEN_SKIN = 1887
    BACKDRAFT = 1888
    IMPROVED_SOUL_LEECH = 1889
    FIRE_AND_BRIMSTONE = 1890
    CHAOS_BOLT = 1891
    CRITICAL_BLOCK = 1893
    ASPIRATION = 1894
    DIVINE_AEGIS = 1895
    RAPTURE = 1896
    PENANCE = 1897
    TWIN_DISCIPLINES = 1898
    GRACE = 1901
    EMPOWERED_RENEW = 1902
    TEST_OF_FAITH = 1903
    SERENDIPITY = 1904
    DIVINE_PROVIDENCE = 1905
    IMPROVED_SHADOWFORM = 1906
    TWISTED_FAITH = 1907
    PSYCHIC_HORROR = 1908
    PAIN_AND_SUFFERING = 1909
    DISPERSION = 1910
    GUARDIAN_SPIRIT = 1911
    IMPROVED_MOONKIN_FORM = 1912
    OWLKIN_FRENZY = 1913
    PRIMAL_PRECISION = 1914
    MASTER_SHAPESHIFTER = 1915
    GIFT_OF_THE_EARTHMOTHER = 1916
    WILD_GROWTH = 1917
    REND_AND_TEAR = 1918
    INFECTED_WOUNDS = 1919
    IMPROVED_MANGLE = 1920
    KING_OF_THE_JUNGLE = 1921
    LIVING_SEED = 1922
    TYPHOON = 1923
    ECLIPSE = 1924
    GALE_WINDS = 1925
    STARFALL = 1926
    BERSERK = 1927
    EARTH_AND_MOON = 1928
    REVITALIZE = 1929
    IMPROVED_TREE_OF_LIFE = 1930
    VIRULENCE = 1932
    MORBIDITY = 1933
    RAVENOUS_DEAD = 1934
    IMPROVED_BLOOD_PRESENCE = 1936
    BLADED_ARMOR = 1938
    BUTCHERY = 1939
    RUNE_TAP = 1941
    IMPROVED_RUNE_TAP = 1942
    DARK_CONVICTION = 1943
    BLOODY_VENGEANCE = 1944
    SUBVERSION = 1945
    SCENT_OF_BLOOD = 1948
    MARK_OF_BLOOD = 1949
    VETERAN_OF_THE_THIRD_WAR = 1950
    VENDETTA = 1953
    HYSTERIA = 1954
    SUDDEN_DOOM = 1955
    HEART_STRIKE = 1957
    MIGHT_OF_MOGRAINE = 1958
    WILL_OF_THE_NECROPOLIS = 1959
    BLOODWORMS = 1960
    DANCING_RUNE_WEAPON = 1961
    CRYPT_FEVER = 1962
    EPIDEMIC = 1963
    DEATH_KNIGHT_TOUGHNESS = 1968
    ENDLESS_WINTER = 1971
    BLACK_ICE = 1973
    FROST_STRIKE = 1975
    UNBREAKABLE_ARMOR = 1979
    DEATHCHILL = 1980
    CHILL_OF_THE_GRAVE = 1981
    MASTER_OF_GHOULS = 1984
    CORPSE_EXPLOSION = 1985
    HOWLING_BLAST = 1989
    FRIGID_DREADPLATE = 1990
    RIME = 1992
    MERCILESS_COMBAT = 1993
    UNHOLY_BLIGHT = 1996
    ACCLIMATION = 1997
    TUNDRA_STALKER = 1998
    HUNGERING_COLD = 1999
    SUMMON_GARGOYLE = 2000
    REAPING = 2001
    WANDERING_PLAGUE = 2003
    BLOOD_CAKED_BLADE = 2004
    IMPURITY = 2005
    BONE_SHIELD = 2007
    OUTBREAK = 2008
    MAGIC_SUPPRESSION = 2009
    DIRGE = 2011
    IMPROVED_UNHOLY_PRESENCE = 2013
    BLOODY_STRIKES = 2015
    BLADE_BARRIER = 2017
    SPELL_DEFLECTION = 2018
    VAMPIRIC_BLOOD = 2019
    RUNIC_POWER_MASTERY = 2020
    NERVES_OF_COLD_STEEL = 2022
    UNHOLY_COMMAND = 2025
    IMPROVED_SPIRIT_TAP = 2027
    IMPROVED_FROST_PRESENCE = 2029
    GLACIER_ROT = 2030
    IMPROVED_ICY_TOUCH = 2031
    BLOOD_GORGED = 2034
    ICY_REACH = 2035
    RAGE_OF_RIVENDARE = 2036
    ON_A_PALE_HORSE = 2039
    GUILE_OF_GOREFIEND = 2040
    HAUNT = 2041
    ICY_TALONS = 2042
    EBON_PLAGUEBRINGER = 2043
    KILLING_MACHINE = 2044
    EMPOWERED_IMP = 2045
    NECROSIS = 2047
    ANNIHILATION = 2048
    ELEMENTAL_OATH = 2049
    ASTRAL_SHIFT = 2050
    LAVA_FLOWS = 2051
    STORM_EARTH_AND_FIRE = 2052
    THUNDERSTORM = 2053
    IMPROVED_STORMSTRIKE = 2054
    STATIC_SHOCK = 2055
    EARTHEN_POWER = 2056
    MAELSTROM_WEAPON = 2057
    FERAL_SPIRIT = 2058
    IMPROVED_EARTH_SHIELD = 2059
    BLESSING_OF_THE_ETERNALS = 2060
    ANCESTRAL_AWAKENING = 2061
    TIDAL_WAVES = 2063
    RIPTIDE = 2064
    DEADLY_BREW = 2065
    TURN_THE_TABLES = 2066
    BLOOD_SPATTER = 2068
    FOCUSED_ATTACKS = 2069
    CUT_TO_THE_CHASE = 2070
    HUNGER_FOR_BLOOD = 2071
    THROWING_SPECIALIZATION = 2072
    UNFAIR_ADVANTAGE = 2073
    SAVAGE_COMBAT = 2074
    PREY_ON_THE_WEAK = 2075
    KILLING_SPREE = 2076
    WAYLAY = 2077
    HONOR_AMONG_THIEVES = 2078
    FILTHY_TRICKS = 2079
    SLAUGHTER_FROM_THE_SHADOWS = 2080
    SHADOW_DANCE = 2081
    VICIOUS_STRIKES = 2082
    MENTAL_DEXTERITY = 2083
    CLEANSE_SPIRIT = 2084
    GHOUL_FRENZY = 2085
    DEATH_RUNE_MASTERY = 2086
    EARTHS_GRASP = 2101
    ABOMINATIONS_MIGHT = 2105
    HUNTER_CULLING_THE_HERD = 2106
    HUNTER_COBRA_REFLEXES = 2107
    HUNTER_DASH = 2109
    HUNTER_CULLING_THE_HERD2 = 2110
    HUNTER_CHARGE = 2111
    HUNTER_GREAT_STAMINA = 2112
    HUNTER_NATURAL_ARMOR = 2113
    HUNTER_COBRA_REFLEXES2 = 2114
    HUNTER_GREAT_STAMINA2 = 2116
    HUNTER_NATURAL_ARMOR2 = 2117
    HUNTER_COBRA_REFLEXES3 = 2118
    HUNTER_DASH2 = 2119
    HUNTER_GREAT_STAMINA3 = 2120
    HUNTER_NATURAL_ARMOR3 = 2121
    PET_BARDING = 2122
    GUARD_DOG = 2123
    IMPROVED_COWER = 2124
    HUNTER_SPIKED_COLLAR = 2125
    HUNTER_SPIKED_COLLAR2 = 2126
    HUNTER_SPIKED_COLLAR3 = 2127
    BLOODTHIRSTY = 2128
    SPIDERS_BITE = 2129
    PIERCING_SHOTS = 2130
    RAPID_RECUPERATION = 2131
    WILD_QUIVER = 2132
    IMPROVED_STEADY_SHOT = 2133
    MARKED_FOR_DEATH = 2134
    CHIMERA_SHOT = 2135
    INVIGORATION = 2136
    COBRA_STRIKES = 2137
    ASPECT_MASTERY = 2138
    BEAST_MASTERY = 2139
    LONGEVITY = 2140
    NOXIOUS_STINGS = 2141
    POINT_OF_NO_ESCAPE = 2142
    SNIPER_TRAINING = 2143
    HUNTING_PARTY = 2144
    EXPLOSIVE_SHOT = 2145
    SANCTIFIED_WRATH = 2147
    SWIFT_RETRIBUTION = 2148
    RIGHTEOUS_VENGEANCE = 2149
    DIVINE_STORM = 2150
    HUNTER_BOARS_SPEED = 2151
    HUNTER_LIONHEARTED = 2152
    LICK_YOUR_WOUNDS = 2153
    HUNTER_GREAT_RESISTANCE = 2154
    RABID = 2155
    HEART_OF_THE_PHOENIX = 2156
    CALL_OF_THE_WILD = 2157
    HUNTER_BOARS_SPEED2 = 2160
    HUNTER_GREAT_RESISTANCE2 = 2161
    HUNTER_LIONHEARTED2 = 2162
    HUNTER_GRACE_OF_THE_MANTIS = 2163
    HUNTER_BOARS_SPEED3 = 2165
    HUNTER_CULLING_THE_HERD3 = 2166
    HUNTER_LIONHEARTED3 = 2167
    HUNTER_GREAT_RESISTANCE3 = 2168
    INTERVENE = 2169
    TAUNT = 2170
    HUNTER_LAST_STAND = 2171
    HUNTER_ROAR_OF_SACRIFICE = 2172
    BLOOD_OF_THE_RHINO = 2173
    BULLHEADED = 2175
    THE_ART_OF_WAR = 2176
    CORNERED = 2177
    SHEATH_OF_LIGHT = 2179
    WOLVERINE_BITE = 2181
    OWLS_FOCUS = 2182
    FEEDING_FRENZY = 2183
    ROAR_OF_RECOVERY = 2184
    DIVINE_STRENGTH = 2185
    SACRED_CLEANSING = 2190
    ENLIGHTENED_JUDGEMENTS = 2191
    BEACON_OF_LIGHT = 2192
    INFUSION_OF_LIGHT = 2193
    GUARDED_BY_THE_LIGHT = 2194
    TOUCHED_BY_THE_LIGHT = 2195
    HAMMER_OF_THE_RIGHTEOUS = 2196
    FOCUSED_AIM = 2197
    BLESSED_HANDS = 2198
    JUDGEMENTS_OF_THE_PURE = 2199
    JUDGEMENTS_OF_THE_JUST = 2200
    HUNTER_DIVE = 2201
    HUNTER_DIVE2 = 2203
    SHIELD_OF_THE_TEMPLAR = 2204
    IMPROVED_FEAR = 2205
    CARRION_FEEDER = 2206
    HUNTER_MOBILITY = 2207
    HUNTER_MOBILITY2 = 2208
    MISSILE_BARRAGE = 2209
    BLOOD_OF_THE_NORTH = 2210
    FOCUS_MAGIC = 2211
    BURNING_DETERMINATION = 2212
    SHATTERED_BARRIER = 2214
    LICHBORNE = 2215
    SCOURGE_STRIKE = 2216
    DEATH_KNIGHT_TWO_HANDED_WEAPON_SPECIALIZATION = 2217
    DEATH_KNIGHT_ANTICIPATION = 2218
    SWOOP = 2219
    ANTI_MAGIC_ZONE = 2221
    TORMENT_THE_WEAK = 2222
    IMPROVED_ICY_TALONS = 2223
    NIGHT_OF_THE_DEAD = 2225
    DESECRATION = 2226
    KINDRED_SPIRITS = 2227
    HUNTER_VS_WILD = 2228
    T_N_T = 2229
    WRECKING_CREW = 2231
    TASTE_FOR_BLOOD = 2232
    IMPROVED_SLAM = 2233
    UNENDING_FURY = 2234
    RENEWED_HOPE = 2235
    WARBRINGER = 2236
    HUNTER_CHARGE2 = 2237
    GENESIS = 2238
    IMPROVED_INSECT_SWARM = 2239
    NATURES_SPLENDOR = 2240
    PROTECTOR_OF_THE_PACK = 2241
    NATURAL_REACTION = 2242
    RELENTLESS_STRIKES = 2244
    PANDEMIC = 2245
    DAMAGE_SHIELD = 2246
    IMPROVED_SPELL_REFLECTION = 2247
    LAVA_LASH = 2249
    ARMORED_TO_THE_TEETH = 2250
    SHAMANISM = 2252
    HUNTER_WILD_HUNT = 2253
    SHARK_ATTACK = 2254
    HUNTER_WILD_HUNT2 = 2255
    HUNTER_WILD_HUNT3 = 2256
    HUNTER_GRACE_OF_THE_MANTIS2 = 2257
    SILVERBACK = 2258
    IMPROVED_DEATH_STRIKE = 2259
    CHILBLAINS = 2260
    DECIMATION = 2261
    BOOMING_ECHOES = 2262
    FROZEN_POWER = 2263
    IMPROVED_BARKSKIN = 2264
    PRIMAL_GORE = 2266
    IMPROVED_DEVOURING_PLAGUE = 2267
    REFLECTIVE_SHIELD = 2268
    THUNDERSTOMP = 2277
    HUNTER_ROAR_OF_SACRIFICE2 = 2278
    BODY_AND_SOUL = 2279
    DIVINE_SACRIFICE = 2280
    DIVINE_GUARDIAN = 2281
    SPIRITUAL_ATTUNEMENT = 2282
    JUGGERNAUT = 2283
    THREAT_OF_THASSARIAN = 2284
    DESOLATION = 2285


class TalentInfoType(enum.Enum):
    PLAYER = 0
    PET = 1


class TextEmote(enum.Enum):
    AGREE = 1
    AMAZE = 2
    ANGRY = 3
    APOLOGIZE = 4
    APPLAUD = 5
    BASHFUL = 6
    BECKON = 7
    BEG = 8
    BITE = 9
    BLEED = 10
    BLINK = 11
    BLUSH = 12
    BONK = 13
    BORED = 14
    BOUNCE = 15
    BRB = 16
    BOW = 17
    BURP = 18
    BYE = 19
    CACKLE = 20
    CHEER = 21
    CHICKEN = 22
    CHUCKLE = 23
    CLAP = 24
    CONFUSED = 25
    CONGRATULATE = 26
    COUGH = 27
    COWER = 28
    CRACK = 29
    CRINGE = 30
    CRY = 31
    CURIOUS = 32
    CURTSEY = 33
    DANCE = 34
    DRINK = 35
    DROOL = 36
    EAT = 37
    EYE = 38
    FART = 39
    FIDGET = 40
    FLEX = 41
    FROWN = 42
    GASP = 43
    GAZE = 44
    GIGGLE = 45
    GLARE = 46
    GLOAT = 47
    GREET = 48
    GRIN = 49
    GROAN = 50
    GROVEL = 51
    GUFFAW = 52
    HAIL = 53
    HAPPY = 54
    HELLO = 55
    HUG = 56
    HUNGRY = 57
    KISS = 58
    KNEEL = 59
    LAUGH = 60
    LAYDOWN = 61
    MASSAGE = 62
    MOAN = 63
    MOON = 64
    MOURN = 65
    NO = 66
    NOD = 67
    NOSE_PICK = 68
    PANIC = 69
    PEER = 70
    PLEAD = 71
    POINT = 72
    POKE = 73
    PRAY = 74
    ROAR = 75
    ROFL = 76
    RUDE = 77
    SALUTE = 78
    SCRATCH = 79
    SEXY = 80
    SHAKE = 81
    SHOUT = 82
    SHRUG = 83
    SHY = 84
    SIGH = 85
    SIT = 86
    SLEEP = 87
    SNARL = 88
    SPIT = 89
    STARE = 90
    SURPRISED = 91
    SURRENDER = 92
    TALK = 93
    TALK_EX = 94
    TALK_Q = 95
    TAP = 96
    THANK = 97
    THREATEN = 98
    TIRED = 99
    VICTORY = 100
    WAVE = 101
    WELCOME = 102
    WHINE = 103
    WHISTLE = 104
    WORK = 105
    YAWN = 106
    BOGGLE = 107
    CALM = 108
    COLD = 109
    COMFORT = 110
    CUDDLE = 111
    DUCK = 112
    INSULT = 113
    INTRODUCE = 114
    JK = 115
    LICK = 116
    LISTEN = 117
    LOST = 118
    MOCK = 119
    PONDER = 120
    POUNCE = 121
    PRAISE = 122
    PURR = 123
    PUZZLE = 124
    RAISE = 125
    READY = 126
    SHIMMY = 127
    SHIVER = 128
    SHOO = 129
    SLAP = 130
    SMIRK = 131
    SNIFF = 132
    SNUB = 133
    SOOTHE = 134
    STINK = 135
    TAUNT = 136
    TEASE = 137
    THIRSTY = 138
    VETO = 139
    SNICKER = 140
    STAND = 141
    TICKLE = 142
    VIOLIN = 143
    SMILE = 163
    RASP = 183
    PITY = 203
    GROWL = 204
    BARK = 205
    SCARED = 223
    FLOP = 224
    LOVE = 225
    MOO = 226
    COMMEND = 243
    TRAIN = 264
    HELPME = 303
    INCOMING = 304
    CHARGE = 305
    FLEE = 306
    ATTACK_MY_TARGET = 307
    OOM = 323
    FOLLOW = 324
    WAIT = 325
    HEAL_ME = 326
    OPEN_FIRE = 327
    FLIRT = 328
    JOKE = 329
    GOLF_CLAP = 343
    WINK = 363
    PAT = 364
    SERIOUS = 365
    MOUNT_SPECIAL = 366
    GOOD_LUCK = 367
    BLAME = 368
    BLANK = 369
    BRANDISH = 370
    BREATH = 371
    DISAGREE = 372
    DOUBT = 373
    EMBARRASS = 374
    ENCOURAGE = 375
    ENEMY = 376
    EYE_BROW = 377
    TOAST = 378
    FAIL = 379
    HIGH_FIVE = 380
    ABSENT = 381
    ARM = 382
    AWE = 383
    BACKPACK = 384
    BAD_FEELING = 385
    CHALLENGE = 386
    CHUG = 387
    DING = 389
    FACE_PALM = 390
    FAINT = 391
    GO = 392
    GOING = 393
    GLOWER = 394
    HEADACHE = 395
    HICCUP = 396
    HISS = 398
    HOLD_HAND = 399
    HURRY = 401
    IDEA = 402
    JEALOUS = 403
    LUCK = 404
    MAP = 405
    MERCY = 406
    MUTTER = 407
    NERVOUS = 408
    OFFER = 409
    PET = 410
    PINCH = 411
    PROUD = 413
    PROMISE = 414
    PULSE = 415
    PUNCH = 416
    POUT = 417
    REGRET = 418
    REVENGE = 420
    ROLL_EYES = 421
    RUFFLE = 422
    SAD = 423
    SCOFF = 424
    SCOLD = 425
    SCOWL = 426
    SEARCH = 427
    SHAKEFIST = 428
    SHIFTY = 429
    SHUDDER = 430
    SIGNAL = 431
    SILENCE = 432
    SING = 433
    SMACK = 434
    SNEAK = 435
    SNEEZE = 436
    SNORT = 437
    SQUEAL = 438
    STOP_ATTACK = 439
    SUSPICIOUS = 440
    THINK = 441
    TRUCE = 442
    TWIDDLE = 443
    WARN = 444
    SNAP = 445
    CHARM = 446
    COVER_EARS = 447
    CROSS_ARMS = 448
    LOOK = 449
    OBJECT = 450
    SWEAT = 451
    YW = 453


class TimerType(enum.Enum):
    FATIGUE = 0
    BREATH = 1
    FEIGN_DEATH = 2
    ENVIRONMENTAL = 3


class TitleEarnStatus(enum.Enum):
    LOST = 0
    EARNED = 1


class TradeStatus(enum.Enum):
    BUSY = 0
    BEGIN_TRADE = 1
    OPEN_WINDOW = 2
    TRADE_CANCELED = 3
    TRADE_ACCEPT = 4
    BUSY_2 = 5
    NO_TARGET = 6
    BACK_TO_TRADE = 7
    TRADE_COMPLETE = 8
    TRADE_REJECTED = 9
    TARGET_TO_FAR = 10
    WRONG_FACTION = 11
    CLOSE_WINDOW = 12
    UNKNOWN_13 = 13
    IGNORE_YOU = 14
    YOU_STUNNED = 15
    TARGET_STUNNED = 16
    YOU_DEAD = 17
    TARGET_DEAD = 18
    YOU_LOGOUT = 19
    TARGET_LOGOUT = 20
    TRIAL_ACCOUNT = 21
    ONLY_CONJURED = 22
    NOT_ON_TAPLIST = 23


class TrainerSpellState(enum.Enum):
    GREEN = 0
    RED = 1
    GRAY = 2


class TrainingFailureReason(enum.Enum):
    UNAVAILABLE = 0
    NOT_ENOUGH_MONEY = 1
    NOT_ENOUGH_SKILL = 2


class TransferAbortReason(enum.Enum):
    NONE = 0
    ERROR = 1
    MAX_PLAYERS = 2
    NOT_FOUND = 3
    TOO_MANY_INSTANCES = 4
    ZONE_IN_COMBAT = 6
    INSUFFICIENT_EXPANSION_LEVEL = 7
    DIFFICULTY_NOT_AVAILABLE = 8
    UNIQUE_MESSAGE = 9
    TOO_MANY_REALM_INSTANCES = 10
    NEED_GROUP = 11
    NOT_FOUND1 = 12
    NOT_FOUND2 = 13
    NOT_FOUND3 = 14
    REALM_ONLY = 15
    MAP_NOT_ALLOWED = 16


class UnitStandState(enum.Enum):
    STAND = 0
    SIT = 1
    SIT_CHAIR = 2
    SLEEP = 3
    SIT_LOW_CHAIR = 4
    SIT_MEDIUM_CHAIR = 5
    SIT_HIGH_CHAIR = 6
    DEAD = 7
    KNEEL = 8
    CUSTOM = 9


class UpdateType(enum.Enum):
    VALUES = 0
    MOVEMENT = 1
    CREATE_OBJECT = 2
    CREATE_OBJECT2 = 3
    OUT_OF_RANGE_OBJECTS = 4
    NEAR_OBJECTS = 5


class WeatherChangeType(enum.Enum):
    SMOOTH = 0
    INSTANT = 1


class WeatherType(enum.Enum):
    FINE = 0
    FOG = 1
    LIGHT_RAIN = 3
    MEDIUM_RAIN = 4
    HEAVY_RAIN = 5
    LIGHT_SNOW = 6
    MEDIUM_SNOW = 7
    HEAVY_SNOW = 8
    LIGHT_SANDSTORM = 22
    MEDIUM_SANDSTORM = 41
    HEAVY_SANDSTORM = 42
    THUNDERS = 86
    BLACKRAIN = 90


class WorldResult(enum.Enum):
    RESPONSE_SUCCESS = 0
    RESPONSE_FAILURE = 1
    RESPONSE_CANCELLED = 2
    RESPONSE_DISCONNECTED = 3
    RESPONSE_FAILED_TO_CONNECT = 4
    RESPONSE_CONNECTED = 5
    RESPONSE_VERSION_MISMATCH = 6
    CSTATUS_CONNECTING = 7
    CSTATUS_NEGOTIATING_SECURITY = 8
    CSTATUS_NEGOTIATION_COMPLETE = 9
    CSTATUS_NEGOTIATION_FAILED = 10
    CSTATUS_AUTHENTICATING = 11
    AUTH_OK = 12
    AUTH_FAILED = 13
    AUTH_REJECT = 14
    AUTH_BAD_SERVER_PROOF = 15
    AUTH_UNAVAILABLE = 16
    AUTH_SYSTEM_ERROR = 17
    AUTH_BILLING_ERROR = 18
    AUTH_BILLING_EXPIRED = 19
    AUTH_VERSION_MISMATCH = 20
    AUTH_UNKNOWN_ACCOUNT = 21
    AUTH_INCORRECT_PASSWORD = 22
    AUTH_SESSION_EXPIRED = 23
    AUTH_SERVER_SHUTTING_DOWN = 24
    AUTH_ALREADY_LOGGING_IN = 25
    AUTH_LOGIN_SERVER_NOT_FOUND = 26
    AUTH_WAIT_QUEUE = 27
    AUTH_BANNED = 28
    AUTH_ALREADY_ONLINE = 29
    AUTH_NO_TIME = 30
    AUTH_DB_BUSY = 31
    AUTH_SUSPENDED = 32
    AUTH_PARENTAL_CONTROL = 33
    AUTH_LOCKED_ENFORCED = 34
    REALM_LIST_IN_PROGRESS = 35
    REALM_LIST_SUCCESS = 36
    REALM_LIST_FAILED = 37
    REALM_LIST_INVALID = 38
    REALM_LIST_REALM_NOT_FOUND = 39
    ACCOUNT_CREATE_IN_PROGRESS = 40
    ACCOUNT_CREATE_SUCCESS = 41
    ACCOUNT_CREATE_FAILED = 42
    CHAR_LIST_RETRIEVING = 43
    CHAR_LIST_RETRIEVED = 44
    CHAR_LIST_FAILED = 45
    CHAR_CREATE_IN_PROGRESS = 46
    CHAR_CREATE_SUCCESS = 47
    CHAR_CREATE_ERROR = 48
    CHAR_CREATE_FAILED = 49
    CHAR_CREATE_NAME_IN_USE = 50
    CHAR_CREATE_DISABLED = 51
    CHAR_CREATE_PVP_TEAMS_VIOLATION = 52
    CHAR_CREATE_SERVER_LIMIT = 53
    CHAR_CREATE_ACCOUNT_LIMIT = 54
    CHAR_CREATE_SERVER_QUEUE = 55
    CHAR_CREATE_ONLY_EXISTING = 56
    CHAR_CREATE_EXPANSION = 57
    CHAR_CREATE_EXPANSION_CLASS = 58
    CHAR_CREATE_LEVEL_REQUIREMENT = 59
    CHAR_CREATE_UNIQUE_CLASS_LIMIT = 60
    CHAR_CREATE_CHARACTER_IN_GUILD = 61
    CHAR_CREATE_RESTRICTED_RACECLASS = 62
    CHAR_CREATE_CHARACTER_CHOOSE_RACE = 63
    CHAR_CREATE_CHARACTER_ARENA_LEADER = 64
    CHAR_CREATE_CHARACTER_DELETE_MAIL = 65
    CHAR_CREATE_CHARACTER_SWAP_FACTION = 66
    CHAR_CREATE_CHARACTER_RACE_ONLY = 67
    CHAR_CREATE_CHARACTER_GOLD_LIMIT = 68
    CHAR_CREATE_FORCE_LOGIN = 69
    CHAR_DELETE_IN_PROGRESS = 70
    CHAR_DELETE_SUCCESS = 71
    CHAR_DELETE_FAILED = 72
    CHAR_DELETE_FAILED_LOCKED_FOR_TRANSFER = 73
    CHAR_DELETE_FAILED_GUILD_LEADER = 74
    CHAR_DELETE_FAILED_ARENA_CAPTAIN = 75
    CHAR_LOGIN_IN_PROGRESS = 76
    CHAR_LOGIN_SUCCESS = 77
    CHAR_LOGIN_NO_WORLD = 78
    CHAR_LOGIN_DUPLICATE_CHARACTER = 79
    CHAR_LOGIN_NO_INSTANCES = 80
    CHAR_LOGIN_FAILED = 81
    CHAR_LOGIN_DISABLED = 82
    CHAR_LOGIN_NO_CHARACTER = 83
    CHAR_LOGIN_LOCKED_FOR_TRANSFER = 84
    CHAR_LOGIN_LOCKED_BY_BILLING = 85
    CHAR_LOGIN_LOCKED_BY_MOBILE_AH = 86
    CHAR_NAME_SUCCESS = 87
    CHAR_NAME_FAILURE = 88
    CHAR_NAME_NO_NAME = 89
    CHAR_NAME_TOO_SHORT = 90
    CHAR_NAME_TOO_LONG = 91
    CHAR_NAME_INVALID_CHARACTER = 92
    CHAR_NAME_MIXED_LANGUAGES = 93
    CHAR_NAME_PROFANE = 94
    CHAR_NAME_RESERVED = 95
    CHAR_NAME_INVALID_APOSTROPHE = 96
    CHAR_NAME_MULTIPLE_APOSTROPHES = 97
    CHAR_NAME_THREE_CONSECUTIVE = 98
    CHAR_NAME_INVALID_SPACE = 99
    CHAR_NAME_CONSECUTIVE_SPACES = 100
    CHAR_NAME_RUSSIAN_CONSECUTIVE_SILENT_CHARACTERS = 101
    CHAR_NAME_RUSSIAN_SILENT_CHARACTER_AT_BEGINNING_OR_END = 102
    CHAR_NAME_DECLENSION_DOESNT_MATCH_BASE_NAME = 103


class AllowedClass(enum.Flag):
    ALL = 0
    WARRIOR = 1
    PALADIN = 2
    HUNTER = 4
    ROGUE = 8
    PRIEST = 16
    DEATH_KNIGHT = 32
    SHAMAN = 64
    MAGE = 128
    WARLOCK = 256
    DRUID = 1024


class AllowedRace(enum.Flag):
    ALL = 0
    HUMAN = 1
    ORC = 2
    DWARF = 4
    NIGHT_ELF = 8
    UNDEAD = 16
    TAUREN = 32
    GNOME = 64
    TROLL = 128
    GOBLIN = 256
    BLOODELF = 512
    DRAENEI = 1024
    FEL_ORC = 2048
    NAGA = 4096
    BROKEN = 8192
    SKELETON = 16384
    VRYKUL = 32768
    TUSKARR = 65536
    FOREST_TROLL = 131072
    TAUNKA = 262144
    NORTHREND_SKELETON = 524288
    ICE_TROLL = 1048576


class AuraFlag(enum.Flag):
    EMPTY = 0
    EFFECT_1 = 1
    EFFECT_2 = 2
    EFFECT_3 = 4
    NOT_CASTER = 8
    SET = 9
    CANCELLABLE = 16
    DURATION = 32
    HIDE = 64
    NEGATIVE = 128


class BagFamily(enum.Flag):
    NONE = 0
    ARROWS = 1
    BULLETS = 2
    SOUL_SHARDS = 4
    LEATHERWORKING_SUPPLIES = 8
    INSCRIPTION_SUPPLIES = 16
    HERBS = 32
    ENCHANTING_SUPPLIES = 64
    ENGINEERING_SUPPLIES = 128
    KEYS = 256
    GEMS = 512
    MINING_SUPPLIES = 1024
    SOULBOUND_EQUIPMENT = 2048
    VANITY_PETS = 4096
    CURRENCY_TOKENS = 8192
    QUEST_ITEMS = 16384


class BillingPlanFlags(enum.Flag):
    NONE = 0
    UNUSED = 1
    RECURRING_BILL = 2
    FREE_TRIAL = 4
    IGR = 8
    USAGE = 16
    TIME_MIXTURE = 32
    RESTRICTED = 64
    ENABLE_CAIS = 128


class CastFlags(enum.Flag):
    NONE = 0
    PENDING = 1
    HAS_TRAJECTORY = 2
    UNKNOWN_3 = 4
    UNKNOWN_4 = 8
    UNKNOWN_5 = 16
    AMMO = 32
    UNKNOWN_7 = 64
    UNKNOWN_8 = 128
    UNKNOWN_9 = 256
    UNKNOWN_10 = 512
    UNKNOWN_11 = 1024
    POWER_LEFT_SELF = 2048
    UNKNOWN_13 = 4096
    UNKNOWN_14 = 8192
    UNKNOWN_15 = 16384
    UNKNOWN_16 = 32768
    UNKNOWN_17 = 65536
    ADJUST_MISSILE = 131072
    NO_GCD = 262144
    VISUAL_CHAIN = 524288
    UNKNOWN_21 = 1048576
    RUNE_LIST = 2097152
    UNKNOWN_23 = 4194304
    UNKNOWN_24 = 8388608
    UNKNOWN_25 = 16777216
    UNKNOWN_26 = 33554432
    IMMUNITY = 67108864
    UNKNOWN_28 = 134217728
    UNKNOWN_29 = 268435456
    UNKNOWN_30 = 536870912
    HEAL_PREDICTION = 1073741824
    UNKNOWN_32 = 2147483648


class ChannelFlags(enum.Flag):
    NONE = 0
    CUSTOM = 1
    TRADE = 4
    NOT_LFG = 8
    GENERAL = 16
    CITY = 32
    LFG = 64
    VOICE = 128


class ChannelMemberFlags(enum.Flag):
    NONE = 0
    OWNER = 1
    MODERATOR = 4
    VOICED = 8
    MUTED = 16
    CUSTOM = 32
    MICROPHONE_MUTE = 64


class FactionFlag(enum.Flag):
    VISIBLE = 1
    AT_WAR = 2
    HIDDEN = 4
    INVISIBLE_FORCED = 8
    PEACE_FORCED = 16
    INACTIVE = 32
    RIVAL = 64
    SPECIAL = 128


class GameobjectCastFlags(enum.Flag):
    LOCK_PLAYER_CAST_ANIM = 1
    UNKNOWN2 = 2
    UNKNOWN4 = 4
    UNKNOWN8 = 8
    UNKNOWN16 = 16
    AMMO = 32
    DEST_LOCATION = 64
    ITEM_CASTER = 256
    UNK200 = 512
    EXTRA_MESSAGE = 1024
    POWER_UPDATE = 2048
    UNK2000 = 8192
    UNK1000 = 4096
    UNK8000 = 32768
    ADJUST_MISSILE = 131072
    UNK40000 = 262144
    VISUAL_CHAIN = 524288
    RUNE_UPDATE = 2097152
    UNK400000 = 4194304


class GroupMemberOnlineStatus(enum.Flag):
    OFFLINE = 0
    ONLINE = 1
    PVP = 2
    DEAD = 4
    GHOST = 8
    PVP_FFA = 16
    ZONE_OUT = 32
    AFK = 64
    DND = 128


class GroupUpdateFlags(enum.Flag):
    NONE = 0
    STATUS = 1
    CUR_HP = 2
    MAX_HP = 4
    POWER_TYPE = 8
    CUR_POWER = 16
    MAX_POWER = 32
    LEVEL = 64
    ZONE = 128
    POSITION = 256
    AURAS = 512
    PET_GUID = 1024
    PET_NAME = 2048
    PET_MODEL_ID = 4096
    PET_CUR_HP = 8192
    PET_MAX_HP = 16384
    PET_POWER_TYPE = 32768
    PET_CUR_POWER = 65536
    PET_MAX_POWER = 131072
    PET_AURAS = 262144
    VEHICLE_SEAT = 524288


class HitInfo(enum.Flag):
    NORMALSWING = 0
    UNK1 = 1
    AFFECTS_VICTIM = 2
    OFFHAND = 4
    UNK2 = 8
    MISS = 16
    FULL_ABSORB = 32
    PARTIAL_ABSORB = 64
    ALL_ABSORB = 96
    FULL_RESIST = 128
    PARTIAL_RESIST = 256
    ALL_RESIST = 384
    CRITICALHIT = 512
    UNK10 = 1024
    UNK11 = 2048
    UNK12 = 4096
    BLOCK = 8192
    UNK14 = 16384
    UNK15 = 32768
    GLANCING = 65536
    CRUSHING = 131072
    NO_ANIMATION = 262144
    UNK19 = 524288
    UNK20 = 1048576
    SWINGNOHITSOUND = 2097152
    UNK22 = 4194304
    RAGE_GAIN = 8388608
    FAKE_DAMAGE = 16777216


class ItemFlag(enum.Flag):
    NO_PICKUP = 1
    CONJURED = 2
    LOOTABLE = 4
    HEROIC_TOOLTIP = 8
    DEPRECATED = 16
    INDESTRUCTIBLE = 32
    PLAYER_CAST = 64
    NO_EQUIP_COOLDOWN = 128
    MULTI_LOOT_QUEST = 256
    WRAPPER = 512
    USES_RESOURCES = 1024
    MULTI_DROP = 2048
    ITEM_PURCHASE_RECORD = 4096
    CHARTER = 8192
    HAS_TEXT = 16384
    NO_DISENCHANT = 32768
    REAL_DURATION = 65536
    NO_CREATOR = 131072
    IS_PROSPECTABLE = 262144
    UNIQUE_EQUIPPED = 524288
    IGNORE_FOR_AURAS = 1048576
    IGNORE_DEFAULT_ARENA_RESTRICTIONS = 2097152
    NO_DURABILITY_LOSS = 4194304
    USE_WHEN_SHAPESHIFTED = 8388608
    HAS_QUEST_GLOW = 16777216
    HIDE_UNUSABLE_RECIPE = 33554432
    NOT_USEABLE_IN_ARENA = 67108864
    IS_BOUND_TO_ACCOUNT = 134217728
    NO_REAGENT_COST = 268435456
    IS_MILLABLE = 536870912
    REPORT_TO_GUILD_CHAT = 1073741824
    NO_PROGRESSIVE_LOOT = 2147483648


class ItemFlag2(enum.Flag):
    FACTION_HORDE = 1
    FACTION_ALLIANCE = 2
    DONT_IGNORE_BUY_PRICE = 4
    CLASSIFY_AS_CASTER = 8
    CLASSIFY_AS_PHYSICAL = 16
    EVERYONE_CAN_ROLL_NEED = 32
    NO_TRADE_BIND_ON_ACQUIRE = 64
    CAN_TRADE_BIND_ON_ACQUIRE = 128
    CAN_ONLY_ROLL_GREED = 256
    CASTER_WEAPON = 512
    DELETE_ON_LOGIN = 1024
    INTERNAL_ITEM = 2048
    NO_VENDOR_VALUE = 4096
    SHOW_BEFORE_DISCOVERED = 8192
    OVERRIDE_GOLD_COST = 16384
    IGNORE_DEFAULT_RATED_BG_RESTRICTIONS = 32768
    NOT_USABLE_IN_RATED_BG = 65536
    BNET_ACCOUNT_TRADE_OK = 131072
    CONFIRM_BEFORE_USE = 262144
    REEVALUATE_BONDING_ON_TRANSFORM = 524288
    NO_TRANSFORM_ON_CHARGE_DEPLETION = 1048576
    NO_ALTER_ITEM_VISUAL = 2097152
    NO_SOURCE_FOR_ITEM_VISUAL = 4194304
    IGNORE_QUALITY_FOR_ITEM_VISUAL_SOURCE = 8388608
    NO_DURABILITY = 16777216
    ROLE_TANK = 33554432
    ROLE_HEALER = 67108864
    ROLE_DAMAGE = 134217728
    CAN_DROP_IN_CHALLENGE_MODE = 268435456
    NEVER_STACK_IN_LOOT_UI = 536870912
    DISENCHANT_TO_LOOT_TABLE = 1073741824
    USED_IN_A_TRADESKILL = 2147483648


class LfgUpdateFlag(enum.Flag):
    NONE = 0
    CHARACTER_INFO = 1
    COMMENT = 2
    GROUP_LEADER = 4
    GROUP_GUID = 8
    ROLES = 16
    AREA = 32
    STATUS = 64
    BOUND = 128


class MovementFlags(enum.Flag):
    NONE = 0
    FORWARD = 1
    BACKWARD = 2
    STRAFE_LEFT = 4
    STRAFE_RIGHT = 8
    LEFT = 16
    RIGHT = 32
    PITCH_UP = 64
    PITCH_DOWN = 128
    WALKING = 256
    ON_TRANSPORT = 512
    DISABLE_GRAVITY = 1024
    ROOT = 2048
    FALLING = 4096
    FALLING_FAR = 8192
    PENDING_STOP = 16384
    PENDING_STRAFE_STOP = 32768
    PENDING_FORWARD = 65536
    PENDING_BACKWARD = 131072
    PENDING_STRAFE_LEFT = 262144
    PENDING_STRAFE_RIGHT = 524288
    PENDING_ROOT = 1048576
    SWIMMING = 2097152
    ASCENDING = 4194304
    DESCENDING = 8388608
    CAN_FLY = 16777216
    FLYING = 33554432
    SPLINE_ELEVATION = 67108864
    SPLINE_ENABLED = 134217728
    WATERWALKING = 268435456
    FALLING_SLOW = 536870912
    HOVER = 1073741824
    NO_STRAFE = 4294967296
    NO_JUMPING = 8589934592
    UNK3 = 17179869184
    FULL_SPEED_TURNING = 34359738368
    FULL_SPEED_PITCHING = 68719476736
    ALWAYS_ALLOW_PITCHING = 137438953472
    UNK7 = 274877906944
    UNK8 = 549755813888
    UNK9 = 1099511627776
    UNK10 = 2199023255552
    INTERPOLATED_MOVEMENT = 4398046511104
    INTERPOLATED_TURNING = 8796093022208
    INTERPOLATED_PITCHING = 17592186044416
    UNK14 = 35184372088832
    UNK15 = 70368744177664
    UNK16 = 140737488355328
    ON_TRANSPORT_AND_INTERPOLATED_MOVEMENT = 4398046511616


class RelationType(enum.Flag):
    NONE = 0
    FRIEND = 1
    IGNORED = 2
    MUTED = 4
    RECRUITAFRIEND = 8


class RollFlags(enum.Flag):
    PASS = 1
    NEED = 2
    GREED = 4
    DISENCHANT = 8


class SpellCastTargetFlags(enum.Flag):
    SELF = 0
    UNUSED1 = 1
    UNIT = 2
    UNIT_RAID = 4
    UNIT_PARTY = 8
    ITEM = 16
    SOURCE_LOCATION = 32
    DEST_LOCATION = 64
    UNIT_ENEMY = 128
    UNIT_ALLY = 256
    CORPSE_ENEMY = 512
    UNIT_DEAD = 1024
    GAMEOBJECT = 2048
    TRADE_ITEM = 4096
    STRING = 8192
    LOCKED = 16384
    CORPSE_ALLY = 32768
    UNIT_MINIPET = 65536
    GLYPH_SLOT = 131072
    DEST_TARGET = 262144
    UNUSED20 = 524288
    UNIT_PASSENGER = 1048576


class SplineFlag(enum.Flag):
    NONE = 0
    DONE = 1
    FALLING = 2
    UNKNOWN3 = 4
    UNKNOWN4 = 8
    UNKNOWN5 = 16
    UNKNOWN6 = 32
    UNKNOWN7 = 64
    UNKNOWN8 = 128
    RUNMODE = 256
    FLYING = 512
    NO_SPLINE = 1024
    PARABOLIC = 2048
    UNKNOWN13 = 4096
    UNKNOWN14 = 8192
    UNKNOWN15 = 16384
    UNKNOWN16 = 32768
    FINAL_POINT = 65536
    FINAL_TARGET = 131072
    FINAL_ANGLE = 262144
    UNKNOWN19 = 524288
    CYCLIC = 1048576
    ENTER_CYCLE = 2097152
    FROZEN = 4194304
    UNKNOWN23 = 8388608
    UNKNOWN24 = 16777216
    UNKNOWN25 = 33554432
    UNKNOWN26 = 67108864
    UNKNOWN27 = 134217728
    UNKNOWN28 = 268435456
    UNKNOWN29 = 536870912
    UNKNOWN30 = 1073741824
    UNKNOWN31 = 2147483648


class UpdateFlag(enum.Flag):
    NONE = 0
    SELF = 1
    TRANSPORT = 2
    HAS_ATTACKING_TARGET = 4
    LOW_GUID = 8
    HIGH_GUID = 16
    LIVING = 32
    HAS_POSITION = 64
    VEHICLE = 128
    POSITION = 256
    ROTATION = 512


class VictimState(enum.Flag):
    INTACT = 0
    HIT = 1
    DODGE = 2
    PARRY = 3
    INTERRUPT = 4
    BLOCKS = 5
    EVADES = 6
    IS_IMMUNE = 7
    DEFLECTS = 8


@dataclasses.dataclass
class AchievementDone:
    achievement: int
    time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> AchievementDone:
        # achievement: u32
        achievement = await read_int(reader, 4)

        # time: DateTime
        time = await read_int(reader, 4)

        return AchievementDone(
            achievement=achievement,
            time=time,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.achievement, self.time])
        return _fmt, _data


@dataclasses.dataclass
class AchievementInProgress:
    achievement: int
    counter: int
    player: int
    timed_criteria_failed: bool
    progress_date: int
    time_since_progress: int
    time_since_progress2: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> AchievementInProgress:
        # achievement: u32
        achievement = await read_int(reader, 4)

        # counter: PackedGuid
        counter = await read_packed_guid(reader)

        # player: PackedGuid
        player = await read_packed_guid(reader)

        # timed_criteria_failed: Bool32
        timed_criteria_failed = await read_bool(reader, 4)

        # progress_date: DateTime
        progress_date = await read_int(reader, 4)

        # time_since_progress: u32
        time_since_progress = await read_int(reader, 4)

        # time_since_progress2: u32
        time_since_progress2 = await read_int(reader, 4)

        return AchievementInProgress(
            achievement=achievement,
            counter=counter,
            player=player,
            timed_criteria_failed=timed_criteria_failed,
            progress_date=progress_date,
            time_since_progress=time_since_progress,
            time_since_progress2=time_since_progress2,
        )

    def write(self, _fmt, _data):
        _fmt += 'I'
        _data.append(self.achievement)
        # counter: PackedGuid
        _fmt, _data = packed_guid_write(self.counter, _fmt, _data)

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # timed_criteria_failed: Bool32
        _fmt += 'I'
        _data.append(self.timed_criteria_failed)

        # progress_date: DateTime
        _fmt += 'I'
        _data.append(self.progress_date)

        # time_since_progress: u32
        _fmt += 'I'
        _data.append(self.time_since_progress)

        # time_since_progress2: u32
        _fmt += 'I'
        _data.append(self.time_since_progress2)

        return _fmt, _data

    def size(self) -> int:
        return 20 + packed_guid_size(self.counter) + packed_guid_size(self.player)


@dataclasses.dataclass
class ActionButton:
    action: int
    action_type: int
    misc: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ActionButton:
        # action: u16
        action = await read_int(reader, 2)

        # action_type: u8
        action_type = await read_int(reader, 1)

        # misc: u8
        misc = await read_int(reader, 1)

        return ActionButton(
            action=action,
            action_type=action_type,
            misc=misc,
        )

    def write(self, _fmt, _data):
        _fmt += 'HBB'
        _data.extend([self.action, self.action_type, self.misc])
        return _fmt, _data


@dataclasses.dataclass
class Addon:
    addon_type: int
    uses_crc: int
    uses_diffent_public_key: bool
    unknown1: int
    unknown2: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Addon:
        # addon_type: u8
        addon_type = await read_int(reader, 1)

        # uses_crc: u8
        uses_crc = await read_int(reader, 1)

        # uses_diffent_public_key: Bool8
        uses_diffent_public_key = await read_bool(reader, 1)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # unknown2: u8
        unknown2 = await read_int(reader, 1)

        return Addon(
            addon_type=addon_type,
            uses_crc=uses_crc,
            uses_diffent_public_key=uses_diffent_public_key,
            unknown1=unknown1,
            unknown2=unknown2,
        )

    def write(self, _fmt, _data):
        _fmt += 'BBBIB'
        _data.extend([self.addon_type, self.uses_crc, self.uses_diffent_public_key, self.unknown1, self.unknown2])
        return _fmt, _data


@dataclasses.dataclass
class AddonInfo:
    addon_name: str
    addon_has_signature: int
    addon_crc: int
    addon_extra_crc: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> AddonInfo:
        # addon_name: CString
        addon_name = await read_cstring(reader)

        # addon_has_signature: u8
        addon_has_signature = await read_int(reader, 1)

        # addon_crc: u32
        addon_crc = await read_int(reader, 4)

        # addon_extra_crc: u32
        addon_extra_crc = await read_int(reader, 4)

        return AddonInfo(
            addon_name=addon_name,
            addon_has_signature=addon_has_signature,
            addon_crc=addon_crc,
            addon_extra_crc=addon_extra_crc,
        )

    def write(self, _fmt, _data):
        _fmt += f'{len(self.addon_name)}sBBII'
        _data.extend([self.addon_name.encode('utf-8'), 0, self.addon_has_signature, self.addon_crc, self.addon_extra_crc])
        return _fmt, _data

    def size(self) -> int:
        return 10 + len(self.addon_name)


@dataclasses.dataclass
class ArenaTeamMember:
    guid: int
    online: bool
    name: str
    level: int
    class_type: Class
    games_played_this_week: int
    wins_this_week: int
    games_played_this_season: int
    wins_this_season: int
    personal_rating: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ArenaTeamMember:
        # guid: Guid
        guid = await read_int(reader, 8)

        # online: Bool8
        online = await read_bool(reader, 1)

        # name: CString
        name = await read_cstring(reader)

        # level: Level
        level = await read_int(reader, 1)

        # class_type: Class
        class_type = Class(await read_int(reader, 1))

        # games_played_this_week: u32
        games_played_this_week = await read_int(reader, 4)

        # wins_this_week: u32
        wins_this_week = await read_int(reader, 4)

        # games_played_this_season: u32
        games_played_this_season = await read_int(reader, 4)

        # wins_this_season: u32
        wins_this_season = await read_int(reader, 4)

        # personal_rating: u32
        personal_rating = await read_int(reader, 4)

        return ArenaTeamMember(
            guid=guid,
            online=online,
            name=name,
            level=level,
            class_type=class_type,
            games_played_this_week=games_played_this_week,
            wins_this_week=wins_this_week,
            games_played_this_season=games_played_this_season,
            wins_this_season=wins_this_season,
            personal_rating=personal_rating,
        )

    def write(self, _fmt, _data):
        _fmt += f'QB{len(self.name)}sBBBIIIII'
        _data.extend([self.guid, self.online, self.name.encode('utf-8'), 0, self.level, self.class_type.value, self.games_played_this_week, self.wins_this_week, self.games_played_this_season, self.wins_this_season, self.personal_rating])
        return _fmt, _data

    def size(self) -> int:
        return 32 + len(self.name)


@dataclasses.dataclass
class AuctionEnchantment:
    enchant_id: int
    enchant_duration: int
    enchant_charges: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> AuctionEnchantment:
        # enchant_id: u32
        enchant_id = await read_int(reader, 4)

        # enchant_duration: u32
        enchant_duration = await read_int(reader, 4)

        # enchant_charges: u32
        enchant_charges = await read_int(reader, 4)

        return AuctionEnchantment(
            enchant_id=enchant_id,
            enchant_duration=enchant_duration,
            enchant_charges=enchant_charges,
        )

    def write(self, _fmt, _data):
        _fmt += 'III'
        _data.extend([self.enchant_id, self.enchant_duration, self.enchant_charges])
        return _fmt, _data


@dataclasses.dataclass
class AuctionListItem:
    id: int
    item: int
    enchantments: typing.List[AuctionEnchantment]
    item_random_property_id: int
    item_suffix_factor: int
    item_count: int
    item_charges: int
    item_flags: int
    item_owner: int
    start_bid: int
    minimum_bid: int
    buyout_amount: int
    time_left: int
    highest_bidder: int
    highest_bid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> AuctionListItem:
        # id: u32
        id = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        # enchantments: AuctionEnchantment[7]
        enchantments = []
        for _ in range(0, 7):
            enchantments.append(await AuctionEnchantment.read(reader))

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # item_suffix_factor: u32
        item_suffix_factor = await read_int(reader, 4)

        # item_count: u32
        item_count = await read_int(reader, 4)

        # item_charges: u32
        item_charges = await read_int(reader, 4)

        # item_flags: u32
        item_flags = await read_int(reader, 4)

        # item_owner: Guid
        item_owner = await read_int(reader, 8)

        # start_bid: u32
        start_bid = await read_int(reader, 4)

        # minimum_bid: u32
        minimum_bid = await read_int(reader, 4)

        # buyout_amount: u32
        buyout_amount = await read_int(reader, 4)

        # time_left: Milliseconds
        time_left = await read_int(reader, 4)

        # highest_bidder: Guid
        highest_bidder = await read_int(reader, 8)

        # highest_bid: u32
        highest_bid = await read_int(reader, 4)

        return AuctionListItem(
            id=id,
            item=item,
            enchantments=enchantments,
            item_random_property_id=item_random_property_id,
            item_suffix_factor=item_suffix_factor,
            item_count=item_count,
            item_charges=item_charges,
            item_flags=item_flags,
            item_owner=item_owner,
            start_bid=start_bid,
            minimum_bid=minimum_bid,
            buyout_amount=buyout_amount,
            time_left=time_left,
            highest_bidder=highest_bidder,
            highest_bid=highest_bid,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.id, self.item])
        # enchantments: AuctionEnchantment[7]
        for i in self.enchantments:
            _fmt, _data = i.write(_fmt, _data)

        # item_random_property_id: u32
        _fmt += 'I'
        _data.append(self.item_random_property_id)

        # item_suffix_factor: u32
        _fmt += 'I'
        _data.append(self.item_suffix_factor)

        # item_count: u32
        _fmt += 'I'
        _data.append(self.item_count)

        # item_charges: u32
        _fmt += 'I'
        _data.append(self.item_charges)

        # item_flags: u32
        _fmt += 'I'
        _data.append(self.item_flags)

        # item_owner: Guid
        _fmt += 'Q'
        _data.append(self.item_owner)

        # start_bid: u32
        _fmt += 'I'
        _data.append(self.start_bid)

        # minimum_bid: u32
        _fmt += 'I'
        _data.append(self.minimum_bid)

        # buyout_amount: u32
        _fmt += 'I'
        _data.append(self.buyout_amount)

        # time_left: Milliseconds
        _fmt += 'I'
        _data.append(self.time_left)

        # highest_bidder: Guid
        _fmt += 'Q'
        _data.append(self.highest_bidder)

        # highest_bid: u32
        _fmt += 'I'
        _data.append(self.highest_bid)

        return _fmt, _data


@dataclasses.dataclass
class AuctionSort:
    column: int
    reversed: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> AuctionSort:
        # column: u8
        column = await read_int(reader, 1)

        # reversed: u8
        reversed = await read_int(reader, 1)

        return AuctionSort(
            column=column,
            reversed=reversed,
        )

    def write(self, _fmt, _data):
        _fmt += 'BB'
        _data.extend([self.column, self.reversed])
        return _fmt, _data


@dataclasses.dataclass
class Aura:
    aura: int
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Aura:
        # aura: u32
        aura = await read_int(reader, 4)

        # unknown: u8
        unknown = await read_int(reader, 1)

        return Aura(
            aura=aura,
            unknown=unknown,
        )

    def write(self, _fmt, _data):
        _fmt += 'IB'
        _data.extend([self.aura, self.unknown])
        return _fmt, _data


@dataclasses.dataclass
class AuraMask:
    fields: dict[int, Aura]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        mask = await read_int(reader, 8)

        fields = {}
        for index in range(0, 64):
            if mask & 1 << index:
                aura = Aura.read(reader)
                fields[index] = aura

        return AuraMask(fields=fields)

    def write(self, fmt, data):
        mask = 0
        for i, _ in enumerate(self.fields):
            mask |= 1 << i

        fmt += 'Q'
        data.append(mask)

        for aura in self.fields:
            fmt, data = aura.write(fmt, data)

        return fmt, data

    def size(self):
        return 4 + len(self.fields) * 5



@dataclasses.dataclass
class AuraLog:
    aura_type: AuraType
    damage1: typing.Optional[int] = None
    overkill_damage: typing.Optional[int] = None
    school: typing.Optional[SpellSchool] = None
    absorb1: typing.Optional[int] = None
    resisted: typing.Optional[int] = None
    critical1: typing.Optional[bool] = None
    damage2: typing.Optional[int] = None
    over_damage: typing.Optional[int] = None
    absorb2: typing.Optional[int] = None
    critical2: typing.Optional[bool] = None
    misc_value1: typing.Optional[int] = None
    damage3: typing.Optional[int] = None
    misc_value2: typing.Optional[int] = None
    damage4: typing.Optional[int] = None
    gain_multiplier: typing.Optional[float] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> AuraLog:
        damage1 = None
        overkill_damage = None
        school = None
        absorb1 = None
        resisted = None
        critical1 = None
        damage2 = None
        over_damage = None
        absorb2 = None
        critical2 = None
        misc_value1 = None
        damage3 = None
        misc_value2 = None
        damage4 = None
        gain_multiplier = None
        # aura_type: AuraType
        aura_type = AuraType(await read_int(reader, 4))

        if aura_type in {AuraType.PERIODIC_DAMAGE, AuraType.PERIODIC_DAMAGE_PERCENT}:
            # damage1: u32
            damage1 = await read_int(reader, 4)

            # overkill_damage: u32
            overkill_damage = await read_int(reader, 4)

            # school: SpellSchool
            school = SpellSchool(await read_int(reader, 1))

            # absorb1: u32
            absorb1 = await read_int(reader, 4)

            # resisted: u32
            resisted = await read_int(reader, 4)

            # critical1: Bool8
            critical1 = await read_bool(reader, 1)

        elif aura_type in {AuraType.PERIODIC_HEAL, AuraType.OBS_MOD_HEALTH}:
            # damage2: u32
            damage2 = await read_int(reader, 4)

            # over_damage: u32
            over_damage = await read_int(reader, 4)

            # absorb2: u32
            absorb2 = await read_int(reader, 4)

            # critical2: Bool8
            critical2 = await read_bool(reader, 1)

        elif aura_type in {AuraType.OBS_MOD_POWER, AuraType.PERIODIC_ENERGIZE}:
            # misc_value1: u32
            misc_value1 = await read_int(reader, 4)

            # damage3: u32
            damage3 = await read_int(reader, 4)

        elif aura_type == AuraType.PERIODIC_MANA_LEECH:
            # misc_value2: u32
            misc_value2 = await read_int(reader, 4)

            # damage4: u32
            damage4 = await read_int(reader, 4)

            # gain_multiplier: f32
            gain_multiplier = await read_float(reader)

        return AuraLog(
            aura_type=aura_type,
            damage1=damage1,
            overkill_damage=overkill_damage,
            school=school,
            absorb1=absorb1,
            resisted=resisted,
            critical1=critical1,
            damage2=damage2,
            over_damage=over_damage,
            absorb2=absorb2,
            critical2=critical2,
            misc_value1=misc_value1,
            damage3=damage3,
            misc_value2=misc_value2,
            damage4=damage4,
            gain_multiplier=gain_multiplier,
        )

    def write(self, _fmt, _data):
        _fmt += 'I'
        _data.append(self.aura_type.value)
        if self.aura_type in {AuraType.PERIODIC_DAMAGE, AuraType.PERIODIC_DAMAGE_PERCENT}:
            _fmt += 'IIBIIB'
            _data.extend([self.damage1, self.overkill_damage, self.school.value, self.absorb1, self.resisted, self.critical1])
        elif self.aura_type in {AuraType.PERIODIC_HEAL, AuraType.OBS_MOD_HEALTH}:
            _fmt += 'IIIB'
            _data.extend([self.damage2, self.over_damage, self.absorb2, self.critical2])
        elif self.aura_type in {AuraType.OBS_MOD_POWER, AuraType.PERIODIC_ENERGIZE}:
            _fmt += 'II'
            _data.extend([self.misc_value1, self.damage3])
        elif self.aura_type == AuraType.PERIODIC_MANA_LEECH:
            _fmt += 'IIf'
            _data.extend([self.misc_value2, self.damage4, self.gain_multiplier])
        return _fmt, _data

    def size(self) -> int:
        _size = 4

        if self.aura_type in {AuraType.PERIODIC_DAMAGE, AuraType.PERIODIC_DAMAGE_PERCENT}:
            _size += 18
        elif self.aura_type in {AuraType.PERIODIC_HEAL, AuraType.OBS_MOD_HEALTH}:
            _size += 13
        elif self.aura_type in {AuraType.OBS_MOD_POWER, AuraType.PERIODIC_ENERGIZE}:
            _size += 8
        elif self.aura_type == AuraType.PERIODIC_MANA_LEECH:
            _size += 12

        return _size


@dataclasses.dataclass
class AuraUpdate:
    visual_slot: int
    spell: int
    flags: AuraFlag
    level: int
    aura_stack_count: int
    caster: typing.Optional[int] = None
    duration: typing.Optional[int] = None
    time_left: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> AuraUpdate:
        caster = None
        duration = None
        time_left = None
        # visual_slot: u8
        visual_slot = await read_int(reader, 1)

        # spell: Spell
        spell = await read_int(reader, 4)

        # flags: AuraFlag
        flags = AuraFlag(await read_int(reader, 1))

        # level: Level
        level = await read_int(reader, 1)

        # aura_stack_count: u8
        aura_stack_count = await read_int(reader, 1)

        if AuraFlag.NOT_CASTER in flags:
            # caster: PackedGuid
            caster = await read_packed_guid(reader)

        if AuraFlag.DURATION in flags:
            # duration: u32
            duration = await read_int(reader, 4)

            # time_left: u32
            time_left = await read_int(reader, 4)

        return AuraUpdate(
            visual_slot=visual_slot,
            spell=spell,
            flags=flags,
            level=level,
            aura_stack_count=aura_stack_count,
            caster=caster,
            duration=duration,
            time_left=time_left,
        )

    def write(self, _fmt, _data):
        _fmt += 'BIBBB'
        _data.extend([self.visual_slot, self.spell, self.flags.value, self.level, self.aura_stack_count])
        if AuraFlag.NOT_CASTER in self.flags:
            # caster: PackedGuid
            _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        if AuraFlag.DURATION in self.flags:
            _fmt += 'II'
            _data.extend([self.duration, self.time_left])
        return _fmt, _data

    def size(self) -> int:
        _size = 8

        if AuraFlag.NOT_CASTER in self.flags:
            _size += 0 + packed_guid_size(self.caster)

        if AuraFlag.DURATION in self.flags:
            _size += 8

        return _size


@dataclasses.dataclass
class BankTab:
    flags: int
    stacks_per_day: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> BankTab:
        # flags: u32
        flags = await read_int(reader, 4)

        # stacks_per_day: u32
        stacks_per_day = await read_int(reader, 4)

        return BankTab(
            flags=flags,
            stacks_per_day=stacks_per_day,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.flags, self.stacks_per_day])
        return _fmt, _data


@dataclasses.dataclass
class BattlegroundPlayerPosition:
    player: int
    position_x: float
    position_y: float

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> BattlegroundPlayerPosition:
        # player: Guid
        player = await read_int(reader, 8)

        # position_x: f32
        position_x = await read_float(reader)

        # position_y: f32
        position_y = await read_float(reader)

        return BattlegroundPlayerPosition(
            player=player,
            position_x=position_x,
            position_y=position_y,
        )

    def write(self, _fmt, _data):
        _fmt += 'Qff'
        _data.extend([self.player, self.position_x, self.position_y])
        return _fmt, _data


@dataclasses.dataclass
class CalendarInvitee:
    guid: int
    status: int
    rank: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> CalendarInvitee:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # status: u8
        status = await read_int(reader, 1)

        # rank: u8
        rank = await read_int(reader, 1)

        return CalendarInvitee(
            guid=guid,
            status=status,
            rank=rank,
        )

    def write(self, _fmt, _data):
        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # status: u8
        _fmt += 'B'
        _data.append(self.status)

        # rank: u8
        _fmt += 'B'
        _data.append(self.rank)

        return _fmt, _data

    def size(self) -> int:
        return 2 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CalendarMember:
    member: int
    level: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> CalendarMember:
        # member: PackedGuid
        member = await read_packed_guid(reader)

        # level: Level
        level = await read_int(reader, 1)

        return CalendarMember(
            member=member,
            level=level,
        )

    def write(self, _fmt, _data):
        # member: PackedGuid
        _fmt, _data = packed_guid_write(self.member, _fmt, _data)

        # level: Level
        _fmt += 'B'
        _data.append(self.level)

        return _fmt, _data

    def size(self) -> int:
        return 1 + packed_guid_size(self.member)


@dataclasses.dataclass
class CalendarSendInvitee:
    invitee: int
    level: int
    status: int
    rank: int
    guild_member: int
    invite_id: int
    status_time: int
    text: str

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> CalendarSendInvitee:
        # invitee: PackedGuid
        invitee = await read_packed_guid(reader)

        # level: Level
        level = await read_int(reader, 1)

        # status: u8
        status = await read_int(reader, 1)

        # rank: u8
        rank = await read_int(reader, 1)

        # guild_member: u8
        guild_member = await read_int(reader, 1)

        # invite_id: Guid
        invite_id = await read_int(reader, 8)

        # status_time: DateTime
        status_time = await read_int(reader, 4)

        # text: CString
        text = await read_cstring(reader)

        return CalendarSendInvitee(
            invitee=invitee,
            level=level,
            status=status,
            rank=rank,
            guild_member=guild_member,
            invite_id=invite_id,
            status_time=status_time,
            text=text,
        )

    def write(self, _fmt, _data):
        # invitee: PackedGuid
        _fmt, _data = packed_guid_write(self.invitee, _fmt, _data)

        # level: Level
        _fmt += 'B'
        _data.append(self.level)

        # status: u8
        _fmt += 'B'
        _data.append(self.status)

        # rank: u8
        _fmt += 'B'
        _data.append(self.rank)

        # guild_member: u8
        _fmt += 'B'
        _data.append(self.guild_member)

        # invite_id: Guid
        _fmt += 'Q'
        _data.append(self.invite_id)

        # status_time: DateTime
        _fmt += 'I'
        _data.append(self.status_time)

        # text: CString
        _fmt += f'{len(self.text)}sB'
        _data.extend([self.text.encode('utf-8'), 0])

        return _fmt, _data

    def size(self) -> int:
        return 17 + packed_guid_size(self.invitee) + len(self.text)


@dataclasses.dataclass
class ChannelMember:
    guid: int
    member_flags: ChannelMemberFlags

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ChannelMember:
        # guid: Guid
        guid = await read_int(reader, 8)

        # member_flags: ChannelMemberFlags
        member_flags = ChannelMemberFlags(await read_int(reader, 1))

        return ChannelMember(
            guid=guid,
            member_flags=member_flags,
        )

    def write(self, _fmt, _data):
        _fmt += 'QB'
        _data.extend([self.guid, self.member_flags.value])
        return _fmt, _data


@dataclasses.dataclass
class Vector3d:
    x: float
    y: float
    z: float

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Vector3d:
        # x: f32
        x = await read_float(reader)

        # y: f32
        y = await read_float(reader)

        # z: f32
        z = await read_float(reader)

        return Vector3d(
            x=x,
            y=y,
            z=z,
        )

    def write(self, _fmt, _data):
        _fmt += 'fff'
        _data.extend([self.x, self.y, self.z])
        return _fmt, _data


@dataclasses.dataclass
class MonsterMoveSpline:
    splines: list[Vector3d]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        def packed_to_vec(packed: int) -> Vector3d:
            x = float(packed & 0x7FF) / 4
            y = float((packed >> 11) & 0x7FF) / 4
            z = float((packed >> 22) & 0x3FF) / 4
            return Vector3d(x=x, y=y, z=z)

        amount_of_splines = await read_int(reader, 4)

        if amount_of_splines == 0:
            return MonsterMoveSpline(splines=[])

        splines = [await Vector3d.read(reader)]

        for i in range(1, amount_of_splines): # subtract the 'real' one
            packed = await read_int(reader, 4)
            splines.append(packed_to_vec(packed))

        return MonsterMoveSpline(splines=splines)

    def write(self, fmt, data):
        def vec_to_packed(vec: Vector3d) -> int:
            packed = 0
            packed |= int(vec.x / 0.25) & 0x7FF
            packed |= (int(vec.y / 0.25) & 0x7FF) << 11
            packed |= (int(vec.z / 0.25) & 0x3FF) << 22
            return packed
        amount_of_splines = len(self.splines)
        fmt += 'I'
        data.append(amount_of_splines)

        if amount_of_splines == 0:
            return fmt, data

        fmt, data = self.splines[0].write(fmt, data)

        for i in range(1, amount_of_splines):
            packed = vec_to_packed(self.splines[i])
            fmt += 'I'
            data.append(packed)

        return fmt, data

    def size(self):
        if len(self.splines) == 0:
            return 4

        return 4 + 3 * 4 + (len(self.splines) - 1) * 4


@dataclasses.dataclass
class CharacterGear:
    equipment_display_id: int
    inventory_type: InventoryType
    enchantment: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> CharacterGear:
        # equipment_display_id: u32
        equipment_display_id = await read_int(reader, 4)

        # inventory_type: InventoryType
        inventory_type = InventoryType(await read_int(reader, 1))

        # enchantment: u32
        enchantment = await read_int(reader, 4)

        return CharacterGear(
            equipment_display_id=equipment_display_id,
            inventory_type=inventory_type,
            enchantment=enchantment,
        )

    def write(self, _fmt, _data):
        _fmt += 'IBI'
        _data.extend([self.equipment_display_id, self.inventory_type.value, self.enchantment])
        return _fmt, _data


@dataclasses.dataclass
class Character:
    guid: int
    name: str
    race: Race
    class_type: Class
    gender: Gender
    skin: int
    face: int
    hair_style: int
    hair_color: int
    facial_hair: int
    level: int
    area: Area
    map: Map
    position: Vector3d
    guild_id: int
    flags: int
    recustomization_flags: int
    first_login: bool
    pet_display_id: int
    pet_level: int
    pet_family: CreatureFamily
    equipment: typing.List[CharacterGear]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Character:
        # guid: Guid
        guid = await read_int(reader, 8)

        # name: CString
        name = await read_cstring(reader)

        # race: Race
        race = Race(await read_int(reader, 1))

        # class_type: Class
        class_type = Class(await read_int(reader, 1))

        # gender: Gender
        gender = Gender(await read_int(reader, 1))

        # skin: u8
        skin = await read_int(reader, 1)

        # face: u8
        face = await read_int(reader, 1)

        # hair_style: u8
        hair_style = await read_int(reader, 1)

        # hair_color: u8
        hair_color = await read_int(reader, 1)

        # facial_hair: u8
        facial_hair = await read_int(reader, 1)

        # level: Level
        level = await read_int(reader, 1)

        # area: Area
        area = Area(await read_int(reader, 4))

        # map: Map
        map = Map(await read_int(reader, 4))

        # position: Vector3d
        position = await Vector3d.read(reader)

        # guild_id: u32
        guild_id = await read_int(reader, 4)

        # flags: u32
        flags = await read_int(reader, 4)

        # recustomization_flags: u32
        recustomization_flags = await read_int(reader, 4)

        # first_login: Bool8
        first_login = await read_bool(reader, 1)

        # pet_display_id: u32
        pet_display_id = await read_int(reader, 4)

        # pet_level: Level32
        pet_level = await read_int(reader, 4)

        # pet_family: CreatureFamily
        pet_family = CreatureFamily(await read_int(reader, 4))

        # equipment: CharacterGear[23]
        equipment = []
        for _ in range(0, 23):
            equipment.append(await CharacterGear.read(reader))

        return Character(
            guid=guid,
            name=name,
            race=race,
            class_type=class_type,
            gender=gender,
            skin=skin,
            face=face,
            hair_style=hair_style,
            hair_color=hair_color,
            facial_hair=facial_hair,
            level=level,
            area=area,
            map=map,
            position=position,
            guild_id=guild_id,
            flags=flags,
            recustomization_flags=recustomization_flags,
            first_login=first_login,
            pet_display_id=pet_display_id,
            pet_level=pet_level,
            pet_family=pet_family,
            equipment=equipment,
        )

    def write(self, _fmt, _data):
        _fmt += f'Q{len(self.name)}sBBBBBBBBBBII'
        _data.extend([self.guid, self.name.encode('utf-8'), 0, self.race.value, self.class_type.value, self.gender.value, self.skin, self.face, self.hair_style, self.hair_color, self.facial_hair, self.level, self.area.value, self.map.value])
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # guild_id: u32
        _fmt += 'I'
        _data.append(self.guild_id)

        # flags: u32
        _fmt += 'I'
        _data.append(self.flags)

        # recustomization_flags: u32
        _fmt += 'I'
        _data.append(self.recustomization_flags)

        # first_login: Bool8
        _fmt += 'B'
        _data.append(self.first_login)

        # pet_display_id: u32
        _fmt += 'I'
        _data.append(self.pet_display_id)

        # pet_level: Level32
        _fmt += 'I'
        _data.append(self.pet_level)

        # pet_family: CreatureFamily
        _fmt += 'I'
        _data.append(self.pet_family.value)

        # equipment: CharacterGear[23]
        for i in self.equipment:
            _fmt, _data = i.write(_fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        return 270 + len(self.name)


@dataclasses.dataclass
class CooldownSpell:
    spell_id: int
    item_id: int
    spell_category: int
    cooldown: int
    category_cooldown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> CooldownSpell:
        # spell_id: u16
        spell_id = await read_int(reader, 2)

        # item_id: u16
        item_id = await read_int(reader, 2)

        # spell_category: u16
        spell_category = await read_int(reader, 2)

        # cooldown: Milliseconds
        cooldown = await read_int(reader, 4)

        # category_cooldown: Milliseconds
        category_cooldown = await read_int(reader, 4)

        return CooldownSpell(
            spell_id=spell_id,
            item_id=item_id,
            spell_category=spell_category,
            cooldown=cooldown,
            category_cooldown=category_cooldown,
        )

    def write(self, _fmt, _data):
        _fmt += 'HHHII'
        _data.extend([self.spell_id, self.item_id, self.spell_category, self.cooldown, self.category_cooldown])
        return _fmt, _data


@dataclasses.dataclass
class DamageInfo:
    spell_school_mask: int
    damage_float: float
    damage_uint: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> DamageInfo:
        # spell_school_mask: u32
        spell_school_mask = await read_int(reader, 4)

        # damage_float: f32
        damage_float = await read_float(reader)

        # damage_uint: u32
        damage_uint = await read_int(reader, 4)

        return DamageInfo(
            spell_school_mask=spell_school_mask,
            damage_float=damage_float,
            damage_uint=damage_uint,
        )

    def write(self, _fmt, _data):
        _fmt += 'IfI'
        _data.extend([self.spell_school_mask, self.damage_float, self.damage_uint])
        return _fmt, _data


@dataclasses.dataclass
class DispelledSpell:
    spell: int
    method: DispelMethod

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> DispelledSpell:
        # spell: Spell
        spell = await read_int(reader, 4)

        # method: DispelMethod
        method = DispelMethod(await read_int(reader, 1))

        return DispelledSpell(
            spell=spell,
            method=method,
        )

    def write(self, _fmt, _data):
        _fmt += 'IB'
        _data.extend([self.spell, self.method.value])
        return _fmt, _data


@dataclasses.dataclass
class EquipmentSet:
    item: int
    source_bag: int
    source_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> EquipmentSet:
        # item: Guid
        item = await read_int(reader, 8)

        # source_bag: u8
        source_bag = await read_int(reader, 1)

        # source_slot: u8
        source_slot = await read_int(reader, 1)

        return EquipmentSet(
            item=item,
            source_bag=source_bag,
            source_slot=source_slot,
        )

    def write(self, _fmt, _data):
        _fmt += 'QBB'
        _data.extend([self.item, self.source_bag, self.source_slot])
        return _fmt, _data


@dataclasses.dataclass
class EquipmentSetListItem:
    guid: int
    name: str
    icon_name: str
    equipment: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> EquipmentSetListItem:
        # guid: Guid
        guid = await read_int(reader, 8)

        # name: CString
        name = await read_cstring(reader)

        # icon_name: CString
        icon_name = await read_cstring(reader)

        # equipment: Guid[19]
        equipment = []
        for _ in range(0, 19):
            equipment.append(await read_int(reader, 8))

        return EquipmentSetListItem(
            guid=guid,
            name=name,
            icon_name=icon_name,
            equipment=equipment,
        )

    def write(self, _fmt, _data):
        _fmt += f'Q{len(self.name)}sB{len(self.icon_name)}sB{len(self.equipment)}Q'
        _data.extend([self.guid, self.name.encode('utf-8'), 0, self.icon_name.encode('utf-8'), 0, *self.equipment])
        return _fmt, _data

    def size(self) -> int:
        return 162 + len(self.name) + len(self.icon_name)


@dataclasses.dataclass
class FactionInitializer:
    flag: FactionFlag
    standing: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> FactionInitializer:
        # flag: FactionFlag
        flag = FactionFlag(await read_int(reader, 1))

        # standing: u32
        standing = await read_int(reader, 4)

        return FactionInitializer(
            flag=flag,
            standing=standing,
        )

    def write(self, _fmt, _data):
        _fmt += 'BI'
        _data.extend([self.flag.value, self.standing])
        return _fmt, _data


@dataclasses.dataclass
class FactionStanding:
    faction: Faction
    standing: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> FactionStanding:
        # faction: Faction
        faction = Faction(await read_int(reader, 2))

        # standing: u32
        standing = await read_int(reader, 4)

        return FactionStanding(
            faction=faction,
            standing=standing,
        )

    def write(self, _fmt, _data):
        _fmt += 'HI'
        _data.extend([self.faction.value, self.standing])
        return _fmt, _data


@dataclasses.dataclass
class ForcedReaction:
    faction: Faction
    reputation_rank: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ForcedReaction:
        # faction: Faction
        faction = Faction(await read_int(reader, 2))

        # reputation_rank: u32
        reputation_rank = await read_int(reader, 4)

        return ForcedReaction(
            faction=faction,
            reputation_rank=reputation_rank,
        )

    def write(self, _fmt, _data):
        _fmt += 'HI'
        _data.extend([self.faction.value, self.reputation_rank])
        return _fmt, _data


@dataclasses.dataclass
class GmSurveyQuestion:
    question_id: int
    answer: int
    comment: str

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GmSurveyQuestion:
        # question_id: u32
        question_id = await read_int(reader, 4)

        # answer: u8
        answer = await read_int(reader, 1)

        # comment: CString
        comment = await read_cstring(reader)

        return GmSurveyQuestion(
            question_id=question_id,
            answer=answer,
            comment=comment,
        )

    def write(self, _fmt, _data):
        _fmt += f'IB{len(self.comment)}sB'
        _data.extend([self.question_id, self.answer, self.comment.encode('utf-8'), 0])
        return _fmt, _data

    def size(self) -> int:
        return 6 + len(self.comment)


@dataclasses.dataclass
class GossipItem:
    id: int
    item_icon: int
    coded: bool
    money_required: int
    message: str
    accept_text: str

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GossipItem:
        # id: u32
        id = await read_int(reader, 4)

        # item_icon: u8
        item_icon = await read_int(reader, 1)

        # coded: Bool8
        coded = await read_bool(reader, 1)

        # money_required: Gold
        money_required = await read_int(reader, 4)

        # message: CString
        message = await read_cstring(reader)

        # accept_text: CString
        accept_text = await read_cstring(reader)

        return GossipItem(
            id=id,
            item_icon=item_icon,
            coded=coded,
            money_required=money_required,
            message=message,
            accept_text=accept_text,
        )

    def write(self, _fmt, _data):
        _fmt += f'IBBI{len(self.message)}sB{len(self.accept_text)}sB'
        _data.extend([self.id, self.item_icon, self.coded, self.money_required, self.message.encode('utf-8'), 0, self.accept_text.encode('utf-8'), 0])
        return _fmt, _data

    def size(self) -> int:
        return 12 + len(self.message) + len(self.accept_text)


@dataclasses.dataclass
class GroupListMember:
    name: str
    guid: int
    is_online: bool
    group_id: int
    flags: int
    lfg_roles: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GroupListMember:
        # name: CString
        name = await read_cstring(reader)

        # guid: Guid
        guid = await read_int(reader, 8)

        # is_online: Bool8
        is_online = await read_bool(reader, 1)

        # group_id: u8
        group_id = await read_int(reader, 1)

        # flags: u8
        flags = await read_int(reader, 1)

        # lfg_roles: u8
        lfg_roles = await read_int(reader, 1)

        return GroupListMember(
            name=name,
            guid=guid,
            is_online=is_online,
            group_id=group_id,
            flags=flags,
            lfg_roles=lfg_roles,
        )

    def write(self, _fmt, _data):
        _fmt += f'{len(self.name)}sBQBBBB'
        _data.extend([self.name.encode('utf-8'), 0, self.guid, self.is_online, self.group_id, self.flags, self.lfg_roles])
        return _fmt, _data

    def size(self) -> int:
        return 13 + len(self.name)


@dataclasses.dataclass
class GuildBankRights:
    rights: int
    slots_per_day: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GuildBankRights:
        # rights: u32
        rights = await read_int(reader, 4)

        # slots_per_day: u32
        slots_per_day = await read_int(reader, 4)

        return GuildBankRights(
            rights=rights,
            slots_per_day=slots_per_day,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.rights, self.slots_per_day])
        return _fmt, _data


@dataclasses.dataclass
class GuildBankSocket:
    socket_index: int
    gem: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GuildBankSocket:
        # socket_index: u8
        socket_index = await read_int(reader, 1)

        # gem: u32
        gem = await read_int(reader, 4)

        return GuildBankSocket(
            socket_index=socket_index,
            gem=gem,
        )

    def write(self, _fmt, _data):
        _fmt += 'BI'
        _data.extend([self.socket_index, self.gem])
        return _fmt, _data


@dataclasses.dataclass
class GuildBankSlot:
    slot: int
    item: int
    unknown1: int
    item_random_property_id: VariableItemRandomProperty
    amount_of_items: int
    unknown2: int
    unknown3: int
    sockets: typing.List[GuildBankSocket]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GuildBankSlot:
        # slot: u8
        slot = await read_int(reader, 1)

        # item: Item
        item = await read_int(reader, 4)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # item_random_property_id: VariableItemRandomProperty
        item_random_property_id = await VariableItemRandomProperty.read(reader)

        # amount_of_items: u32
        amount_of_items = await read_int(reader, 4)

        # unknown2: u32
        unknown2 = await read_int(reader, 4)

        # unknown3: u8
        unknown3 = await read_int(reader, 1)

        # amount_of_sockets: u8
        amount_of_sockets = await read_int(reader, 1)

        # sockets: GuildBankSocket[amount_of_sockets]
        sockets = []
        for _ in range(0, amount_of_sockets):
            sockets.append(await GuildBankSocket.read(reader))

        return GuildBankSlot(
            slot=slot,
            item=item,
            unknown1=unknown1,
            item_random_property_id=item_random_property_id,
            amount_of_items=amount_of_items,
            unknown2=unknown2,
            unknown3=unknown3,
            sockets=sockets,
        )

    def write(self, _fmt, _data):
        _fmt += 'BII'
        _data.extend([self.slot, self.item, self.unknown1])
        # item_random_property_id: VariableItemRandomProperty
        _fmt, _data = self.item_random_property_id.write(_fmt, _data)

        # amount_of_items: u32
        _fmt += 'I'
        _data.append(self.amount_of_items)

        # unknown2: u32
        _fmt += 'I'
        _data.append(self.unknown2)

        # unknown3: u8
        _fmt += 'B'
        _data.append(self.unknown3)

        # amount_of_sockets: u8
        _fmt += 'B'
        _data.append(len(self.sockets))

        # sockets: GuildBankSocket[amount_of_sockets]
        for i in self.sockets:
            _fmt, _data = i.write(_fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        return 19 + self.item_random_property_id.size() + 5 * len(self.sockets)


@dataclasses.dataclass
class GuildBankTab:
    tab_name: str
    tab_icon: str

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GuildBankTab:
        # tab_name: CString
        tab_name = await read_cstring(reader)

        # tab_icon: CString
        tab_icon = await read_cstring(reader)

        return GuildBankTab(
            tab_name=tab_name,
            tab_icon=tab_icon,
        )

    def write(self, _fmt, _data):
        _fmt += f'{len(self.tab_name)}sB{len(self.tab_icon)}sB'
        _data.extend([self.tab_name.encode('utf-8'), 0, self.tab_icon.encode('utf-8'), 0])
        return _fmt, _data

    def size(self) -> int:
        return 2 + len(self.tab_name) + len(self.tab_icon)


@dataclasses.dataclass
class GuildLogEvent:
    event: GuildEvent
    player1: int
    unix_time: int
    player2: typing.Optional[int] = None
    new_rank: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GuildLogEvent:
        player2 = None
        new_rank = None
        # event: GuildEvent
        event = GuildEvent(await read_int(reader, 1))

        # player1: Guid
        player1 = await read_int(reader, 8)

        if event in {GuildEvent.JOINED, GuildEvent.LEFT}:
            # player2: Guid
            player2 = await read_int(reader, 8)

        elif event in {GuildEvent.PROMOTION, GuildEvent.DEMOTION}:
            # new_rank: u8
            new_rank = await read_int(reader, 1)

        # unix_time: u32
        unix_time = await read_int(reader, 4)

        return GuildLogEvent(
            event=event,
            player1=player1,
            player2=player2,
            new_rank=new_rank,
            unix_time=unix_time,
        )

    def write(self, _fmt, _data):
        _fmt += 'BQ'
        _data.extend([self.event.value, self.player1])
        if self.event in {GuildEvent.JOINED, GuildEvent.LEFT}:
            _fmt += 'Q'
            _data.append(self.player2)
        elif self.event in {GuildEvent.PROMOTION, GuildEvent.DEMOTION}:
            _fmt += 'B'
            _data.append(self.new_rank)
        # unix_time: u32
        _fmt += 'I'
        _data.append(self.unix_time)

        return _fmt, _data

    def size(self) -> int:
        _size = 13

        if self.event in {GuildEvent.JOINED, GuildEvent.LEFT}:
            _size += 8
        elif self.event in {GuildEvent.PROMOTION, GuildEvent.DEMOTION}:
            _size += 1

        return _size


@dataclasses.dataclass
class GuildMember:
    guid: int
    unknown: int
    status: GuildMemberStatus
    name: str
    rank: int
    level: int
    class_type: Class
    gender: Gender
    area: Area
    public_note: str
    officer_note: str
    time_offline: typing.Optional[float] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GuildMember:
        time_offline = None
        # guid: Guid
        guid = await read_int(reader, 8)

        # unknown: u32
        unknown = await read_int(reader, 4)

        # status: GuildMemberStatus
        status = GuildMemberStatus(await read_int(reader, 1))

        # name: CString
        name = await read_cstring(reader)

        # rank: u32
        rank = await read_int(reader, 4)

        # level: Level
        level = await read_int(reader, 1)

        # class_type: Class
        class_type = Class(await read_int(reader, 1))

        # gender: Gender
        gender = Gender(await read_int(reader, 1))

        # area: Area
        area = Area(await read_int(reader, 4))

        if status == GuildMemberStatus.OFFLINE:
            # time_offline: f32
            time_offline = await read_float(reader)

        # public_note: CString
        public_note = await read_cstring(reader)

        # officer_note: CString
        officer_note = await read_cstring(reader)

        return GuildMember(
            guid=guid,
            unknown=unknown,
            status=status,
            name=name,
            rank=rank,
            level=level,
            class_type=class_type,
            gender=gender,
            area=area,
            time_offline=time_offline,
            public_note=public_note,
            officer_note=officer_note,
        )

    def write(self, _fmt, _data):
        _fmt += f'QIB{len(self.name)}sBIBBBI'
        _data.extend([self.guid, self.unknown, self.status.value, self.name.encode('utf-8'), 0, self.rank, self.level, self.class_type.value, self.gender.value, self.area.value])
        if self.status == GuildMemberStatus.OFFLINE:
            _fmt += 'f'
            _data.append(self.time_offline)
        # public_note: CString
        _fmt += f'{len(self.public_note)}sB'
        _data.extend([self.public_note.encode('utf-8'), 0])

        # officer_note: CString
        _fmt += f'{len(self.officer_note)}sB'
        _data.extend([self.officer_note.encode('utf-8'), 0])

        return _fmt, _data

    def size(self) -> int:
        _size = 27 + len(self.name) + len(self.public_note) + len(self.officer_note)

        if self.status == GuildMemberStatus.OFFLINE:
            _size += 4

        return _size


@dataclasses.dataclass
class GuildRights:
    rights: int
    money_per_day: int
    bank_tab_rights: typing.List[GuildBankRights]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GuildRights:
        # rights: u32
        rights = await read_int(reader, 4)

        # money_per_day: Gold
        money_per_day = await read_int(reader, 4)

        # bank_tab_rights: GuildBankRights[6]
        bank_tab_rights = []
        for _ in range(0, 6):
            bank_tab_rights.append(await GuildBankRights.read(reader))

        return GuildRights(
            rights=rights,
            money_per_day=money_per_day,
            bank_tab_rights=bank_tab_rights,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.rights, self.money_per_day])
        # bank_tab_rights: GuildBankRights[6]
        for i in self.bank_tab_rights:
            _fmt, _data = i.write(_fmt, _data)

        return _fmt, _data


@dataclasses.dataclass
class InitialSpell:
    spell_id: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> InitialSpell:
        # spell_id: u32
        spell_id = await read_int(reader, 4)

        # unknown1: u16
        unknown1 = await read_int(reader, 2)

        return InitialSpell(
            spell_id=spell_id,
            unknown1=unknown1,
        )

    def write(self, _fmt, _data):
        _fmt += 'IH'
        _data.extend([self.spell_id, self.unknown1])
        return _fmt, _data


@dataclasses.dataclass
class InspectTalent:
    talent: Talent
    max_rank: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> InspectTalent:
        # talent: Talent
        talent = Talent(await read_int(reader, 4))

        # max_rank: u8
        max_rank = await read_int(reader, 1)

        return InspectTalent(
            talent=talent,
            max_rank=max_rank,
        )

    def write(self, _fmt, _data):
        _fmt += 'IB'
        _data.extend([self.talent.value, self.max_rank])
        return _fmt, _data


@dataclasses.dataclass
class InspectTalentGear:
    item: int
    enchant_mask: EnchantMask
    unknown1: int
    creator: int
    unknown2: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> InspectTalentGear:
        # item: Item
        item = await read_int(reader, 4)

        # enchant_mask: EnchantMask
        enchant_mask = await EnchantMask.read(reader)

        # unknown1: u16
        unknown1 = await read_int(reader, 2)

        # creator: PackedGuid
        creator = await read_packed_guid(reader)

        # unknown2: u32
        unknown2 = await read_int(reader, 4)

        return InspectTalentGear(
            item=item,
            enchant_mask=enchant_mask,
            unknown1=unknown1,
            creator=creator,
            unknown2=unknown2,
        )

    def write(self, _fmt, _data):
        _fmt += 'I'
        _data.append(self.item)
        # enchant_mask: EnchantMask
        _fmt, _data = self.enchant_mask.write(_fmt, _data)

        # unknown1: u16
        _fmt += 'H'
        _data.append(self.unknown1)

        # creator: PackedGuid
        _fmt, _data = packed_guid_write(self.creator, _fmt, _data)

        # unknown2: u32
        _fmt += 'I'
        _data.append(self.unknown2)

        return _fmt, _data

    def size(self) -> int:
        return 10 + self.enchant_mask.size() + packed_guid_size(self.creator)


@dataclasses.dataclass
class InspectTalentSpec:
    talents: typing.List[InspectTalent]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> InspectTalentSpec:
        # amount_of_talents: u8
        amount_of_talents = await read_int(reader, 1)

        # talents: InspectTalent[amount_of_talents]
        talents = []
        for _ in range(0, amount_of_talents):
            talents.append(await InspectTalent.read(reader))

        return InspectTalentSpec(
            talents=talents,
        )

    def write(self, _fmt, _data):
        _fmt += 'B'
        _data.append(len(self.talents))
        # talents: InspectTalent[amount_of_talents]
        for i in self.talents:
            _fmt, _data = i.write(_fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        return 1 + 5 * len(self.talents)


@dataclasses.dataclass
class ItemDamageType:
    damage_minimum: float
    damage_maximum: float
    school: SpellSchool

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ItemDamageType:
        # damage_minimum: f32
        damage_minimum = await read_float(reader)

        # damage_maximum: f32
        damage_maximum = await read_float(reader)

        # school: SpellSchool
        school = SpellSchool(await read_int(reader, 4))

        return ItemDamageType(
            damage_minimum=damage_minimum,
            damage_maximum=damage_maximum,
            school=school,
        )

    def write(self, _fmt, _data):
        _fmt += 'ffI'
        _data.extend([self.damage_minimum, self.damage_maximum, self.school.value])
        return _fmt, _data


@dataclasses.dataclass
class ItemRefundExtra:
    item: int
    amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ItemRefundExtra:
        # item: Item
        item = await read_int(reader, 4)

        # amount: u32
        amount = await read_int(reader, 4)

        return ItemRefundExtra(
            item=item,
            amount=amount,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.item, self.amount])
        return _fmt, _data


@dataclasses.dataclass
class ItemSocket:
    color: int
    content: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ItemSocket:
        # color: u32
        color = await read_int(reader, 4)

        # content: u32
        content = await read_int(reader, 4)

        return ItemSocket(
            color=color,
            content=content,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.color, self.content])
        return _fmt, _data


@dataclasses.dataclass
class ItemSpells:
    spell: int
    spell_trigger: SpellTriggerType
    spell_charges: int
    spell_cooldown: int
    spell_category: int
    spell_category_cooldown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ItemSpells:
        # spell: Spell
        spell = await read_int(reader, 4)

        # spell_trigger: SpellTriggerType
        spell_trigger = SpellTriggerType(await read_int(reader, 4))

        # spell_charges: i32
        spell_charges = await read_int(reader, 4)

        # spell_cooldown: i32
        spell_cooldown = await read_int(reader, 4)

        # spell_category: u32
        spell_category = await read_int(reader, 4)

        # spell_category_cooldown: i32
        spell_category_cooldown = await read_int(reader, 4)

        return ItemSpells(
            spell=spell,
            spell_trigger=spell_trigger,
            spell_charges=spell_charges,
            spell_cooldown=spell_cooldown,
            spell_category=spell_category,
            spell_category_cooldown=spell_category_cooldown,
        )

    def write(self, _fmt, _data):
        _fmt += 'IIiiIi'
        _data.extend([self.spell, self.spell_trigger.value, self.spell_charges, self.spell_cooldown, self.spell_category, self.spell_category_cooldown])
        return _fmt, _data


@dataclasses.dataclass
class ItemStat:
    stat_type: int
    value: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ItemStat:
        # stat_type: u32
        stat_type = await read_int(reader, 4)

        # value: i32
        value = await read_int(reader, 4)

        return ItemStat(
            stat_type=stat_type,
            value=value,
        )

    def write(self, _fmt, _data):
        _fmt += 'Ii'
        _data.extend([self.stat_type, self.value])
        return _fmt, _data


@dataclasses.dataclass
class LfgQuestReward:
    item: int
    display_id: int
    amount_of_rewards: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> LfgQuestReward:
        # item: Item
        item = await read_int(reader, 4)

        # display_id: u32
        display_id = await read_int(reader, 4)

        # amount_of_rewards: u32
        amount_of_rewards = await read_int(reader, 4)

        return LfgQuestReward(
            item=item,
            display_id=display_id,
            amount_of_rewards=amount_of_rewards,
        )

    def write(self, _fmt, _data):
        _fmt += 'III'
        _data.extend([self.item, self.display_id, self.amount_of_rewards])
        return _fmt, _data


@dataclasses.dataclass
class LfgAvailableDungeon:
    dungeon_entry: int
    done: bool
    quest_reward: int
    xp_reward: int
    unknown1: int
    unknown2: int
    rewards: typing.List[LfgQuestReward]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> LfgAvailableDungeon:
        # dungeon_entry: u32
        dungeon_entry = await read_int(reader, 4)

        # done: Bool8
        done = await read_bool(reader, 1)

        # quest_reward: u32
        quest_reward = await read_int(reader, 4)

        # xp_reward: u32
        xp_reward = await read_int(reader, 4)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # unknown2: u32
        unknown2 = await read_int(reader, 4)

        # amount_of_rewards: u8
        amount_of_rewards = await read_int(reader, 1)

        # rewards: LfgQuestReward[amount_of_rewards]
        rewards = []
        for _ in range(0, amount_of_rewards):
            rewards.append(await LfgQuestReward.read(reader))

        return LfgAvailableDungeon(
            dungeon_entry=dungeon_entry,
            done=done,
            quest_reward=quest_reward,
            xp_reward=xp_reward,
            unknown1=unknown1,
            unknown2=unknown2,
            rewards=rewards,
        )

    def write(self, _fmt, _data):
        _fmt += 'IBIIIIB'
        _data.extend([self.dungeon_entry, self.done, self.quest_reward, self.xp_reward, self.unknown1, self.unknown2, len(self.rewards)])
        # rewards: LfgQuestReward[amount_of_rewards]
        for i in self.rewards:
            _fmt, _data = i.write(_fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        return 22 + 12 * len(self.rewards)


@dataclasses.dataclass
class LfgJoinLockedDungeon:
    dungeon_entry: int
    reason: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> LfgJoinLockedDungeon:
        # dungeon_entry: u32
        dungeon_entry = await read_int(reader, 4)

        # reason: u32
        reason = await read_int(reader, 4)

        return LfgJoinLockedDungeon(
            dungeon_entry=dungeon_entry,
            reason=reason,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.dungeon_entry, self.reason])
        return _fmt, _data


@dataclasses.dataclass
class LfgJoinPlayer:
    player: int
    locked_dungeons: typing.List[LfgJoinLockedDungeon]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> LfgJoinPlayer:
        # player: Guid
        player = await read_int(reader, 8)

        # amount_of_locked_dungeons: u32
        amount_of_locked_dungeons = await read_int(reader, 4)

        # locked_dungeons: LfgJoinLockedDungeon[amount_of_locked_dungeons]
        locked_dungeons = []
        for _ in range(0, amount_of_locked_dungeons):
            locked_dungeons.append(await LfgJoinLockedDungeon.read(reader))

        return LfgJoinPlayer(
            player=player,
            locked_dungeons=locked_dungeons,
        )

    def write(self, _fmt, _data):
        _fmt += 'QI'
        _data.extend([self.player, len(self.locked_dungeons)])
        # locked_dungeons: LfgJoinLockedDungeon[amount_of_locked_dungeons]
        for i in self.locked_dungeons:
            _fmt, _data = i.write(_fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        return 12 + 8 * len(self.locked_dungeons)


@dataclasses.dataclass
class LfgListGroup:
    group: int
    flags: LfgUpdateFlag
    instance: int
    encounter_mask: int
    comment: typing.Optional[str] = None
    roles: typing.Optional[typing.List[int]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> LfgListGroup:
        comment = None
        roles = None
        # group: Guid
        group = await read_int(reader, 8)

        # flags: LfgUpdateFlag
        flags = LfgUpdateFlag(await read_int(reader, 4))

        if LfgUpdateFlag.COMMENT in flags:
            # comment: CString
            comment = await read_cstring(reader)

        if LfgUpdateFlag.ROLES in flags:
            # roles: u8[3]
            roles = []
            for _ in range(0, 3):
                roles.append(await read_int(reader, 1))

        # instance: Guid
        instance = await read_int(reader, 8)

        # encounter_mask: u32
        encounter_mask = await read_int(reader, 4)

        return LfgListGroup(
            group=group,
            flags=flags,
            comment=comment,
            roles=roles,
            instance=instance,
            encounter_mask=encounter_mask,
        )

    def write(self, _fmt, _data):
        _fmt += 'QI'
        _data.extend([self.group, self.flags.value])
        if LfgUpdateFlag.COMMENT in self.flags:
            _fmt += f'{len(self.comment)}sB'
            _data.extend([self.comment.encode('utf-8'), 0])
        if LfgUpdateFlag.ROLES in self.flags:
            _fmt += f'{len(self.roles)}B'
            _data.extend([*self.roles])
        # instance: Guid
        _fmt += 'Q'
        _data.append(self.instance)

        # encounter_mask: u32
        _fmt += 'I'
        _data.append(self.encounter_mask)

        return _fmt, _data

    def size(self) -> int:
        _size = 24

        if LfgUpdateFlag.COMMENT in self.flags:
            _size += 1 + len(self.comment)

        if LfgUpdateFlag.ROLES in self.flags:
            _size += 3

        return _size


@dataclasses.dataclass
class LfgListPlayer:
    player: int
    flags: LfgUpdateFlag
    instance: int
    encounter_mask: int
    level: typing.Optional[int] = None
    class_type: typing.Optional[Class] = None
    race: typing.Optional[Race] = None
    talents0: typing.Optional[int] = None
    talents1: typing.Optional[int] = None
    talents2: typing.Optional[int] = None
    armor: typing.Optional[int] = None
    spell_damage: typing.Optional[int] = None
    spell_heal: typing.Optional[int] = None
    crit_rating_melee: typing.Optional[int] = None
    crit_rating_ranged: typing.Optional[int] = None
    crit_rating_spell: typing.Optional[int] = None
    mana_per_5_seconds: typing.Optional[float] = None
    mana_per_5_seconds_combat: typing.Optional[float] = None
    attack_power: typing.Optional[int] = None
    agility: typing.Optional[int] = None
    health: typing.Optional[int] = None
    mana: typing.Optional[int] = None
    online: typing.Optional[bool] = None
    average_item_level: typing.Optional[int] = None
    defense_skill: typing.Optional[int] = None
    dodge_rating: typing.Optional[int] = None
    block_rating: typing.Optional[int] = None
    parry_rating: typing.Optional[int] = None
    haste_rating: typing.Optional[int] = None
    expertise_rating: typing.Optional[int] = None
    comment: typing.Optional[str] = None
    is_looking_for_more: typing.Optional[bool] = None
    group: typing.Optional[int] = None
    roles: typing.Optional[int] = None
    area: typing.Optional[Area] = None
    unknown1: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> LfgListPlayer:
        level = None
        class_type = None
        race = None
        talents0 = None
        talents1 = None
        talents2 = None
        armor = None
        spell_damage = None
        spell_heal = None
        crit_rating_melee = None
        crit_rating_ranged = None
        crit_rating_spell = None
        mana_per_5_seconds = None
        mana_per_5_seconds_combat = None
        attack_power = None
        agility = None
        health = None
        mana = None
        online = None
        average_item_level = None
        defense_skill = None
        dodge_rating = None
        block_rating = None
        parry_rating = None
        haste_rating = None
        expertise_rating = None
        comment = None
        is_looking_for_more = None
        group = None
        roles = None
        area = None
        unknown1 = None
        # player: Guid
        player = await read_int(reader, 8)

        # flags: LfgUpdateFlag
        flags = LfgUpdateFlag(await read_int(reader, 4))

        if LfgUpdateFlag.CHARACTER_INFO in flags:
            # level: Level
            level = await read_int(reader, 1)

            # class_type: Class
            class_type = Class(await read_int(reader, 1))

            # race: Race
            race = Race(await read_int(reader, 1))

            # talents0: u8
            talents0 = await read_int(reader, 1)

            # talents1: u8
            talents1 = await read_int(reader, 1)

            # talents2: u8
            talents2 = await read_int(reader, 1)

            # armor: u32
            armor = await read_int(reader, 4)

            # spell_damage: u32
            spell_damage = await read_int(reader, 4)

            # spell_heal: u32
            spell_heal = await read_int(reader, 4)

            # crit_rating_melee: u32
            crit_rating_melee = await read_int(reader, 4)

            # crit_rating_ranged: u32
            crit_rating_ranged = await read_int(reader, 4)

            # crit_rating_spell: u32
            crit_rating_spell = await read_int(reader, 4)

            # mana_per_5_seconds: f32
            mana_per_5_seconds = await read_float(reader)

            # mana_per_5_seconds_combat: f32
            mana_per_5_seconds_combat = await read_float(reader)

            # attack_power: u32
            attack_power = await read_int(reader, 4)

            # agility: u32
            agility = await read_int(reader, 4)

            # health: u32
            health = await read_int(reader, 4)

            # mana: u32
            mana = await read_int(reader, 4)

            # online: Bool32
            online = await read_bool(reader, 4)

            # average_item_level: u32
            average_item_level = await read_int(reader, 4)

            # defense_skill: u32
            defense_skill = await read_int(reader, 4)

            # dodge_rating: u32
            dodge_rating = await read_int(reader, 4)

            # block_rating: u32
            block_rating = await read_int(reader, 4)

            # parry_rating: u32
            parry_rating = await read_int(reader, 4)

            # haste_rating: u32
            haste_rating = await read_int(reader, 4)

            # expertise_rating: u32
            expertise_rating = await read_int(reader, 4)

        if LfgUpdateFlag.COMMENT in flags:
            # comment: CString
            comment = await read_cstring(reader)

        if LfgUpdateFlag.GROUP_LEADER in flags:
            # is_looking_for_more: Bool8
            is_looking_for_more = await read_bool(reader, 1)

        if LfgUpdateFlag.GROUP_GUID in flags:
            # group: Guid
            group = await read_int(reader, 8)

        if LfgUpdateFlag.ROLES in flags:
            # roles: u8
            roles = await read_int(reader, 1)

        if LfgUpdateFlag.AREA in flags:
            # area: Area
            area = Area(await read_int(reader, 4))

        if LfgUpdateFlag.STATUS in flags:
            # unknown1: u8
            unknown1 = await read_int(reader, 1)

        # instance: Guid
        instance = await read_int(reader, 8)

        # encounter_mask: u32
        encounter_mask = await read_int(reader, 4)

        return LfgListPlayer(
            player=player,
            flags=flags,
            level=level,
            class_type=class_type,
            race=race,
            talents0=talents0,
            talents1=talents1,
            talents2=talents2,
            armor=armor,
            spell_damage=spell_damage,
            spell_heal=spell_heal,
            crit_rating_melee=crit_rating_melee,
            crit_rating_ranged=crit_rating_ranged,
            crit_rating_spell=crit_rating_spell,
            mana_per_5_seconds=mana_per_5_seconds,
            mana_per_5_seconds_combat=mana_per_5_seconds_combat,
            attack_power=attack_power,
            agility=agility,
            health=health,
            mana=mana,
            online=online,
            average_item_level=average_item_level,
            defense_skill=defense_skill,
            dodge_rating=dodge_rating,
            block_rating=block_rating,
            parry_rating=parry_rating,
            haste_rating=haste_rating,
            expertise_rating=expertise_rating,
            comment=comment,
            is_looking_for_more=is_looking_for_more,
            group=group,
            roles=roles,
            area=area,
            unknown1=unknown1,
            instance=instance,
            encounter_mask=encounter_mask,
        )

    def write(self, _fmt, _data):
        _fmt += 'QI'
        _data.extend([self.player, self.flags.value])
        if LfgUpdateFlag.CHARACTER_INFO in self.flags:
            _fmt += 'BBBBBBIIIIIIffIIIIIIIIIIII'
            _data.extend([self.level, self.class_type.value, self.race.value, self.talents0, self.talents1, self.talents2, self.armor, self.spell_damage, self.spell_heal, self.crit_rating_melee, self.crit_rating_ranged, self.crit_rating_spell, self.mana_per_5_seconds, self.mana_per_5_seconds_combat, self.attack_power, self.agility, self.health, self.mana, self.online, self.average_item_level, self.defense_skill, self.dodge_rating, self.block_rating, self.parry_rating, self.haste_rating, self.expertise_rating])
        if LfgUpdateFlag.COMMENT in self.flags:
            _fmt += f'{len(self.comment)}sB'
            _data.extend([self.comment.encode('utf-8'), 0])
        if LfgUpdateFlag.GROUP_LEADER in self.flags:
            _fmt += 'B'
            _data.append(self.is_looking_for_more)
        if LfgUpdateFlag.GROUP_GUID in self.flags:
            _fmt += 'Q'
            _data.append(self.group)
        if LfgUpdateFlag.ROLES in self.flags:
            _fmt += 'B'
            _data.append(self.roles)
        if LfgUpdateFlag.AREA in self.flags:
            _fmt += 'I'
            _data.append(self.area.value)
        if LfgUpdateFlag.STATUS in self.flags:
            _fmt += 'B'
            _data.append(self.unknown1)
        # instance: Guid
        _fmt += 'Q'
        _data.append(self.instance)

        # encounter_mask: u32
        _fmt += 'I'
        _data.append(self.encounter_mask)

        return _fmt, _data

    def size(self) -> int:
        _size = 24

        if LfgUpdateFlag.CHARACTER_INFO in self.flags:
            _size += 86

        if LfgUpdateFlag.COMMENT in self.flags:
            _size += 1 + len(self.comment)

        if LfgUpdateFlag.GROUP_LEADER in self.flags:
            _size += 1

        if LfgUpdateFlag.GROUP_GUID in self.flags:
            _size += 8

        if LfgUpdateFlag.ROLES in self.flags:
            _size += 1

        if LfgUpdateFlag.AREA in self.flags:
            _size += 4

        if LfgUpdateFlag.STATUS in self.flags:
            _size += 1

        return _size


@dataclasses.dataclass
class LfgPartyInfo:
    player: int
    dungeons: typing.List[LfgJoinLockedDungeon]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> LfgPartyInfo:
        # player: Guid
        player = await read_int(reader, 8)

        # amount_of_dungeons: u32
        amount_of_dungeons = await read_int(reader, 4)

        # dungeons: LfgJoinLockedDungeon[amount_of_dungeons]
        dungeons = []
        for _ in range(0, amount_of_dungeons):
            dungeons.append(await LfgJoinLockedDungeon.read(reader))

        return LfgPartyInfo(
            player=player,
            dungeons=dungeons,
        )

    def write(self, _fmt, _data):
        _fmt += 'QI'
        _data.extend([self.player, len(self.dungeons)])
        # dungeons: LfgJoinLockedDungeon[amount_of_dungeons]
        for i in self.dungeons:
            _fmt, _data = i.write(_fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        return 12 + 8 * len(self.dungeons)


@dataclasses.dataclass
class LfgProposal:
    role_mask: int
    is_current_player: int
    in_dungeon: int
    in_same_group: int
    has_answered: int
    has_accepted: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> LfgProposal:
        # role_mask: u32
        role_mask = await read_int(reader, 4)

        # is_current_player: u8
        is_current_player = await read_int(reader, 1)

        # in_dungeon: u8
        in_dungeon = await read_int(reader, 1)

        # in_same_group: u8
        in_same_group = await read_int(reader, 1)

        # has_answered: u8
        has_answered = await read_int(reader, 1)

        # has_accepted: u8
        has_accepted = await read_int(reader, 1)

        return LfgProposal(
            role_mask=role_mask,
            is_current_player=is_current_player,
            in_dungeon=in_dungeon,
            in_same_group=in_same_group,
            has_answered=has_answered,
            has_accepted=has_accepted,
        )

    def write(self, _fmt, _data):
        _fmt += 'IBBBBB'
        _data.extend([self.role_mask, self.is_current_player, self.in_dungeon, self.in_same_group, self.has_answered, self.has_accepted])
        return _fmt, _data


@dataclasses.dataclass
class LfgRole:
    guid: int
    ready: bool
    roles: int
    level: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> LfgRole:
        # guid: Guid
        guid = await read_int(reader, 8)

        # ready: Bool8
        ready = await read_bool(reader, 1)

        # roles: u32
        roles = await read_int(reader, 4)

        # level: Level
        level = await read_int(reader, 1)

        return LfgRole(
            guid=guid,
            ready=ready,
            roles=roles,
            level=level,
        )

    def write(self, _fmt, _data):
        _fmt += 'QBIB'
        _data.extend([self.guid, self.ready, self.roles, self.level])
        return _fmt, _data


@dataclasses.dataclass
class ListInventoryItem:
    item_stack_count: int
    item: int
    item_display_id: int
    max_items: int
    price: int
    max_durability: int
    durability: int
    extended_cost: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ListInventoryItem:
        # item_stack_count: u32
        item_stack_count = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        # item_display_id: u32
        item_display_id = await read_int(reader, 4)

        # max_items: u32
        max_items = await read_int(reader, 4)

        # price: Gold
        price = await read_int(reader, 4)

        # max_durability: u32
        max_durability = await read_int(reader, 4)

        # durability: u32
        durability = await read_int(reader, 4)

        # extended_cost: u32
        extended_cost = await read_int(reader, 4)

        return ListInventoryItem(
            item_stack_count=item_stack_count,
            item=item,
            item_display_id=item_display_id,
            max_items=max_items,
            price=price,
            max_durability=max_durability,
            durability=durability,
            extended_cost=extended_cost,
        )

    def write(self, _fmt, _data):
        _fmt += 'IIIIIIII'
        _data.extend([self.item_stack_count, self.item, self.item_display_id, self.max_items, self.price, self.max_durability, self.durability, self.extended_cost])
        return _fmt, _data


@dataclasses.dataclass
class LootItem:
    index: int
    item: int
    ty: LootSlotType

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> LootItem:
        # index: u8
        index = await read_int(reader, 1)

        # item: Item
        item = await read_int(reader, 4)

        # ty: LootSlotType
        ty = LootSlotType(await read_int(reader, 1))

        return LootItem(
            index=index,
            item=item,
            ty=ty,
        )

    def write(self, _fmt, _data):
        _fmt += 'BIB'
        _data.extend([self.index, self.item, self.ty.value])
        return _fmt, _data


@dataclasses.dataclass
class MailListItemEnchant:
    charges: int
    duration: int
    enchant_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> MailListItemEnchant:
        # charges: u32
        charges = await read_int(reader, 4)

        # duration: u32
        duration = await read_int(reader, 4)

        # enchant_id: u32
        enchant_id = await read_int(reader, 4)

        return MailListItemEnchant(
            charges=charges,
            duration=duration,
            enchant_id=enchant_id,
        )

    def write(self, _fmt, _data):
        _fmt += 'III'
        _data.extend([self.charges, self.duration, self.enchant_id])
        return _fmt, _data


@dataclasses.dataclass
class MailListItem:
    item_index: int
    low_guid: int
    item: int
    enchants: typing.List[MailListItemEnchant]
    item_random_property_id: int
    item_suffix_factor: int
    item_amount: int
    charges: int
    max_durability: int
    durability: int
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> MailListItem:
        # item_index: u8
        item_index = await read_int(reader, 1)

        # low_guid: u32
        low_guid = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        # enchants: MailListItemEnchant[7]
        enchants = []
        for _ in range(0, 7):
            enchants.append(await MailListItemEnchant.read(reader))

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # item_suffix_factor: u32
        item_suffix_factor = await read_int(reader, 4)

        # item_amount: u8
        item_amount = await read_int(reader, 1)

        # charges: u32
        charges = await read_int(reader, 4)

        # max_durability: u32
        max_durability = await read_int(reader, 4)

        # durability: u32
        durability = await read_int(reader, 4)

        # unknown: u8
        unknown = await read_int(reader, 1)

        return MailListItem(
            item_index=item_index,
            low_guid=low_guid,
            item=item,
            enchants=enchants,
            item_random_property_id=item_random_property_id,
            item_suffix_factor=item_suffix_factor,
            item_amount=item_amount,
            charges=charges,
            max_durability=max_durability,
            durability=durability,
            unknown=unknown,
        )

    def write(self, _fmt, _data):
        _fmt += 'BII'
        _data.extend([self.item_index, self.low_guid, self.item])
        # enchants: MailListItemEnchant[7]
        for i in self.enchants:
            _fmt, _data = i.write(_fmt, _data)

        # item_random_property_id: u32
        _fmt += 'I'
        _data.append(self.item_random_property_id)

        # item_suffix_factor: u32
        _fmt += 'I'
        _data.append(self.item_suffix_factor)

        # item_amount: u8
        _fmt += 'B'
        _data.append(self.item_amount)

        # charges: u32
        _fmt += 'I'
        _data.append(self.charges)

        # max_durability: u32
        _fmt += 'I'
        _data.append(self.max_durability)

        # durability: u32
        _fmt += 'I'
        _data.append(self.durability)

        # unknown: u8
        _fmt += 'B'
        _data.append(self.unknown)

        return _fmt, _data


@dataclasses.dataclass
class Mail:
    message_id: int
    message_type: MailType
    cash_on_delivery: int
    unknown: int
    stationery: int
    money: int
    flags: int
    expiration_time: float
    mail_template_id: int
    subject: str
    message: str
    items: typing.List[MailListItem]
    sender: typing.Optional[int] = None
    sender_id: typing.Optional[int] = None
    auction_id: typing.Optional[int] = None
    item: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Mail:
        sender = None
        sender_id = None
        auction_id = None
        item = None
        # size: u16
        _size = await read_int(reader, 2)

        # message_id: u32
        message_id = await read_int(reader, 4)

        # message_type: MailType
        message_type = MailType(await read_int(reader, 1))

        if message_type == MailType.NORMAL:
            # sender: Guid
            sender = await read_int(reader, 8)

        elif message_type in {MailType.CREATURE, MailType.GAMEOBJECT}:
            # sender_id: u32
            sender_id = await read_int(reader, 4)

        elif message_type == MailType.AUCTION:
            # auction_id: u32
            auction_id = await read_int(reader, 4)

        elif message_type == MailType.ITEM:
            # item: Item
            item = await read_int(reader, 4)

        # cash_on_delivery: Gold
        cash_on_delivery = await read_int(reader, 4)

        # unknown: u32
        unknown = await read_int(reader, 4)

        # stationery: u32
        stationery = await read_int(reader, 4)

        # money: Gold
        money = await read_int(reader, 4)

        # flags: u32
        flags = await read_int(reader, 4)

        # expiration_time: f32
        expiration_time = await read_float(reader)

        # mail_template_id: u32
        mail_template_id = await read_int(reader, 4)

        # subject: CString
        subject = await read_cstring(reader)

        # message: CString
        message = await read_cstring(reader)

        # amount_of_items: u8
        amount_of_items = await read_int(reader, 1)

        # items: MailListItem[amount_of_items]
        items = []
        for _ in range(0, amount_of_items):
            items.append(await MailListItem.read(reader))

        return Mail(
            message_id=message_id,
            message_type=message_type,
            sender=sender,
            sender_id=sender_id,
            auction_id=auction_id,
            item=item,
            cash_on_delivery=cash_on_delivery,
            unknown=unknown,
            stationery=stationery,
            money=money,
            flags=flags,
            expiration_time=expiration_time,
            mail_template_id=mail_template_id,
            subject=subject,
            message=message,
            items=items,
        )

    def write(self, _fmt, _data):
        _fmt += 'HIB'
        _data.extend([self.size(), self.message_id, self.message_type.value])
        if self.message_type == MailType.NORMAL:
            _fmt += 'Q'
            _data.append(self.sender)
        elif self.message_type in {MailType.CREATURE, MailType.GAMEOBJECT}:
            _fmt += 'I'
            _data.append(self.sender_id)
        elif self.message_type == MailType.AUCTION:
            _fmt += 'I'
            _data.append(self.auction_id)
        elif self.message_type == MailType.ITEM:
            _fmt += 'I'
            _data.append(self.item)
        # cash_on_delivery: Gold
        _fmt += 'I'
        _data.append(self.cash_on_delivery)

        # unknown: u32
        _fmt += 'I'
        _data.append(self.unknown)

        # stationery: u32
        _fmt += 'I'
        _data.append(self.stationery)

        # money: Gold
        _fmt += 'I'
        _data.append(self.money)

        # flags: u32
        _fmt += 'I'
        _data.append(self.flags)

        # expiration_time: f32
        _fmt += 'f'
        _data.append(self.expiration_time)

        # mail_template_id: u32
        _fmt += 'I'
        _data.append(self.mail_template_id)

        # subject: CString
        _fmt += f'{len(self.subject)}sB'
        _data.extend([self.subject.encode('utf-8'), 0])

        # message: CString
        _fmt += f'{len(self.message)}sB'
        _data.extend([self.message.encode('utf-8'), 0])

        # amount_of_items: u8
        _fmt += 'B'
        _data.append(len(self.items))

        # items: MailListItem[amount_of_items]
        for i in self.items:
            _fmt, _data = i.write(_fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        _size = 38 + len(self.subject) + len(self.message) + 115 * len(self.items)

        if self.message_type == MailType.NORMAL:
            _size += 8
        elif self.message_type in {MailType.CREATURE, MailType.GAMEOBJECT}:
            _size += 4
        elif self.message_type == MailType.AUCTION:
            _size += 4
        elif self.message_type == MailType.ITEM:
            _size += 4

        return _size


@dataclasses.dataclass
class MailItem:
    item: int
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> MailItem:
        # item: Guid
        item = await read_int(reader, 8)

        # slot: u8
        slot = await read_int(reader, 1)

        return MailItem(
            item=item,
            slot=slot,
        )

    def write(self, _fmt, _data):
        _fmt += 'QB'
        _data.extend([self.item, self.slot])
        return _fmt, _data


@dataclasses.dataclass
class MiniMoveMessage:
    opcode: MiniMoveOpcode
    guid: int
    movement_counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> MiniMoveMessage:
        # size: u8
        _size = await read_int(reader, 1)

        # opcode: MiniMoveOpcode
        opcode = MiniMoveOpcode(await read_int(reader, 2))

        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        return MiniMoveMessage(
            opcode=opcode,
            guid=guid,
            movement_counter=movement_counter,
        )

    def write(self, _fmt, _data):
        _fmt += 'BH'
        _data.extend([self.size(), self.opcode.value])
        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # movement_counter: u32
        _fmt += 'I'
        _data.append(self.movement_counter)

        return _fmt, _data

    def size(self) -> int:
        return 7 + packed_guid_size(self.guid)


@dataclasses.dataclass
class MoneyLogItem:
    action: int
    player: int
    entry: int
    timestamp: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> MoneyLogItem:
        # action: u8
        action = await read_int(reader, 1)

        # player: Guid
        player = await read_int(reader, 8)

        # entry: u32
        entry = await read_int(reader, 4)

        # timestamp: u32
        timestamp = await read_int(reader, 4)

        return MoneyLogItem(
            action=action,
            player=player,
            entry=entry,
            timestamp=timestamp,
        )

    def write(self, _fmt, _data):
        _fmt += 'BQII'
        _data.extend([self.action, self.player, self.entry, self.timestamp])
        return _fmt, _data


@dataclasses.dataclass
class TransportInfo:
    guid: int
    position: Vector3d
    orientation: float
    timestamp: int
    seat: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> TransportInfo:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # position: Vector3d
        position = await Vector3d.read(reader)

        # orientation: f32
        orientation = await read_float(reader)

        # timestamp: u32
        timestamp = await read_int(reader, 4)

        # seat: u8
        seat = await read_int(reader, 1)

        return TransportInfo(
            guid=guid,
            position=position,
            orientation=orientation,
            timestamp=timestamp,
            seat=seat,
        )

    def write(self, _fmt, _data):
        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # orientation: f32
        _fmt += 'f'
        _data.append(self.orientation)

        # timestamp: u32
        _fmt += 'I'
        _data.append(self.timestamp)

        # seat: u8
        _fmt += 'B'
        _data.append(self.seat)

        return _fmt, _data

    def size(self) -> int:
        return 21 + packed_guid_size(self.guid)


@dataclasses.dataclass
class MovementBlock:
    update_flag: UpdateFlag
    flags: typing.Optional[MovementFlags] = None
    timestamp: typing.Optional[int] = None
    position: typing.Optional[Vector3d] = None
    orientation: typing.Optional[float] = None
    transport_info: typing.Optional[TransportInfo] = None
    transport_time: typing.Optional[int] = None
    transport: typing.Optional[TransportInfo] = None
    pitch1: typing.Optional[float] = None
    pitch2: typing.Optional[float] = None
    pitch3: typing.Optional[float] = None
    fall_time: typing.Optional[float] = None
    z_speed: typing.Optional[float] = None
    cos_angle: typing.Optional[float] = None
    sin_angle: typing.Optional[float] = None
    xy_speed: typing.Optional[float] = None
    spline_elevation: typing.Optional[float] = None
    walking_speed: typing.Optional[float] = None
    running_speed: typing.Optional[float] = None
    backwards_running_speed: typing.Optional[float] = None
    swimming_speed: typing.Optional[float] = None
    backwards_swimming_speed: typing.Optional[float] = None
    flight_speed: typing.Optional[float] = None
    backwards_flight_speed: typing.Optional[float] = None
    turn_rate: typing.Optional[float] = None
    pitch_rate: typing.Optional[float] = None
    spline_flags: typing.Optional[SplineFlag] = None
    angle: typing.Optional[float] = None
    target: typing.Optional[int] = None
    spline_final_point: typing.Optional[Vector3d] = None
    time_passed: typing.Optional[int] = None
    duration: typing.Optional[int] = None
    id: typing.Optional[int] = None
    nodes: typing.Optional[typing.List[Vector3d]] = None
    final_node: typing.Optional[Vector3d] = None
    transport_guid: typing.Optional[int] = None
    position1: typing.Optional[Vector3d] = None
    orientation1: typing.Optional[float] = None
    corpse_orientation: typing.Optional[float] = None
    position2: typing.Optional[Vector3d] = None
    orientation2: typing.Optional[float] = None
    unknown0: typing.Optional[int] = None
    unknown1: typing.Optional[int] = None
    guid: typing.Optional[int] = None
    transport_progress_in_ms: typing.Optional[int] = None
    vehicle_id: typing.Optional[int] = None
    vehicle_orientation: typing.Optional[float] = None
    packed_local_rotation: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> MovementBlock:
        flags = None
        timestamp = None
        position = None
        orientation = None
        transport_info = None
        transport_time = None
        transport = None
        pitch1 = None
        pitch2 = None
        pitch3 = None
        fall_time = None
        z_speed = None
        cos_angle = None
        sin_angle = None
        xy_speed = None
        spline_elevation = None
        walking_speed = None
        running_speed = None
        backwards_running_speed = None
        swimming_speed = None
        backwards_swimming_speed = None
        flight_speed = None
        backwards_flight_speed = None
        turn_rate = None
        pitch_rate = None
        spline_flags = None
        angle = None
        target = None
        spline_final_point = None
        time_passed = None
        duration = None
        id = None
        amount_of_nodes = None
        nodes = None
        final_node = None
        transport_guid = None
        position1 = None
        orientation1 = None
        corpse_orientation = None
        position2 = None
        orientation2 = None
        unknown0 = None
        unknown1 = None
        guid = None
        transport_progress_in_ms = None
        vehicle_id = None
        vehicle_orientation = None
        packed_local_rotation = None
        # update_flag: UpdateFlag
        update_flag = UpdateFlag(await read_int(reader, 2))

        if UpdateFlag.LIVING in update_flag:
            # flags: MovementFlags
            flags = MovementFlags(await read_int(reader, 6))

            # timestamp: u32
            timestamp = await read_int(reader, 4)

            # position: Vector3d
            position = await Vector3d.read(reader)

            # orientation: f32
            orientation = await read_float(reader)

            if MovementFlags.ON_TRANSPORT_AND_INTERPOLATED_MOVEMENT in flags:
                # transport_info: TransportInfo
                transport_info = await TransportInfo.read(reader)

                # transport_time: u32
                transport_time = await read_int(reader, 4)

            elif MovementFlags.ON_TRANSPORT in flags:
                # transport: TransportInfo
                transport = await TransportInfo.read(reader)

            if MovementFlags.SWIMMING in flags:
                # pitch1: f32
                pitch1 = await read_float(reader)

            elif MovementFlags.FLYING in flags:
                # pitch2: f32
                pitch2 = await read_float(reader)

            elif MovementFlags.ALWAYS_ALLOW_PITCHING in flags:
                # pitch3: f32
                pitch3 = await read_float(reader)

            # fall_time: f32
            fall_time = await read_float(reader)

            if MovementFlags.FALLING in flags:
                # z_speed: f32
                z_speed = await read_float(reader)

                # cos_angle: f32
                cos_angle = await read_float(reader)

                # sin_angle: f32
                sin_angle = await read_float(reader)

                # xy_speed: f32
                xy_speed = await read_float(reader)

            if MovementFlags.SPLINE_ELEVATION in flags:
                # spline_elevation: f32
                spline_elevation = await read_float(reader)

            # walking_speed: f32
            walking_speed = await read_float(reader)

            # running_speed: f32
            running_speed = await read_float(reader)

            # backwards_running_speed: f32
            backwards_running_speed = await read_float(reader)

            # swimming_speed: f32
            swimming_speed = await read_float(reader)

            # backwards_swimming_speed: f32
            backwards_swimming_speed = await read_float(reader)

            # flight_speed: f32
            flight_speed = await read_float(reader)

            # backwards_flight_speed: f32
            backwards_flight_speed = await read_float(reader)

            # turn_rate: f32
            turn_rate = await read_float(reader)

            # pitch_rate: f32
            pitch_rate = await read_float(reader)

            if MovementFlags.SPLINE_ENABLED in flags:
                # spline_flags: SplineFlag
                spline_flags = SplineFlag(await read_int(reader, 4))

                if SplineFlag.FINAL_ANGLE in spline_flags:
                    # angle: f32
                    angle = await read_float(reader)

                elif SplineFlag.FINAL_TARGET in spline_flags:
                    # target: u64
                    target = await read_int(reader, 8)

                elif SplineFlag.FINAL_POINT in spline_flags:
                    # spline_final_point: Vector3d
                    spline_final_point = await Vector3d.read(reader)

                # time_passed: u32
                time_passed = await read_int(reader, 4)

                # duration: u32
                duration = await read_int(reader, 4)

                # id: u32
                id = await read_int(reader, 4)

                # amount_of_nodes: u32
                amount_of_nodes = await read_int(reader, 4)

                # nodes: Vector3d[amount_of_nodes]
                nodes = []
                for _ in range(0, amount_of_nodes):
                    nodes.append(await Vector3d.read(reader))

                # final_node: Vector3d
                final_node = await Vector3d.read(reader)

        elif UpdateFlag.POSITION in update_flag:
            # transport_guid: PackedGuid
            transport_guid = await read_packed_guid(reader)

            # position1: Vector3d
            position1 = await Vector3d.read(reader)

            # orientation1: f32
            orientation1 = await read_float(reader)

            # corpse_orientation: f32
            corpse_orientation = await read_float(reader)

        elif UpdateFlag.HAS_POSITION in update_flag:
            # position2: Vector3d
            position2 = await Vector3d.read(reader)

            # orientation2: f32
            orientation2 = await read_float(reader)

        if UpdateFlag.HIGH_GUID in update_flag:
            # unknown0: u32
            unknown0 = await read_int(reader, 4)

        if UpdateFlag.LOW_GUID in update_flag:
            # unknown1: u32
            unknown1 = await read_int(reader, 4)

        if UpdateFlag.HAS_ATTACKING_TARGET in update_flag:
            # guid: PackedGuid
            guid = await read_packed_guid(reader)

        if UpdateFlag.TRANSPORT in update_flag:
            # transport_progress_in_ms: u32
            transport_progress_in_ms = await read_int(reader, 4)

        if UpdateFlag.VEHICLE in update_flag:
            # vehicle_id: u32
            vehicle_id = await read_int(reader, 4)

            # vehicle_orientation: f32
            vehicle_orientation = await read_float(reader)

        if UpdateFlag.ROTATION in update_flag:
            # packed_local_rotation: u64
            packed_local_rotation = await read_int(reader, 8)

        return MovementBlock(
            update_flag=update_flag,
            flags=flags,
            timestamp=timestamp,
            position=position,
            orientation=orientation,
            transport_info=transport_info,
            transport_time=transport_time,
            transport=transport,
            pitch1=pitch1,
            pitch2=pitch2,
            pitch3=pitch3,
            fall_time=fall_time,
            z_speed=z_speed,
            cos_angle=cos_angle,
            sin_angle=sin_angle,
            xy_speed=xy_speed,
            spline_elevation=spline_elevation,
            walking_speed=walking_speed,
            running_speed=running_speed,
            backwards_running_speed=backwards_running_speed,
            swimming_speed=swimming_speed,
            backwards_swimming_speed=backwards_swimming_speed,
            flight_speed=flight_speed,
            backwards_flight_speed=backwards_flight_speed,
            turn_rate=turn_rate,
            pitch_rate=pitch_rate,
            spline_flags=spline_flags,
            angle=angle,
            target=target,
            spline_final_point=spline_final_point,
            time_passed=time_passed,
            duration=duration,
            id=id,
            nodes=nodes,
            final_node=final_node,
            transport_guid=transport_guid,
            position1=position1,
            orientation1=orientation1,
            corpse_orientation=corpse_orientation,
            position2=position2,
            orientation2=orientation2,
            unknown0=unknown0,
            unknown1=unknown1,
            guid=guid,
            transport_progress_in_ms=transport_progress_in_ms,
            vehicle_id=vehicle_id,
            vehicle_orientation=vehicle_orientation,
            packed_local_rotation=packed_local_rotation,
        )

    def write(self, _fmt, _data):
        _fmt += 'H'
        _data.append(self.update_flag.value)
        if UpdateFlag.LIVING in self.update_flag:
            _fmt += 'IHI'
            _data.extend([self.flags.value & 0xFFFFFFFF, self.flags.value >> 32, self.timestamp])
            # position: Vector3d
            _fmt, _data = self.position.write(_fmt, _data)

            # orientation: f32
            _fmt += 'f'
            _data.append(self.orientation)

            if MovementFlags.ON_TRANSPORT_AND_INTERPOLATED_MOVEMENT in self.flags:
                # transport_info: TransportInfo
                _fmt, _data = self.transport_info.write(_fmt, _data)

                # transport_time: u32
                _fmt += 'I'
                _data.append(self.transport_time)

            elif MovementFlags.ON_TRANSPORT in self.flags:
                # transport: TransportInfo
                _fmt, _data = self.transport.write(_fmt, _data)

            if MovementFlags.SWIMMING in self.flags:
                _fmt += 'f'
                _data.append(self.pitch1)
            elif MovementFlags.FLYING in self.flags:
                _fmt += 'f'
                _data.append(self.pitch2)
            elif MovementFlags.ALWAYS_ALLOW_PITCHING in self.flags:
                _fmt += 'f'
                _data.append(self.pitch3)
            # fall_time: f32
            _fmt += 'f'
            _data.append(self.fall_time)

            if MovementFlags.FALLING in self.flags:
                _fmt += 'ffff'
                _data.extend([self.z_speed, self.cos_angle, self.sin_angle, self.xy_speed])
            if MovementFlags.SPLINE_ELEVATION in self.flags:
                _fmt += 'f'
                _data.append(self.spline_elevation)
            # walking_speed: f32
            _fmt += 'f'
            _data.append(self.walking_speed)

            # running_speed: f32
            _fmt += 'f'
            _data.append(self.running_speed)

            # backwards_running_speed: f32
            _fmt += 'f'
            _data.append(self.backwards_running_speed)

            # swimming_speed: f32
            _fmt += 'f'
            _data.append(self.swimming_speed)

            # backwards_swimming_speed: f32
            _fmt += 'f'
            _data.append(self.backwards_swimming_speed)

            # flight_speed: f32
            _fmt += 'f'
            _data.append(self.flight_speed)

            # backwards_flight_speed: f32
            _fmt += 'f'
            _data.append(self.backwards_flight_speed)

            # turn_rate: f32
            _fmt += 'f'
            _data.append(self.turn_rate)

            # pitch_rate: f32
            _fmt += 'f'
            _data.append(self.pitch_rate)

            if MovementFlags.SPLINE_ENABLED in self.flags:
                _fmt += 'I'
                _data.append(self.spline_flags.value)
                if SplineFlag.FINAL_ANGLE in self.spline_flags:
                    _fmt += 'f'
                    _data.append(self.angle)
                elif SplineFlag.FINAL_TARGET in self.spline_flags:
                    _fmt += 'Q'
                    _data.append(self.target)
                elif SplineFlag.FINAL_POINT in self.spline_flags:
                    # spline_final_point: Vector3d
                    _fmt, _data = self.spline_final_point.write(_fmt, _data)

                # time_passed: u32
                _fmt += 'I'
                _data.append(self.time_passed)

                # duration: u32
                _fmt += 'I'
                _data.append(self.duration)

                # id: u32
                _fmt += 'I'
                _data.append(self.id)

                # amount_of_nodes: u32
                _fmt += 'I'
                _data.append(len(self.nodes))

                # nodes: Vector3d[amount_of_nodes]
                for i in self.nodes:
                    _fmt, _data = i.write(_fmt, _data)

                # final_node: Vector3d
                _fmt, _data = self.final_node.write(_fmt, _data)

        elif UpdateFlag.POSITION in self.update_flag:
            # transport_guid: PackedGuid
            _fmt, _data = packed_guid_write(self.transport_guid, _fmt, _data)

            # position1: Vector3d
            _fmt, _data = self.position1.write(_fmt, _data)

            # orientation1: f32
            _fmt += 'f'
            _data.append(self.orientation1)

            # corpse_orientation: f32
            _fmt += 'f'
            _data.append(self.corpse_orientation)

        elif UpdateFlag.HAS_POSITION in self.update_flag:
            # position2: Vector3d
            _fmt, _data = self.position2.write(_fmt, _data)

            # orientation2: f32
            _fmt += 'f'
            _data.append(self.orientation2)

        if UpdateFlag.HIGH_GUID in self.update_flag:
            _fmt += 'I'
            _data.append(self.unknown0)
        if UpdateFlag.LOW_GUID in self.update_flag:
            _fmt += 'I'
            _data.append(self.unknown1)
        if UpdateFlag.HAS_ATTACKING_TARGET in self.update_flag:
            # guid: PackedGuid
            _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        if UpdateFlag.TRANSPORT in self.update_flag:
            _fmt += 'I'
            _data.append(self.transport_progress_in_ms)
        if UpdateFlag.VEHICLE in self.update_flag:
            _fmt += 'If'
            _data.extend([self.vehicle_id, self.vehicle_orientation])
        if UpdateFlag.ROTATION in self.update_flag:
            _fmt += 'Q'
            _data.append(self.packed_local_rotation)
        return _fmt, _data

    def size(self) -> int:
        _size = 2

        if UpdateFlag.LIVING in self.update_flag:
            _size += 66

            if MovementFlags.ON_TRANSPORT_AND_INTERPOLATED_MOVEMENT in self.flags:
                _size += 4 + self.transport_info.size()
            elif MovementFlags.ON_TRANSPORT in self.flags:
                _size += 0 + self.transport.size()

            if MovementFlags.SWIMMING in self.flags:
                _size += 4
            elif MovementFlags.FLYING in self.flags:
                _size += 4
            elif MovementFlags.ALWAYS_ALLOW_PITCHING in self.flags:
                _size += 4

            if MovementFlags.FALLING in self.flags:
                _size += 16

            if MovementFlags.SPLINE_ELEVATION in self.flags:
                _size += 4

            if MovementFlags.SPLINE_ENABLED in self.flags:
                _size += 32 + 12 * len(self.nodes)

                if SplineFlag.FINAL_ANGLE in self.spline_flags:
                    _size += 4
                elif SplineFlag.FINAL_TARGET in self.spline_flags:
                    _size += 8
                elif SplineFlag.FINAL_POINT in self.spline_flags:
                    _size += 12


        elif UpdateFlag.POSITION in self.update_flag:
            _size += 20 + packed_guid_size(self.transport_guid)
        elif UpdateFlag.HAS_POSITION in self.update_flag:
            _size += 16

        if UpdateFlag.HIGH_GUID in self.update_flag:
            _size += 4

        if UpdateFlag.LOW_GUID in self.update_flag:
            _size += 4

        if UpdateFlag.HAS_ATTACKING_TARGET in self.update_flag:
            _size += 0 + packed_guid_size(self.guid)

        if UpdateFlag.TRANSPORT in self.update_flag:
            _size += 4

        if UpdateFlag.VEHICLE in self.update_flag:
            _size += 8

        if UpdateFlag.ROTATION in self.update_flag:
            _size += 8

        return _size


@dataclasses.dataclass
class MovementInfo:
    flags: MovementFlags
    timestamp: int
    position: Vector3d
    orientation: float
    fall_time: float
    transport_info: typing.Optional[TransportInfo] = None
    transport_time: typing.Optional[int] = None
    transport: typing.Optional[TransportInfo] = None
    pitch1: typing.Optional[float] = None
    pitch2: typing.Optional[float] = None
    pitch3: typing.Optional[float] = None
    z_speed: typing.Optional[float] = None
    cos_angle: typing.Optional[float] = None
    sin_angle: typing.Optional[float] = None
    xy_speed: typing.Optional[float] = None
    spline_elevation: typing.Optional[float] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> MovementInfo:
        transport_info = None
        transport_time = None
        transport = None
        pitch1 = None
        pitch2 = None
        pitch3 = None
        z_speed = None
        cos_angle = None
        sin_angle = None
        xy_speed = None
        spline_elevation = None
        # flags: MovementFlags
        flags = MovementFlags(await read_int(reader, 6))

        # timestamp: u32
        timestamp = await read_int(reader, 4)

        # position: Vector3d
        position = await Vector3d.read(reader)

        # orientation: f32
        orientation = await read_float(reader)

        if MovementFlags.ON_TRANSPORT_AND_INTERPOLATED_MOVEMENT in flags:
            # transport_info: TransportInfo
            transport_info = await TransportInfo.read(reader)

            # transport_time: u32
            transport_time = await read_int(reader, 4)

        elif MovementFlags.ON_TRANSPORT in flags:
            # transport: TransportInfo
            transport = await TransportInfo.read(reader)

        if MovementFlags.SWIMMING in flags:
            # pitch1: f32
            pitch1 = await read_float(reader)

        elif MovementFlags.FLYING in flags:
            # pitch2: f32
            pitch2 = await read_float(reader)

        elif MovementFlags.ALWAYS_ALLOW_PITCHING in flags:
            # pitch3: f32
            pitch3 = await read_float(reader)

        # fall_time: f32
        fall_time = await read_float(reader)

        if MovementFlags.FALLING in flags:
            # z_speed: f32
            z_speed = await read_float(reader)

            # cos_angle: f32
            cos_angle = await read_float(reader)

            # sin_angle: f32
            sin_angle = await read_float(reader)

            # xy_speed: f32
            xy_speed = await read_float(reader)

        if MovementFlags.SPLINE_ELEVATION in flags:
            # spline_elevation: f32
            spline_elevation = await read_float(reader)

        return MovementInfo(
            flags=flags,
            timestamp=timestamp,
            position=position,
            orientation=orientation,
            transport_info=transport_info,
            transport_time=transport_time,
            transport=transport,
            pitch1=pitch1,
            pitch2=pitch2,
            pitch3=pitch3,
            fall_time=fall_time,
            z_speed=z_speed,
            cos_angle=cos_angle,
            sin_angle=sin_angle,
            xy_speed=xy_speed,
            spline_elevation=spline_elevation,
        )

    def write(self, _fmt, _data):
        _fmt += 'IHI'
        _data.extend([self.flags.value & 0xFFFFFFFF, self.flags.value >> 32, self.timestamp])
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # orientation: f32
        _fmt += 'f'
        _data.append(self.orientation)

        if MovementFlags.ON_TRANSPORT_AND_INTERPOLATED_MOVEMENT in self.flags:
            # transport_info: TransportInfo
            _fmt, _data = self.transport_info.write(_fmt, _data)

            # transport_time: u32
            _fmt += 'I'
            _data.append(self.transport_time)

        elif MovementFlags.ON_TRANSPORT in self.flags:
            # transport: TransportInfo
            _fmt, _data = self.transport.write(_fmt, _data)

        if MovementFlags.SWIMMING in self.flags:
            _fmt += 'f'
            _data.append(self.pitch1)
        elif MovementFlags.FLYING in self.flags:
            _fmt += 'f'
            _data.append(self.pitch2)
        elif MovementFlags.ALWAYS_ALLOW_PITCHING in self.flags:
            _fmt += 'f'
            _data.append(self.pitch3)
        # fall_time: f32
        _fmt += 'f'
        _data.append(self.fall_time)

        if MovementFlags.FALLING in self.flags:
            _fmt += 'ffff'
            _data.extend([self.z_speed, self.cos_angle, self.sin_angle, self.xy_speed])
        if MovementFlags.SPLINE_ELEVATION in self.flags:
            _fmt += 'f'
            _data.append(self.spline_elevation)
        return _fmt, _data

    def size(self) -> int:
        _size = 30

        if MovementFlags.ON_TRANSPORT_AND_INTERPOLATED_MOVEMENT in self.flags:
            _size += 4 + self.transport_info.size()
        elif MovementFlags.ON_TRANSPORT in self.flags:
            _size += 0 + self.transport.size()

        if MovementFlags.SWIMMING in self.flags:
            _size += 4
        elif MovementFlags.FLYING in self.flags:
            _size += 4
        elif MovementFlags.ALWAYS_ALLOW_PITCHING in self.flags:
            _size += 4

        if MovementFlags.FALLING in self.flags:
            _size += 16

        if MovementFlags.SPLINE_ELEVATION in self.flags:
            _size += 4

        return _size


@dataclasses.dataclass
class NpcTextUpdateEmote:
    delay: int
    emote: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> NpcTextUpdateEmote:
        # delay: u32
        delay = await read_int(reader, 4)

        # emote: u32
        emote = await read_int(reader, 4)

        return NpcTextUpdateEmote(
            delay=delay,
            emote=emote,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.delay, self.emote])
        return _fmt, _data


@dataclasses.dataclass
class NpcTextUpdate:
    probability: float
    texts: typing.List[str]
    language: Language
    emotes: typing.List[NpcTextUpdateEmote]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> NpcTextUpdate:
        # probability: f32
        probability = await read_float(reader)

        # texts: CString[2]
        texts = []
        for _ in range(0, 2):
            texts.append(await read_cstring(reader))

        # language: Language
        language = Language(await read_int(reader, 1))

        # emotes: NpcTextUpdateEmote[3]
        emotes = []
        for _ in range(0, 3):
            emotes.append(await NpcTextUpdateEmote.read(reader))

        return NpcTextUpdate(
            probability=probability,
            texts=texts,
            language=language,
            emotes=emotes,
        )

    def write(self, _fmt, _data):
        _fmt += 'f'
        _data.append(self.probability)
        # texts: CString[2]
        for i in self.texts:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        # language: Language
        _fmt += 'B'
        _data.append(self.language.value)

        # emotes: NpcTextUpdateEmote[3]
        for i in self.emotes:
            _fmt, _data = i.write(_fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        return 29 + sum([len(i) + 1 for i in self.texts])


@dataclasses.dataclass
class Object:
    update_type: UpdateType
    guid1: typing.Optional[int] = None
    mask1: typing.Optional[UpdateMask] = None
    guid2: typing.Optional[int] = None
    movement1: typing.Optional[MovementBlock] = None
    guid3: typing.Optional[int] = None
    object_type: typing.Optional[ObjectType] = None
    movement2: typing.Optional[MovementBlock] = None
    mask2: typing.Optional[UpdateMask] = None
    guids: typing.Optional[typing.List[int]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Object:
        guid1 = None
        mask1 = None
        guid2 = None
        movement1 = None
        guid3 = None
        object_type = None
        movement2 = None
        mask2 = None
        count = None
        guids = None
        # update_type: UpdateType
        update_type = UpdateType(await read_int(reader, 1))

        if update_type == UpdateType.VALUES:
            # guid1: PackedGuid
            guid1 = await read_packed_guid(reader)

            # mask1: UpdateMask
            mask1 = await UpdateMask.read(reader)

        elif update_type == UpdateType.MOVEMENT:
            # guid2: PackedGuid
            guid2 = await read_packed_guid(reader)

            # movement1: MovementBlock
            movement1 = await MovementBlock.read(reader)

        elif update_type in {UpdateType.CREATE_OBJECT, UpdateType.CREATE_OBJECT2}:
            # guid3: PackedGuid
            guid3 = await read_packed_guid(reader)

            # object_type: ObjectType
            object_type = ObjectType(await read_int(reader, 1))

            # movement2: MovementBlock
            movement2 = await MovementBlock.read(reader)

            # mask2: UpdateMask
            mask2 = await UpdateMask.read(reader)

        elif update_type in {UpdateType.OUT_OF_RANGE_OBJECTS, UpdateType.NEAR_OBJECTS}:
            # count: u32
            count = await read_int(reader, 4)

            # guids: PackedGuid[count]
            guids = []
            for _ in range(0, count):
                guids.append(await read_packed_guid(reader))

        return Object(
            update_type=update_type,
            guid1=guid1,
            mask1=mask1,
            guid2=guid2,
            movement1=movement1,
            guid3=guid3,
            object_type=object_type,
            movement2=movement2,
            mask2=mask2,
            guids=guids,
        )

    def write(self, _fmt, _data):
        _fmt += 'B'
        _data.append(self.update_type.value)
        if self.update_type == UpdateType.VALUES:
            # guid1: PackedGuid
            _fmt, _data = packed_guid_write(self.guid1, _fmt, _data)

            # mask1: UpdateMask
            _fmt, _data = self.mask1.write(_fmt, _data)

        elif self.update_type == UpdateType.MOVEMENT:
            # guid2: PackedGuid
            _fmt, _data = packed_guid_write(self.guid2, _fmt, _data)

            # movement1: MovementBlock
            _fmt, _data = self.movement1.write(_fmt, _data)

        elif self.update_type in {UpdateType.CREATE_OBJECT, UpdateType.CREATE_OBJECT2}:
            # guid3: PackedGuid
            _fmt, _data = packed_guid_write(self.guid3, _fmt, _data)

            # object_type: ObjectType
            _fmt += 'B'
            _data.append(self.object_type.value)

            # movement2: MovementBlock
            _fmt, _data = self.movement2.write(_fmt, _data)

            # mask2: UpdateMask
            _fmt, _data = self.mask2.write(_fmt, _data)

        elif self.update_type in {UpdateType.OUT_OF_RANGE_OBJECTS, UpdateType.NEAR_OBJECTS}:
            _fmt += 'I'
            _data.append(len(self.guids))
            # guids: PackedGuid[count]
            for i in self.guids:
                _fmt, _data = packed_guid_write(i, _fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        _size = 1

        if self.update_type == UpdateType.VALUES:
            _size += 0 + packed_guid_size(self.guid1) + self.mask1.size()
        elif self.update_type == UpdateType.MOVEMENT:
            _size += 0 + packed_guid_size(self.guid2) + self.movement1.size()
        elif self.update_type in {UpdateType.CREATE_OBJECT, UpdateType.CREATE_OBJECT2}:
            _size += 1 + packed_guid_size(self.guid3) + self.movement2.size() + self.mask2.size()
        elif self.update_type in {UpdateType.OUT_OF_RANGE_OBJECTS, UpdateType.NEAR_OBJECTS}:
            _size += 4 + sum([packed_guid_size(i) for i in self.guids])

        return _size


@dataclasses.dataclass
class PendingAuctionSale:
    string1: str
    string2: str
    unknown1: int
    unknown2: int
    time_left: float

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> PendingAuctionSale:
        # string1: CString
        string1 = await read_cstring(reader)

        # string2: CString
        string2 = await read_cstring(reader)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # unknown2: u32
        unknown2 = await read_int(reader, 4)

        # time_left: f32
        time_left = await read_float(reader)

        return PendingAuctionSale(
            string1=string1,
            string2=string2,
            unknown1=unknown1,
            unknown2=unknown2,
            time_left=time_left,
        )

    def write(self, _fmt, _data):
        _fmt += f'{len(self.string1)}sB{len(self.string2)}sBIIf'
        _data.extend([self.string1.encode('utf-8'), 0, self.string2.encode('utf-8'), 0, self.unknown1, self.unknown2, self.time_left])
        return _fmt, _data

    def size(self) -> int:
        return 14 + len(self.string1) + len(self.string2)


@dataclasses.dataclass
class PetSpellCooldown:
    spell: int
    spell_category: int
    cooldown: int
    category_cooldown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> PetSpellCooldown:
        # spell: Spell
        spell = await read_int(reader, 4)

        # spell_category: u16
        spell_category = await read_int(reader, 2)

        # cooldown: Milliseconds
        cooldown = await read_int(reader, 4)

        # category_cooldown: Milliseconds
        category_cooldown = await read_int(reader, 4)

        return PetSpellCooldown(
            spell=spell,
            spell_category=spell_category,
            cooldown=cooldown,
            category_cooldown=category_cooldown,
        )

    def write(self, _fmt, _data):
        _fmt += 'IHII'
        _data.extend([self.spell, self.spell_category, self.cooldown, self.category_cooldown])
        return _fmt, _data


@dataclasses.dataclass
class PetitionShowlist:
    index: int
    charter_entry: int
    charter_display_id: int
    guild_charter_cost: int
    unknown1: int
    signatures_required: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> PetitionShowlist:
        # index: u32
        index = await read_int(reader, 4)

        # charter_entry: u32
        charter_entry = await read_int(reader, 4)

        # charter_display_id: u32
        charter_display_id = await read_int(reader, 4)

        # guild_charter_cost: u32
        guild_charter_cost = await read_int(reader, 4)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # signatures_required: u32
        signatures_required = await read_int(reader, 4)

        return PetitionShowlist(
            index=index,
            charter_entry=charter_entry,
            charter_display_id=charter_display_id,
            guild_charter_cost=guild_charter_cost,
            unknown1=unknown1,
            signatures_required=signatures_required,
        )

    def write(self, _fmt, _data):
        _fmt += 'IIIIII'
        _data.extend([self.index, self.charter_entry, self.charter_display_id, self.guild_charter_cost, self.unknown1, self.signatures_required])
        return _fmt, _data


@dataclasses.dataclass
class PetitionSignature:
    signer: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> PetitionSignature:
        # signer: Guid
        signer = await read_int(reader, 8)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return PetitionSignature(
            signer=signer,
            unknown1=unknown1,
        )

    def write(self, _fmt, _data):
        _fmt += 'QI'
        _data.extend([self.signer, self.unknown1])
        return _fmt, _data


@dataclasses.dataclass
class PreviewTalent:
    talent: Talent
    rank: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> PreviewTalent:
        # talent: Talent
        talent = Talent(await read_int(reader, 4))

        # rank: u32
        rank = await read_int(reader, 4)

        return PreviewTalent(
            talent=talent,
            rank=rank,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.talent.value, self.rank])
        return _fmt, _data


@dataclasses.dataclass
class QuestDetailsEmote:
    emote: int
    emote_delay: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> QuestDetailsEmote:
        # emote: u32
        emote = await read_int(reader, 4)

        # emote_delay: Milliseconds
        emote_delay = await read_int(reader, 4)

        return QuestDetailsEmote(
            emote=emote,
            emote_delay=emote_delay,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.emote, self.emote_delay])
        return _fmt, _data


@dataclasses.dataclass
class QuestGiverReward:
    item: int
    item_count: int
    display_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> QuestGiverReward:
        # item: Item
        item = await read_int(reader, 4)

        # item_count: u32
        item_count = await read_int(reader, 4)

        # display_id: u32
        display_id = await read_int(reader, 4)

        return QuestGiverReward(
            item=item,
            item_count=item_count,
            display_id=display_id,
        )

    def write(self, _fmt, _data):
        _fmt += 'III'
        _data.extend([self.item, self.item_count, self.display_id])
        return _fmt, _data


@dataclasses.dataclass
class QuestGiverStatusReport:
    npc: int
    dialog_status: QuestGiverStatus

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> QuestGiverStatusReport:
        # npc: Guid
        npc = await read_int(reader, 8)

        # dialog_status: QuestGiverStatus
        dialog_status = QuestGiverStatus(await read_int(reader, 1))

        return QuestGiverStatusReport(
            npc=npc,
            dialog_status=dialog_status,
        )

    def write(self, _fmt, _data):
        _fmt += 'QB'
        _data.extend([self.npc, self.dialog_status.value])
        return _fmt, _data


@dataclasses.dataclass
class QuestItem:
    quest_id: int
    quest_icon: int
    level: int
    flags: int
    repeatable: bool
    title: str

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> QuestItem:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # quest_icon: u32
        quest_icon = await read_int(reader, 4)

        # level: Level32
        level = await read_int(reader, 4)

        # flags: u32
        flags = await read_int(reader, 4)

        # repeatable: Bool8
        repeatable = await read_bool(reader, 1)

        # title: CString
        title = await read_cstring(reader)

        return QuestItem(
            quest_id=quest_id,
            quest_icon=quest_icon,
            level=level,
            flags=flags,
            repeatable=repeatable,
            title=title,
        )

    def write(self, _fmt, _data):
        _fmt += f'IIIIB{len(self.title)}sB'
        _data.extend([self.quest_id, self.quest_icon, self.level, self.flags, self.repeatable, self.title.encode('utf-8'), 0])
        return _fmt, _data

    def size(self) -> int:
        return 18 + len(self.title)


@dataclasses.dataclass
class QuestItemRequirement:
    item: int
    item_count: int
    item_display_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> QuestItemRequirement:
        # item: Item
        item = await read_int(reader, 4)

        # item_count: u32
        item_count = await read_int(reader, 4)

        # item_display_id: u32
        item_display_id = await read_int(reader, 4)

        return QuestItemRequirement(
            item=item,
            item_count=item_count,
            item_display_id=item_display_id,
        )

    def write(self, _fmt, _data):
        _fmt += 'III'
        _data.extend([self.item, self.item_count, self.item_display_id])
        return _fmt, _data


@dataclasses.dataclass
class QuestItemReward:
    item: int
    item_count: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> QuestItemReward:
        # item: Item
        item = await read_int(reader, 4)

        # item_count: u32
        item_count = await read_int(reader, 4)

        return QuestItemReward(
            item=item,
            item_count=item_count,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.item, self.item_count])
        return _fmt, _data


@dataclasses.dataclass
class QuestObjective:
    creature_id: int
    kill_count: int
    required_item_id: int
    required_item_count: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> QuestObjective:
        # creature_id: u32
        creature_id = await read_int(reader, 4)

        # kill_count: u32
        kill_count = await read_int(reader, 4)

        # required_item_id: u32
        required_item_id = await read_int(reader, 4)

        # required_item_count: u32
        required_item_count = await read_int(reader, 4)

        return QuestObjective(
            creature_id=creature_id,
            kill_count=kill_count,
            required_item_id=required_item_id,
            required_item_count=required_item_count,
        )

    def write(self, _fmt, _data):
        _fmt += 'IIII'
        _data.extend([self.creature_id, self.kill_count, self.required_item_id, self.required_item_count])
        return _fmt, _data


@dataclasses.dataclass
class Vector2dUnsigned:
    x: int
    y: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Vector2dUnsigned:
        # x: u32
        x = await read_int(reader, 4)

        # y: u32
        y = await read_int(reader, 4)

        return Vector2dUnsigned(
            x=x,
            y=y,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.x, self.y])
        return _fmt, _data


@dataclasses.dataclass
class QuestPoi:
    id: int
    objective_id: int
    map: Map
    area: Area
    floor_id: int
    unknown1: int
    unknown2: int
    points: typing.List[Vector2dUnsigned]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> QuestPoi:
        # id: u32
        id = await read_int(reader, 4)

        # objective_id: u32
        objective_id = await read_int(reader, 4)

        # map: Map
        map = Map(await read_int(reader, 4))

        # area: Area
        area = Area(await read_int(reader, 4))

        # floor_id: u32
        floor_id = await read_int(reader, 4)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # unknown2: u32
        unknown2 = await read_int(reader, 4)

        # amount_of_points: u32
        amount_of_points = await read_int(reader, 4)

        # points: Vector2dUnsigned[amount_of_points]
        points = []
        for _ in range(0, amount_of_points):
            points.append(await Vector2dUnsigned.read(reader))

        return QuestPoi(
            id=id,
            objective_id=objective_id,
            map=map,
            area=area,
            floor_id=floor_id,
            unknown1=unknown1,
            unknown2=unknown2,
            points=points,
        )

    def write(self, _fmt, _data):
        _fmt += 'IIIIIIII'
        _data.extend([self.id, self.objective_id, self.map.value, self.area.value, self.floor_id, self.unknown1, self.unknown2, len(self.points)])
        # points: Vector2dUnsigned[amount_of_points]
        for i in self.points:
            _fmt, _data = i.write(_fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        return 32 + 8 * len(self.points)


@dataclasses.dataclass
class QuestPoiList:
    quest_id: int
    amount_of_pois: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> QuestPoiList:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # amount_of_pois: u32
        amount_of_pois = await read_int(reader, 4)

        return QuestPoiList(
            quest_id=quest_id,
            amount_of_pois=amount_of_pois,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.quest_id, self.amount_of_pois])
        return _fmt, _data


@dataclasses.dataclass
class RaidInfo:
    map: Map
    difficulty: DungeonDifficulty
    instance_id: int
    expired: bool
    extended: bool
    time_until_reset: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> RaidInfo:
        # map: Map
        map = Map(await read_int(reader, 4))

        # difficulty: DungeonDifficulty
        difficulty = DungeonDifficulty(await read_int(reader, 4))

        # instance_id: u64
        instance_id = await read_int(reader, 8)

        # expired: Bool8
        expired = await read_bool(reader, 1)

        # extended: Bool8
        extended = await read_bool(reader, 1)

        # time_until_reset: u32
        time_until_reset = await read_int(reader, 4)

        return RaidInfo(
            map=map,
            difficulty=difficulty,
            instance_id=instance_id,
            expired=expired,
            extended=extended,
            time_until_reset=time_until_reset,
        )

    def write(self, _fmt, _data):
        _fmt += 'IIQBBI'
        _data.extend([self.map.value, self.difficulty.value, self.instance_id, self.expired, self.extended, self.time_until_reset])
        return _fmt, _data


@dataclasses.dataclass
class RaidTargetUpdate:
    index: RaidTargetIndex
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> RaidTargetUpdate:
        # index: RaidTargetIndex
        index = RaidTargetIndex(await read_int(reader, 1))

        # guid: Guid
        guid = await read_int(reader, 8)

        return RaidTargetUpdate(
            index=index,
            guid=guid,
        )

    def write(self, _fmt, _data):
        _fmt += 'BQ'
        _data.extend([self.index.value, self.guid])
        return _fmt, _data


@dataclasses.dataclass
class ReceivedMail:
    sender: int
    auction_house: AuctionHouse
    message_type: MailMessageType
    stationery: int
    time: float

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ReceivedMail:
        # sender: Guid
        sender = await read_int(reader, 8)

        # auction_house: AuctionHouse
        auction_house = AuctionHouse(await read_int(reader, 4))

        # message_type: MailMessageType
        message_type = MailMessageType(await read_int(reader, 4))

        # stationery: u32
        stationery = await read_int(reader, 4)

        # time: f32
        time = await read_float(reader)

        return ReceivedMail(
            sender=sender,
            auction_house=auction_house,
            message_type=message_type,
            stationery=stationery,
            time=time,
        )

    def write(self, _fmt, _data):
        _fmt += 'QIIIf'
        _data.extend([self.sender, self.auction_house.value, self.message_type.value, self.stationery, self.time])
        return _fmt, _data


@dataclasses.dataclass
class Relation:
    guid: int
    relation_mask: RelationType
    note: str
    status: typing.Optional[FriendStatus] = None
    area: typing.Optional[Area] = None
    level: typing.Optional[int] = None
    class_type: typing.Optional[Class] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Relation:
        status = None
        area = None
        level = None
        class_type = None
        # guid: Guid
        guid = await read_int(reader, 8)

        # relation_mask: RelationType
        relation_mask = RelationType(await read_int(reader, 4))

        # note: CString
        note = await read_cstring(reader)

        if RelationType.FRIEND in relation_mask:
            # status: FriendStatus
            status = FriendStatus(await read_int(reader, 1))

            if status == FriendStatus.ONLINE:
                # area: Area
                area = Area(await read_int(reader, 4))

                # level: Level32
                level = await read_int(reader, 4)

                # class_type: Class
                class_type = Class(await read_int(reader, 4))

        return Relation(
            guid=guid,
            relation_mask=relation_mask,
            note=note,
            status=status,
            area=area,
            level=level,
            class_type=class_type,
        )

    def write(self, _fmt, _data):
        _fmt += f'QI{len(self.note)}sB'
        _data.extend([self.guid, self.relation_mask.value, self.note.encode('utf-8'), 0])
        if RelationType.FRIEND in self.relation_mask:
            _fmt += 'B'
            _data.append(self.status.value)
            if self.status == FriendStatus.ONLINE:
                _fmt += 'III'
                _data.extend([self.area.value, self.level, self.class_type.value])
        return _fmt, _data

    def size(self) -> int:
        _size = 13 + len(self.note)

        if RelationType.FRIEND in self.relation_mask:
            _size += 1

            if self.status == FriendStatus.ONLINE:
                _size += 12


        return _size


@dataclasses.dataclass
class ResyncRune:
    current_rune: int
    rune_cooldown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ResyncRune:
        # current_rune: u8
        current_rune = await read_int(reader, 1)

        # rune_cooldown: u8
        rune_cooldown = await read_int(reader, 1)

        return ResyncRune(
            current_rune=current_rune,
            rune_cooldown=rune_cooldown,
        )

    def write(self, _fmt, _data):
        _fmt += 'BB'
        _data.extend([self.current_rune, self.rune_cooldown])
        return _fmt, _data


@dataclasses.dataclass
class SendCalendarEvent:
    event_id: int
    title: str
    event_type: int
    event_time: int
    flags: int
    dungeon_id: int
    creator: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SendCalendarEvent:
        # event_id: Guid
        event_id = await read_int(reader, 8)

        # title: CString
        title = await read_cstring(reader)

        # event_type: u32
        event_type = await read_int(reader, 4)

        # event_time: DateTime
        event_time = await read_int(reader, 4)

        # flags: u32
        flags = await read_int(reader, 4)

        # dungeon_id: u32
        dungeon_id = await read_int(reader, 4)

        # creator: PackedGuid
        creator = await read_packed_guid(reader)

        return SendCalendarEvent(
            event_id=event_id,
            title=title,
            event_type=event_type,
            event_time=event_time,
            flags=flags,
            dungeon_id=dungeon_id,
            creator=creator,
        )

    def write(self, _fmt, _data):
        _fmt += f'Q{len(self.title)}sBIIII'
        _data.extend([self.event_id, self.title.encode('utf-8'), 0, self.event_type, self.event_time, self.flags, self.dungeon_id])
        # creator: PackedGuid
        _fmt, _data = packed_guid_write(self.creator, _fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        return 25 + len(self.title) + packed_guid_size(self.creator)


@dataclasses.dataclass
class SendCalendarHoliday:
    holiday_id: int
    region: int
    looping: int
    priority: int
    calendar_filter_type: int
    holiday_days: typing.List[int]
    durations: typing.List[int]
    flags: typing.List[int]
    texture_file_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SendCalendarHoliday:
        # holiday_id: u32
        holiday_id = await read_int(reader, 4)

        # region: u32
        region = await read_int(reader, 4)

        # looping: u32
        looping = await read_int(reader, 4)

        # priority: u32
        priority = await read_int(reader, 4)

        # calendar_filter_type: u32
        calendar_filter_type = await read_int(reader, 4)

        # holiday_days: u32[26]
        holiday_days = []
        for _ in range(0, 26):
            holiday_days.append(await read_int(reader, 4))

        # durations: u32[10]
        durations = []
        for _ in range(0, 10):
            durations.append(await read_int(reader, 4))

        # flags: u32[10]
        flags = []
        for _ in range(0, 10):
            flags.append(await read_int(reader, 4))

        # texture_file_name: CString
        texture_file_name = await read_cstring(reader)

        return SendCalendarHoliday(
            holiday_id=holiday_id,
            region=region,
            looping=looping,
            priority=priority,
            calendar_filter_type=calendar_filter_type,
            holiday_days=holiday_days,
            durations=durations,
            flags=flags,
            texture_file_name=texture_file_name,
        )

    def write(self, _fmt, _data):
        _fmt += f'IIIII{len(self.holiday_days)}I{len(self.durations)}I{len(self.flags)}I{len(self.texture_file_name)}sB'
        _data.extend([self.holiday_id, self.region, self.looping, self.priority, self.calendar_filter_type, *self.holiday_days, *self.durations, *self.flags, self.texture_file_name.encode('utf-8'), 0])
        return _fmt, _data

    def size(self) -> int:
        return 205 + len(self.texture_file_name)


@dataclasses.dataclass
class SendCalendarInstance:
    map: Map
    difficulty: int
    reset_time: int
    instance_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SendCalendarInstance:
        # map: Map
        map = Map(await read_int(reader, 4))

        # difficulty: u32
        difficulty = await read_int(reader, 4)

        # reset_time: u32
        reset_time = await read_int(reader, 4)

        # instance_id: Guid
        instance_id = await read_int(reader, 8)

        return SendCalendarInstance(
            map=map,
            difficulty=difficulty,
            reset_time=reset_time,
            instance_id=instance_id,
        )

    def write(self, _fmt, _data):
        _fmt += 'IIIQ'
        _data.extend([self.map.value, self.difficulty, self.reset_time, self.instance_id])
        return _fmt, _data


@dataclasses.dataclass
class SendCalendarInvite:
    event_id: int
    invite_id: int
    status: int
    rank: int
    is_guild_event: bool
    creator: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SendCalendarInvite:
        # event_id: Guid
        event_id = await read_int(reader, 8)

        # invite_id: Guid
        invite_id = await read_int(reader, 8)

        # status: u8
        status = await read_int(reader, 1)

        # rank: u8
        rank = await read_int(reader, 1)

        # is_guild_event: Bool8
        is_guild_event = await read_bool(reader, 1)

        # creator: PackedGuid
        creator = await read_packed_guid(reader)

        return SendCalendarInvite(
            event_id=event_id,
            invite_id=invite_id,
            status=status,
            rank=rank,
            is_guild_event=is_guild_event,
            creator=creator,
        )

    def write(self, _fmt, _data):
        _fmt += 'QQBBB'
        _data.extend([self.event_id, self.invite_id, self.status, self.rank, self.is_guild_event])
        # creator: PackedGuid
        _fmt, _data = packed_guid_write(self.creator, _fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        return 19 + packed_guid_size(self.creator)


@dataclasses.dataclass
class SendCalendarResetTime:
    map: Map
    period: int
    time_offset: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SendCalendarResetTime:
        # map: Map
        map = Map(await read_int(reader, 4))

        # period: u32
        period = await read_int(reader, 4)

        # time_offset: u32
        time_offset = await read_int(reader, 4)

        return SendCalendarResetTime(
            map=map,
            period=period,
            time_offset=time_offset,
        )

    def write(self, _fmt, _data):
        _fmt += 'III'
        _data.extend([self.map.value, self.period, self.time_offset])
        return _fmt, _data


@dataclasses.dataclass
class SpellCastTargets:
    target_flags: SpellCastTargetFlags
    unit_target: typing.Optional[int] = None
    minipet_target: typing.Optional[int] = None
    gameobject_target: typing.Optional[int] = None
    enemy_corpse_target: typing.Optional[int] = None
    ally_corpse_target: typing.Optional[int] = None
    item_target: typing.Optional[int] = None
    trade_item_target: typing.Optional[int] = None
    source: typing.Optional[Vector3d] = None
    destination: typing.Optional[Vector3d] = None
    target_string: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SpellCastTargets:
        unit_target = None
        minipet_target = None
        gameobject_target = None
        enemy_corpse_target = None
        ally_corpse_target = None
        item_target = None
        trade_item_target = None
        source = None
        destination = None
        target_string = None
        # target_flags: SpellCastTargetFlags
        target_flags = SpellCastTargetFlags(await read_int(reader, 4))

        if SpellCastTargetFlags.UNIT in target_flags:
            # unit_target: PackedGuid
            unit_target = await read_packed_guid(reader)

        elif SpellCastTargetFlags.UNIT_MINIPET in target_flags:
            # minipet_target: PackedGuid
            minipet_target = await read_packed_guid(reader)

        elif SpellCastTargetFlags.GAMEOBJECT in target_flags:
            # gameobject_target: PackedGuid
            gameobject_target = await read_packed_guid(reader)

        elif SpellCastTargetFlags.CORPSE_ENEMY in target_flags:
            # enemy_corpse_target: PackedGuid
            enemy_corpse_target = await read_packed_guid(reader)

        elif SpellCastTargetFlags.CORPSE_ALLY in target_flags:
            # ally_corpse_target: PackedGuid
            ally_corpse_target = await read_packed_guid(reader)

        if SpellCastTargetFlags.ITEM in target_flags:
            # item_target: PackedGuid
            item_target = await read_packed_guid(reader)

        elif SpellCastTargetFlags.TRADE_ITEM in target_flags:
            # trade_item_target: PackedGuid
            trade_item_target = await read_packed_guid(reader)

        if SpellCastTargetFlags.SOURCE_LOCATION in target_flags:
            # source: Vector3d
            source = await Vector3d.read(reader)

        if SpellCastTargetFlags.DEST_LOCATION in target_flags:
            # destination: Vector3d
            destination = await Vector3d.read(reader)

        if SpellCastTargetFlags.STRING in target_flags:
            # target_string: CString
            target_string = await read_cstring(reader)

        return SpellCastTargets(
            target_flags=target_flags,
            unit_target=unit_target,
            minipet_target=minipet_target,
            gameobject_target=gameobject_target,
            enemy_corpse_target=enemy_corpse_target,
            ally_corpse_target=ally_corpse_target,
            item_target=item_target,
            trade_item_target=trade_item_target,
            source=source,
            destination=destination,
            target_string=target_string,
        )

    def write(self, _fmt, _data):
        _fmt += 'I'
        _data.append(self.target_flags.value)
        if SpellCastTargetFlags.UNIT in self.target_flags:
            # unit_target: PackedGuid
            _fmt, _data = packed_guid_write(self.unit_target, _fmt, _data)

        elif SpellCastTargetFlags.UNIT_MINIPET in self.target_flags:
            # minipet_target: PackedGuid
            _fmt, _data = packed_guid_write(self.minipet_target, _fmt, _data)

        elif SpellCastTargetFlags.GAMEOBJECT in self.target_flags:
            # gameobject_target: PackedGuid
            _fmt, _data = packed_guid_write(self.gameobject_target, _fmt, _data)

        elif SpellCastTargetFlags.CORPSE_ENEMY in self.target_flags:
            # enemy_corpse_target: PackedGuid
            _fmt, _data = packed_guid_write(self.enemy_corpse_target, _fmt, _data)

        elif SpellCastTargetFlags.CORPSE_ALLY in self.target_flags:
            # ally_corpse_target: PackedGuid
            _fmt, _data = packed_guid_write(self.ally_corpse_target, _fmt, _data)

        if SpellCastTargetFlags.ITEM in self.target_flags:
            # item_target: PackedGuid
            _fmt, _data = packed_guid_write(self.item_target, _fmt, _data)

        elif SpellCastTargetFlags.TRADE_ITEM in self.target_flags:
            # trade_item_target: PackedGuid
            _fmt, _data = packed_guid_write(self.trade_item_target, _fmt, _data)

        if SpellCastTargetFlags.SOURCE_LOCATION in self.target_flags:
            # source: Vector3d
            _fmt, _data = self.source.write(_fmt, _data)

        if SpellCastTargetFlags.DEST_LOCATION in self.target_flags:
            # destination: Vector3d
            _fmt, _data = self.destination.write(_fmt, _data)

        if SpellCastTargetFlags.STRING in self.target_flags:
            _fmt += f'{len(self.target_string)}sB'
            _data.extend([self.target_string.encode('utf-8'), 0])
        return _fmt, _data

    def size(self) -> int:
        _size = 4

        if SpellCastTargetFlags.UNIT in self.target_flags:
            _size += 0 + packed_guid_size(self.unit_target)
        elif SpellCastTargetFlags.UNIT_MINIPET in self.target_flags:
            _size += 0 + packed_guid_size(self.minipet_target)
        elif SpellCastTargetFlags.GAMEOBJECT in self.target_flags:
            _size += 0 + packed_guid_size(self.gameobject_target)
        elif SpellCastTargetFlags.CORPSE_ENEMY in self.target_flags:
            _size += 0 + packed_guid_size(self.enemy_corpse_target)
        elif SpellCastTargetFlags.CORPSE_ALLY in self.target_flags:
            _size += 0 + packed_guid_size(self.ally_corpse_target)

        if SpellCastTargetFlags.ITEM in self.target_flags:
            _size += 0 + packed_guid_size(self.item_target)
        elif SpellCastTargetFlags.TRADE_ITEM in self.target_flags:
            _size += 0 + packed_guid_size(self.trade_item_target)

        if SpellCastTargetFlags.SOURCE_LOCATION in self.target_flags:
            _size += 12

        if SpellCastTargetFlags.DEST_LOCATION in self.target_flags:
            _size += 12

        if SpellCastTargetFlags.STRING in self.target_flags:
            _size += 1 + len(self.target_string)

        return _size


@dataclasses.dataclass
class SpellCooldownStatus:
    id: int
    cooldown_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SpellCooldownStatus:
        # id: Spell
        id = await read_int(reader, 4)

        # cooldown_time: Milliseconds
        cooldown_time = await read_int(reader, 4)

        return SpellCooldownStatus(
            id=id,
            cooldown_time=cooldown_time,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.id, self.cooldown_time])
        return _fmt, _data


@dataclasses.dataclass
class SpellLog:
    effect: SpellEffect
    target1: typing.Optional[int] = None
    amount: typing.Optional[int] = None
    power: typing.Optional[Power] = None
    multiplier: typing.Optional[float] = None
    target4: typing.Optional[int] = None
    extra_attacks: typing.Optional[int] = None
    target5: typing.Optional[int] = None
    interrupted_spell: typing.Optional[int] = None
    target6: typing.Optional[int] = None
    item_to_damage: typing.Optional[int] = None
    unknown5: typing.Optional[int] = None
    lock_target: typing.Optional[int] = None
    item: typing.Optional[int] = None
    summon_target: typing.Optional[int] = None
    pet_feed_guid: typing.Optional[int] = None
    pet_dismiss_guid: typing.Optional[int] = None
    resurrect_guid: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SpellLog:
        target1 = None
        amount = None
        power = None
        multiplier = None
        target4 = None
        extra_attacks = None
        target5 = None
        interrupted_spell = None
        target6 = None
        item_to_damage = None
        unknown5 = None
        lock_target = None
        item = None
        summon_target = None
        pet_feed_guid = None
        pet_dismiss_guid = None
        resurrect_guid = None
        # effect: SpellEffect
        effect = SpellEffect(await read_int(reader, 4))

        # amount_of_logs: u32
        _amount_of_logs = await read_int(reader, 4)

        if effect == SpellEffect.POWER_DRAIN:
            # target1: PackedGuid
            target1 = await read_packed_guid(reader)

            # amount: u32
            amount = await read_int(reader, 4)

            # power: Power
            power = Power(await read_int(reader, 4))

            # multiplier: f32
            multiplier = await read_float(reader)

        elif effect == SpellEffect.ADD_EXTRA_ATTACKS:
            # target4: PackedGuid
            target4 = await read_packed_guid(reader)

            # extra_attacks: u32
            extra_attacks = await read_int(reader, 4)

        elif effect == SpellEffect.INTERRUPT_CAST:
            # target5: PackedGuid
            target5 = await read_packed_guid(reader)

            # interrupted_spell: Spell
            interrupted_spell = await read_int(reader, 4)

        elif effect == SpellEffect.DURABILITY_DAMAGE:
            # target6: PackedGuid
            target6 = await read_packed_guid(reader)

            # item_to_damage: Item
            item_to_damage = await read_int(reader, 4)

            # unknown5: u32
            unknown5 = await read_int(reader, 4)

        elif effect in {SpellEffect.OPEN_LOCK, SpellEffect.OPEN_LOCK_ITEM}:
            # lock_target: PackedGuid
            lock_target = await read_packed_guid(reader)

        elif effect in {SpellEffect.CREATE_ITEM, SpellEffect.CREATE_ITEM2}:
            # item: Item
            item = await read_int(reader, 4)

        elif effect in {SpellEffect.SUMMON, SpellEffect.TRANS_DOOR, SpellEffect.SUMMON_PET, SpellEffect.SUMMON_OBJECT_WILD, SpellEffect.CREATE_HOUSE, SpellEffect.DUEL, SpellEffect.SUMMON_OBJECT_SLOT1, SpellEffect.SUMMON_OBJECT_SLOT2, SpellEffect.SUMMON_OBJECT_SLOT3, SpellEffect.SUMMON_OBJECT_SLOT4}:
            # summon_target: PackedGuid
            summon_target = await read_packed_guid(reader)

        elif effect == SpellEffect.FEED_PET:
            # pet_feed_guid: PackedGuid
            pet_feed_guid = await read_packed_guid(reader)

        elif effect == SpellEffect.DISMISS_PET:
            # pet_dismiss_guid: PackedGuid
            pet_dismiss_guid = await read_packed_guid(reader)

        elif effect in {SpellEffect.RESURRECT, SpellEffect.RESURRECT_NEW}:
            # resurrect_guid: PackedGuid
            resurrect_guid = await read_packed_guid(reader)

        return SpellLog(
            effect=effect,
            target1=target1,
            amount=amount,
            power=power,
            multiplier=multiplier,
            target4=target4,
            extra_attacks=extra_attacks,
            target5=target5,
            interrupted_spell=interrupted_spell,
            target6=target6,
            item_to_damage=item_to_damage,
            unknown5=unknown5,
            lock_target=lock_target,
            item=item,
            summon_target=summon_target,
            pet_feed_guid=pet_feed_guid,
            pet_dismiss_guid=pet_dismiss_guid,
            resurrect_guid=resurrect_guid,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.effect.value, 1])
        if self.effect == SpellEffect.POWER_DRAIN:
            # target1: PackedGuid
            _fmt, _data = packed_guid_write(self.target1, _fmt, _data)

            # amount: u32
            _fmt += 'I'
            _data.append(self.amount)

            # power: Power
            _fmt += 'I'
            _data.append(self.power.value)

            # multiplier: f32
            _fmt += 'f'
            _data.append(self.multiplier)

        elif self.effect == SpellEffect.ADD_EXTRA_ATTACKS:
            # target4: PackedGuid
            _fmt, _data = packed_guid_write(self.target4, _fmt, _data)

            # extra_attacks: u32
            _fmt += 'I'
            _data.append(self.extra_attacks)

        elif self.effect == SpellEffect.INTERRUPT_CAST:
            # target5: PackedGuid
            _fmt, _data = packed_guid_write(self.target5, _fmt, _data)

            # interrupted_spell: Spell
            _fmt += 'I'
            _data.append(self.interrupted_spell)

        elif self.effect == SpellEffect.DURABILITY_DAMAGE:
            # target6: PackedGuid
            _fmt, _data = packed_guid_write(self.target6, _fmt, _data)

            # item_to_damage: Item
            _fmt += 'I'
            _data.append(self.item_to_damage)

            # unknown5: u32
            _fmt += 'I'
            _data.append(self.unknown5)

        elif self.effect in {SpellEffect.OPEN_LOCK, SpellEffect.OPEN_LOCK_ITEM}:
            # lock_target: PackedGuid
            _fmt, _data = packed_guid_write(self.lock_target, _fmt, _data)

        elif self.effect in {SpellEffect.CREATE_ITEM, SpellEffect.CREATE_ITEM2}:
            _fmt += 'I'
            _data.append(self.item)
        elif self.effect in {SpellEffect.SUMMON, SpellEffect.TRANS_DOOR, SpellEffect.SUMMON_PET, SpellEffect.SUMMON_OBJECT_WILD, SpellEffect.CREATE_HOUSE, SpellEffect.DUEL, SpellEffect.SUMMON_OBJECT_SLOT1, SpellEffect.SUMMON_OBJECT_SLOT2, SpellEffect.SUMMON_OBJECT_SLOT3, SpellEffect.SUMMON_OBJECT_SLOT4}:
            # summon_target: PackedGuid
            _fmt, _data = packed_guid_write(self.summon_target, _fmt, _data)

        elif self.effect == SpellEffect.FEED_PET:
            # pet_feed_guid: PackedGuid
            _fmt, _data = packed_guid_write(self.pet_feed_guid, _fmt, _data)

        elif self.effect == SpellEffect.DISMISS_PET:
            # pet_dismiss_guid: PackedGuid
            _fmt, _data = packed_guid_write(self.pet_dismiss_guid, _fmt, _data)

        elif self.effect in {SpellEffect.RESURRECT, SpellEffect.RESURRECT_NEW}:
            # resurrect_guid: PackedGuid
            _fmt, _data = packed_guid_write(self.resurrect_guid, _fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        _size = 8

        if self.effect == SpellEffect.POWER_DRAIN:
            _size += 12 + packed_guid_size(self.target1)
        elif self.effect == SpellEffect.ADD_EXTRA_ATTACKS:
            _size += 4 + packed_guid_size(self.target4)
        elif self.effect == SpellEffect.INTERRUPT_CAST:
            _size += 4 + packed_guid_size(self.target5)
        elif self.effect == SpellEffect.DURABILITY_DAMAGE:
            _size += 8 + packed_guid_size(self.target6)
        elif self.effect in {SpellEffect.OPEN_LOCK, SpellEffect.OPEN_LOCK_ITEM}:
            _size += 0 + packed_guid_size(self.lock_target)
        elif self.effect in {SpellEffect.CREATE_ITEM, SpellEffect.CREATE_ITEM2}:
            _size += 4
        elif self.effect in {SpellEffect.SUMMON, SpellEffect.TRANS_DOOR, SpellEffect.SUMMON_PET, SpellEffect.SUMMON_OBJECT_WILD, SpellEffect.CREATE_HOUSE, SpellEffect.DUEL, SpellEffect.SUMMON_OBJECT_SLOT1, SpellEffect.SUMMON_OBJECT_SLOT2, SpellEffect.SUMMON_OBJECT_SLOT3, SpellEffect.SUMMON_OBJECT_SLOT4}:
            _size += 0 + packed_guid_size(self.summon_target)
        elif self.effect == SpellEffect.FEED_PET:
            _size += 0 + packed_guid_size(self.pet_feed_guid)
        elif self.effect == SpellEffect.DISMISS_PET:
            _size += 0 + packed_guid_size(self.pet_dismiss_guid)
        elif self.effect in {SpellEffect.RESURRECT, SpellEffect.RESURRECT_NEW}:
            _size += 0 + packed_guid_size(self.resurrect_guid)

        return _size


@dataclasses.dataclass
class SpellLogMiss:
    target: int
    miss_info: SpellMissInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SpellLogMiss:
        # target: Guid
        target = await read_int(reader, 8)

        # miss_info: SpellMissInfo
        miss_info = SpellMissInfo(await read_int(reader, 1))

        return SpellLogMiss(
            target=target,
            miss_info=miss_info,
        )

    def write(self, _fmt, _data):
        _fmt += 'QB'
        _data.extend([self.target, self.miss_info.value])
        return _fmt, _data


@dataclasses.dataclass
class SpellMiss:
    target: int
    miss_info: SpellMissInfo
    reflect_result: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SpellMiss:
        reflect_result = None
        # target: Guid
        target = await read_int(reader, 8)

        # miss_info: SpellMissInfo
        miss_info = SpellMissInfo(await read_int(reader, 1))

        if miss_info == SpellMissInfo.REFLECT:
            # reflect_result: u8
            reflect_result = await read_int(reader, 1)

        return SpellMiss(
            target=target,
            miss_info=miss_info,
            reflect_result=reflect_result,
        )

    def write(self, _fmt, _data):
        _fmt += 'QB'
        _data.extend([self.target, self.miss_info.value])
        if self.miss_info == SpellMissInfo.REFLECT:
            _fmt += 'B'
            _data.append(self.reflect_result)
        return _fmt, _data

    def size(self) -> int:
        _size = 9

        if self.miss_info == SpellMissInfo.REFLECT:
            _size += 1

        return _size


@dataclasses.dataclass
class SpellSteal:
    spell: int
    action: SpellStealAction

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SpellSteal:
        # spell: Spell
        spell = await read_int(reader, 4)

        # action: SpellStealAction
        action = SpellStealAction(await read_int(reader, 1))

        return SpellSteal(
            spell=spell,
            action=action,
        )

    def write(self, _fmt, _data):
        _fmt += 'IB'
        _data.extend([self.spell, self.action.value])
        return _fmt, _data


@dataclasses.dataclass
class StabledPet:
    pet_number: int
    entry: int
    level: int
    name: str
    loyalty: int
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> StabledPet:
        # pet_number: u32
        pet_number = await read_int(reader, 4)

        # entry: u32
        entry = await read_int(reader, 4)

        # level: Level32
        level = await read_int(reader, 4)

        # name: CString
        name = await read_cstring(reader)

        # loyalty: u32
        loyalty = await read_int(reader, 4)

        # slot: u8
        slot = await read_int(reader, 1)

        return StabledPet(
            pet_number=pet_number,
            entry=entry,
            level=level,
            name=name,
            loyalty=loyalty,
            slot=slot,
        )

    def write(self, _fmt, _data):
        _fmt += f'III{len(self.name)}sBIB'
        _data.extend([self.pet_number, self.entry, self.level, self.name.encode('utf-8'), 0, self.loyalty, self.slot])
        return _fmt, _data

    def size(self) -> int:
        return 18 + len(self.name)


@dataclasses.dataclass
class TalentInfoSpec:
    talents: typing.List[InspectTalent]
    glyphs: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> TalentInfoSpec:
        # amount_of_talents: u8
        amount_of_talents = await read_int(reader, 1)

        # talents: InspectTalent[amount_of_talents]
        talents = []
        for _ in range(0, amount_of_talents):
            talents.append(await InspectTalent.read(reader))

        # amount_of_glyphs: u8
        amount_of_glyphs = await read_int(reader, 1)

        # glyphs: u16[amount_of_glyphs]
        glyphs = []
        for _ in range(0, amount_of_glyphs):
            glyphs.append(await read_int(reader, 2))

        return TalentInfoSpec(
            talents=talents,
            glyphs=glyphs,
        )

    def write(self, _fmt, _data):
        _fmt += 'B'
        _data.append(len(self.talents))
        # talents: InspectTalent[amount_of_talents]
        for i in self.talents:
            _fmt, _data = i.write(_fmt, _data)

        # amount_of_glyphs: u8
        _fmt += 'B'
        _data.append(len(self.glyphs))

        # glyphs: u16[amount_of_glyphs]
        _fmt += f'{len(self.glyphs)}H'
        _data.extend([*self.glyphs])

        return _fmt, _data

    def size(self) -> int:
        return 2 + 5 * len(self.talents) + 2 * len(self.glyphs)


@dataclasses.dataclass
class ThreatUpdateUnit:
    unit: int
    threat: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ThreatUpdateUnit:
        # unit: PackedGuid
        unit = await read_packed_guid(reader)

        # threat: u32
        threat = await read_int(reader, 4)

        return ThreatUpdateUnit(
            unit=unit,
            threat=threat,
        )

    def write(self, _fmt, _data):
        # unit: PackedGuid
        _fmt, _data = packed_guid_write(self.unit, _fmt, _data)

        # threat: u32
        _fmt += 'I'
        _data.append(self.threat)

        return _fmt, _data

    def size(self) -> int:
        return 4 + packed_guid_size(self.unit)


@dataclasses.dataclass
class TradeSlot:
    trade_slot_number: int
    item: int
    display_id: int
    stack_count: int
    wrapped: bool
    gift_wrapper: int
    enchantment: int
    enchantments_slots: typing.List[int]
    item_creator: int
    spell_charges: int
    item_suffix_factor: int
    item_random_properties_id: int
    lock_id: int
    max_durability: int
    durability: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> TradeSlot:
        # trade_slot_number: u8
        trade_slot_number = await read_int(reader, 1)

        # item: Item
        item = await read_int(reader, 4)

        # display_id: u32
        display_id = await read_int(reader, 4)

        # stack_count: u32
        stack_count = await read_int(reader, 4)

        # wrapped: Bool32
        wrapped = await read_bool(reader, 4)

        # gift_wrapper: Guid
        gift_wrapper = await read_int(reader, 8)

        # enchantment: u32
        enchantment = await read_int(reader, 4)

        # enchantments_slots: u32[3]
        enchantments_slots = []
        for _ in range(0, 3):
            enchantments_slots.append(await read_int(reader, 4))

        # item_creator: Guid
        item_creator = await read_int(reader, 8)

        # spell_charges: u32
        spell_charges = await read_int(reader, 4)

        # item_suffix_factor: u32
        item_suffix_factor = await read_int(reader, 4)

        # item_random_properties_id: u32
        item_random_properties_id = await read_int(reader, 4)

        # lock_id: u32
        lock_id = await read_int(reader, 4)

        # max_durability: u32
        max_durability = await read_int(reader, 4)

        # durability: u32
        durability = await read_int(reader, 4)

        return TradeSlot(
            trade_slot_number=trade_slot_number,
            item=item,
            display_id=display_id,
            stack_count=stack_count,
            wrapped=wrapped,
            gift_wrapper=gift_wrapper,
            enchantment=enchantment,
            enchantments_slots=enchantments_slots,
            item_creator=item_creator,
            spell_charges=spell_charges,
            item_suffix_factor=item_suffix_factor,
            item_random_properties_id=item_random_properties_id,
            lock_id=lock_id,
            max_durability=max_durability,
            durability=durability,
        )

    def write(self, _fmt, _data):
        _fmt += f'BIIIIQI{len(self.enchantments_slots)}IQIIIIII'
        _data.extend([self.trade_slot_number, self.item, self.display_id, self.stack_count, self.wrapped, self.gift_wrapper, self.enchantment, *self.enchantments_slots, self.item_creator, self.spell_charges, self.item_suffix_factor, self.item_random_properties_id, self.lock_id, self.max_durability, self.durability])
        return _fmt, _data


@dataclasses.dataclass
class TrainerSpell:
    spell: int
    state: TrainerSpellState
    spell_cost: int
    talent_point_cost: int
    first_rank: int
    required_level: int
    required_skill: Skill
    required_skill_value: int
    required_spells: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> TrainerSpell:
        # spell: Spell
        spell = await read_int(reader, 4)

        # state: TrainerSpellState
        state = TrainerSpellState(await read_int(reader, 1))

        # spell_cost: u32
        spell_cost = await read_int(reader, 4)

        # talent_point_cost: u32
        talent_point_cost = await read_int(reader, 4)

        # first_rank: u32
        first_rank = await read_int(reader, 4)

        # required_level: u8
        required_level = await read_int(reader, 1)

        # required_skill: Skill
        required_skill = Skill(await read_int(reader, 4))

        # required_skill_value: u32
        required_skill_value = await read_int(reader, 4)

        # required_spells: u32[3]
        required_spells = []
        for _ in range(0, 3):
            required_spells.append(await read_int(reader, 4))

        return TrainerSpell(
            spell=spell,
            state=state,
            spell_cost=spell_cost,
            talent_point_cost=talent_point_cost,
            first_rank=first_rank,
            required_level=required_level,
            required_skill=required_skill,
            required_skill_value=required_skill_value,
            required_spells=required_spells,
        )

    def write(self, _fmt, _data):
        _fmt += f'IBIIIBII{len(self.required_spells)}I'
        _data.extend([self.spell, self.state.value, self.spell_cost, self.talent_point_cost, self.first_rank, self.required_level, self.required_skill.value, self.required_skill_value, *self.required_spells])
        return _fmt, _data


@dataclasses.dataclass
class Vector2d:
    x: float
    y: float

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Vector2d:
        # x: f32
        x = await read_float(reader)

        # y: f32
        y = await read_float(reader)

        return Vector2d(
            x=x,
            y=y,
        )

    def write(self, _fmt, _data):
        _fmt += 'ff'
        _data.extend([self.x, self.y])
        return _fmt, _data


@dataclasses.dataclass
class WhoPlayer:
    name: str
    guild: str
    level: int
    class_type: Class
    race: Race
    gender: Gender
    area: Area

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> WhoPlayer:
        # name: CString
        name = await read_cstring(reader)

        # guild: CString
        guild = await read_cstring(reader)

        # level: Level32
        level = await read_int(reader, 4)

        # class_type: Class
        class_type = Class(await read_int(reader, 1))

        # race: Race
        race = Race(await read_int(reader, 1))

        # gender: Gender
        gender = Gender(await read_int(reader, 1))

        # area: Area
        area = Area(await read_int(reader, 4))

        return WhoPlayer(
            name=name,
            guild=guild,
            level=level,
            class_type=class_type,
            race=race,
            gender=gender,
            area=area,
        )

    def write(self, _fmt, _data):
        _fmt += f'{len(self.name)}sB{len(self.guild)}sBIBBBI'
        _data.extend([self.name.encode('utf-8'), 0, self.guild.encode('utf-8'), 0, self.level, self.class_type.value, self.race.value, self.gender.value, self.area.value])
        return _fmt, _data

    def size(self) -> int:
        return 13 + len(self.name) + len(self.guild)


@dataclasses.dataclass
class WorldState:
    state: int
    value: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> WorldState:
        # state: u32
        state = await read_int(reader, 4)

        # value: u32
        value = await read_int(reader, 4)

        return WorldState(
            state=state,
            value=value,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.state, self.value])
        return _fmt, _data


@dataclasses.dataclass
class CMSG_BOOTME:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BOOTME:
        return CMSG_BOOTME()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0001))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_DBLOOKUP:
    query: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_DBLOOKUP:
        # query: CString
        query = await read_cstring(reader)

        return CMSG_DBLOOKUP(
            query=query,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0002))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.query)}sB'
        _data.extend([self.query.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.query)


@dataclasses.dataclass
class CMSG_WORLD_TELEPORT:
    time: int
    map: Map
    unknown: int
    position: Vector3d
    orientation: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_WORLD_TELEPORT:
        # time: Milliseconds
        time = await read_int(reader, 4)

        # map: Map
        map = Map(await read_int(reader, 4))

        # unknown: u64
        unknown = await read_int(reader, 8)

        # position: Vector3d
        position = await Vector3d.read(reader)

        # orientation: f32
        orientation = await read_float(reader)

        return CMSG_WORLD_TELEPORT(
            time=time,
            map=map,
            unknown=unknown,
            position=position,
            orientation=orientation,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(32 + 4, 0x0008))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IIQ'
        _data.extend([self.time, self.map.value, self.unknown])
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # orientation: f32
        _fmt += 'f'
        _data.append(self.orientation)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TELEPORT_TO_UNIT:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TELEPORT_TO_UNIT:
        # name: CString
        name = await read_cstring(reader)

        return CMSG_TELEPORT_TO_UNIT(
            name=name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0009))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class CMSG_CHAR_CREATE:
    name: str
    race: Race
    class_type: Class
    gender: Gender
    skin_color: int
    face: int
    hair_style: int
    hair_color: int
    facial_hair: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHAR_CREATE:
        # name: CString
        name = await read_cstring(reader)

        # race: Race
        race = Race(await read_int(reader, 1))

        # class_type: Class
        class_type = Class(await read_int(reader, 1))

        # gender: Gender
        gender = Gender(await read_int(reader, 1))

        # skin_color: u8
        skin_color = await read_int(reader, 1)

        # face: u8
        face = await read_int(reader, 1)

        # hair_style: u8
        hair_style = await read_int(reader, 1)

        # hair_color: u8
        hair_color = await read_int(reader, 1)

        # facial_hair: u8
        facial_hair = await read_int(reader, 1)

        # outfit_id: u8
        _outfit_id = await read_int(reader, 1)

        return CMSG_CHAR_CREATE(
            name=name,
            race=race,
            class_type=class_type,
            gender=gender,
            skin_color=skin_color,
            face=face,
            hair_style=hair_style,
            hair_color=hair_color,
            facial_hair=facial_hair,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0036))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sBBBBBBBBBB'
        _data.extend([self.name.encode('utf-8'), 0, self.race.value, self.class_type.value, self.gender.value, self.skin_color, self.face, self.hair_style, self.hair_color, self.facial_hair, 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 10 + len(self.name)


@dataclasses.dataclass
class CMSG_CHAR_ENUM:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHAR_ENUM:
        return CMSG_CHAR_ENUM()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0037))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CHAR_DELETE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHAR_DELETE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_CHAR_DELETE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0038))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CHAR_CREATE:
    result: WorldResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAR_CREATE:
        # result: WorldResult
        result = WorldResult(await read_int(reader, 1))

        return SMSG_CHAR_CREATE(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x003A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CHAR_ENUM:
    characters: typing.List[Character]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAR_ENUM:
        # amount_of_characters: u8
        amount_of_characters = await read_int(reader, 1)

        # characters: Character[amount_of_characters]
        characters = []
        for _ in range(0, amount_of_characters):
            characters.append(await Character.read(reader))

        return SMSG_CHAR_ENUM(
            characters=characters,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x003B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(len(self.characters))
        # characters: Character[amount_of_characters]
        for i in self.characters:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + sum([i.size() for i in self.characters])


@dataclasses.dataclass
class SMSG_CHAR_DELETE:
    result: WorldResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAR_DELETE:
        # result: WorldResult
        result = WorldResult(await read_int(reader, 1))

        return SMSG_CHAR_DELETE(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x003C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PLAYER_LOGIN:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PLAYER_LOGIN:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_PLAYER_LOGIN(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x003D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_NEW_WORLD:
    map: Map
    position: Vector3d
    orientation: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_NEW_WORLD:
        # map: Map
        map = Map(await read_int(reader, 4))

        # position: Vector3d
        position = await Vector3d.read(reader)

        # orientation: f32
        orientation = await read_float(reader)

        return SMSG_NEW_WORLD(
            map=map,
            position=position,
            orientation=orientation,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x003E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # orientation: f32
        _fmt += 'f'
        _data.append(self.orientation)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TRANSFER_PENDING:
    map: Map
    transport: typing.Optional[int] = None
    transport_map: typing.Optional[Map] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRANSFER_PENDING:
        transport = None
        transport_map = None
        _size = 0

        # map: Map
        map = Map(await read_int(reader, 4))
        _size += 4

        # has_transport: optional
        if _size < body_size:
            # transport: u32
            transport = await read_int(reader, 4)
            _size += 4

            # transport_map: Map
            transport_map = Map(await read_int(reader, 4))
            _size += 4

        return SMSG_TRANSFER_PENDING(
            map=map,
            transport=transport,
            transport_map=transport_map,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x003F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        # has_transport: optional
        if self.transport is not None and self.transport_map is not None:
            _fmt += 'II'
            _data.extend([self.transport, self.transport_map.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        # has_transport: optional
        if self.transport is not None and self.transport_map is not None:
            _size += 8

        return _size


@dataclasses.dataclass
class SMSG_TRANSFER_ABORTED:
    map: Map
    reason: TransferAbortReason
    difficulty: typing.Optional[DungeonDifficulty] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRANSFER_ABORTED:
        difficulty = None
        # map: Map
        map = Map(await read_int(reader, 4))

        # reason: TransferAbortReason
        reason = TransferAbortReason(await read_int(reader, 1))

        if reason in {TransferAbortReason.INSUFFICIENT_EXPANSION_LEVEL, TransferAbortReason.DIFFICULTY_NOT_AVAILABLE, TransferAbortReason.UNIQUE_MESSAGE}:
            # difficulty: DungeonDifficulty
            difficulty = DungeonDifficulty(await read_int(reader, 1))

        return SMSG_TRANSFER_ABORTED(
            map=map,
            reason=reason,
            difficulty=difficulty,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0040))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([self.map.value, self.reason.value])
        if self.reason in {TransferAbortReason.INSUFFICIENT_EXPANSION_LEVEL, TransferAbortReason.DIFFICULTY_NOT_AVAILABLE, TransferAbortReason.UNIQUE_MESSAGE}:
            _fmt += 'B'
            _data.append(self.difficulty.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 5

        if self.reason in {TransferAbortReason.INSUFFICIENT_EXPANSION_LEVEL, TransferAbortReason.DIFFICULTY_NOT_AVAILABLE, TransferAbortReason.UNIQUE_MESSAGE}:
            _size += 1

        return _size


@dataclasses.dataclass
class SMSG_CHARACTER_LOGIN_FAILED:
    result: WorldResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHARACTER_LOGIN_FAILED:
        # result: WorldResult
        result = WorldResult(await read_int(reader, 1))

        return SMSG_CHARACTER_LOGIN_FAILED(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x0041))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOGIN_SETTIMESPEED:
    datetime: int
    timescale: float
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOGIN_SETTIMESPEED:
        # datetime: DateTime
        datetime = await read_int(reader, 4)

        # timescale: f32
        timescale = await read_float(reader)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return SMSG_LOGIN_SETTIMESPEED(
            datetime=datetime,
            timescale=timescale,
            unknown1=unknown1,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0042))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IfI'
        _data.extend([self.datetime, self.timescale, self.unknown1])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PLAYER_LOGOUT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PLAYER_LOGOUT:
        return CMSG_PLAYER_LOGOUT()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x004A))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LOGOUT_REQUEST:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOGOUT_REQUEST:
        return CMSG_LOGOUT_REQUEST()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x004B))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOGOUT_RESPONSE:
    result: LogoutResult
    speed: LogoutSpeed

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOGOUT_RESPONSE:
        # result: LogoutResult
        result = LogoutResult(await read_int(reader, 4))

        # speed: LogoutSpeed
        speed = LogoutSpeed(await read_int(reader, 1))

        return SMSG_LOGOUT_RESPONSE(
            result=result,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x004C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([self.result.value, self.speed.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOGOUT_COMPLETE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOGOUT_COMPLETE:
        return SMSG_LOGOUT_COMPLETE()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x004D))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LOGOUT_CANCEL:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOGOUT_CANCEL:
        return CMSG_LOGOUT_CANCEL()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x004E))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOGOUT_CANCEL_ACK:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOGOUT_CANCEL_ACK:
        return SMSG_LOGOUT_CANCEL_ACK()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x004F))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_NAME_QUERY:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_NAME_QUERY:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_NAME_QUERY(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0050))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_NAME_QUERY_RESPONSE:
    guid: int
    character_name: str
    realm_name: str
    race: Race
    gender: Gender
    class_type: Class
    has_declined_names: DeclinedNames
    declined_names: typing.Optional[typing.List[str]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_NAME_QUERY_RESPONSE:
        declined_names = None
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # early_terminate: u8
        _early_terminate = await read_int(reader, 1)

        # character_name: CString
        character_name = await read_cstring(reader)

        # realm_name: CString
        realm_name = await read_cstring(reader)

        # race: Race
        race = Race(await read_int(reader, 1))

        # gender: Gender
        gender = Gender(await read_int(reader, 1))

        # class_type: Class
        class_type = Class(await read_int(reader, 1))

        # has_declined_names: DeclinedNames
        has_declined_names = DeclinedNames(await read_int(reader, 1))

        if has_declined_names == DeclinedNames.YES:
            # declined_names: CString[5]
            declined_names = []
            for _ in range(0, 5):
                declined_names.append(await read_cstring(reader))

        return SMSG_NAME_QUERY_RESPONSE(
            guid=guid,
            character_name=character_name,
            realm_name=realm_name,
            race=race,
            gender=gender,
            class_type=class_type,
            has_declined_names=has_declined_names,
            declined_names=declined_names,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0051))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # early_terminate: u8
        _fmt += 'B'
        _data.append(0)

        # character_name: CString
        _fmt += f'{len(self.character_name)}sB'
        _data.extend([self.character_name.encode('utf-8'), 0])

        # realm_name: CString
        _fmt += f'{len(self.realm_name)}sB'
        _data.extend([self.realm_name.encode('utf-8'), 0])

        # race: Race
        _fmt += 'B'
        _data.append(self.race.value)

        # gender: Gender
        _fmt += 'B'
        _data.append(self.gender.value)

        # class_type: Class
        _fmt += 'B'
        _data.append(self.class_type.value)

        # has_declined_names: DeclinedNames
        _fmt += 'B'
        _data.append(self.has_declined_names.value)

        if self.has_declined_names == DeclinedNames.YES:
            # declined_names: CString[5]
            for i in self.declined_names:
                _fmt += f'{len(i)}sB'
                _data.append(i.encode('utf-8'))
                _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 7 + packed_guid_size(self.guid) + len(self.character_name) + len(self.realm_name)

        if self.has_declined_names == DeclinedNames.YES:
            _size += 0 + sum([len(i) + 1 for i in self.declined_names])

        return _size


@dataclasses.dataclass
class CMSG_PET_NAME_QUERY:
    pet_number: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_NAME_QUERY:
        # pet_number: u32
        pet_number = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_PET_NAME_QUERY(
            pet_number=pet_number,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0052))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.pet_number, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PET_NAME_QUERY_RESPONSE:
    pet_number: int
    name: str
    pet_name_timestamp: int
    names: PetQueryDisabledNames
    declined_names: typing.Optional[typing.List[str]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_NAME_QUERY_RESPONSE:
        declined_names = None
        # pet_number: u32
        pet_number = await read_int(reader, 4)

        # name: CString
        name = await read_cstring(reader)

        # pet_name_timestamp: u32
        pet_name_timestamp = await read_int(reader, 4)

        # names: PetQueryDisabledNames
        names = PetQueryDisabledNames(await read_int(reader, 1))

        if names == PetQueryDisabledNames.PRESENT:
            # declined_names: CString[5]
            declined_names = []
            for _ in range(0, 5):
                declined_names.append(await read_cstring(reader))

        return SMSG_PET_NAME_QUERY_RESPONSE(
            pet_number=pet_number,
            name=name,
            pet_name_timestamp=pet_name_timestamp,
            names=names,
            declined_names=declined_names,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0053))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.name)}sBIB'
        _data.extend([self.pet_number, self.name.encode('utf-8'), 0, self.pet_name_timestamp, self.names.value])
        if self.names == PetQueryDisabledNames.PRESENT:
            # declined_names: CString[5]
            for i in self.declined_names:
                _fmt += f'{len(i)}sB'
                _data.append(i.encode('utf-8'))
                _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 10 + len(self.name)

        if self.names == PetQueryDisabledNames.PRESENT:
            _size += 0 + sum([len(i) + 1 for i in self.declined_names])

        return _size


@dataclasses.dataclass
class CMSG_GUILD_QUERY:
    guild_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_QUERY:
        # guild_id: u32
        guild_id = await read_int(reader, 4)

        return CMSG_GUILD_QUERY(
            guild_id=guild_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0054))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.guild_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GUILD_QUERY_RESPONSE:
    id: int
    name: str
    rank_names: typing.List[str]
    emblem_style: int
    emblem_color: int
    border_style: int
    border_color: int
    background_color: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_QUERY_RESPONSE:
        # id: u32
        id = await read_int(reader, 4)

        # name: CString
        name = await read_cstring(reader)

        # rank_names: CString[10]
        rank_names = []
        for _ in range(0, 10):
            rank_names.append(await read_cstring(reader))

        # emblem_style: u32
        emblem_style = await read_int(reader, 4)

        # emblem_color: u32
        emblem_color = await read_int(reader, 4)

        # border_style: u32
        border_style = await read_int(reader, 4)

        # border_color: u32
        border_color = await read_int(reader, 4)

        # background_color: u32
        background_color = await read_int(reader, 4)

        return SMSG_GUILD_QUERY_RESPONSE(
            id=id,
            name=name,
            rank_names=rank_names,
            emblem_style=emblem_style,
            emblem_color=emblem_color,
            border_style=border_style,
            border_color=border_color,
            background_color=background_color,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0055))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.name)}sB'
        _data.extend([self.id, self.name.encode('utf-8'), 0])
        # rank_names: CString[10]
        for i in self.rank_names:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        # emblem_style: u32
        _fmt += 'I'
        _data.append(self.emblem_style)

        # emblem_color: u32
        _fmt += 'I'
        _data.append(self.emblem_color)

        # border_style: u32
        _fmt += 'I'
        _data.append(self.border_style)

        # border_color: u32
        _fmt += 'I'
        _data.append(self.border_color)

        # background_color: u32
        _fmt += 'I'
        _data.append(self.background_color)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 25 + len(self.name) + sum([len(i) + 1 for i in self.rank_names])


@dataclasses.dataclass
class CMSG_ITEM_QUERY_SINGLE:
    item: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ITEM_QUERY_SINGLE:
        # item: Item
        item = await read_int(reader, 4)

        return CMSG_ITEM_QUERY_SINGLE(
            item=item,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0056))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.item)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_QUERY_SINGLE_RESPONSE:
    item: int
    class_and_sub_class: typing.Optional[ItemClassAndSubClass] = None
    sound_override_sub_class: typing.Optional[int] = None
    name1: typing.Optional[str] = None
    name2: typing.Optional[str] = None
    name3: typing.Optional[str] = None
    name4: typing.Optional[str] = None
    display_id: typing.Optional[int] = None
    quality: typing.Optional[ItemQuality] = None
    flags: typing.Optional[ItemFlag] = None
    flags2: typing.Optional[ItemFlag2] = None
    buy_price: typing.Optional[int] = None
    sell_price: typing.Optional[int] = None
    inventory_type: typing.Optional[InventoryType] = None
    allowed_class: typing.Optional[AllowedClass] = None
    allowed_race: typing.Optional[AllowedRace] = None
    item_level: typing.Optional[int] = None
    required_level: typing.Optional[int] = None
    required_skill: typing.Optional[Skill] = None
    required_skill_rank: typing.Optional[int] = None
    required_spell: typing.Optional[int] = None
    required_honor_rank: typing.Optional[int] = None
    required_city_rank: typing.Optional[int] = None
    required_faction: typing.Optional[Faction] = None
    required_faction_rank: typing.Optional[int] = None
    max_count: typing.Optional[int] = None
    stackable: typing.Optional[int] = None
    container_slots: typing.Optional[int] = None
    stats: typing.Optional[typing.List[ItemStat]] = None
    scaling_stats_entry: typing.Optional[int] = None
    scaling_stats_flag: typing.Optional[int] = None
    damages: typing.Optional[typing.List[ItemDamageType]] = None
    armor: typing.Optional[int] = None
    holy_resistance: typing.Optional[int] = None
    fire_resistance: typing.Optional[int] = None
    nature_resistance: typing.Optional[int] = None
    frost_resistance: typing.Optional[int] = None
    shadow_resistance: typing.Optional[int] = None
    arcane_resistance: typing.Optional[int] = None
    delay: typing.Optional[int] = None
    ammo_type: typing.Optional[int] = None
    ranged_range_modification: typing.Optional[float] = None
    spells: typing.Optional[typing.List[ItemSpells]] = None
    bonding: typing.Optional[Bonding] = None
    description: typing.Optional[str] = None
    page_text: typing.Optional[int] = None
    language: typing.Optional[Language] = None
    page_text_material: typing.Optional[PageTextMaterial] = None
    start_quest: typing.Optional[int] = None
    lock_id: typing.Optional[int] = None
    material: typing.Optional[int] = None
    sheathe_type: typing.Optional[SheatheType] = None
    random_property: typing.Optional[int] = None
    random_suffix: typing.Optional[int] = None
    block: typing.Optional[int] = None
    item_set: typing.Optional[ItemSet] = None
    max_durability: typing.Optional[int] = None
    area: typing.Optional[Area] = None
    map: typing.Optional[Map] = None
    bag_family: typing.Optional[BagFamily] = None
    totem_category: typing.Optional[int] = None
    sockets: typing.Optional[typing.List[ItemSocket]] = None
    socket_bonus: typing.Optional[int] = None
    gem_properties: typing.Optional[int] = None
    required_disenchant_skill: typing.Optional[int] = None
    armor_damage_modifier: typing.Optional[float] = None
    duration: typing.Optional[int] = None
    item_limit_category: typing.Optional[int] = None
    holiday_id: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_QUERY_SINGLE_RESPONSE:
        class_and_sub_class = None
        sound_override_sub_class = None
        name1 = None
        name2 = None
        name3 = None
        name4 = None
        display_id = None
        quality = None
        flags = None
        flags2 = None
        buy_price = None
        sell_price = None
        inventory_type = None
        allowed_class = None
        allowed_race = None
        item_level = None
        required_level = None
        required_skill = None
        required_skill_rank = None
        required_spell = None
        required_honor_rank = None
        required_city_rank = None
        required_faction = None
        required_faction_rank = None
        max_count = None
        stackable = None
        container_slots = None
        amount_of_stats = None
        stats = None
        scaling_stats_entry = None
        scaling_stats_flag = None
        damages = None
        armor = None
        holy_resistance = None
        fire_resistance = None
        nature_resistance = None
        frost_resistance = None
        shadow_resistance = None
        arcane_resistance = None
        delay = None
        ammo_type = None
        ranged_range_modification = None
        spells = None
        bonding = None
        description = None
        page_text = None
        language = None
        page_text_material = None
        start_quest = None
        lock_id = None
        material = None
        sheathe_type = None
        random_property = None
        random_suffix = None
        block = None
        item_set = None
        max_durability = None
        area = None
        map = None
        bag_family = None
        totem_category = None
        sockets = None
        socket_bonus = None
        gem_properties = None
        required_disenchant_skill = None
        armor_damage_modifier = None
        duration = None
        item_limit_category = None
        holiday_id = None
        _size = 0

        # item: Item
        item = await read_int(reader, 4)
        _size += 4

        # found: optional
        if _size < body_size:
            # class_and_sub_class: ItemClassAndSubClass
            class_and_sub_class = ItemClassAndSubClass(await read_int(reader, 8))
            _size += 8

            # sound_override_sub_class: u32
            sound_override_sub_class = await read_int(reader, 4)
            _size += 4

            # name1: CString
            name1 = await read_cstring(reader)
            _size += len(name1) + 1

            # name2: CString
            name2 = await read_cstring(reader)
            _size += len(name2) + 1

            # name3: CString
            name3 = await read_cstring(reader)
            _size += len(name3) + 1

            # name4: CString
            name4 = await read_cstring(reader)
            _size += len(name4) + 1

            # display_id: u32
            display_id = await read_int(reader, 4)
            _size += 4

            # quality: ItemQuality
            quality = ItemQuality(await read_int(reader, 4))
            _size += 4

            # flags: ItemFlag
            flags = ItemFlag(await read_int(reader, 4))
            _size += 4

            # flags2: ItemFlag2
            flags2 = ItemFlag2(await read_int(reader, 4))
            _size += 4

            # buy_price: Gold
            buy_price = await read_int(reader, 4)
            _size += 4

            # sell_price: Gold
            sell_price = await read_int(reader, 4)
            _size += 4

            # inventory_type: InventoryType
            inventory_type = InventoryType(await read_int(reader, 4))
            _size += 4

            # allowed_class: AllowedClass
            allowed_class = AllowedClass(await read_int(reader, 4))
            _size += 4

            # allowed_race: AllowedRace
            allowed_race = AllowedRace(await read_int(reader, 4))
            _size += 4

            # item_level: u32
            item_level = await read_int(reader, 4)
            _size += 4

            # required_level: Level32
            required_level = await read_int(reader, 4)
            _size += 4

            # required_skill: Skill
            required_skill = Skill(await read_int(reader, 4))
            _size += 4

            # required_skill_rank: u32
            required_skill_rank = await read_int(reader, 4)
            _size += 4

            # required_spell: Spell
            required_spell = await read_int(reader, 4)
            _size += 4

            # required_honor_rank: u32
            required_honor_rank = await read_int(reader, 4)
            _size += 4

            # required_city_rank: u32
            required_city_rank = await read_int(reader, 4)
            _size += 4

            # required_faction: Faction
            required_faction = Faction(await read_int(reader, 4))
            _size += 4

            # required_faction_rank: u32
            required_faction_rank = await read_int(reader, 4)
            _size += 4

            # max_count: u32
            max_count = await read_int(reader, 4)
            _size += 4

            # stackable: u32
            stackable = await read_int(reader, 4)
            _size += 4

            # container_slots: u32
            container_slots = await read_int(reader, 4)
            _size += 4

            # amount_of_stats: u32
            amount_of_stats = await read_int(reader, 4)
            _size += 4

            # stats: ItemStat[amount_of_stats]
            stats = []
            for _ in range(0, amount_of_stats):
                stats.append(await ItemStat.read(reader))
                _size += 8

            # scaling_stats_entry: u32
            scaling_stats_entry = await read_int(reader, 4)
            _size += 4

            # scaling_stats_flag: u32
            scaling_stats_flag = await read_int(reader, 4)
            _size += 4

            # damages: ItemDamageType[2]
            damages = []
            for _ in range(0, 2):
                damages.append(await ItemDamageType.read(reader))
                _size += 12

            # armor: i32
            armor = await read_int(reader, 4)
            _size += 4

            # holy_resistance: i32
            holy_resistance = await read_int(reader, 4)
            _size += 4

            # fire_resistance: i32
            fire_resistance = await read_int(reader, 4)
            _size += 4

            # nature_resistance: i32
            nature_resistance = await read_int(reader, 4)
            _size += 4

            # frost_resistance: i32
            frost_resistance = await read_int(reader, 4)
            _size += 4

            # shadow_resistance: i32
            shadow_resistance = await read_int(reader, 4)
            _size += 4

            # arcane_resistance: i32
            arcane_resistance = await read_int(reader, 4)
            _size += 4

            # delay: u32
            delay = await read_int(reader, 4)
            _size += 4

            # ammo_type: u32
            ammo_type = await read_int(reader, 4)
            _size += 4

            # ranged_range_modification: f32
            ranged_range_modification = await read_float(reader)
            _size += 4

            # spells: ItemSpells[5]
            spells = []
            for _ in range(0, 5):
                spells.append(await ItemSpells.read(reader))
                _size += 24

            # bonding: Bonding
            bonding = Bonding(await read_int(reader, 4))
            _size += 4

            # description: CString
            description = await read_cstring(reader)
            _size += len(description) + 1

            # page_text: u32
            page_text = await read_int(reader, 4)
            _size += 4

            # language: Language
            language = Language(await read_int(reader, 4))
            _size += 4

            # page_text_material: PageTextMaterial
            page_text_material = PageTextMaterial(await read_int(reader, 4))
            _size += 4

            # start_quest: u32
            start_quest = await read_int(reader, 4)
            _size += 4

            # lock_id: u32
            lock_id = await read_int(reader, 4)
            _size += 4

            # material: u32
            material = await read_int(reader, 4)
            _size += 4

            # sheathe_type: SheatheType
            sheathe_type = SheatheType(await read_int(reader, 4))
            _size += 4

            # random_property: u32
            random_property = await read_int(reader, 4)
            _size += 4

            # random_suffix: u32
            random_suffix = await read_int(reader, 4)
            _size += 4

            # block: u32
            block = await read_int(reader, 4)
            _size += 4

            # item_set: ItemSet
            item_set = ItemSet(await read_int(reader, 4))
            _size += 4

            # max_durability: u32
            max_durability = await read_int(reader, 4)
            _size += 4

            # area: Area
            area = Area(await read_int(reader, 4))
            _size += 4

            # map: Map
            map = Map(await read_int(reader, 4))
            _size += 4

            # bag_family: BagFamily
            bag_family = BagFamily(await read_int(reader, 4))
            _size += 4

            # totem_category: u32
            totem_category = await read_int(reader, 4)
            _size += 4

            # sockets: ItemSocket[3]
            sockets = []
            for _ in range(0, 3):
                sockets.append(await ItemSocket.read(reader))
                _size += 8

            # socket_bonus: u32
            socket_bonus = await read_int(reader, 4)
            _size += 4

            # gem_properties: u32
            gem_properties = await read_int(reader, 4)
            _size += 4

            # required_disenchant_skill: u32
            required_disenchant_skill = await read_int(reader, 4)
            _size += 4

            # armor_damage_modifier: f32
            armor_damage_modifier = await read_float(reader)
            _size += 4

            # duration: Seconds
            duration = await read_int(reader, 4)
            _size += 4

            # item_limit_category: u32
            item_limit_category = await read_int(reader, 4)
            _size += 4

            # holiday_id: u32
            holiday_id = await read_int(reader, 4)
            _size += 4

        return SMSG_ITEM_QUERY_SINGLE_RESPONSE(
            item=item,
            class_and_sub_class=class_and_sub_class,
            sound_override_sub_class=sound_override_sub_class,
            name1=name1,
            name2=name2,
            name3=name3,
            name4=name4,
            display_id=display_id,
            quality=quality,
            flags=flags,
            flags2=flags2,
            buy_price=buy_price,
            sell_price=sell_price,
            inventory_type=inventory_type,
            allowed_class=allowed_class,
            allowed_race=allowed_race,
            item_level=item_level,
            required_level=required_level,
            required_skill=required_skill,
            required_skill_rank=required_skill_rank,
            required_spell=required_spell,
            required_honor_rank=required_honor_rank,
            required_city_rank=required_city_rank,
            required_faction=required_faction,
            required_faction_rank=required_faction_rank,
            max_count=max_count,
            stackable=stackable,
            container_slots=container_slots,
            stats=stats,
            scaling_stats_entry=scaling_stats_entry,
            scaling_stats_flag=scaling_stats_flag,
            damages=damages,
            armor=armor,
            holy_resistance=holy_resistance,
            fire_resistance=fire_resistance,
            nature_resistance=nature_resistance,
            frost_resistance=frost_resistance,
            shadow_resistance=shadow_resistance,
            arcane_resistance=arcane_resistance,
            delay=delay,
            ammo_type=ammo_type,
            ranged_range_modification=ranged_range_modification,
            spells=spells,
            bonding=bonding,
            description=description,
            page_text=page_text,
            language=language,
            page_text_material=page_text_material,
            start_quest=start_quest,
            lock_id=lock_id,
            material=material,
            sheathe_type=sheathe_type,
            random_property=random_property,
            random_suffix=random_suffix,
            block=block,
            item_set=item_set,
            max_durability=max_durability,
            area=area,
            map=map,
            bag_family=bag_family,
            totem_category=totem_category,
            sockets=sockets,
            socket_bonus=socket_bonus,
            gem_properties=gem_properties,
            required_disenchant_skill=required_disenchant_skill,
            armor_damage_modifier=armor_damage_modifier,
            duration=duration,
            item_limit_category=item_limit_category,
            holiday_id=holiday_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0058))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.item)
        # found: optional
        if self.class_and_sub_class is not None and self.sound_override_sub_class is not None and self.name1 is not None and self.name2 is not None and self.name3 is not None and self.name4 is not None and self.display_id is not None and self.quality is not None and self.flags is not None and self.flags2 is not None and self.buy_price is not None and self.sell_price is not None and self.inventory_type is not None and self.allowed_class is not None and self.allowed_race is not None and self.item_level is not None and self.required_level is not None and self.required_skill is not None and self.required_skill_rank is not None and self.required_spell is not None and self.required_honor_rank is not None and self.required_city_rank is not None and self.required_faction is not None and self.required_faction_rank is not None and self.max_count is not None and self.stackable is not None and self.container_slots is not None and self.stats is not None and self.scaling_stats_entry is not None and self.scaling_stats_flag is not None and self.damages is not None and self.armor is not None and self.holy_resistance is not None and self.fire_resistance is not None and self.nature_resistance is not None and self.frost_resistance is not None and self.shadow_resistance is not None and self.arcane_resistance is not None and self.delay is not None and self.ammo_type is not None and self.ranged_range_modification is not None and self.spells is not None and self.bonding is not None and self.description is not None and self.page_text is not None and self.language is not None and self.page_text_material is not None and self.start_quest is not None and self.lock_id is not None and self.material is not None and self.sheathe_type is not None and self.random_property is not None and self.random_suffix is not None and self.block is not None and self.item_set is not None and self.max_durability is not None and self.area is not None and self.map is not None and self.bag_family is not None and self.totem_category is not None and self.sockets is not None and self.socket_bonus is not None and self.gem_properties is not None and self.required_disenchant_skill is not None and self.armor_damage_modifier is not None and self.duration is not None and self.item_limit_category is not None and self.holiday_id is not None:
            _fmt += f'QI{len(self.name1)}sB{len(self.name2)}sB{len(self.name3)}sB{len(self.name4)}sBIIIIIIIIIIIIIIIIIIIIII'
            _data.extend([self.class_and_sub_class.value, self.sound_override_sub_class, self.name1.encode('utf-8'), 0, self.name2.encode('utf-8'), 0, self.name3.encode('utf-8'), 0, self.name4.encode('utf-8'), 0, self.display_id, self.quality.value, self.flags.value, self.flags2.value, self.buy_price, self.sell_price, self.inventory_type.value, self.allowed_class.value, self.allowed_race.value, self.item_level, self.required_level, self.required_skill.value, self.required_skill_rank, self.required_spell, self.required_honor_rank, self.required_city_rank, self.required_faction.value, self.required_faction_rank, self.max_count, self.stackable, self.container_slots, len(self.stats)])
            # stats: ItemStat[amount_of_stats]
            for i in self.stats:
                _fmt, _data = i.write(_fmt, _data)

            # scaling_stats_entry: u32
            _fmt += 'I'
            _data.append(self.scaling_stats_entry)

            # scaling_stats_flag: u32
            _fmt += 'I'
            _data.append(self.scaling_stats_flag)

            # damages: ItemDamageType[2]
            for i in self.damages:
                _fmt, _data = i.write(_fmt, _data)

            # armor: i32
            _fmt += 'i'
            _data.append(self.armor)

            # holy_resistance: i32
            _fmt += 'i'
            _data.append(self.holy_resistance)

            # fire_resistance: i32
            _fmt += 'i'
            _data.append(self.fire_resistance)

            # nature_resistance: i32
            _fmt += 'i'
            _data.append(self.nature_resistance)

            # frost_resistance: i32
            _fmt += 'i'
            _data.append(self.frost_resistance)

            # shadow_resistance: i32
            _fmt += 'i'
            _data.append(self.shadow_resistance)

            # arcane_resistance: i32
            _fmt += 'i'
            _data.append(self.arcane_resistance)

            # delay: u32
            _fmt += 'I'
            _data.append(self.delay)

            # ammo_type: u32
            _fmt += 'I'
            _data.append(self.ammo_type)

            # ranged_range_modification: f32
            _fmt += 'f'
            _data.append(self.ranged_range_modification)

            # spells: ItemSpells[5]
            for i in self.spells:
                _fmt, _data = i.write(_fmt, _data)

            # bonding: Bonding
            _fmt += 'I'
            _data.append(self.bonding.value)

            # description: CString
            _fmt += f'{len(self.description)}sB'
            _data.extend([self.description.encode('utf-8'), 0])

            # page_text: u32
            _fmt += 'I'
            _data.append(self.page_text)

            # language: Language
            _fmt += 'I'
            _data.append(self.language.value)

            # page_text_material: PageTextMaterial
            _fmt += 'I'
            _data.append(self.page_text_material.value)

            # start_quest: u32
            _fmt += 'I'
            _data.append(self.start_quest)

            # lock_id: u32
            _fmt += 'I'
            _data.append(self.lock_id)

            # material: u32
            _fmt += 'I'
            _data.append(self.material)

            # sheathe_type: SheatheType
            _fmt += 'I'
            _data.append(self.sheathe_type.value)

            # random_property: u32
            _fmt += 'I'
            _data.append(self.random_property)

            # random_suffix: u32
            _fmt += 'I'
            _data.append(self.random_suffix)

            # block: u32
            _fmt += 'I'
            _data.append(self.block)

            # item_set: ItemSet
            _fmt += 'I'
            _data.append(self.item_set.value)

            # max_durability: u32
            _fmt += 'I'
            _data.append(self.max_durability)

            # area: Area
            _fmt += 'I'
            _data.append(self.area.value)

            # map: Map
            _fmt += 'I'
            _data.append(self.map.value)

            # bag_family: BagFamily
            _fmt += 'I'
            _data.append(self.bag_family.value)

            # totem_category: u32
            _fmt += 'I'
            _data.append(self.totem_category)

            # sockets: ItemSocket[3]
            for i in self.sockets:
                _fmt, _data = i.write(_fmt, _data)

            # socket_bonus: u32
            _fmt += 'I'
            _data.append(self.socket_bonus)

            # gem_properties: u32
            _fmt += 'I'
            _data.append(self.gem_properties)

            # required_disenchant_skill: u32
            _fmt += 'I'
            _data.append(self.required_disenchant_skill)

            # armor_damage_modifier: f32
            _fmt += 'f'
            _data.append(self.armor_damage_modifier)

            # duration: Seconds
            _fmt += 'I'
            _data.append(self.duration)

            # item_limit_category: u32
            _fmt += 'I'
            _data.append(self.item_limit_category)

            # holiday_id: u32
            _fmt += 'I'
            _data.append(self.holiday_id)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        # found: optional
        if self.class_and_sub_class is not None and self.sound_override_sub_class is not None and self.name1 is not None and self.name2 is not None and self.name3 is not None and self.name4 is not None and self.display_id is not None and self.quality is not None and self.flags is not None and self.flags2 is not None and self.buy_price is not None and self.sell_price is not None and self.inventory_type is not None and self.allowed_class is not None and self.allowed_race is not None and self.item_level is not None and self.required_level is not None and self.required_skill is not None and self.required_skill_rank is not None and self.required_spell is not None and self.required_honor_rank is not None and self.required_city_rank is not None and self.required_faction is not None and self.required_faction_rank is not None and self.max_count is not None and self.stackable is not None and self.container_slots is not None and self.stats is not None and self.scaling_stats_entry is not None and self.scaling_stats_flag is not None and self.damages is not None and self.armor is not None and self.holy_resistance is not None and self.fire_resistance is not None and self.nature_resistance is not None and self.frost_resistance is not None and self.shadow_resistance is not None and self.arcane_resistance is not None and self.delay is not None and self.ammo_type is not None and self.ranged_range_modification is not None and self.spells is not None and self.bonding is not None and self.description is not None and self.page_text is not None and self.language is not None and self.page_text_material is not None and self.start_quest is not None and self.lock_id is not None and self.material is not None and self.sheathe_type is not None and self.random_property is not None and self.random_suffix is not None and self.block is not None and self.item_set is not None and self.max_durability is not None and self.area is not None and self.map is not None and self.bag_family is not None and self.totem_category is not None and self.sockets is not None and self.socket_bonus is not None and self.gem_properties is not None and self.required_disenchant_skill is not None and self.armor_damage_modifier is not None and self.duration is not None and self.item_limit_category is not None and self.holiday_id is not None:
            _size += 417 + len(self.name1) + len(self.name2) + len(self.name3) + len(self.name4) + 8 * len(self.stats) + len(self.description)

        return _size


@dataclasses.dataclass
class CMSG_PAGE_TEXT_QUERY:
    page_id: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PAGE_TEXT_QUERY:
        # page_id: u32
        page_id = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_PAGE_TEXT_QUERY(
            page_id=page_id,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x005A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.page_id, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PAGE_TEXT_QUERY_RESPONSE:
    page_id: int
    text: str
    next_page_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PAGE_TEXT_QUERY_RESPONSE:
        # page_id: u32
        page_id = await read_int(reader, 4)

        # text: CString
        text = await read_cstring(reader)

        # next_page_id: u32
        next_page_id = await read_int(reader, 4)

        return SMSG_PAGE_TEXT_QUERY_RESPONSE(
            page_id=page_id,
            text=text,
            next_page_id=next_page_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x005B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.text)}sBI'
        _data.extend([self.page_id, self.text.encode('utf-8'), 0, self.next_page_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.text)


@dataclasses.dataclass
class CMSG_QUEST_QUERY:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUEST_QUERY:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return CMSG_QUEST_QUERY(
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x005C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.quest_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUEST_QUERY_RESPONSE:
    quest_id: int
    quest_method: int
    quest_level: int
    minimum_quest_level: int
    zone_or_sort: int
    quest_type: int
    suggest_player_amount: int
    reputation_objective_faction: Faction
    reputation_objective_value: int
    required_opposite_faction: Faction
    required_opposite_reputation_value: int
    next_quest_in_chain: int
    money_reward: int
    max_level_money_reward: int
    reward_spell: int
    casted_reward_spell: int
    honor_reward: int
    honor_reward_multiplier: float
    source_item_id: int
    quest_flags: int
    title_reward: int
    players_slain: int
    bonus_talents: int
    bonus_arena_points: int
    unknown1: int
    rewards: typing.List[QuestItemReward]
    choice_rewards: typing.List[QuestItemReward]
    reputation_rewards: typing.List[int]
    reputation_reward_amounts: typing.List[int]
    reputation_reward_overrides: typing.List[int]
    point_map_id: int
    position: Vector2d
    point_opt: int
    title: str
    objective_text: str
    details: str
    end_text: str
    completed_text: str
    objectives: typing.List[QuestObjective]
    item_requirements: typing.List[QuestItemRequirement]
    objective_texts: typing.List[str]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUEST_QUERY_RESPONSE:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # quest_method: u32
        quest_method = await read_int(reader, 4)

        # quest_level: Level32
        quest_level = await read_int(reader, 4)

        # minimum_quest_level: Level32
        minimum_quest_level = await read_int(reader, 4)

        # zone_or_sort: u32
        zone_or_sort = await read_int(reader, 4)

        # quest_type: u32
        quest_type = await read_int(reader, 4)

        # suggest_player_amount: u32
        suggest_player_amount = await read_int(reader, 4)

        # reputation_objective_faction: Faction
        reputation_objective_faction = Faction(await read_int(reader, 2))

        # reputation_objective_value: u32
        reputation_objective_value = await read_int(reader, 4)

        # required_opposite_faction: Faction
        required_opposite_faction = Faction(await read_int(reader, 2))

        # required_opposite_reputation_value: u32
        required_opposite_reputation_value = await read_int(reader, 4)

        # next_quest_in_chain: u32
        next_quest_in_chain = await read_int(reader, 4)

        # money_reward: Gold
        money_reward = await read_int(reader, 4)

        # max_level_money_reward: Gold
        max_level_money_reward = await read_int(reader, 4)

        # reward_spell: u32
        reward_spell = await read_int(reader, 4)

        # casted_reward_spell: u32
        casted_reward_spell = await read_int(reader, 4)

        # honor_reward: u32
        honor_reward = await read_int(reader, 4)

        # honor_reward_multiplier: f32
        honor_reward_multiplier = await read_float(reader)

        # source_item_id: u32
        source_item_id = await read_int(reader, 4)

        # quest_flags: u32
        quest_flags = await read_int(reader, 4)

        # title_reward: u32
        title_reward = await read_int(reader, 4)

        # players_slain: u32
        players_slain = await read_int(reader, 4)

        # bonus_talents: u32
        bonus_talents = await read_int(reader, 4)

        # bonus_arena_points: u32
        bonus_arena_points = await read_int(reader, 4)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # rewards: QuestItemReward[4]
        rewards = []
        for _ in range(0, 4):
            rewards.append(await QuestItemReward.read(reader))

        # choice_rewards: QuestItemReward[6]
        choice_rewards = []
        for _ in range(0, 6):
            choice_rewards.append(await QuestItemReward.read(reader))

        # reputation_rewards: u32[5]
        reputation_rewards = []
        for _ in range(0, 5):
            reputation_rewards.append(await read_int(reader, 4))

        # reputation_reward_amounts: u32[5]
        reputation_reward_amounts = []
        for _ in range(0, 5):
            reputation_reward_amounts.append(await read_int(reader, 4))

        # reputation_reward_overrides: u32[5]
        reputation_reward_overrides = []
        for _ in range(0, 5):
            reputation_reward_overrides.append(await read_int(reader, 4))

        # point_map_id: u32
        point_map_id = await read_int(reader, 4)

        # position: Vector2d
        position = await Vector2d.read(reader)

        # point_opt: u32
        point_opt = await read_int(reader, 4)

        # title: CString
        title = await read_cstring(reader)

        # objective_text: CString
        objective_text = await read_cstring(reader)

        # details: CString
        details = await read_cstring(reader)

        # end_text: CString
        end_text = await read_cstring(reader)

        # completed_text: CString
        completed_text = await read_cstring(reader)

        # objectives: QuestObjective[4]
        objectives = []
        for _ in range(0, 4):
            objectives.append(await QuestObjective.read(reader))

        # item_requirements: QuestItemRequirement[6]
        item_requirements = []
        for _ in range(0, 6):
            item_requirements.append(await QuestItemRequirement.read(reader))

        # objective_texts: CString[4]
        objective_texts = []
        for _ in range(0, 4):
            objective_texts.append(await read_cstring(reader))

        return SMSG_QUEST_QUERY_RESPONSE(
            quest_id=quest_id,
            quest_method=quest_method,
            quest_level=quest_level,
            minimum_quest_level=minimum_quest_level,
            zone_or_sort=zone_or_sort,
            quest_type=quest_type,
            suggest_player_amount=suggest_player_amount,
            reputation_objective_faction=reputation_objective_faction,
            reputation_objective_value=reputation_objective_value,
            required_opposite_faction=required_opposite_faction,
            required_opposite_reputation_value=required_opposite_reputation_value,
            next_quest_in_chain=next_quest_in_chain,
            money_reward=money_reward,
            max_level_money_reward=max_level_money_reward,
            reward_spell=reward_spell,
            casted_reward_spell=casted_reward_spell,
            honor_reward=honor_reward,
            honor_reward_multiplier=honor_reward_multiplier,
            source_item_id=source_item_id,
            quest_flags=quest_flags,
            title_reward=title_reward,
            players_slain=players_slain,
            bonus_talents=bonus_talents,
            bonus_arena_points=bonus_arena_points,
            unknown1=unknown1,
            rewards=rewards,
            choice_rewards=choice_rewards,
            reputation_rewards=reputation_rewards,
            reputation_reward_amounts=reputation_reward_amounts,
            reputation_reward_overrides=reputation_reward_overrides,
            point_map_id=point_map_id,
            position=position,
            point_opt=point_opt,
            title=title,
            objective_text=objective_text,
            details=details,
            end_text=end_text,
            completed_text=completed_text,
            objectives=objectives,
            item_requirements=item_requirements,
            objective_texts=objective_texts,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x005D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIIIIIHIHIIIIIIIfIIIIIII'
        _data.extend([self.quest_id, self.quest_method, self.quest_level, self.minimum_quest_level, self.zone_or_sort, self.quest_type, self.suggest_player_amount, self.reputation_objective_faction.value, self.reputation_objective_value, self.required_opposite_faction.value, self.required_opposite_reputation_value, self.next_quest_in_chain, self.money_reward, self.max_level_money_reward, self.reward_spell, self.casted_reward_spell, self.honor_reward, self.honor_reward_multiplier, self.source_item_id, self.quest_flags, self.title_reward, self.players_slain, self.bonus_talents, self.bonus_arena_points, self.unknown1])
        # rewards: QuestItemReward[4]
        for i in self.rewards:
            _fmt, _data = i.write(_fmt, _data)

        # choice_rewards: QuestItemReward[6]
        for i in self.choice_rewards:
            _fmt, _data = i.write(_fmt, _data)

        # reputation_rewards: u32[5]
        _fmt += f'{len(self.reputation_rewards)}I'
        _data.extend([*self.reputation_rewards])

        # reputation_reward_amounts: u32[5]
        _fmt += f'{len(self.reputation_reward_amounts)}I'
        _data.extend([*self.reputation_reward_amounts])

        # reputation_reward_overrides: u32[5]
        _fmt += f'{len(self.reputation_reward_overrides)}I'
        _data.extend([*self.reputation_reward_overrides])

        # point_map_id: u32
        _fmt += 'I'
        _data.append(self.point_map_id)

        # position: Vector2d
        _fmt, _data = self.position.write(_fmt, _data)

        # point_opt: u32
        _fmt += 'I'
        _data.append(self.point_opt)

        # title: CString
        _fmt += f'{len(self.title)}sB'
        _data.extend([self.title.encode('utf-8'), 0])

        # objective_text: CString
        _fmt += f'{len(self.objective_text)}sB'
        _data.extend([self.objective_text.encode('utf-8'), 0])

        # details: CString
        _fmt += f'{len(self.details)}sB'
        _data.extend([self.details.encode('utf-8'), 0])

        # end_text: CString
        _fmt += f'{len(self.end_text)}sB'
        _data.extend([self.end_text.encode('utf-8'), 0])

        # completed_text: CString
        _fmt += f'{len(self.completed_text)}sB'
        _data.extend([self.completed_text.encode('utf-8'), 0])

        # objectives: QuestObjective[4]
        for i in self.objectives:
            _fmt, _data = i.write(_fmt, _data)

        # item_requirements: QuestItemRequirement[6]
        for i in self.item_requirements:
            _fmt, _data = i.write(_fmt, _data)

        # objective_texts: CString[4]
        for i in self.objective_texts:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 393 + len(self.title) + len(self.objective_text) + len(self.details) + len(self.end_text) + len(self.completed_text) + sum([len(i) + 1 for i in self.objective_texts])


@dataclasses.dataclass
class CMSG_GAMEOBJECT_QUERY:
    entry_id: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GAMEOBJECT_QUERY:
        # entry_id: u32
        entry_id = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_GAMEOBJECT_QUERY(
            entry_id=entry_id,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x005E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.entry_id, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GAMEOBJECT_QUERY_RESPONSE:
    entry_id: int
    info_type: typing.Optional[int] = None
    display_id: typing.Optional[int] = None
    name1: typing.Optional[str] = None
    name2: typing.Optional[str] = None
    name3: typing.Optional[str] = None
    name4: typing.Optional[str] = None
    icon_name: typing.Optional[str] = None
    cast_bar_caption: typing.Optional[str] = None
    unknown: typing.Optional[str] = None
    raw_data: typing.Optional[typing.List[int]] = None
    gameobject_size: typing.Optional[float] = None
    gameobject_quest_items: typing.Optional[typing.List[int]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GAMEOBJECT_QUERY_RESPONSE:
        info_type = None
        display_id = None
        name1 = None
        name2 = None
        name3 = None
        name4 = None
        icon_name = None
        cast_bar_caption = None
        unknown = None
        raw_data = None
        gameobject_size = None
        gameobject_quest_items = None
        _size = 0

        # entry_id: u32
        entry_id = await read_int(reader, 4)
        _size += 4

        # found: optional
        if _size < body_size:
            # info_type: u32
            info_type = await read_int(reader, 4)
            _size += 4

            # display_id: u32
            display_id = await read_int(reader, 4)
            _size += 4

            # name1: CString
            name1 = await read_cstring(reader)
            _size += len(name1) + 1

            # name2: CString
            name2 = await read_cstring(reader)
            _size += len(name2) + 1

            # name3: CString
            name3 = await read_cstring(reader)
            _size += len(name3) + 1

            # name4: CString
            name4 = await read_cstring(reader)
            _size += len(name4) + 1

            # icon_name: CString
            icon_name = await read_cstring(reader)
            _size += len(icon_name) + 1

            # cast_bar_caption: CString
            cast_bar_caption = await read_cstring(reader)
            _size += len(cast_bar_caption) + 1

            # unknown: CString
            unknown = await read_cstring(reader)
            _size += len(unknown) + 1

            # raw_data: u32[6]
            raw_data = []
            for _ in range(0, 6):
                raw_data.append(await read_int(reader, 4))
                _size += 4

            # gameobject_size: f32
            gameobject_size = await read_float(reader)
            _size += 4

            # gameobject_quest_items: u32[6]
            gameobject_quest_items = []
            for _ in range(0, 6):
                gameobject_quest_items.append(await read_int(reader, 4))
                _size += 4

        return SMSG_GAMEOBJECT_QUERY_RESPONSE(
            entry_id=entry_id,
            info_type=info_type,
            display_id=display_id,
            name1=name1,
            name2=name2,
            name3=name3,
            name4=name4,
            icon_name=icon_name,
            cast_bar_caption=cast_bar_caption,
            unknown=unknown,
            raw_data=raw_data,
            gameobject_size=gameobject_size,
            gameobject_quest_items=gameobject_quest_items,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x005F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.entry_id)
        # found: optional
        if self.info_type is not None and self.display_id is not None and self.name1 is not None and self.name2 is not None and self.name3 is not None and self.name4 is not None and self.icon_name is not None and self.cast_bar_caption is not None and self.unknown is not None and self.raw_data is not None and self.gameobject_size is not None and self.gameobject_quest_items is not None:
            _fmt += f'II{len(self.name1)}sB{len(self.name2)}sB{len(self.name3)}sB{len(self.name4)}sB{len(self.icon_name)}sB{len(self.cast_bar_caption)}sB{len(self.unknown)}sB{len(self.raw_data)}If{len(self.gameobject_quest_items)}I'
            _data.extend([self.info_type, self.display_id, self.name1.encode('utf-8'), 0, self.name2.encode('utf-8'), 0, self.name3.encode('utf-8'), 0, self.name4.encode('utf-8'), 0, self.icon_name.encode('utf-8'), 0, self.cast_bar_caption.encode('utf-8'), 0, self.unknown.encode('utf-8'), 0, *self.raw_data, self.gameobject_size, *self.gameobject_quest_items])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        # found: optional
        if self.info_type is not None and self.display_id is not None and self.name1 is not None and self.name2 is not None and self.name3 is not None and self.name4 is not None and self.icon_name is not None and self.cast_bar_caption is not None and self.unknown is not None and self.raw_data is not None and self.gameobject_size is not None and self.gameobject_quest_items is not None:
            _size += 67 + len(self.name1) + len(self.name2) + len(self.name3) + len(self.name4) + len(self.icon_name) + len(self.cast_bar_caption) + len(self.unknown)

        return _size


@dataclasses.dataclass
class CMSG_CREATURE_QUERY:
    creature: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CREATURE_QUERY:
        # creature: u32
        creature = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_CREATURE_QUERY(
            creature=creature,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0060))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.creature, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CREATURE_QUERY_RESPONSE:
    creature_entry: int
    name1: typing.Optional[str] = None
    name2: typing.Optional[str] = None
    name3: typing.Optional[str] = None
    name4: typing.Optional[str] = None
    sub_name: typing.Optional[str] = None
    description: typing.Optional[str] = None
    type_flags: typing.Optional[int] = None
    creature_type: typing.Optional[int] = None
    creature_family: typing.Optional[CreatureFamily] = None
    creature_rank: typing.Optional[int] = None
    kill_credit1: typing.Optional[int] = None
    kill_credit2: typing.Optional[int] = None
    display_ids: typing.Optional[typing.List[int]] = None
    health_multiplier: typing.Optional[float] = None
    mana_multiplier: typing.Optional[float] = None
    racial_leader: typing.Optional[int] = None
    quest_items: typing.Optional[typing.List[int]] = None
    movement_id: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CREATURE_QUERY_RESPONSE:
        name1 = None
        name2 = None
        name3 = None
        name4 = None
        sub_name = None
        description = None
        type_flags = None
        creature_type = None
        creature_family = None
        creature_rank = None
        kill_credit1 = None
        kill_credit2 = None
        display_ids = None
        health_multiplier = None
        mana_multiplier = None
        racial_leader = None
        quest_items = None
        movement_id = None
        _size = 0

        # creature_entry: u32
        creature_entry = await read_int(reader, 4)
        _size += 4

        # found: optional
        if _size < body_size:
            # name1: CString
            name1 = await read_cstring(reader)
            _size += len(name1) + 1

            # name2: CString
            name2 = await read_cstring(reader)
            _size += len(name2) + 1

            # name3: CString
            name3 = await read_cstring(reader)
            _size += len(name3) + 1

            # name4: CString
            name4 = await read_cstring(reader)
            _size += len(name4) + 1

            # sub_name: CString
            sub_name = await read_cstring(reader)
            _size += len(sub_name) + 1

            # description: CString
            description = await read_cstring(reader)
            _size += len(description) + 1

            # type_flags: u32
            type_flags = await read_int(reader, 4)
            _size += 4

            # creature_type: u32
            creature_type = await read_int(reader, 4)
            _size += 4

            # creature_family: CreatureFamily
            creature_family = CreatureFamily(await read_int(reader, 4))
            _size += 4

            # creature_rank: u32
            creature_rank = await read_int(reader, 4)
            _size += 4

            # kill_credit1: u32
            kill_credit1 = await read_int(reader, 4)
            _size += 4

            # kill_credit2: u32
            kill_credit2 = await read_int(reader, 4)
            _size += 4

            # display_ids: u32[4]
            display_ids = []
            for _ in range(0, 4):
                display_ids.append(await read_int(reader, 4))
                _size += 4

            # health_multiplier: f32
            health_multiplier = await read_float(reader)
            _size += 4

            # mana_multiplier: f32
            mana_multiplier = await read_float(reader)
            _size += 4

            # racial_leader: u8
            racial_leader = await read_int(reader, 1)
            _size += 1

            # quest_items: u32[6]
            quest_items = []
            for _ in range(0, 6):
                quest_items.append(await read_int(reader, 4))
                _size += 4

            # movement_id: u32
            movement_id = await read_int(reader, 4)
            _size += 4

        return SMSG_CREATURE_QUERY_RESPONSE(
            creature_entry=creature_entry,
            name1=name1,
            name2=name2,
            name3=name3,
            name4=name4,
            sub_name=sub_name,
            description=description,
            type_flags=type_flags,
            creature_type=creature_type,
            creature_family=creature_family,
            creature_rank=creature_rank,
            kill_credit1=kill_credit1,
            kill_credit2=kill_credit2,
            display_ids=display_ids,
            health_multiplier=health_multiplier,
            mana_multiplier=mana_multiplier,
            racial_leader=racial_leader,
            quest_items=quest_items,
            movement_id=movement_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0061))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.creature_entry)
        # found: optional
        if self.name1 is not None and self.name2 is not None and self.name3 is not None and self.name4 is not None and self.sub_name is not None and self.description is not None and self.type_flags is not None and self.creature_type is not None and self.creature_family is not None and self.creature_rank is not None and self.kill_credit1 is not None and self.kill_credit2 is not None and self.display_ids is not None and self.health_multiplier is not None and self.mana_multiplier is not None and self.racial_leader is not None and self.quest_items is not None and self.movement_id is not None:
            _fmt += f'{len(self.name1)}sB{len(self.name2)}sB{len(self.name3)}sB{len(self.name4)}sB{len(self.sub_name)}sB{len(self.description)}sBIIIIII{len(self.display_ids)}IffB{len(self.quest_items)}II'
            _data.extend([self.name1.encode('utf-8'), 0, self.name2.encode('utf-8'), 0, self.name3.encode('utf-8'), 0, self.name4.encode('utf-8'), 0, self.sub_name.encode('utf-8'), 0, self.description.encode('utf-8'), 0, self.type_flags, self.creature_type, self.creature_family.value, self.creature_rank, self.kill_credit1, self.kill_credit2, *self.display_ids, self.health_multiplier, self.mana_multiplier, self.racial_leader, *self.quest_items, self.movement_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        # found: optional
        if self.name1 is not None and self.name2 is not None and self.name3 is not None and self.name4 is not None and self.sub_name is not None and self.description is not None and self.type_flags is not None and self.creature_type is not None and self.creature_family is not None and self.creature_rank is not None and self.kill_credit1 is not None and self.kill_credit2 is not None and self.display_ids is not None and self.health_multiplier is not None and self.mana_multiplier is not None and self.racial_leader is not None and self.quest_items is not None and self.movement_id is not None:
            _size += 83 + len(self.name1) + len(self.name2) + len(self.name3) + len(self.name4) + len(self.sub_name) + len(self.description)

        return _size


@dataclasses.dataclass
class CMSG_WHO:
    minimum_level: int
    maximum_level: int
    player_name: str
    guild_name: str
    race_mask: int
    class_mask: int
    zones: typing.List[int]
    search_strings: typing.List[str]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_WHO:
        # minimum_level: Level32
        minimum_level = await read_int(reader, 4)

        # maximum_level: Level32
        maximum_level = await read_int(reader, 4)

        # player_name: CString
        player_name = await read_cstring(reader)

        # guild_name: CString
        guild_name = await read_cstring(reader)

        # race_mask: u32
        race_mask = await read_int(reader, 4)

        # class_mask: u32
        class_mask = await read_int(reader, 4)

        # amount_of_zones: u32
        amount_of_zones = await read_int(reader, 4)

        # zones: u32[amount_of_zones]
        zones = []
        for _ in range(0, amount_of_zones):
            zones.append(await read_int(reader, 4))

        # amount_of_strings: u32
        amount_of_strings = await read_int(reader, 4)

        # search_strings: CString[amount_of_strings]
        search_strings = []
        for _ in range(0, amount_of_strings):
            search_strings.append(await read_cstring(reader))

        return CMSG_WHO(
            minimum_level=minimum_level,
            maximum_level=maximum_level,
            player_name=player_name,
            guild_name=guild_name,
            race_mask=race_mask,
            class_mask=class_mask,
            zones=zones,
            search_strings=search_strings,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0062))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'II{len(self.player_name)}sB{len(self.guild_name)}sBIII{len(self.zones)}II'
        _data.extend([self.minimum_level, self.maximum_level, self.player_name.encode('utf-8'), 0, self.guild_name.encode('utf-8'), 0, self.race_mask, self.class_mask, len(self.zones), *self.zones, len(self.search_strings)])
        # search_strings: CString[amount_of_strings]
        for i in self.search_strings:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 26 + len(self.player_name) + len(self.guild_name) + 4 * len(self.zones) + sum([len(i) + 1 for i in self.search_strings])


@dataclasses.dataclass
class SMSG_WHO:
    online_players: int
    players: typing.List[WhoPlayer]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_WHO:
        # listed_players: u32
        listed_players = await read_int(reader, 4)

        # online_players: u32
        online_players = await read_int(reader, 4)

        # players: WhoPlayer[listed_players]
        players = []
        for _ in range(0, listed_players):
            players.append(await WhoPlayer.read(reader))

        return SMSG_WHO(
            online_players=online_players,
            players=players,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0063))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([len(self.players), self.online_players])
        # players: WhoPlayer[listed_players]
        for i in self.players:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + sum([i.size() for i in self.players])


@dataclasses.dataclass
class CMSG_WHOIS:
    character: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_WHOIS:
        # character: CString
        character = await read_cstring(reader)

        return CMSG_WHOIS(
            character=character,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0064))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.character)}sB'
        _data.extend([self.character.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.character)


@dataclasses.dataclass
class SMSG_WHOIS:
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_WHOIS:
        # message: CString
        message = await read_cstring(reader)

        return SMSG_WHOIS(
            message=message,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0065))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.message)}sB'
        _data.extend([self.message.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.message)


@dataclasses.dataclass
class CMSG_CONTACT_LIST:
    flags: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CONTACT_LIST:
        # flags: u32
        flags = await read_int(reader, 4)

        return CMSG_CONTACT_LIST(
            flags=flags,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0066))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.flags)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CONTACT_LIST:
    list_mask: RelationType
    relations: typing.List[Relation]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CONTACT_LIST:
        # list_mask: RelationType
        list_mask = RelationType(await read_int(reader, 4))

        # amount_of_relations: u32
        amount_of_relations = await read_int(reader, 4)

        # relations: Relation[amount_of_relations]
        relations = []
        for _ in range(0, amount_of_relations):
            relations.append(await Relation.read(reader))

        return SMSG_CONTACT_LIST(
            list_mask=list_mask,
            relations=relations,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0067))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.list_mask.value, len(self.relations)])
        # relations: Relation[amount_of_relations]
        for i in self.relations:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + sum([i.size() for i in self.relations])


@dataclasses.dataclass
class SMSG_FRIEND_STATUS:
    result: FriendResult
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FRIEND_STATUS:
        # result: FriendResult
        result = FriendResult(await read_int(reader, 1))

        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_FRIEND_STATUS(
            result=result,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x0068))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BQ'
        _data.extend([self.result.value, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ADD_FRIEND:
    name: str
    note: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ADD_FRIEND:
        # name: CString
        name = await read_cstring(reader)

        # note: CString
        note = await read_cstring(reader)

        return CMSG_ADD_FRIEND(
            name=name,
            note=note,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0069))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB{len(self.note)}sB'
        _data.extend([self.name.encode('utf-8'), 0, self.note.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.name) + len(self.note)


@dataclasses.dataclass
class CMSG_DEL_FRIEND:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_DEL_FRIEND:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_DEL_FRIEND(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x006A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_CONTACT_NOTES:
    player: int
    note: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_CONTACT_NOTES:
        # player: Guid
        player = await read_int(reader, 8)

        # note: CString
        note = await read_cstring(reader)

        return CMSG_SET_CONTACT_NOTES(
            player=player,
            note=note,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x006B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.note)}sB'
        _data.extend([self.player, self.note.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.note)


@dataclasses.dataclass
class CMSG_ADD_IGNORE:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ADD_IGNORE:
        # name: CString
        name = await read_cstring(reader)

        return CMSG_ADD_IGNORE(
            name=name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x006C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class CMSG_DEL_IGNORE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_DEL_IGNORE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_DEL_IGNORE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x006D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_INVITE:
    name: str
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_INVITE:
        # name: CString
        name = await read_cstring(reader)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return CMSG_GROUP_INVITE(
            name=name,
            unknown1=unknown1,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x006E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sBI'
        _data.extend([self.name.encode('utf-8'), 0, self.unknown1])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + len(self.name)


@dataclasses.dataclass
class SMSG_GROUP_INVITE:
    status: PlayerInviteStatus
    name: str
    unknown1: typing.Optional[int] = None
    count: typing.Optional[int] = None
    unknown2: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GROUP_INVITE:
        unknown1 = None
        count = None
        unknown2 = None
        _size = 0

        # status: PlayerInviteStatus
        status = PlayerInviteStatus(await read_int(reader, 1))
        _size += 1

        # name: CString
        name = await read_cstring(reader)
        _size += len(name) + 1

        # unknown: optional
        if _size < body_size:
            # unknown1: u32
            unknown1 = await read_int(reader, 4)
            _size += 4

            # count: u8
            count = await read_int(reader, 1)
            _size += 1

            # unknown2: u32
            unknown2 = await read_int(reader, 4)
            _size += 4

        return SMSG_GROUP_INVITE(
            status=status,
            name=name,
            unknown1=unknown1,
            count=count,
            unknown2=unknown2,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x006F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'B{len(self.name)}sB'
        _data.extend([self.status.value, self.name.encode('utf-8'), 0])
        # unknown: optional
        if self.unknown1 is not None and self.count is not None and self.unknown2 is not None:
            _fmt += 'IBI'
            _data.extend([self.unknown1, self.count, self.unknown2])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 2 + len(self.name)

        # unknown: optional
        if self.unknown1 is not None and self.count is not None and self.unknown2 is not None:
            _size += 9

        return _size


@dataclasses.dataclass
class CMSG_GROUP_CANCEL:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_CANCEL:
        return CMSG_GROUP_CANCEL()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0070))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_ACCEPT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_ACCEPT:
        return CMSG_GROUP_ACCEPT()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0072))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_DECLINE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_DECLINE:
        return CMSG_GROUP_DECLINE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0073))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GROUP_DECLINE:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GROUP_DECLINE:
        # name: CString
        name = await read_cstring(reader)

        return SMSG_GROUP_DECLINE(
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0074))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class CMSG_GROUP_UNINVITE:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_UNINVITE:
        # name: CString
        name = await read_cstring(reader)

        return CMSG_GROUP_UNINVITE(
            name=name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0075))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class CMSG_GROUP_UNINVITE_GUID:
    guid: int
    reason: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_UNINVITE_GUID:
        # guid: Guid
        guid = await read_int(reader, 8)

        # reason: CString
        reason = await read_cstring(reader)

        return CMSG_GROUP_UNINVITE_GUID(
            guid=guid,
            reason=reason,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0076))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.reason)}sB'
        _data.extend([self.guid, self.reason.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.reason)


@dataclasses.dataclass
class SMSG_GROUP_UNINVITE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GROUP_UNINVITE:
        return SMSG_GROUP_UNINVITE()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0077))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_SET_LEADER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_SET_LEADER:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_GROUP_SET_LEADER(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0078))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GROUP_SET_LEADER:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GROUP_SET_LEADER:
        # name: CString
        name = await read_cstring(reader)

        return SMSG_GROUP_SET_LEADER(
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0079))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class CMSG_LOOT_METHOD:
    loot_setting: GroupLootSetting
    loot_master: int
    loot_threshold: ItemQuality

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOOT_METHOD:
        # loot_setting: GroupLootSetting
        loot_setting = GroupLootSetting(await read_int(reader, 4))

        # loot_master: Guid
        loot_master = await read_int(reader, 8)

        # loot_threshold: ItemQuality
        loot_threshold = ItemQuality(await read_int(reader, 4))

        return CMSG_LOOT_METHOD(
            loot_setting=loot_setting,
            loot_master=loot_master,
            loot_threshold=loot_threshold,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x007A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQI'
        _data.extend([self.loot_setting.value, self.loot_master, self.loot_threshold.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_DISBAND:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_DISBAND:
        return CMSG_GROUP_DISBAND()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x007B))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GROUP_DESTROYED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GROUP_DESTROYED:
        return SMSG_GROUP_DESTROYED()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x007C))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GROUP_LIST:
    group_type: int
    group_id: int
    flags: int
    roles: int
    group: int
    counter: int
    members: typing.List[GroupListMember]
    leader: int
    loot_setting: typing.Optional[GroupLootSetting] = None
    master_loot: typing.Optional[int] = None
    loot_threshold: typing.Optional[ItemQuality] = None
    difficulty: typing.Optional[DungeonDifficulty] = None
    raid_difficulty: typing.Optional[RaidDifficulty] = None
    heroic: typing.Optional[bool] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GROUP_LIST:
        loot_setting = None
        master_loot = None
        loot_threshold = None
        difficulty = None
        raid_difficulty = None
        heroic = None
        _size = 0

        # group_type: u8
        group_type = await read_int(reader, 1)
        _size += 1

        # group_id: u8
        group_id = await read_int(reader, 1)
        _size += 1

        # flags: u8
        flags = await read_int(reader, 1)
        _size += 1

        # roles: u8
        roles = await read_int(reader, 1)
        _size += 1

        # group: Guid
        group = await read_int(reader, 8)
        _size += 8

        # counter: u32
        counter = await read_int(reader, 4)
        _size += 4

        # amount_of_members: u32
        amount_of_members = await read_int(reader, 4)
        _size += 4

        # members: GroupListMember[amount_of_members]
        members = []
        for _ in range(0, amount_of_members):
            members.append(await GroupListMember.read(reader))
            _size += members[-1].size()

        # leader: Guid
        leader = await read_int(reader, 8)
        _size += 8

        # group_not_empty: optional
        if _size < body_size:
            # loot_setting: GroupLootSetting
            loot_setting = GroupLootSetting(await read_int(reader, 1))
            _size += 1

            # master_loot: Guid
            master_loot = await read_int(reader, 8)
            _size += 8

            # loot_threshold: ItemQuality
            loot_threshold = ItemQuality(await read_int(reader, 1))
            _size += 1

            # difficulty: DungeonDifficulty
            difficulty = DungeonDifficulty(await read_int(reader, 1))
            _size += 1

            # raid_difficulty: RaidDifficulty
            raid_difficulty = RaidDifficulty(await read_int(reader, 1))
            _size += 1

            # heroic: Bool8
            heroic = await read_bool(reader, 1)
            _size += 1

        return SMSG_GROUP_LIST(
            group_type=group_type,
            group_id=group_id,
            flags=flags,
            roles=roles,
            group=group,
            counter=counter,
            members=members,
            leader=leader,
            loot_setting=loot_setting,
            master_loot=master_loot,
            loot_threshold=loot_threshold,
            difficulty=difficulty,
            raid_difficulty=raid_difficulty,
            heroic=heroic,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x007D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BBBBQII'
        _data.extend([self.group_type, self.group_id, self.flags, self.roles, self.group, self.counter, len(self.members)])
        # members: GroupListMember[amount_of_members]
        for i in self.members:
            _fmt, _data = i.write(_fmt, _data)

        # leader: Guid
        _fmt += 'Q'
        _data.append(self.leader)

        # group_not_empty: optional
        if self.loot_setting is not None and self.master_loot is not None and self.loot_threshold is not None and self.difficulty is not None and self.raid_difficulty is not None and self.heroic is not None:
            _fmt += 'BQBBBB'
            _data.extend([self.loot_setting.value, self.master_loot, self.loot_threshold.value, self.difficulty.value, self.raid_difficulty.value, self.heroic])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 28 + sum([i.size() for i in self.members])

        # group_not_empty: optional
        if self.loot_setting is not None and self.master_loot is not None and self.loot_threshold is not None and self.difficulty is not None and self.raid_difficulty is not None and self.heroic is not None:
            _size += 13

        return _size


@dataclasses.dataclass
class SMSG_PARTY_MEMBER_STATS:
    guid: int
    mask: GroupUpdateFlags
    status: typing.Optional[GroupMemberOnlineStatus] = None
    current_health: typing.Optional[int] = None
    max_health: typing.Optional[int] = None
    power: typing.Optional[Power] = None
    current_power: typing.Optional[int] = None
    max_power: typing.Optional[int] = None
    level: typing.Optional[int] = None
    area: typing.Optional[Area] = None
    position_x: typing.Optional[int] = None
    position_y: typing.Optional[int] = None
    auras: typing.Optional[AuraMask] = None
    pet: typing.Optional[int] = None
    pet_name: typing.Optional[str] = None
    pet_display_id: typing.Optional[int] = None
    pet_current_health: typing.Optional[int] = None
    pet_max_health: typing.Optional[int] = None
    pet_power_type: typing.Optional[Power] = None
    pet_current_power: typing.Optional[int] = None
    pet_max_power: typing.Optional[int] = None
    pet_auras: typing.Optional[AuraMask] = None
    transport: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PARTY_MEMBER_STATS:
        status = None
        current_health = None
        max_health = None
        power = None
        current_power = None
        max_power = None
        level = None
        area = None
        position_x = None
        position_y = None
        auras = None
        pet = None
        pet_name = None
        pet_display_id = None
        pet_current_health = None
        pet_max_health = None
        pet_power_type = None
        pet_current_power = None
        pet_max_power = None
        pet_auras = None
        transport = None
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # mask: GroupUpdateFlags
        mask = GroupUpdateFlags(await read_int(reader, 4))

        if GroupUpdateFlags.STATUS in mask:
            # status: GroupMemberOnlineStatus
            status = GroupMemberOnlineStatus(await read_int(reader, 1))

        if GroupUpdateFlags.CUR_HP in mask:
            # current_health: u32
            current_health = await read_int(reader, 4)

        if GroupUpdateFlags.MAX_HP in mask:
            # max_health: u32
            max_health = await read_int(reader, 4)

        if GroupUpdateFlags.POWER_TYPE in mask:
            # power: Power
            power = Power(await read_int(reader, 1))

        if GroupUpdateFlags.CUR_POWER in mask:
            # current_power: u16
            current_power = await read_int(reader, 2)

        if GroupUpdateFlags.MAX_POWER in mask:
            # max_power: u16
            max_power = await read_int(reader, 2)

        if GroupUpdateFlags.LEVEL in mask:
            # level: Level16
            level = await read_int(reader, 2)

        if GroupUpdateFlags.ZONE in mask:
            # area: Area
            area = Area(await read_int(reader, 4))

        if GroupUpdateFlags.POSITION in mask:
            # position_x: u16
            position_x = await read_int(reader, 2)

            # position_y: u16
            position_y = await read_int(reader, 2)

        if GroupUpdateFlags.AURAS in mask:
            # auras: AuraMask
            auras = await AuraMask.read(reader)

        if GroupUpdateFlags.PET_GUID in mask:
            # pet: Guid
            pet = await read_int(reader, 8)

        if GroupUpdateFlags.PET_NAME in mask:
            # pet_name: CString
            pet_name = await read_cstring(reader)

        if GroupUpdateFlags.PET_MODEL_ID in mask:
            # pet_display_id: u16
            pet_display_id = await read_int(reader, 2)

        if GroupUpdateFlags.PET_CUR_HP in mask:
            # pet_current_health: u32
            pet_current_health = await read_int(reader, 4)

        if GroupUpdateFlags.PET_MAX_HP in mask:
            # pet_max_health: u32
            pet_max_health = await read_int(reader, 4)

        if GroupUpdateFlags.PET_POWER_TYPE in mask:
            # pet_power_type: Power
            pet_power_type = Power(await read_int(reader, 1))

        if GroupUpdateFlags.PET_CUR_POWER in mask:
            # pet_current_power: u16
            pet_current_power = await read_int(reader, 2)

        if GroupUpdateFlags.PET_MAX_POWER in mask:
            # pet_max_power: u16
            pet_max_power = await read_int(reader, 2)

        if GroupUpdateFlags.PET_AURAS in mask:
            # pet_auras: AuraMask
            pet_auras = await AuraMask.read(reader)

        if GroupUpdateFlags.VEHICLE_SEAT in mask:
            # transport: u32
            transport = await read_int(reader, 4)

        return SMSG_PARTY_MEMBER_STATS(
            guid=guid,
            mask=mask,
            status=status,
            current_health=current_health,
            max_health=max_health,
            power=power,
            current_power=current_power,
            max_power=max_power,
            level=level,
            area=area,
            position_x=position_x,
            position_y=position_y,
            auras=auras,
            pet=pet,
            pet_name=pet_name,
            pet_display_id=pet_display_id,
            pet_current_health=pet_current_health,
            pet_max_health=pet_max_health,
            pet_power_type=pet_power_type,
            pet_current_power=pet_current_power,
            pet_max_power=pet_max_power,
            pet_auras=pet_auras,
            transport=transport,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x007E))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # mask: GroupUpdateFlags
        _fmt += 'I'
        _data.append(self.mask.value)

        if GroupUpdateFlags.STATUS in self.mask:
            _fmt += 'B'
            _data.append(self.status.value)
        if GroupUpdateFlags.CUR_HP in self.mask:
            _fmt += 'I'
            _data.append(self.current_health)
        if GroupUpdateFlags.MAX_HP in self.mask:
            _fmt += 'I'
            _data.append(self.max_health)
        if GroupUpdateFlags.POWER_TYPE in self.mask:
            _fmt += 'B'
            _data.append(self.power.value)
        if GroupUpdateFlags.CUR_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.current_power)
        if GroupUpdateFlags.MAX_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.max_power)
        if GroupUpdateFlags.LEVEL in self.mask:
            _fmt += 'H'
            _data.append(self.level)
        if GroupUpdateFlags.ZONE in self.mask:
            _fmt += 'I'
            _data.append(self.area.value)
        if GroupUpdateFlags.POSITION in self.mask:
            _fmt += 'HH'
            _data.extend([self.position_x, self.position_y])
        if GroupUpdateFlags.AURAS in self.mask:
            # auras: AuraMask
            _fmt, _data = self.auras.write(_fmt, _data)

        if GroupUpdateFlags.PET_GUID in self.mask:
            _fmt += 'Q'
            _data.append(self.pet)
        if GroupUpdateFlags.PET_NAME in self.mask:
            _fmt += f'{len(self.pet_name)}sB'
            _data.extend([self.pet_name.encode('utf-8'), 0])
        if GroupUpdateFlags.PET_MODEL_ID in self.mask:
            _fmt += 'H'
            _data.append(self.pet_display_id)
        if GroupUpdateFlags.PET_CUR_HP in self.mask:
            _fmt += 'I'
            _data.append(self.pet_current_health)
        if GroupUpdateFlags.PET_MAX_HP in self.mask:
            _fmt += 'I'
            _data.append(self.pet_max_health)
        if GroupUpdateFlags.PET_POWER_TYPE in self.mask:
            _fmt += 'B'
            _data.append(self.pet_power_type.value)
        if GroupUpdateFlags.PET_CUR_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.pet_current_power)
        if GroupUpdateFlags.PET_MAX_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.pet_max_power)
        if GroupUpdateFlags.PET_AURAS in self.mask:
            # pet_auras: AuraMask
            _fmt, _data = self.pet_auras.write(_fmt, _data)

        if GroupUpdateFlags.VEHICLE_SEAT in self.mask:
            _fmt += 'I'
            _data.append(self.transport)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4 + packed_guid_size(self.guid)

        if GroupUpdateFlags.STATUS in self.mask:
            _size += 1

        if GroupUpdateFlags.CUR_HP in self.mask:
            _size += 4

        if GroupUpdateFlags.MAX_HP in self.mask:
            _size += 4

        if GroupUpdateFlags.POWER_TYPE in self.mask:
            _size += 1

        if GroupUpdateFlags.CUR_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.MAX_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.LEVEL in self.mask:
            _size += 2

        if GroupUpdateFlags.ZONE in self.mask:
            _size += 4

        if GroupUpdateFlags.POSITION in self.mask:
            _size += 4

        if GroupUpdateFlags.AURAS in self.mask:
            _size += 0 + self.auras.size()

        if GroupUpdateFlags.PET_GUID in self.mask:
            _size += 8

        if GroupUpdateFlags.PET_NAME in self.mask:
            _size += 1 + len(self.pet_name)

        if GroupUpdateFlags.PET_MODEL_ID in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_CUR_HP in self.mask:
            _size += 4

        if GroupUpdateFlags.PET_MAX_HP in self.mask:
            _size += 4

        if GroupUpdateFlags.PET_POWER_TYPE in self.mask:
            _size += 1

        if GroupUpdateFlags.PET_CUR_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_MAX_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_AURAS in self.mask:
            _size += 0 + self.pet_auras.size()

        if GroupUpdateFlags.VEHICLE_SEAT in self.mask:
            _size += 4

        return _size


@dataclasses.dataclass
class SMSG_PARTY_COMMAND_RESULT:
    operation: PartyOperation
    member: str
    result: PartyResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PARTY_COMMAND_RESULT:
        # operation: PartyOperation
        operation = PartyOperation(await read_int(reader, 4))

        # member: CString
        member = await read_cstring(reader)

        # result: PartyResult
        result = PartyResult(await read_int(reader, 4))

        return SMSG_PARTY_COMMAND_RESULT(
            operation=operation,
            member=member,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x007F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.member)}sBI'
        _data.extend([self.operation.value, self.member.encode('utf-8'), 0, self.result.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.member)


@dataclasses.dataclass
class CMSG_GUILD_CREATE:
    guild_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_CREATE:
        # guild_name: CString
        guild_name = await read_cstring(reader)

        return CMSG_GUILD_CREATE(
            guild_name=guild_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0081))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.guild_name)}sB'
        _data.extend([self.guild_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.guild_name)


@dataclasses.dataclass
class CMSG_GUILD_INVITE:
    invited_player: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_INVITE:
        # invited_player: CString
        invited_player = await read_cstring(reader)

        return CMSG_GUILD_INVITE(
            invited_player=invited_player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0082))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.invited_player)}sB'
        _data.extend([self.invited_player.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.invited_player)


@dataclasses.dataclass
class SMSG_GUILD_INVITE:
    player_name: str
    guild_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_INVITE:
        # player_name: CString
        player_name = await read_cstring(reader)

        # guild_name: CString
        guild_name = await read_cstring(reader)

        return SMSG_GUILD_INVITE(
            player_name=player_name,
            guild_name=guild_name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0083))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.player_name)}sB{len(self.guild_name)}sB'
        _data.extend([self.player_name.encode('utf-8'), 0, self.guild_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.player_name) + len(self.guild_name)


@dataclasses.dataclass
class CMSG_GUILD_ACCEPT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_ACCEPT:
        return CMSG_GUILD_ACCEPT()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0084))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_DECLINE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_DECLINE:
        return CMSG_GUILD_DECLINE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0085))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GUILD_DECLINE:
    player: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_DECLINE:
        # player: CString
        player = await read_cstring(reader)

        return SMSG_GUILD_DECLINE(
            player=player,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0086))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.player)}sB'
        _data.extend([self.player.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.player)


@dataclasses.dataclass
class CMSG_GUILD_INFO:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_INFO:
        return CMSG_GUILD_INFO()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0087))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GUILD_INFO:
    guild_name: str
    created: int
    amount_of_characters_in_guild: int
    amount_of_accounts_in_guild: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_INFO:
        # guild_name: CString
        guild_name = await read_cstring(reader)

        # created: DateTime
        created = await read_int(reader, 4)

        # amount_of_characters_in_guild: u32
        amount_of_characters_in_guild = await read_int(reader, 4)

        # amount_of_accounts_in_guild: u32
        amount_of_accounts_in_guild = await read_int(reader, 4)

        return SMSG_GUILD_INFO(
            guild_name=guild_name,
            created=created,
            amount_of_characters_in_guild=amount_of_characters_in_guild,
            amount_of_accounts_in_guild=amount_of_accounts_in_guild,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0088))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.guild_name)}sBIII'
        _data.extend([self.guild_name.encode('utf-8'), 0, self.created, self.amount_of_characters_in_guild, self.amount_of_accounts_in_guild])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 13 + len(self.guild_name)


@dataclasses.dataclass
class CMSG_GUILD_ROSTER:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_ROSTER:
        return CMSG_GUILD_ROSTER()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0089))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GUILD_ROSTER:
    motd: str
    guild_info: str
    rights: typing.List[GuildRights]
    members: typing.List[GuildMember]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_ROSTER:
        # amount_of_members: u32
        amount_of_members = await read_int(reader, 4)

        # motd: CString
        motd = await read_cstring(reader)

        # guild_info: CString
        guild_info = await read_cstring(reader)

        # amount_of_rights: u32
        amount_of_rights = await read_int(reader, 4)

        # rights: GuildRights[amount_of_rights]
        rights = []
        for _ in range(0, amount_of_rights):
            rights.append(await GuildRights.read(reader))

        # members: GuildMember[amount_of_members]
        members = []
        for _ in range(0, amount_of_members):
            members.append(await GuildMember.read(reader))

        return SMSG_GUILD_ROSTER(
            motd=motd,
            guild_info=guild_info,
            rights=rights,
            members=members,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x008A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.motd)}sB{len(self.guild_info)}sBI'
        _data.extend([len(self.members), self.motd.encode('utf-8'), 0, self.guild_info.encode('utf-8'), 0, len(self.rights)])
        # rights: GuildRights[amount_of_rights]
        for i in self.rights:
            _fmt, _data = i.write(_fmt, _data)

        # members: GuildMember[amount_of_members]
        for i in self.members:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 10 + len(self.motd) + len(self.guild_info) + 56 * len(self.rights) + sum([i.size() for i in self.members])


@dataclasses.dataclass
class CMSG_GUILD_PROMOTE:
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_PROMOTE:
        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_GUILD_PROMOTE(
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x008B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.player_name)}sB'
        _data.extend([self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.player_name)


@dataclasses.dataclass
class CMSG_GUILD_DEMOTE:
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_DEMOTE:
        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_GUILD_DEMOTE(
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x008C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.player_name)}sB'
        _data.extend([self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.player_name)


@dataclasses.dataclass
class CMSG_GUILD_LEAVE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_LEAVE:
        return CMSG_GUILD_LEAVE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x008D))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_REMOVE:
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_REMOVE:
        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_GUILD_REMOVE(
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x008E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.player_name)}sB'
        _data.extend([self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.player_name)


@dataclasses.dataclass
class CMSG_GUILD_DISBAND:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_DISBAND:
        return CMSG_GUILD_DISBAND()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x008F))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_LEADER:
    new_guild_leader_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_LEADER:
        # new_guild_leader_name: CString
        new_guild_leader_name = await read_cstring(reader)

        return CMSG_GUILD_LEADER(
            new_guild_leader_name=new_guild_leader_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0090))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.new_guild_leader_name)}sB'
        _data.extend([self.new_guild_leader_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.new_guild_leader_name)


@dataclasses.dataclass
class CMSG_GUILD_MOTD:
    message_of_the_day: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_MOTD:
        # message_of_the_day: CString
        message_of_the_day = await read_cstring(reader)

        return CMSG_GUILD_MOTD(
            message_of_the_day=message_of_the_day,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0091))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.message_of_the_day)}sB'
        _data.extend([self.message_of_the_day.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.message_of_the_day)


@dataclasses.dataclass
class SMSG_GUILD_EVENT:
    event: GuildEvent
    event_descriptions: typing.List[str]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_EVENT:
        # event: GuildEvent
        event = GuildEvent(await read_int(reader, 1))

        # amount_of_events: u8
        amount_of_events = await read_int(reader, 1)

        # event_descriptions: CString[amount_of_events]
        event_descriptions = []
        for _ in range(0, amount_of_events):
            event_descriptions.append(await read_cstring(reader))

        return SMSG_GUILD_EVENT(
            event=event,
            event_descriptions=event_descriptions,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0092))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.event.value, len(self.event_descriptions)])
        # event_descriptions: CString[amount_of_events]
        for i in self.event_descriptions:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + sum([len(i) + 1 for i in self.event_descriptions])


@dataclasses.dataclass
class SMSG_GUILD_COMMAND_RESULT:
    command: GuildCommand
    string: str
    result: GuildCommandResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_COMMAND_RESULT:
        # command: GuildCommand
        command = GuildCommand(await read_int(reader, 4))

        # string: CString
        string = await read_cstring(reader)

        # result: GuildCommandResult
        result = GuildCommandResult(await read_int(reader, 4))

        return SMSG_GUILD_COMMAND_RESULT(
            command=command,
            string=string,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0093))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.string)}sBI'
        _data.extend([self.command.value, self.string.encode('utf-8'), 0, self.result.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.string)


@dataclasses.dataclass
class CMSG_MESSAGECHAT:
    chat_type: ChatType
    language: Language
    message: str
    target_player: typing.Optional[str] = None
    channel: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MESSAGECHAT:
        target_player = None
        channel = None
        # chat_type: ChatType
        chat_type = ChatType(await read_int(reader, 4))

        # language: Language
        language = Language(await read_int(reader, 4))

        if chat_type == ChatType.WHISPER:
            # target_player: CString
            target_player = await read_cstring(reader)

        elif chat_type == ChatType.CHANNEL:
            # channel: CString
            channel = await read_cstring(reader)

        # message: CString
        message = await read_cstring(reader)

        return CMSG_MESSAGECHAT(
            chat_type=chat_type,
            language=language,
            target_player=target_player,
            channel=channel,
            message=message,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0095))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.chat_type.value, self.language.value])
        if self.chat_type == ChatType.WHISPER:
            _fmt += f'{len(self.target_player)}sB'
            _data.extend([self.target_player.encode('utf-8'), 0])
        elif self.chat_type == ChatType.CHANNEL:
            _fmt += f'{len(self.channel)}sB'
            _data.extend([self.channel.encode('utf-8'), 0])
        # message: CString
        _fmt += f'{len(self.message)}sB'
        _data.extend([self.message.encode('utf-8'), 0])

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 9 + len(self.message)

        if self.chat_type == ChatType.WHISPER:
            _size += 1 + len(self.target_player)
        elif self.chat_type == ChatType.CHANNEL:
            _size += 1 + len(self.channel)

        return _size


@dataclasses.dataclass
class SMSG_MESSAGECHAT:
    chat_type: ChatType
    language: Language
    sender: int
    flags: int
    message: str
    tag: PlayerChatTag
    sender1: typing.Optional[str] = None
    target1: typing.Optional[NamedGUID] = None
    sender2: typing.Optional[str] = None
    target2: typing.Optional[int] = None
    target3: typing.Optional[NamedGUID] = None
    target4: typing.Optional[int] = None
    channel_name: typing.Optional[str] = None
    target5: typing.Optional[int] = None
    target6: typing.Optional[int] = None
    achievement_id: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MESSAGECHAT:
        sender1 = None
        target1 = None
        sender2 = None
        target2 = None
        target3 = None
        target4 = None
        channel_name = None
        target5 = None
        target6 = None
        achievement_id = None
        # chat_type: ChatType
        chat_type = ChatType(await read_int(reader, 1))

        # language: Language
        language = Language(await read_int(reader, 4))

        # sender: Guid
        sender = await read_int(reader, 8)

        # flags: u32
        flags = await read_int(reader, 4)

        if chat_type in {ChatType.MONSTER_SAY, ChatType.MONSTER_PARTY, ChatType.MONSTER_YELL, ChatType.MONSTER_WHISPER, ChatType.RAID_BOSS_WHISPER, ChatType.RAID_BOSS_EMOTE, ChatType.MONSTER_EMOTE, ChatType.BATTLENET}:
            # sender1: SizedCString
            sender1 = await read_sized_cstring(reader)

            # target1: NamedGuid
            target1 = await NamedGuid.read(reader)

        elif chat_type == ChatType.WHISPER_FOREIGN:
            # sender2: SizedCString
            sender2 = await read_sized_cstring(reader)

            # target2: Guid
            target2 = await read_int(reader, 8)

        elif chat_type in {ChatType.BG_SYSTEM_NEUTRAL, ChatType.BG_SYSTEM_ALLIANCE, ChatType.BG_SYSTEM_HORDE}:
            # target3: NamedGuid
            target3 = await NamedGuid.read(reader)

        elif chat_type in {ChatType.ACHIEVEMENT, ChatType.GUILD_ACHIEVEMENT}:
            # target4: Guid
            target4 = await read_int(reader, 8)

        elif chat_type == ChatType.CHANNEL:
            # channel_name: CString
            channel_name = await read_cstring(reader)

            # target5: Guid
            target5 = await read_int(reader, 8)

        elif chat_type in {ChatType.SYSTEM, ChatType.SAY, ChatType.PARTY, ChatType.RAID, ChatType.GUILD, ChatType.OFFICER, ChatType.YELL, ChatType.WHISPER, ChatType.WHISPER_INFORM, ChatType.EMOTE, ChatType.TEXT_EMOTE, ChatType.CHANNEL_JOIN, ChatType.CHANNEL_LEAVE, ChatType.CHANNEL_LIST, ChatType.CHANNEL_NOTICE, ChatType.CHANNEL_NOTICE_USER, ChatType.AFK, ChatType.DND, ChatType.IGNORED, ChatType.SKILL, ChatType.LOOT, ChatType.MONEY, ChatType.OPENING, ChatType.TRADESKILLS, ChatType.PET_INFO, ChatType.COMBAT_MISC_INFO, ChatType.COMBAT_XP_GAIN, ChatType.COMBAT_HONOR_GAIN, ChatType.COMBAT_FACTION_CHANGE, ChatType.RAID_LEADER, ChatType.RAID_WARNING, ChatType.FILTERED, ChatType.BATTLEGROUND, ChatType.BATTLEGROUND_LEADER, ChatType.RESTRICTED, ChatType.ARENA_POINTS, ChatType.PARTY_LEADER}:
            # target6: Guid
            target6 = await read_int(reader, 8)

        # message: SizedCString
        message = await read_sized_cstring(reader)

        # tag: PlayerChatTag
        tag = PlayerChatTag(await read_int(reader, 1))

        if chat_type in {ChatType.ACHIEVEMENT, ChatType.GUILD_ACHIEVEMENT}:
            # achievement_id: u32
            achievement_id = await read_int(reader, 4)

        return SMSG_MESSAGECHAT(
            chat_type=chat_type,
            language=language,
            sender=sender,
            flags=flags,
            sender1=sender1,
            target1=target1,
            sender2=sender2,
            target2=target2,
            target3=target3,
            target4=target4,
            channel_name=channel_name,
            target5=target5,
            target6=target6,
            message=message,
            tag=tag,
            achievement_id=achievement_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0096))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BIQI'
        _data.extend([self.chat_type.value, self.language.value, self.sender, self.flags])
        if self.chat_type in {ChatType.MONSTER_SAY, ChatType.MONSTER_PARTY, ChatType.MONSTER_YELL, ChatType.MONSTER_WHISPER, ChatType.RAID_BOSS_WHISPER, ChatType.RAID_BOSS_EMOTE, ChatType.MONSTER_EMOTE, ChatType.BATTLENET}:
            _fmt += f'I{len(self.sender1)}sB'
            _data.extend([len(self.sender1) + 1, self.sender1.encode('utf-8'), 0])
            # target1: NamedGuid
            _fmt, _data = self.target1.write(_fmt, _data)

        elif self.chat_type == ChatType.WHISPER_FOREIGN:
            _fmt += f'I{len(self.sender2)}sBQ'
            _data.extend([len(self.sender2) + 1, self.sender2.encode('utf-8'), 0, self.target2])
        elif self.chat_type in {ChatType.BG_SYSTEM_NEUTRAL, ChatType.BG_SYSTEM_ALLIANCE, ChatType.BG_SYSTEM_HORDE}:
            # target3: NamedGuid
            _fmt, _data = self.target3.write(_fmt, _data)

        elif self.chat_type in {ChatType.ACHIEVEMENT, ChatType.GUILD_ACHIEVEMENT}:
            _fmt += 'Q'
            _data.append(self.target4)
        elif self.chat_type == ChatType.CHANNEL:
            _fmt += f'{len(self.channel_name)}sBQ'
            _data.extend([self.channel_name.encode('utf-8'), 0, self.target5])
        elif self.chat_type in {ChatType.SYSTEM, ChatType.SAY, ChatType.PARTY, ChatType.RAID, ChatType.GUILD, ChatType.OFFICER, ChatType.YELL, ChatType.WHISPER, ChatType.WHISPER_INFORM, ChatType.EMOTE, ChatType.TEXT_EMOTE, ChatType.CHANNEL_JOIN, ChatType.CHANNEL_LEAVE, ChatType.CHANNEL_LIST, ChatType.CHANNEL_NOTICE, ChatType.CHANNEL_NOTICE_USER, ChatType.AFK, ChatType.DND, ChatType.IGNORED, ChatType.SKILL, ChatType.LOOT, ChatType.MONEY, ChatType.OPENING, ChatType.TRADESKILLS, ChatType.PET_INFO, ChatType.COMBAT_MISC_INFO, ChatType.COMBAT_XP_GAIN, ChatType.COMBAT_HONOR_GAIN, ChatType.COMBAT_FACTION_CHANGE, ChatType.RAID_LEADER, ChatType.RAID_WARNING, ChatType.FILTERED, ChatType.BATTLEGROUND, ChatType.BATTLEGROUND_LEADER, ChatType.RESTRICTED, ChatType.ARENA_POINTS, ChatType.PARTY_LEADER}:
            _fmt += 'Q'
            _data.append(self.target6)
        # message: SizedCString
        _fmt += f'I{len(self.message)}sB'
        _data.extend([len(self.message) + 1, self.message.encode('utf-8'), 0])

        # tag: PlayerChatTag
        _fmt += 'B'
        _data.append(self.tag.value)

        if self.chat_type in {ChatType.ACHIEVEMENT, ChatType.GUILD_ACHIEVEMENT}:
            _fmt += 'I'
            _data.append(self.achievement_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 23 + len(self.message)

        if self.chat_type in {ChatType.MONSTER_SAY, ChatType.MONSTER_PARTY, ChatType.MONSTER_YELL, ChatType.MONSTER_WHISPER, ChatType.RAID_BOSS_WHISPER, ChatType.RAID_BOSS_EMOTE, ChatType.MONSTER_EMOTE, ChatType.BATTLENET}:
            _size += 5 + len(self.sender1) + self.target1.size()
        elif self.chat_type == ChatType.WHISPER_FOREIGN:
            _size += 13 + len(self.sender2)
        elif self.chat_type in {ChatType.BG_SYSTEM_NEUTRAL, ChatType.BG_SYSTEM_ALLIANCE, ChatType.BG_SYSTEM_HORDE}:
            _size += 0 + self.target3.size()
        elif self.chat_type in {ChatType.ACHIEVEMENT, ChatType.GUILD_ACHIEVEMENT}:
            _size += 8
        elif self.chat_type == ChatType.CHANNEL:
            _size += 9 + len(self.channel_name)
        elif self.chat_type in {ChatType.SYSTEM, ChatType.SAY, ChatType.PARTY, ChatType.RAID, ChatType.GUILD, ChatType.OFFICER, ChatType.YELL, ChatType.WHISPER, ChatType.WHISPER_INFORM, ChatType.EMOTE, ChatType.TEXT_EMOTE, ChatType.CHANNEL_JOIN, ChatType.CHANNEL_LEAVE, ChatType.CHANNEL_LIST, ChatType.CHANNEL_NOTICE, ChatType.CHANNEL_NOTICE_USER, ChatType.AFK, ChatType.DND, ChatType.IGNORED, ChatType.SKILL, ChatType.LOOT, ChatType.MONEY, ChatType.OPENING, ChatType.TRADESKILLS, ChatType.PET_INFO, ChatType.COMBAT_MISC_INFO, ChatType.COMBAT_XP_GAIN, ChatType.COMBAT_HONOR_GAIN, ChatType.COMBAT_FACTION_CHANGE, ChatType.RAID_LEADER, ChatType.RAID_WARNING, ChatType.FILTERED, ChatType.BATTLEGROUND, ChatType.BATTLEGROUND_LEADER, ChatType.RESTRICTED, ChatType.ARENA_POINTS, ChatType.PARTY_LEADER}:
            _size += 8

        if self.chat_type in {ChatType.ACHIEVEMENT, ChatType.GUILD_ACHIEVEMENT}:
            _size += 4

        return _size


@dataclasses.dataclass
class CMSG_JOIN_CHANNEL:
    channel_id: int
    unknown1: int
    unknown2: int
    channel_name: str
    channel_password: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_JOIN_CHANNEL:
        # channel_id: u32
        channel_id = await read_int(reader, 4)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # unknown2: u8
        unknown2 = await read_int(reader, 1)

        # channel_name: CString
        channel_name = await read_cstring(reader)

        # channel_password: CString
        channel_password = await read_cstring(reader)

        return CMSG_JOIN_CHANNEL(
            channel_id=channel_id,
            unknown1=unknown1,
            unknown2=unknown2,
            channel_name=channel_name,
            channel_password=channel_password,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0097))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'IBB{len(self.channel_name)}sB{len(self.channel_password)}sB'
        _data.extend([self.channel_id, self.unknown1, self.unknown2, self.channel_name.encode('utf-8'), 0, self.channel_password.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + len(self.channel_name) + len(self.channel_password)


@dataclasses.dataclass
class CMSG_LEAVE_CHANNEL:
    channel_id: int
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LEAVE_CHANNEL:
        # channel_id: u32
        channel_id = await read_int(reader, 4)

        # channel_name: CString
        channel_name = await read_cstring(reader)

        return CMSG_LEAVE_CHANNEL(
            channel_id=channel_id,
            channel_name=channel_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0098))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'I{len(self.channel_name)}sB'
        _data.extend([self.channel_id, self.channel_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + len(self.channel_name)


@dataclasses.dataclass
class SMSG_CHANNEL_NOTIFY:
    notify_type: ChatNotify
    channel_name: str
    unknown2: typing.Optional[int] = None
    unkwown3: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHANNEL_NOTIFY:
        unknown2 = None
        unkwown3 = None
        _size = 0

        # notify_type: ChatNotify
        notify_type = ChatNotify(await read_int(reader, 1))
        _size += 1

        # channel_name: CString
        channel_name = await read_cstring(reader)
        _size += len(channel_name) + 1

        # unknown1: optional
        if _size < body_size:
            # unknown2: u32
            unknown2 = await read_int(reader, 4)
            _size += 4

            # unkwown3: u32
            unkwown3 = await read_int(reader, 4)
            _size += 4

        return SMSG_CHANNEL_NOTIFY(
            notify_type=notify_type,
            channel_name=channel_name,
            unknown2=unknown2,
            unkwown3=unkwown3,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0099))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'B{len(self.channel_name)}sB'
        _data.extend([self.notify_type.value, self.channel_name.encode('utf-8'), 0])
        # unknown1: optional
        if self.unknown2 is not None and self.unkwown3 is not None:
            _fmt += 'II'
            _data.extend([self.unknown2, self.unkwown3])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 2 + len(self.channel_name)

        # unknown1: optional
        if self.unknown2 is not None and self.unkwown3 is not None:
            _size += 8

        return _size


@dataclasses.dataclass
class CMSG_CHANNEL_LIST:
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_LIST:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        return CMSG_CHANNEL_LIST(
            channel_name=channel_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x009A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.channel_name)


@dataclasses.dataclass
class SMSG_CHANNEL_LIST:
    channel_name: str
    channel_flags: ChannelFlags
    members: typing.List[ChannelMember]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHANNEL_LIST:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # channel_flags: ChannelFlags
        channel_flags = ChannelFlags(await read_int(reader, 1))

        # amount_of_members: u32
        amount_of_members = await read_int(reader, 4)

        # members: ChannelMember[amount_of_members]
        members = []
        for _ in range(0, amount_of_members):
            members.append(await ChannelMember.read(reader))

        return SMSG_CHANNEL_LIST(
            channel_name=channel_name,
            channel_flags=channel_flags,
            members=members,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x009B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sBBI'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.channel_flags.value, len(self.members)])
        # members: ChannelMember[amount_of_members]
        for i in self.members:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 6 + len(self.channel_name) + 9 * len(self.members)


@dataclasses.dataclass
class CMSG_CHANNEL_PASSWORD:
    channel_name: str
    channel_password: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_PASSWORD:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # channel_password: CString
        channel_password = await read_cstring(reader)

        return CMSG_CHANNEL_PASSWORD(
            channel_name=channel_name,
            channel_password=channel_password,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x009C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.channel_password)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.channel_password.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.channel_password)


@dataclasses.dataclass
class CMSG_CHANNEL_SET_OWNER:
    channel_name: str
    new_owner: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_SET_OWNER:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # new_owner: CString
        new_owner = await read_cstring(reader)

        return CMSG_CHANNEL_SET_OWNER(
            channel_name=channel_name,
            new_owner=new_owner,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x009D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.new_owner)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.new_owner.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.new_owner)


@dataclasses.dataclass
class CMSG_CHANNEL_OWNER:
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_OWNER:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        return CMSG_CHANNEL_OWNER(
            channel_name=channel_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x009E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.channel_name)


@dataclasses.dataclass
class CMSG_CHANNEL_MODERATOR:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_MODERATOR:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_MODERATOR(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x009F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_UNMODERATOR:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_UNMODERATOR:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_UNMODERATOR(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_MUTE:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_MUTE:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_MUTE(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A1))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_UNMUTE:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_UNMUTE:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_UNMUTE(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_INVITE:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_INVITE:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_INVITE(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_KICK:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_KICK:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_KICK(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A4))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_BAN:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_BAN:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_BAN(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A5))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_UNBAN:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_UNBAN:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_UNBAN(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A6))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_ANNOUNCEMENTS:
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_ANNOUNCEMENTS:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        return CMSG_CHANNEL_ANNOUNCEMENTS(
            channel_name=channel_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A7))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.channel_name)


@dataclasses.dataclass
class CMSG_CHANNEL_MODERATE:
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_MODERATE:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        return CMSG_CHANNEL_MODERATE(
            channel_name=channel_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A8))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.channel_name)


@dataclasses.dataclass
class SMSG_UPDATE_OBJECT:
    objects: typing.List[Object]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_UPDATE_OBJECT:
        # amount_of_objects: u32
        amount_of_objects = await read_int(reader, 4)

        # objects: Object[amount_of_objects]
        objects = []
        for _ in range(0, amount_of_objects):
            objects.append(await Object.read(reader))

        return SMSG_UPDATE_OBJECT(
            objects=objects,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00A9))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.objects))
        # objects: Object[amount_of_objects]
        for i in self.objects:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + sum([i.size() for i in self.objects])


@dataclasses.dataclass
class SMSG_DESTROY_OBJECT:
    guid: int
    target_died: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DESTROY_OBJECT:
        # guid: Guid
        guid = await read_int(reader, 8)

        # target_died: Bool8
        target_died = await read_bool(reader, 1)

        return SMSG_DESTROY_OBJECT(
            guid=guid,
            target_died=target_died,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x00AA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.target_died])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_USE_ITEM:
    bag_index: int
    bag_slot: int
    spell_index: int
    cast_count: int
    spell: int
    item: int
    glyph_index: int
    cast_flags: ClientCastFlags
    targets: SpellCastTargets
    elevation: typing.Optional[float] = None
    speed: typing.Optional[float] = None
    movement_data: typing.Optional[ClientMovementData] = None
    opcode: typing.Optional[int] = None
    guid: typing.Optional[int] = None
    info: typing.Optional[MovementInfo] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_USE_ITEM:
        elevation = None
        speed = None
        movement_data = None
        opcode = None
        guid = None
        info = None
        # bag_index: u8
        bag_index = await read_int(reader, 1)

        # bag_slot: u8
        bag_slot = await read_int(reader, 1)

        # spell_index: u8
        spell_index = await read_int(reader, 1)

        # cast_count: u8
        cast_count = await read_int(reader, 1)

        # spell: Spell
        spell = await read_int(reader, 4)

        # item: Guid
        item = await read_int(reader, 8)

        # glyph_index: u32
        glyph_index = await read_int(reader, 4)

        # cast_flags: ClientCastFlags
        cast_flags = ClientCastFlags(await read_int(reader, 1))

        if cast_flags == ClientCastFlags.EXTRA:
            # elevation: f32
            elevation = await read_float(reader)

            # speed: f32
            speed = await read_float(reader)

            # movement_data: ClientMovementData
            movement_data = ClientMovementData(await read_int(reader, 1))

            if movement_data == ClientMovementData.PRESENT:
                # opcode: u32
                opcode = await read_int(reader, 4)

                # guid: PackedGuid
                guid = await read_packed_guid(reader)

                # info: MovementInfo
                info = await MovementInfo.read(reader)

        # targets: SpellCastTargets
        targets = await SpellCastTargets.read(reader)

        return CMSG_USE_ITEM(
            bag_index=bag_index,
            bag_slot=bag_slot,
            spell_index=spell_index,
            cast_count=cast_count,
            spell=spell,
            item=item,
            glyph_index=glyph_index,
            cast_flags=cast_flags,
            elevation=elevation,
            speed=speed,
            movement_data=movement_data,
            opcode=opcode,
            guid=guid,
            info=info,
            targets=targets,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00AB))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBBBIQIB'
        _data.extend([self.bag_index, self.bag_slot, self.spell_index, self.cast_count, self.spell, self.item, self.glyph_index, self.cast_flags.value])
        if self.cast_flags == ClientCastFlags.EXTRA:
            _fmt += 'ffB'
            _data.extend([self.elevation, self.speed, self.movement_data.value])
            if self.movement_data == ClientMovementData.PRESENT:
                _fmt += 'I'
                _data.append(self.opcode)
                # guid: PackedGuid
                _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

                # info: MovementInfo
                _fmt, _data = self.info.write(_fmt, _data)

        # targets: SpellCastTargets
        _fmt, _data = self.targets.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 21 + self.targets.size()

        if self.cast_flags == ClientCastFlags.EXTRA:
            _size += 9

            if self.movement_data == ClientMovementData.PRESENT:
                _size += 4 + packed_guid_size(self.guid) + self.info.size()


        return _size


@dataclasses.dataclass
class CMSG_OPEN_ITEM:
    bag_index: int
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_OPEN_ITEM:
        # bag_index: u8
        bag_index = await read_int(reader, 1)

        # slot: u8
        slot = await read_int(reader, 1)

        return CMSG_OPEN_ITEM(
            bag_index=bag_index,
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x00AC))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.bag_index, self.slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_READ_ITEM:
    bag_index: int
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_READ_ITEM:
        # bag_index: u8
        bag_index = await read_int(reader, 1)

        # slot: u8
        slot = await read_int(reader, 1)

        return CMSG_READ_ITEM(
            bag_index=bag_index,
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x00AD))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.bag_index, self.slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_READ_ITEM_OK:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_READ_ITEM_OK:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_READ_ITEM_OK(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x00AE))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_READ_ITEM_FAILED:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_READ_ITEM_FAILED:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_READ_ITEM_FAILED(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x00AF))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_COOLDOWN:
    guid: int
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_COOLDOWN:
        # guid: Guid
        guid = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        return SMSG_ITEM_COOLDOWN(
            guid=guid,
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x00B0))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GAMEOBJ_USE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GAMEOBJ_USE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_GAMEOBJ_USE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x00B1))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GAMEOBJECT_CUSTOM_ANIM:
    guid: int
    animation_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GAMEOBJECT_CUSTOM_ANIM:
        # guid: Guid
        guid = await read_int(reader, 8)

        # animation_id: u32
        animation_id = await read_int(reader, 4)

        return SMSG_GAMEOBJECT_CUSTOM_ANIM(
            guid=guid,
            animation_id=animation_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x00B3))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.animation_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AREATRIGGER:
    trigger_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AREATRIGGER:
        # trigger_id: u32
        trigger_id = await read_int(reader, 4)

        return CMSG_AREATRIGGER(
            trigger_id=trigger_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x00B4))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.trigger_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MOVE_START_FORWARD:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_FORWARD:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_FORWARD(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00B5))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00B5))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_BACKWARD:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_BACKWARD:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_BACKWARD(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00B6))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00B6))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00B7))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00B7))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_STRAFE_LEFT:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_STRAFE_LEFT:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_STRAFE_LEFT(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00B8))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00B8))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_STRAFE_RIGHT:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_STRAFE_RIGHT:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_STRAFE_RIGHT(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00B9))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00B9))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_STRAFE:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_STRAFE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_STRAFE(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00BA))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00BA))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_JUMP:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_JUMP:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_JUMP(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00BB))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00BB))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_TURN_LEFT:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_TURN_LEFT:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_TURN_LEFT(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00BC))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00BC))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_TURN_RIGHT:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_TURN_RIGHT:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_TURN_RIGHT(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00BD))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00BD))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_TURN:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_TURN:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_TURN(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00BE))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00BE))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_PITCH_UP:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_PITCH_UP:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_PITCH_UP(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00BF))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00BF))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_PITCH_DOWN:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_PITCH_DOWN:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_PITCH_DOWN(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00C0))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00C0))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_PITCH:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_PITCH:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_PITCH(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00C1))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00C1))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_RUN_MODE:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_RUN_MODE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_RUN_MODE(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00C2))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00C2))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_WALK_MODE:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_WALK_MODE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_WALK_MODE(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00C3))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00C3))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_TELEPORT_Server:
    player: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_TELEPORT_Server:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_TELEPORT_Server(
            player=player,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00C5))
        _fmt = "<6s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_TELEPORT_CHEAT_Server:
    position: Vector3d
    orientation: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_TELEPORT_CHEAT_Server:
        # position: Vector3d
        position = await Vector3d.read(reader)

        # orientation: f32
        orientation = await read_float(reader)

        return MSG_MOVE_TELEPORT_CHEAT_Server(
            position=position,
            orientation=orientation,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x00C6))
        _fmt = "<4s"
        _data = [_data]

        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # orientation: f32
        _fmt += 'f'
        _data.append(self.orientation)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MOVE_TELEPORT_ACK_Client:
    guid: int
    movement_counter: int
    time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_TELEPORT_ACK_Client:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # time: Milliseconds
        time = await read_int(reader, 4)

        return MSG_MOVE_TELEPORT_ACK_Client(
            guid=guid,
            movement_counter=movement_counter,
            time=time,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00C7))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # movement_counter: u32
        _fmt += 'I'
        _data.append(self.movement_counter)

        # time: Milliseconds
        _fmt += 'I'
        _data.append(self.time)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class MSG_MOVE_TELEPORT_ACK_Server:
    guid: int
    movement_counter: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_TELEPORT_ACK_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_TELEPORT_ACK_Server(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00C7))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # movement_counter: u32
        _fmt += 'I'
        _data.append(self.movement_counter)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_FALL_LAND:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_FALL_LAND:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_FALL_LAND(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00C9))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00C9))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_SWIM:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_SWIM:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_SWIM(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00CA))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00CA))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_SWIM:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_SWIM:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_SWIM(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00CB))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00CB))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_FACING:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_FACING:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_FACING(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00DA))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00DA))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_PITCH:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_PITCH:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_PITCH(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00DB))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00DB))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_WORLDPORT_ACK:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_WORLDPORT_ACK:
        return MSG_MOVE_WORLDPORT_ACK()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x00DC))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x00DC))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MONSTER_MOVE:
    guid: int
    unknown: int
    spline_point: Vector3d
    spline_id: int
    move_type: MonsterMoveType
    spline_flags: SplineFlag
    duration: int
    splines: MonsterMoveSpline
    target: typing.Optional[int] = None
    angle: typing.Optional[float] = None
    position: typing.Optional[Vector3d] = None
    animation_id: typing.Optional[int] = None
    animation_start_time: typing.Optional[int] = None
    vertical_acceleration: typing.Optional[float] = None
    effect_start_time: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MONSTER_MOVE:
        target = None
        angle = None
        position = None
        animation_id = None
        animation_start_time = None
        vertical_acceleration = None
        effect_start_time = None
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # unknown: u8
        unknown = await read_int(reader, 1)

        # spline_point: Vector3d
        spline_point = await Vector3d.read(reader)

        # spline_id: u32
        spline_id = await read_int(reader, 4)

        # move_type: MonsterMoveType
        move_type = MonsterMoveType(await read_int(reader, 1))

        if move_type == MonsterMoveType.FACING_TARGET:
            # target: Guid
            target = await read_int(reader, 8)

        elif move_type == MonsterMoveType.FACING_ANGLE:
            # angle: f32
            angle = await read_float(reader)

        elif move_type == MonsterMoveType.FACING_SPOT:
            # position: Vector3d
            position = await Vector3d.read(reader)

        # spline_flags: SplineFlag
        spline_flags = SplineFlag(await read_int(reader, 4))

        if SplineFlag.ENTER_CYCLE in spline_flags:
            # animation_id: u32
            animation_id = await read_int(reader, 4)

            # animation_start_time: u32
            animation_start_time = await read_int(reader, 4)

        # duration: u32
        duration = await read_int(reader, 4)

        if SplineFlag.PARABOLIC in spline_flags:
            # vertical_acceleration: f32
            vertical_acceleration = await read_float(reader)

            # effect_start_time: u32
            effect_start_time = await read_int(reader, 4)

        # splines: MonsterMoveSpline
        splines = await MonsterMoveSpline.read(reader)

        return SMSG_MONSTER_MOVE(
            guid=guid,
            unknown=unknown,
            spline_point=spline_point,
            spline_id=spline_id,
            move_type=move_type,
            target=target,
            angle=angle,
            position=position,
            spline_flags=spline_flags,
            animation_id=animation_id,
            animation_start_time=animation_start_time,
            duration=duration,
            vertical_acceleration=vertical_acceleration,
            effect_start_time=effect_start_time,
            splines=splines,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00DD))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # unknown: u8
        _fmt += 'B'
        _data.append(self.unknown)

        # spline_point: Vector3d
        _fmt, _data = self.spline_point.write(_fmt, _data)

        # spline_id: u32
        _fmt += 'I'
        _data.append(self.spline_id)

        # move_type: MonsterMoveType
        _fmt += 'B'
        _data.append(self.move_type.value)

        if self.move_type == MonsterMoveType.FACING_TARGET:
            _fmt += 'Q'
            _data.append(self.target)
        elif self.move_type == MonsterMoveType.FACING_ANGLE:
            _fmt += 'f'
            _data.append(self.angle)
        elif self.move_type == MonsterMoveType.FACING_SPOT:
            # position: Vector3d
            _fmt, _data = self.position.write(_fmt, _data)

        # spline_flags: SplineFlag
        _fmt += 'I'
        _data.append(self.spline_flags.value)

        if SplineFlag.ENTER_CYCLE in self.spline_flags:
            _fmt += 'II'
            _data.extend([self.animation_id, self.animation_start_time])
        # duration: u32
        _fmt += 'I'
        _data.append(self.duration)

        if SplineFlag.PARABOLIC in self.spline_flags:
            _fmt += 'fI'
            _data.extend([self.vertical_acceleration, self.effect_start_time])
        # splines: MonsterMoveSpline
        _fmt, _data = self.splines.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 26 + packed_guid_size(self.guid) + self.splines.size()

        if self.move_type == MonsterMoveType.FACING_TARGET:
            _size += 8
        elif self.move_type == MonsterMoveType.FACING_ANGLE:
            _size += 4
        elif self.move_type == MonsterMoveType.FACING_SPOT:
            _size += 12

        if SplineFlag.ENTER_CYCLE in self.spline_flags:
            _size += 8

        if SplineFlag.PARABOLIC in self.spline_flags:
            _size += 8

        return _size


@dataclasses.dataclass
class SMSG_MOVE_WATER_WALK:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_WATER_WALK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_WATER_WALK(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00DE))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_MOVE_LAND_WALK:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_LAND_WALK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_LAND_WALK(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00DF))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_MOVE_SET_RAW_POSITION:
    position: Vector3d
    orientation: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_SET_RAW_POSITION:
        # position: Vector3d
        position = await Vector3d.read(reader)

        # orientation: f32
        orientation = await read_float(reader)

        return CMSG_MOVE_SET_RAW_POSITION(
            position=position,
            orientation=orientation,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x00E1))
        _fmt = "<6s"
        _data = [_data]

        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # orientation: f32
        _fmt += 'f'
        _data.append(self.orientation)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_FORCE_RUN_SPEED_CHANGE:
    guid: int
    move_event: int
    unknown: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_RUN_SPEED_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # unknown: u8
        unknown = await read_int(reader, 1)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_RUN_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            unknown=unknown,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00E2))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # unknown: u8
        _fmt += 'B'
        _data.append(self.unknown)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_RUN_SPEED_CHANGE_ACK:
    guid: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_RUN_SPEED_CHANGE_ACK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_RUN_SPEED_CHANGE_ACK(
            guid=guid,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00E3))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_RUN_BACK_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_RUN_BACK_SPEED_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_RUN_BACK_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00E4))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK:
    guid: int
    movement_counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00E5))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # movement_counter: u32
        _fmt += 'I'
        _data.append(self.movement_counter)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_SWIM_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_SWIM_SPEED_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_SWIM_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00E6))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_SWIM_SPEED_CHANGE_ACK:
    guid: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_SWIM_SPEED_CHANGE_ACK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_SWIM_SPEED_CHANGE_ACK(
            guid=guid,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00E7))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_MOVE_ROOT:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_MOVE_ROOT:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_FORCE_MOVE_ROOT(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00E8))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_MOVE_ROOT_ACK:
    guid: int
    movement_counter: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_MOVE_ROOT_ACK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return CMSG_FORCE_MOVE_ROOT_ACK(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00E9))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # movement_counter: u32
        _fmt += 'I'
        _data.append(self.movement_counter)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_MOVE_UNROOT:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_MOVE_UNROOT:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_FORCE_MOVE_UNROOT(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00EA))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_MOVE_UNROOT_ACK:
    guid: int
    movement_counter: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_MOVE_UNROOT_ACK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return CMSG_FORCE_MOVE_UNROOT_ACK(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00EB))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # movement_counter: u32
        _fmt += 'I'
        _data.append(self.movement_counter)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_ROOT_Server:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_ROOT_Server:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_ROOT_Server(
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00EC))
        _fmt = "<4s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_UNROOT_Server:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_UNROOT_Server:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_UNROOT_Server(
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00ED))
        _fmt = "<4s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_HEARTBEAT:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_HEARTBEAT:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_HEARTBEAT(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00EE))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00EE))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class SMSG_MOVE_KNOCK_BACK:
    guid: int
    movement_counter: int
    v_cos: float
    v_sin: float
    horizontal_speed: float
    vertical_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_KNOCK_BACK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # v_cos: f32
        v_cos = await read_float(reader)

        # v_sin: f32
        v_sin = await read_float(reader)

        # horizontal_speed: f32
        horizontal_speed = await read_float(reader)

        # vertical_speed: f32
        vertical_speed = await read_float(reader)

        return SMSG_MOVE_KNOCK_BACK(
            guid=guid,
            movement_counter=movement_counter,
            v_cos=v_cos,
            v_sin=v_sin,
            horizontal_speed=horizontal_speed,
            vertical_speed=vertical_speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00EF))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # movement_counter: u32
        _fmt += 'I'
        _data.append(self.movement_counter)

        # v_cos: f32
        _fmt += 'f'
        _data.append(self.v_cos)

        # v_sin: f32
        _fmt += 'f'
        _data.append(self.v_sin)

        # horizontal_speed: f32
        _fmt += 'f'
        _data.append(self.horizontal_speed)

        # vertical_speed: f32
        _fmt += 'f'
        _data.append(self.vertical_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 20 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_MOVE_KNOCK_BACK_ACK:
    guid: int
    counter: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_KNOCK_BACK_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return CMSG_MOVE_KNOCK_BACK_ACK(
            guid=guid,
            counter=counter,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00F0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_KNOCK_BACK_Server:
    player: int
    info: MovementInfo
    sin_angle: float
    cos_angle: float
    x_y_speed: float
    velocity: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_KNOCK_BACK_Server:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # sin_angle: f32
        sin_angle = await read_float(reader)

        # cos_angle: f32
        cos_angle = await read_float(reader)

        # x_y_speed: f32
        x_y_speed = await read_float(reader)

        # velocity: f32
        velocity = await read_float(reader)

        return MSG_MOVE_KNOCK_BACK_Server(
            player=player,
            info=info,
            sin_angle=sin_angle,
            cos_angle=cos_angle,
            x_y_speed=x_y_speed,
            velocity=velocity,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00F1))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # sin_angle: f32
        _fmt += 'f'
        _data.append(self.sin_angle)

        # cos_angle: f32
        _fmt += 'f'
        _data.append(self.cos_angle)

        # x_y_speed: f32
        _fmt += 'f'
        _data.append(self.x_y_speed)

        # velocity: f32
        _fmt += 'f'
        _data.append(self.velocity)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class SMSG_MOVE_FEATHER_FALL:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_FEATHER_FALL:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_FEATHER_FALL(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00F2))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_MOVE_NORMAL_FALL:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_NORMAL_FALL:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_NORMAL_FALL(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00F3))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_MOVE_SET_HOVER:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_SET_HOVER:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_SET_HOVER(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00F4))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_MOVE_UNSET_HOVER:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_UNSET_HOVER:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_UNSET_HOVER(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00F5))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_MOVE_HOVER_ACK:
    guid: int
    counter: int
    info: MovementInfo
    is_applied: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_HOVER_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # is_applied: u32
        is_applied = await read_int(reader, 4)

        return CMSG_MOVE_HOVER_ACK(
            guid=guid,
            counter=counter,
            info=info,
            is_applied=is_applied,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00F6))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # is_applied: u32
        _fmt += 'I'
        _data.append(self.is_applied)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_HOVER:
    player: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_HOVER:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_HOVER(
            player=player,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00F7))
        _fmt = "<6s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00F7))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class SMSG_TRIGGER_CINEMATIC:
    cinematic_sequence_id: CinematicSequenceId

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRIGGER_CINEMATIC:
        # cinematic_sequence_id: CinematicSequenceId
        cinematic_sequence_id = CinematicSequenceId(await read_int(reader, 4))

        return SMSG_TRIGGER_CINEMATIC(
            cinematic_sequence_id=cinematic_sequence_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x00FA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.cinematic_sequence_id.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_NEXT_CINEMATIC_CAMERA:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_NEXT_CINEMATIC_CAMERA:
        return CMSG_NEXT_CINEMATIC_CAMERA()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x00FB))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_COMPLETE_CINEMATIC:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_COMPLETE_CINEMATIC:
        return CMSG_COMPLETE_CINEMATIC()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x00FC))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TUTORIAL_FLAGS:
    tutorial_data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TUTORIAL_FLAGS:
        # tutorial_data: u32[8]
        tutorial_data = []
        for _ in range(0, 8):
            tutorial_data.append(await read_int(reader, 4))

        return SMSG_TUTORIAL_FLAGS(
            tutorial_data=tutorial_data,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(32 + 2, 0x00FD))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.tutorial_data)}I'
        _data.extend([*self.tutorial_data])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TUTORIAL_FLAG:
    tutorial_flag: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TUTORIAL_FLAG:
        # tutorial_flag: u32
        tutorial_flag = await read_int(reader, 4)

        return CMSG_TUTORIAL_FLAG(
            tutorial_flag=tutorial_flag,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x00FE))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.tutorial_flag)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TUTORIAL_CLEAR:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TUTORIAL_CLEAR:
        return CMSG_TUTORIAL_CLEAR()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x00FF))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TUTORIAL_RESET:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TUTORIAL_RESET:
        return CMSG_TUTORIAL_RESET()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0100))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_STANDSTATECHANGE:
    animation_state: UnitStandState

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_STANDSTATECHANGE:
        # animation_state: UnitStandState
        animation_state = UnitStandState(await read_int(reader, 4))

        return CMSG_STANDSTATECHANGE(
            animation_state=animation_state,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0101))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.animation_state.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_EMOTE:
    emote: Emote

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_EMOTE:
        # emote: Emote
        emote = Emote(await read_int(reader, 4))

        return CMSG_EMOTE(
            emote=emote,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0102))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.emote.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_EMOTE:
    emote: Emote
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_EMOTE:
        # emote: Emote
        emote = Emote(await read_int(reader, 4))

        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_EMOTE(
            emote=emote,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0103))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.emote.value, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TEXT_EMOTE:
    text_emote: TextEmote
    emote: int
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TEXT_EMOTE:
        # text_emote: TextEmote
        text_emote = TextEmote(await read_int(reader, 4))

        # emote: u32
        emote = await read_int(reader, 4)

        # target: Guid
        target = await read_int(reader, 8)

        return CMSG_TEXT_EMOTE(
            text_emote=text_emote,
            emote=emote,
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x0104))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IIQ'
        _data.extend([self.text_emote.value, self.emote, self.target])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TEXT_EMOTE:
    guid: int
    text_emote: TextEmote
    emote: int
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TEXT_EMOTE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # text_emote: TextEmote
        text_emote = TextEmote(await read_int(reader, 4))

        # emote: u32
        emote = await read_int(reader, 4)

        # name: SizedCString
        name = await read_sized_cstring(reader)

        return SMSG_TEXT_EMOTE(
            guid=guid,
            text_emote=text_emote,
            emote=emote,
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0105))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QIII{len(self.name)}sB'
        _data.extend([self.guid, self.text_emote.value, self.emote, len(self.name) + 1, self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 21 + len(self.name)


@dataclasses.dataclass
class CMSG_AUTOSTORE_LOOT_ITEM:
    item_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUTOSTORE_LOOT_ITEM:
        # item_slot: u8
        item_slot = await read_int(reader, 1)

        return CMSG_AUTOSTORE_LOOT_ITEM(
            item_slot=item_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x0108))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.item_slot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUTOEQUIP_ITEM:
    source_bag: int
    source_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUTOEQUIP_ITEM:
        # source_bag: u8
        source_bag = await read_int(reader, 1)

        # source_slot: u8
        source_slot = await read_int(reader, 1)

        return CMSG_AUTOEQUIP_ITEM(
            source_bag=source_bag,
            source_slot=source_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x010A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.source_bag, self.source_slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUTOSTORE_BAG_ITEM:
    source_bag: int
    source_slot: int
    destination_bag: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUTOSTORE_BAG_ITEM:
        # source_bag: u8
        source_bag = await read_int(reader, 1)

        # source_slot: u8
        source_slot = await read_int(reader, 1)

        # destination_bag: u8
        destination_bag = await read_int(reader, 1)

        return CMSG_AUTOSTORE_BAG_ITEM(
            source_bag=source_bag,
            source_slot=source_slot,
            destination_bag=destination_bag,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(3 + 4, 0x010B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBB'
        _data.extend([self.source_bag, self.source_slot, self.destination_bag])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SWAP_ITEM:
    destination_bag: int
    destionation_slot: int
    source_bag: int
    source_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SWAP_ITEM:
        # destination_bag: u8
        destination_bag = await read_int(reader, 1)

        # destionation_slot: u8
        destionation_slot = await read_int(reader, 1)

        # source_bag: u8
        source_bag = await read_int(reader, 1)

        # source_slot: u8
        source_slot = await read_int(reader, 1)

        return CMSG_SWAP_ITEM(
            destination_bag=destination_bag,
            destionation_slot=destionation_slot,
            source_bag=source_bag,
            source_slot=source_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x010C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBBB'
        _data.extend([self.destination_bag, self.destionation_slot, self.source_bag, self.source_slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SWAP_INV_ITEM:
    source_slot: ItemSlot
    destination_slot: ItemSlot

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SWAP_INV_ITEM:
        # source_slot: ItemSlot
        source_slot = ItemSlot(await read_int(reader, 1))

        # destination_slot: ItemSlot
        destination_slot = ItemSlot(await read_int(reader, 1))

        return CMSG_SWAP_INV_ITEM(
            source_slot=source_slot,
            destination_slot=destination_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x010D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.source_slot.value, self.destination_slot.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SPLIT_ITEM:
    source_bag: int
    source_slot: int
    destination_bag: int
    destination_slot: int
    amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SPLIT_ITEM:
        # source_bag: u8
        source_bag = await read_int(reader, 1)

        # source_slot: u8
        source_slot = await read_int(reader, 1)

        # destination_bag: u8
        destination_bag = await read_int(reader, 1)

        # destination_slot: u8
        destination_slot = await read_int(reader, 1)

        # amount: u32
        amount = await read_int(reader, 4)

        return CMSG_SPLIT_ITEM(
            source_bag=source_bag,
            source_slot=source_slot,
            destination_bag=destination_bag,
            destination_slot=destination_slot,
            amount=amount,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x010E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBBBI'
        _data.extend([self.source_bag, self.source_slot, self.destination_bag, self.destination_slot, self.amount])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUTOEQUIP_ITEM_SLOT:
    guid: int
    destination_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUTOEQUIP_ITEM_SLOT:
        # guid: Guid
        guid = await read_int(reader, 8)

        # destination_slot: u8
        destination_slot = await read_int(reader, 1)

        return CMSG_AUTOEQUIP_ITEM_SLOT(
            guid=guid,
            destination_slot=destination_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x010F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.destination_slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_DESTROYITEM:
    bag: int
    slot: int
    amount: int
    unknown1: int
    unknown2: int
    unknown3: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_DESTROYITEM:
        # bag: u8
        bag = await read_int(reader, 1)

        # slot: u8
        slot = await read_int(reader, 1)

        # amount: u8
        amount = await read_int(reader, 1)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # unknown2: u8
        unknown2 = await read_int(reader, 1)

        # unknown3: u8
        unknown3 = await read_int(reader, 1)

        return CMSG_DESTROYITEM(
            bag=bag,
            slot=slot,
            amount=amount,
            unknown1=unknown1,
            unknown2=unknown2,
            unknown3=unknown3,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(6 + 4, 0x0111))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBBBBB'
        _data.extend([self.bag, self.slot, self.amount, self.unknown1, self.unknown2, self.unknown3])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_INVENTORY_CHANGE_FAILURE:
    result: InventoryResult
    item1: typing.Optional[int] = None
    item2: typing.Optional[int] = None
    bag_type_subclass: typing.Optional[int] = None
    required_level: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INVENTORY_CHANGE_FAILURE:
        item1 = None
        item2 = None
        bag_type_subclass = None
        required_level = None
        # result: InventoryResult
        result = InventoryResult(await read_int(reader, 1))

        if result in {InventoryResult.CANT_EQUIP_LEVEL_I, InventoryResult.CANT_EQUIP_SKILL, InventoryResult.ITEM_DOESNT_GO_TO_SLOT, InventoryResult.BAG_FULL, InventoryResult.NONEMPTY_BAG_OVER_OTHER_BAG, InventoryResult.CANT_TRADE_EQUIP_BAGS, InventoryResult.ONLY_AMMO_CAN_GO_HERE, InventoryResult.NO_REQUIRED_PROFICIENCY, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE, InventoryResult.YOU_CAN_NEVER_USE_THAT_ITEM, InventoryResult.YOU_CAN_NEVER_USE_THAT_ITEM2, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE2, InventoryResult.CANT_EQUIP_WITH_TWOHANDED, InventoryResult.CANT_DUAL_WIELD, InventoryResult.ITEM_DOESNT_GO_INTO_BAG, InventoryResult.ITEM_DOESNT_GO_INTO_BAG2, InventoryResult.CANT_CARRY_MORE_OF_THIS, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE3, InventoryResult.ITEM_CANT_STACK, InventoryResult.ITEM_CANT_BE_EQUIPPED, InventoryResult.ITEMS_CANT_BE_SWAPPED, InventoryResult.SLOT_IS_EMPTY, InventoryResult.ITEM_NOT_FOUND, InventoryResult.CANT_DROP_SOULBOUND, InventoryResult.OUT_OF_RANGE, InventoryResult.TRIED_TO_SPLIT_MORE_THAN_COUNT, InventoryResult.COULDNT_SPLIT_ITEMS, InventoryResult.MISSING_REAGENT, InventoryResult.NOT_ENOUGH_MONEY, InventoryResult.NOT_A_BAG, InventoryResult.CAN_ONLY_DO_WITH_EMPTY_BAGS, InventoryResult.DONT_OWN_THAT_ITEM, InventoryResult.CAN_EQUIP_ONLY1_QUIVER, InventoryResult.MUST_PURCHASE_THAT_BAG_SLOT, InventoryResult.TOO_FAR_AWAY_FROM_BANK, InventoryResult.ITEM_LOCKED, InventoryResult.YOU_ARE_STUNNED, InventoryResult.YOU_ARE_DEAD, InventoryResult.CANT_DO_RIGHT_NOW, InventoryResult.INT_BAG_ERROR, InventoryResult.CAN_EQUIP_ONLY1_BOLT, InventoryResult.CAN_EQUIP_ONLY1_AMMOPOUCH, InventoryResult.STACKABLE_CANT_BE_WRAPPED, InventoryResult.EQUIPPED_CANT_BE_WRAPPED, InventoryResult.WRAPPED_CANT_BE_WRAPPED, InventoryResult.BOUND_CANT_BE_WRAPPED, InventoryResult.UNIQUE_CANT_BE_WRAPPED, InventoryResult.BAGS_CANT_BE_WRAPPED, InventoryResult.ALREADY_LOOTED, InventoryResult.INVENTORY_FULL, InventoryResult.BANK_FULL, InventoryResult.ITEM_IS_CURRENTLY_SOLD_OUT, InventoryResult.BAG_FULL3, InventoryResult.ITEM_NOT_FOUND2, InventoryResult.ITEM_CANT_STACK2, InventoryResult.BAG_FULL4, InventoryResult.ITEM_SOLD_OUT, InventoryResult.OBJECT_IS_BUSY, InventoryResult.NONE, InventoryResult.NOT_IN_COMBAT, InventoryResult.NOT_WHILE_DISARMED, InventoryResult.BAG_FULL6, InventoryResult.CANT_EQUIP_RANK, InventoryResult.CANT_EQUIP_REPUTATION, InventoryResult.TOO_MANY_SPECIAL_BAGS, InventoryResult.LOOT_CANT_LOOT_THAT_NOW, InventoryResult.ITEM_UNIQUE_EQUIPABLE, InventoryResult.VENDOR_MISSING_TURNINS, InventoryResult.NOT_ENOUGH_HONOR_POINTS, InventoryResult.NOT_ENOUGH_ARENA_POINTS, InventoryResult.ITEM_MAX_COUNT_SOCKETED, InventoryResult.MAIL_BOUND_ITEM, InventoryResult.NO_SPLIT_WHILE_PROSPECTING, InventoryResult.ITEM_MAX_COUNT_EQUIPPED_SOCKETED, InventoryResult.ITEM_UNIQUE_EQUIPPABLE_SOCKETED, InventoryResult.TOO_MUCH_GOLD, InventoryResult.NOT_DURING_ARENA_MATCH, InventoryResult.CANNOT_TRADE_THAT, InventoryResult.PERSONAL_ARENA_RATING_TOO_LOW, InventoryResult.EVENT_AUTOEQUIP_BIND_CONFIRM, InventoryResult.ARTEFACTS_ONLY_FOR_OWN_CHARACTERS, InventoryResult.ITEM_MAX_LIMIT_CATEGORY_COUNT_EXCEEDED, InventoryResult.ITEM_MAX_LIMIT_CATEGORY_SOCKETED_EXCEEDED, InventoryResult.SCALING_STAT_ITEM_LEVEL_EXCEEDED, InventoryResult.PURCHASE_LEVEL_TOO_LOW, InventoryResult.CANT_EQUIP_NEED_TALENT, InventoryResult.ITEM_MAX_LIMIT_CATEGORY_EQUIPPED_EXCEEDED}:
            # item1: Guid
            item1 = await read_int(reader, 8)

            # item2: Guid
            item2 = await read_int(reader, 8)

            # bag_type_subclass: u8
            bag_type_subclass = await read_int(reader, 1)

        if result == InventoryResult.CANT_EQUIP_LEVEL_I:
            # required_level: Level32
            required_level = await read_int(reader, 4)

        return SMSG_INVENTORY_CHANGE_FAILURE(
            result=result,
            item1=item1,
            item2=item2,
            bag_type_subclass=bag_type_subclass,
            required_level=required_level,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0112))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        if self.result in {InventoryResult.CANT_EQUIP_LEVEL_I, InventoryResult.CANT_EQUIP_SKILL, InventoryResult.ITEM_DOESNT_GO_TO_SLOT, InventoryResult.BAG_FULL, InventoryResult.NONEMPTY_BAG_OVER_OTHER_BAG, InventoryResult.CANT_TRADE_EQUIP_BAGS, InventoryResult.ONLY_AMMO_CAN_GO_HERE, InventoryResult.NO_REQUIRED_PROFICIENCY, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE, InventoryResult.YOU_CAN_NEVER_USE_THAT_ITEM, InventoryResult.YOU_CAN_NEVER_USE_THAT_ITEM2, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE2, InventoryResult.CANT_EQUIP_WITH_TWOHANDED, InventoryResult.CANT_DUAL_WIELD, InventoryResult.ITEM_DOESNT_GO_INTO_BAG, InventoryResult.ITEM_DOESNT_GO_INTO_BAG2, InventoryResult.CANT_CARRY_MORE_OF_THIS, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE3, InventoryResult.ITEM_CANT_STACK, InventoryResult.ITEM_CANT_BE_EQUIPPED, InventoryResult.ITEMS_CANT_BE_SWAPPED, InventoryResult.SLOT_IS_EMPTY, InventoryResult.ITEM_NOT_FOUND, InventoryResult.CANT_DROP_SOULBOUND, InventoryResult.OUT_OF_RANGE, InventoryResult.TRIED_TO_SPLIT_MORE_THAN_COUNT, InventoryResult.COULDNT_SPLIT_ITEMS, InventoryResult.MISSING_REAGENT, InventoryResult.NOT_ENOUGH_MONEY, InventoryResult.NOT_A_BAG, InventoryResult.CAN_ONLY_DO_WITH_EMPTY_BAGS, InventoryResult.DONT_OWN_THAT_ITEM, InventoryResult.CAN_EQUIP_ONLY1_QUIVER, InventoryResult.MUST_PURCHASE_THAT_BAG_SLOT, InventoryResult.TOO_FAR_AWAY_FROM_BANK, InventoryResult.ITEM_LOCKED, InventoryResult.YOU_ARE_STUNNED, InventoryResult.YOU_ARE_DEAD, InventoryResult.CANT_DO_RIGHT_NOW, InventoryResult.INT_BAG_ERROR, InventoryResult.CAN_EQUIP_ONLY1_BOLT, InventoryResult.CAN_EQUIP_ONLY1_AMMOPOUCH, InventoryResult.STACKABLE_CANT_BE_WRAPPED, InventoryResult.EQUIPPED_CANT_BE_WRAPPED, InventoryResult.WRAPPED_CANT_BE_WRAPPED, InventoryResult.BOUND_CANT_BE_WRAPPED, InventoryResult.UNIQUE_CANT_BE_WRAPPED, InventoryResult.BAGS_CANT_BE_WRAPPED, InventoryResult.ALREADY_LOOTED, InventoryResult.INVENTORY_FULL, InventoryResult.BANK_FULL, InventoryResult.ITEM_IS_CURRENTLY_SOLD_OUT, InventoryResult.BAG_FULL3, InventoryResult.ITEM_NOT_FOUND2, InventoryResult.ITEM_CANT_STACK2, InventoryResult.BAG_FULL4, InventoryResult.ITEM_SOLD_OUT, InventoryResult.OBJECT_IS_BUSY, InventoryResult.NONE, InventoryResult.NOT_IN_COMBAT, InventoryResult.NOT_WHILE_DISARMED, InventoryResult.BAG_FULL6, InventoryResult.CANT_EQUIP_RANK, InventoryResult.CANT_EQUIP_REPUTATION, InventoryResult.TOO_MANY_SPECIAL_BAGS, InventoryResult.LOOT_CANT_LOOT_THAT_NOW, InventoryResult.ITEM_UNIQUE_EQUIPABLE, InventoryResult.VENDOR_MISSING_TURNINS, InventoryResult.NOT_ENOUGH_HONOR_POINTS, InventoryResult.NOT_ENOUGH_ARENA_POINTS, InventoryResult.ITEM_MAX_COUNT_SOCKETED, InventoryResult.MAIL_BOUND_ITEM, InventoryResult.NO_SPLIT_WHILE_PROSPECTING, InventoryResult.ITEM_MAX_COUNT_EQUIPPED_SOCKETED, InventoryResult.ITEM_UNIQUE_EQUIPPABLE_SOCKETED, InventoryResult.TOO_MUCH_GOLD, InventoryResult.NOT_DURING_ARENA_MATCH, InventoryResult.CANNOT_TRADE_THAT, InventoryResult.PERSONAL_ARENA_RATING_TOO_LOW, InventoryResult.EVENT_AUTOEQUIP_BIND_CONFIRM, InventoryResult.ARTEFACTS_ONLY_FOR_OWN_CHARACTERS, InventoryResult.ITEM_MAX_LIMIT_CATEGORY_COUNT_EXCEEDED, InventoryResult.ITEM_MAX_LIMIT_CATEGORY_SOCKETED_EXCEEDED, InventoryResult.SCALING_STAT_ITEM_LEVEL_EXCEEDED, InventoryResult.PURCHASE_LEVEL_TOO_LOW, InventoryResult.CANT_EQUIP_NEED_TALENT, InventoryResult.ITEM_MAX_LIMIT_CATEGORY_EQUIPPED_EXCEEDED}:
            _fmt += 'QQB'
            _data.extend([self.item1, self.item2, self.bag_type_subclass])
        if self.result == InventoryResult.CANT_EQUIP_LEVEL_I:
            _fmt += 'I'
            _data.append(self.required_level)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.result in {InventoryResult.CANT_EQUIP_LEVEL_I, InventoryResult.CANT_EQUIP_SKILL, InventoryResult.ITEM_DOESNT_GO_TO_SLOT, InventoryResult.BAG_FULL, InventoryResult.NONEMPTY_BAG_OVER_OTHER_BAG, InventoryResult.CANT_TRADE_EQUIP_BAGS, InventoryResult.ONLY_AMMO_CAN_GO_HERE, InventoryResult.NO_REQUIRED_PROFICIENCY, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE, InventoryResult.YOU_CAN_NEVER_USE_THAT_ITEM, InventoryResult.YOU_CAN_NEVER_USE_THAT_ITEM2, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE2, InventoryResult.CANT_EQUIP_WITH_TWOHANDED, InventoryResult.CANT_DUAL_WIELD, InventoryResult.ITEM_DOESNT_GO_INTO_BAG, InventoryResult.ITEM_DOESNT_GO_INTO_BAG2, InventoryResult.CANT_CARRY_MORE_OF_THIS, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE3, InventoryResult.ITEM_CANT_STACK, InventoryResult.ITEM_CANT_BE_EQUIPPED, InventoryResult.ITEMS_CANT_BE_SWAPPED, InventoryResult.SLOT_IS_EMPTY, InventoryResult.ITEM_NOT_FOUND, InventoryResult.CANT_DROP_SOULBOUND, InventoryResult.OUT_OF_RANGE, InventoryResult.TRIED_TO_SPLIT_MORE_THAN_COUNT, InventoryResult.COULDNT_SPLIT_ITEMS, InventoryResult.MISSING_REAGENT, InventoryResult.NOT_ENOUGH_MONEY, InventoryResult.NOT_A_BAG, InventoryResult.CAN_ONLY_DO_WITH_EMPTY_BAGS, InventoryResult.DONT_OWN_THAT_ITEM, InventoryResult.CAN_EQUIP_ONLY1_QUIVER, InventoryResult.MUST_PURCHASE_THAT_BAG_SLOT, InventoryResult.TOO_FAR_AWAY_FROM_BANK, InventoryResult.ITEM_LOCKED, InventoryResult.YOU_ARE_STUNNED, InventoryResult.YOU_ARE_DEAD, InventoryResult.CANT_DO_RIGHT_NOW, InventoryResult.INT_BAG_ERROR, InventoryResult.CAN_EQUIP_ONLY1_BOLT, InventoryResult.CAN_EQUIP_ONLY1_AMMOPOUCH, InventoryResult.STACKABLE_CANT_BE_WRAPPED, InventoryResult.EQUIPPED_CANT_BE_WRAPPED, InventoryResult.WRAPPED_CANT_BE_WRAPPED, InventoryResult.BOUND_CANT_BE_WRAPPED, InventoryResult.UNIQUE_CANT_BE_WRAPPED, InventoryResult.BAGS_CANT_BE_WRAPPED, InventoryResult.ALREADY_LOOTED, InventoryResult.INVENTORY_FULL, InventoryResult.BANK_FULL, InventoryResult.ITEM_IS_CURRENTLY_SOLD_OUT, InventoryResult.BAG_FULL3, InventoryResult.ITEM_NOT_FOUND2, InventoryResult.ITEM_CANT_STACK2, InventoryResult.BAG_FULL4, InventoryResult.ITEM_SOLD_OUT, InventoryResult.OBJECT_IS_BUSY, InventoryResult.NONE, InventoryResult.NOT_IN_COMBAT, InventoryResult.NOT_WHILE_DISARMED, InventoryResult.BAG_FULL6, InventoryResult.CANT_EQUIP_RANK, InventoryResult.CANT_EQUIP_REPUTATION, InventoryResult.TOO_MANY_SPECIAL_BAGS, InventoryResult.LOOT_CANT_LOOT_THAT_NOW, InventoryResult.ITEM_UNIQUE_EQUIPABLE, InventoryResult.VENDOR_MISSING_TURNINS, InventoryResult.NOT_ENOUGH_HONOR_POINTS, InventoryResult.NOT_ENOUGH_ARENA_POINTS, InventoryResult.ITEM_MAX_COUNT_SOCKETED, InventoryResult.MAIL_BOUND_ITEM, InventoryResult.NO_SPLIT_WHILE_PROSPECTING, InventoryResult.ITEM_MAX_COUNT_EQUIPPED_SOCKETED, InventoryResult.ITEM_UNIQUE_EQUIPPABLE_SOCKETED, InventoryResult.TOO_MUCH_GOLD, InventoryResult.NOT_DURING_ARENA_MATCH, InventoryResult.CANNOT_TRADE_THAT, InventoryResult.PERSONAL_ARENA_RATING_TOO_LOW, InventoryResult.EVENT_AUTOEQUIP_BIND_CONFIRM, InventoryResult.ARTEFACTS_ONLY_FOR_OWN_CHARACTERS, InventoryResult.ITEM_MAX_LIMIT_CATEGORY_COUNT_EXCEEDED, InventoryResult.ITEM_MAX_LIMIT_CATEGORY_SOCKETED_EXCEEDED, InventoryResult.SCALING_STAT_ITEM_LEVEL_EXCEEDED, InventoryResult.PURCHASE_LEVEL_TOO_LOW, InventoryResult.CANT_EQUIP_NEED_TALENT, InventoryResult.ITEM_MAX_LIMIT_CATEGORY_EQUIPPED_EXCEEDED}:
            _size += 17

        if self.result == InventoryResult.CANT_EQUIP_LEVEL_I:
            _size += 4

        return _size


@dataclasses.dataclass
class CMSG_INSPECT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_INSPECT:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_INSPECT(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0114))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_INITIATE_TRADE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_INITIATE_TRADE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_INITIATE_TRADE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0116))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BEGIN_TRADE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BEGIN_TRADE:
        return CMSG_BEGIN_TRADE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0117))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BUSY_TRADE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BUSY_TRADE:
        return CMSG_BUSY_TRADE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0118))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_IGNORE_TRADE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_IGNORE_TRADE:
        return CMSG_IGNORE_TRADE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0119))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ACCEPT_TRADE:
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ACCEPT_TRADE:
        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return CMSG_ACCEPT_TRADE(
            unknown1=unknown1,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x011A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.unknown1)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_UNACCEPT_TRADE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_UNACCEPT_TRADE:
        return CMSG_UNACCEPT_TRADE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x011B))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CANCEL_TRADE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_TRADE:
        return CMSG_CANCEL_TRADE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x011C))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_TRADE_ITEM:
    trade_slot: int
    bag: int
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_TRADE_ITEM:
        # trade_slot: u8
        trade_slot = await read_int(reader, 1)

        # bag: u8
        bag = await read_int(reader, 1)

        # slot: u8
        slot = await read_int(reader, 1)

        return CMSG_SET_TRADE_ITEM(
            trade_slot=trade_slot,
            bag=bag,
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(3 + 4, 0x011D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBB'
        _data.extend([self.trade_slot, self.bag, self.slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CLEAR_TRADE_ITEM:
    trade_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CLEAR_TRADE_ITEM:
        # trade_slot: u8
        trade_slot = await read_int(reader, 1)

        return CMSG_CLEAR_TRADE_ITEM(
            trade_slot=trade_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x011E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.trade_slot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_TRADE_GOLD:
    gold: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_TRADE_GOLD:
        # gold: Gold
        gold = await read_int(reader, 4)

        return CMSG_SET_TRADE_GOLD(
            gold=gold,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x011F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.gold)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TRADE_STATUS:
    status: TradeStatus
    unknown1: typing.Optional[int] = None
    inventory_result: typing.Optional[InventoryResult] = None
    target_error: typing.Optional[bool] = None
    item_limit_category_id: typing.Optional[int] = None
    slot: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRADE_STATUS:
        unknown1 = None
        inventory_result = None
        target_error = None
        item_limit_category_id = None
        slot = None
        # status: TradeStatus
        status = TradeStatus(await read_int(reader, 4))

        if status == TradeStatus.BEGIN_TRADE:
            # unknown1: Guid
            unknown1 = await read_int(reader, 8)

        elif status == TradeStatus.CLOSE_WINDOW:
            # inventory_result: InventoryResult
            inventory_result = InventoryResult(await read_int(reader, 4))

            # target_error: Bool8
            target_error = await read_bool(reader, 1)

            # item_limit_category_id: u32
            item_limit_category_id = await read_int(reader, 4)

        elif status in {TradeStatus.ONLY_CONJURED, TradeStatus.NOT_ON_TAPLIST}:
            # slot: u8
            slot = await read_int(reader, 1)

        return SMSG_TRADE_STATUS(
            status=status,
            unknown1=unknown1,
            inventory_result=inventory_result,
            target_error=target_error,
            item_limit_category_id=item_limit_category_id,
            slot=slot,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0120))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.status.value)
        if self.status == TradeStatus.BEGIN_TRADE:
            _fmt += 'Q'
            _data.append(self.unknown1)
        elif self.status == TradeStatus.CLOSE_WINDOW:
            _fmt += 'IBI'
            _data.extend([self.inventory_result.value, self.target_error, self.item_limit_category_id])
        elif self.status in {TradeStatus.ONLY_CONJURED, TradeStatus.NOT_ON_TAPLIST}:
            _fmt += 'B'
            _data.append(self.slot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        if self.status == TradeStatus.BEGIN_TRADE:
            _size += 8
        elif self.status == TradeStatus.CLOSE_WINDOW:
            _size += 9
        elif self.status in {TradeStatus.ONLY_CONJURED, TradeStatus.NOT_ON_TAPLIST}:
            _size += 1

        return _size


@dataclasses.dataclass
class SMSG_TRADE_STATUS_EXTENDED:
    self_player: bool
    trade_id: int
    trade_slot_count1: int
    trade_slot_count2: int
    money_in_trade: int
    spell_on_lowest_slot: int
    trade_slots: typing.List[TradeSlot]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRADE_STATUS_EXTENDED:
        # self_player: Bool8
        self_player = await read_bool(reader, 1)

        # trade_id: u32
        trade_id = await read_int(reader, 4)

        # trade_slot_count1: u32
        trade_slot_count1 = await read_int(reader, 4)

        # trade_slot_count2: u32
        trade_slot_count2 = await read_int(reader, 4)

        # money_in_trade: Gold
        money_in_trade = await read_int(reader, 4)

        # spell_on_lowest_slot: Spell
        spell_on_lowest_slot = await read_int(reader, 4)

        # trade_slots: TradeSlot[7]
        trade_slots = []
        for _ in range(0, 7):
            trade_slots.append(await TradeSlot.read(reader))

        return SMSG_TRADE_STATUS_EXTENDED(
            self_player=self_player,
            trade_id=trade_id,
            trade_slot_count1=trade_slot_count1,
            trade_slot_count2=trade_slot_count2,
            money_in_trade=money_in_trade,
            spell_on_lowest_slot=spell_on_lowest_slot,
            trade_slots=trade_slots,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(532 + 2, 0x0121))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BIIIII'
        _data.extend([self.self_player, self.trade_id, self.trade_slot_count1, self.trade_slot_count2, self.money_in_trade, self.spell_on_lowest_slot])
        # trade_slots: TradeSlot[7]
        for i in self.trade_slots:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_INITIALIZE_FACTIONS:
    factions: typing.List[FactionInitializer]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INITIALIZE_FACTIONS:
        # amount_of_factions: u32
        amount_of_factions = await read_int(reader, 4)

        # factions: FactionInitializer[amount_of_factions]
        factions = []
        for _ in range(0, amount_of_factions):
            factions.append(await FactionInitializer.read(reader))

        return SMSG_INITIALIZE_FACTIONS(
            factions=factions,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0122))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.factions))
        # factions: FactionInitializer[amount_of_factions]
        for i in self.factions:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + 5 * len(self.factions)


@dataclasses.dataclass
class SMSG_SET_FACTION_VISIBLE:
    faction: Faction

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_FACTION_VISIBLE:
        # faction: Faction
        faction = Faction(await read_int(reader, 2))

        return SMSG_SET_FACTION_VISIBLE(
            faction=faction,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 2, 0x0123))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'H'
        _data.append(self.faction.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SET_FACTION_STANDING:
    refer_a_friend_bonus: float
    any_rank_increased: bool
    faction_standings: typing.List[FactionStanding]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_FACTION_STANDING:
        # refer_a_friend_bonus: f32
        refer_a_friend_bonus = await read_float(reader)

        # any_rank_increased: Bool8
        any_rank_increased = await read_bool(reader, 1)

        # amount_of_faction_standings: u32
        amount_of_faction_standings = await read_int(reader, 4)

        # faction_standings: FactionStanding[amount_of_faction_standings]
        faction_standings = []
        for _ in range(0, amount_of_faction_standings):
            faction_standings.append(await FactionStanding.read(reader))

        return SMSG_SET_FACTION_STANDING(
            refer_a_friend_bonus=refer_a_friend_bonus,
            any_rank_increased=any_rank_increased,
            faction_standings=faction_standings,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0124))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'fBI'
        _data.extend([self.refer_a_friend_bonus, self.any_rank_increased, len(self.faction_standings)])
        # faction_standings: FactionStanding[amount_of_faction_standings]
        for i in self.faction_standings:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + 6 * len(self.faction_standings)


@dataclasses.dataclass
class CMSG_SET_FACTION_ATWAR:
    faction: Faction
    flags: FactionFlag

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_FACTION_ATWAR:
        # faction: Faction
        faction = Faction(await read_int(reader, 2))

        # flags: FactionFlag
        flags = FactionFlag(await read_int(reader, 1))

        return CMSG_SET_FACTION_ATWAR(
            faction=faction,
            flags=flags,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(3 + 4, 0x0125))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'HB'
        _data.extend([self.faction.value, self.flags.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SET_PROFICIENCY:
    class_type: ItemClass
    item_sub_class_mask: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_PROFICIENCY:
        # class_type: ItemClass
        class_type = ItemClass(await read_int(reader, 1))

        # item_sub_class_mask: u32
        item_sub_class_mask = await read_int(reader, 4)

        return SMSG_SET_PROFICIENCY(
            class_type=class_type,
            item_sub_class_mask=item_sub_class_mask,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x0127))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BI'
        _data.extend([self.class_type.value, self.item_sub_class_mask])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_ACTION_BUTTON:
    button: int
    action: int
    misc: int
    action_type: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_ACTION_BUTTON:
        # button: u8
        button = await read_int(reader, 1)

        # action: u16
        action = await read_int(reader, 2)

        # misc: u8
        misc = await read_int(reader, 1)

        # action_type: u8
        action_type = await read_int(reader, 1)

        return CMSG_SET_ACTION_BUTTON(
            button=button,
            action=action,
            misc=misc,
            action_type=action_type,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 4, 0x0128))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BHBB'
        _data.extend([self.button, self.action, self.misc, self.action_type])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ACTION_BUTTONS:
    behavior: ActionBarBehavior
    data: typing.Optional[typing.List[ActionButton]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ACTION_BUTTONS:
        data = None
        # behavior: ActionBarBehavior
        behavior = ActionBarBehavior(await read_int(reader, 1))

        if behavior in {ActionBarBehavior.INITIAL, ActionBarBehavior.SET}:
            # data: ActionButton[144]
            data = []
            for _ in range(0, 144):
                data.append(await ActionButton.read(reader))

        return SMSG_ACTION_BUTTONS(
            behavior=behavior,
            data=data,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0129))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.behavior.value)
        if self.behavior in {ActionBarBehavior.INITIAL, ActionBarBehavior.SET}:
            # data: ActionButton[144]
            for i in self.data:
                _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.behavior in {ActionBarBehavior.INITIAL, ActionBarBehavior.SET}:
            _size += 576

        return _size


@dataclasses.dataclass
class SMSG_INITIAL_SPELLS:
    unknown1: int
    initial_spells: typing.List[InitialSpell]
    cooldowns: typing.List[CooldownSpell]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INITIAL_SPELLS:
        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # spell_count: u16
        spell_count = await read_int(reader, 2)

        # initial_spells: InitialSpell[spell_count]
        initial_spells = []
        for _ in range(0, spell_count):
            initial_spells.append(await InitialSpell.read(reader))

        # cooldown_count: u16
        cooldown_count = await read_int(reader, 2)

        # cooldowns: CooldownSpell[cooldown_count]
        cooldowns = []
        for _ in range(0, cooldown_count):
            cooldowns.append(await CooldownSpell.read(reader))

        return SMSG_INITIAL_SPELLS(
            unknown1=unknown1,
            initial_spells=initial_spells,
            cooldowns=cooldowns,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x012A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BH'
        _data.extend([self.unknown1, len(self.initial_spells)])
        # initial_spells: InitialSpell[spell_count]
        for i in self.initial_spells:
            _fmt, _data = i.write(_fmt, _data)

        # cooldown_count: u16
        _fmt += 'H'
        _data.append(len(self.cooldowns))

        # cooldowns: CooldownSpell[cooldown_count]
        for i in self.cooldowns:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + 6 * len(self.initial_spells) + 14 * len(self.cooldowns)


@dataclasses.dataclass
class SMSG_LEARNED_SPELL:
    id: int
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LEARNED_SPELL:
        # id: Spell
        id = await read_int(reader, 4)

        # unknown: u16
        unknown = await read_int(reader, 2)

        return SMSG_LEARNED_SPELL(
            id=id,
            unknown=unknown,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(6 + 2, 0x012B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IH'
        _data.extend([self.id, self.unknown])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SUPERCEDED_SPELL:
    new: int
    old: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SUPERCEDED_SPELL:
        # new: Spell
        new = await read_int(reader, 4)

        # old: Spell
        old = await read_int(reader, 4)

        return SMSG_SUPERCEDED_SPELL(
            new=new,
            old=old,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x012C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.new, self.old])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CAST_SPELL:
    cast_count: int
    spell: int
    cast_flags: ClientCastFlags
    targets: SpellCastTargets
    elevation: typing.Optional[float] = None
    speed: typing.Optional[float] = None
    movement_data: typing.Optional[ClientMovementData] = None
    opcode: typing.Optional[int] = None
    guid: typing.Optional[int] = None
    info: typing.Optional[MovementInfo] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CAST_SPELL:
        elevation = None
        speed = None
        movement_data = None
        opcode = None
        guid = None
        info = None
        # cast_count: u8
        cast_count = await read_int(reader, 1)

        # spell: Spell
        spell = await read_int(reader, 4)

        # cast_flags: ClientCastFlags
        cast_flags = ClientCastFlags(await read_int(reader, 1))

        # targets: SpellCastTargets
        targets = await SpellCastTargets.read(reader)

        if cast_flags == ClientCastFlags.EXTRA:
            # elevation: f32
            elevation = await read_float(reader)

            # speed: f32
            speed = await read_float(reader)

            # movement_data: ClientMovementData
            movement_data = ClientMovementData(await read_int(reader, 1))

            if movement_data == ClientMovementData.PRESENT:
                # opcode: u32
                opcode = await read_int(reader, 4)

                # guid: PackedGuid
                guid = await read_packed_guid(reader)

                # info: MovementInfo
                info = await MovementInfo.read(reader)

        return CMSG_CAST_SPELL(
            cast_count=cast_count,
            spell=spell,
            cast_flags=cast_flags,
            targets=targets,
            elevation=elevation,
            speed=speed,
            movement_data=movement_data,
            opcode=opcode,
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x012E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BIB'
        _data.extend([self.cast_count, self.spell, self.cast_flags.value])
        # targets: SpellCastTargets
        _fmt, _data = self.targets.write(_fmt, _data)

        if self.cast_flags == ClientCastFlags.EXTRA:
            _fmt += 'ffB'
            _data.extend([self.elevation, self.speed, self.movement_data.value])
            if self.movement_data == ClientMovementData.PRESENT:
                _fmt += 'I'
                _data.append(self.opcode)
                # guid: PackedGuid
                _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

                # info: MovementInfo
                _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 6 + self.targets.size()

        if self.cast_flags == ClientCastFlags.EXTRA:
            _size += 9

            if self.movement_data == ClientMovementData.PRESENT:
                _size += 4 + packed_guid_size(self.guid) + self.info.size()


        return _size


@dataclasses.dataclass
class CMSG_CANCEL_CAST:
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_CAST:
        # id: Spell
        id = await read_int(reader, 4)

        return CMSG_CANCEL_CAST(
            id=id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x012F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CAST_FAILED:
    cast_count: int
    id: int
    result: SpellCastResult
    multiple_casts: bool
    spell_focus: typing.Optional[int] = None
    area: typing.Optional[Area] = None
    totems: typing.Optional[typing.List[int]] = None
    totem_categories: typing.Optional[typing.List[int]] = None
    item_class: typing.Optional[int] = None
    item_sub_class: typing.Optional[int] = None
    item_limit_category: typing.Optional[int] = None
    custom_error: typing.Optional[int] = None
    missing_item: typing.Optional[int] = None
    mechanic: typing.Optional[int] = None
    equipped_item_sub_class: typing.Optional[int] = None
    item: typing.Optional[int] = None
    count: typing.Optional[int] = None
    skill: typing.Optional[Skill] = None
    skill_required: typing.Optional[int] = None
    fishing_skill_required: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CAST_FAILED:
        spell_focus = None
        area = None
        totems = None
        totem_categories = None
        item_class = None
        item_sub_class = None
        item_limit_category = None
        custom_error = None
        missing_item = None
        mechanic = None
        equipped_item_sub_class = None
        item = None
        count = None
        skill = None
        skill_required = None
        fishing_skill_required = None
        # cast_count: u8
        cast_count = await read_int(reader, 1)

        # id: Spell
        id = await read_int(reader, 4)

        # result: SpellCastResult
        result = SpellCastResult(await read_int(reader, 1))

        # multiple_casts: Bool8
        multiple_casts = await read_bool(reader, 1)

        if result == SpellCastResult.REQUIRES_SPELL_FOCUS:
            # spell_focus: u32
            spell_focus = await read_int(reader, 4)

        elif result == SpellCastResult.REQUIRES_AREA:
            # area: Area
            area = Area(await read_int(reader, 4))

        elif result == SpellCastResult.TOTEMS:
            # totems: u32[2]
            totems = []
            for _ in range(0, 2):
                totems.append(await read_int(reader, 4))

        elif result == SpellCastResult.TOTEM_CATEGORY:
            # totem_categories: u32[2]
            totem_categories = []
            for _ in range(0, 2):
                totem_categories.append(await read_int(reader, 4))

        elif result in {SpellCastResult.EQUIPPED_ITEM_CLASS, SpellCastResult.EQUIPPED_ITEM_CLASS_OFFHAND, SpellCastResult.EQUIPPED_ITEM_CLASS_MAINHAND}:
            # item_class: u32
            item_class = await read_int(reader, 4)

            # item_sub_class: u32
            item_sub_class = await read_int(reader, 4)

        elif result == SpellCastResult.TOO_MANY_OF_ITEM:
            # item_limit_category: u32
            item_limit_category = await read_int(reader, 4)

        elif result == SpellCastResult.CUSTOM_ERROR:
            # custom_error: u32
            custom_error = await read_int(reader, 4)

        elif result == SpellCastResult.REAGENTS:
            # missing_item: u32
            missing_item = await read_int(reader, 4)

        elif result == SpellCastResult.PREVENTED_BY_MECHANIC:
            # mechanic: u32
            mechanic = await read_int(reader, 4)

        elif result == SpellCastResult.NEED_EXOTIC_AMMO:
            # equipped_item_sub_class: u32
            equipped_item_sub_class = await read_int(reader, 4)

        elif result == SpellCastResult.NEED_MORE_ITEMS:
            # item: Item
            item = await read_int(reader, 4)

            # count: u32
            count = await read_int(reader, 4)

        elif result == SpellCastResult.MIN_SKILL:
            # skill: Skill
            skill = Skill(await read_int(reader, 4))

            # skill_required: u32
            skill_required = await read_int(reader, 4)

        elif result == SpellCastResult.FISHING_TOO_LOW:
            # fishing_skill_required: u32
            fishing_skill_required = await read_int(reader, 4)

        return SMSG_CAST_FAILED(
            cast_count=cast_count,
            id=id,
            result=result,
            multiple_casts=multiple_casts,
            spell_focus=spell_focus,
            area=area,
            totems=totems,
            totem_categories=totem_categories,
            item_class=item_class,
            item_sub_class=item_sub_class,
            item_limit_category=item_limit_category,
            custom_error=custom_error,
            missing_item=missing_item,
            mechanic=mechanic,
            equipped_item_sub_class=equipped_item_sub_class,
            item=item,
            count=count,
            skill=skill,
            skill_required=skill_required,
            fishing_skill_required=fishing_skill_required,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0130))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BIBB'
        _data.extend([self.cast_count, self.id, self.result.value, self.multiple_casts])
        if self.result == SpellCastResult.REQUIRES_SPELL_FOCUS:
            _fmt += 'I'
            _data.append(self.spell_focus)
        elif self.result == SpellCastResult.REQUIRES_AREA:
            _fmt += 'I'
            _data.append(self.area.value)
        elif self.result == SpellCastResult.TOTEMS:
            _fmt += f'{len(self.totems)}I'
            _data.extend([*self.totems])
        elif self.result == SpellCastResult.TOTEM_CATEGORY:
            _fmt += f'{len(self.totem_categories)}I'
            _data.extend([*self.totem_categories])
        elif self.result in {SpellCastResult.EQUIPPED_ITEM_CLASS, SpellCastResult.EQUIPPED_ITEM_CLASS_OFFHAND, SpellCastResult.EQUIPPED_ITEM_CLASS_MAINHAND}:
            _fmt += 'II'
            _data.extend([self.item_class, self.item_sub_class])
        elif self.result == SpellCastResult.TOO_MANY_OF_ITEM:
            _fmt += 'I'
            _data.append(self.item_limit_category)
        elif self.result == SpellCastResult.CUSTOM_ERROR:
            _fmt += 'I'
            _data.append(self.custom_error)
        elif self.result == SpellCastResult.REAGENTS:
            _fmt += 'I'
            _data.append(self.missing_item)
        elif self.result == SpellCastResult.PREVENTED_BY_MECHANIC:
            _fmt += 'I'
            _data.append(self.mechanic)
        elif self.result == SpellCastResult.NEED_EXOTIC_AMMO:
            _fmt += 'I'
            _data.append(self.equipped_item_sub_class)
        elif self.result == SpellCastResult.NEED_MORE_ITEMS:
            _fmt += 'II'
            _data.extend([self.item, self.count])
        elif self.result == SpellCastResult.MIN_SKILL:
            _fmt += 'II'
            _data.extend([self.skill.value, self.skill_required])
        elif self.result == SpellCastResult.FISHING_TOO_LOW:
            _fmt += 'I'
            _data.append(self.fishing_skill_required)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 7

        if self.result == SpellCastResult.REQUIRES_SPELL_FOCUS:
            _size += 4
        elif self.result == SpellCastResult.REQUIRES_AREA:
            _size += 4
        elif self.result == SpellCastResult.TOTEMS:
            _size += 8
        elif self.result == SpellCastResult.TOTEM_CATEGORY:
            _size += 8
        elif self.result in {SpellCastResult.EQUIPPED_ITEM_CLASS, SpellCastResult.EQUIPPED_ITEM_CLASS_OFFHAND, SpellCastResult.EQUIPPED_ITEM_CLASS_MAINHAND}:
            _size += 8
        elif self.result == SpellCastResult.TOO_MANY_OF_ITEM:
            _size += 4
        elif self.result == SpellCastResult.CUSTOM_ERROR:
            _size += 4
        elif self.result == SpellCastResult.REAGENTS:
            _size += 4
        elif self.result == SpellCastResult.PREVENTED_BY_MECHANIC:
            _size += 4
        elif self.result == SpellCastResult.NEED_EXOTIC_AMMO:
            _size += 4
        elif self.result == SpellCastResult.NEED_MORE_ITEMS:
            _size += 8
        elif self.result == SpellCastResult.MIN_SKILL:
            _size += 8
        elif self.result == SpellCastResult.FISHING_TOO_LOW:
            _size += 4

        return _size


@dataclasses.dataclass
class SMSG_SPELL_START:
    cast_item: int
    caster: int
    cast_count: int
    spell: int
    flags: CastFlags
    timer: int
    targets: SpellCastTargets
    power: typing.Optional[Power] = None
    ammo_display_id: typing.Optional[int] = None
    ammo_inventory_type: typing.Optional[int] = None
    unknown1: typing.Optional[int] = None
    unknown2: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELL_START:
        power = None
        ammo_display_id = None
        ammo_inventory_type = None
        unknown1 = None
        unknown2 = None
        # cast_item: PackedGuid
        cast_item = await read_packed_guid(reader)

        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # cast_count: u8
        cast_count = await read_int(reader, 1)

        # spell: Spell
        spell = await read_int(reader, 4)

        # flags: CastFlags
        flags = CastFlags(await read_int(reader, 4))

        # timer: u32
        timer = await read_int(reader, 4)

        # targets: SpellCastTargets
        targets = await SpellCastTargets.read(reader)

        if CastFlags.POWER_LEFT_SELF in flags:
            # power: Power
            power = Power(await read_int(reader, 4))

        if CastFlags.AMMO in flags:
            # ammo_display_id: u32
            ammo_display_id = await read_int(reader, 4)

            # ammo_inventory_type: u32
            ammo_inventory_type = await read_int(reader, 4)

        if CastFlags.UNKNOWN_23 in flags:
            # unknown1: u32
            unknown1 = await read_int(reader, 4)

            # unknown2: u32
            unknown2 = await read_int(reader, 4)

        return SMSG_SPELL_START(
            cast_item=cast_item,
            caster=caster,
            cast_count=cast_count,
            spell=spell,
            flags=flags,
            timer=timer,
            targets=targets,
            power=power,
            ammo_display_id=ammo_display_id,
            ammo_inventory_type=ammo_inventory_type,
            unknown1=unknown1,
            unknown2=unknown2,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0131))
        _fmt = "<4s"
        _data = [_data]

        # cast_item: PackedGuid
        _fmt, _data = packed_guid_write(self.cast_item, _fmt, _data)

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # cast_count: u8
        _fmt += 'B'
        _data.append(self.cast_count)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # flags: CastFlags
        _fmt += 'I'
        _data.append(self.flags.value)

        # timer: u32
        _fmt += 'I'
        _data.append(self.timer)

        # targets: SpellCastTargets
        _fmt, _data = self.targets.write(_fmt, _data)

        if CastFlags.POWER_LEFT_SELF in self.flags:
            _fmt += 'I'
            _data.append(self.power.value)
        if CastFlags.AMMO in self.flags:
            _fmt += 'II'
            _data.extend([self.ammo_display_id, self.ammo_inventory_type])
        if CastFlags.UNKNOWN_23 in self.flags:
            _fmt += 'II'
            _data.extend([self.unknown1, self.unknown2])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 13 + packed_guid_size(self.cast_item) + packed_guid_size(self.caster) + self.targets.size()

        if CastFlags.POWER_LEFT_SELF in self.flags:
            _size += 4

        if CastFlags.AMMO in self.flags:
            _size += 8

        if CastFlags.UNKNOWN_23 in self.flags:
            _size += 8

        return _size


@dataclasses.dataclass
class SMSG_SPELL_GO:
    cast_item: int
    caster: int
    extra_casts: int
    spell: int
    flags: GameobjectCastFlags
    timestamp: int
    hits: typing.List[int]
    misses: typing.List[SpellMiss]
    targets: SpellCastTargets
    power: typing.Optional[Power] = None
    rune_mask_initial: typing.Optional[int] = None
    rune_mask_after_cast: typing.Optional[int] = None
    rune_cooldowns: typing.Optional[typing.List[int]] = None
    elevation: typing.Optional[float] = None
    delay_trajectory: typing.Optional[int] = None
    ammo_display_id: typing.Optional[int] = None
    ammo_inventory_type: typing.Optional[int] = None
    unknown1: typing.Optional[int] = None
    unknown2: typing.Optional[int] = None
    unknown3: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELL_GO:
        power = None
        rune_mask_initial = None
        rune_mask_after_cast = None
        rune_cooldowns = None
        elevation = None
        delay_trajectory = None
        ammo_display_id = None
        ammo_inventory_type = None
        unknown1 = None
        unknown2 = None
        unknown3 = None
        # cast_item: PackedGuid
        cast_item = await read_packed_guid(reader)

        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # extra_casts: u8
        extra_casts = await read_int(reader, 1)

        # spell: Spell
        spell = await read_int(reader, 4)

        # flags: GameobjectCastFlags
        flags = GameobjectCastFlags(await read_int(reader, 4))

        # timestamp: u32
        timestamp = await read_int(reader, 4)

        # amount_of_hits: u8
        amount_of_hits = await read_int(reader, 1)

        # hits: Guid[amount_of_hits]
        hits = []
        for _ in range(0, amount_of_hits):
            hits.append(await read_int(reader, 8))

        # amount_of_misses: u8
        amount_of_misses = await read_int(reader, 1)

        # misses: SpellMiss[amount_of_misses]
        misses = []
        for _ in range(0, amount_of_misses):
            misses.append(await SpellMiss.read(reader))

        # targets: SpellCastTargets
        targets = await SpellCastTargets.read(reader)

        if GameobjectCastFlags.POWER_UPDATE in flags:
            # power: Power
            power = Power(await read_int(reader, 4))

        if GameobjectCastFlags.RUNE_UPDATE in flags:
            # rune_mask_initial: u8
            rune_mask_initial = await read_int(reader, 1)

            # rune_mask_after_cast: u8
            rune_mask_after_cast = await read_int(reader, 1)

            # rune_cooldowns: u8[6]
            rune_cooldowns = []
            for _ in range(0, 6):
                rune_cooldowns.append(await read_int(reader, 1))

        if GameobjectCastFlags.ADJUST_MISSILE in flags:
            # elevation: f32
            elevation = await read_float(reader)

            # delay_trajectory: u32
            delay_trajectory = await read_int(reader, 4)

        if GameobjectCastFlags.AMMO in flags:
            # ammo_display_id: u32
            ammo_display_id = await read_int(reader, 4)

            # ammo_inventory_type: u32
            ammo_inventory_type = await read_int(reader, 4)

        if GameobjectCastFlags.VISUAL_CHAIN in flags:
            # unknown1: u32
            unknown1 = await read_int(reader, 4)

            # unknown2: u32
            unknown2 = await read_int(reader, 4)

        if GameobjectCastFlags.DEST_LOCATION in flags:
            # unknown3: u8
            unknown3 = await read_int(reader, 1)

        return SMSG_SPELL_GO(
            cast_item=cast_item,
            caster=caster,
            extra_casts=extra_casts,
            spell=spell,
            flags=flags,
            timestamp=timestamp,
            hits=hits,
            misses=misses,
            targets=targets,
            power=power,
            rune_mask_initial=rune_mask_initial,
            rune_mask_after_cast=rune_mask_after_cast,
            rune_cooldowns=rune_cooldowns,
            elevation=elevation,
            delay_trajectory=delay_trajectory,
            ammo_display_id=ammo_display_id,
            ammo_inventory_type=ammo_inventory_type,
            unknown1=unknown1,
            unknown2=unknown2,
            unknown3=unknown3,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0132))
        _fmt = "<4s"
        _data = [_data]

        # cast_item: PackedGuid
        _fmt, _data = packed_guid_write(self.cast_item, _fmt, _data)

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # extra_casts: u8
        _fmt += 'B'
        _data.append(self.extra_casts)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # flags: GameobjectCastFlags
        _fmt += 'I'
        _data.append(self.flags.value)

        # timestamp: u32
        _fmt += 'I'
        _data.append(self.timestamp)

        # amount_of_hits: u8
        _fmt += 'B'
        _data.append(len(self.hits))

        # hits: Guid[amount_of_hits]
        _fmt += f'{len(self.hits)}Q'
        _data.extend([*self.hits])

        # amount_of_misses: u8
        _fmt += 'B'
        _data.append(len(self.misses))

        # misses: SpellMiss[amount_of_misses]
        for i in self.misses:
            _fmt, _data = i.write(_fmt, _data)

        # targets: SpellCastTargets
        _fmt, _data = self.targets.write(_fmt, _data)

        if GameobjectCastFlags.POWER_UPDATE in self.flags:
            _fmt += 'I'
            _data.append(self.power.value)
        if GameobjectCastFlags.RUNE_UPDATE in self.flags:
            _fmt += f'BB{len(self.rune_cooldowns)}B'
            _data.extend([self.rune_mask_initial, self.rune_mask_after_cast, *self.rune_cooldowns])
        if GameobjectCastFlags.ADJUST_MISSILE in self.flags:
            _fmt += 'fI'
            _data.extend([self.elevation, self.delay_trajectory])
        if GameobjectCastFlags.AMMO in self.flags:
            _fmt += 'II'
            _data.extend([self.ammo_display_id, self.ammo_inventory_type])
        if GameobjectCastFlags.VISUAL_CHAIN in self.flags:
            _fmt += 'II'
            _data.extend([self.unknown1, self.unknown2])
        if GameobjectCastFlags.DEST_LOCATION in self.flags:
            _fmt += 'B'
            _data.append(self.unknown3)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 15 + packed_guid_size(self.cast_item) + packed_guid_size(self.caster) + 8 * len(self.hits) + sum([i.size() for i in self.misses]) + self.targets.size()

        if GameobjectCastFlags.POWER_UPDATE in self.flags:
            _size += 4

        if GameobjectCastFlags.RUNE_UPDATE in self.flags:
            _size += 8

        if GameobjectCastFlags.ADJUST_MISSILE in self.flags:
            _size += 8

        if GameobjectCastFlags.AMMO in self.flags:
            _size += 8

        if GameobjectCastFlags.VISUAL_CHAIN in self.flags:
            _size += 8

        if GameobjectCastFlags.DEST_LOCATION in self.flags:
            _size += 1

        return _size


@dataclasses.dataclass
class SMSG_SPELL_FAILURE:
    guid: int
    extra_casts: int
    spell: int
    result: SpellCastResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELL_FAILURE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # extra_casts: u8
        extra_casts = await read_int(reader, 1)

        # spell: Spell
        spell = await read_int(reader, 4)

        # result: SpellCastResult
        result = SpellCastResult(await read_int(reader, 1))

        return SMSG_SPELL_FAILURE(
            guid=guid,
            extra_casts=extra_casts,
            spell=spell,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(14 + 2, 0x0133))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QBIB'
        _data.extend([self.guid, self.extra_casts, self.spell, self.result.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELL_COOLDOWN:
    guid: int
    flags: int
    cooldowns: typing.List[SpellCooldownStatus]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELL_COOLDOWN:
        _size = 0

        # guid: Guid
        guid = await read_int(reader, 8)
        _size += 8

        # flags: u8
        flags = await read_int(reader, 1)
        _size += 1

        # cooldowns: SpellCooldownStatus[-]
        cooldowns = []
        while _size < body_size:
            cooldowns.append(await SpellCooldownStatus.read(reader))
            _size += 8

        return SMSG_SPELL_COOLDOWN(
            guid=guid,
            flags=flags,
            cooldowns=cooldowns,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0134))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.flags])
        # cooldowns: SpellCooldownStatus[-]
        for i in self.cooldowns:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + 8 * len(self.cooldowns)


@dataclasses.dataclass
class SMSG_COOLDOWN_EVENT:
    id: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_COOLDOWN_EVENT:
        # id: Spell
        id = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_COOLDOWN_EVENT(
            id=id,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0135))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.id, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CANCEL_AURA:
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_AURA:
        # id: Spell
        id = await read_int(reader, 4)

        return CMSG_CANCEL_AURA(
            id=id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0136))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PET_CAST_FAILED:
    cast_count: int
    id: int
    result: SpellCastResult
    multiple_casts: bool
    spell_focus: typing.Optional[int] = None
    area: typing.Optional[Area] = None
    totems: typing.Optional[typing.List[int]] = None
    totem_categories: typing.Optional[typing.List[int]] = None
    item_class: typing.Optional[int] = None
    item_sub_class: typing.Optional[int] = None
    item_limit_category: typing.Optional[int] = None
    custom_error: typing.Optional[int] = None
    missing_item: typing.Optional[int] = None
    mechanic: typing.Optional[int] = None
    equipped_item_sub_class: typing.Optional[int] = None
    item: typing.Optional[int] = None
    count: typing.Optional[int] = None
    skill: typing.Optional[Skill] = None
    skill_required: typing.Optional[int] = None
    fishing_skill_required: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_CAST_FAILED:
        spell_focus = None
        area = None
        totems = None
        totem_categories = None
        item_class = None
        item_sub_class = None
        item_limit_category = None
        custom_error = None
        missing_item = None
        mechanic = None
        equipped_item_sub_class = None
        item = None
        count = None
        skill = None
        skill_required = None
        fishing_skill_required = None
        # cast_count: u8
        cast_count = await read_int(reader, 1)

        # id: Spell
        id = await read_int(reader, 4)

        # result: SpellCastResult
        result = SpellCastResult(await read_int(reader, 1))

        # multiple_casts: Bool8
        multiple_casts = await read_bool(reader, 1)

        if result == SpellCastResult.REQUIRES_SPELL_FOCUS:
            # spell_focus: u32
            spell_focus = await read_int(reader, 4)

        elif result == SpellCastResult.REQUIRES_AREA:
            # area: Area
            area = Area(await read_int(reader, 4))

        elif result == SpellCastResult.TOTEMS:
            # totems: u32[2]
            totems = []
            for _ in range(0, 2):
                totems.append(await read_int(reader, 4))

        elif result == SpellCastResult.TOTEM_CATEGORY:
            # totem_categories: u32[2]
            totem_categories = []
            for _ in range(0, 2):
                totem_categories.append(await read_int(reader, 4))

        elif result in {SpellCastResult.EQUIPPED_ITEM_CLASS, SpellCastResult.EQUIPPED_ITEM_CLASS_OFFHAND, SpellCastResult.EQUIPPED_ITEM_CLASS_MAINHAND}:
            # item_class: u32
            item_class = await read_int(reader, 4)

            # item_sub_class: u32
            item_sub_class = await read_int(reader, 4)

        elif result == SpellCastResult.TOO_MANY_OF_ITEM:
            # item_limit_category: u32
            item_limit_category = await read_int(reader, 4)

        elif result == SpellCastResult.CUSTOM_ERROR:
            # custom_error: u32
            custom_error = await read_int(reader, 4)

        elif result == SpellCastResult.REAGENTS:
            # missing_item: u32
            missing_item = await read_int(reader, 4)

        elif result == SpellCastResult.PREVENTED_BY_MECHANIC:
            # mechanic: u32
            mechanic = await read_int(reader, 4)

        elif result == SpellCastResult.NEED_EXOTIC_AMMO:
            # equipped_item_sub_class: u32
            equipped_item_sub_class = await read_int(reader, 4)

        elif result == SpellCastResult.NEED_MORE_ITEMS:
            # item: Item
            item = await read_int(reader, 4)

            # count: u32
            count = await read_int(reader, 4)

        elif result == SpellCastResult.MIN_SKILL:
            # skill: Skill
            skill = Skill(await read_int(reader, 4))

            # skill_required: u32
            skill_required = await read_int(reader, 4)

        elif result == SpellCastResult.FISHING_TOO_LOW:
            # fishing_skill_required: u32
            fishing_skill_required = await read_int(reader, 4)

        return SMSG_PET_CAST_FAILED(
            cast_count=cast_count,
            id=id,
            result=result,
            multiple_casts=multiple_casts,
            spell_focus=spell_focus,
            area=area,
            totems=totems,
            totem_categories=totem_categories,
            item_class=item_class,
            item_sub_class=item_sub_class,
            item_limit_category=item_limit_category,
            custom_error=custom_error,
            missing_item=missing_item,
            mechanic=mechanic,
            equipped_item_sub_class=equipped_item_sub_class,
            item=item,
            count=count,
            skill=skill,
            skill_required=skill_required,
            fishing_skill_required=fishing_skill_required,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0138))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BIBB'
        _data.extend([self.cast_count, self.id, self.result.value, self.multiple_casts])
        if self.result == SpellCastResult.REQUIRES_SPELL_FOCUS:
            _fmt += 'I'
            _data.append(self.spell_focus)
        elif self.result == SpellCastResult.REQUIRES_AREA:
            _fmt += 'I'
            _data.append(self.area.value)
        elif self.result == SpellCastResult.TOTEMS:
            _fmt += f'{len(self.totems)}I'
            _data.extend([*self.totems])
        elif self.result == SpellCastResult.TOTEM_CATEGORY:
            _fmt += f'{len(self.totem_categories)}I'
            _data.extend([*self.totem_categories])
        elif self.result in {SpellCastResult.EQUIPPED_ITEM_CLASS, SpellCastResult.EQUIPPED_ITEM_CLASS_OFFHAND, SpellCastResult.EQUIPPED_ITEM_CLASS_MAINHAND}:
            _fmt += 'II'
            _data.extend([self.item_class, self.item_sub_class])
        elif self.result == SpellCastResult.TOO_MANY_OF_ITEM:
            _fmt += 'I'
            _data.append(self.item_limit_category)
        elif self.result == SpellCastResult.CUSTOM_ERROR:
            _fmt += 'I'
            _data.append(self.custom_error)
        elif self.result == SpellCastResult.REAGENTS:
            _fmt += 'I'
            _data.append(self.missing_item)
        elif self.result == SpellCastResult.PREVENTED_BY_MECHANIC:
            _fmt += 'I'
            _data.append(self.mechanic)
        elif self.result == SpellCastResult.NEED_EXOTIC_AMMO:
            _fmt += 'I'
            _data.append(self.equipped_item_sub_class)
        elif self.result == SpellCastResult.NEED_MORE_ITEMS:
            _fmt += 'II'
            _data.extend([self.item, self.count])
        elif self.result == SpellCastResult.MIN_SKILL:
            _fmt += 'II'
            _data.extend([self.skill.value, self.skill_required])
        elif self.result == SpellCastResult.FISHING_TOO_LOW:
            _fmt += 'I'
            _data.append(self.fishing_skill_required)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 7

        if self.result == SpellCastResult.REQUIRES_SPELL_FOCUS:
            _size += 4
        elif self.result == SpellCastResult.REQUIRES_AREA:
            _size += 4
        elif self.result == SpellCastResult.TOTEMS:
            _size += 8
        elif self.result == SpellCastResult.TOTEM_CATEGORY:
            _size += 8
        elif self.result in {SpellCastResult.EQUIPPED_ITEM_CLASS, SpellCastResult.EQUIPPED_ITEM_CLASS_OFFHAND, SpellCastResult.EQUIPPED_ITEM_CLASS_MAINHAND}:
            _size += 8
        elif self.result == SpellCastResult.TOO_MANY_OF_ITEM:
            _size += 4
        elif self.result == SpellCastResult.CUSTOM_ERROR:
            _size += 4
        elif self.result == SpellCastResult.REAGENTS:
            _size += 4
        elif self.result == SpellCastResult.PREVENTED_BY_MECHANIC:
            _size += 4
        elif self.result == SpellCastResult.NEED_EXOTIC_AMMO:
            _size += 4
        elif self.result == SpellCastResult.NEED_MORE_ITEMS:
            _size += 8
        elif self.result == SpellCastResult.MIN_SKILL:
            _size += 8
        elif self.result == SpellCastResult.FISHING_TOO_LOW:
            _size += 4

        return _size


@dataclasses.dataclass
class MSG_CHANNEL_START_Server:
    caster: int
    spell: int
    duration: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_CHANNEL_START_Server:
        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # spell: Spell
        spell = await read_int(reader, 4)

        # duration: u32
        duration = await read_int(reader, 4)

        return MSG_CHANNEL_START_Server(
            caster=caster,
            spell=spell,
            duration=duration,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0139))
        _fmt = "<4s"
        _data = [_data]

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # duration: u32
        _fmt += 'I'
        _data.append(self.duration)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.caster)


@dataclasses.dataclass
class MSG_CHANNEL_UPDATE_Server:
    caster: int
    time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_CHANNEL_UPDATE_Server:
        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # time: u32
        time = await read_int(reader, 4)

        return MSG_CHANNEL_UPDATE_Server(
            caster=caster,
            time=time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x013A))
        _fmt = "<4s"
        _data = [_data]

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # time: u32
        _fmt += 'I'
        _data.append(self.time)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.caster)


@dataclasses.dataclass
class CMSG_CANCEL_CHANNELLING:
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_CHANNELLING:
        # id: Spell
        id = await read_int(reader, 4)

        return CMSG_CANCEL_CHANNELLING(
            id=id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x013B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AI_REACTION:
    guid: int
    reaction: AiReaction

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AI_REACTION:
        # guid: Guid
        guid = await read_int(reader, 8)

        # reaction: AiReaction
        reaction = AiReaction(await read_int(reader, 4))

        return SMSG_AI_REACTION(
            guid=guid,
            reaction=reaction,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x013C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.reaction.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_SELECTION:
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_SELECTION:
        # target: Guid
        target = await read_int(reader, 8)

        return CMSG_SET_SELECTION(
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x013D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.target)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_DELETEEQUIPMENT_SET:
    set: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_DELETEEQUIPMENT_SET:
        # set: PackedGuid
        set = await read_packed_guid(reader)

        return CMSG_DELETEEQUIPMENT_SET(
            set=set,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x013E))
        _fmt = "<6s"
        _data = [_data]

        # set: PackedGuid
        _fmt, _data = packed_guid_write(self.set, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.set)


@dataclasses.dataclass
class CMSG_INSTANCE_LOCK_RESPONSE:
    accept: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_INSTANCE_LOCK_RESPONSE:
        # accept: Bool8
        accept = await read_bool(reader, 1)

        return CMSG_INSTANCE_LOCK_RESPONSE(
            accept=accept,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x013F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.accept)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ATTACKSWING:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ATTACKSWING:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_ATTACKSWING(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0141))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ATTACKSTOP:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ATTACKSTOP:
        return CMSG_ATTACKSTOP()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0142))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ATTACKSTART:
    attacker: int
    victim: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKSTART:
        # attacker: Guid
        attacker = await read_int(reader, 8)

        # victim: Guid
        victim = await read_int(reader, 8)

        return SMSG_ATTACKSTART(
            attacker=attacker,
            victim=victim,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x0143))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQ'
        _data.extend([self.attacker, self.victim])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ATTACKSTOP:
    player: int
    enemy: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKSTOP:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # enemy: PackedGuid
        enemy = await read_packed_guid(reader)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return SMSG_ATTACKSTOP(
            player=player,
            enemy=enemy,
            unknown1=unknown1,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0144))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # enemy: PackedGuid
        _fmt, _data = packed_guid_write(self.enemy, _fmt, _data)

        # unknown1: u32
        _fmt += 'I'
        _data.append(self.unknown1)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.player) + packed_guid_size(self.enemy)


@dataclasses.dataclass
class SMSG_ATTACKSWING_NOTINRANGE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKSWING_NOTINRANGE:
        return SMSG_ATTACKSWING_NOTINRANGE()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0145))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ATTACKSWING_BADFACING:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKSWING_BADFACING:
        return SMSG_ATTACKSWING_BADFACING()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0146))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_INSTANCE_LOCK_WARNING_QUERY:
    time: int
    encounter_mask: int
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INSTANCE_LOCK_WARNING_QUERY:
        # time: Milliseconds
        time = await read_int(reader, 4)

        # encounter_mask: u32
        encounter_mask = await read_int(reader, 4)

        # unknown: u8
        unknown = await read_int(reader, 1)

        return SMSG_INSTANCE_LOCK_WARNING_QUERY(
            time=time,
            encounter_mask=encounter_mask,
            unknown=unknown,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x0147))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIB'
        _data.extend([self.time, self.encounter_mask, self.unknown])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ATTACKSWING_DEADTARGET:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKSWING_DEADTARGET:
        return SMSG_ATTACKSWING_DEADTARGET()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0148))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ATTACKSWING_CANT_ATTACK:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKSWING_CANT_ATTACK:
        return SMSG_ATTACKSWING_CANT_ATTACK()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0149))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ATTACKERSTATEUPDATE:
    hit_info: HitInfo
    attacker: int
    target: int
    total_damage: int
    overkill: int
    damage_infos: typing.List[DamageInfo]
    victim_state: VictimState
    unknown1: int
    unknown2: int
    absorb: typing.Optional[int] = None
    resist: typing.Optional[int] = None
    blocked_amount: typing.Optional[int] = None
    unknown3: typing.Optional[int] = None
    unknown4: typing.Optional[int] = None
    unknown5: typing.Optional[float] = None
    unknown6: typing.Optional[float] = None
    unknown7: typing.Optional[float] = None
    unknown8: typing.Optional[float] = None
    unknown9: typing.Optional[float] = None
    unknown10: typing.Optional[float] = None
    unknown11: typing.Optional[float] = None
    unknown12: typing.Optional[float] = None
    unknown13: typing.Optional[float] = None
    unknown14: typing.Optional[float] = None
    unknown15: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKERSTATEUPDATE:
        absorb = None
        resist = None
        blocked_amount = None
        unknown3 = None
        unknown4 = None
        unknown5 = None
        unknown6 = None
        unknown7 = None
        unknown8 = None
        unknown9 = None
        unknown10 = None
        unknown11 = None
        unknown12 = None
        unknown13 = None
        unknown14 = None
        unknown15 = None
        # hit_info: HitInfo
        hit_info = HitInfo(await read_int(reader, 4))

        # attacker: PackedGuid
        attacker = await read_packed_guid(reader)

        # target: PackedGuid
        target = await read_packed_guid(reader)

        # total_damage: u32
        total_damage = await read_int(reader, 4)

        # overkill: u32
        overkill = await read_int(reader, 4)

        # amount_of_damages: u8
        amount_of_damages = await read_int(reader, 1)

        # damage_infos: DamageInfo[amount_of_damages]
        damage_infos = []
        for _ in range(0, amount_of_damages):
            damage_infos.append(await DamageInfo.read(reader))

        if HitInfo.ALL_ABSORB in hit_info:
            # absorb: u32
            absorb = await read_int(reader, 4)

        if HitInfo.ALL_RESIST in hit_info:
            # resist: u32
            resist = await read_int(reader, 4)

        # victim_state: VictimState
        victim_state = VictimState(await read_int(reader, 1))

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # unknown2: u32
        unknown2 = await read_int(reader, 4)

        if HitInfo.BLOCK in hit_info:
            # blocked_amount: u32
            blocked_amount = await read_int(reader, 4)

        if HitInfo.UNK19 in hit_info:
            # unknown3: u32
            unknown3 = await read_int(reader, 4)

        if HitInfo.UNK1 in hit_info:
            # unknown4: u32
            unknown4 = await read_int(reader, 4)

            # unknown5: f32
            unknown5 = await read_float(reader)

            # unknown6: f32
            unknown6 = await read_float(reader)

            # unknown7: f32
            unknown7 = await read_float(reader)

            # unknown8: f32
            unknown8 = await read_float(reader)

            # unknown9: f32
            unknown9 = await read_float(reader)

            # unknown10: f32
            unknown10 = await read_float(reader)

            # unknown11: f32
            unknown11 = await read_float(reader)

            # unknown12: f32
            unknown12 = await read_float(reader)

            # unknown13: f32
            unknown13 = await read_float(reader)

            # unknown14: f32
            unknown14 = await read_float(reader)

            # unknown15: u32
            unknown15 = await read_int(reader, 4)

        return SMSG_ATTACKERSTATEUPDATE(
            hit_info=hit_info,
            attacker=attacker,
            target=target,
            total_damage=total_damage,
            overkill=overkill,
            damage_infos=damage_infos,
            absorb=absorb,
            resist=resist,
            victim_state=victim_state,
            unknown1=unknown1,
            unknown2=unknown2,
            blocked_amount=blocked_amount,
            unknown3=unknown3,
            unknown4=unknown4,
            unknown5=unknown5,
            unknown6=unknown6,
            unknown7=unknown7,
            unknown8=unknown8,
            unknown9=unknown9,
            unknown10=unknown10,
            unknown11=unknown11,
            unknown12=unknown12,
            unknown13=unknown13,
            unknown14=unknown14,
            unknown15=unknown15,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x014A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.hit_info.value)
        # attacker: PackedGuid
        _fmt, _data = packed_guid_write(self.attacker, _fmt, _data)

        # target: PackedGuid
        _fmt, _data = packed_guid_write(self.target, _fmt, _data)

        # total_damage: u32
        _fmt += 'I'
        _data.append(self.total_damage)

        # overkill: u32
        _fmt += 'I'
        _data.append(self.overkill)

        # amount_of_damages: u8
        _fmt += 'B'
        _data.append(len(self.damage_infos))

        # damage_infos: DamageInfo[amount_of_damages]
        for i in self.damage_infos:
            _fmt, _data = i.write(_fmt, _data)

        if HitInfo.ALL_ABSORB in self.hit_info:
            _fmt += 'I'
            _data.append(self.absorb)
        if HitInfo.ALL_RESIST in self.hit_info:
            _fmt += 'I'
            _data.append(self.resist)
        # victim_state: VictimState
        _fmt += 'B'
        _data.append(self.victim_state.value)

        # unknown1: u32
        _fmt += 'I'
        _data.append(self.unknown1)

        # unknown2: u32
        _fmt += 'I'
        _data.append(self.unknown2)

        if HitInfo.BLOCK in self.hit_info:
            _fmt += 'I'
            _data.append(self.blocked_amount)
        if HitInfo.UNK19 in self.hit_info:
            _fmt += 'I'
            _data.append(self.unknown3)
        if HitInfo.UNK1 in self.hit_info:
            _fmt += 'IffffffffffI'
            _data.extend([self.unknown4, self.unknown5, self.unknown6, self.unknown7, self.unknown8, self.unknown9, self.unknown10, self.unknown11, self.unknown12, self.unknown13, self.unknown14, self.unknown15])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 22 + packed_guid_size(self.attacker) + packed_guid_size(self.target) + 12 * len(self.damage_infos)

        if HitInfo.ALL_ABSORB in self.hit_info:
            _size += 4

        if HitInfo.ALL_RESIST in self.hit_info:
            _size += 4

        if HitInfo.BLOCK in self.hit_info:
            _size += 4

        if HitInfo.UNK19 in self.hit_info:
            _size += 4

        if HitInfo.UNK1 in self.hit_info:
            _size += 48

        return _size


@dataclasses.dataclass
class SMSG_CANCEL_COMBAT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CANCEL_COMBAT:
        return SMSG_CANCEL_COMBAT()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x014E))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELLHEALLOG:
    victim: int
    caster: int
    id: int
    damage: int
    overheal: int
    absorb: int
    critical: bool
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLHEALLOG:
        # victim: PackedGuid
        victim = await read_packed_guid(reader)

        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # id: Spell
        id = await read_int(reader, 4)

        # damage: u32
        damage = await read_int(reader, 4)

        # overheal: u32
        overheal = await read_int(reader, 4)

        # absorb: u32
        absorb = await read_int(reader, 4)

        # critical: Bool8
        critical = await read_bool(reader, 1)

        # unknown: u8
        unknown = await read_int(reader, 1)

        return SMSG_SPELLHEALLOG(
            victim=victim,
            caster=caster,
            id=id,
            damage=damage,
            overheal=overheal,
            absorb=absorb,
            critical=critical,
            unknown=unknown,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0150))
        _fmt = "<4s"
        _data = [_data]

        # victim: PackedGuid
        _fmt, _data = packed_guid_write(self.victim, _fmt, _data)

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # id: Spell
        _fmt += 'I'
        _data.append(self.id)

        # damage: u32
        _fmt += 'I'
        _data.append(self.damage)

        # overheal: u32
        _fmt += 'I'
        _data.append(self.overheal)

        # absorb: u32
        _fmt += 'I'
        _data.append(self.absorb)

        # critical: Bool8
        _fmt += 'B'
        _data.append(self.critical)

        # unknown: u8
        _fmt += 'B'
        _data.append(self.unknown)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 18 + packed_guid_size(self.victim) + packed_guid_size(self.caster)


@dataclasses.dataclass
class SMSG_SPELLENERGIZELOG:
    victim: int
    caster: int
    spell: int
    power: Power
    damage: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLENERGIZELOG:
        # victim: PackedGuid
        victim = await read_packed_guid(reader)

        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # spell: Spell
        spell = await read_int(reader, 4)

        # power: Power
        power = Power(await read_int(reader, 4))

        # damage: u32
        damage = await read_int(reader, 4)

        return SMSG_SPELLENERGIZELOG(
            victim=victim,
            caster=caster,
            spell=spell,
            power=power,
            damage=damage,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0151))
        _fmt = "<4s"
        _data = [_data]

        # victim: PackedGuid
        _fmt, _data = packed_guid_write(self.victim, _fmt, _data)

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # power: Power
        _fmt += 'I'
        _data.append(self.power.value)

        # damage: u32
        _fmt += 'I'
        _data.append(self.damage)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + packed_guid_size(self.victim) + packed_guid_size(self.caster)


@dataclasses.dataclass
class SMSG_BREAK_TARGET:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BREAK_TARGET:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_BREAK_TARGET(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0152))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_BINDPOINTUPDATE:
    position: Vector3d
    map: Map
    area: Area

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BINDPOINTUPDATE:
        # position: Vector3d
        position = await Vector3d.read(reader)

        # map: Map
        map = Map(await read_int(reader, 4))

        # area: Area
        area = Area(await read_int(reader, 4))

        return SMSG_BINDPOINTUPDATE(
            position=position,
            map=map,
            area=area,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x0155))
        _fmt = "<4s"
        _data = [_data]

        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # map: Map
        _fmt += 'I'
        _data.append(self.map.value)

        # area: Area
        _fmt += 'I'
        _data.append(self.area.value)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PLAYERBOUND:
    guid: int
    area: Area

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAYERBOUND:
        # guid: Guid
        guid = await read_int(reader, 8)

        # area: Area
        area = Area(await read_int(reader, 4))

        return SMSG_PLAYERBOUND(
            guid=guid,
            area=area,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0158))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.area.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CLIENT_CONTROL_UPDATE:
    guid: int
    allow_movement: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CLIENT_CONTROL_UPDATE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # allow_movement: Bool8
        allow_movement = await read_bool(reader, 1)

        return SMSG_CLIENT_CONTROL_UPDATE(
            guid=guid,
            allow_movement=allow_movement,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0159))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # allow_movement: Bool8
        _fmt += 'B'
        _data.append(self.allow_movement)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_REPOP_REQUEST:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REPOP_REQUEST:
        return CMSG_REPOP_REQUEST()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x015A))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_RESURRECT_REQUEST:
    guid: int
    name: str
    player: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RESURRECT_REQUEST:
        # guid: Guid
        guid = await read_int(reader, 8)

        # name: SizedCString
        name = await read_sized_cstring(reader)

        # player: Bool8
        player = await read_bool(reader, 1)

        return SMSG_RESURRECT_REQUEST(
            guid=guid,
            name=name,
            player=player,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x015B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QI{len(self.name)}sBB'
        _data.extend([self.guid, len(self.name) + 1, self.name.encode('utf-8'), 0, self.player])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 14 + len(self.name)


@dataclasses.dataclass
class CMSG_RESURRECT_RESPONSE:
    guid: int
    status: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_RESURRECT_RESPONSE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # status: u8
        status = await read_int(reader, 1)

        return CMSG_RESURRECT_RESPONSE(
            guid=guid,
            status=status,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x015C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.status])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LOOT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOOT:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_LOOT(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x015D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LOOT_MONEY:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOOT_MONEY:
        return CMSG_LOOT_MONEY()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x015E))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LOOT_RELEASE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOOT_RELEASE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_LOOT_RELEASE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x015F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_RESPONSE:
    guid: int
    loot_method: LootMethod
    gold: int
    items: typing.List[LootItem]
    loot_error: typing.Optional[LootMethodError] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_RESPONSE:
        loot_error = None
        # guid: Guid
        guid = await read_int(reader, 8)

        # loot_method: LootMethod
        loot_method = LootMethod(await read_int(reader, 1))

        if loot_method == LootMethod.ERROR:
            # loot_error: LootMethodError
            loot_error = LootMethodError(await read_int(reader, 1))

        # gold: Gold
        gold = await read_int(reader, 4)

        # amount_of_items: u8
        amount_of_items = await read_int(reader, 1)

        # items: LootItem[amount_of_items]
        items = []
        for _ in range(0, amount_of_items):
            items.append(await LootItem.read(reader))

        return SMSG_LOOT_RESPONSE(
            guid=guid,
            loot_method=loot_method,
            loot_error=loot_error,
            gold=gold,
            items=items,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0160))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.loot_method.value])
        if self.loot_method == LootMethod.ERROR:
            _fmt += 'B'
            _data.append(self.loot_error.value)
        # gold: Gold
        _fmt += 'I'
        _data.append(self.gold)

        # amount_of_items: u8
        _fmt += 'B'
        _data.append(len(self.items))

        # items: LootItem[amount_of_items]
        for i in self.items:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 14 + 6 * len(self.items)

        if self.loot_method == LootMethod.ERROR:
            _size += 1

        return _size


@dataclasses.dataclass
class SMSG_LOOT_RELEASE_RESPONSE:
    guid: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_RELEASE_RESPONSE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        return SMSG_LOOT_RELEASE_RESPONSE(
            guid=guid,
            unknown1=unknown1,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x0161))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.unknown1])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_REMOVED:
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_REMOVED:
        # slot: u8
        slot = await read_int(reader, 1)

        return SMSG_LOOT_REMOVED(
            slot=slot,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x0162))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.slot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_MONEY_NOTIFY:
    amount: int
    alone: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_MONEY_NOTIFY:
        # amount: u32
        amount = await read_int(reader, 4)

        # alone: Bool8
        alone = await read_bool(reader, 1)

        return SMSG_LOOT_MONEY_NOTIFY(
            amount=amount,
            alone=alone,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x0163))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([self.amount, self.alone])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_CLEAR_MONEY:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_CLEAR_MONEY:
        return SMSG_LOOT_CLEAR_MONEY()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0165))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_PUSH_RESULT:
    guid: int
    source: NewItemSource
    creation_type: NewItemCreationType
    alert_chat: NewItemChatAlert
    bag_slot: int
    item_slot: int
    item: int
    item_suffix_factor: int
    item_random_property_id: int
    item_count: int
    item_count_in_inventory: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_PUSH_RESULT:
        # guid: Guid
        guid = await read_int(reader, 8)

        # source: NewItemSource
        source = NewItemSource(await read_int(reader, 4))

        # creation_type: NewItemCreationType
        creation_type = NewItemCreationType(await read_int(reader, 4))

        # alert_chat: NewItemChatAlert
        alert_chat = NewItemChatAlert(await read_int(reader, 4))

        # bag_slot: u8
        bag_slot = await read_int(reader, 1)

        # item_slot: u32
        item_slot = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        # item_suffix_factor: u32
        item_suffix_factor = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # item_count: u32
        item_count = await read_int(reader, 4)

        # item_count_in_inventory: u32
        item_count_in_inventory = await read_int(reader, 4)

        return SMSG_ITEM_PUSH_RESULT(
            guid=guid,
            source=source,
            creation_type=creation_type,
            alert_chat=alert_chat,
            bag_slot=bag_slot,
            item_slot=item_slot,
            item=item,
            item_suffix_factor=item_suffix_factor,
            item_random_property_id=item_random_property_id,
            item_count=item_count,
            item_count_in_inventory=item_count_in_inventory,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(45 + 2, 0x0166))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIIIBIIIIII'
        _data.extend([self.guid, self.source.value, self.creation_type.value, self.alert_chat.value, self.bag_slot, self.item_slot, self.item, self.item_suffix_factor, self.item_random_property_id, self.item_count, self.item_count_in_inventory])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DUEL_REQUESTED:
    initiator: int
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DUEL_REQUESTED:
        # initiator: Guid
        initiator = await read_int(reader, 8)

        # target: Guid
        target = await read_int(reader, 8)

        return SMSG_DUEL_REQUESTED(
            initiator=initiator,
            target=target,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x0167))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQ'
        _data.extend([self.initiator, self.target])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DUEL_OUTOFBOUNDS:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DUEL_OUTOFBOUNDS:
        return SMSG_DUEL_OUTOFBOUNDS()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0168))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DUEL_INBOUNDS:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DUEL_INBOUNDS:
        return SMSG_DUEL_INBOUNDS()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0169))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DUEL_COMPLETE:
    ended_without_interruption: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DUEL_COMPLETE:
        # ended_without_interruption: Bool8
        ended_without_interruption = await read_bool(reader, 1)

        return SMSG_DUEL_COMPLETE(
            ended_without_interruption=ended_without_interruption,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x016A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.ended_without_interruption)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DUEL_WINNER:
    reason: DuelWinnerReason
    opponent_name: str
    initiator_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DUEL_WINNER:
        # reason: DuelWinnerReason
        reason = DuelWinnerReason(await read_int(reader, 1))

        # opponent_name: CString
        opponent_name = await read_cstring(reader)

        # initiator_name: CString
        initiator_name = await read_cstring(reader)

        return SMSG_DUEL_WINNER(
            reason=reason,
            opponent_name=opponent_name,
            initiator_name=initiator_name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x016B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'B{len(self.opponent_name)}sB{len(self.initiator_name)}sB'
        _data.extend([self.reason.value, self.opponent_name.encode('utf-8'), 0, self.initiator_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 3 + len(self.opponent_name) + len(self.initiator_name)


@dataclasses.dataclass
class CMSG_DUEL_ACCEPTED:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_DUEL_ACCEPTED:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_DUEL_ACCEPTED(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x016C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_DUEL_CANCELLED:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_DUEL_CANCELLED:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_DUEL_CANCELLED(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x016D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MOUNTRESULT:
    result: MountResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOUNTRESULT:
        # result: MountResult
        result = MountResult(await read_int(reader, 4))

        return SMSG_MOUNTRESULT(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x016E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MOUNTSPECIAL_ANIM:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOUNTSPECIAL_ANIM:
        return CMSG_MOUNTSPECIAL_ANIM()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0171))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MOUNTSPECIAL_ANIM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOUNTSPECIAL_ANIM:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_MOUNTSPECIAL_ANIM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0172))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PET_TAME_FAILURE:
    reason: PetTameFailureReason

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_TAME_FAILURE:
        # reason: PetTameFailureReason
        reason = PetTameFailureReason(await read_int(reader, 1))

        return SMSG_PET_TAME_FAILURE(
            reason=reason,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x0173))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.reason.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PET_SET_ACTION:
    guid: int
    position1: int
    data1: int
    position2: typing.Optional[int] = None
    data2: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_SET_ACTION:
        position2 = None
        data2 = None
        _size = 0

        # guid: Guid
        guid = await read_int(reader, 8)
        _size += 8

        # position1: u32
        position1 = await read_int(reader, 4)
        _size += 4

        # data1: u32
        data1 = await read_int(reader, 4)
        _size += 4

        # extra: optional
        if _size < body_size:
            # position2: u32
            position2 = await read_int(reader, 4)
            _size += 4

            # data2: u32
            data2 = await read_int(reader, 4)
            _size += 4

        return CMSG_PET_SET_ACTION(
            guid=guid,
            position1=position1,
            data1=data1,
            position2=position2,
            data2=data2,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0174))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.guid, self.position1, self.data1])
        # extra: optional
        if self.position2 is not None and self.data2 is not None:
            _fmt += 'II'
            _data.extend([self.position2, self.data2])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 16

        # extra: optional
        if self.position2 is not None and self.data2 is not None:
            _size += 8

        return _size


@dataclasses.dataclass
class CMSG_PET_ACTION:
    pet: int
    data: int
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_ACTION:
        # pet: Guid
        pet = await read_int(reader, 8)

        # data: u32
        data = await read_int(reader, 4)

        # target: Guid
        target = await read_int(reader, 8)

        return CMSG_PET_ACTION(
            pet=pet,
            data=data,
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 4, 0x0175))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIQ'
        _data.extend([self.pet, self.data, self.target])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PET_ABANDON:
    pet: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_ABANDON:
        # pet: Guid
        pet = await read_int(reader, 8)

        return CMSG_PET_ABANDON(
            pet=pet,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0176))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.pet)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PET_RENAME:
    pet: int
    name: str
    declined: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_RENAME:
        # pet: Guid
        pet = await read_int(reader, 8)

        # name: CString
        name = await read_cstring(reader)

        # declined: Bool8
        declined = await read_bool(reader, 1)

        return CMSG_PET_RENAME(
            pet=pet,
            name=name,
            declined=declined,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0177))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.name)}sBB'
        _data.extend([self.pet, self.name.encode('utf-8'), 0, self.declined])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 10 + len(self.name)


@dataclasses.dataclass
class SMSG_PET_NAME_INVALID:
    reason: PetNameInvalidReason
    name: str
    included: DeclinedPetNameIncluded
    declined_names: typing.Optional[typing.List[str]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_NAME_INVALID:
        declined_names = None
        # reason: PetNameInvalidReason
        reason = PetNameInvalidReason(await read_int(reader, 4))

        # name: CString
        name = await read_cstring(reader)

        # included: DeclinedPetNameIncluded
        included = DeclinedPetNameIncluded(await read_int(reader, 1))

        if included == DeclinedPetNameIncluded.INCLUDED:
            # declined_names: CString[5]
            declined_names = []
            for _ in range(0, 5):
                declined_names.append(await read_cstring(reader))

        return SMSG_PET_NAME_INVALID(
            reason=reason,
            name=name,
            included=included,
            declined_names=declined_names,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0178))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.name)}sBB'
        _data.extend([self.reason.value, self.name.encode('utf-8'), 0, self.included.value])
        if self.included == DeclinedPetNameIncluded.INCLUDED:
            # declined_names: CString[5]
            for i in self.declined_names:
                _fmt += f'{len(i)}sB'
                _data.append(i.encode('utf-8'))
                _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 6 + len(self.name)

        if self.included == DeclinedPetNameIncluded.INCLUDED:
            _size += 0 + sum([len(i) + 1 for i in self.declined_names])

        return _size


@dataclasses.dataclass
class SMSG_PET_SPELLS:
    pet: int
    family: typing.Optional[CreatureFamily] = None
    duration: typing.Optional[int] = None
    react: typing.Optional[PetReactState] = None
    command: typing.Optional[PetCommandState] = None
    unknown: typing.Optional[int] = None
    pet_enabled: typing.Optional[PetEnabled] = None
    action_bars: typing.Optional[typing.List[int]] = None
    spells: typing.Optional[typing.List[int]] = None
    cooldowns: typing.Optional[typing.List[PetSpellCooldown]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_SPELLS:
        family = None
        duration = None
        react = None
        command = None
        unknown = None
        pet_enabled = None
        action_bars = None
        amount_of_spells = None
        spells = None
        amount_of_cooldowns = None
        cooldowns = None
        _size = 0

        # pet: Guid
        pet = await read_int(reader, 8)
        _size += 8

        # action_bars: optional
        if _size < body_size:
            # family: CreatureFamily
            family = CreatureFamily(await read_int(reader, 2))
            _size += 2

            # duration: u32
            duration = await read_int(reader, 4)
            _size += 4

            # react: PetReactState
            react = PetReactState(await read_int(reader, 1))
            _size += 1

            # command: PetCommandState
            command = PetCommandState(await read_int(reader, 1))
            _size += 1

            # unknown: u8
            unknown = await read_int(reader, 1)
            _size += 1

            # pet_enabled: PetEnabled
            pet_enabled = PetEnabled(await read_int(reader, 1))
            _size += 1

            # action_bars: u32[10]
            action_bars = []
            for _ in range(0, 10):
                action_bars.append(await read_int(reader, 4))
                _size += 4

            # amount_of_spells: u8
            amount_of_spells = await read_int(reader, 1)
            _size += 1

            # spells: u32[amount_of_spells]
            spells = []
            for _ in range(0, amount_of_spells):
                spells.append(await read_int(reader, 4))
                _size += 4

            # amount_of_cooldowns: u8
            amount_of_cooldowns = await read_int(reader, 1)
            _size += 1

            # cooldowns: PetSpellCooldown[amount_of_cooldowns]
            cooldowns = []
            for _ in range(0, amount_of_cooldowns):
                cooldowns.append(await PetSpellCooldown.read(reader))
                _size += 14

        return SMSG_PET_SPELLS(
            pet=pet,
            family=family,
            duration=duration,
            react=react,
            command=command,
            unknown=unknown,
            pet_enabled=pet_enabled,
            action_bars=action_bars,
            spells=spells,
            cooldowns=cooldowns,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0179))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.pet)
        # action_bars: optional
        if self.family is not None and self.duration is not None and self.react is not None and self.command is not None and self.unknown is not None and self.pet_enabled is not None and self.action_bars is not None and self.spells is not None and self.cooldowns is not None:
            _fmt += f'HIBBBB{len(self.action_bars)}IB{len(self.spells)}IB'
            _data.extend([self.family.value, self.duration, self.react.value, self.command.value, self.unknown, self.pet_enabled.value, *self.action_bars, len(self.spells), *self.spells, len(self.cooldowns)])
            # cooldowns: PetSpellCooldown[amount_of_cooldowns]
            for i in self.cooldowns:
                _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 8

        # action_bars: optional
        if self.family is not None and self.duration is not None and self.react is not None and self.command is not None and self.unknown is not None and self.pet_enabled is not None and self.action_bars is not None and self.spells is not None and self.cooldowns is not None:
            _size += 52 + 4 * len(self.spells) + 14 * len(self.cooldowns)

        return _size


@dataclasses.dataclass
class SMSG_PET_MODE:
    guid: int
    react_state: PetReactState
    command_state: PetCommandState
    unknown1: int
    pet_enabled: PetEnabled

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_MODE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # react_state: PetReactState
        react_state = PetReactState(await read_int(reader, 1))

        # command_state: PetCommandState
        command_state = PetCommandState(await read_int(reader, 1))

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # pet_enabled: PetEnabled
        pet_enabled = PetEnabled(await read_int(reader, 1))

        return SMSG_PET_MODE(
            guid=guid,
            react_state=react_state,
            command_state=command_state,
            unknown1=unknown1,
            pet_enabled=pet_enabled,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x017A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QBBBB'
        _data.extend([self.guid, self.react_state.value, self.command_state.value, self.unknown1, self.pet_enabled.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GOSSIP_HELLO:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GOSSIP_HELLO:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_GOSSIP_HELLO(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x017B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GOSSIP_SELECT_OPTION:
    guid: int
    menu_id: int
    gossip_list_id: int
    code: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GOSSIP_SELECT_OPTION:
        code = None
        _size = 0

        # guid: Guid
        guid = await read_int(reader, 8)
        _size += 8

        # menu_id: u32
        menu_id = await read_int(reader, 4)
        _size += 4

        # gossip_list_id: u32
        gossip_list_id = await read_int(reader, 4)
        _size += 4

        # unknown: optional
        if _size < body_size:
            # code: CString
            code = await read_cstring(reader)
            _size += len(code) + 1

        return CMSG_GOSSIP_SELECT_OPTION(
            guid=guid,
            menu_id=menu_id,
            gossip_list_id=gossip_list_id,
            code=code,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x017C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.guid, self.menu_id, self.gossip_list_id])
        # unknown: optional
        if self.code is not None:
            _fmt += f'{len(self.code)}sB'
            _data.extend([self.code.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 16

        # unknown: optional
        if self.code is not None:
            _size += 1 + len(self.code)

        return _size


@dataclasses.dataclass
class SMSG_GOSSIP_MESSAGE:
    guid: int
    menu_id: int
    title_text_id: int
    gossips: typing.List[GossipItem]
    quests: typing.List[QuestItem]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GOSSIP_MESSAGE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # menu_id: u32
        menu_id = await read_int(reader, 4)

        # title_text_id: u32
        title_text_id = await read_int(reader, 4)

        # amount_of_gossip_items: u32
        amount_of_gossip_items = await read_int(reader, 4)

        # gossips: GossipItem[amount_of_gossip_items]
        gossips = []
        for _ in range(0, amount_of_gossip_items):
            gossips.append(await GossipItem.read(reader))

        # amount_of_quests: u32
        amount_of_quests = await read_int(reader, 4)

        # quests: QuestItem[amount_of_quests]
        quests = []
        for _ in range(0, amount_of_quests):
            quests.append(await QuestItem.read(reader))

        return SMSG_GOSSIP_MESSAGE(
            guid=guid,
            menu_id=menu_id,
            title_text_id=title_text_id,
            gossips=gossips,
            quests=quests,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x017D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIII'
        _data.extend([self.guid, self.menu_id, self.title_text_id, len(self.gossips)])
        # gossips: GossipItem[amount_of_gossip_items]
        for i in self.gossips:
            _fmt, _data = i.write(_fmt, _data)

        # amount_of_quests: u32
        _fmt += 'I'
        _data.append(len(self.quests))

        # quests: QuestItem[amount_of_quests]
        for i in self.quests:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 24 + sum([i.size() for i in self.gossips]) + sum([i.size() for i in self.quests])


@dataclasses.dataclass
class SMSG_GOSSIP_COMPLETE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GOSSIP_COMPLETE:
        return SMSG_GOSSIP_COMPLETE()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x017E))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_NPC_TEXT_QUERY:
    text_id: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_NPC_TEXT_QUERY:
        # text_id: u32
        text_id = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_NPC_TEXT_QUERY(
            text_id=text_id,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x017F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.text_id, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_NPC_TEXT_UPDATE:
    text_id: int
    texts: typing.List[NpcTextUpdate]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_NPC_TEXT_UPDATE:
        # text_id: u32
        text_id = await read_int(reader, 4)

        # texts: NpcTextUpdate[8]
        texts = []
        for _ in range(0, 8):
            texts.append(await NpcTextUpdate.read(reader))

        return SMSG_NPC_TEXT_UPDATE(
            text_id=text_id,
            texts=texts,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0180))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.text_id)
        # texts: NpcTextUpdate[8]
        for i in self.texts:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + sum([i.size() for i in self.texts])


@dataclasses.dataclass
class CMSG_QUESTGIVER_STATUS_QUERY:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_STATUS_QUERY:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_QUESTGIVER_STATUS_QUERY(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0182))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_STATUS:
    guid: int
    status: QuestGiverStatus

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_STATUS:
        # guid: Guid
        guid = await read_int(reader, 8)

        # status: QuestGiverStatus
        status = QuestGiverStatus(await read_int(reader, 4))

        return SMSG_QUESTGIVER_STATUS(
            guid=guid,
            status=status,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0183))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.status.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUESTGIVER_HELLO:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_HELLO:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_QUESTGIVER_HELLO(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0184))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_QUEST_LIST:
    npc: int
    title: str
    emote_delay: int
    emote: int
    quest_items: typing.List[QuestItem]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_QUEST_LIST:
        # npc: Guid
        npc = await read_int(reader, 8)

        # title: CString
        title = await read_cstring(reader)

        # emote_delay: u32
        emote_delay = await read_int(reader, 4)

        # emote: u32
        emote = await read_int(reader, 4)

        # amount_of_entries: u8
        amount_of_entries = await read_int(reader, 1)

        # quest_items: QuestItem[amount_of_entries]
        quest_items = []
        for _ in range(0, amount_of_entries):
            quest_items.append(await QuestItem.read(reader))

        return SMSG_QUESTGIVER_QUEST_LIST(
            npc=npc,
            title=title,
            emote_delay=emote_delay,
            emote=emote,
            quest_items=quest_items,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0185))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'Q{len(self.title)}sBIIB'
        _data.extend([self.npc, self.title.encode('utf-8'), 0, self.emote_delay, self.emote, len(self.quest_items)])
        # quest_items: QuestItem[amount_of_entries]
        for i in self.quest_items:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 18 + len(self.title) + sum([i.size() for i in self.quest_items])


@dataclasses.dataclass
class CMSG_QUESTGIVER_QUERY_QUEST:
    guid: int
    quest_id: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_QUERY_QUEST:
        # guid: Guid
        guid = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        return CMSG_QUESTGIVER_QUERY_QUEST(
            guid=guid,
            quest_id=quest_id,
            unknown1=unknown1,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(13 + 4, 0x0186))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIB'
        _data.extend([self.guid, self.quest_id, self.unknown1])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUESTGIVER_QUEST_AUTOLAUNCH:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_QUEST_AUTOLAUNCH:
        return CMSG_QUESTGIVER_QUEST_AUTOLAUNCH()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0187))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_QUEST_DETAILS:
    guid: int
    guid2: int
    quest_id: int
    title: str
    details: str
    objectives: str
    auto_finish: bool
    quest_flags: int
    suggested_players: int
    is_finished: int
    choice_item_rewards: typing.List[QuestGiverReward]
    item_rewards: typing.List[QuestGiverReward]
    money_reward: int
    experience_reward: int
    honor_reward: int
    honor_reward_multiplier: float
    reward_spell: int
    casted_spell: int
    title_reward: int
    talent_reward: int
    arena_point_reward: int
    unknown2: int
    reward_factions: typing.List[int]
    reward_reputations: typing.List[int]
    reward_reputations_override: typing.List[int]
    emotes: typing.List[QuestDetailsEmote]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_QUEST_DETAILS:
        # guid: Guid
        guid = await read_int(reader, 8)

        # guid2: Guid
        guid2 = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # title: CString
        title = await read_cstring(reader)

        # details: CString
        details = await read_cstring(reader)

        # objectives: CString
        objectives = await read_cstring(reader)

        # auto_finish: Bool8
        auto_finish = await read_bool(reader, 1)

        # quest_flags: u32
        quest_flags = await read_int(reader, 4)

        # suggested_players: u32
        suggested_players = await read_int(reader, 4)

        # is_finished: u8
        is_finished = await read_int(reader, 1)

        # amount_of_choice_item_rewards: u32
        amount_of_choice_item_rewards = await read_int(reader, 4)

        # choice_item_rewards: QuestGiverReward[amount_of_choice_item_rewards]
        choice_item_rewards = []
        for _ in range(0, amount_of_choice_item_rewards):
            choice_item_rewards.append(await QuestGiverReward.read(reader))

        # amount_of_item_rewards: u32
        amount_of_item_rewards = await read_int(reader, 4)

        # item_rewards: QuestGiverReward[amount_of_item_rewards]
        item_rewards = []
        for _ in range(0, amount_of_item_rewards):
            item_rewards.append(await QuestGiverReward.read(reader))

        # money_reward: Gold
        money_reward = await read_int(reader, 4)

        # experience_reward: u32
        experience_reward = await read_int(reader, 4)

        # honor_reward: u32
        honor_reward = await read_int(reader, 4)

        # honor_reward_multiplier: f32
        honor_reward_multiplier = await read_float(reader)

        # reward_spell: Spell
        reward_spell = await read_int(reader, 4)

        # casted_spell: Spell
        casted_spell = await read_int(reader, 4)

        # title_reward: u32
        title_reward = await read_int(reader, 4)

        # talent_reward: u32
        talent_reward = await read_int(reader, 4)

        # arena_point_reward: u32
        arena_point_reward = await read_int(reader, 4)

        # unknown2: u32
        unknown2 = await read_int(reader, 4)

        # reward_factions: u32[5]
        reward_factions = []
        for _ in range(0, 5):
            reward_factions.append(await read_int(reader, 4))

        # reward_reputations: u32[5]
        reward_reputations = []
        for _ in range(0, 5):
            reward_reputations.append(await read_int(reader, 4))

        # reward_reputations_override: u32[5]
        reward_reputations_override = []
        for _ in range(0, 5):
            reward_reputations_override.append(await read_int(reader, 4))

        # amount_of_emotes: u32
        amount_of_emotes = await read_int(reader, 4)

        # emotes: QuestDetailsEmote[amount_of_emotes]
        emotes = []
        for _ in range(0, amount_of_emotes):
            emotes.append(await QuestDetailsEmote.read(reader))

        return SMSG_QUESTGIVER_QUEST_DETAILS(
            guid=guid,
            guid2=guid2,
            quest_id=quest_id,
            title=title,
            details=details,
            objectives=objectives,
            auto_finish=auto_finish,
            quest_flags=quest_flags,
            suggested_players=suggested_players,
            is_finished=is_finished,
            choice_item_rewards=choice_item_rewards,
            item_rewards=item_rewards,
            money_reward=money_reward,
            experience_reward=experience_reward,
            honor_reward=honor_reward,
            honor_reward_multiplier=honor_reward_multiplier,
            reward_spell=reward_spell,
            casted_spell=casted_spell,
            title_reward=title_reward,
            talent_reward=talent_reward,
            arena_point_reward=arena_point_reward,
            unknown2=unknown2,
            reward_factions=reward_factions,
            reward_reputations=reward_reputations,
            reward_reputations_override=reward_reputations_override,
            emotes=emotes,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0188))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QQI{len(self.title)}sB{len(self.details)}sB{len(self.objectives)}sBBIIBI'
        _data.extend([self.guid, self.guid2, self.quest_id, self.title.encode('utf-8'), 0, self.details.encode('utf-8'), 0, self.objectives.encode('utf-8'), 0, self.auto_finish, self.quest_flags, self.suggested_players, self.is_finished, len(self.choice_item_rewards)])
        # choice_item_rewards: QuestGiverReward[amount_of_choice_item_rewards]
        for i in self.choice_item_rewards:
            _fmt, _data = i.write(_fmt, _data)

        # amount_of_item_rewards: u32
        _fmt += 'I'
        _data.append(len(self.item_rewards))

        # item_rewards: QuestGiverReward[amount_of_item_rewards]
        for i in self.item_rewards:
            _fmt, _data = i.write(_fmt, _data)

        # money_reward: Gold
        _fmt += 'I'
        _data.append(self.money_reward)

        # experience_reward: u32
        _fmt += 'I'
        _data.append(self.experience_reward)

        # honor_reward: u32
        _fmt += 'I'
        _data.append(self.honor_reward)

        # honor_reward_multiplier: f32
        _fmt += 'f'
        _data.append(self.honor_reward_multiplier)

        # reward_spell: Spell
        _fmt += 'I'
        _data.append(self.reward_spell)

        # casted_spell: Spell
        _fmt += 'I'
        _data.append(self.casted_spell)

        # title_reward: u32
        _fmt += 'I'
        _data.append(self.title_reward)

        # talent_reward: u32
        _fmt += 'I'
        _data.append(self.talent_reward)

        # arena_point_reward: u32
        _fmt += 'I'
        _data.append(self.arena_point_reward)

        # unknown2: u32
        _fmt += 'I'
        _data.append(self.unknown2)

        # reward_factions: u32[5]
        _fmt += f'{len(self.reward_factions)}I'
        _data.extend([*self.reward_factions])

        # reward_reputations: u32[5]
        _fmt += f'{len(self.reward_reputations)}I'
        _data.extend([*self.reward_reputations])

        # reward_reputations_override: u32[5]
        _fmt += f'{len(self.reward_reputations_override)}I'
        _data.extend([*self.reward_reputations_override])

        # amount_of_emotes: u32
        _fmt += 'I'
        _data.append(len(self.emotes))

        # emotes: QuestDetailsEmote[amount_of_emotes]
        for i in self.emotes:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 145 + len(self.title) + len(self.details) + len(self.objectives) + 12 * len(self.choice_item_rewards) + 12 * len(self.item_rewards) + 8 * len(self.emotes)


@dataclasses.dataclass
class CMSG_QUESTGIVER_ACCEPT_QUEST:
    guid: int
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_ACCEPT_QUEST:
        # guid: Guid
        guid = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return CMSG_QUESTGIVER_ACCEPT_QUEST(
            guid=guid,
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0189))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.quest_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUESTGIVER_COMPLETE_QUEST:
    guid: int
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_COMPLETE_QUEST:
        # guid: Guid
        guid = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return CMSG_QUESTGIVER_COMPLETE_QUEST(
            guid=guid,
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x018A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.quest_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_REQUEST_ITEMS:
    npc: int
    quest_id: int
    title: str
    request_items_text: str
    emote_delay: int
    emote: int
    auto_finish: bool
    flags1: int
    suggested_players: int
    required_money: int
    required_items: typing.List[QuestItemRequirement]
    completable: QuestCompletable
    flags2: int
    flags3: int
    flags4: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_REQUEST_ITEMS:
        # npc: Guid
        npc = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # title: CString
        title = await read_cstring(reader)

        # request_items_text: CString
        request_items_text = await read_cstring(reader)

        # emote_delay: u32
        emote_delay = await read_int(reader, 4)

        # emote: u32
        emote = await read_int(reader, 4)

        # auto_finish: Bool32
        auto_finish = await read_bool(reader, 4)

        # flags1: u32
        flags1 = await read_int(reader, 4)

        # suggested_players: u32
        suggested_players = await read_int(reader, 4)

        # required_money: Gold
        required_money = await read_int(reader, 4)

        # amount_of_required_items: u32
        amount_of_required_items = await read_int(reader, 4)

        # required_items: QuestItemRequirement[amount_of_required_items]
        required_items = []
        for _ in range(0, amount_of_required_items):
            required_items.append(await QuestItemRequirement.read(reader))

        # completable: QuestCompletable
        completable = QuestCompletable(await read_int(reader, 4))

        # flags2: u32
        flags2 = await read_int(reader, 4)

        # flags3: u32
        flags3 = await read_int(reader, 4)

        # flags4: u32
        flags4 = await read_int(reader, 4)

        return SMSG_QUESTGIVER_REQUEST_ITEMS(
            npc=npc,
            quest_id=quest_id,
            title=title,
            request_items_text=request_items_text,
            emote_delay=emote_delay,
            emote=emote,
            auto_finish=auto_finish,
            flags1=flags1,
            suggested_players=suggested_players,
            required_money=required_money,
            required_items=required_items,
            completable=completable,
            flags2=flags2,
            flags3=flags3,
            flags4=flags4,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x018B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QI{len(self.title)}sB{len(self.request_items_text)}sBIIIIIII'
        _data.extend([self.npc, self.quest_id, self.title.encode('utf-8'), 0, self.request_items_text.encode('utf-8'), 0, self.emote_delay, self.emote, self.auto_finish, self.flags1, self.suggested_players, self.required_money, len(self.required_items)])
        # required_items: QuestItemRequirement[amount_of_required_items]
        for i in self.required_items:
            _fmt, _data = i.write(_fmt, _data)

        # completable: QuestCompletable
        _fmt += 'I'
        _data.append(self.completable.value)

        # flags2: u32
        _fmt += 'I'
        _data.append(self.flags2)

        # flags3: u32
        _fmt += 'I'
        _data.append(self.flags3)

        # flags4: u32
        _fmt += 'I'
        _data.append(self.flags4)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 58 + len(self.title) + len(self.request_items_text) + 12 * len(self.required_items)


@dataclasses.dataclass
class CMSG_QUESTGIVER_REQUEST_REWARD:
    guid: int
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_REQUEST_REWARD:
        # guid: Guid
        guid = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return CMSG_QUESTGIVER_REQUEST_REWARD(
            guid=guid,
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x018C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.quest_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_OFFER_REWARD:
    npc: int
    quest_id: int
    title: str
    offer_reward_text: str
    auto_finish: bool
    flags1: int
    suggested_players: int
    emotes: typing.List[NpcTextUpdateEmote]
    choice_item_rewards: typing.List[QuestItemRequirement]
    item_rewards: typing.List[QuestItemRequirement]
    money_reward: int
    experience_reward: int
    honor_reward: int
    honor_reward_multiplier: float
    unknown1: int
    reward_spell: int
    reward_spell_cast: int
    title_reward: int
    reward_talents: int
    reward_arena_points: int
    reward_reputation_mask: int
    reward_factions: typing.List[int]
    reward_reputations: typing.List[int]
    reward_reputations_override: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_OFFER_REWARD:
        # npc: Guid
        npc = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # title: CString
        title = await read_cstring(reader)

        # offer_reward_text: CString
        offer_reward_text = await read_cstring(reader)

        # auto_finish: Bool32
        auto_finish = await read_bool(reader, 4)

        # flags1: u32
        flags1 = await read_int(reader, 4)

        # suggested_players: u32
        suggested_players = await read_int(reader, 4)

        # amount_of_emotes: u32
        amount_of_emotes = await read_int(reader, 4)

        # emotes: NpcTextUpdateEmote[amount_of_emotes]
        emotes = []
        for _ in range(0, amount_of_emotes):
            emotes.append(await NpcTextUpdateEmote.read(reader))

        # amount_of_choice_item_rewards: u32
        amount_of_choice_item_rewards = await read_int(reader, 4)

        # choice_item_rewards: QuestItemRequirement[amount_of_choice_item_rewards]
        choice_item_rewards = []
        for _ in range(0, amount_of_choice_item_rewards):
            choice_item_rewards.append(await QuestItemRequirement.read(reader))

        # amount_of_item_rewards: u32
        amount_of_item_rewards = await read_int(reader, 4)

        # item_rewards: QuestItemRequirement[amount_of_item_rewards]
        item_rewards = []
        for _ in range(0, amount_of_item_rewards):
            item_rewards.append(await QuestItemRequirement.read(reader))

        # money_reward: Gold
        money_reward = await read_int(reader, 4)

        # experience_reward: u32
        experience_reward = await read_int(reader, 4)

        # honor_reward: u32
        honor_reward = await read_int(reader, 4)

        # honor_reward_multiplier: f32
        honor_reward_multiplier = await read_float(reader)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # reward_spell: Spell
        reward_spell = await read_int(reader, 4)

        # reward_spell_cast: Spell
        reward_spell_cast = await read_int(reader, 4)

        # title_reward: u32
        title_reward = await read_int(reader, 4)

        # reward_talents: u32
        reward_talents = await read_int(reader, 4)

        # reward_arena_points: u32
        reward_arena_points = await read_int(reader, 4)

        # reward_reputation_mask: u32
        reward_reputation_mask = await read_int(reader, 4)

        # reward_factions: u32[5]
        reward_factions = []
        for _ in range(0, 5):
            reward_factions.append(await read_int(reader, 4))

        # reward_reputations: u32[5]
        reward_reputations = []
        for _ in range(0, 5):
            reward_reputations.append(await read_int(reader, 4))

        # reward_reputations_override: u32[5]
        reward_reputations_override = []
        for _ in range(0, 5):
            reward_reputations_override.append(await read_int(reader, 4))

        return SMSG_QUESTGIVER_OFFER_REWARD(
            npc=npc,
            quest_id=quest_id,
            title=title,
            offer_reward_text=offer_reward_text,
            auto_finish=auto_finish,
            flags1=flags1,
            suggested_players=suggested_players,
            emotes=emotes,
            choice_item_rewards=choice_item_rewards,
            item_rewards=item_rewards,
            money_reward=money_reward,
            experience_reward=experience_reward,
            honor_reward=honor_reward,
            honor_reward_multiplier=honor_reward_multiplier,
            unknown1=unknown1,
            reward_spell=reward_spell,
            reward_spell_cast=reward_spell_cast,
            title_reward=title_reward,
            reward_talents=reward_talents,
            reward_arena_points=reward_arena_points,
            reward_reputation_mask=reward_reputation_mask,
            reward_factions=reward_factions,
            reward_reputations=reward_reputations,
            reward_reputations_override=reward_reputations_override,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x018D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QI{len(self.title)}sB{len(self.offer_reward_text)}sBIIII'
        _data.extend([self.npc, self.quest_id, self.title.encode('utf-8'), 0, self.offer_reward_text.encode('utf-8'), 0, self.auto_finish, self.flags1, self.suggested_players, len(self.emotes)])
        # emotes: NpcTextUpdateEmote[amount_of_emotes]
        for i in self.emotes:
            _fmt, _data = i.write(_fmt, _data)

        # amount_of_choice_item_rewards: u32
        _fmt += 'I'
        _data.append(len(self.choice_item_rewards))

        # choice_item_rewards: QuestItemRequirement[amount_of_choice_item_rewards]
        for i in self.choice_item_rewards:
            _fmt, _data = i.write(_fmt, _data)

        # amount_of_item_rewards: u32
        _fmt += 'I'
        _data.append(len(self.item_rewards))

        # item_rewards: QuestItemRequirement[amount_of_item_rewards]
        for i in self.item_rewards:
            _fmt, _data = i.write(_fmt, _data)

        # money_reward: Gold
        _fmt += 'I'
        _data.append(self.money_reward)

        # experience_reward: u32
        _fmt += 'I'
        _data.append(self.experience_reward)

        # honor_reward: u32
        _fmt += 'I'
        _data.append(self.honor_reward)

        # honor_reward_multiplier: f32
        _fmt += 'f'
        _data.append(self.honor_reward_multiplier)

        # unknown1: u32
        _fmt += 'I'
        _data.append(self.unknown1)

        # reward_spell: Spell
        _fmt += 'I'
        _data.append(self.reward_spell)

        # reward_spell_cast: Spell
        _fmt += 'I'
        _data.append(self.reward_spell_cast)

        # title_reward: u32
        _fmt += 'I'
        _data.append(self.title_reward)

        # reward_talents: u32
        _fmt += 'I'
        _data.append(self.reward_talents)

        # reward_arena_points: u32
        _fmt += 'I'
        _data.append(self.reward_arena_points)

        # reward_reputation_mask: u32
        _fmt += 'I'
        _data.append(self.reward_reputation_mask)

        # reward_factions: u32[5]
        _fmt += f'{len(self.reward_factions)}I'
        _data.extend([*self.reward_factions])

        # reward_reputations: u32[5]
        _fmt += f'{len(self.reward_reputations)}I'
        _data.extend([*self.reward_reputations])

        # reward_reputations_override: u32[5]
        _fmt += f'{len(self.reward_reputations_override)}I'
        _data.extend([*self.reward_reputations_override])

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 142 + len(self.title) + len(self.offer_reward_text) + 8 * len(self.emotes) + 12 * len(self.choice_item_rewards) + 12 * len(self.item_rewards)


@dataclasses.dataclass
class CMSG_QUESTGIVER_CHOOSE_REWARD:
    guid: int
    quest_id: int
    reward: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_CHOOSE_REWARD:
        # guid: Guid
        guid = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # reward: u32
        reward = await read_int(reader, 4)

        return CMSG_QUESTGIVER_CHOOSE_REWARD(
            guid=guid,
            quest_id=quest_id,
            reward=reward,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x018E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.guid, self.quest_id, self.reward])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_QUEST_INVALID:
    msg: QuestFailedReason

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_QUEST_INVALID:
        # msg: QuestFailedReason
        msg = QuestFailedReason(await read_int(reader, 4))

        return SMSG_QUESTGIVER_QUEST_INVALID(
            msg=msg,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x018F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.msg.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUESTGIVER_CANCEL:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_CANCEL:
        return CMSG_QUESTGIVER_CANCEL()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0190))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_QUEST_COMPLETE:
    quest_id: int
    unknown: int
    experience_reward: int
    money_reward: int
    honor_reward: int
    talent_reward: int
    arena_point_reward: int
    item_rewards: typing.List[QuestItemReward]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_QUEST_COMPLETE:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # unknown: u32
        unknown = await read_int(reader, 4)

        # experience_reward: u32
        experience_reward = await read_int(reader, 4)

        # money_reward: Gold
        money_reward = await read_int(reader, 4)

        # honor_reward: u32
        honor_reward = await read_int(reader, 4)

        # talent_reward: u32
        talent_reward = await read_int(reader, 4)

        # arena_point_reward: u32
        arena_point_reward = await read_int(reader, 4)

        # amount_of_item_rewards: u32
        amount_of_item_rewards = await read_int(reader, 4)

        # item_rewards: QuestItemReward[amount_of_item_rewards]
        item_rewards = []
        for _ in range(0, amount_of_item_rewards):
            item_rewards.append(await QuestItemReward.read(reader))

        return SMSG_QUESTGIVER_QUEST_COMPLETE(
            quest_id=quest_id,
            unknown=unknown,
            experience_reward=experience_reward,
            money_reward=money_reward,
            honor_reward=honor_reward,
            talent_reward=talent_reward,
            arena_point_reward=arena_point_reward,
            item_rewards=item_rewards,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0191))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIIIIII'
        _data.extend([self.quest_id, self.unknown, self.experience_reward, self.money_reward, self.honor_reward, self.talent_reward, self.arena_point_reward, len(self.item_rewards)])
        # item_rewards: QuestItemReward[amount_of_item_rewards]
        for i in self.item_rewards:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 32 + 8 * len(self.item_rewards)


@dataclasses.dataclass
class SMSG_QUESTGIVER_QUEST_FAILED:
    quest_id: int
    reason: QuestFailedReason

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_QUEST_FAILED:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # reason: QuestFailedReason
        reason = QuestFailedReason(await read_int(reader, 4))

        return SMSG_QUESTGIVER_QUEST_FAILED(
            quest_id=quest_id,
            reason=reason,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0192))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.quest_id, self.reason.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUESTLOG_SWAP_QUEST:
    slot1: int
    slot2: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTLOG_SWAP_QUEST:
        # slot1: u8
        slot1 = await read_int(reader, 1)

        # slot2: u8
        slot2 = await read_int(reader, 1)

        return CMSG_QUESTLOG_SWAP_QUEST(
            slot1=slot1,
            slot2=slot2,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x0193))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.slot1, self.slot2])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUESTLOG_REMOVE_QUEST:
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTLOG_REMOVE_QUEST:
        # slot: u8
        slot = await read_int(reader, 1)

        return CMSG_QUESTLOG_REMOVE_QUEST(
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x0194))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.slot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTLOG_FULL:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTLOG_FULL:
        return SMSG_QUESTLOG_FULL()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0195))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTUPDATE_FAILED:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTUPDATE_FAILED:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return SMSG_QUESTUPDATE_FAILED(
            quest_id=quest_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0196))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.quest_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTUPDATE_FAILEDTIMER:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTUPDATE_FAILEDTIMER:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return SMSG_QUESTUPDATE_FAILEDTIMER(
            quest_id=quest_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0197))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.quest_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTUPDATE_COMPLETE:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTUPDATE_COMPLETE:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return SMSG_QUESTUPDATE_COMPLETE(
            quest_id=quest_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0198))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.quest_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTUPDATE_ADD_KILL:
    quest_id: int
    creature_id: int
    kill_count: int
    required_kill_count: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTUPDATE_ADD_KILL:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # creature_id: u32
        creature_id = await read_int(reader, 4)

        # kill_count: u32
        kill_count = await read_int(reader, 4)

        # required_kill_count: u32
        required_kill_count = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_QUESTUPDATE_ADD_KILL(
            quest_id=quest_id,
            creature_id=creature_id,
            kill_count=kill_count,
            required_kill_count=required_kill_count,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(24 + 2, 0x0199))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIIQ'
        _data.extend([self.quest_id, self.creature_id, self.kill_count, self.required_kill_count, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTUPDATE_ADD_ITEM:
    required_item_id: int
    items_required: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTUPDATE_ADD_ITEM:
        # required_item_id: u32
        required_item_id = await read_int(reader, 4)

        # items_required: u32
        items_required = await read_int(reader, 4)

        return SMSG_QUESTUPDATE_ADD_ITEM(
            required_item_id=required_item_id,
            items_required=items_required,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x019A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.required_item_id, self.items_required])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUEST_CONFIRM_ACCEPT:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUEST_CONFIRM_ACCEPT:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return CMSG_QUEST_CONFIRM_ACCEPT(
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x019B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.quest_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUEST_CONFIRM_ACCEPT:
    quest_id: int
    quest_title: str
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUEST_CONFIRM_ACCEPT:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # quest_title: CString
        quest_title = await read_cstring(reader)

        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_QUEST_CONFIRM_ACCEPT(
            quest_id=quest_id,
            quest_title=quest_title,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x019C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.quest_title)}sBQ'
        _data.extend([self.quest_id, self.quest_title.encode('utf-8'), 0, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 13 + len(self.quest_title)


@dataclasses.dataclass
class CMSG_PUSHQUESTTOPARTY:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PUSHQUESTTOPARTY:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return CMSG_PUSHQUESTTOPARTY(
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x019D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.quest_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LIST_INVENTORY:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LIST_INVENTORY:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_LIST_INVENTORY(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x019E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LIST_INVENTORY:
    vendor: int
    items: typing.List[ListInventoryItem]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LIST_INVENTORY:
        # vendor: Guid
        vendor = await read_int(reader, 8)

        # amount_of_items: u8
        amount_of_items = await read_int(reader, 1)

        # items: ListInventoryItem[amount_of_items]
        items = []
        for _ in range(0, amount_of_items):
            items.append(await ListInventoryItem.read(reader))

        return SMSG_LIST_INVENTORY(
            vendor=vendor,
            items=items,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x019F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.vendor, len(self.items)])
        # items: ListInventoryItem[amount_of_items]
        for i in self.items:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + 32 * len(self.items)


@dataclasses.dataclass
class CMSG_SELL_ITEM:
    vendor: int
    item: int
    amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SELL_ITEM:
        # vendor: Guid
        vendor = await read_int(reader, 8)

        # item: Guid
        item = await read_int(reader, 8)

        # amount: u8
        amount = await read_int(reader, 1)

        return CMSG_SELL_ITEM(
            vendor=vendor,
            item=item,
            amount=amount,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(17 + 4, 0x01A0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QQB'
        _data.extend([self.vendor, self.item, self.amount])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SELL_ITEM:
    guid: int
    item: int
    result: SellItemResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SELL_ITEM:
        # guid: Guid
        guid = await read_int(reader, 8)

        # item: Guid
        item = await read_int(reader, 8)

        # result: SellItemResult
        result = SellItemResult(await read_int(reader, 1))

        return SMSG_SELL_ITEM(
            guid=guid,
            item=item,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(17 + 2, 0x01A1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQB'
        _data.extend([self.guid, self.item, self.result.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BUY_ITEM:
    vendor: int
    item: int
    slot: int
    amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BUY_ITEM:
        # vendor: Guid
        vendor = await read_int(reader, 8)

        # item: Item
        item = await read_int(reader, 4)

        # slot: u32
        slot = await read_int(reader, 4)

        # amount: u8
        amount = await read_int(reader, 1)

        return CMSG_BUY_ITEM(
            vendor=vendor,
            item=item,
            slot=slot,
            amount=amount,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(17 + 4, 0x01A2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIIB'
        _data.extend([self.vendor, self.item, self.slot, self.amount])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BUY_ITEM_IN_SLOT:
    vendor: int
    item: int
    vendor_slot: int
    bag: int
    bag_slot: int
    amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BUY_ITEM_IN_SLOT:
        # vendor: Guid
        vendor = await read_int(reader, 8)

        # item: Item
        item = await read_int(reader, 4)

        # vendor_slot: u32
        vendor_slot = await read_int(reader, 4)

        # bag: Guid
        bag = await read_int(reader, 8)

        # bag_slot: u8
        bag_slot = await read_int(reader, 1)

        # amount: u8
        amount = await read_int(reader, 1)

        return CMSG_BUY_ITEM_IN_SLOT(
            vendor=vendor,
            item=item,
            vendor_slot=vendor_slot,
            bag=bag,
            bag_slot=bag_slot,
            amount=amount,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(26 + 4, 0x01A3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIIQBB'
        _data.extend([self.vendor, self.item, self.vendor_slot, self.bag, self.bag_slot, self.amount])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BUY_ITEM:
    guid: int
    vendor_slot: int
    amount_for_sale: int
    amount_bought: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BUY_ITEM:
        # guid: Guid
        guid = await read_int(reader, 8)

        # vendor_slot: u32
        vendor_slot = await read_int(reader, 4)

        # amount_for_sale: u32
        amount_for_sale = await read_int(reader, 4)

        # amount_bought: u32
        amount_bought = await read_int(reader, 4)

        return SMSG_BUY_ITEM(
            guid=guid,
            vendor_slot=vendor_slot,
            amount_for_sale=amount_for_sale,
            amount_bought=amount_bought,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x01A4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIII'
        _data.extend([self.guid, self.vendor_slot, self.amount_for_sale, self.amount_bought])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BUY_FAILED:
    guid: int
    item: int
    result: BuyResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BUY_FAILED:
        # guid: Guid
        guid = await read_int(reader, 8)

        # item: Item
        item = await read_int(reader, 4)

        # result: BuyResult
        result = BuyResult(await read_int(reader, 1))

        return SMSG_BUY_FAILED(
            guid=guid,
            item=item,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(13 + 2, 0x01A5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIB'
        _data.extend([self.guid, self.item, self.result.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SHOWTAXINODES:
    unknown1: int
    guid: int
    nearest_node: int
    nodes: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SHOWTAXINODES:
        _size = 0

        # unknown1: u32
        unknown1 = await read_int(reader, 4)
        _size += 4

        # guid: Guid
        guid = await read_int(reader, 8)
        _size += 8

        # nearest_node: u32
        nearest_node = await read_int(reader, 4)
        _size += 4

        # nodes: u32[-]
        nodes = []
        while _size < body_size:
            nodes.append(await read_int(reader, 4))
            _size += 4

        return SMSG_SHOWTAXINODES(
            unknown1=unknown1,
            guid=guid,
            nearest_node=nearest_node,
            nodes=nodes,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01A9))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'IQI{len(self.nodes)}I'
        _data.extend([self.unknown1, self.guid, self.nearest_node, *self.nodes])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + 4 * len(self.nodes)


@dataclasses.dataclass
class CMSG_TAXINODE_STATUS_QUERY:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TAXINODE_STATUS_QUERY:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_TAXINODE_STATUS_QUERY(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01AA))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TAXINODE_STATUS:
    guid: int
    taxi_mask_node_known: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TAXINODE_STATUS:
        # guid: Guid
        guid = await read_int(reader, 8)

        # taxi_mask_node_known: Bool8
        taxi_mask_node_known = await read_bool(reader, 1)

        return SMSG_TAXINODE_STATUS(
            guid=guid,
            taxi_mask_node_known=taxi_mask_node_known,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x01AB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.taxi_mask_node_known])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TAXIQUERYAVAILABLENODES:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TAXIQUERYAVAILABLENODES:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_TAXIQUERYAVAILABLENODES(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01AC))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ACTIVATETAXI:
    guid: int
    source_node: int
    destination_node: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ACTIVATETAXI:
        # guid: Guid
        guid = await read_int(reader, 8)

        # source_node: u32
        source_node = await read_int(reader, 4)

        # destination_node: u32
        destination_node = await read_int(reader, 4)

        return CMSG_ACTIVATETAXI(
            guid=guid,
            source_node=source_node,
            destination_node=destination_node,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x01AD))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.guid, self.source_node, self.destination_node])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ACTIVATETAXIREPLY:
    reply: ActivateTaxiReply

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ACTIVATETAXIREPLY:
        # reply: ActivateTaxiReply
        reply = ActivateTaxiReply(await read_int(reader, 4))

        return SMSG_ACTIVATETAXIREPLY(
            reply=reply,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01AE))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.reply.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_NEW_TAXI_PATH:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_NEW_TAXI_PATH:
        return SMSG_NEW_TAXI_PATH()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x01AF))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TRAINER_LIST:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TRAINER_LIST:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_TRAINER_LIST(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01B0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TRAINER_LIST:
    guid: int
    trainer_type: int
    spells: typing.List[TrainerSpell]
    greeting: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRAINER_LIST:
        # guid: Guid
        guid = await read_int(reader, 8)

        # trainer_type: u32
        trainer_type = await read_int(reader, 4)

        # amount_of_spells: u32
        amount_of_spells = await read_int(reader, 4)

        # spells: TrainerSpell[amount_of_spells]
        spells = []
        for _ in range(0, amount_of_spells):
            spells.append(await TrainerSpell.read(reader))

        # greeting: CString
        greeting = await read_cstring(reader)

        return SMSG_TRAINER_LIST(
            guid=guid,
            trainer_type=trainer_type,
            spells=spells,
            greeting=greeting,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01B1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.guid, self.trainer_type, len(self.spells)])
        # spells: TrainerSpell[amount_of_spells]
        for i in self.spells:
            _fmt, _data = i.write(_fmt, _data)

        # greeting: CString
        _fmt += f'{len(self.greeting)}sB'
        _data.extend([self.greeting.encode('utf-8'), 0])

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 17 + 38 * len(self.spells) + len(self.greeting)


@dataclasses.dataclass
class CMSG_TRAINER_BUY_SPELL:
    guid: int
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TRAINER_BUY_SPELL:
        # guid: Guid
        guid = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        return CMSG_TRAINER_BUY_SPELL(
            guid=guid,
            id=id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x01B2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TRAINER_BUY_SUCCEEDED:
    guid: int
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRAINER_BUY_SUCCEEDED:
        # guid: Guid
        guid = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        return SMSG_TRAINER_BUY_SUCCEEDED(
            guid=guid,
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01B3))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TRAINER_BUY_FAILED:
    guid: int
    id: int
    error: TrainingFailureReason

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRAINER_BUY_FAILED:
        # guid: Guid
        guid = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        # error: TrainingFailureReason
        error = TrainingFailureReason(await read_int(reader, 4))

        return SMSG_TRAINER_BUY_FAILED(
            guid=guid,
            id=id,
            error=error,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x01B4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.guid, self.id, self.error.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BINDER_ACTIVATE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BINDER_ACTIVATE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_BINDER_ACTIVATE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01B5))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BANKER_ACTIVATE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BANKER_ACTIVATE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_BANKER_ACTIVATE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01B7))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SHOW_BANK:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SHOW_BANK:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_SHOW_BANK(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01B8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BUY_BANK_SLOT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BUY_BANK_SLOT:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_BUY_BANK_SLOT(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01B9))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BUY_BANK_SLOT_RESULT:
    result: BuyBankSlotResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BUY_BANK_SLOT_RESULT:
        # result: BuyBankSlotResult
        result = BuyBankSlotResult(await read_int(reader, 4))

        return SMSG_BUY_BANK_SLOT_RESULT(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01BA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PETITION_SHOWLIST:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PETITION_SHOWLIST:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_PETITION_SHOWLIST(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01BB))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PETITION_SHOWLIST:
    npc: int
    petitions: typing.List[PetitionShowlist]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PETITION_SHOWLIST:
        # npc: Guid
        npc = await read_int(reader, 8)

        # amount_of_petitions: u8
        amount_of_petitions = await read_int(reader, 1)

        # petitions: PetitionShowlist[amount_of_petitions]
        petitions = []
        for _ in range(0, amount_of_petitions):
            petitions.append(await PetitionShowlist.read(reader))

        return SMSG_PETITION_SHOWLIST(
            npc=npc,
            petitions=petitions,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01BC))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.npc, len(self.petitions)])
        # petitions: PetitionShowlist[amount_of_petitions]
        for i in self.petitions:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + 24 * len(self.petitions)


@dataclasses.dataclass
class CMSG_PETITION_BUY:
    npc: int
    unknown1: int
    unknown2: int
    name: str
    unknown3: str
    unknown4: int
    unknown5: int
    unknown6: int
    unknown7: int
    unknown8: int
    unknown9: int
    unknown10: int
    unknown11: int
    unknown12: int
    unknown13: int
    unknown14: int
    unknown15: typing.List[str]
    index: int
    unknown16: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PETITION_BUY:
        # npc: Guid
        npc = await read_int(reader, 8)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # unknown2: Guid
        unknown2 = await read_int(reader, 8)

        # name: CString
        name = await read_cstring(reader)

        # unknown3: CString
        unknown3 = await read_cstring(reader)

        # unknown4: u32
        unknown4 = await read_int(reader, 4)

        # unknown5: u32
        unknown5 = await read_int(reader, 4)

        # unknown6: u32
        unknown6 = await read_int(reader, 4)

        # unknown7: u32
        unknown7 = await read_int(reader, 4)

        # unknown8: u32
        unknown8 = await read_int(reader, 4)

        # unknown9: u32
        unknown9 = await read_int(reader, 4)

        # unknown10: u32
        unknown10 = await read_int(reader, 4)

        # unknown11: u16
        unknown11 = await read_int(reader, 2)

        # unknown12: u32
        unknown12 = await read_int(reader, 4)

        # unknown13: u32
        unknown13 = await read_int(reader, 4)

        # unknown14: u32
        unknown14 = await read_int(reader, 4)

        # unknown15: CString[10]
        unknown15 = []
        for _ in range(0, 10):
            unknown15.append(await read_cstring(reader))

        # index: u32
        index = await read_int(reader, 4)

        # unknown16: u32
        unknown16 = await read_int(reader, 4)

        return CMSG_PETITION_BUY(
            npc=npc,
            unknown1=unknown1,
            unknown2=unknown2,
            name=name,
            unknown3=unknown3,
            unknown4=unknown4,
            unknown5=unknown5,
            unknown6=unknown6,
            unknown7=unknown7,
            unknown8=unknown8,
            unknown9=unknown9,
            unknown10=unknown10,
            unknown11=unknown11,
            unknown12=unknown12,
            unknown13=unknown13,
            unknown14=unknown14,
            unknown15=unknown15,
            index=index,
            unknown16=unknown16,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x01BD))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'QIQ{len(self.name)}sB{len(self.unknown3)}sBIIIIIIIHIII'
        _data.extend([self.npc, self.unknown1, self.unknown2, self.name.encode('utf-8'), 0, self.unknown3.encode('utf-8'), 0, self.unknown4, self.unknown5, self.unknown6, self.unknown7, self.unknown8, self.unknown9, self.unknown10, self.unknown11, self.unknown12, self.unknown13, self.unknown14])
        # unknown15: CString[10]
        for i in self.unknown15:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        # index: u32
        _fmt += 'I'
        _data.append(self.index)

        # unknown16: u32
        _fmt += 'I'
        _data.append(self.unknown16)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 72 + len(self.name) + len(self.unknown3) + sum([len(i) + 1 for i in self.unknown15])


@dataclasses.dataclass
class CMSG_PETITION_SHOW_SIGNATURES:
    item: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PETITION_SHOW_SIGNATURES:
        # item: Guid
        item = await read_int(reader, 8)

        return CMSG_PETITION_SHOW_SIGNATURES(
            item=item,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01BE))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.item)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PETITION_SHOW_SIGNATURES:
    item: int
    owner: int
    petition: int
    signatures: typing.List[PetitionSignature]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PETITION_SHOW_SIGNATURES:
        # item: Guid
        item = await read_int(reader, 8)

        # owner: Guid
        owner = await read_int(reader, 8)

        # petition: u32
        petition = await read_int(reader, 4)

        # amount_of_signatures: u8
        amount_of_signatures = await read_int(reader, 1)

        # signatures: PetitionSignature[amount_of_signatures]
        signatures = []
        for _ in range(0, amount_of_signatures):
            signatures.append(await PetitionSignature.read(reader))

        return SMSG_PETITION_SHOW_SIGNATURES(
            item=item,
            owner=owner,
            petition=petition,
            signatures=signatures,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01BF))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQIB'
        _data.extend([self.item, self.owner, self.petition, len(self.signatures)])
        # signatures: PetitionSignature[amount_of_signatures]
        for i in self.signatures:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 21 + 12 * len(self.signatures)


@dataclasses.dataclass
class CMSG_PETITION_SIGN:
    petition: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PETITION_SIGN:
        # petition: Guid
        petition = await read_int(reader, 8)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        return CMSG_PETITION_SIGN(
            petition=petition,
            unknown1=unknown1,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x01C0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.petition, self.unknown1])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PETITION_SIGN_RESULTS:
    petition: int
    owner: int
    result: PetitionResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PETITION_SIGN_RESULTS:
        # petition: Guid
        petition = await read_int(reader, 8)

        # owner: Guid
        owner = await read_int(reader, 8)

        # result: PetitionResult
        result = PetitionResult(await read_int(reader, 4))

        return SMSG_PETITION_SIGN_RESULTS(
            petition=petition,
            owner=owner,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x01C1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQI'
        _data.extend([self.petition, self.owner, self.result.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_PETITION_DECLINE:
    petition: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_PETITION_DECLINE:
        # petition: Guid
        petition = await read_int(reader, 8)

        return MSG_PETITION_DECLINE(
            petition=petition,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01C2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.petition)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01C2))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.petition)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_OFFER_PETITION:
    unknown0: int
    petition: int
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_OFFER_PETITION:
        # unknown0: u32
        unknown0 = await read_int(reader, 4)

        # petition: Guid
        petition = await read_int(reader, 8)

        # target: Guid
        target = await read_int(reader, 8)

        return CMSG_OFFER_PETITION(
            unknown0=unknown0,
            petition=petition,
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 4, 0x01C3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQQ'
        _data.extend([self.unknown0, self.petition, self.target])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TURN_IN_PETITION:
    petition: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TURN_IN_PETITION:
        # petition: Guid
        petition = await read_int(reader, 8)

        return CMSG_TURN_IN_PETITION(
            petition=petition,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01C4))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.petition)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TURN_IN_PETITION_RESULTS:
    result: PetitionResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TURN_IN_PETITION_RESULTS:
        # result: PetitionResult
        result = PetitionResult(await read_int(reader, 4))

        return SMSG_TURN_IN_PETITION_RESULTS(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01C5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PETITION_QUERY:
    guild_id: int
    petition: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PETITION_QUERY:
        # guild_id: u32
        guild_id = await read_int(reader, 4)

        # petition: Guid
        petition = await read_int(reader, 8)

        return CMSG_PETITION_QUERY(
            guild_id=guild_id,
            petition=petition,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x01C6))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.guild_id, self.petition])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PETITION_QUERY_RESPONSE:
    petition_id: int
    charter_owner: int
    guild_name: str
    body_text: str
    minimum_signatures: int
    maximum_signatures: int
    unknown1: int
    unknown2: int
    unknown3: int
    unknown4: int
    unknown5: int
    unknown6: int
    unknown7: int
    unknown8: int
    unknown9: int
    unknown10: typing.List[int]
    unknown11: int
    charter_type: CharterType

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PETITION_QUERY_RESPONSE:
        # petition_id: u32
        petition_id = await read_int(reader, 4)

        # charter_owner: Guid
        charter_owner = await read_int(reader, 8)

        # guild_name: CString
        guild_name = await read_cstring(reader)

        # body_text: CString
        body_text = await read_cstring(reader)

        # minimum_signatures: u32
        minimum_signatures = await read_int(reader, 4)

        # maximum_signatures: u32
        maximum_signatures = await read_int(reader, 4)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # unknown2: u32
        unknown2 = await read_int(reader, 4)

        # unknown3: u32
        unknown3 = await read_int(reader, 4)

        # unknown4: u32
        unknown4 = await read_int(reader, 4)

        # unknown5: u32
        unknown5 = await read_int(reader, 4)

        # unknown6: u16
        unknown6 = await read_int(reader, 2)

        # unknown7: u32
        unknown7 = await read_int(reader, 4)

        # unknown8: u32
        unknown8 = await read_int(reader, 4)

        # unknown9: u32
        unknown9 = await read_int(reader, 4)

        # unknown10: u8[10]
        unknown10 = []
        for _ in range(0, 10):
            unknown10.append(await read_int(reader, 1))

        # unknown11: u32
        unknown11 = await read_int(reader, 4)

        # charter_type: CharterType
        charter_type = CharterType(await read_int(reader, 4))

        return SMSG_PETITION_QUERY_RESPONSE(
            petition_id=petition_id,
            charter_owner=charter_owner,
            guild_name=guild_name,
            body_text=body_text,
            minimum_signatures=minimum_signatures,
            maximum_signatures=maximum_signatures,
            unknown1=unknown1,
            unknown2=unknown2,
            unknown3=unknown3,
            unknown4=unknown4,
            unknown5=unknown5,
            unknown6=unknown6,
            unknown7=unknown7,
            unknown8=unknown8,
            unknown9=unknown9,
            unknown10=unknown10,
            unknown11=unknown11,
            charter_type=charter_type,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01C7))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'IQ{len(self.guild_name)}sB{len(self.body_text)}sBIIIIIIIHIII{len(self.unknown10)}BII'
        _data.extend([self.petition_id, self.charter_owner, self.guild_name.encode('utf-8'), 0, self.body_text.encode('utf-8'), 0, self.minimum_signatures, self.maximum_signatures, self.unknown1, self.unknown2, self.unknown3, self.unknown4, self.unknown5, self.unknown6, self.unknown7, self.unknown8, self.unknown9, *self.unknown10, self.unknown11, self.charter_type.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 74 + len(self.guild_name) + len(self.body_text)


@dataclasses.dataclass
class SMSG_FISH_NOT_HOOKED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FISH_NOT_HOOKED:
        return SMSG_FISH_NOT_HOOKED()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x01C8))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_FISH_ESCAPED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FISH_ESCAPED:
        return SMSG_FISH_ESCAPED()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x01C9))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BUG:
    suggestion: int
    content: str
    bug_type: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BUG:
        # suggestion: u32
        suggestion = await read_int(reader, 4)

        # content: SizedCString
        content = await read_sized_cstring(reader)

        # bug_type: SizedCString
        bug_type = await read_sized_cstring(reader)

        return CMSG_BUG(
            suggestion=suggestion,
            content=content,
            bug_type=bug_type,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x01CA))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'II{len(self.content)}sBI{len(self.bug_type)}sB'
        _data.extend([self.suggestion, len(self.content) + 1, self.content.encode('utf-8'), 0, len(self.bug_type) + 1, self.bug_type.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 14 + len(self.content) + len(self.bug_type)


@dataclasses.dataclass
class SMSG_NOTIFICATION:
    notification: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_NOTIFICATION:
        # notification: CString
        notification = await read_cstring(reader)

        return SMSG_NOTIFICATION(
            notification=notification,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01CB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.notification)}sB'
        _data.extend([self.notification.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.notification)


@dataclasses.dataclass
class CMSG_PLAYED_TIME:
    show_on_ui: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PLAYED_TIME:
        # show_on_ui: Bool8
        show_on_ui = await read_bool(reader, 1)

        return CMSG_PLAYED_TIME(
            show_on_ui=show_on_ui,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x01CC))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.show_on_ui)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PLAYED_TIME:
    total_played_time: int
    level_played_time: int
    show_on_ui: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAYED_TIME:
        # total_played_time: u32
        total_played_time = await read_int(reader, 4)

        # level_played_time: u32
        level_played_time = await read_int(reader, 4)

        # show_on_ui: Bool8
        show_on_ui = await read_bool(reader, 1)

        return SMSG_PLAYED_TIME(
            total_played_time=total_played_time,
            level_played_time=level_played_time,
            show_on_ui=show_on_ui,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x01CD))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIB'
        _data.extend([self.total_played_time, self.level_played_time, self.show_on_ui])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUERY_TIME:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUERY_TIME:
        return CMSG_QUERY_TIME()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x01CE))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUERY_TIME_RESPONSE:
    time: int
    time_until_daily_quest_reset: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUERY_TIME_RESPONSE:
        # time: u32
        time = await read_int(reader, 4)

        # time_until_daily_quest_reset: u32
        time_until_daily_quest_reset = await read_int(reader, 4)

        return SMSG_QUERY_TIME_RESPONSE(
            time=time,
            time_until_daily_quest_reset=time_until_daily_quest_reset,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01CF))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.time, self.time_until_daily_quest_reset])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOG_XPGAIN:
    target: int
    total_exp: int
    exp_type: ExperienceAwardType
    exp_includes_recruit_a_friend_bonus: bool
    experience_without_rested: typing.Optional[int] = None
    exp_group_bonus: typing.Optional[float] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOG_XPGAIN:
        experience_without_rested = None
        exp_group_bonus = None
        # target: Guid
        target = await read_int(reader, 8)

        # total_exp: u32
        total_exp = await read_int(reader, 4)

        # exp_type: ExperienceAwardType
        exp_type = ExperienceAwardType(await read_int(reader, 1))

        if exp_type == ExperienceAwardType.NON_KILL:
            # experience_without_rested: u32
            experience_without_rested = await read_int(reader, 4)

            # exp_group_bonus: f32
            exp_group_bonus = await read_float(reader)

        # exp_includes_recruit_a_friend_bonus: Bool8
        exp_includes_recruit_a_friend_bonus = await read_bool(reader, 1)

        return SMSG_LOG_XPGAIN(
            target=target,
            total_exp=total_exp,
            exp_type=exp_type,
            experience_without_rested=experience_without_rested,
            exp_group_bonus=exp_group_bonus,
            exp_includes_recruit_a_friend_bonus=exp_includes_recruit_a_friend_bonus,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01D0))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIB'
        _data.extend([self.target, self.total_exp, self.exp_type.value])
        if self.exp_type == ExperienceAwardType.NON_KILL:
            _fmt += 'If'
            _data.extend([self.experience_without_rested, self.exp_group_bonus])
        # exp_includes_recruit_a_friend_bonus: Bool8
        _fmt += 'B'
        _data.append(self.exp_includes_recruit_a_friend_bonus)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 14

        if self.exp_type == ExperienceAwardType.NON_KILL:
            _size += 8

        return _size


@dataclasses.dataclass
class CMSG_RECLAIM_CORPSE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_RECLAIM_CORPSE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_RECLAIM_CORPSE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01D2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_WRAP_ITEM:
    gift_bag_index: int
    gift_slot: int
    item_bag_index: int
    item_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_WRAP_ITEM:
        # gift_bag_index: u8
        gift_bag_index = await read_int(reader, 1)

        # gift_slot: u8
        gift_slot = await read_int(reader, 1)

        # item_bag_index: u8
        item_bag_index = await read_int(reader, 1)

        # item_slot: u8
        item_slot = await read_int(reader, 1)

        return CMSG_WRAP_ITEM(
            gift_bag_index=gift_bag_index,
            gift_slot=gift_slot,
            item_bag_index=item_bag_index,
            item_slot=item_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x01D3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBBB'
        _data.extend([self.gift_bag_index, self.gift_slot, self.item_bag_index, self.item_slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LEVELUP_INFO:
    new_level: int
    health: int
    mana: int
    rage: int
    focus: int
    energy: int
    happiness: int
    rune: int
    runic_power: int
    strength: int
    agility: int
    stamina: int
    intellect: int
    spirit: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LEVELUP_INFO:
        # new_level: Level32
        new_level = await read_int(reader, 4)

        # health: u32
        health = await read_int(reader, 4)

        # mana: u32
        mana = await read_int(reader, 4)

        # rage: u32
        rage = await read_int(reader, 4)

        # focus: u32
        focus = await read_int(reader, 4)

        # energy: u32
        energy = await read_int(reader, 4)

        # happiness: u32
        happiness = await read_int(reader, 4)

        # rune: u32
        rune = await read_int(reader, 4)

        # runic_power: u32
        runic_power = await read_int(reader, 4)

        # strength: u32
        strength = await read_int(reader, 4)

        # agility: u32
        agility = await read_int(reader, 4)

        # stamina: u32
        stamina = await read_int(reader, 4)

        # intellect: u32
        intellect = await read_int(reader, 4)

        # spirit: u32
        spirit = await read_int(reader, 4)

        return SMSG_LEVELUP_INFO(
            new_level=new_level,
            health=health,
            mana=mana,
            rage=rage,
            focus=focus,
            energy=energy,
            happiness=happiness,
            rune=rune,
            runic_power=runic_power,
            strength=strength,
            agility=agility,
            stamina=stamina,
            intellect=intellect,
            spirit=spirit,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(56 + 2, 0x01D4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIIIIIIIIIIII'
        _data.extend([self.new_level, self.health, self.mana, self.rage, self.focus, self.energy, self.happiness, self.rune, self.runic_power, self.strength, self.agility, self.stamina, self.intellect, self.spirit])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MINIMAP_PING_Client:
    position_x: float
    position_y: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MINIMAP_PING_Client:
        # position_x: f32
        position_x = await read_float(reader)

        # position_y: f32
        position_y = await read_float(reader)

        return MSG_MINIMAP_PING_Client(
            position_x=position_x,
            position_y=position_y,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01D5))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'ff'
        _data.extend([self.position_x, self.position_y])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MINIMAP_PING_Server:
    guid: int
    position_x: float
    position_y: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MINIMAP_PING_Server:
        # guid: Guid
        guid = await read_int(reader, 8)

        # position_x: f32
        position_x = await read_float(reader)

        # position_y: f32
        position_y = await read_float(reader)

        return MSG_MINIMAP_PING_Server(
            guid=guid,
            position_x=position_x,
            position_y=position_y,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x01D5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Qff'
        _data.extend([self.guid, self.position_x, self.position_y])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ENCHANTMENTLOG:
    target: int
    caster: int
    item: int
    spell: int
    show_affiliation: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ENCHANTMENTLOG:
        # target: PackedGuid
        target = await read_packed_guid(reader)

        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # item: Item
        item = await read_int(reader, 4)

        # spell: Spell
        spell = await read_int(reader, 4)

        # show_affiliation: Bool8
        show_affiliation = await read_bool(reader, 1)

        return SMSG_ENCHANTMENTLOG(
            target=target,
            caster=caster,
            item=item,
            spell=spell,
            show_affiliation=show_affiliation,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01D7))
        _fmt = "<4s"
        _data = [_data]

        # target: PackedGuid
        _fmt, _data = packed_guid_write(self.target, _fmt, _data)

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # item: Item
        _fmt += 'I'
        _data.append(self.item)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # show_affiliation: Bool8
        _fmt += 'B'
        _data.append(self.show_affiliation)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + packed_guid_size(self.target) + packed_guid_size(self.caster)


@dataclasses.dataclass
class SMSG_START_MIRROR_TIMER:
    timer: TimerType
    time_remaining: int
    duration: int
    scale: int
    is_frozen: bool
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_START_MIRROR_TIMER:
        # timer: TimerType
        timer = TimerType(await read_int(reader, 4))

        # time_remaining: u32
        time_remaining = await read_int(reader, 4)

        # duration: u32
        duration = await read_int(reader, 4)

        # scale: u32
        scale = await read_int(reader, 4)

        # is_frozen: Bool8
        is_frozen = await read_bool(reader, 1)

        # id: Spell
        id = await read_int(reader, 4)

        return SMSG_START_MIRROR_TIMER(
            timer=timer,
            time_remaining=time_remaining,
            duration=duration,
            scale=scale,
            is_frozen=is_frozen,
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(21 + 2, 0x01D9))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIIBI'
        _data.extend([self.timer.value, self.time_remaining, self.duration, self.scale, self.is_frozen, self.id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PAUSE_MIRROR_TIMER:
    timer: TimerType
    is_frozen: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PAUSE_MIRROR_TIMER:
        # timer: TimerType
        timer = TimerType(await read_int(reader, 4))

        # is_frozen: Bool8
        is_frozen = await read_bool(reader, 1)

        return SMSG_PAUSE_MIRROR_TIMER(
            timer=timer,
            is_frozen=is_frozen,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x01DA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([self.timer.value, self.is_frozen])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_STOP_MIRROR_TIMER:
    timer: TimerType

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_STOP_MIRROR_TIMER:
        # timer: TimerType
        timer = TimerType(await read_int(reader, 4))

        return SMSG_STOP_MIRROR_TIMER(
            timer=timer,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01DB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.timer.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PING:
    sequence_id: int
    round_time_in_ms: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PING:
        # sequence_id: u32
        sequence_id = await read_int(reader, 4)

        # round_time_in_ms: u32
        round_time_in_ms = await read_int(reader, 4)

        return CMSG_PING(
            sequence_id=sequence_id,
            round_time_in_ms=round_time_in_ms,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01DC))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.sequence_id, self.round_time_in_ms])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PONG:
    sequence_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PONG:
        # sequence_id: u32
        sequence_id = await read_int(reader, 4)

        return SMSG_PONG(
            sequence_id=sequence_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01DD))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.sequence_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CLEAR_COOLDOWN:
    id: int
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CLEAR_COOLDOWN:
        # id: Spell
        id = await read_int(reader, 4)

        # target: Guid
        target = await read_int(reader, 8)

        return SMSG_CLEAR_COOLDOWN(
            id=id,
            target=target,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01DE))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.id, self.target])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GAMEOBJECT_PAGETEXT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GAMEOBJECT_PAGETEXT:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_GAMEOBJECT_PAGETEXT(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01DF))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SETSHEATHED:
    sheathed: SheathState

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SETSHEATHED:
        # sheathed: SheathState
        sheathed = SheathState(await read_int(reader, 4))

        return CMSG_SETSHEATHED(
            sheathed=sheathed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x01E0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.sheathed.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELL_DELAYED:
    guid: int
    delay_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELL_DELAYED:
        # guid: Guid
        guid = await read_int(reader, 8)

        # delay_time: u32
        delay_time = await read_int(reader, 4)

        return SMSG_SPELL_DELAYED(
            guid=guid,
            delay_time=delay_time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01E2))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.delay_time])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUEST_POI_QUERY:
    points_of_interests: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUEST_POI_QUERY:
        # amount_of_pois: u32
        amount_of_pois = await read_int(reader, 4)

        # points_of_interests: u32[amount_of_pois]
        points_of_interests = []
        for _ in range(0, amount_of_pois):
            points_of_interests.append(await read_int(reader, 4))

        return CMSG_QUEST_POI_QUERY(
            points_of_interests=points_of_interests,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x01E3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'I{len(self.points_of_interests)}I'
        _data.extend([len(self.points_of_interests), *self.points_of_interests])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + 4 * len(self.points_of_interests)


@dataclasses.dataclass
class SMSG_QUEST_POI_QUERY_RESPONSE:
    quests: typing.List[QuestPoiList]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUEST_POI_QUERY_RESPONSE:
        # amount_of_quests: u32
        amount_of_quests = await read_int(reader, 4)

        # quests: QuestPoiList[amount_of_quests]
        quests = []
        for _ in range(0, amount_of_quests):
            quests.append(await QuestPoiList.read(reader))

        return SMSG_QUEST_POI_QUERY_RESPONSE(
            quests=quests,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01E4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.quests))
        # quests: QuestPoiList[amount_of_quests]
        for i in self.quests:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + 8 * len(self.quests)


@dataclasses.dataclass
class SMSG_ITEM_TIME_UPDATE:
    guid: int
    duration: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_TIME_UPDATE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # duration: u32
        duration = await read_int(reader, 4)

        return SMSG_ITEM_TIME_UPDATE(
            guid=guid,
            duration=duration,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01EA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.duration])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_ENCHANT_TIME_UPDATE:
    item: int
    slot: int
    duration: int
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_ENCHANT_TIME_UPDATE:
        # item: Guid
        item = await read_int(reader, 8)

        # slot: u32
        slot = await read_int(reader, 4)

        # duration: u32
        duration = await read_int(reader, 4)

        # player: Guid
        player = await read_int(reader, 8)

        return SMSG_ITEM_ENCHANT_TIME_UPDATE(
            item=item,
            slot=slot,
            duration=duration,
            player=player,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(24 + 2, 0x01EB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIIQ'
        _data.extend([self.item, self.slot, self.duration, self.player])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AUTH_CHALLENGE:
    unknown1: int
    server_seed: int
    seed: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUTH_CHALLENGE:
        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # server_seed: u32
        server_seed = await read_int(reader, 4)

        # seed: u8[32]
        seed = []
        for _ in range(0, 32):
            seed.append(await read_int(reader, 1))

        return SMSG_AUTH_CHALLENGE(
            unknown1=unknown1,
            server_seed=server_seed,
            seed=seed,
        )

    def write_unencrypted(self, writer: typing.Union[asyncio.StreamWriter, bytearray]):
        _data = bytearray(4)
        struct.pack_into(">H", _data, 0, 40 + 2)
        struct.pack_into("<H", _data, 2, 0x01EC)
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'II{len(self.seed)}B'
        _data.extend([self.unknown1, self.server_seed, *self.seed])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUTH_SESSION:
    client_build: int
    login_server_id: int
    username: str
    login_server_type: int
    client_seed: int
    region_id: int
    battleground_id: int
    realm_id: int
    dos_response: int
    client_proof: typing.List[int]
    addon_info: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUTH_SESSION:
        _size = 0

        # client_build: u32
        client_build = await read_int(reader, 4)
        _size += 4

        # login_server_id: u32
        login_server_id = await read_int(reader, 4)
        _size += 4

        # username: CString
        username = await read_cstring(reader)
        _size += len(username) + 1

        # login_server_type: u32
        login_server_type = await read_int(reader, 4)
        _size += 4

        # client_seed: u32
        client_seed = await read_int(reader, 4)
        _size += 4

        # region_id: u32
        region_id = await read_int(reader, 4)
        _size += 4

        # battleground_id: u32
        battleground_id = await read_int(reader, 4)
        _size += 4

        # realm_id: u32
        realm_id = await read_int(reader, 4)
        _size += 4

        # dos_response: u64
        dos_response = await read_int(reader, 8)
        _size += 8

        # client_proof: u8[20]
        client_proof = []
        for _ in range(0, 20):
            client_proof.append(await read_int(reader, 1))
            _size += 1

        # addon_info: u8[-]
        # {d.name}_decompressed_size: u32
        _size += 4  # decompressed_size

        addon_info_decompressed_size = await read_int(reader, 4)
        addon_info_bytes = await reader.readexactly(body_size - _size)

        addon_info_reader = reader
        if len(addon_info_bytes) != 0:
            addon_info_bytes = zlib.decompress(addon_info_bytes, bufsize=addon_info_decompressed_size)
            addon_info_reader = asyncio.StreamReader()
            addon_info_reader.feed_data(addon_info_bytes)
            addon_info_reader.feed_eof()

        addon_info = []
        while not addon_info_reader.at_eof():
            addon_info.append(await read_int(addon_info_reader, 1))
            _size += 1

        return CMSG_AUTH_SESSION(
            client_build=client_build,
            login_server_id=login_server_id,
            username=username,
            login_server_type=login_server_type,
            client_seed=client_seed,
            region_id=region_id,
            battleground_id=battleground_id,
            realm_id=realm_id,
            dos_response=dos_response,
            client_proof=client_proof,
            addon_info=addon_info,
        )

    def write_unencrypted(self, writer: typing.Union[asyncio.StreamWriter, bytearray]):
        _data = bytearray(6)
        struct.pack_into(">H", _data, 0, self.size() + 4)
        struct.pack_into("<I", _data, 2, 0x01ED)
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'II{len(self.username)}sBIIIIIQ{len(self.client_proof)}B'
        _data.extend([self.client_build, self.login_server_id, self.username.encode('utf-8'), 0, self.login_server_type, self.client_seed, self.region_id, self.battleground_id, self.realm_id, self.dos_response, *self.client_proof])
        # addon_info: u8[-]
        _addon_info_fmt = ''
        _addon_info_data = []

        _addon_info_decompressed_size = 0
        if len(self.addon_info) != 0:
            _addon_info_fmt += f'{len(self.addon_info)}B'
            _addon_info_data.extend(self.addon_info)
            _addon_info_bytes = struct.pack(_addon_info_fmt, *_addon_info_data)
            _addon_info_decompressed_size = len(_addon_info_bytes)
            _addon_info_bytes = list(_addon_info_bytes)

            _fmt += 'I'
            _data.append(_addon_info_decompressed_size)

            _fmt += f'{len(_addon_info_bytes)}B'
            _data.extend(list(_addon_info_bytes))
        else:
            _fmt += 'I'
            _data.append(_addon_info_decompressed_size)


        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 57 + len(self.username)

        # addon_info: u8[-]
        _addon_info_fmt = ''
        _addon_info_data = []

        if len(self.addon_info) != 0:
            _addon_info_fmt += f'{len(self.addon_info)}B'
            _addon_info_data.extend(self.addon_info)
            _addon_info_bytes = struct.pack(_addon_info_fmt, *_addon_info_data)
            _size += len(_addon_info_bytes) + 4
        else:
            _size += 4

        return _size


@dataclasses.dataclass
class SMSG_AUTH_RESPONSE:
    result: WorldResult
    billing_time: typing.Optional[int] = None
    billing_flags: typing.Optional[BillingPlanFlags] = None
    billing_rested: typing.Optional[int] = None
    expansion: typing.Optional[Expansion] = None
    queue_position: typing.Optional[int] = None
    realm_has_free_character_migration: typing.Optional[bool] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUTH_RESPONSE:
        billing_time = None
        billing_flags = None
        billing_rested = None
        expansion = None
        queue_position = None
        realm_has_free_character_migration = None
        # result: WorldResult
        result = WorldResult(await read_int(reader, 1))

        if result == WorldResult.AUTH_OK:
            # billing_time: u32
            billing_time = await read_int(reader, 4)

            # billing_flags: BillingPlanFlags
            billing_flags = BillingPlanFlags(await read_int(reader, 1))

            # billing_rested: u32
            billing_rested = await read_int(reader, 4)

            # expansion: Expansion
            expansion = Expansion(await read_int(reader, 1))

        elif result == WorldResult.AUTH_WAIT_QUEUE:
            # queue_position: u32
            queue_position = await read_int(reader, 4)

            # realm_has_free_character_migration: Bool8
            realm_has_free_character_migration = await read_bool(reader, 1)

        return SMSG_AUTH_RESPONSE(
            result=result,
            billing_time=billing_time,
            billing_flags=billing_flags,
            billing_rested=billing_rested,
            expansion=expansion,
            queue_position=queue_position,
            realm_has_free_character_migration=realm_has_free_character_migration,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01EE))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        if self.result == WorldResult.AUTH_OK:
            _fmt += 'IBIB'
            _data.extend([self.billing_time, self.billing_flags.value, self.billing_rested, self.expansion.value])
        elif self.result == WorldResult.AUTH_WAIT_QUEUE:
            _fmt += 'IB'
            _data.extend([self.queue_position, self.realm_has_free_character_migration])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.result == WorldResult.AUTH_OK:
            _size += 10
        elif self.result == WorldResult.AUTH_WAIT_QUEUE:
            _size += 5

        return _size


@dataclasses.dataclass
class CMSG_PET_CAST_SPELL:
    guid: int
    cast_count: int
    id: int
    cast_flags: ClientCastFlags
    targets: SpellCastTargets
    elevation: typing.Optional[float] = None
    speed: typing.Optional[float] = None
    movement_data: typing.Optional[ClientMovementData] = None
    opcode: typing.Optional[int] = None
    movement: typing.Optional[int] = None
    info: typing.Optional[MovementInfo] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_CAST_SPELL:
        elevation = None
        speed = None
        movement_data = None
        opcode = None
        movement = None
        info = None
        # guid: Guid
        guid = await read_int(reader, 8)

        # cast_count: u8
        cast_count = await read_int(reader, 1)

        # id: Spell
        id = await read_int(reader, 4)

        # cast_flags: ClientCastFlags
        cast_flags = ClientCastFlags(await read_int(reader, 1))

        # targets: SpellCastTargets
        targets = await SpellCastTargets.read(reader)

        if cast_flags == ClientCastFlags.EXTRA:
            # elevation: f32
            elevation = await read_float(reader)

            # speed: f32
            speed = await read_float(reader)

            # movement_data: ClientMovementData
            movement_data = ClientMovementData(await read_int(reader, 1))

            if movement_data == ClientMovementData.PRESENT:
                # opcode: u32
                opcode = await read_int(reader, 4)

                # movement: PackedGuid
                movement = await read_packed_guid(reader)

                # info: MovementInfo
                info = await MovementInfo.read(reader)

        return CMSG_PET_CAST_SPELL(
            guid=guid,
            cast_count=cast_count,
            id=id,
            cast_flags=cast_flags,
            targets=targets,
            elevation=elevation,
            speed=speed,
            movement_data=movement_data,
            opcode=opcode,
            movement=movement,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x01F0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QBIB'
        _data.extend([self.guid, self.cast_count, self.id, self.cast_flags.value])
        # targets: SpellCastTargets
        _fmt, _data = self.targets.write(_fmt, _data)

        if self.cast_flags == ClientCastFlags.EXTRA:
            _fmt += 'ffB'
            _data.extend([self.elevation, self.speed, self.movement_data.value])
            if self.movement_data == ClientMovementData.PRESENT:
                _fmt += 'I'
                _data.append(self.opcode)
                # movement: PackedGuid
                _fmt, _data = packed_guid_write(self.movement, _fmt, _data)

                # info: MovementInfo
                _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 14 + self.targets.size()

        if self.cast_flags == ClientCastFlags.EXTRA:
            _size += 9

            if self.movement_data == ClientMovementData.PRESENT:
                _size += 4 + packed_guid_size(self.movement) + self.info.size()


        return _size


@dataclasses.dataclass
class MSG_SAVE_GUILD_EMBLEM_Client:
    vendor: int
    emblem_style: int
    emblem_color: int
    border_style: int
    border_color: int
    background_color: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_SAVE_GUILD_EMBLEM_Client:
        # vendor: Guid
        vendor = await read_int(reader, 8)

        # emblem_style: u32
        emblem_style = await read_int(reader, 4)

        # emblem_color: u32
        emblem_color = await read_int(reader, 4)

        # border_style: u32
        border_style = await read_int(reader, 4)

        # border_color: u32
        border_color = await read_int(reader, 4)

        # background_color: u32
        background_color = await read_int(reader, 4)

        return MSG_SAVE_GUILD_EMBLEM_Client(
            vendor=vendor,
            emblem_style=emblem_style,
            emblem_color=emblem_color,
            border_style=border_style,
            border_color=border_color,
            background_color=background_color,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(28 + 4, 0x01F1))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIIIII'
        _data.extend([self.vendor, self.emblem_style, self.emblem_color, self.border_style, self.border_color, self.background_color])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_SAVE_GUILD_EMBLEM_Server:
    result: GuildEmblemResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_SAVE_GUILD_EMBLEM_Server:
        # result: GuildEmblemResult
        result = GuildEmblemResult(await read_int(reader, 4))

        return MSG_SAVE_GUILD_EMBLEM_Server(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01F1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_TABARDVENDOR_ACTIVATE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_TABARDVENDOR_ACTIVATE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return MSG_TABARDVENDOR_ACTIVATE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01F2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01F2))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PLAY_SPELL_VISUAL:
    guid: int
    spell_art_kit: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAY_SPELL_VISUAL:
        # guid: Guid
        guid = await read_int(reader, 8)

        # spell_art_kit: u32
        spell_art_kit = await read_int(reader, 4)

        return SMSG_PLAY_SPELL_VISUAL(
            guid=guid,
            spell_art_kit=spell_art_kit,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01F3))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.spell_art_kit])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ZONEUPDATE:
    area: Area

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ZONEUPDATE:
        # area: Area
        area = Area(await read_int(reader, 4))

        return CMSG_ZONEUPDATE(
            area=area,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x01F4))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.area.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PARTYKILLLOG:
    player_with_killing_blow: int
    victim: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PARTYKILLLOG:
        # player_with_killing_blow: Guid
        player_with_killing_blow = await read_int(reader, 8)

        # victim: Guid
        victim = await read_int(reader, 8)

        return SMSG_PARTYKILLLOG(
            player_with_killing_blow=player_with_killing_blow,
            victim=victim,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x01F5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQ'
        _data.extend([self.player_with_killing_blow, self.victim])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_COMPRESSED_UPDATE_OBJECT:
    objects: typing.List[Object]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_COMPRESSED_UPDATE_OBJECT:
        decompressed_size = await read_int(reader, 4)
        compressed_bytes = await reader.readexactly(body_size - 4)
        decompressed_bytes = zlib.decompress(compressed_bytes, bufsize=decompressed_size)
        reader = asyncio.StreamReader()
        reader.feed_data(decompressed_bytes)
        reader.feed_eof()


        # amount_of_objects: u32
        amount_of_objects = await read_int(reader, 4)

        # objects: Object[amount_of_objects]
        objects = []
        for _ in range(0, amount_of_objects):
            objects.append(await Object.read(reader))

        return SMSG_COMPRESSED_UPDATE_OBJECT(
            objects=objects,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01F6))
        _fmt = "<4s"
        _data = [_data]

        _compressed_fmt = "<"
        _compressed_data = []

        _fmt += 'I'
        _data.append(len(self.objects))
        # objects: Object[amount_of_objects]
        for i in self.objects:
            _compressed_fmt, _compressed_data = i.write(_compressed_fmt, _compressed_data)

        _uncompressed_data = struct.pack(_compressed_fmt, *_compressed_data)
        _compressed_data = zlib.compress(_uncompressed_data)

        _fmt += 'I'
        _data.append(len(_uncompressed_data))

        _fmt += f'{len(_compressed_data)}s'
        _data.append(_compressed_data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _fmt = ''
        _data = []

        # amount_of_objects: u32
        _fmt += 'I'
        _data.append(len(self.objects))

        # objects: Object[amount_of_objects]
        for i in self.objects:
            _fmt, _data = i.write(_fmt, _data)

        _uncompressed_data = struct.pack(_fmt, *_data)
        _compressed_data = zlib.compress(_uncompressed_data)
        return len(_compressed_data) + 4


@dataclasses.dataclass
class SMSG_PLAY_SPELL_IMPACT:
    guid: int
    spell_visual_kit: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAY_SPELL_IMPACT:
        # guid: Guid
        guid = await read_int(reader, 8)

        # spell_visual_kit: u32
        spell_visual_kit = await read_int(reader, 4)

        return SMSG_PLAY_SPELL_IMPACT(
            guid=guid,
            spell_visual_kit=spell_visual_kit,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01F7))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.spell_visual_kit])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_EXPLORATION_EXPERIENCE:
    area: Area
    experience: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_EXPLORATION_EXPERIENCE:
        # area: Area
        area = Area(await read_int(reader, 4))

        # experience: u32
        experience = await read_int(reader, 4)

        return SMSG_EXPLORATION_EXPERIENCE(
            area=area,
            experience=experience,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01F8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.area.value, self.experience])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_RANDOM_ROLL_Client:
    minimum: int
    maximum: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RANDOM_ROLL_Client:
        # minimum: u32
        minimum = await read_int(reader, 4)

        # maximum: u32
        maximum = await read_int(reader, 4)

        return MSG_RANDOM_ROLL_Client(
            minimum=minimum,
            maximum=maximum,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01FB))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.minimum, self.maximum])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_RANDOM_ROLL_Server:
    minimum: int
    maximum: int
    actual_roll: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RANDOM_ROLL_Server:
        # minimum: u32
        minimum = await read_int(reader, 4)

        # maximum: u32
        maximum = await read_int(reader, 4)

        # actual_roll: u32
        actual_roll = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return MSG_RANDOM_ROLL_Server(
            minimum=minimum,
            maximum=maximum,
            actual_roll=actual_roll,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x01FB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIQ'
        _data.extend([self.minimum, self.maximum, self.actual_roll, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ENVIRONMENTAL_DAMAGE_LOG:
    guid: int
    damage_type: EnvironmentalDamageType
    damage: int
    absorb: int
    resist: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ENVIRONMENTAL_DAMAGE_LOG:
        # guid: Guid
        guid = await read_int(reader, 8)

        # damage_type: EnvironmentalDamageType
        damage_type = EnvironmentalDamageType(await read_int(reader, 1))

        # damage: u32
        damage = await read_int(reader, 4)

        # absorb: u32
        absorb = await read_int(reader, 4)

        # resist: u32
        resist = await read_int(reader, 4)

        return SMSG_ENVIRONMENTAL_DAMAGE_LOG(
            guid=guid,
            damage_type=damage_type,
            damage=damage,
            absorb=absorb,
            resist=resist,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(21 + 2, 0x01FC))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QBIII'
        _data.extend([self.guid, self.damage_type.value, self.damage, self.absorb, self.resist])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LFG_PLAYER_REWARD:
    random_dungeon_entry: int
    dungeon_finished_entry: int
    done: bool
    unknown1: int
    money_reward: int
    experience_reward: int
    unknown2: int
    unknown3: int
    rewards: typing.List[QuestGiverReward]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LFG_PLAYER_REWARD:
        # random_dungeon_entry: u32
        random_dungeon_entry = await read_int(reader, 4)

        # dungeon_finished_entry: u32
        dungeon_finished_entry = await read_int(reader, 4)

        # done: Bool8
        done = await read_bool(reader, 1)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # money_reward: Gold
        money_reward = await read_int(reader, 4)

        # experience_reward: u32
        experience_reward = await read_int(reader, 4)

        # unknown2: u32
        unknown2 = await read_int(reader, 4)

        # unknown3: u32
        unknown3 = await read_int(reader, 4)

        # amount_of_rewards: u8
        amount_of_rewards = await read_int(reader, 1)

        # rewards: QuestGiverReward[amount_of_rewards]
        rewards = []
        for _ in range(0, amount_of_rewards):
            rewards.append(await QuestGiverReward.read(reader))

        return SMSG_LFG_PLAYER_REWARD(
            random_dungeon_entry=random_dungeon_entry,
            dungeon_finished_entry=dungeon_finished_entry,
            done=done,
            unknown1=unknown1,
            money_reward=money_reward,
            experience_reward=experience_reward,
            unknown2=unknown2,
            unknown3=unknown3,
            rewards=rewards,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01FF))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIBIIIIIB'
        _data.extend([self.random_dungeon_entry, self.dungeon_finished_entry, self.done, self.unknown1, self.money_reward, self.experience_reward, self.unknown2, self.unknown3, len(self.rewards)])
        # rewards: QuestGiverReward[amount_of_rewards]
        for i in self.rewards:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 30 + 12 * len(self.rewards)


@dataclasses.dataclass
class SMSG_LFG_TELEPORT_DENIED:
    error: LfgTeleportError

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LFG_TELEPORT_DENIED:
        # error: LfgTeleportError
        error = LfgTeleportError(await read_int(reader, 4))

        return SMSG_LFG_TELEPORT_DENIED(
            error=error,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0200))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.error.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_UNLEARN_SKILL:
    skill: Skill

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_UNLEARN_SKILL:
        # skill: Skill
        skill = Skill(await read_int(reader, 4))

        return CMSG_UNLEARN_SKILL(
            skill=skill,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0202))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.skill.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_REMOVED_SPELL:
    spell: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_REMOVED_SPELL:
        # spell: Spell
        spell = await read_int(reader, 4)

        return SMSG_REMOVED_SPELL(
            spell=spell,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0203))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.spell)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GMTICKET_CREATE:
    map: Map
    position: Vector3d
    message: str
    needs_response: bool
    needs_more_help: bool
    times: typing.List[int]
    compressed_data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GMTICKET_CREATE:
        _size = 0

        # map: Map
        map = Map(await read_int(reader, 4))
        _size += 4

        # position: Vector3d
        position = await Vector3d.read(reader)
        _size += 12

        # message: CString
        message = await read_cstring(reader)
        _size += len(message) + 1

        # needs_response: Bool8
        needs_response = await read_bool(reader, 1)
        _size += 1

        # needs_more_help: Bool8
        needs_more_help = await read_bool(reader, 1)
        _size += 1

        # num_of_times: u32
        num_of_times = await read_int(reader, 4)
        _size += 4

        # times: u32[num_of_times]
        times = []
        for _ in range(0, num_of_times):
            times.append(await read_int(reader, 4))
            _size += 4

        # compressed_data: u8[-]
        # {d.name}_decompressed_size: u32
        _size += 4  # decompressed_size

        compressed_data_decompressed_size = await read_int(reader, 4)
        compressed_data_bytes = await reader.readexactly(body_size - _size)

        compressed_data_reader = reader
        if len(compressed_data_bytes) != 0:
            compressed_data_bytes = zlib.decompress(compressed_data_bytes, bufsize=compressed_data_decompressed_size)
            compressed_data_reader = asyncio.StreamReader()
            compressed_data_reader.feed_data(compressed_data_bytes)
            compressed_data_reader.feed_eof()

        compressed_data = []
        while not compressed_data_reader.at_eof():
            compressed_data.append(await read_int(compressed_data_reader, 1))
            _size += 1

        return CMSG_GMTICKET_CREATE(
            map=map,
            position=position,
            message=message,
            needs_response=needs_response,
            needs_more_help=needs_more_help,
            times=times,
            compressed_data=compressed_data,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0205))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # message: CString
        _fmt += f'{len(self.message)}sB'
        _data.extend([self.message.encode('utf-8'), 0])

        # needs_response: Bool8
        _fmt += 'B'
        _data.append(self.needs_response)

        # needs_more_help: Bool8
        _fmt += 'B'
        _data.append(self.needs_more_help)

        # num_of_times: u32
        _fmt += 'I'
        _data.append(len(self.times))

        # times: u32[num_of_times]
        _fmt += f'{len(self.times)}I'
        _data.extend([*self.times])

        # compressed_data: u8[-]
        _compressed_data_fmt = ''
        _compressed_data_data = []

        _compressed_data_decompressed_size = 0
        if len(self.compressed_data) != 0:
            _compressed_data_fmt += f'{len(self.compressed_data)}B'
            _compressed_data_data.extend(self.compressed_data)
            _compressed_data_bytes = struct.pack(_compressed_data_fmt, *_compressed_data_data)
            _compressed_data_decompressed_size = len(_compressed_data_bytes)
            _compressed_data_bytes = list(_compressed_data_bytes)

            _fmt += 'I'
            _data.append(_compressed_data_decompressed_size)

            _fmt += f'{len(_compressed_data_bytes)}B'
            _data.extend(list(_compressed_data_bytes))
        else:
            _fmt += 'I'
            _data.append(_compressed_data_decompressed_size)


        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 23 + len(self.message) + 4 * len(self.times)

        # compressed_data: u8[-]
        _compressed_data_fmt = ''
        _compressed_data_data = []

        if len(self.compressed_data) != 0:
            _compressed_data_fmt += f'{len(self.compressed_data)}B'
            _compressed_data_data.extend(self.compressed_data)
            _compressed_data_bytes = struct.pack(_compressed_data_fmt, *_compressed_data_data)
            _size += len(_compressed_data_bytes) + 4
        else:
            _size += 4

        return _size


@dataclasses.dataclass
class SMSG_GMTICKET_CREATE:
    response: GmTicketResponse

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GMTICKET_CREATE:
        # response: GmTicketResponse
        response = GmTicketResponse(await read_int(reader, 4))

        return SMSG_GMTICKET_CREATE(
            response=response,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0206))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.response.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GMTICKET_UPDATETEXT:
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GMTICKET_UPDATETEXT:
        # message: CString
        message = await read_cstring(reader)

        return CMSG_GMTICKET_UPDATETEXT(
            message=message,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0207))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.message)}sB'
        _data.extend([self.message.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.message)


@dataclasses.dataclass
class SMSG_GMTICKET_UPDATETEXT:
    response: GmTicketResponse

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GMTICKET_UPDATETEXT:
        # response: GmTicketResponse
        response = GmTicketResponse(await read_int(reader, 4))

        return SMSG_GMTICKET_UPDATETEXT(
            response=response,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0208))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.response.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ACCOUNT_DATA_TIMES:
    unix_time: int
    unknown1: int
    mask: CacheMask

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ACCOUNT_DATA_TIMES:
        # unix_time: u32
        unix_time = await read_int(reader, 4)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # mask: CacheMask
        mask = await CacheMask.read(reader)

        return SMSG_ACCOUNT_DATA_TIMES(
            unix_time=unix_time,
            unknown1=unknown1,
            mask=mask,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0209))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([self.unix_time, self.unknown1])
        # mask: CacheMask
        _fmt, _data = self.mask.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + self.mask.size()


@dataclasses.dataclass
class CMSG_REQUEST_ACCOUNT_DATA:
    data_type: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REQUEST_ACCOUNT_DATA:
        # data_type: u32
        data_type = await read_int(reader, 4)

        return CMSG_REQUEST_ACCOUNT_DATA(
            data_type=data_type,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x020A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.data_type)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_UPDATE_ACCOUNT_DATA:
    data_type: int
    unix_time: int
    compressed_data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_UPDATE_ACCOUNT_DATA:
        _size = 0

        # data_type: u32
        data_type = await read_int(reader, 4)
        _size += 4

        # unix_time: u32
        unix_time = await read_int(reader, 4)
        _size += 4

        # compressed_data: u8[-]
        # {d.name}_decompressed_size: u32
        _size += 4  # decompressed_size

        compressed_data_decompressed_size = await read_int(reader, 4)
        compressed_data_bytes = await reader.readexactly(body_size - _size)

        compressed_data_reader = reader
        if len(compressed_data_bytes) != 0:
            compressed_data_bytes = zlib.decompress(compressed_data_bytes, bufsize=compressed_data_decompressed_size)
            compressed_data_reader = asyncio.StreamReader()
            compressed_data_reader.feed_data(compressed_data_bytes)
            compressed_data_reader.feed_eof()

        compressed_data = []
        while not compressed_data_reader.at_eof():
            compressed_data.append(await read_int(compressed_data_reader, 1))
            _size += 1

        return CMSG_UPDATE_ACCOUNT_DATA(
            data_type=data_type,
            unix_time=unix_time,
            compressed_data=compressed_data,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x020B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.data_type, self.unix_time])
        # compressed_data: u8[-]
        _compressed_data_fmt = ''
        _compressed_data_data = []

        _compressed_data_decompressed_size = 0
        if len(self.compressed_data) != 0:
            _compressed_data_fmt += f'{len(self.compressed_data)}B'
            _compressed_data_data.extend(self.compressed_data)
            _compressed_data_bytes = struct.pack(_compressed_data_fmt, *_compressed_data_data)
            _compressed_data_decompressed_size = len(_compressed_data_bytes)
            _compressed_data_bytes = list(_compressed_data_bytes)

            _fmt += 'I'
            _data.append(_compressed_data_decompressed_size)

            _fmt += f'{len(_compressed_data_bytes)}B'
            _data.extend(list(_compressed_data_bytes))
        else:
            _fmt += 'I'
            _data.append(_compressed_data_decompressed_size)


        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 8

        # compressed_data: u8[-]
        _compressed_data_fmt = ''
        _compressed_data_data = []

        if len(self.compressed_data) != 0:
            _compressed_data_fmt += f'{len(self.compressed_data)}B'
            _compressed_data_data.extend(self.compressed_data)
            _compressed_data_bytes = struct.pack(_compressed_data_fmt, *_compressed_data_data)
            _size += len(_compressed_data_bytes) + 4
        else:
            _size += 4

        return _size


@dataclasses.dataclass
class SMSG_UPDATE_ACCOUNT_DATA:
    data_type: int
    decompressed_size: int
    compressed_data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_UPDATE_ACCOUNT_DATA:
        _size = 0

        # data_type: u32
        data_type = await read_int(reader, 4)
        _size += 4

        # decompressed_size: u32
        decompressed_size = await read_int(reader, 4)
        _size += 4

        # compressed_data: u8[-]
        compressed_data = []
        while _size < body_size:
            compressed_data.append(await read_int(reader, 1))
            _size += 1

        return SMSG_UPDATE_ACCOUNT_DATA(
            data_type=data_type,
            decompressed_size=decompressed_size,
            compressed_data=compressed_data,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x020C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'II{len(self.compressed_data)}B'
        _data.extend([self.data_type, self.decompressed_size, *self.compressed_data])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + 1 * len(self.compressed_data)


@dataclasses.dataclass
class CMSG_GMTICKET_GETTICKET:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GMTICKET_GETTICKET:
        return CMSG_GMTICKET_GETTICKET()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0211))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GMTICKET_GETTICKET:
    status: GmTicketStatus
    id: typing.Optional[int] = None
    text: typing.Optional[str] = None
    need_more_help: typing.Optional[bool] = None
    days_since_ticket_creation: typing.Optional[float] = None
    days_since_oldest_ticket_creation: typing.Optional[float] = None
    days_since_last_updated: typing.Optional[float] = None
    escalation_status: typing.Optional[GmTicketEscalationStatus] = None
    read_by_gm: typing.Optional[bool] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GMTICKET_GETTICKET:
        id = None
        text = None
        need_more_help = None
        days_since_ticket_creation = None
        days_since_oldest_ticket_creation = None
        days_since_last_updated = None
        escalation_status = None
        read_by_gm = None
        # status: GmTicketStatus
        status = GmTicketStatus(await read_int(reader, 4))

        if status == GmTicketStatus.HAS_TEXT:
            # id: u32
            id = await read_int(reader, 4)

            # text: CString
            text = await read_cstring(reader)

            # need_more_help: Bool8
            need_more_help = await read_bool(reader, 1)

            # days_since_ticket_creation: f32
            days_since_ticket_creation = await read_float(reader)

            # days_since_oldest_ticket_creation: f32
            days_since_oldest_ticket_creation = await read_float(reader)

            # days_since_last_updated: f32
            days_since_last_updated = await read_float(reader)

            # escalation_status: GmTicketEscalationStatus
            escalation_status = GmTicketEscalationStatus(await read_int(reader, 1))

            # read_by_gm: Bool8
            read_by_gm = await read_bool(reader, 1)

        return SMSG_GMTICKET_GETTICKET(
            status=status,
            id=id,
            text=text,
            need_more_help=need_more_help,
            days_since_ticket_creation=days_since_ticket_creation,
            days_since_oldest_ticket_creation=days_since_oldest_ticket_creation,
            days_since_last_updated=days_since_last_updated,
            escalation_status=escalation_status,
            read_by_gm=read_by_gm,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0212))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.status.value)
        if self.status == GmTicketStatus.HAS_TEXT:
            _fmt += f'I{len(self.text)}sBBfffBB'
            _data.extend([self.id, self.text.encode('utf-8'), 0, self.need_more_help, self.days_since_ticket_creation, self.days_since_oldest_ticket_creation, self.days_since_last_updated, self.escalation_status.value, self.read_by_gm])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        if self.status == GmTicketStatus.HAS_TEXT:
            _size += 20 + len(self.text)

        return _size


@dataclasses.dataclass
class CMSG_UNLEARN_TALENTS:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_UNLEARN_TALENTS:
        return CMSG_UNLEARN_TALENTS()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0213))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_UPDATE_INSTANCE_ENCOUNTER_UNIT:
    frame: EncounterFrame
    guid: typing.Optional[int] = None
    parameter1: typing.Optional[int] = None
    parameter2: typing.Optional[int] = None
    parameter3: typing.Optional[int] = None
    parameter4: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_UPDATE_INSTANCE_ENCOUNTER_UNIT:
        guid = None
        parameter1 = None
        parameter2 = None
        parameter3 = None
        parameter4 = None
        # frame: EncounterFrame
        frame = EncounterFrame(await read_int(reader, 4))

        if frame in {EncounterFrame.ENGAGE, EncounterFrame.DISENGAGE, EncounterFrame.UPDATE_PRIORITY}:
            # guid: PackedGuid
            guid = await read_packed_guid(reader)

            # parameter1: u8
            parameter1 = await read_int(reader, 1)

        elif frame in {EncounterFrame.ADD_TIMER, EncounterFrame.ENABLE_OBJECTIVE, EncounterFrame.DISABLE_OBJECTIVE}:
            # parameter2: u8
            parameter2 = await read_int(reader, 1)

        elif frame == EncounterFrame.UPDATE_OBJECTIVE:
            # parameter3: u8
            parameter3 = await read_int(reader, 1)

            # parameter4: u8
            parameter4 = await read_int(reader, 1)

        return SMSG_UPDATE_INSTANCE_ENCOUNTER_UNIT(
            frame=frame,
            guid=guid,
            parameter1=parameter1,
            parameter2=parameter2,
            parameter3=parameter3,
            parameter4=parameter4,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0214))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.frame.value)
        if self.frame in {EncounterFrame.ENGAGE, EncounterFrame.DISENGAGE, EncounterFrame.UPDATE_PRIORITY}:
            # guid: PackedGuid
            _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

            # parameter1: u8
            _fmt += 'B'
            _data.append(self.parameter1)

        elif self.frame in {EncounterFrame.ADD_TIMER, EncounterFrame.ENABLE_OBJECTIVE, EncounterFrame.DISABLE_OBJECTIVE}:
            _fmt += 'B'
            _data.append(self.parameter2)
        elif self.frame == EncounterFrame.UPDATE_OBJECTIVE:
            _fmt += 'BB'
            _data.extend([self.parameter3, self.parameter4])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        if self.frame in {EncounterFrame.ENGAGE, EncounterFrame.DISENGAGE, EncounterFrame.UPDATE_PRIORITY}:
            _size += 1 + packed_guid_size(self.guid)
        elif self.frame in {EncounterFrame.ADD_TIMER, EncounterFrame.ENABLE_OBJECTIVE, EncounterFrame.DISABLE_OBJECTIVE}:
            _size += 1
        elif self.frame == EncounterFrame.UPDATE_OBJECTIVE:
            _size += 2

        return _size


@dataclasses.dataclass
class SMSG_GAMEOBJECT_DESPAWN_ANIM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GAMEOBJECT_DESPAWN_ANIM:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_GAMEOBJECT_DESPAWN_ANIM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0215))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_CORPSE_QUERY_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_CORPSE_QUERY_Client:
        return MSG_CORPSE_QUERY_Client()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0216))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_CORPSE_QUERY_Server:
    result: CorpseQueryResult
    unknown: int
    map: typing.Optional[Map] = None
    position: typing.Optional[Vector3d] = None
    corpse_map: typing.Optional[Map] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_CORPSE_QUERY_Server:
        map = None
        position = None
        corpse_map = None
        # result: CorpseQueryResult
        result = CorpseQueryResult(await read_int(reader, 1))

        if result == CorpseQueryResult.FOUND:
            # map: Map
            map = Map(await read_int(reader, 4))

            # position: Vector3d
            position = await Vector3d.read(reader)

            # corpse_map: Map
            corpse_map = Map(await read_int(reader, 4))

        # unknown: u32
        unknown = await read_int(reader, 4)

        return MSG_CORPSE_QUERY_Server(
            result=result,
            map=map,
            position=position,
            corpse_map=corpse_map,
            unknown=unknown,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0216))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        if self.result == CorpseQueryResult.FOUND:
            _fmt += 'I'
            _data.append(self.map.value)
            # position: Vector3d
            _fmt, _data = self.position.write(_fmt, _data)

            # corpse_map: Map
            _fmt += 'I'
            _data.append(self.corpse_map.value)

        # unknown: u32
        _fmt += 'I'
        _data.append(self.unknown)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 5

        if self.result == CorpseQueryResult.FOUND:
            _size += 20

        return _size


@dataclasses.dataclass
class CMSG_GMTICKET_DELETETICKET:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GMTICKET_DELETETICKET:
        return CMSG_GMTICKET_DELETETICKET()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0217))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GMTICKET_DELETETICKET:
    response: GmTicketResponse

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GMTICKET_DELETETICKET:
        # response: GmTicketResponse
        response = GmTicketResponse(await read_int(reader, 4))

        return SMSG_GMTICKET_DELETETICKET(
            response=response,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0218))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.response.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CHAT_WRONG_FACTION:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAT_WRONG_FACTION:
        return SMSG_CHAT_WRONG_FACTION()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0219))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GMTICKET_SYSTEMSTATUS:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GMTICKET_SYSTEMSTATUS:
        return CMSG_GMTICKET_SYSTEMSTATUS()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x021A))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GMTICKET_SYSTEMSTATUS:
    will_accept_tickets: GmTicketQueueStatus

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GMTICKET_SYSTEMSTATUS:
        # will_accept_tickets: GmTicketQueueStatus
        will_accept_tickets = GmTicketQueueStatus(await read_int(reader, 4))

        return SMSG_GMTICKET_SYSTEMSTATUS(
            will_accept_tickets=will_accept_tickets,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x021B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.will_accept_tickets.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SPIRIT_HEALER_ACTIVATE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SPIRIT_HEALER_ACTIVATE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_SPIRIT_HEALER_ACTIVATE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x021C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUEST_FORCE_REMOVE:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUEST_FORCE_REMOVE:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return SMSG_QUEST_FORCE_REMOVE(
            quest_id=quest_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x021E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.quest_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPIRIT_HEALER_CONFIRM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPIRIT_HEALER_CONFIRM:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_SPIRIT_HEALER_CONFIRM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0222))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GOSSIP_POI:
    flags: int
    position: Vector2d
    icon: int
    data: int
    location_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GOSSIP_POI:
        # flags: u32
        flags = await read_int(reader, 4)

        # position: Vector2d
        position = await Vector2d.read(reader)

        # icon: u32
        icon = await read_int(reader, 4)

        # data: u32
        data = await read_int(reader, 4)

        # location_name: CString
        location_name = await read_cstring(reader)

        return SMSG_GOSSIP_POI(
            flags=flags,
            position=position,
            icon=icon,
            data=data,
            location_name=location_name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0224))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.flags)
        # position: Vector2d
        _fmt, _data = self.position.write(_fmt, _data)

        # icon: u32
        _fmt += 'I'
        _data.append(self.icon)

        # data: u32
        _fmt += 'I'
        _data.append(self.data)

        # location_name: CString
        _fmt += f'{len(self.location_name)}sB'
        _data.extend([self.location_name.encode('utf-8'), 0])

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 21 + len(self.location_name)


@dataclasses.dataclass
class CMSG_CHAT_IGNORED:
    guid: int
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHAT_IGNORED:
        # guid: Guid
        guid = await read_int(reader, 8)

        # unknown: u8
        unknown = await read_int(reader, 1)

        return CMSG_CHAT_IGNORED(
            guid=guid,
            unknown=unknown,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x0225))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.unknown])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_RANK:
    rank_id: int
    rights: int
    rank_name: str
    money_per_day: int
    bank_tab_rights: typing.List[GuildBankRights]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_RANK:
        # rank_id: u32
        rank_id = await read_int(reader, 4)

        # rights: u32
        rights = await read_int(reader, 4)

        # rank_name: CString
        rank_name = await read_cstring(reader)

        # money_per_day: Gold
        money_per_day = await read_int(reader, 4)

        # bank_tab_rights: GuildBankRights[6]
        bank_tab_rights = []
        for _ in range(0, 6):
            bank_tab_rights.append(await GuildBankRights.read(reader))

        return CMSG_GUILD_RANK(
            rank_id=rank_id,
            rights=rights,
            rank_name=rank_name,
            money_per_day=money_per_day,
            bank_tab_rights=bank_tab_rights,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0231))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'II{len(self.rank_name)}sBI'
        _data.extend([self.rank_id, self.rights, self.rank_name.encode('utf-8'), 0, self.money_per_day])
        # bank_tab_rights: GuildBankRights[6]
        for i in self.bank_tab_rights:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 61 + len(self.rank_name)


@dataclasses.dataclass
class CMSG_GUILD_ADD_RANK:
    rank_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_ADD_RANK:
        # rank_name: CString
        rank_name = await read_cstring(reader)

        return CMSG_GUILD_ADD_RANK(
            rank_name=rank_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0232))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.rank_name)}sB'
        _data.extend([self.rank_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.rank_name)


@dataclasses.dataclass
class CMSG_GUILD_DEL_RANK:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_DEL_RANK:
        return CMSG_GUILD_DEL_RANK()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0233))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_SET_PUBLIC_NOTE:
    player_name: str
    note: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_SET_PUBLIC_NOTE:
        # player_name: CString
        player_name = await read_cstring(reader)

        # note: CString
        note = await read_cstring(reader)

        return CMSG_GUILD_SET_PUBLIC_NOTE(
            player_name=player_name,
            note=note,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0234))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.player_name)}sB{len(self.note)}sB'
        _data.extend([self.player_name.encode('utf-8'), 0, self.note.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.player_name) + len(self.note)


@dataclasses.dataclass
class CMSG_GUILD_SET_OFFICER_NOTE:
    player_name: str
    note: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_SET_OFFICER_NOTE:
        # player_name: CString
        player_name = await read_cstring(reader)

        # note: CString
        note = await read_cstring(reader)

        return CMSG_GUILD_SET_OFFICER_NOTE(
            player_name=player_name,
            note=note,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0235))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.player_name)}sB{len(self.note)}sB'
        _data.extend([self.player_name.encode('utf-8'), 0, self.note.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.player_name) + len(self.note)


@dataclasses.dataclass
class SMSG_LOGIN_VERIFY_WORLD:
    map: Map
    position: Vector3d
    orientation: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOGIN_VERIFY_WORLD:
        # map: Map
        map = Map(await read_int(reader, 4))

        # position: Vector3d
        position = await Vector3d.read(reader)

        # orientation: f32
        orientation = await read_float(reader)

        return SMSG_LOGIN_VERIFY_WORLD(
            map=map,
            position=position,
            orientation=orientation,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x0236))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # orientation: f32
        _fmt += 'f'
        _data.append(self.orientation)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SEND_MAIL:
    mailbox: int
    receiver: str
    subject: str
    body: str
    unknown1: int
    unknown2: int
    items: typing.List[MailItem]
    money: int
    cash_on_delivery_amount: int
    unknown3: int
    unknown4: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SEND_MAIL:
        # mailbox: Guid
        mailbox = await read_int(reader, 8)

        # receiver: CString
        receiver = await read_cstring(reader)

        # subject: CString
        subject = await read_cstring(reader)

        # body: CString
        body = await read_cstring(reader)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # unknown2: u32
        unknown2 = await read_int(reader, 4)

        # amount_of_items: u8
        amount_of_items = await read_int(reader, 1)

        # items: MailItem[amount_of_items]
        items = []
        for _ in range(0, amount_of_items):
            items.append(await MailItem.read(reader))

        # money: Gold
        money = await read_int(reader, 4)

        # cash_on_delivery_amount: u32
        cash_on_delivery_amount = await read_int(reader, 4)

        # unknown3: u32
        unknown3 = await read_int(reader, 4)

        # unknown4: u32
        unknown4 = await read_int(reader, 4)

        return CMSG_SEND_MAIL(
            mailbox=mailbox,
            receiver=receiver,
            subject=subject,
            body=body,
            unknown1=unknown1,
            unknown2=unknown2,
            items=items,
            money=money,
            cash_on_delivery_amount=cash_on_delivery_amount,
            unknown3=unknown3,
            unknown4=unknown4,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0238))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.receiver)}sB{len(self.subject)}sB{len(self.body)}sBIIB'
        _data.extend([self.mailbox, self.receiver.encode('utf-8'), 0, self.subject.encode('utf-8'), 0, self.body.encode('utf-8'), 0, self.unknown1, self.unknown2, len(self.items)])
        # items: MailItem[amount_of_items]
        for i in self.items:
            _fmt, _data = i.write(_fmt, _data)

        # money: Gold
        _fmt += 'I'
        _data.append(self.money)

        # cash_on_delivery_amount: u32
        _fmt += 'I'
        _data.append(self.cash_on_delivery_amount)

        # unknown3: u32
        _fmt += 'I'
        _data.append(self.unknown3)

        # unknown4: u32
        _fmt += 'I'
        _data.append(self.unknown4)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 36 + len(self.receiver) + len(self.subject) + len(self.body) + 9 * len(self.items)


@dataclasses.dataclass
class SMSG_SEND_MAIL_RESULT:
    mail_id: int
    action: MailAction
    result: typing.Optional[MailResult] = None
    equip_error: typing.Optional[int] = None
    item: typing.Optional[int] = None
    item_count: typing.Optional[int] = None
    result2: typing.Optional[MailResultTwo] = None
    equip_error2: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SEND_MAIL_RESULT:
        result = None
        equip_error = None
        item = None
        item_count = None
        result2 = None
        equip_error2 = None
        # mail_id: u32
        mail_id = await read_int(reader, 4)

        # action: MailAction
        action = MailAction(await read_int(reader, 4))

        if action == MailAction.ITEM_TAKEN:
            # result: MailResult
            result = MailResult(await read_int(reader, 4))

            if result == MailResult.ERR_EQUIP_ERROR:
                # equip_error: u32
                equip_error = await read_int(reader, 4)

            elif result in {MailResult.OK, MailResult.ERR_CANNOT_SEND_TO_SELF, MailResult.ERR_NOT_ENOUGH_MONEY, MailResult.ERR_RECIPIENT_NOT_FOUND, MailResult.ERR_NOT_YOUR_TEAM, MailResult.ERR_INTERNAL_ERROR, MailResult.ERR_DISABLED_FOR_TRIAL_ACC, MailResult.ERR_RECIPIENT_CAP_REACHED, MailResult.ERR_CANT_SEND_WRAPPED_COD, MailResult.ERR_MAIL_AND_CHAT_SUSPENDED, MailResult.ERR_TOO_MANY_ATTACHMENTS, MailResult.ERR_MAIL_ATTACHMENT_INVALID, MailResult.ERR_ITEM_HAS_EXPIRED}:
                # item: Item
                item = await read_int(reader, 4)

                # item_count: u32
                item_count = await read_int(reader, 4)

        elif action in {MailAction.SEND, MailAction.MONEY_TAKEN, MailAction.RETURNED_TO_SENDER, MailAction.DELETED, MailAction.MADE_PERMANENT}:
            # result2: MailResultTwo
            result2 = MailResultTwo(await read_int(reader, 4))

            if result2 == MailResultTwo.ERR_EQUIP_ERROR:
                # equip_error2: u32
                equip_error2 = await read_int(reader, 4)

        return SMSG_SEND_MAIL_RESULT(
            mail_id=mail_id,
            action=action,
            result=result,
            equip_error=equip_error,
            item=item,
            item_count=item_count,
            result2=result2,
            equip_error2=equip_error2,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0239))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.mail_id, self.action.value])
        if self.action == MailAction.ITEM_TAKEN:
            _fmt += 'I'
            _data.append(self.result.value)
            if self.result == MailResult.ERR_EQUIP_ERROR:
                _fmt += 'I'
                _data.append(self.equip_error)
            elif self.result in {MailResult.OK, MailResult.ERR_CANNOT_SEND_TO_SELF, MailResult.ERR_NOT_ENOUGH_MONEY, MailResult.ERR_RECIPIENT_NOT_FOUND, MailResult.ERR_NOT_YOUR_TEAM, MailResult.ERR_INTERNAL_ERROR, MailResult.ERR_DISABLED_FOR_TRIAL_ACC, MailResult.ERR_RECIPIENT_CAP_REACHED, MailResult.ERR_CANT_SEND_WRAPPED_COD, MailResult.ERR_MAIL_AND_CHAT_SUSPENDED, MailResult.ERR_TOO_MANY_ATTACHMENTS, MailResult.ERR_MAIL_ATTACHMENT_INVALID, MailResult.ERR_ITEM_HAS_EXPIRED}:
                _fmt += 'II'
                _data.extend([self.item, self.item_count])
        elif self.action in {MailAction.SEND, MailAction.MONEY_TAKEN, MailAction.RETURNED_TO_SENDER, MailAction.DELETED, MailAction.MADE_PERMANENT}:
            _fmt += 'I'
            _data.append(self.result2.value)
            if self.result2 == MailResultTwo.ERR_EQUIP_ERROR:
                _fmt += 'I'
                _data.append(self.equip_error2)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 8

        if self.action == MailAction.ITEM_TAKEN:
            _size += 4

            if self.result == MailResult.ERR_EQUIP_ERROR:
                _size += 4
            elif self.result in {MailResult.OK, MailResult.ERR_CANNOT_SEND_TO_SELF, MailResult.ERR_NOT_ENOUGH_MONEY, MailResult.ERR_RECIPIENT_NOT_FOUND, MailResult.ERR_NOT_YOUR_TEAM, MailResult.ERR_INTERNAL_ERROR, MailResult.ERR_DISABLED_FOR_TRIAL_ACC, MailResult.ERR_RECIPIENT_CAP_REACHED, MailResult.ERR_CANT_SEND_WRAPPED_COD, MailResult.ERR_MAIL_AND_CHAT_SUSPENDED, MailResult.ERR_TOO_MANY_ATTACHMENTS, MailResult.ERR_MAIL_ATTACHMENT_INVALID, MailResult.ERR_ITEM_HAS_EXPIRED}:
                _size += 8

        elif self.action in {MailAction.SEND, MailAction.MONEY_TAKEN, MailAction.RETURNED_TO_SENDER, MailAction.DELETED, MailAction.MADE_PERMANENT}:
            _size += 4

            if self.result2 == MailResultTwo.ERR_EQUIP_ERROR:
                _size += 4


        return _size


@dataclasses.dataclass
class CMSG_GET_MAIL_LIST:
    mailbox: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GET_MAIL_LIST:
        # mailbox: Guid
        mailbox = await read_int(reader, 8)

        return CMSG_GET_MAIL_LIST(
            mailbox=mailbox,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x023A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.mailbox)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MAIL_LIST_RESULT:
    real_mail_amount: int
    mails: typing.List[Mail]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MAIL_LIST_RESULT:
        # real_mail_amount: u32
        real_mail_amount = await read_int(reader, 4)

        # amount_of_mails: u8
        amount_of_mails = await read_int(reader, 1)

        # mails: Mail[amount_of_mails]
        mails = []
        for _ in range(0, amount_of_mails):
            mails.append(await Mail.read(reader))

        return SMSG_MAIL_LIST_RESULT(
            real_mail_amount=real_mail_amount,
            mails=mails,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x023B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([self.real_mail_amount, len(self.mails)])
        # mails: Mail[amount_of_mails]
        for i in self.mails:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + sum([i.size() for i in self.mails])


@dataclasses.dataclass
class CMSG_BATTLEFIELD_LIST:
    battleground_type: BattlegroundType
    location: BattlefieldListLocation
    can_gain_exp: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BATTLEFIELD_LIST:
        # battleground_type: BattlegroundType
        battleground_type = BattlegroundType(await read_int(reader, 4))

        # location: BattlefieldListLocation
        location = BattlefieldListLocation(await read_int(reader, 1))

        # can_gain_exp: Bool8
        can_gain_exp = await read_bool(reader, 1)

        return CMSG_BATTLEFIELD_LIST(
            battleground_type=battleground_type,
            location=location,
            can_gain_exp=can_gain_exp,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(6 + 4, 0x023C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IBB'
        _data.extend([self.battleground_type.value, self.location.value, self.can_gain_exp])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BATTLEFIELD_LIST:
    battlemaster: int
    battleground_type: BattlegroundType
    unknown1: int
    unknown2: int
    has_win: int
    win_honor: int
    win_arena: int
    loss_honor: int
    random: RandomBg
    battlegrounds: typing.List[int]
    win_random: typing.Optional[int] = None
    reward_honor: typing.Optional[int] = None
    reward_arena: typing.Optional[int] = None
    honor_lost: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BATTLEFIELD_LIST:
        win_random = None
        reward_honor = None
        reward_arena = None
        honor_lost = None
        # battlemaster: Guid
        battlemaster = await read_int(reader, 8)

        # battleground_type: BattlegroundType
        battleground_type = BattlegroundType(await read_int(reader, 4))

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # unknown2: u8
        unknown2 = await read_int(reader, 1)

        # has_win: u8
        has_win = await read_int(reader, 1)

        # win_honor: u32
        win_honor = await read_int(reader, 4)

        # win_arena: u32
        win_arena = await read_int(reader, 4)

        # loss_honor: u32
        loss_honor = await read_int(reader, 4)

        # random: RandomBg
        random = RandomBg(await read_int(reader, 1))

        if random == RandomBg.RANDOM:
            # win_random: u8
            win_random = await read_int(reader, 1)

            # reward_honor: u32
            reward_honor = await read_int(reader, 4)

            # reward_arena: u32
            reward_arena = await read_int(reader, 4)

            # honor_lost: u32
            honor_lost = await read_int(reader, 4)

        # number_of_battlegrounds: u32
        number_of_battlegrounds = await read_int(reader, 4)

        # battlegrounds: u32[number_of_battlegrounds]
        battlegrounds = []
        for _ in range(0, number_of_battlegrounds):
            battlegrounds.append(await read_int(reader, 4))

        return SMSG_BATTLEFIELD_LIST(
            battlemaster=battlemaster,
            battleground_type=battleground_type,
            unknown1=unknown1,
            unknown2=unknown2,
            has_win=has_win,
            win_honor=win_honor,
            win_arena=win_arena,
            loss_honor=loss_honor,
            random=random,
            win_random=win_random,
            reward_honor=reward_honor,
            reward_arena=reward_arena,
            honor_lost=honor_lost,
            battlegrounds=battlegrounds,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x023D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIBBBIIIB'
        _data.extend([self.battlemaster, self.battleground_type.value, self.unknown1, self.unknown2, self.has_win, self.win_honor, self.win_arena, self.loss_honor, self.random.value])
        if self.random == RandomBg.RANDOM:
            _fmt += 'BIII'
            _data.extend([self.win_random, self.reward_honor, self.reward_arena, self.honor_lost])
        # number_of_battlegrounds: u32
        _fmt += 'I'
        _data.append(len(self.battlegrounds))

        # battlegrounds: u32[number_of_battlegrounds]
        _fmt += f'{len(self.battlegrounds)}I'
        _data.extend([*self.battlegrounds])

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 32 + 4 * len(self.battlegrounds)

        if self.random == RandomBg.RANDOM:
            _size += 13

        return _size


@dataclasses.dataclass
class CMSG_ITEM_TEXT_QUERY:
    item: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ITEM_TEXT_QUERY:
        # item: Guid
        item = await read_int(reader, 8)

        return CMSG_ITEM_TEXT_QUERY(
            item=item,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0243))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.item)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_TEXT_QUERY_RESPONSE:
    query: ItemTextQuery
    item: typing.Optional[int] = None
    text: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_TEXT_QUERY_RESPONSE:
        item = None
        text = None
        # query: ItemTextQuery
        query = ItemTextQuery(await read_int(reader, 1))

        if query == ItemTextQuery.HAS_TEXT:
            # item: Guid
            item = await read_int(reader, 8)

            # text: CString
            text = await read_cstring(reader)

        return SMSG_ITEM_TEXT_QUERY_RESPONSE(
            query=query,
            item=item,
            text=text,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0244))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.query.value)
        if self.query == ItemTextQuery.HAS_TEXT:
            _fmt += f'Q{len(self.text)}sB'
            _data.extend([self.item, self.text.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.query == ItemTextQuery.HAS_TEXT:
            _size += 9 + len(self.text)

        return _size


@dataclasses.dataclass
class CMSG_MAIL_TAKE_MONEY:
    mailbox: int
    mail_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MAIL_TAKE_MONEY:
        # mailbox: Guid
        mailbox = await read_int(reader, 8)

        # mail_id: u32
        mail_id = await read_int(reader, 4)

        return CMSG_MAIL_TAKE_MONEY(
            mailbox=mailbox,
            mail_id=mail_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0245))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.mailbox, self.mail_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MAIL_TAKE_ITEM:
    mailbox: int
    mail_id: int
    item: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MAIL_TAKE_ITEM:
        # mailbox: Guid
        mailbox = await read_int(reader, 8)

        # mail_id: u32
        mail_id = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        return CMSG_MAIL_TAKE_ITEM(
            mailbox=mailbox,
            mail_id=mail_id,
            item=item,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x0246))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.mailbox, self.mail_id, self.item])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MAIL_MARK_AS_READ:
    mailbox: int
    mail_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MAIL_MARK_AS_READ:
        # mailbox: Guid
        mailbox = await read_int(reader, 8)

        # mail_id: u32
        mail_id = await read_int(reader, 4)

        return CMSG_MAIL_MARK_AS_READ(
            mailbox=mailbox,
            mail_id=mail_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0247))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.mailbox, self.mail_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MAIL_RETURN_TO_SENDER:
    mailbox_id: int
    mail_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MAIL_RETURN_TO_SENDER:
        # mailbox_id: Guid
        mailbox_id = await read_int(reader, 8)

        # mail_id: u32
        mail_id = await read_int(reader, 4)

        return CMSG_MAIL_RETURN_TO_SENDER(
            mailbox_id=mailbox_id,
            mail_id=mail_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0248))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.mailbox_id, self.mail_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MAIL_DELETE:
    mailbox_id: int
    mail_id: int
    mail_template_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MAIL_DELETE:
        # mailbox_id: Guid
        mailbox_id = await read_int(reader, 8)

        # mail_id: u32
        mail_id = await read_int(reader, 4)

        # mail_template_id: u32
        mail_template_id = await read_int(reader, 4)

        return CMSG_MAIL_DELETE(
            mailbox_id=mailbox_id,
            mail_id=mail_id,
            mail_template_id=mail_template_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x0249))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.mailbox_id, self.mail_id, self.mail_template_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MAIL_CREATE_TEXT_ITEM:
    mailbox: int
    mail_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MAIL_CREATE_TEXT_ITEM:
        # mailbox: Guid
        mailbox = await read_int(reader, 8)

        # mail_id: u32
        mail_id = await read_int(reader, 4)

        return CMSG_MAIL_CREATE_TEXT_ITEM(
            mailbox=mailbox,
            mail_id=mail_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x024A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.mailbox, self.mail_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELLLOGMISS:
    id: int
    caster: int
    unknown1: int
    targets: typing.List[SpellLogMiss]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLLOGMISS:
        # id: Spell
        id = await read_int(reader, 4)

        # caster: Guid
        caster = await read_int(reader, 8)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # amount_of_targets: u32
        amount_of_targets = await read_int(reader, 4)

        # targets: SpellLogMiss[amount_of_targets]
        targets = []
        for _ in range(0, amount_of_targets):
            targets.append(await SpellLogMiss.read(reader))

        return SMSG_SPELLLOGMISS(
            id=id,
            caster=caster,
            unknown1=unknown1,
            targets=targets,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x024B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IQBI'
        _data.extend([self.id, self.caster, self.unknown1, len(self.targets)])
        # targets: SpellLogMiss[amount_of_targets]
        for i in self.targets:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 17 + 9 * len(self.targets)


@dataclasses.dataclass
class SMSG_SPELLLOGEXECUTE:
    caster: int
    spell: int
    logs: typing.List[SpellLog]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLLOGEXECUTE:
        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # spell: Spell
        spell = await read_int(reader, 4)

        # amount_of_effects: u32
        amount_of_effects = await read_int(reader, 4)

        # logs: SpellLog[amount_of_effects]
        logs = []
        for _ in range(0, amount_of_effects):
            logs.append(await SpellLog.read(reader))

        return SMSG_SPELLLOGEXECUTE(
            caster=caster,
            spell=spell,
            logs=logs,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x024C))
        _fmt = "<4s"
        _data = [_data]

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # amount_of_effects: u32
        _fmt += 'I'
        _data.append(len(self.logs))

        # logs: SpellLog[amount_of_effects]
        for i in self.logs:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.caster) + sum([i.size() for i in self.logs])


@dataclasses.dataclass
class SMSG_PERIODICAURALOG:
    target: int
    caster: int
    spell: int
    auras: typing.List[AuraLog]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PERIODICAURALOG:
        # target: PackedGuid
        target = await read_packed_guid(reader)

        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # spell: Spell
        spell = await read_int(reader, 4)

        # amount_of_auras: u32
        amount_of_auras = await read_int(reader, 4)

        # auras: AuraLog[amount_of_auras]
        auras = []
        for _ in range(0, amount_of_auras):
            auras.append(await AuraLog.read(reader))

        return SMSG_PERIODICAURALOG(
            target=target,
            caster=caster,
            spell=spell,
            auras=auras,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x024E))
        _fmt = "<4s"
        _data = [_data]

        # target: PackedGuid
        _fmt, _data = packed_guid_write(self.target, _fmt, _data)

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # amount_of_auras: u32
        _fmt += 'I'
        _data.append(len(self.auras))

        # auras: AuraLog[amount_of_auras]
        for i in self.auras:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.target) + packed_guid_size(self.caster) + sum([i.size() for i in self.auras])


@dataclasses.dataclass
class SMSG_SPELLDAMAGESHIELD:
    victim: int
    caster: int
    spell: int
    damage: int
    overkill: int
    school: SpellSchool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLDAMAGESHIELD:
        # victim: Guid
        victim = await read_int(reader, 8)

        # caster: Guid
        caster = await read_int(reader, 8)

        # spell: Spell
        spell = await read_int(reader, 4)

        # damage: u32
        damage = await read_int(reader, 4)

        # overkill: u32
        overkill = await read_int(reader, 4)

        # school: SpellSchool
        school = SpellSchool(await read_int(reader, 4))

        return SMSG_SPELLDAMAGESHIELD(
            victim=victim,
            caster=caster,
            spell=spell,
            damage=damage,
            overkill=overkill,
            school=school,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(32 + 2, 0x024F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQIIII'
        _data.extend([self.victim, self.caster, self.spell, self.damage, self.overkill, self.school.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELLNONMELEEDAMAGELOG:
    target: int
    attacker: int
    spell: int
    damage: int
    overkill: int
    school: SpellSchool
    absorbed_damage: int
    resisted: int
    periodic_log: bool
    unused: int
    blocked: int
    hit_info: HitInfo
    extend_flag: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLNONMELEEDAMAGELOG:
        # target: PackedGuid
        target = await read_packed_guid(reader)

        # attacker: PackedGuid
        attacker = await read_packed_guid(reader)

        # spell: Spell
        spell = await read_int(reader, 4)

        # damage: u32
        damage = await read_int(reader, 4)

        # overkill: u32
        overkill = await read_int(reader, 4)

        # school: SpellSchool
        school = SpellSchool(await read_int(reader, 1))

        # absorbed_damage: u32
        absorbed_damage = await read_int(reader, 4)

        # resisted: u32
        resisted = await read_int(reader, 4)

        # periodic_log: Bool8
        periodic_log = await read_bool(reader, 1)

        # unused: u8
        unused = await read_int(reader, 1)

        # blocked: u32
        blocked = await read_int(reader, 4)

        # hit_info: HitInfo
        hit_info = HitInfo(await read_int(reader, 4))

        # extend_flag: u8
        extend_flag = await read_int(reader, 1)

        return SMSG_SPELLNONMELEEDAMAGELOG(
            target=target,
            attacker=attacker,
            spell=spell,
            damage=damage,
            overkill=overkill,
            school=school,
            absorbed_damage=absorbed_damage,
            resisted=resisted,
            periodic_log=periodic_log,
            unused=unused,
            blocked=blocked,
            hit_info=hit_info,
            extend_flag=extend_flag,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0250))
        _fmt = "<4s"
        _data = [_data]

        # target: PackedGuid
        _fmt, _data = packed_guid_write(self.target, _fmt, _data)

        # attacker: PackedGuid
        _fmt, _data = packed_guid_write(self.attacker, _fmt, _data)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # damage: u32
        _fmt += 'I'
        _data.append(self.damage)

        # overkill: u32
        _fmt += 'I'
        _data.append(self.overkill)

        # school: SpellSchool
        _fmt += 'B'
        _data.append(self.school.value)

        # absorbed_damage: u32
        _fmt += 'I'
        _data.append(self.absorbed_damage)

        # resisted: u32
        _fmt += 'I'
        _data.append(self.resisted)

        # periodic_log: Bool8
        _fmt += 'B'
        _data.append(self.periodic_log)

        # unused: u8
        _fmt += 'B'
        _data.append(self.unused)

        # blocked: u32
        _fmt += 'I'
        _data.append(self.blocked)

        # hit_info: HitInfo
        _fmt += 'I'
        _data.append(self.hit_info.value)

        # extend_flag: u8
        _fmt += 'B'
        _data.append(self.extend_flag)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 32 + packed_guid_size(self.target) + packed_guid_size(self.attacker)


@dataclasses.dataclass
class CMSG_LEARN_TALENT:
    talent: Talent
    requested_rank: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LEARN_TALENT:
        # talent: Talent
        talent = Talent(await read_int(reader, 4))

        # requested_rank: u32
        requested_rank = await read_int(reader, 4)

        return CMSG_LEARN_TALENT(
            talent=talent,
            requested_rank=requested_rank,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0251))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.talent.value, self.requested_rank])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_RESURRECT_FAILED:
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RESURRECT_FAILED:
        # unknown: u32
        unknown = await read_int(reader, 4)

        return SMSG_RESURRECT_FAILED(
            unknown=unknown,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0252))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.unknown)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TOGGLE_PVP:
    enable_pvp: typing.Optional[bool] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TOGGLE_PVP:
        enable_pvp = None
        _size = 0

        # set: optional
        if _size < body_size:
            # enable_pvp: Bool8
            enable_pvp = await read_bool(reader, 1)
            _size += 1

        return CMSG_TOGGLE_PVP(
            enable_pvp=enable_pvp,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0253))
        _fmt = "<6s"
        _data = [_data]

        # set: optional
        if self.enable_pvp is not None:
            _fmt += 'B'
            _data.append(self.enable_pvp)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 0

        # set: optional
        if self.enable_pvp is not None:
            _size += 1

        return _size


@dataclasses.dataclass
class SMSG_ZONE_UNDER_ATTACK:
    zone_id: Area

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ZONE_UNDER_ATTACK:
        # zone_id: Area
        zone_id = Area(await read_int(reader, 4))

        return SMSG_ZONE_UNDER_ATTACK(
            zone_id=zone_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0254))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.zone_id.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_AUCTION_HELLO_Client:
    auctioneer: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_AUCTION_HELLO_Client:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        return MSG_AUCTION_HELLO_Client(
            auctioneer=auctioneer,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0255))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.auctioneer)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_AUCTION_HELLO_Server:
    auctioneer: int
    auction_house: AuctionHouse
    auction_house_enabled: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_AUCTION_HELLO_Server:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        # auction_house: AuctionHouse
        auction_house = AuctionHouse(await read_int(reader, 4))

        # auction_house_enabled: Bool8
        auction_house_enabled = await read_bool(reader, 1)

        return MSG_AUCTION_HELLO_Server(
            auctioneer=auctioneer,
            auction_house=auction_house,
            auction_house_enabled=auction_house_enabled,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(13 + 2, 0x0255))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIB'
        _data.extend([self.auctioneer, self.auction_house.value, self.auction_house_enabled])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUCTION_SELL_ITEM:
    auctioneer: int
    unknown1: int
    item: int
    unknown2: int
    starting_bid: int
    buyout: int
    auction_duration_in_minutes: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUCTION_SELL_ITEM:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # item: Guid
        item = await read_int(reader, 8)

        # unknown2: u32
        unknown2 = await read_int(reader, 4)

        # starting_bid: u32
        starting_bid = await read_int(reader, 4)

        # buyout: u32
        buyout = await read_int(reader, 4)

        # auction_duration_in_minutes: u32
        auction_duration_in_minutes = await read_int(reader, 4)

        return CMSG_AUCTION_SELL_ITEM(
            auctioneer=auctioneer,
            unknown1=unknown1,
            item=item,
            unknown2=unknown2,
            starting_bid=starting_bid,
            buyout=buyout,
            auction_duration_in_minutes=auction_duration_in_minutes,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(36 + 4, 0x0256))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIQIIII'
        _data.extend([self.auctioneer, self.unknown1, self.item, self.unknown2, self.starting_bid, self.buyout, self.auction_duration_in_minutes])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUCTION_REMOVE_ITEM:
    auctioneer: int
    auction_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUCTION_REMOVE_ITEM:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        # auction_id: u32
        auction_id = await read_int(reader, 4)

        return CMSG_AUCTION_REMOVE_ITEM(
            auctioneer=auctioneer,
            auction_id=auction_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0257))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.auctioneer, self.auction_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUCTION_LIST_ITEMS:
    auctioneer: int
    list_start_item: int
    searched_name: str
    minimum_level: int
    maximum_level: int
    auction_slot_id: int
    auction_main_category: int
    auction_sub_category: int
    auction_quality: ItemQuality
    usable: int
    is_full: int
    sorted_auctions: typing.List[AuctionSort]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUCTION_LIST_ITEMS:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        # list_start_item: u32
        list_start_item = await read_int(reader, 4)

        # searched_name: CString
        searched_name = await read_cstring(reader)

        # minimum_level: u8
        minimum_level = await read_int(reader, 1)

        # maximum_level: u8
        maximum_level = await read_int(reader, 1)

        # auction_slot_id: u32
        auction_slot_id = await read_int(reader, 4)

        # auction_main_category: u32
        auction_main_category = await read_int(reader, 4)

        # auction_sub_category: u32
        auction_sub_category = await read_int(reader, 4)

        # auction_quality: ItemQuality
        auction_quality = ItemQuality(await read_int(reader, 4))

        # usable: u8
        usable = await read_int(reader, 1)

        # is_full: u8
        is_full = await read_int(reader, 1)

        # amount_of_sorted_auctions: u8
        amount_of_sorted_auctions = await read_int(reader, 1)

        # sorted_auctions: AuctionSort[amount_of_sorted_auctions]
        sorted_auctions = []
        for _ in range(0, amount_of_sorted_auctions):
            sorted_auctions.append(await AuctionSort.read(reader))

        return CMSG_AUCTION_LIST_ITEMS(
            auctioneer=auctioneer,
            list_start_item=list_start_item,
            searched_name=searched_name,
            minimum_level=minimum_level,
            maximum_level=maximum_level,
            auction_slot_id=auction_slot_id,
            auction_main_category=auction_main_category,
            auction_sub_category=auction_sub_category,
            auction_quality=auction_quality,
            usable=usable,
            is_full=is_full,
            sorted_auctions=sorted_auctions,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0258))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'QI{len(self.searched_name)}sBBBIIIIBBB'
        _data.extend([self.auctioneer, self.list_start_item, self.searched_name.encode('utf-8'), 0, self.minimum_level, self.maximum_level, self.auction_slot_id, self.auction_main_category, self.auction_sub_category, self.auction_quality.value, self.usable, self.is_full, len(self.sorted_auctions)])
        # sorted_auctions: AuctionSort[amount_of_sorted_auctions]
        for i in self.sorted_auctions:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 34 + len(self.searched_name) + 2 * len(self.sorted_auctions)


@dataclasses.dataclass
class CMSG_AUCTION_LIST_OWNER_ITEMS:
    auctioneer: int
    list_from: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUCTION_LIST_OWNER_ITEMS:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        # list_from: u32
        list_from = await read_int(reader, 4)

        return CMSG_AUCTION_LIST_OWNER_ITEMS(
            auctioneer=auctioneer,
            list_from=list_from,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0259))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.auctioneer, self.list_from])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUCTION_PLACE_BID:
    auctioneer: int
    auction_id: int
    price: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUCTION_PLACE_BID:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        # auction_id: u32
        auction_id = await read_int(reader, 4)

        # price: Gold
        price = await read_int(reader, 4)

        return CMSG_AUCTION_PLACE_BID(
            auctioneer=auctioneer,
            auction_id=auction_id,
            price=price,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x025A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.auctioneer, self.auction_id, self.price])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AUCTION_COMMAND_RESULT:
    auction_id: int
    action: AuctionCommandAction
    result: AuctionCommandResult
    inventory_result: typing.Optional[InventoryResult] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_COMMAND_RESULT:
        inventory_result = None
        # auction_id: u32
        auction_id = await read_int(reader, 4)

        # action: AuctionCommandAction
        action = AuctionCommandAction(await read_int(reader, 4))

        # result: AuctionCommandResult
        result = AuctionCommandResult(await read_int(reader, 4))

        if result == AuctionCommandResult.ERR_INVENTORY:
            # inventory_result: InventoryResult
            inventory_result = InventoryResult(await read_int(reader, 1))

        return SMSG_AUCTION_COMMAND_RESULT(
            auction_id=auction_id,
            action=action,
            result=result,
            inventory_result=inventory_result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x025B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'III'
        _data.extend([self.auction_id, self.action.value, self.result.value])
        if self.result == AuctionCommandResult.ERR_INVENTORY:
            _fmt += 'B'
            _data.append(self.inventory_result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 12

        if self.result == AuctionCommandResult.ERR_INVENTORY:
            _size += 1

        return _size


@dataclasses.dataclass
class SMSG_AUCTION_LIST_RESULT:
    auctions: typing.List[AuctionListItem]
    total_amount_of_auctions: int
    auction_search_delay: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_LIST_RESULT:
        # count: u32
        count = await read_int(reader, 4)

        # auctions: AuctionListItem[count]
        auctions = []
        for _ in range(0, count):
            auctions.append(await AuctionListItem.read(reader))

        # total_amount_of_auctions: u32
        total_amount_of_auctions = await read_int(reader, 4)

        # auction_search_delay: Milliseconds
        auction_search_delay = await read_int(reader, 4)

        return SMSG_AUCTION_LIST_RESULT(
            auctions=auctions,
            total_amount_of_auctions=total_amount_of_auctions,
            auction_search_delay=auction_search_delay,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x025C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.auctions))
        # auctions: AuctionListItem[count]
        for i in self.auctions:
            _fmt, _data = i.write(_fmt, _data)

        # total_amount_of_auctions: u32
        _fmt += 'I'
        _data.append(self.total_amount_of_auctions)

        # auction_search_delay: Milliseconds
        _fmt += 'I'
        _data.append(self.auction_search_delay)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + 148 * len(self.auctions)


@dataclasses.dataclass
class SMSG_AUCTION_OWNER_LIST_RESULT:
    auctions: typing.List[AuctionListItem]
    total_amount_of_auctions: int
    auction_search_delay: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_OWNER_LIST_RESULT:
        # count: u32
        count = await read_int(reader, 4)

        # auctions: AuctionListItem[count]
        auctions = []
        for _ in range(0, count):
            auctions.append(await AuctionListItem.read(reader))

        # total_amount_of_auctions: u32
        total_amount_of_auctions = await read_int(reader, 4)

        # auction_search_delay: Milliseconds
        auction_search_delay = await read_int(reader, 4)

        return SMSG_AUCTION_OWNER_LIST_RESULT(
            auctions=auctions,
            total_amount_of_auctions=total_amount_of_auctions,
            auction_search_delay=auction_search_delay,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x025D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.auctions))
        # auctions: AuctionListItem[count]
        for i in self.auctions:
            _fmt, _data = i.write(_fmt, _data)

        # total_amount_of_auctions: u32
        _fmt += 'I'
        _data.append(self.total_amount_of_auctions)

        # auction_search_delay: Milliseconds
        _fmt += 'I'
        _data.append(self.auction_search_delay)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + 148 * len(self.auctions)


@dataclasses.dataclass
class SMSG_AUCTION_BIDDER_NOTIFICATION:
    auction_house: AuctionHouse
    auction_id: int
    bidder: int
    bid_sum: int
    new_highest_bid: int
    out_bid_amount: int
    item_template: int
    item_random_property_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_BIDDER_NOTIFICATION:
        # auction_house: AuctionHouse
        auction_house = AuctionHouse(await read_int(reader, 4))

        # auction_id: u32
        auction_id = await read_int(reader, 4)

        # bidder: Guid
        bidder = await read_int(reader, 8)

        # bid_sum: u32
        bid_sum = await read_int(reader, 4)

        # new_highest_bid: u32
        new_highest_bid = await read_int(reader, 4)

        # out_bid_amount: u32
        out_bid_amount = await read_int(reader, 4)

        # item_template: u32
        item_template = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        return SMSG_AUCTION_BIDDER_NOTIFICATION(
            auction_house=auction_house,
            auction_id=auction_id,
            bidder=bidder,
            bid_sum=bid_sum,
            new_highest_bid=new_highest_bid,
            out_bid_amount=out_bid_amount,
            item_template=item_template,
            item_random_property_id=item_random_property_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(36 + 2, 0x025E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIQIIIII'
        _data.extend([self.auction_house.value, self.auction_id, self.bidder, self.bid_sum, self.new_highest_bid, self.out_bid_amount, self.item_template, self.item_random_property_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AUCTION_OWNER_NOTIFICATION:
    auction_id: int
    bid: int
    auction_out_bid: int
    bidder: int
    item: int
    item_random_property_id: int
    time_left: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_OWNER_NOTIFICATION:
        # auction_id: u32
        auction_id = await read_int(reader, 4)

        # bid: u32
        bid = await read_int(reader, 4)

        # auction_out_bid: u32
        auction_out_bid = await read_int(reader, 4)

        # bidder: Guid
        bidder = await read_int(reader, 8)

        # item: Item
        item = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # time_left: f32
        time_left = await read_float(reader)

        return SMSG_AUCTION_OWNER_NOTIFICATION(
            auction_id=auction_id,
            bid=bid,
            auction_out_bid=auction_out_bid,
            bidder=bidder,
            item=item,
            item_random_property_id=item_random_property_id,
            time_left=time_left,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(32 + 2, 0x025F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIQIIf'
        _data.extend([self.auction_id, self.bid, self.auction_out_bid, self.bidder, self.item, self.item_random_property_id, self.time_left])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PROCRESIST:
    caster: int
    target: int
    id: int
    log_format: LogFormat

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PROCRESIST:
        # caster: Guid
        caster = await read_int(reader, 8)

        # target: Guid
        target = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        # log_format: LogFormat
        log_format = LogFormat(await read_int(reader, 1))

        return SMSG_PROCRESIST(
            caster=caster,
            target=target,
            id=id,
            log_format=log_format,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(21 + 2, 0x0260))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQIB'
        _data.extend([self.caster, self.target, self.id, self.log_format.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DISPEL_FAILED:
    caster: int
    target: int
    spells: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DISPEL_FAILED:
        _size = 0

        # caster: Guid
        caster = await read_int(reader, 8)
        _size += 8

        # target: Guid
        target = await read_int(reader, 8)
        _size += 8

        # spells: Spell[-]
        spells = []
        while _size < body_size:
            spells.append(await read_int(reader, 4))
            _size += 4

        return SMSG_DISPEL_FAILED(
            caster=caster,
            target=target,
            spells=spells,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0262))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQ'
        _data.extend([self.caster, self.target])
        # spells: Spell[-]
        _fmt += f'len({self.spells})I'
        _data.extend(self.spells)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + 4 * len(self.spells)


@dataclasses.dataclass
class SMSG_SPELLORDAMAGE_IMMUNE:
    caster: int
    target: int
    id: int
    debug_log_format: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLORDAMAGE_IMMUNE:
        # caster: Guid
        caster = await read_int(reader, 8)

        # target: Guid
        target = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        # debug_log_format: Bool8
        debug_log_format = await read_bool(reader, 1)

        return SMSG_SPELLORDAMAGE_IMMUNE(
            caster=caster,
            target=target,
            id=id,
            debug_log_format=debug_log_format,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(21 + 2, 0x0263))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQIB'
        _data.extend([self.caster, self.target, self.id, self.debug_log_format])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUCTION_LIST_BIDDER_ITEMS:
    auctioneer: int
    start_from_page: int
    outbid_item_ids: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUCTION_LIST_BIDDER_ITEMS:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        # start_from_page: u32
        start_from_page = await read_int(reader, 4)

        # amount_of_outbid_items: u32
        amount_of_outbid_items = await read_int(reader, 4)

        # outbid_item_ids: u32[amount_of_outbid_items]
        outbid_item_ids = []
        for _ in range(0, amount_of_outbid_items):
            outbid_item_ids.append(await read_int(reader, 4))

        return CMSG_AUCTION_LIST_BIDDER_ITEMS(
            auctioneer=auctioneer,
            start_from_page=start_from_page,
            outbid_item_ids=outbid_item_ids,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0264))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'QII{len(self.outbid_item_ids)}I'
        _data.extend([self.auctioneer, self.start_from_page, len(self.outbid_item_ids), *self.outbid_item_ids])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + 4 * len(self.outbid_item_ids)


@dataclasses.dataclass
class SMSG_AUCTION_BIDDER_LIST_RESULT:
    auctions: typing.List[AuctionListItem]
    total_amount_of_auctions: int
    auction_search_delay: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_BIDDER_LIST_RESULT:
        # count: u32
        count = await read_int(reader, 4)

        # auctions: AuctionListItem[count]
        auctions = []
        for _ in range(0, count):
            auctions.append(await AuctionListItem.read(reader))

        # total_amount_of_auctions: u32
        total_amount_of_auctions = await read_int(reader, 4)

        # auction_search_delay: Milliseconds
        auction_search_delay = await read_int(reader, 4)

        return SMSG_AUCTION_BIDDER_LIST_RESULT(
            auctions=auctions,
            total_amount_of_auctions=total_amount_of_auctions,
            auction_search_delay=auction_search_delay,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0265))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.auctions))
        # auctions: AuctionListItem[count]
        for i in self.auctions:
            _fmt, _data = i.write(_fmt, _data)

        # total_amount_of_auctions: u32
        _fmt += 'I'
        _data.append(self.total_amount_of_auctions)

        # auction_search_delay: Milliseconds
        _fmt += 'I'
        _data.append(self.auction_search_delay)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + 148 * len(self.auctions)


@dataclasses.dataclass
class SMSG_SET_FLAT_SPELL_MODIFIER:
    eff: int
    op: int
    value: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_FLAT_SPELL_MODIFIER:
        # eff: u8
        eff = await read_int(reader, 1)

        # op: u8
        op = await read_int(reader, 1)

        # value: u32
        value = await read_int(reader, 4)

        return SMSG_SET_FLAT_SPELL_MODIFIER(
            eff=eff,
            op=op,
            value=value,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(6 + 2, 0x0266))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BBI'
        _data.extend([self.eff, self.op, self.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SET_PCT_SPELL_MODIFIER:
    eff: int
    op: int
    value: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_PCT_SPELL_MODIFIER:
        # eff: u8
        eff = await read_int(reader, 1)

        # op: u8
        op = await read_int(reader, 1)

        # value: u32
        value = await read_int(reader, 4)

        return SMSG_SET_PCT_SPELL_MODIFIER(
            eff=eff,
            op=op,
            value=value,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(6 + 2, 0x0267))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BBI'
        _data.extend([self.eff, self.op, self.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_AMMO:
    item: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_AMMO:
        # item: Item
        item = await read_int(reader, 4)

        return CMSG_SET_AMMO(
            item=item,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0268))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.item)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CORPSE_RECLAIM_DELAY:
    delay: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CORPSE_RECLAIM_DELAY:
        # delay: Seconds
        delay = await read_int(reader, 4)

        return SMSG_CORPSE_RECLAIM_DELAY(
            delay=delay,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0269))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.delay)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_ACTIVE_MOVER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_ACTIVE_MOVER:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_SET_ACTIVE_MOVER(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x026A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PET_CANCEL_AURA:
    guid: int
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_CANCEL_AURA:
        # guid: Guid
        guid = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        return CMSG_PET_CANCEL_AURA(
            guid=guid,
            id=id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x026B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CANCEL_AUTO_REPEAT_SPELL:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_AUTO_REPEAT_SPELL:
        return CMSG_CANCEL_AUTO_REPEAT_SPELL()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x026D))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_LIST_STABLED_PETS_Client:
    npc: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_LIST_STABLED_PETS_Client:
        # npc: Guid
        npc = await read_int(reader, 8)

        return MSG_LIST_STABLED_PETS_Client(
            npc=npc,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x026F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.npc)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_LIST_STABLED_PETS_Server:
    npc: int
    stable_slots: int
    pets: typing.List[StabledPet]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_LIST_STABLED_PETS_Server:
        # npc: Guid
        npc = await read_int(reader, 8)

        # amount_of_pets: u8
        amount_of_pets = await read_int(reader, 1)

        # stable_slots: u8
        stable_slots = await read_int(reader, 1)

        # pets: StabledPet[amount_of_pets]
        pets = []
        for _ in range(0, amount_of_pets):
            pets.append(await StabledPet.read(reader))

        return MSG_LIST_STABLED_PETS_Server(
            npc=npc,
            stable_slots=stable_slots,
            pets=pets,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x026F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QBB'
        _data.extend([self.npc, len(self.pets), self.stable_slots])
        # pets: StabledPet[amount_of_pets]
        for i in self.pets:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 10 + sum([i.size() for i in self.pets])


@dataclasses.dataclass
class CMSG_STABLE_PET:
    stable_master: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_STABLE_PET:
        # stable_master: Guid
        stable_master = await read_int(reader, 8)

        return CMSG_STABLE_PET(
            stable_master=stable_master,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0270))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.stable_master)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_UNSTABLE_PET:
    stable_master: int
    pet_number: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_UNSTABLE_PET:
        # stable_master: Guid
        stable_master = await read_int(reader, 8)

        # pet_number: u32
        pet_number = await read_int(reader, 4)

        return CMSG_UNSTABLE_PET(
            stable_master=stable_master,
            pet_number=pet_number,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0271))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.stable_master, self.pet_number])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BUY_STABLE_SLOT:
    npc: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BUY_STABLE_SLOT:
        # npc: Guid
        npc = await read_int(reader, 8)

        return CMSG_BUY_STABLE_SLOT(
            npc=npc,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0272))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.npc)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_STABLE_RESULT:
    result: StableResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_STABLE_RESULT:
        # result: StableResult
        result = StableResult(await read_int(reader, 1))

        return SMSG_STABLE_RESULT(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x0273))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_STABLE_SWAP_PET:
    npc: int
    pet_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_STABLE_SWAP_PET:
        # npc: Guid
        npc = await read_int(reader, 8)

        # pet_slot: u32
        pet_slot = await read_int(reader, 4)

        return CMSG_STABLE_SWAP_PET(
            npc=npc,
            pet_slot=pet_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0275))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.npc, self.pet_slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_QUEST_PUSH_RESULT:
    guid: int
    message: QuestPartyMessage

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_QUEST_PUSH_RESULT:
        # guid: Guid
        guid = await read_int(reader, 8)

        # message: QuestPartyMessage
        message = QuestPartyMessage(await read_int(reader, 1))

        return MSG_QUEST_PUSH_RESULT(
            guid=guid,
            message=message,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x0276))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.message.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x0276))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.message.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PLAY_MUSIC:
    sound_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAY_MUSIC:
        # sound_id: u32
        sound_id = await read_int(reader, 4)

        return SMSG_PLAY_MUSIC(
            sound_id=sound_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0277))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.sound_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PLAY_OBJECT_SOUND:
    sound_id: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAY_OBJECT_SOUND:
        # sound_id: u32
        sound_id = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_PLAY_OBJECT_SOUND(
            sound_id=sound_id,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0278))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.sound_id, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_REQUEST_PET_INFO:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REQUEST_PET_INFO:
        return CMSG_REQUEST_PET_INFO()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0279))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_FAR_SIGHT:
    operation: FarSightOperation

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FAR_SIGHT:
        # operation: FarSightOperation
        operation = FarSightOperation(await read_int(reader, 1))

        return CMSG_FAR_SIGHT(
            operation=operation,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x027A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.operation.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELLDISPELLOG:
    victim: int
    caster: int
    dispell_spell: int
    unknown: int
    spells: typing.List[DispelledSpell]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLDISPELLOG:
        # victim: PackedGuid
        victim = await read_packed_guid(reader)

        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # dispell_spell: Spell
        dispell_spell = await read_int(reader, 4)

        # unknown: u8
        unknown = await read_int(reader, 1)

        # amount_of_spells: u32
        amount_of_spells = await read_int(reader, 4)

        # spells: DispelledSpell[amount_of_spells]
        spells = []
        for _ in range(0, amount_of_spells):
            spells.append(await DispelledSpell.read(reader))

        return SMSG_SPELLDISPELLOG(
            victim=victim,
            caster=caster,
            dispell_spell=dispell_spell,
            unknown=unknown,
            spells=spells,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x027B))
        _fmt = "<4s"
        _data = [_data]

        # victim: PackedGuid
        _fmt, _data = packed_guid_write(self.victim, _fmt, _data)

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # dispell_spell: Spell
        _fmt += 'I'
        _data.append(self.dispell_spell)

        # unknown: u8
        _fmt += 'B'
        _data.append(self.unknown)

        # amount_of_spells: u32
        _fmt += 'I'
        _data.append(len(self.spells))

        # spells: DispelledSpell[amount_of_spells]
        for i in self.spells:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + packed_guid_size(self.victim) + packed_guid_size(self.caster) + 5 * len(self.spells)


@dataclasses.dataclass
class CMSG_GROUP_CHANGE_SUB_GROUP:
    name: str
    group_number: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_CHANGE_SUB_GROUP:
        # name: CString
        name = await read_cstring(reader)

        # group_number: u8
        group_number = await read_int(reader, 1)

        return CMSG_GROUP_CHANGE_SUB_GROUP(
            name=name,
            group_number=group_number,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x027E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sBB'
        _data.extend([self.name.encode('utf-8'), 0, self.group_number])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.name)


@dataclasses.dataclass
class CMSG_REQUEST_PARTY_MEMBER_STATS:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REQUEST_PARTY_MEMBER_STATS:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_REQUEST_PARTY_MEMBER_STATS(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x027F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_SWAP_SUB_GROUP:
    name: str
    swap_with_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_SWAP_SUB_GROUP:
        # name: CString
        name = await read_cstring(reader)

        # swap_with_name: CString
        swap_with_name = await read_cstring(reader)

        return CMSG_GROUP_SWAP_SUB_GROUP(
            name=name,
            swap_with_name=swap_with_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0280))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB{len(self.swap_with_name)}sB'
        _data.extend([self.name.encode('utf-8'), 0, self.swap_with_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.name) + len(self.swap_with_name)


@dataclasses.dataclass
class CMSG_AUTOSTORE_BANK_ITEM:
    bag_index: int
    slot_index: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUTOSTORE_BANK_ITEM:
        # bag_index: u8
        bag_index = await read_int(reader, 1)

        # slot_index: u8
        slot_index = await read_int(reader, 1)

        return CMSG_AUTOSTORE_BANK_ITEM(
            bag_index=bag_index,
            slot_index=slot_index,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x0282))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.bag_index, self.slot_index])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUTOBANK_ITEM:
    bag_index: int
    slot_index: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUTOBANK_ITEM:
        # bag_index: u8
        bag_index = await read_int(reader, 1)

        # slot_index: u8
        slot_index = await read_int(reader, 1)

        return CMSG_AUTOBANK_ITEM(
            bag_index=bag_index,
            slot_index=slot_index,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x0283))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.bag_index, self.slot_index])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_QUERY_NEXT_MAIL_TIME_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_QUERY_NEXT_MAIL_TIME_Client:
        return MSG_QUERY_NEXT_MAIL_TIME_Client()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0284))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_QUERY_NEXT_MAIL_TIME_Server:
    float: int
    mails: typing.List[ReceivedMail]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_QUERY_NEXT_MAIL_TIME_Server:
        # float: u32
        float = await read_int(reader, 4)

        # amount_of_mails: u32
        amount_of_mails = await read_int(reader, 4)

        # mails: ReceivedMail[amount_of_mails]
        mails = []
        for _ in range(0, amount_of_mails):
            mails.append(await ReceivedMail.read(reader))

        return MSG_QUERY_NEXT_MAIL_TIME_Server(
            float=float,
            mails=mails,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0284))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.float, len(self.mails)])
        # mails: ReceivedMail[amount_of_mails]
        for i in self.mails:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + 24 * len(self.mails)


@dataclasses.dataclass
class SMSG_RECEIVED_MAIL:
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RECEIVED_MAIL:
        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return SMSG_RECEIVED_MAIL(
            unknown1=unknown1,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0285))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.unknown1)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_RAID_GROUP_ONLY:
    homebind_timer: int
    error: RaidGroupError

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RAID_GROUP_ONLY:
        # homebind_timer: u32
        homebind_timer = await read_int(reader, 4)

        # error: RaidGroupError
        error = RaidGroupError(await read_int(reader, 4))

        return SMSG_RAID_GROUP_ONLY(
            homebind_timer=homebind_timer,
            error=error,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0286))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.homebind_timer, self.error.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PVP_CREDIT:
    honor_points: int
    victim: int
    rank: PvpRank

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PVP_CREDIT:
        # honor_points: u32
        honor_points = await read_int(reader, 4)

        # victim: Guid
        victim = await read_int(reader, 8)

        # rank: PvpRank
        rank = PvpRank(await read_int(reader, 4))

        return SMSG_PVP_CREDIT(
            honor_points=honor_points,
            victim=victim,
            rank=rank,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x028C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IQI'
        _data.extend([self.honor_points, self.victim, self.rank.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AUCTION_REMOVED_NOTIFICATION:
    item: int
    item_template: int
    random_property_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_REMOVED_NOTIFICATION:
        # item: Item
        item = await read_int(reader, 4)

        # item_template: u32
        item_template = await read_int(reader, 4)

        # random_property_id: u32
        random_property_id = await read_int(reader, 4)

        return SMSG_AUCTION_REMOVED_NOTIFICATION(
            item=item,
            item_template=item_template,
            random_property_id=random_property_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x028D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'III'
        _data.extend([self.item, self.item_template, self.random_property_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_RAID_CONVERT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_RAID_CONVERT:
        return CMSG_GROUP_RAID_CONVERT()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x028E))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_ASSISTANT_LEADER:
    guid: int
    set_assistant: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_ASSISTANT_LEADER:
        # guid: Guid
        guid = await read_int(reader, 8)

        # set_assistant: Bool8
        set_assistant = await read_bool(reader, 1)

        return CMSG_GROUP_ASSISTANT_LEADER(
            guid=guid,
            set_assistant=set_assistant,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x028F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.set_assistant])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BUYBACK_ITEM:
    guid: int
    slot: BuybackSlot

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BUYBACK_ITEM:
        # guid: Guid
        guid = await read_int(reader, 8)

        # slot: BuybackSlot
        slot = BuybackSlot(await read_int(reader, 4))

        return CMSG_BUYBACK_ITEM(
            guid=guid,
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0290))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.slot.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SERVER_MESSAGE:
    message_type: ServerMessageType
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SERVER_MESSAGE:
        # message_type: ServerMessageType
        message_type = ServerMessageType(await read_int(reader, 4))

        # message: CString
        message = await read_cstring(reader)

        return SMSG_SERVER_MESSAGE(
            message_type=message_type,
            message=message,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0291))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.message)}sB'
        _data.extend([self.message_type.value, self.message.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + len(self.message)


@dataclasses.dataclass
class CMSG_SET_SAVED_INSTANCE_EXTEND:
    map: Map
    difficulty: RaidDifficulty
    toggle_extend: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_SAVED_INSTANCE_EXTEND:
        # map: Map
        map = Map(await read_int(reader, 4))

        # difficulty: RaidDifficulty
        difficulty = RaidDifficulty(await read_int(reader, 1))

        # toggle_extend: Bool8
        toggle_extend = await read_bool(reader, 1)

        return CMSG_SET_SAVED_INSTANCE_EXTEND(
            map=map,
            difficulty=difficulty,
            toggle_extend=toggle_extend,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(6 + 4, 0x0292))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IBB'
        _data.extend([self.map.value, self.difficulty.value, self.toggle_extend])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LFG_OFFER_CONTINUE:
    dungeon_entry: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LFG_OFFER_CONTINUE:
        # dungeon_entry: u32
        dungeon_entry = await read_int(reader, 4)

        return SMSG_LFG_OFFER_CONTINUE(
            dungeon_entry=dungeon_entry,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0293))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.dungeon_entry)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LFG_GET_STATUS:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LFG_GET_STATUS:
        return CMSG_LFG_GET_STATUS()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0296))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SHOW_MAILBOX:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SHOW_MAILBOX:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_SHOW_MAILBOX(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0297))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GMTICKETSYSTEM_TOGGLE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GMTICKETSYSTEM_TOGGLE:
        return CMSG_GMTICKETSYSTEM_TOGGLE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x029A))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CANCEL_GROWTH_AURA:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_GROWTH_AURA:
        return CMSG_CANCEL_GROWTH_AURA()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x029B))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CANCEL_AUTO_REPEAT:
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CANCEL_AUTO_REPEAT:
        # target: PackedGuid
        target = await read_packed_guid(reader)

        return SMSG_CANCEL_AUTO_REPEAT(
            target=target,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x029C))
        _fmt = "<4s"
        _data = [_data]

        # target: PackedGuid
        _fmt, _data = packed_guid_write(self.target, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.target)


@dataclasses.dataclass
class SMSG_STANDSTATE_UPDATE:
    state: UnitStandState

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_STANDSTATE_UPDATE:
        # state: UnitStandState
        state = UnitStandState(await read_int(reader, 1))

        return SMSG_STANDSTATE_UPDATE(
            state=state,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x029D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.state.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_ALL_PASSED:
    looted_target: int
    loot_slot: int
    item: int
    item_random_property_id: int
    item_random_suffix_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_ALL_PASSED:
        # looted_target: Guid
        looted_target = await read_int(reader, 8)

        # loot_slot: u32
        loot_slot = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # item_random_suffix_id: u32
        item_random_suffix_id = await read_int(reader, 4)

        return SMSG_LOOT_ALL_PASSED(
            looted_target=looted_target,
            loot_slot=loot_slot,
            item=item,
            item_random_property_id=item_random_property_id,
            item_random_suffix_id=item_random_suffix_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(24 + 2, 0x029E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIIII'
        _data.extend([self.looted_target, self.loot_slot, self.item, self.item_random_property_id, self.item_random_suffix_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_ROLL_WON:
    looted_target: int
    loot_slot: int
    item: int
    item_random_suffix: int
    item_random_property_id: int
    winning_player: int
    winning_roll: int
    vote: RollVote

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_ROLL_WON:
        # looted_target: Guid
        looted_target = await read_int(reader, 8)

        # loot_slot: u32
        loot_slot = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        # item_random_suffix: u32
        item_random_suffix = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # winning_player: Guid
        winning_player = await read_int(reader, 8)

        # winning_roll: u8
        winning_roll = await read_int(reader, 1)

        # vote: RollVote
        vote = RollVote(await read_int(reader, 1))

        return SMSG_LOOT_ROLL_WON(
            looted_target=looted_target,
            loot_slot=loot_slot,
            item=item,
            item_random_suffix=item_random_suffix,
            item_random_property_id=item_random_property_id,
            winning_player=winning_player,
            winning_roll=winning_roll,
            vote=vote,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(34 + 2, 0x029F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIIIIQBB'
        _data.extend([self.looted_target, self.loot_slot, self.item, self.item_random_suffix, self.item_random_property_id, self.winning_player, self.winning_roll, self.vote.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LOOT_ROLL:
    item: int
    item_slot: int
    vote: RollVote

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOOT_ROLL:
        # item: Guid
        item = await read_int(reader, 8)

        # item_slot: u32
        item_slot = await read_int(reader, 4)

        # vote: RollVote
        vote = RollVote(await read_int(reader, 1))

        return CMSG_LOOT_ROLL(
            item=item,
            item_slot=item_slot,
            vote=vote,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(13 + 4, 0x02A0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIB'
        _data.extend([self.item, self.item_slot, self.vote.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_START_ROLL:
    creature: int
    map: Map
    loot_slot: int
    item: int
    item_random_suffix: int
    item_random_property_id: int
    countdown_time: int
    flags: RollFlags

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_START_ROLL:
        # creature: Guid
        creature = await read_int(reader, 8)

        # map: Map
        map = Map(await read_int(reader, 4))

        # loot_slot: u32
        loot_slot = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        # item_random_suffix: u32
        item_random_suffix = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # countdown_time: Milliseconds
        countdown_time = await read_int(reader, 4)

        # flags: RollFlags
        flags = RollFlags(await read_int(reader, 1))

        return SMSG_LOOT_START_ROLL(
            creature=creature,
            map=map,
            loot_slot=loot_slot,
            item=item,
            item_random_suffix=item_random_suffix,
            item_random_property_id=item_random_property_id,
            countdown_time=countdown_time,
            flags=flags,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(33 + 2, 0x02A1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIIIIIIB'
        _data.extend([self.creature, self.map.value, self.loot_slot, self.item, self.item_random_suffix, self.item_random_property_id, self.countdown_time, self.flags.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_ROLL:
    creature: int
    loot_slot: int
    player: int
    item: int
    item_random_suffix: int
    item_random_property_id: int
    roll_number: int
    vote: RollVote
    auto_pass: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_ROLL:
        # creature: Guid
        creature = await read_int(reader, 8)

        # loot_slot: u32
        loot_slot = await read_int(reader, 4)

        # player: Guid
        player = await read_int(reader, 8)

        # item: Item
        item = await read_int(reader, 4)

        # item_random_suffix: u32
        item_random_suffix = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # roll_number: u8
        roll_number = await read_int(reader, 1)

        # vote: RollVote
        vote = RollVote(await read_int(reader, 1))

        # auto_pass: u8
        auto_pass = await read_int(reader, 1)

        return SMSG_LOOT_ROLL(
            creature=creature,
            loot_slot=loot_slot,
            player=player,
            item=item,
            item_random_suffix=item_random_suffix,
            item_random_property_id=item_random_property_id,
            roll_number=roll_number,
            vote=vote,
            auto_pass=auto_pass,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(35 + 2, 0x02A2))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIQIIIBBB'
        _data.extend([self.creature, self.loot_slot, self.player, self.item, self.item_random_suffix, self.item_random_property_id, self.roll_number, self.vote.value, self.auto_pass])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LOOT_MASTER_GIVE:
    loot: int
    slot_id: int
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOOT_MASTER_GIVE:
        # loot: Guid
        loot = await read_int(reader, 8)

        # slot_id: u8
        slot_id = await read_int(reader, 1)

        # player: Guid
        player = await read_int(reader, 8)

        return CMSG_LOOT_MASTER_GIVE(
            loot=loot,
            slot_id=slot_id,
            player=player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(17 + 4, 0x02A3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QBQ'
        _data.extend([self.loot, self.slot_id, self.player])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_MASTER_LIST:
    guids: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_MASTER_LIST:
        # amount_of_players: u8
        amount_of_players = await read_int(reader, 1)

        # guids: Guid[amount_of_players]
        guids = []
        for _ in range(0, amount_of_players):
            guids.append(await read_int(reader, 8))

        return SMSG_LOOT_MASTER_LIST(
            guids=guids,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02A4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'B{len(self.guids)}Q'
        _data.extend([len(self.guids), *self.guids])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + 8 * len(self.guids)


@dataclasses.dataclass
class SMSG_SET_FORCED_REACTIONS:
    reactions: typing.List[ForcedReaction]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_FORCED_REACTIONS:
        # amount_of_reactions: u32
        amount_of_reactions = await read_int(reader, 4)

        # reactions: ForcedReaction[amount_of_reactions]
        reactions = []
        for _ in range(0, amount_of_reactions):
            reactions.append(await ForcedReaction.read(reader))

        return SMSG_SET_FORCED_REACTIONS(
            reactions=reactions,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02A5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.reactions))
        # reactions: ForcedReaction[amount_of_reactions]
        for i in self.reactions:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + 6 * len(self.reactions)


@dataclasses.dataclass
class SMSG_SPELL_FAILED_OTHER:
    caster: int
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELL_FAILED_OTHER:
        # caster: Guid
        caster = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        return SMSG_SPELL_FAILED_OTHER(
            caster=caster,
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x02A6))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.caster, self.id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_REPAIR_ITEM:
    npc: int
    item: int
    from_guild_bank: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REPAIR_ITEM:
        # npc: Guid
        npc = await read_int(reader, 8)

        # item: Guid
        item = await read_int(reader, 8)

        # from_guild_bank: Bool8
        from_guild_bank = await read_bool(reader, 1)

        return CMSG_REPAIR_ITEM(
            npc=npc,
            item=item,
            from_guild_bank=from_guild_bank,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(17 + 4, 0x02A8))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QQB'
        _data.extend([self.npc, self.item, self.from_guild_bank])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CHAT_PLAYER_NOT_FOUND:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAT_PLAYER_NOT_FOUND:
        # name: CString
        name = await read_cstring(reader)

        return SMSG_CHAT_PLAYER_NOT_FOUND(
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02A9))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class MSG_TALENT_WIPE_CONFIRM_Client:
    wiping_npc: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_TALENT_WIPE_CONFIRM_Client:
        # wiping_npc: Guid
        wiping_npc = await read_int(reader, 8)

        return MSG_TALENT_WIPE_CONFIRM_Client(
            wiping_npc=wiping_npc,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02AA))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.wiping_npc)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_TALENT_WIPE_CONFIRM_Server:
    wiping_npc: int
    cost_in_copper: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_TALENT_WIPE_CONFIRM_Server:
        # wiping_npc: Guid
        wiping_npc = await read_int(reader, 8)

        # cost_in_copper: u32
        cost_in_copper = await read_int(reader, 4)

        return MSG_TALENT_WIPE_CONFIRM_Server(
            wiping_npc=wiping_npc,
            cost_in_copper=cost_in_copper,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x02AA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.wiping_npc, self.cost_in_copper])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SUMMON_REQUEST:
    summoner: int
    area: Area
    auto_decline_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SUMMON_REQUEST:
        # summoner: Guid
        summoner = await read_int(reader, 8)

        # area: Area
        area = Area(await read_int(reader, 4))

        # auto_decline_time: Milliseconds
        auto_decline_time = await read_int(reader, 4)

        return SMSG_SUMMON_REQUEST(
            summoner=summoner,
            area=area,
            auto_decline_time=auto_decline_time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x02AB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.summoner, self.area.value, self.auto_decline_time])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SUMMON_RESPONSE:
    summoner: int
    agree: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SUMMON_RESPONSE:
        # summoner: Guid
        summoner = await read_int(reader, 8)

        # agree: Bool8
        agree = await read_bool(reader, 1)

        return CMSG_SUMMON_RESPONSE(
            summoner=summoner,
            agree=agree,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x02AC))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.summoner, self.agree])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MONSTER_MOVE_TRANSPORT:
    guid: int
    transport: int
    unknown: int
    spline_point: Vector3d
    spline_id: int
    move_type: MonsterMoveType
    spline_flags: SplineFlag
    duration: int
    splines: MonsterMoveSpline
    target: typing.Optional[int] = None
    angle: typing.Optional[float] = None
    position: typing.Optional[Vector3d] = None
    animation_id: typing.Optional[int] = None
    animation_start_time: typing.Optional[int] = None
    vertical_acceleration: typing.Optional[float] = None
    effect_start_time: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MONSTER_MOVE_TRANSPORT:
        target = None
        angle = None
        position = None
        animation_id = None
        animation_start_time = None
        vertical_acceleration = None
        effect_start_time = None
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # transport: PackedGuid
        transport = await read_packed_guid(reader)

        # unknown: u8
        unknown = await read_int(reader, 1)

        # spline_point: Vector3d
        spline_point = await Vector3d.read(reader)

        # spline_id: u32
        spline_id = await read_int(reader, 4)

        # move_type: MonsterMoveType
        move_type = MonsterMoveType(await read_int(reader, 1))

        if move_type == MonsterMoveType.FACING_TARGET:
            # target: Guid
            target = await read_int(reader, 8)

        elif move_type == MonsterMoveType.FACING_ANGLE:
            # angle: f32
            angle = await read_float(reader)

        elif move_type == MonsterMoveType.FACING_SPOT:
            # position: Vector3d
            position = await Vector3d.read(reader)

        # spline_flags: SplineFlag
        spline_flags = SplineFlag(await read_int(reader, 4))

        if SplineFlag.ENTER_CYCLE in spline_flags:
            # animation_id: u32
            animation_id = await read_int(reader, 4)

            # animation_start_time: u32
            animation_start_time = await read_int(reader, 4)

        # duration: u32
        duration = await read_int(reader, 4)

        if SplineFlag.PARABOLIC in spline_flags:
            # vertical_acceleration: f32
            vertical_acceleration = await read_float(reader)

            # effect_start_time: u32
            effect_start_time = await read_int(reader, 4)

        # splines: MonsterMoveSpline
        splines = await MonsterMoveSpline.read(reader)

        return SMSG_MONSTER_MOVE_TRANSPORT(
            guid=guid,
            transport=transport,
            unknown=unknown,
            spline_point=spline_point,
            spline_id=spline_id,
            move_type=move_type,
            target=target,
            angle=angle,
            position=position,
            spline_flags=spline_flags,
            animation_id=animation_id,
            animation_start_time=animation_start_time,
            duration=duration,
            vertical_acceleration=vertical_acceleration,
            effect_start_time=effect_start_time,
            splines=splines,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02AE))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # transport: PackedGuid
        _fmt, _data = packed_guid_write(self.transport, _fmt, _data)

        # unknown: u8
        _fmt += 'B'
        _data.append(self.unknown)

        # spline_point: Vector3d
        _fmt, _data = self.spline_point.write(_fmt, _data)

        # spline_id: u32
        _fmt += 'I'
        _data.append(self.spline_id)

        # move_type: MonsterMoveType
        _fmt += 'B'
        _data.append(self.move_type.value)

        if self.move_type == MonsterMoveType.FACING_TARGET:
            _fmt += 'Q'
            _data.append(self.target)
        elif self.move_type == MonsterMoveType.FACING_ANGLE:
            _fmt += 'f'
            _data.append(self.angle)
        elif self.move_type == MonsterMoveType.FACING_SPOT:
            # position: Vector3d
            _fmt, _data = self.position.write(_fmt, _data)

        # spline_flags: SplineFlag
        _fmt += 'I'
        _data.append(self.spline_flags.value)

        if SplineFlag.ENTER_CYCLE in self.spline_flags:
            _fmt += 'II'
            _data.extend([self.animation_id, self.animation_start_time])
        # duration: u32
        _fmt += 'I'
        _data.append(self.duration)

        if SplineFlag.PARABOLIC in self.spline_flags:
            _fmt += 'fI'
            _data.extend([self.vertical_acceleration, self.effect_start_time])
        # splines: MonsterMoveSpline
        _fmt, _data = self.splines.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 26 + packed_guid_size(self.guid) + packed_guid_size(self.transport) + self.splines.size()

        if self.move_type == MonsterMoveType.FACING_TARGET:
            _size += 8
        elif self.move_type == MonsterMoveType.FACING_ANGLE:
            _size += 4
        elif self.move_type == MonsterMoveType.FACING_SPOT:
            _size += 12

        if SplineFlag.ENTER_CYCLE in self.spline_flags:
            _size += 8

        if SplineFlag.PARABOLIC in self.spline_flags:
            _size += 8

        return _size


@dataclasses.dataclass
class SMSG_PET_BROKEN:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_BROKEN:
        return SMSG_PET_BROKEN()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x02AF))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MOVE_FEATHER_FALL_Server:
    player: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_FEATHER_FALL_Server:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_FEATHER_FALL_Server(
            player=player,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02B0))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_WATER_WALK:
    player: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_WATER_WALK:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_WATER_WALK(
            player=player,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02B1))
        _fmt = "<6s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02B1))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class CMSG_SELF_RES:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SELF_RES:
        return CMSG_SELF_RES()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02B3))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_FEIGN_DEATH_RESISTED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FEIGN_DEATH_RESISTED:
        return SMSG_FEIGN_DEATH_RESISTED()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x02B4))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DUEL_COUNTDOWN:
    time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DUEL_COUNTDOWN:
        # time: Seconds
        time = await read_int(reader, 4)

        return SMSG_DUEL_COUNTDOWN(
            time=time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x02B7))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.time)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AREA_TRIGGER_MESSAGE:
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AREA_TRIGGER_MESSAGE:
        # message: SizedCString
        message = await read_sized_cstring(reader)

        return SMSG_AREA_TRIGGER_MESSAGE(
            message=message,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02B8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.message)}sB'
        _data.extend([len(self.message) + 1, self.message.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + len(self.message)


@dataclasses.dataclass
class CMSG_TOGGLE_HELM:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TOGGLE_HELM:
        return CMSG_TOGGLE_HELM()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02B9))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TOGGLE_CLOAK:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TOGGLE_CLOAK:
        return CMSG_TOGGLE_CLOAK()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02BA))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LFG_ROLE_CHOSEN:
    guid: int
    ready: bool
    roles: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LFG_ROLE_CHOSEN:
        # guid: Guid
        guid = await read_int(reader, 8)

        # ready: Bool8
        ready = await read_bool(reader, 1)

        # roles: u32
        roles = await read_int(reader, 4)

        return SMSG_LFG_ROLE_CHOSEN(
            guid=guid,
            ready=ready,
            roles=roles,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(13 + 2, 0x02BB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QBI'
        _data.extend([self.guid, self.ready, self.roles])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PLAYER_SKINNED:
    spirit_released: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAYER_SKINNED:
        # spirit_released: Bool8
        spirit_released = await read_bool(reader, 1)

        return SMSG_PLAYER_SKINNED(
            spirit_released=spirit_released,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x02BC))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.spirit_released)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DURABILITY_DAMAGE_DEATH:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DURABILITY_DAMAGE_DEATH:
        return SMSG_DURABILITY_DAMAGE_DEATH()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x02BD))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_ACTIONBAR_TOGGLES:
    action_bar: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_ACTIONBAR_TOGGLES:
        # action_bar: u8
        action_bar = await read_int(reader, 1)

        return CMSG_SET_ACTIONBAR_TOGGLES(
            action_bar=action_bar,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x02BF))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.action_bar)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_PETITION_RENAME:
    petition: int
    new_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_PETITION_RENAME:
        # petition: Guid
        petition = await read_int(reader, 8)

        # new_name: CString
        new_name = await read_cstring(reader)

        return MSG_PETITION_RENAME(
            petition=petition,
            new_name=new_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02C1))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.new_name)}sB'
        _data.extend([self.petition, self.new_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02C1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'Q{len(self.new_name)}sB'
        _data.extend([self.petition, self.new_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.new_name)


@dataclasses.dataclass
class SMSG_INIT_WORLD_STATES:
    map: Map
    area: Area
    sub_area: Area
    states: typing.List[WorldState]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INIT_WORLD_STATES:
        # map: Map
        map = Map(await read_int(reader, 4))

        # area: Area
        area = Area(await read_int(reader, 4))

        # sub_area: Area
        sub_area = Area(await read_int(reader, 4))

        # amount_of_states: u16
        amount_of_states = await read_int(reader, 2)

        # states: WorldState[amount_of_states]
        states = []
        for _ in range(0, amount_of_states):
            states.append(await WorldState.read(reader))

        return SMSG_INIT_WORLD_STATES(
            map=map,
            area=area,
            sub_area=sub_area,
            states=states,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02C2))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIH'
        _data.extend([self.map.value, self.area.value, self.sub_area.value, len(self.states)])
        # states: WorldState[amount_of_states]
        for i in self.states:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 14 + 8 * len(self.states)


@dataclasses.dataclass
class SMSG_UPDATE_WORLD_STATE:
    state: WorldState

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_UPDATE_WORLD_STATE:
        # state: WorldState
        state = await WorldState.read(reader)

        return SMSG_UPDATE_WORLD_STATE(
            state=state,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x02C3))
        _fmt = "<4s"
        _data = [_data]

        # state: WorldState
        _fmt, _data = self.state.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ITEM_NAME_QUERY:
    item: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ITEM_NAME_QUERY:
        # item: Item
        item = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_ITEM_NAME_QUERY(
            item=item,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x02C4))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.item, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_NAME_QUERY_RESPONSE:
    item: int
    item_name: str
    inventory_type: InventoryType

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_NAME_QUERY_RESPONSE:
        # item: Item
        item = await read_int(reader, 4)

        # item_name: CString
        item_name = await read_cstring(reader)

        # inventory_type: InventoryType
        inventory_type = InventoryType(await read_int(reader, 1))

        return SMSG_ITEM_NAME_QUERY_RESPONSE(
            item=item,
            item_name=item_name,
            inventory_type=inventory_type,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02C5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.item_name)}sBB'
        _data.extend([self.item, self.item_name.encode('utf-8'), 0, self.inventory_type.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 6 + len(self.item_name)


@dataclasses.dataclass
class SMSG_PET_ACTION_FEEDBACK:
    feedback: PetFeedback

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_ACTION_FEEDBACK:
        # feedback: PetFeedback
        feedback = PetFeedback(await read_int(reader, 1))

        return SMSG_PET_ACTION_FEEDBACK(
            feedback=feedback,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x02C6))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.feedback.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CHAR_RENAME:
    character: int
    new_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHAR_RENAME:
        # character: Guid
        character = await read_int(reader, 8)

        # new_name: CString
        new_name = await read_cstring(reader)

        return CMSG_CHAR_RENAME(
            character=character,
            new_name=new_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02C7))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.new_name)}sB'
        _data.extend([self.character, self.new_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.new_name)


@dataclasses.dataclass
class SMSG_CHAR_RENAME:
    result: WorldResult
    character: typing.Optional[int] = None
    new_name: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAR_RENAME:
        character = None
        new_name = None
        # result: WorldResult
        result = WorldResult(await read_int(reader, 1))

        if result == WorldResult.RESPONSE_SUCCESS:
            # character: Guid
            character = await read_int(reader, 8)

            # new_name: CString
            new_name = await read_cstring(reader)

        return SMSG_CHAR_RENAME(
            result=result,
            character=character,
            new_name=new_name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02C8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        if self.result == WorldResult.RESPONSE_SUCCESS:
            _fmt += f'Q{len(self.new_name)}sB'
            _data.extend([self.character, self.new_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.result == WorldResult.RESPONSE_SUCCESS:
            _size += 9 + len(self.new_name)

        return _size


@dataclasses.dataclass
class CMSG_MOVE_SPLINE_DONE:
    info: MovementInfo
    movement_counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_SPLINE_DONE:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        return CMSG_MOVE_SPLINE_DONE(
            info=info,
            movement_counter=movement_counter,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02C9))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # movement_counter: u32
        _fmt += 'I'
        _data.append(self.movement_counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + self.info.size()


@dataclasses.dataclass
class CMSG_MOVE_FALL_RESET:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_FALL_RESET:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return CMSG_MOVE_FALL_RESET(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02CA))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class SMSG_INSTANCE_SAVE_CREATED:
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INSTANCE_SAVE_CREATED:
        # unknown: u32
        unknown = await read_int(reader, 4)

        return SMSG_INSTANCE_SAVE_CREATED(
            unknown=unknown,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x02CB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.unknown)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_RAID_INSTANCE_INFO:
    raid_infos: typing.List[RaidInfo]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RAID_INSTANCE_INFO:
        # amount_of_raid_infos: u32
        amount_of_raid_infos = await read_int(reader, 4)

        # raid_infos: RaidInfo[amount_of_raid_infos]
        raid_infos = []
        for _ in range(0, amount_of_raid_infos):
            raid_infos.append(await RaidInfo.read(reader))

        return SMSG_RAID_INSTANCE_INFO(
            raid_infos=raid_infos,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02CC))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.raid_infos))
        # raid_infos: RaidInfo[amount_of_raid_infos]
        for i in self.raid_infos:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + 22 * len(self.raid_infos)


@dataclasses.dataclass
class CMSG_REQUEST_RAID_INFO:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REQUEST_RAID_INFO:
        return CMSG_REQUEST_RAID_INFO()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02CD))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MOVE_TIME_SKIPPED:
    guid: int
    lag: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_TIME_SKIPPED:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # lag: u32
        lag = await read_int(reader, 4)

        return CMSG_MOVE_TIME_SKIPPED(
            guid=guid,
            lag=lag,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02CE))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # lag: u32
        _fmt += 'I'
        _data.append(self.lag)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_MOVE_FEATHER_FALL_ACK:
    guid: int
    movement_counter: int
    info: MovementInfo
    apply: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_FEATHER_FALL_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # apply: u32
        apply = await read_int(reader, 4)

        return CMSG_MOVE_FEATHER_FALL_ACK(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
            apply=apply,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02CF))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.movement_counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # apply: u32
        _fmt += 'I'
        _data.append(self.apply)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class CMSG_MOVE_WATER_WALK_ACK:
    guid: int
    movement_counter: int
    info: MovementInfo
    apply: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_WATER_WALK_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # apply: u32
        apply = await read_int(reader, 4)

        return CMSG_MOVE_WATER_WALK_ACK(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
            apply=apply,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02D0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.movement_counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # apply: u32
        _fmt += 'I'
        _data.append(self.apply)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class CMSG_MOVE_NOT_ACTIVE_MOVER:
    old_mover: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_NOT_ACTIVE_MOVER:
        # old_mover: Guid
        old_mover = await read_int(reader, 8)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return CMSG_MOVE_NOT_ACTIVE_MOVER(
            old_mover=old_mover,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02D1))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.old_mover)
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + self.info.size()


@dataclasses.dataclass
class SMSG_PLAY_SOUND:
    sound_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAY_SOUND:
        # sound_id: u32
        sound_id = await read_int(reader, 4)

        return SMSG_PLAY_SOUND(
            sound_id=sound_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x02D2))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.sound_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BATTLEFIELD_STATUS:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BATTLEFIELD_STATUS:
        return CMSG_BATTLEFIELD_STATUS()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02D3))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BATTLEFIELD_STATUS:
    queue_slot: int
    arena_type: ArenaType
    is_arena: int
    battleground_type: BattlegroundType
    unknown1: int
    minimum_level: int
    maximum_level: int
    client_instance_id: int
    rated: bool
    status_id: StatusId
    average_wait_time_in_ms: typing.Optional[int] = None
    time_in_queue_in_ms: typing.Optional[int] = None
    map1: typing.Optional[Map] = None
    unknown2: typing.Optional[int] = None
    time_to_remove_in_queue_in_ms: typing.Optional[int] = None
    map2: typing.Optional[Map] = None
    unknown3: typing.Optional[int] = None
    time_to_bg_autoleave_in_ms: typing.Optional[int] = None
    time_to_bg_start_in_ms: typing.Optional[int] = None
    faction: typing.Optional[ArenaFaction] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BATTLEFIELD_STATUS:
        average_wait_time_in_ms = None
        time_in_queue_in_ms = None
        map1 = None
        unknown2 = None
        time_to_remove_in_queue_in_ms = None
        map2 = None
        unknown3 = None
        time_to_bg_autoleave_in_ms = None
        time_to_bg_start_in_ms = None
        faction = None
        # queue_slot: u32
        queue_slot = await read_int(reader, 4)

        # arena_type: ArenaType
        arena_type = ArenaType(await read_int(reader, 1))

        # is_arena: u8
        is_arena = await read_int(reader, 1)

        # battleground_type: BattlegroundType
        battleground_type = BattlegroundType(await read_int(reader, 4))

        # unknown1: u16
        unknown1 = await read_int(reader, 2)

        # minimum_level: u8
        minimum_level = await read_int(reader, 1)

        # maximum_level: u8
        maximum_level = await read_int(reader, 1)

        # client_instance_id: u32
        client_instance_id = await read_int(reader, 4)

        # rated: Bool8
        rated = await read_bool(reader, 1)

        # status_id: StatusId
        status_id = StatusId(await read_int(reader, 1))

        if status_id == StatusId.WAIT_QUEUE:
            # average_wait_time_in_ms: u32
            average_wait_time_in_ms = await read_int(reader, 4)

            # time_in_queue_in_ms: u32
            time_in_queue_in_ms = await read_int(reader, 4)

        elif status_id == StatusId.WAIT_JOIN:
            # map1: Map
            map1 = Map(await read_int(reader, 4))

            # unknown2: u64
            unknown2 = await read_int(reader, 8)

            # time_to_remove_in_queue_in_ms: u32
            time_to_remove_in_queue_in_ms = await read_int(reader, 4)

        elif status_id == StatusId.IN_PROGRESS:
            # map2: Map
            map2 = Map(await read_int(reader, 4))

            # unknown3: u64
            unknown3 = await read_int(reader, 8)

            # time_to_bg_autoleave_in_ms: u32
            time_to_bg_autoleave_in_ms = await read_int(reader, 4)

            # time_to_bg_start_in_ms: u32
            time_to_bg_start_in_ms = await read_int(reader, 4)

            # faction: ArenaFaction
            faction = ArenaFaction(await read_int(reader, 1))

        return SMSG_BATTLEFIELD_STATUS(
            queue_slot=queue_slot,
            arena_type=arena_type,
            is_arena=is_arena,
            battleground_type=battleground_type,
            unknown1=unknown1,
            minimum_level=minimum_level,
            maximum_level=maximum_level,
            client_instance_id=client_instance_id,
            rated=rated,
            status_id=status_id,
            average_wait_time_in_ms=average_wait_time_in_ms,
            time_in_queue_in_ms=time_in_queue_in_ms,
            map1=map1,
            unknown2=unknown2,
            time_to_remove_in_queue_in_ms=time_to_remove_in_queue_in_ms,
            map2=map2,
            unknown3=unknown3,
            time_to_bg_autoleave_in_ms=time_to_bg_autoleave_in_ms,
            time_to_bg_start_in_ms=time_to_bg_start_in_ms,
            faction=faction,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02D4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IBBIHBBIBB'
        _data.extend([self.queue_slot, self.arena_type.value, self.is_arena, self.battleground_type.value, self.unknown1, self.minimum_level, self.maximum_level, self.client_instance_id, self.rated, self.status_id.value])
        if self.status_id == StatusId.WAIT_QUEUE:
            _fmt += 'II'
            _data.extend([self.average_wait_time_in_ms, self.time_in_queue_in_ms])
        elif self.status_id == StatusId.WAIT_JOIN:
            _fmt += 'IQI'
            _data.extend([self.map1.value, self.unknown2, self.time_to_remove_in_queue_in_ms])
        elif self.status_id == StatusId.IN_PROGRESS:
            _fmt += 'IQIIB'
            _data.extend([self.map2.value, self.unknown3, self.time_to_bg_autoleave_in_ms, self.time_to_bg_start_in_ms, self.faction.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 20

        if self.status_id == StatusId.WAIT_QUEUE:
            _size += 8
        elif self.status_id == StatusId.WAIT_JOIN:
            _size += 16
        elif self.status_id == StatusId.IN_PROGRESS:
            _size += 21

        return _size


@dataclasses.dataclass
class CMSG_BATTLEFIELD_PORT:
    arena_type: int
    unknown1: int
    bg_type_id: int
    unknown2: int
    action: BattlefieldPortAction

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BATTLEFIELD_PORT:
        # arena_type: u8
        arena_type = await read_int(reader, 1)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # bg_type_id: u32
        bg_type_id = await read_int(reader, 4)

        # unknown2: u16
        unknown2 = await read_int(reader, 2)

        # action: BattlefieldPortAction
        action = BattlefieldPortAction(await read_int(reader, 1))

        return CMSG_BATTLEFIELD_PORT(
            arena_type=arena_type,
            unknown1=unknown1,
            bg_type_id=bg_type_id,
            unknown2=unknown2,
            action=action,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x02D5))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBIHB'
        _data.extend([self.arena_type, self.unknown1, self.bg_type_id, self.unknown2, self.action.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_INSPECT_HONOR_STATS_Client:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_INSPECT_HONOR_STATS_Client:
        # guid: Guid
        guid = await read_int(reader, 8)

        return MSG_INSPECT_HONOR_STATS_Client(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02D6))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_INSPECT_HONOR_STATS_Server:
    guid: int
    amount_of_honor: int
    kills: int
    honor_today: int
    honor_yesterday: int
    lifetime_honorable_kills: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_INSPECT_HONOR_STATS_Server:
        # guid: Guid
        guid = await read_int(reader, 8)

        # amount_of_honor: u8
        amount_of_honor = await read_int(reader, 1)

        # kills: u32
        kills = await read_int(reader, 4)

        # honor_today: u32
        honor_today = await read_int(reader, 4)

        # honor_yesterday: u32
        honor_yesterday = await read_int(reader, 4)

        # lifetime_honorable_kills: u32
        lifetime_honorable_kills = await read_int(reader, 4)

        return MSG_INSPECT_HONOR_STATS_Server(
            guid=guid,
            amount_of_honor=amount_of_honor,
            kills=kills,
            honor_today=honor_today,
            honor_yesterday=honor_yesterday,
            lifetime_honorable_kills=lifetime_honorable_kills,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(25 + 2, 0x02D6))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QBIIII'
        _data.extend([self.guid, self.amount_of_honor, self.kills, self.honor_today, self.honor_yesterday, self.lifetime_honorable_kills])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BATTLEMASTER_HELLO:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BATTLEMASTER_HELLO:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_BATTLEMASTER_HELLO(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02D7))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_FORCE_WALK_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_WALK_SPEED_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_WALK_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02DA))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_WALK_SPEED_CHANGE_ACK:
    guid: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_WALK_SPEED_CHANGE_ACK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_WALK_SPEED_CHANGE_ACK(
            guid=guid,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02DB))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_SWIM_BACK_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_SWIM_BACK_SPEED_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_SWIM_BACK_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02DC))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK:
    guid: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK(
            guid=guid,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02DD))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_TURN_RATE_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_TURN_RATE_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_TURN_RATE_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02DE))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_TURN_RATE_CHANGE_ACK:
    guid: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_TURN_RATE_CHANGE_ACK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_TURN_RATE_CHANGE_ACK(
            guid=guid,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02DF))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_PVP_LOG_DATA_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_PVP_LOG_DATA_Client:
        return MSG_PVP_LOG_DATA_Client()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02E0))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LEAVE_BATTLEFIELD:
    unknown1: int
    unknown2: int
    map: Map
    unknown3: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LEAVE_BATTLEFIELD:
        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # unknown2: u8
        unknown2 = await read_int(reader, 1)

        # map: Map
        map = Map(await read_int(reader, 4))

        # unknown3: u16
        unknown3 = await read_int(reader, 2)

        return CMSG_LEAVE_BATTLEFIELD(
            unknown1=unknown1,
            unknown2=unknown2,
            map=map,
            unknown3=unknown3,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02E1))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBIH'
        _data.extend([self.unknown1, self.unknown2, self.map.value, self.unknown3])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AREA_SPIRIT_HEALER_QUERY:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AREA_SPIRIT_HEALER_QUERY:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_AREA_SPIRIT_HEALER_QUERY(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02E2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AREA_SPIRIT_HEALER_QUEUE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AREA_SPIRIT_HEALER_QUEUE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_AREA_SPIRIT_HEALER_QUEUE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02E3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AREA_SPIRIT_HEALER_TIME:
    guid: int
    next_resurrect_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AREA_SPIRIT_HEALER_TIME:
        # guid: Guid
        guid = await read_int(reader, 8)

        # next_resurrect_time: u32
        next_resurrect_time = await read_int(reader, 4)

        return SMSG_AREA_SPIRIT_HEALER_TIME(
            guid=guid,
            next_resurrect_time=next_resurrect_time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x02E4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.next_resurrect_time])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_WARDEN_DATA:
    encrypted_data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_WARDEN_DATA:
        _size = 0

        # encrypted_data: u8[-]
        encrypted_data = []
        while _size < body_size:
            encrypted_data.append(await read_int(reader, 1))
            _size += 1

        return SMSG_WARDEN_DATA(
            encrypted_data=encrypted_data,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02E6))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.encrypted_data)}B'
        _data.extend([*self.encrypted_data])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + 1 * len(self.encrypted_data)


@dataclasses.dataclass
class CMSG_WARDEN_DATA:
    encrypted_data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_WARDEN_DATA:
        _size = 0

        # encrypted_data: u8[-]
        encrypted_data = []
        while _size < body_size:
            encrypted_data.append(await read_int(reader, 1))
            _size += 1

        return CMSG_WARDEN_DATA(
            encrypted_data=encrypted_data,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02E7))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.encrypted_data)}B'
        _data.extend([*self.encrypted_data])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + 1 * len(self.encrypted_data)


@dataclasses.dataclass
class SMSG_GROUP_JOINED_BATTLEGROUND:
    id: BgTypeId

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GROUP_JOINED_BATTLEGROUND:
        # id: BgTypeId
        id = BgTypeId(await read_int(reader, 4))

        return SMSG_GROUP_JOINED_BATTLEGROUND(
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x02E8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.id.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_BATTLEGROUND_PLAYER_POSITIONS_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_BATTLEGROUND_PLAYER_POSITIONS_Client:
        return MSG_BATTLEGROUND_PLAYER_POSITIONS_Client()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02E9))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_BATTLEGROUND_PLAYER_POSITIONS_Server:
    teammates: typing.List[BattlegroundPlayerPosition]
    carriers: typing.List[BattlegroundPlayerPosition]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_BATTLEGROUND_PLAYER_POSITIONS_Server:
        # amount_of_teammates: u32
        amount_of_teammates = await read_int(reader, 4)

        # teammates: BattlegroundPlayerPosition[amount_of_teammates]
        teammates = []
        for _ in range(0, amount_of_teammates):
            teammates.append(await BattlegroundPlayerPosition.read(reader))

        # amount_of_carriers: u8
        amount_of_carriers = await read_int(reader, 1)

        # carriers: BattlegroundPlayerPosition[amount_of_carriers]
        carriers = []
        for _ in range(0, amount_of_carriers):
            carriers.append(await BattlegroundPlayerPosition.read(reader))

        return MSG_BATTLEGROUND_PLAYER_POSITIONS_Server(
            teammates=teammates,
            carriers=carriers,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02E9))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.teammates))
        # teammates: BattlegroundPlayerPosition[amount_of_teammates]
        for i in self.teammates:
            _fmt, _data = i.write(_fmt, _data)

        # amount_of_carriers: u8
        _fmt += 'B'
        _data.append(len(self.carriers))

        # carriers: BattlegroundPlayerPosition[amount_of_carriers]
        for i in self.carriers:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + 16 * len(self.teammates) + 16 * len(self.carriers)


@dataclasses.dataclass
class CMSG_PET_STOP_ATTACK:
    pet: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_STOP_ATTACK:
        # pet: Guid
        pet = await read_int(reader, 8)

        return CMSG_PET_STOP_ATTACK(
            pet=pet,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02EA))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.pet)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BINDER_CONFIRM:
    guid: int
    area: Area

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BINDER_CONFIRM:
        # guid: Guid
        guid = await read_int(reader, 8)

        # area: Area
        area = Area(await read_int(reader, 4))

        return SMSG_BINDER_CONFIRM(
            guid=guid,
            area=area,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x02EB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.area.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BATTLEGROUND_PLAYER_JOINED:
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BATTLEGROUND_PLAYER_JOINED:
        # player: Guid
        player = await read_int(reader, 8)

        return SMSG_BATTLEGROUND_PLAYER_JOINED(
            player=player,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x02EC))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.player)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BATTLEGROUND_PLAYER_LEFT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BATTLEGROUND_PLAYER_LEFT:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_BATTLEGROUND_PLAYER_LEFT(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x02ED))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BATTLEMASTER_JOIN:
    guid: int
    map: Map
    instance_id: int
    join_as_group: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BATTLEMASTER_JOIN:
        # guid: Guid
        guid = await read_int(reader, 8)

        # map: Map
        map = Map(await read_int(reader, 4))

        # instance_id: u32
        instance_id = await read_int(reader, 4)

        # join_as_group: Bool8
        join_as_group = await read_bool(reader, 1)

        return CMSG_BATTLEMASTER_JOIN(
            guid=guid,
            map=map,
            instance_id=instance_id,
            join_as_group=join_as_group,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(17 + 4, 0x02EE))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIIB'
        _data.extend([self.guid, self.map.value, self.instance_id, self.join_as_group])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ADDON_INFO:
    addons: AddonArray

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ADDON_INFO:
        # addons: AddonArray
        addons = await CacheMask.read(reader)

        # number_of_banned_addons: u32
        _number_of_banned_addons = await read_int(reader, 4)

        return SMSG_ADDON_INFO(
            addons=addons,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02EF))
        _fmt = "<4s"
        _data = [_data]

        # addons: AddonArray
        _fmt, _data = self.addons.write(_fmt, _data)

        # number_of_banned_addons: u32
        _fmt += 'I'
        _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + self.addons.size()


@dataclasses.dataclass
class CMSG_PET_UNLEARN:
    pet: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_UNLEARN:
        # pet: Guid
        pet = await read_int(reader, 8)

        return CMSG_PET_UNLEARN(
            pet=pet,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02F0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.pet)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PET_UNLEARN_CONFIRM:
    pet: int
    talent_reset_cost: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_UNLEARN_CONFIRM:
        # pet: Guid
        pet = await read_int(reader, 8)

        # talent_reset_cost: u32
        talent_reset_cost = await read_int(reader, 4)

        return SMSG_PET_UNLEARN_CONFIRM(
            pet=pet,
            talent_reset_cost=talent_reset_cost,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x02F1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.pet, self.talent_reset_cost])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PARTY_MEMBER_STATS_FULL:
    guid: int
    mask: GroupUpdateFlags
    status: typing.Optional[GroupMemberOnlineStatus] = None
    current_health: typing.Optional[int] = None
    max_health: typing.Optional[int] = None
    power: typing.Optional[Power] = None
    current_power: typing.Optional[int] = None
    max_power: typing.Optional[int] = None
    level: typing.Optional[int] = None
    area: typing.Optional[Area] = None
    position_x: typing.Optional[int] = None
    position_y: typing.Optional[int] = None
    auras: typing.Optional[AuraMask] = None
    pet: typing.Optional[int] = None
    pet_name: typing.Optional[str] = None
    pet_display_id: typing.Optional[int] = None
    pet_current_health: typing.Optional[int] = None
    pet_max_health: typing.Optional[int] = None
    pet_power_type: typing.Optional[Power] = None
    pet_current_power: typing.Optional[int] = None
    pet_max_power: typing.Optional[int] = None
    pet_auras: typing.Optional[AuraMask] = None
    transport: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PARTY_MEMBER_STATS_FULL:
        status = None
        current_health = None
        max_health = None
        power = None
        current_power = None
        max_power = None
        level = None
        area = None
        position_x = None
        position_y = None
        auras = None
        pet = None
        pet_name = None
        pet_display_id = None
        pet_current_health = None
        pet_max_health = None
        pet_power_type = None
        pet_current_power = None
        pet_max_power = None
        pet_auras = None
        transport = None
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # mask: GroupUpdateFlags
        mask = GroupUpdateFlags(await read_int(reader, 4))

        if GroupUpdateFlags.STATUS in mask:
            # status: GroupMemberOnlineStatus
            status = GroupMemberOnlineStatus(await read_int(reader, 1))

        if GroupUpdateFlags.CUR_HP in mask:
            # current_health: u32
            current_health = await read_int(reader, 4)

        if GroupUpdateFlags.MAX_HP in mask:
            # max_health: u32
            max_health = await read_int(reader, 4)

        if GroupUpdateFlags.POWER_TYPE in mask:
            # power: Power
            power = Power(await read_int(reader, 1))

        if GroupUpdateFlags.CUR_POWER in mask:
            # current_power: u16
            current_power = await read_int(reader, 2)

        if GroupUpdateFlags.MAX_POWER in mask:
            # max_power: u16
            max_power = await read_int(reader, 2)

        if GroupUpdateFlags.LEVEL in mask:
            # level: Level16
            level = await read_int(reader, 2)

        if GroupUpdateFlags.ZONE in mask:
            # area: Area
            area = Area(await read_int(reader, 4))

        if GroupUpdateFlags.POSITION in mask:
            # position_x: u16
            position_x = await read_int(reader, 2)

            # position_y: u16
            position_y = await read_int(reader, 2)

        if GroupUpdateFlags.AURAS in mask:
            # auras: AuraMask
            auras = await AuraMask.read(reader)

        if GroupUpdateFlags.PET_GUID in mask:
            # pet: Guid
            pet = await read_int(reader, 8)

        if GroupUpdateFlags.PET_NAME in mask:
            # pet_name: CString
            pet_name = await read_cstring(reader)

        if GroupUpdateFlags.PET_MODEL_ID in mask:
            # pet_display_id: u16
            pet_display_id = await read_int(reader, 2)

        if GroupUpdateFlags.PET_CUR_HP in mask:
            # pet_current_health: u32
            pet_current_health = await read_int(reader, 4)

        if GroupUpdateFlags.PET_MAX_HP in mask:
            # pet_max_health: u32
            pet_max_health = await read_int(reader, 4)

        if GroupUpdateFlags.PET_POWER_TYPE in mask:
            # pet_power_type: Power
            pet_power_type = Power(await read_int(reader, 1))

        if GroupUpdateFlags.PET_CUR_POWER in mask:
            # pet_current_power: u16
            pet_current_power = await read_int(reader, 2)

        if GroupUpdateFlags.PET_MAX_POWER in mask:
            # pet_max_power: u16
            pet_max_power = await read_int(reader, 2)

        if GroupUpdateFlags.PET_AURAS in mask:
            # pet_auras: AuraMask
            pet_auras = await AuraMask.read(reader)

        if GroupUpdateFlags.VEHICLE_SEAT in mask:
            # transport: u32
            transport = await read_int(reader, 4)

        return SMSG_PARTY_MEMBER_STATS_FULL(
            guid=guid,
            mask=mask,
            status=status,
            current_health=current_health,
            max_health=max_health,
            power=power,
            current_power=current_power,
            max_power=max_power,
            level=level,
            area=area,
            position_x=position_x,
            position_y=position_y,
            auras=auras,
            pet=pet,
            pet_name=pet_name,
            pet_display_id=pet_display_id,
            pet_current_health=pet_current_health,
            pet_max_health=pet_max_health,
            pet_power_type=pet_power_type,
            pet_current_power=pet_current_power,
            pet_max_power=pet_max_power,
            pet_auras=pet_auras,
            transport=transport,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02F2))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # mask: GroupUpdateFlags
        _fmt += 'I'
        _data.append(self.mask.value)

        if GroupUpdateFlags.STATUS in self.mask:
            _fmt += 'B'
            _data.append(self.status.value)
        if GroupUpdateFlags.CUR_HP in self.mask:
            _fmt += 'I'
            _data.append(self.current_health)
        if GroupUpdateFlags.MAX_HP in self.mask:
            _fmt += 'I'
            _data.append(self.max_health)
        if GroupUpdateFlags.POWER_TYPE in self.mask:
            _fmt += 'B'
            _data.append(self.power.value)
        if GroupUpdateFlags.CUR_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.current_power)
        if GroupUpdateFlags.MAX_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.max_power)
        if GroupUpdateFlags.LEVEL in self.mask:
            _fmt += 'H'
            _data.append(self.level)
        if GroupUpdateFlags.ZONE in self.mask:
            _fmt += 'I'
            _data.append(self.area.value)
        if GroupUpdateFlags.POSITION in self.mask:
            _fmt += 'HH'
            _data.extend([self.position_x, self.position_y])
        if GroupUpdateFlags.AURAS in self.mask:
            # auras: AuraMask
            _fmt, _data = self.auras.write(_fmt, _data)

        if GroupUpdateFlags.PET_GUID in self.mask:
            _fmt += 'Q'
            _data.append(self.pet)
        if GroupUpdateFlags.PET_NAME in self.mask:
            _fmt += f'{len(self.pet_name)}sB'
            _data.extend([self.pet_name.encode('utf-8'), 0])
        if GroupUpdateFlags.PET_MODEL_ID in self.mask:
            _fmt += 'H'
            _data.append(self.pet_display_id)
        if GroupUpdateFlags.PET_CUR_HP in self.mask:
            _fmt += 'I'
            _data.append(self.pet_current_health)
        if GroupUpdateFlags.PET_MAX_HP in self.mask:
            _fmt += 'I'
            _data.append(self.pet_max_health)
        if GroupUpdateFlags.PET_POWER_TYPE in self.mask:
            _fmt += 'B'
            _data.append(self.pet_power_type.value)
        if GroupUpdateFlags.PET_CUR_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.pet_current_power)
        if GroupUpdateFlags.PET_MAX_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.pet_max_power)
        if GroupUpdateFlags.PET_AURAS in self.mask:
            # pet_auras: AuraMask
            _fmt, _data = self.pet_auras.write(_fmt, _data)

        if GroupUpdateFlags.VEHICLE_SEAT in self.mask:
            _fmt += 'I'
            _data.append(self.transport)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4 + packed_guid_size(self.guid)

        if GroupUpdateFlags.STATUS in self.mask:
            _size += 1

        if GroupUpdateFlags.CUR_HP in self.mask:
            _size += 4

        if GroupUpdateFlags.MAX_HP in self.mask:
            _size += 4

        if GroupUpdateFlags.POWER_TYPE in self.mask:
            _size += 1

        if GroupUpdateFlags.CUR_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.MAX_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.LEVEL in self.mask:
            _size += 2

        if GroupUpdateFlags.ZONE in self.mask:
            _size += 4

        if GroupUpdateFlags.POSITION in self.mask:
            _size += 4

        if GroupUpdateFlags.AURAS in self.mask:
            _size += 0 + self.auras.size()

        if GroupUpdateFlags.PET_GUID in self.mask:
            _size += 8

        if GroupUpdateFlags.PET_NAME in self.mask:
            _size += 1 + len(self.pet_name)

        if GroupUpdateFlags.PET_MODEL_ID in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_CUR_HP in self.mask:
            _size += 4

        if GroupUpdateFlags.PET_MAX_HP in self.mask:
            _size += 4

        if GroupUpdateFlags.PET_POWER_TYPE in self.mask:
            _size += 1

        if GroupUpdateFlags.PET_CUR_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_MAX_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_AURAS in self.mask:
            _size += 0 + self.pet_auras.size()

        if GroupUpdateFlags.VEHICLE_SEAT in self.mask:
            _size += 4

        return _size


@dataclasses.dataclass
class CMSG_PET_SPELL_AUTOCAST:
    guid: int
    id: int
    autocast_enabled: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_SPELL_AUTOCAST:
        # guid: Guid
        guid = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        # autocast_enabled: Bool8
        autocast_enabled = await read_bool(reader, 1)

        return CMSG_PET_SPELL_AUTOCAST(
            guid=guid,
            id=id,
            autocast_enabled=autocast_enabled,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(13 + 4, 0x02F3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIB'
        _data.extend([self.guid, self.id, self.autocast_enabled])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_WEATHER:
    weather_type: WeatherType
    grade: float
    change: WeatherChangeType

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_WEATHER:
        # weather_type: WeatherType
        weather_type = WeatherType(await read_int(reader, 4))

        # grade: f32
        grade = await read_float(reader)

        # change: WeatherChangeType
        change = WeatherChangeType(await read_int(reader, 1))

        return SMSG_WEATHER(
            weather_type=weather_type,
            grade=grade,
            change=change,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x02F4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IfB'
        _data.extend([self.weather_type.value, self.grade, self.change.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_RAID_INSTANCE_MESSAGE:
    message_type: RaidInstanceMessage
    map: Map
    difficulty: RaidDifficulty
    time_left: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RAID_INSTANCE_MESSAGE:
        # message_type: RaidInstanceMessage
        message_type = RaidInstanceMessage(await read_int(reader, 4))

        # map: Map
        map = Map(await read_int(reader, 4))

        # difficulty: RaidDifficulty
        difficulty = RaidDifficulty(await read_int(reader, 4))

        # time_left: u32
        time_left = await read_int(reader, 4)

        return SMSG_RAID_INSTANCE_MESSAGE(
            message_type=message_type,
            map=map,
            difficulty=difficulty,
            time_left=time_left,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x02FA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIII'
        _data.extend([self.message_type.value, self.map.value, self.difficulty.value, self.time_left])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_COMPRESSED_MOVES:
    moves: typing.List[MiniMoveMessage]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_COMPRESSED_MOVES:
        decompressed_size = await read_int(reader, 4)
        compressed_bytes = await reader.readexactly(body_size - 4)
        decompressed_bytes = zlib.decompress(compressed_bytes, bufsize=decompressed_size)
        reader = asyncio.StreamReader()
        reader.feed_data(decompressed_bytes)
        reader.feed_eof()


        _size = 0

        # size: u32
        _size = await read_int(reader, 4)
        _size += 4

        # moves: MiniMoveMessage[-]
        moves = []
        while not reader.at_eof():
            moves.append(await MiniMoveMessage.read(reader))
            _size += moves[-1].size()

        return SMSG_COMPRESSED_MOVES(
            moves=moves,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02FB))
        _fmt = "<4s"
        _data = [_data]

        _compressed_fmt = "<"
        _compressed_data = []

        _fmt += 'I'
        _data.append(self.size())
        # moves: MiniMoveMessage[-]
        for i in self.moves:
            _compressed_fmt, _compressed_data = i.write(_compressed_fmt, _compressed_data)

        _uncompressed_data = struct.pack(_compressed_fmt, *_compressed_data)
        _compressed_data = zlib.compress(_uncompressed_data)

        _fmt += 'I'
        _data.append(len(_uncompressed_data))

        _fmt += f'{len(_compressed_data)}s'
        _data.append(_compressed_data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _fmt = ''
        _data = []

        # size: u32
        _fmt += 'I'
        _data.append(self.size())

        # moves: MiniMoveMessage[-]
        for i in self.moves:
            _fmt, _data = i.write(_fmt, _data)

        _uncompressed_data = struct.pack(_fmt, *_data)
        _compressed_data = zlib.compress(_uncompressed_data)
        return len(_compressed_data) + 4


@dataclasses.dataclass
class CMSG_GUILD_INFO_TEXT:
    guild_info: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_INFO_TEXT:
        # guild_info: CString
        guild_info = await read_cstring(reader)

        return CMSG_GUILD_INFO_TEXT(
            guild_info=guild_info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02FC))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.guild_info)}sB'
        _data.extend([self.guild_info.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.guild_info)


@dataclasses.dataclass
class SMSG_CHAT_RESTRICTED:
    restriction: ChatRestrictionType

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAT_RESTRICTED:
        # restriction: ChatRestrictionType
        restriction = ChatRestrictionType(await read_int(reader, 1))

        return SMSG_CHAT_RESTRICTED(
            restriction=restriction,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x02FD))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.restriction.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPLINE_SET_RUN_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_RUN_SPEED:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_RUN_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02FE))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_RUN_BACK_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_RUN_BACK_SPEED:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_RUN_BACK_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02FF))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_SWIM_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_SWIM_SPEED:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_SWIM_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0300))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_WALK_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_WALK_SPEED:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_WALK_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0301))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_SWIM_BACK_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_SWIM_BACK_SPEED:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_SWIM_BACK_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0302))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_TURN_RATE:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_TURN_RATE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_TURN_RATE(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0303))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_UNROOT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_UNROOT:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_UNROOT(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0304))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_FEATHER_FALL:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_FEATHER_FALL:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_FEATHER_FALL(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0305))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_NORMAL_FALL:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_NORMAL_FALL:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_NORMAL_FALL(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0306))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_SET_HOVER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_SET_HOVER:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_SET_HOVER(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0307))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_UNSET_HOVER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_UNSET_HOVER:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_UNSET_HOVER(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0308))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_WATER_WALK:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_WATER_WALK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_WATER_WALK(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0309))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_LAND_WALK:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_LAND_WALK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_LAND_WALK(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x030A))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_START_SWIM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_START_SWIM:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_START_SWIM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x030B))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_STOP_SWIM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_STOP_SWIM:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_STOP_SWIM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x030C))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_SET_RUN_MODE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_SET_RUN_MODE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_SET_RUN_MODE(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x030D))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_SET_WALK_MODE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_SET_WALK_MODE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_SET_WALK_MODE(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x030E))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_ACTIVATETAXIEXPRESS:
    guid: int
    nodes: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ACTIVATETAXIEXPRESS:
        # guid: Guid
        guid = await read_int(reader, 8)

        # node_count: u32
        node_count = await read_int(reader, 4)

        # nodes: u32[node_count]
        nodes = []
        for _ in range(0, node_count):
            nodes.append(await read_int(reader, 4))

        return CMSG_ACTIVATETAXIEXPRESS(
            guid=guid,
            nodes=nodes,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0312))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'QI{len(self.nodes)}I'
        _data.extend([self.guid, len(self.nodes), *self.nodes])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + 4 * len(self.nodes)


@dataclasses.dataclass
class CMSG_SET_FACTION_INACTIVE:
    faction: Faction
    inactive: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_FACTION_INACTIVE:
        # faction: Faction
        faction = Faction(await read_int(reader, 2))

        # inactive: Bool8
        inactive = await read_bool(reader, 1)

        return CMSG_SET_FACTION_INACTIVE(
            faction=faction,
            inactive=inactive,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(3 + 4, 0x0317))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'HB'
        _data.extend([self.faction.value, self.inactive])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_WATCHED_FACTION:
    faction: Faction

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_WATCHED_FACTION:
        # faction: Faction
        faction = Faction(await read_int(reader, 2))

        return CMSG_SET_WATCHED_FACTION(
            faction=faction,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x0318))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'H'
        _data.append(self.faction.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MOVE_TIME_SKIPPED_Server:
    player: int
    time_skipped: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_TIME_SKIPPED_Server:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # time_skipped: u32
        time_skipped = await read_int(reader, 4)

        return MSG_MOVE_TIME_SKIPPED_Server(
            player=player,
            time_skipped=time_skipped,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0319))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # time_skipped: u32
        _fmt += 'I'
        _data.append(self.time_skipped)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.player)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_ROOT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_ROOT:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_SPLINE_MOVE_ROOT(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x031A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_INVALIDATE_PLAYER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INVALIDATE_PLAYER:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_INVALIDATE_PLAYER(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x031C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_RESET_INSTANCES:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_RESET_INSTANCES:
        return CMSG_RESET_INSTANCES()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x031D))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_INSTANCE_RESET:
    map: Map

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INSTANCE_RESET:
        # map: Map
        map = Map(await read_int(reader, 4))

        return SMSG_INSTANCE_RESET(
            map=map,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x031E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_INSTANCE_RESET_FAILED:
    reason: InstanceResetFailedReason
    map: Map

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INSTANCE_RESET_FAILED:
        # reason: InstanceResetFailedReason
        reason = InstanceResetFailedReason(await read_int(reader, 4))

        # map: Map
        map = Map(await read_int(reader, 4))

        return SMSG_INSTANCE_RESET_FAILED(
            reason=reason,
            map=map,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x031F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.reason.value, self.map.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_UPDATE_LAST_INSTANCE:
    map: Map

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_UPDATE_LAST_INSTANCE:
        # map: Map
        map = Map(await read_int(reader, 4))

        return SMSG_UPDATE_LAST_INSTANCE(
            map=map,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0320))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_RAID_TARGET_UPDATE_Client:
    target_index: RaidTargetIndex
    target: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RAID_TARGET_UPDATE_Client:
        target = None
        # target_index: RaidTargetIndex
        target_index = RaidTargetIndex(await read_int(reader, 1))

        if target_index in {RaidTargetIndex.UNKNOWN0, RaidTargetIndex.UNKNOWN1, RaidTargetIndex.UNKNOWN2, RaidTargetIndex.UNKNOWN3, RaidTargetIndex.UNKNOWN4, RaidTargetIndex.UNKNOWN5, RaidTargetIndex.UNKNOWN6, RaidTargetIndex.UNKNOWN7, RaidTargetIndex.UNKNOWN8}:
            # target: Guid
            target = await read_int(reader, 8)

        return MSG_RAID_TARGET_UPDATE_Client(
            target_index=target_index,
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0321))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.target_index.value)
        if self.target_index in {RaidTargetIndex.UNKNOWN0, RaidTargetIndex.UNKNOWN1, RaidTargetIndex.UNKNOWN2, RaidTargetIndex.UNKNOWN3, RaidTargetIndex.UNKNOWN4, RaidTargetIndex.UNKNOWN5, RaidTargetIndex.UNKNOWN6, RaidTargetIndex.UNKNOWN7, RaidTargetIndex.UNKNOWN8}:
            _fmt += 'Q'
            _data.append(self.target)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.target_index in {RaidTargetIndex.UNKNOWN0, RaidTargetIndex.UNKNOWN1, RaidTargetIndex.UNKNOWN2, RaidTargetIndex.UNKNOWN3, RaidTargetIndex.UNKNOWN4, RaidTargetIndex.UNKNOWN5, RaidTargetIndex.UNKNOWN6, RaidTargetIndex.UNKNOWN7, RaidTargetIndex.UNKNOWN8}:
            _size += 8

        return _size


@dataclasses.dataclass
class MSG_RAID_TARGET_UPDATE_Server:
    update_type: RaidTargetUpdateType
    raid_targets: typing.Optional[typing.List[RaidTargetUpdate]] = None
    raid_target: typing.Optional[RaidTargetUpdate] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RAID_TARGET_UPDATE_Server:
        raid_targets = None
        raid_target = None
        # update_type: RaidTargetUpdateType
        update_type = RaidTargetUpdateType(await read_int(reader, 1))

        if update_type == RaidTargetUpdateType.FULL:
            # raid_targets: RaidTargetUpdate[8]
            raid_targets = []
            for _ in range(0, 8):
                raid_targets.append(await RaidTargetUpdate.read(reader))

        elif update_type == RaidTargetUpdateType.PARTIAL:
            # raid_target: RaidTargetUpdate
            raid_target = await RaidTargetUpdate.read(reader)

        return MSG_RAID_TARGET_UPDATE_Server(
            update_type=update_type,
            raid_targets=raid_targets,
            raid_target=raid_target,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0321))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.update_type.value)
        if self.update_type == RaidTargetUpdateType.FULL:
            # raid_targets: RaidTargetUpdate[8]
            for i in self.raid_targets:
                _fmt, _data = i.write(_fmt, _data)

        elif self.update_type == RaidTargetUpdateType.PARTIAL:
            # raid_target: RaidTargetUpdate
            _fmt, _data = self.raid_target.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.update_type == RaidTargetUpdateType.FULL:
            _size += 72
        elif self.update_type == RaidTargetUpdateType.PARTIAL:
            _size += 9

        return _size


@dataclasses.dataclass
class MSG_RAID_READY_CHECK_Client:
    state: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RAID_READY_CHECK_Client:
        state = None
        _size = 0

        # answer: optional
        if _size < body_size:
            # state: u8
            state = await read_int(reader, 1)
            _size += 1

        return MSG_RAID_READY_CHECK_Client(
            state=state,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0322))
        _fmt = "<6s"
        _data = [_data]

        # answer: optional
        if self.state is not None:
            _fmt += 'B'
            _data.append(self.state)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 0

        # answer: optional
        if self.state is not None:
            _size += 1

        return _size


@dataclasses.dataclass
class MSG_RAID_READY_CHECK_Server:
    guid: typing.Optional[int] = None
    state: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RAID_READY_CHECK_Server:
        guid = None
        state = None
        _size = 0

        # state_check: optional
        if _size < body_size:
            # guid: Guid
            guid = await read_int(reader, 8)
            _size += 8

            # state: u8
            state = await read_int(reader, 1)
            _size += 1

        return MSG_RAID_READY_CHECK_Server(
            guid=guid,
            state=state,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0322))
        _fmt = "<4s"
        _data = [_data]

        # state_check: optional
        if self.guid is not None and self.state is not None:
            _fmt += 'QB'
            _data.extend([self.guid, self.state])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 0

        # state_check: optional
        if self.guid is not None and self.state is not None:
            _size += 9

        return _size


@dataclasses.dataclass
class SMSG_PET_ACTION_SOUND:
    guid: int
    reason: PetTalkReason

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_ACTION_SOUND:
        # guid: Guid
        guid = await read_int(reader, 8)

        # reason: PetTalkReason
        reason = PetTalkReason(await read_int(reader, 4))

        return SMSG_PET_ACTION_SOUND(
            guid=guid,
            reason=reason,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0324))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.reason.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PET_DISMISS_SOUND:
    sound_id: int
    position: Vector3d

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_DISMISS_SOUND:
        # sound_id: u32
        sound_id = await read_int(reader, 4)

        # position: Vector3d
        position = await Vector3d.read(reader)

        return SMSG_PET_DISMISS_SOUND(
            sound_id=sound_id,
            position=position,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x0325))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.sound_id)
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GM_TICKET_STATUS_UPDATE:
    response: GmTicketStatusResponse

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GM_TICKET_STATUS_UPDATE:
        # response: GmTicketStatusResponse
        response = GmTicketStatusResponse(await read_int(reader, 4))

        return SMSG_GM_TICKET_STATUS_UPDATE(
            response=response,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0328))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.response.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_SET_DUNGEON_DIFFICULTY_Client:
    difficulty: DungeonDifficulty

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_SET_DUNGEON_DIFFICULTY_Client:
        # difficulty: DungeonDifficulty
        difficulty = DungeonDifficulty(await read_int(reader, 4))

        return MSG_SET_DUNGEON_DIFFICULTY_Client(
            difficulty=difficulty,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0329))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.difficulty.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_SET_DUNGEON_DIFFICULTY_Server:
    difficulty: DungeonDifficulty
    unknown1: int
    is_in_group: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_SET_DUNGEON_DIFFICULTY_Server:
        # difficulty: DungeonDifficulty
        difficulty = DungeonDifficulty(await read_int(reader, 4))

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # is_in_group: Bool32
        is_in_group = await read_bool(reader, 4)

        return MSG_SET_DUNGEON_DIFFICULTY_Server(
            difficulty=difficulty,
            unknown1=unknown1,
            is_in_group=is_in_group,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0329))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'III'
        _data.extend([self.difficulty.value, self.unknown1, self.is_in_group])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GMSURVEY_SUBMIT:
    survey_id: int
    questions: typing.List[GmSurveyQuestion]
    answer_comment: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GMSURVEY_SUBMIT:
        # survey_id: u32
        survey_id = await read_int(reader, 4)

        # questions: GmSurveyQuestion[10]
        questions = []
        for _ in range(0, 10):
            questions.append(await GmSurveyQuestion.read(reader))

        # answer_comment: CString
        answer_comment = await read_cstring(reader)

        return CMSG_GMSURVEY_SUBMIT(
            survey_id=survey_id,
            questions=questions,
            answer_comment=answer_comment,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x032A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.survey_id)
        # questions: GmSurveyQuestion[10]
        for i in self.questions:
            _fmt, _data = i.write(_fmt, _data)

        # answer_comment: CString
        _fmt += f'{len(self.answer_comment)}sB'
        _data.extend([self.answer_comment.encode('utf-8'), 0])

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + sum([i.size() for i in self.questions]) + len(self.answer_comment)


@dataclasses.dataclass
class SMSG_UPDATE_INSTANCE_OWNERSHIP:
    player_is_saved_to_a_raid: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_UPDATE_INSTANCE_OWNERSHIP:
        # player_is_saved_to_a_raid: Bool32
        player_is_saved_to_a_raid = await read_bool(reader, 4)

        return SMSG_UPDATE_INSTANCE_OWNERSHIP(
            player_is_saved_to_a_raid=player_is_saved_to_a_raid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x032B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.player_is_saved_to_a_raid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CHAT_PLAYER_AMBIGUOUS:
    player: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAT_PLAYER_AMBIGUOUS:
        # player: CString
        player = await read_cstring(reader)

        return SMSG_CHAT_PLAYER_AMBIGUOUS(
            player=player,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x032D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.player)}sB'
        _data.extend([self.player.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.player)


@dataclasses.dataclass
class SMSG_SPELLINSTAKILLLOG:
    caster: int
    target: int
    spell: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLINSTAKILLLOG:
        # caster: Guid
        caster = await read_int(reader, 8)

        # target: Guid
        target = await read_int(reader, 8)

        # spell: Spell
        spell = await read_int(reader, 4)

        return SMSG_SPELLINSTAKILLLOG(
            caster=caster,
            target=target,
            spell=spell,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x032F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQI'
        _data.extend([self.caster, self.target, self.spell])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELL_UPDATE_CHAIN_TARGETS:
    caster: int
    spell: int
    targets: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELL_UPDATE_CHAIN_TARGETS:
        # caster: Guid
        caster = await read_int(reader, 8)

        # spell: Spell
        spell = await read_int(reader, 4)

        # amount_of_targets: u32
        amount_of_targets = await read_int(reader, 4)

        # targets: Guid[amount_of_targets]
        targets = []
        for _ in range(0, amount_of_targets):
            targets.append(await read_int(reader, 8))

        return SMSG_SPELL_UPDATE_CHAIN_TARGETS(
            caster=caster,
            spell=spell,
            targets=targets,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0330))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QII{len(self.targets)}Q'
        _data.extend([self.caster, self.spell, len(self.targets), *self.targets])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + 8 * len(self.targets)


@dataclasses.dataclass
class SMSG_SPELLSTEALLOG:
    victim: int
    caster: int
    spell: int
    unknown: int
    spell_steals: typing.List[SpellSteal]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLSTEALLOG:
        # victim: PackedGuid
        victim = await read_packed_guid(reader)

        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # spell: Spell
        spell = await read_int(reader, 4)

        # unknown: u8
        unknown = await read_int(reader, 1)

        # amount_of_spell_steals: u32
        amount_of_spell_steals = await read_int(reader, 4)

        # spell_steals: SpellSteal[amount_of_spell_steals]
        spell_steals = []
        for _ in range(0, amount_of_spell_steals):
            spell_steals.append(await SpellSteal.read(reader))

        return SMSG_SPELLSTEALLOG(
            victim=victim,
            caster=caster,
            spell=spell,
            unknown=unknown,
            spell_steals=spell_steals,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0333))
        _fmt = "<4s"
        _data = [_data]

        # victim: PackedGuid
        _fmt, _data = packed_guid_write(self.victim, _fmt, _data)

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # unknown: u8
        _fmt += 'B'
        _data.append(self.unknown)

        # amount_of_spell_steals: u32
        _fmt += 'I'
        _data.append(len(self.spell_steals))

        # spell_steals: SpellSteal[amount_of_spell_steals]
        for i in self.spell_steals:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + packed_guid_size(self.victim) + packed_guid_size(self.caster) + 5 * len(self.spell_steals)


@dataclasses.dataclass
class SMSG_DEFENSE_MESSAGE:
    area: Area
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DEFENSE_MESSAGE:
        # area: Area
        area = Area(await read_int(reader, 4))

        # message: SizedCString
        message = await read_sized_cstring(reader)

        return SMSG_DEFENSE_MESSAGE(
            area=area,
            message=message,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x033A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'II{len(self.message)}sB'
        _data.extend([self.area.value, len(self.message) + 1, self.message.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.message)


@dataclasses.dataclass
class SMSG_INSTANCE_DIFFICULTY:
    difficulty: int
    dynamic_difficulty: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INSTANCE_DIFFICULTY:
        # difficulty: u32
        difficulty = await read_int(reader, 4)

        # dynamic_difficulty: Bool32
        dynamic_difficulty = await read_bool(reader, 4)

        return SMSG_INSTANCE_DIFFICULTY(
            difficulty=difficulty,
            dynamic_difficulty=dynamic_difficulty,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x033B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.difficulty, self.dynamic_difficulty])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MOTD:
    motds: typing.List[str]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOTD:
        # amount_of_motds: u32
        amount_of_motds = await read_int(reader, 4)

        # motds: CString[amount_of_motds]
        motds = []
        for _ in range(0, amount_of_motds):
            motds.append(await read_cstring(reader))

        return SMSG_MOTD(
            motds=motds,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x033D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.motds))
        # motds: CString[amount_of_motds]
        for i in self.motds:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + sum([len(i) + 1 for i in self.motds])


@dataclasses.dataclass
class CMSG_MOVE_SET_CAN_TRANSITION_BETWEEN_SWIM_AND_FLY_ACK:
    guid: int
    unknown1: int
    info: MovementInfo
    unknown2: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_SET_CAN_TRANSITION_BETWEEN_SWIM_AND_FLY_ACK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # unknown2: u32
        unknown2 = await read_int(reader, 4)

        return CMSG_MOVE_SET_CAN_TRANSITION_BETWEEN_SWIM_AND_FLY_ACK(
            guid=guid,
            unknown1=unknown1,
            info=info,
            unknown2=unknown2,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0340))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # unknown1: u32
        _fmt += 'I'
        _data.append(self.unknown1)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # unknown2: u32
        _fmt += 'I'
        _data.append(self.unknown2)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class SMSG_MOVE_SET_CAN_FLY:
    player: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_SET_CAN_FLY:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_SET_CAN_FLY(
            player=player,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0343))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.player)


@dataclasses.dataclass
class SMSG_MOVE_UNSET_CAN_FLY:
    player: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_UNSET_CAN_FLY:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_UNSET_CAN_FLY(
            player=player,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0344))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.player)


@dataclasses.dataclass
class CMSG_MOVE_SET_CAN_FLY_ACK:
    player: int
    counter: int
    info: MovementInfo
    applied: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_SET_CAN_FLY_ACK:
        # player: Guid
        player = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # applied: Bool32
        applied = await read_bool(reader, 4)

        return CMSG_MOVE_SET_CAN_FLY_ACK(
            player=player,
            counter=counter,
            info=info,
            applied=applied,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0345))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.player, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # applied: Bool32
        _fmt += 'I'
        _data.append(self.applied)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class CMSG_MOVE_SET_FLY:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_SET_FLY:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return CMSG_MOVE_SET_FLY(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0346))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class CMSG_SOCKET_GEMS:
    item: int
    gems: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SOCKET_GEMS:
        # item: Guid
        item = await read_int(reader, 8)

        # gems: Guid[3]
        gems = []
        for _ in range(0, 3):
            gems.append(await read_int(reader, 8))

        return CMSG_SOCKET_GEMS(
            item=item,
            gems=gems,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(32 + 4, 0x0347))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.gems)}Q'
        _data.extend([self.item, *self.gems])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ARENA_TEAM_COMMAND_RESULT:
    command: ArenaTeamCommand
    team: str
    player: str
    error: ArenaTeamCommandError

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ARENA_TEAM_COMMAND_RESULT:
        # command: ArenaTeamCommand
        command = ArenaTeamCommand(await read_int(reader, 4))

        # team: CString
        team = await read_cstring(reader)

        # player: CString
        player = await read_cstring(reader)

        # error: ArenaTeamCommandError
        error = ArenaTeamCommandError(await read_int(reader, 4))

        return SMSG_ARENA_TEAM_COMMAND_RESULT(
            command=command,
            team=team,
            player=player,
            error=error,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0349))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.team)}sB{len(self.player)}sBI'
        _data.extend([self.command.value, self.team.encode('utf-8'), 0, self.player.encode('utf-8'), 0, self.error.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 10 + len(self.team) + len(self.player)


@dataclasses.dataclass
class SMSG_ARENA_TEAM_QUERY_RESPONSE:
    arena_team: int
    team_name: str
    team_type: ArenaType
    background_color: int
    emblem_style: int
    emblem_color: int
    border_style: int
    border_color: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ARENA_TEAM_QUERY_RESPONSE:
        # arena_team: u32
        arena_team = await read_int(reader, 4)

        # team_name: CString
        team_name = await read_cstring(reader)

        # team_type: ArenaType
        team_type = ArenaType(await read_int(reader, 1))

        # background_color: u32
        background_color = await read_int(reader, 4)

        # emblem_style: u32
        emblem_style = await read_int(reader, 4)

        # emblem_color: u32
        emblem_color = await read_int(reader, 4)

        # border_style: u32
        border_style = await read_int(reader, 4)

        # border_color: u32
        border_color = await read_int(reader, 4)

        return SMSG_ARENA_TEAM_QUERY_RESPONSE(
            arena_team=arena_team,
            team_name=team_name,
            team_type=team_type,
            background_color=background_color,
            emblem_style=emblem_style,
            emblem_color=emblem_color,
            border_style=border_style,
            border_color=border_color,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x034C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.team_name)}sBBIIIII'
        _data.extend([self.arena_team, self.team_name.encode('utf-8'), 0, self.team_type.value, self.background_color, self.emblem_style, self.emblem_color, self.border_style, self.border_color])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 26 + len(self.team_name)


@dataclasses.dataclass
class CMSG_ARENA_TEAM_ROSTER:
    arena_team: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ARENA_TEAM_ROSTER:
        # arena_team: u32
        arena_team = await read_int(reader, 4)

        return CMSG_ARENA_TEAM_ROSTER(
            arena_team=arena_team,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x034D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.arena_team)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ARENA_TEAM_ROSTER:
    arena_team: int
    unknown: int
    arena_type: ArenaType
    members: typing.List[ArenaTeamMember]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ARENA_TEAM_ROSTER:
        # arena_team: u32
        arena_team = await read_int(reader, 4)

        # unknown: u8
        unknown = await read_int(reader, 1)

        # amount_of_members: u32
        amount_of_members = await read_int(reader, 4)

        # arena_type: ArenaType
        arena_type = ArenaType(await read_int(reader, 1))

        # members: ArenaTeamMember[amount_of_members]
        members = []
        for _ in range(0, amount_of_members):
            members.append(await ArenaTeamMember.read(reader))

        return SMSG_ARENA_TEAM_ROSTER(
            arena_team=arena_team,
            unknown=unknown,
            arena_type=arena_type,
            members=members,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x034E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IBIB'
        _data.extend([self.arena_team, self.unknown, len(self.members), self.arena_type.value])
        # members: ArenaTeamMember[amount_of_members]
        for i in self.members:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 10 + sum([i.size() for i in self.members])


@dataclasses.dataclass
class CMSG_ARENA_TEAM_INVITE:
    arena_team: int
    player: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ARENA_TEAM_INVITE:
        # arena_team: u32
        arena_team = await read_int(reader, 4)

        # player: CString
        player = await read_cstring(reader)

        return CMSG_ARENA_TEAM_INVITE(
            arena_team=arena_team,
            player=player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x034F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'I{len(self.player)}sB'
        _data.extend([self.arena_team, self.player.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + len(self.player)


@dataclasses.dataclass
class SMSG_ARENA_TEAM_INVITE:
    player_name: str
    team_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ARENA_TEAM_INVITE:
        # player_name: CString
        player_name = await read_cstring(reader)

        # team_name: CString
        team_name = await read_cstring(reader)

        return SMSG_ARENA_TEAM_INVITE(
            player_name=player_name,
            team_name=team_name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0350))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.player_name)}sB{len(self.team_name)}sB'
        _data.extend([self.player_name.encode('utf-8'), 0, self.team_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.player_name) + len(self.team_name)


@dataclasses.dataclass
class CMSG_ARENA_TEAM_ACCEPT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ARENA_TEAM_ACCEPT:
        return CMSG_ARENA_TEAM_ACCEPT()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0351))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ARENA_TEAM_DECLINE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ARENA_TEAM_DECLINE:
        return CMSG_ARENA_TEAM_DECLINE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0352))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ARENA_TEAM_LEAVE:
    arena_team: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ARENA_TEAM_LEAVE:
        # arena_team: u32
        arena_team = await read_int(reader, 4)

        return CMSG_ARENA_TEAM_LEAVE(
            arena_team=arena_team,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0353))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.arena_team)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ARENA_TEAM_REMOVE:
    arena_team: int
    player: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ARENA_TEAM_REMOVE:
        # arena_team: u32
        arena_team = await read_int(reader, 4)

        # player: CString
        player = await read_cstring(reader)

        return CMSG_ARENA_TEAM_REMOVE(
            arena_team=arena_team,
            player=player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0354))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'I{len(self.player)}sB'
        _data.extend([self.arena_team, self.player.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + len(self.player)


@dataclasses.dataclass
class CMSG_ARENA_TEAM_DISBAND:
    arena_team: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ARENA_TEAM_DISBAND:
        # arena_team: u32
        arena_team = await read_int(reader, 4)

        return CMSG_ARENA_TEAM_DISBAND(
            arena_team=arena_team,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0355))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.arena_team)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ARENA_TEAM_LEADER:
    arena_team: int
    player: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ARENA_TEAM_LEADER:
        # arena_team: u32
        arena_team = await read_int(reader, 4)

        # player: CString
        player = await read_cstring(reader)

        return CMSG_ARENA_TEAM_LEADER(
            arena_team=arena_team,
            player=player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0356))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'I{len(self.player)}sB'
        _data.extend([self.arena_team, self.player.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + len(self.player)


@dataclasses.dataclass
class SMSG_ARENA_TEAM_EVENT:
    event: ArenaTeamEvent
    string: typing.List[str]
    joiner_name: typing.Optional[str] = None
    arena_team_name1: typing.Optional[str] = None
    joiner: typing.Optional[int] = None
    leaver_name: typing.Optional[str] = None
    leaver: typing.Optional[int] = None
    kicked_player_name: typing.Optional[str] = None
    arena_team_name2: typing.Optional[str] = None
    kicker_name: typing.Optional[str] = None
    leader_name: typing.Optional[str] = None
    arena_team_name3: typing.Optional[str] = None
    old_leader: typing.Optional[str] = None
    new_leader: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ARENA_TEAM_EVENT:
        joiner_name = None
        arena_team_name1 = None
        joiner = None
        leaver_name = None
        leaver = None
        kicked_player_name = None
        arena_team_name2 = None
        kicker_name = None
        leader_name = None
        arena_team_name3 = None
        old_leader = None
        new_leader = None
        # event: ArenaTeamEvent
        event = ArenaTeamEvent(await read_int(reader, 1))

        if event == ArenaTeamEvent.JOIN:
            # joiner_name: CString
            joiner_name = await read_cstring(reader)

            # arena_team_name1: CString
            arena_team_name1 = await read_cstring(reader)

            # joiner: Guid
            joiner = await read_int(reader, 8)

        elif event == ArenaTeamEvent.LEAVE:
            # leaver_name: CString
            leaver_name = await read_cstring(reader)

            # leaver: Guid
            leaver = await read_int(reader, 8)

        elif event == ArenaTeamEvent.REMOVE:
            # kicked_player_name: CString
            kicked_player_name = await read_cstring(reader)

            # arena_team_name2: CString
            arena_team_name2 = await read_cstring(reader)

            # kicker_name: CString
            kicker_name = await read_cstring(reader)

        elif event in {ArenaTeamEvent.LEADER_IS, ArenaTeamEvent.DISBANDED}:
            # leader_name: CString
            leader_name = await read_cstring(reader)

            # arena_team_name3: CString
            arena_team_name3 = await read_cstring(reader)

        elif event == ArenaTeamEvent.LEADER_CHANGED:
            # old_leader: CString
            old_leader = await read_cstring(reader)

            # new_leader: CString
            new_leader = await read_cstring(reader)

        # amount_of_strings: u8
        amount_of_strings = await read_int(reader, 1)

        # string: CString[amount_of_strings]
        string = []
        for _ in range(0, amount_of_strings):
            string.append(await read_cstring(reader))

        return SMSG_ARENA_TEAM_EVENT(
            event=event,
            joiner_name=joiner_name,
            arena_team_name1=arena_team_name1,
            joiner=joiner,
            leaver_name=leaver_name,
            leaver=leaver,
            kicked_player_name=kicked_player_name,
            arena_team_name2=arena_team_name2,
            kicker_name=kicker_name,
            leader_name=leader_name,
            arena_team_name3=arena_team_name3,
            old_leader=old_leader,
            new_leader=new_leader,
            string=string,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0357))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.event.value)
        if self.event == ArenaTeamEvent.JOIN:
            _fmt += f'{len(self.joiner_name)}sB{len(self.arena_team_name1)}sBQ'
            _data.extend([self.joiner_name.encode('utf-8'), 0, self.arena_team_name1.encode('utf-8'), 0, self.joiner])
        elif self.event == ArenaTeamEvent.LEAVE:
            _fmt += f'{len(self.leaver_name)}sBQ'
            _data.extend([self.leaver_name.encode('utf-8'), 0, self.leaver])
        elif self.event == ArenaTeamEvent.REMOVE:
            _fmt += f'{len(self.kicked_player_name)}sB{len(self.arena_team_name2)}sB{len(self.kicker_name)}sB'
            _data.extend([self.kicked_player_name.encode('utf-8'), 0, self.arena_team_name2.encode('utf-8'), 0, self.kicker_name.encode('utf-8'), 0])
        elif self.event in {ArenaTeamEvent.LEADER_IS, ArenaTeamEvent.DISBANDED}:
            _fmt += f'{len(self.leader_name)}sB{len(self.arena_team_name3)}sB'
            _data.extend([self.leader_name.encode('utf-8'), 0, self.arena_team_name3.encode('utf-8'), 0])
        elif self.event == ArenaTeamEvent.LEADER_CHANGED:
            _fmt += f'{len(self.old_leader)}sB{len(self.new_leader)}sB'
            _data.extend([self.old_leader.encode('utf-8'), 0, self.new_leader.encode('utf-8'), 0])
        # amount_of_strings: u8
        _fmt += 'B'
        _data.append(len(self.string))

        # string: CString[amount_of_strings]
        for i in self.string:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 2 + sum([len(i) + 1 for i in self.string])

        if self.event == ArenaTeamEvent.JOIN:
            _size += 10 + len(self.joiner_name) + len(self.arena_team_name1)
        elif self.event == ArenaTeamEvent.LEAVE:
            _size += 9 + len(self.leaver_name)
        elif self.event == ArenaTeamEvent.REMOVE:
            _size += 3 + len(self.kicked_player_name) + len(self.arena_team_name2) + len(self.kicker_name)
        elif self.event in {ArenaTeamEvent.LEADER_IS, ArenaTeamEvent.DISBANDED}:
            _size += 2 + len(self.leader_name) + len(self.arena_team_name3)
        elif self.event == ArenaTeamEvent.LEADER_CHANGED:
            _size += 2 + len(self.old_leader) + len(self.new_leader)

        return _size


@dataclasses.dataclass
class CMSG_BATTLEMASTER_JOIN_ARENA:
    battlemaster: int
    arena_type: JoinArenaType
    as_group: bool
    rated: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BATTLEMASTER_JOIN_ARENA:
        # battlemaster: Guid
        battlemaster = await read_int(reader, 8)

        # arena_type: JoinArenaType
        arena_type = JoinArenaType(await read_int(reader, 1))

        # as_group: Bool8
        as_group = await read_bool(reader, 1)

        # rated: Bool8
        rated = await read_bool(reader, 1)

        return CMSG_BATTLEMASTER_JOIN_ARENA(
            battlemaster=battlemaster,
            arena_type=arena_type,
            as_group=as_group,
            rated=rated,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(11 + 4, 0x0358))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QBBB'
        _data.extend([self.battlemaster, self.arena_type.value, self.as_group, self.rated])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MOVE_START_ASCEND:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_ASCEND:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_ASCEND(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0359))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0359))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_ASCEND:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_ASCEND:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_ASCEND(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x035A))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x035A))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class SMSG_ARENA_TEAM_STATS:
    arena_team: int
    rating: int
    games_played_this_week: int
    games_won_this_week: int
    games_played_this_season: int
    games_won_this_season: int
    ranking: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ARENA_TEAM_STATS:
        # arena_team: u32
        arena_team = await read_int(reader, 4)

        # rating: u32
        rating = await read_int(reader, 4)

        # games_played_this_week: u32
        games_played_this_week = await read_int(reader, 4)

        # games_won_this_week: u32
        games_won_this_week = await read_int(reader, 4)

        # games_played_this_season: u32
        games_played_this_season = await read_int(reader, 4)

        # games_won_this_season: u32
        games_won_this_season = await read_int(reader, 4)

        # ranking: u32
        ranking = await read_int(reader, 4)

        return SMSG_ARENA_TEAM_STATS(
            arena_team=arena_team,
            rating=rating,
            games_played_this_week=games_played_this_week,
            games_won_this_week=games_won_this_week,
            games_played_this_season=games_played_this_season,
            games_won_this_season=games_won_this_season,
            ranking=ranking,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(28 + 2, 0x035B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIIIII'
        _data.extend([self.arena_team, self.rating, self.games_played_this_week, self.games_won_this_week, self.games_played_this_season, self.games_won_this_season, self.ranking])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LFG_JOIN:
    roles: int
    no_partial_clear: bool
    achievements: bool
    slots: typing.List[int]
    needs: typing.List[int]
    comment: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LFG_JOIN:
        # roles: u32
        roles = await read_int(reader, 4)

        # no_partial_clear: Bool8
        no_partial_clear = await read_bool(reader, 1)

        # achievements: Bool8
        achievements = await read_bool(reader, 1)

        # amount_of_slots: u8
        amount_of_slots = await read_int(reader, 1)

        # slots: u32[amount_of_slots]
        slots = []
        for _ in range(0, amount_of_slots):
            slots.append(await read_int(reader, 4))

        # amount_of_needs: u8
        amount_of_needs = await read_int(reader, 1)

        # needs: u8[amount_of_needs]
        needs = []
        for _ in range(0, amount_of_needs):
            needs.append(await read_int(reader, 1))

        # comment: CString
        comment = await read_cstring(reader)

        return CMSG_LFG_JOIN(
            roles=roles,
            no_partial_clear=no_partial_clear,
            achievements=achievements,
            slots=slots,
            needs=needs,
            comment=comment,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x035C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'IBBB{len(self.slots)}IB{len(self.needs)}B{len(self.comment)}sB'
        _data.extend([self.roles, self.no_partial_clear, self.achievements, len(self.slots), *self.slots, len(self.needs), *self.needs, self.comment.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + 4 * len(self.slots) + 1 * len(self.needs) + len(self.comment)


@dataclasses.dataclass
class CMSG_LFG_LEAVE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LFG_LEAVE:
        return CMSG_LFG_LEAVE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x035D))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SEARCH_LFG_JOIN:
    dungeon_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SEARCH_LFG_JOIN:
        # dungeon_id: u32
        dungeon_id = await read_int(reader, 4)

        return CMSG_SEARCH_LFG_JOIN(
            dungeon_id=dungeon_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x035E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.dungeon_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SEARCH_LFG_LEAVE:
    dungeon_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SEARCH_LFG_LEAVE:
        # dungeon_id: u32
        dungeon_id = await read_int(reader, 4)

        return CMSG_SEARCH_LFG_LEAVE(
            dungeon_id=dungeon_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x035F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.dungeon_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_UPDATE_LFG_LIST:
    lfg_type: LfgType
    dungeon_id: int
    update_type: LfgListUpdateType
    unknown1: int
    groups: typing.List[LfgListGroup]
    unknown2: int
    players: typing.List[LfgListPlayer]
    deleted_guids: typing.Optional[typing.List[int]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_UPDATE_LFG_LIST:
        amount_of_deleted_guids = None
        deleted_guids = None
        # lfg_type: LfgType
        lfg_type = LfgType(await read_int(reader, 4))

        # dungeon_id: u32
        dungeon_id = await read_int(reader, 4)

        # update_type: LfgListUpdateType
        update_type = LfgListUpdateType(await read_int(reader, 1))

        if update_type == LfgListUpdateType.PARTIAL:
            # amount_of_deleted_guids: u32
            amount_of_deleted_guids = await read_int(reader, 4)

            # deleted_guids: Guid[amount_of_deleted_guids]
            deleted_guids = []
            for _ in range(0, amount_of_deleted_guids):
                deleted_guids.append(await read_int(reader, 8))

        # amount_of_groups: u32
        amount_of_groups = await read_int(reader, 4)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # groups: LfgListGroup[amount_of_groups]
        groups = []
        for _ in range(0, amount_of_groups):
            groups.append(await LfgListGroup.read(reader))

        # amount_of_players: u32
        amount_of_players = await read_int(reader, 4)

        # unknown2: u32
        unknown2 = await read_int(reader, 4)

        # players: LfgListPlayer[amount_of_players]
        players = []
        for _ in range(0, amount_of_players):
            players.append(await LfgListPlayer.read(reader))

        return SMSG_UPDATE_LFG_LIST(
            lfg_type=lfg_type,
            dungeon_id=dungeon_id,
            update_type=update_type,
            deleted_guids=deleted_guids,
            unknown1=unknown1,
            groups=groups,
            unknown2=unknown2,
            players=players,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0360))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIB'
        _data.extend([self.lfg_type.value, self.dungeon_id, self.update_type.value])
        if self.update_type == LfgListUpdateType.PARTIAL:
            _fmt += f'I{len(self.deleted_guids)}Q'
            _data.extend([len(self.deleted_guids), *self.deleted_guids])
        # amount_of_groups: u32
        _fmt += 'I'
        _data.append(len(self.groups))

        # unknown1: u32
        _fmt += 'I'
        _data.append(self.unknown1)

        # groups: LfgListGroup[amount_of_groups]
        for i in self.groups:
            _fmt, _data = i.write(_fmt, _data)

        # amount_of_players: u32
        _fmt += 'I'
        _data.append(len(self.players))

        # unknown2: u32
        _fmt += 'I'
        _data.append(self.unknown2)

        # players: LfgListPlayer[amount_of_players]
        for i in self.players:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 25 + sum([i.size() for i in self.groups]) + sum([i.size() for i in self.players])

        if self.update_type == LfgListUpdateType.PARTIAL:
            _size += 4 + 8 * len(self.deleted_guids)

        return _size


@dataclasses.dataclass
class SMSG_LFG_PROPOSAL_UPDATE:
    dungeon_id: int
    proposal_state: int
    proposal_id: int
    encounters_finished_mask: int
    silent: int
    proposals: typing.List[LfgProposal]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LFG_PROPOSAL_UPDATE:
        # dungeon_id: u32
        dungeon_id = await read_int(reader, 4)

        # proposal_state: u8
        proposal_state = await read_int(reader, 1)

        # proposal_id: u32
        proposal_id = await read_int(reader, 4)

        # encounters_finished_mask: u32
        encounters_finished_mask = await read_int(reader, 4)

        # silent: u8
        silent = await read_int(reader, 1)

        # amount_of_proposals: u8
        amount_of_proposals = await read_int(reader, 1)

        # proposals: LfgProposal[amount_of_proposals]
        proposals = []
        for _ in range(0, amount_of_proposals):
            proposals.append(await LfgProposal.read(reader))

        return SMSG_LFG_PROPOSAL_UPDATE(
            dungeon_id=dungeon_id,
            proposal_state=proposal_state,
            proposal_id=proposal_id,
            encounters_finished_mask=encounters_finished_mask,
            silent=silent,
            proposals=proposals,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0361))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IBIIBB'
        _data.extend([self.dungeon_id, self.proposal_state, self.proposal_id, self.encounters_finished_mask, self.silent, len(self.proposals)])
        # proposals: LfgProposal[amount_of_proposals]
        for i in self.proposals:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 15 + 9 * len(self.proposals)


@dataclasses.dataclass
class CMSG_LFG_PROPOSAL_RESULT:
    proposal_id: int
    accept_join: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LFG_PROPOSAL_RESULT:
        # proposal_id: u32
        proposal_id = await read_int(reader, 4)

        # accept_join: Bool8
        accept_join = await read_bool(reader, 1)

        return CMSG_LFG_PROPOSAL_RESULT(
            proposal_id=proposal_id,
            accept_join=accept_join,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 4, 0x0362))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([self.proposal_id, self.accept_join])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LFG_ROLE_CHECK_UPDATE:
    rolecheck_state: int
    rolecheck_initializing: int
    dungeon_entries: typing.List[int]
    roles: typing.List[LfgRole]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LFG_ROLE_CHECK_UPDATE:
        # rolecheck_state: u32
        rolecheck_state = await read_int(reader, 4)

        # rolecheck_initializing: u8
        rolecheck_initializing = await read_int(reader, 1)

        # amount_of_dungeon_entries: u8
        amount_of_dungeon_entries = await read_int(reader, 1)

        # dungeon_entries: u32[amount_of_dungeon_entries]
        dungeon_entries = []
        for _ in range(0, amount_of_dungeon_entries):
            dungeon_entries.append(await read_int(reader, 4))

        # amount_of_roles: u8
        amount_of_roles = await read_int(reader, 1)

        # roles: LfgRole[amount_of_roles]
        roles = []
        for _ in range(0, amount_of_roles):
            roles.append(await LfgRole.read(reader))

        return SMSG_LFG_ROLE_CHECK_UPDATE(
            rolecheck_state=rolecheck_state,
            rolecheck_initializing=rolecheck_initializing,
            dungeon_entries=dungeon_entries,
            roles=roles,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0363))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'IBB{len(self.dungeon_entries)}IB'
        _data.extend([self.rolecheck_state, self.rolecheck_initializing, len(self.dungeon_entries), *self.dungeon_entries, len(self.roles)])
        # roles: LfgRole[amount_of_roles]
        for i in self.roles:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 7 + 4 * len(self.dungeon_entries) + 14 * len(self.roles)


@dataclasses.dataclass
class SMSG_LFG_JOIN_RESULT:
    result: int
    state: int
    players: typing.List[LfgJoinPlayer]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LFG_JOIN_RESULT:
        _size = 0

        # result: u32
        result = await read_int(reader, 4)
        _size += 4

        # state: u32
        state = await read_int(reader, 4)
        _size += 4

        # players: LfgJoinPlayer[-]
        players = []
        while _size < body_size:
            players.append(await LfgJoinPlayer.read(reader))
            _size += players[-1].size()

        return SMSG_LFG_JOIN_RESULT(
            result=result,
            state=state,
            players=players,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0364))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.result, self.state])
        # players: LfgJoinPlayer[-]
        for i in self.players:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + sum([i.size() for i in self.players])


@dataclasses.dataclass
class SMSG_LFG_QUEUE_STATUS:
    dungeon: int
    average_wait_time: int
    wait_time: int
    wait_time_tank: int
    wait_time_healer: int
    wait_time_dps: int
    tanks_needed: int
    healers_needed: int
    dps_needed: int
    queue_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LFG_QUEUE_STATUS:
        # dungeon: u32
        dungeon = await read_int(reader, 4)

        # average_wait_time: i32
        average_wait_time = await read_int(reader, 4)

        # wait_time: i32
        wait_time = await read_int(reader, 4)

        # wait_time_tank: i32
        wait_time_tank = await read_int(reader, 4)

        # wait_time_healer: i32
        wait_time_healer = await read_int(reader, 4)

        # wait_time_dps: i32
        wait_time_dps = await read_int(reader, 4)

        # tanks_needed: u8
        tanks_needed = await read_int(reader, 1)

        # healers_needed: u8
        healers_needed = await read_int(reader, 1)

        # dps_needed: u8
        dps_needed = await read_int(reader, 1)

        # queue_time: u32
        queue_time = await read_int(reader, 4)

        return SMSG_LFG_QUEUE_STATUS(
            dungeon=dungeon,
            average_wait_time=average_wait_time,
            wait_time=wait_time,
            wait_time_tank=wait_time_tank,
            wait_time_healer=wait_time_healer,
            wait_time_dps=wait_time_dps,
            tanks_needed=tanks_needed,
            healers_needed=healers_needed,
            dps_needed=dps_needed,
            queue_time=queue_time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(31 + 2, 0x0365))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IiiiiiBBBI'
        _data.extend([self.dungeon, self.average_wait_time, self.wait_time, self.wait_time_tank, self.wait_time_healer, self.wait_time_dps, self.tanks_needed, self.healers_needed, self.dps_needed, self.queue_time])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_LFG_COMMENT:
    comment: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_LFG_COMMENT:
        # comment: CString
        comment = await read_cstring(reader)

        return CMSG_SET_LFG_COMMENT(
            comment=comment,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0366))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.comment)}sB'
        _data.extend([self.comment.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.comment)


@dataclasses.dataclass
class SMSG_LFG_UPDATE_PLAYER:
    update_type: LfgUpdateType
    join_status: LfgJoinStatus
    queued: typing.Optional[int] = None
    no_partial_clear: typing.Optional[int] = None
    achievements: typing.Optional[int] = None
    dungeons: typing.Optional[typing.List[int]] = None
    comment: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LFG_UPDATE_PLAYER:
        queued = None
        no_partial_clear = None
        achievements = None
        amount_of_dungeons = None
        dungeons = None
        comment = None
        # update_type: LfgUpdateType
        update_type = LfgUpdateType(await read_int(reader, 1))

        # join_status: LfgJoinStatus
        join_status = LfgJoinStatus(await read_int(reader, 1))

        if join_status == LfgJoinStatus.JOINED:
            # queued: u8
            queued = await read_int(reader, 1)

            # no_partial_clear: u8
            no_partial_clear = await read_int(reader, 1)

            # achievements: u8
            achievements = await read_int(reader, 1)

            # amount_of_dungeons: u8
            amount_of_dungeons = await read_int(reader, 1)

            # dungeons: u32[amount_of_dungeons]
            dungeons = []
            for _ in range(0, amount_of_dungeons):
                dungeons.append(await read_int(reader, 4))

            # comment: CString
            comment = await read_cstring(reader)

        return SMSG_LFG_UPDATE_PLAYER(
            update_type=update_type,
            join_status=join_status,
            queued=queued,
            no_partial_clear=no_partial_clear,
            achievements=achievements,
            dungeons=dungeons,
            comment=comment,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0367))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.update_type.value, self.join_status.value])
        if self.join_status == LfgJoinStatus.JOINED:
            _fmt += f'BBBB{len(self.dungeons)}I{len(self.comment)}sB'
            _data.extend([self.queued, self.no_partial_clear, self.achievements, len(self.dungeons), *self.dungeons, self.comment.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 2

        if self.join_status == LfgJoinStatus.JOINED:
            _size += 5 + 4 * len(self.dungeons) + len(self.comment)

        return _size


@dataclasses.dataclass
class SMSG_LFG_UPDATE_PARTY:
    update_type: LfgUpdateType
    join_status: LfgJoinStatus
    joined: typing.Optional[int] = None
    queued: typing.Optional[int] = None
    no_partial_clear: typing.Optional[int] = None
    achievements: typing.Optional[int] = None
    dungeons: typing.Optional[typing.List[int]] = None
    comment: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LFG_UPDATE_PARTY:
        joined = None
        queued = None
        no_partial_clear = None
        achievements = None
        amount_of_dungeons = None
        dungeons = None
        comment = None
        # update_type: LfgUpdateType
        update_type = LfgUpdateType(await read_int(reader, 1))

        # join_status: LfgJoinStatus
        join_status = LfgJoinStatus(await read_int(reader, 1))

        if join_status == LfgJoinStatus.JOINED:
            # joined: u8
            joined = await read_int(reader, 1)

            # queued: u8
            queued = await read_int(reader, 1)

            # no_partial_clear: u8
            no_partial_clear = await read_int(reader, 1)

            # achievements: u8
            achievements = await read_int(reader, 1)

            # amount_of_dungeons: u8
            amount_of_dungeons = await read_int(reader, 1)

            # dungeons: u32[amount_of_dungeons]
            dungeons = []
            for _ in range(0, amount_of_dungeons):
                dungeons.append(await read_int(reader, 4))

            # comment: CString
            comment = await read_cstring(reader)

        return SMSG_LFG_UPDATE_PARTY(
            update_type=update_type,
            join_status=join_status,
            joined=joined,
            queued=queued,
            no_partial_clear=no_partial_clear,
            achievements=achievements,
            dungeons=dungeons,
            comment=comment,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0368))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.update_type.value, self.join_status.value])
        if self.join_status == LfgJoinStatus.JOINED:
            _fmt += f'BBBBB{len(self.dungeons)}I{len(self.comment)}sB'
            _data.extend([self.joined, self.queued, self.no_partial_clear, self.achievements, len(self.dungeons), *self.dungeons, self.comment.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 2

        if self.join_status == LfgJoinStatus.JOINED:
            _size += 6 + 4 * len(self.dungeons) + len(self.comment)

        return _size


@dataclasses.dataclass
class SMSG_LFG_UPDATE_SEARCH:
    in_lfg_queue: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LFG_UPDATE_SEARCH:
        # in_lfg_queue: Bool8
        in_lfg_queue = await read_bool(reader, 1)

        return SMSG_LFG_UPDATE_SEARCH(
            in_lfg_queue=in_lfg_queue,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x0369))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.in_lfg_queue)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LFG_SET_ROLES:
    roles: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LFG_SET_ROLES:
        # roles: u8
        roles = await read_int(reader, 1)

        return CMSG_LFG_SET_ROLES(
            roles=roles,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x036A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.roles)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LFG_SET_BOOT_VOTE:
    agree_to_kick_player: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LFG_SET_BOOT_VOTE:
        # agree_to_kick_player: Bool8
        agree_to_kick_player = await read_bool(reader, 1)

        return CMSG_LFG_SET_BOOT_VOTE(
            agree_to_kick_player=agree_to_kick_player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x036C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.agree_to_kick_player)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LFG_BOOT_PROPOSAL_UPDATE:
    vote_in_progress: bool
    did_vote: bool
    agreed_with_kick: bool
    victim: int
    total_votes: int
    votes_agree: int
    time_left: int
    votes_needed: int
    reason: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LFG_BOOT_PROPOSAL_UPDATE:
        # vote_in_progress: Bool8
        vote_in_progress = await read_bool(reader, 1)

        # did_vote: Bool8
        did_vote = await read_bool(reader, 1)

        # agreed_with_kick: Bool8
        agreed_with_kick = await read_bool(reader, 1)

        # victim: Guid
        victim = await read_int(reader, 8)

        # total_votes: u32
        total_votes = await read_int(reader, 4)

        # votes_agree: u32
        votes_agree = await read_int(reader, 4)

        # time_left: Seconds
        time_left = await read_int(reader, 4)

        # votes_needed: u32
        votes_needed = await read_int(reader, 4)

        # reason: CString
        reason = await read_cstring(reader)

        return SMSG_LFG_BOOT_PROPOSAL_UPDATE(
            vote_in_progress=vote_in_progress,
            did_vote=did_vote,
            agreed_with_kick=agreed_with_kick,
            victim=victim,
            total_votes=total_votes,
            votes_agree=votes_agree,
            time_left=time_left,
            votes_needed=votes_needed,
            reason=reason,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x036D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'BBBQIIII{len(self.reason)}sB'
        _data.extend([self.vote_in_progress, self.did_vote, self.agreed_with_kick, self.victim, self.total_votes, self.votes_agree, self.time_left, self.votes_needed, self.reason.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 28 + len(self.reason)


@dataclasses.dataclass
class CMSG_LFD_PLAYER_LOCK_INFO_REQUEST:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LFD_PLAYER_LOCK_INFO_REQUEST:
        return CMSG_LFD_PLAYER_LOCK_INFO_REQUEST()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x036E))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LFG_PLAYER_INFO:
    available_dungeons: typing.List[LfgAvailableDungeon]
    locked_dungeons: typing.List[LfgJoinLockedDungeon]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LFG_PLAYER_INFO:
        # amount_of_available_dungeons: u8
        amount_of_available_dungeons = await read_int(reader, 1)

        # available_dungeons: LfgAvailableDungeon[amount_of_available_dungeons]
        available_dungeons = []
        for _ in range(0, amount_of_available_dungeons):
            available_dungeons.append(await LfgAvailableDungeon.read(reader))

        # amount_of_locked_dungeons: u8
        amount_of_locked_dungeons = await read_int(reader, 1)

        # locked_dungeons: LfgJoinLockedDungeon[amount_of_locked_dungeons]
        locked_dungeons = []
        for _ in range(0, amount_of_locked_dungeons):
            locked_dungeons.append(await LfgJoinLockedDungeon.read(reader))

        return SMSG_LFG_PLAYER_INFO(
            available_dungeons=available_dungeons,
            locked_dungeons=locked_dungeons,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x036F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(len(self.available_dungeons))
        # available_dungeons: LfgAvailableDungeon[amount_of_available_dungeons]
        for i in self.available_dungeons:
            _fmt, _data = i.write(_fmt, _data)

        # amount_of_locked_dungeons: u8
        _fmt += 'B'
        _data.append(len(self.locked_dungeons))

        # locked_dungeons: LfgJoinLockedDungeon[amount_of_locked_dungeons]
        for i in self.locked_dungeons:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + sum([i.size() for i in self.available_dungeons]) + 8 * len(self.locked_dungeons)


@dataclasses.dataclass
class CMSG_LFG_TELEPORT:
    location: LfgTeleportLocation

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LFG_TELEPORT:
        # location: LfgTeleportLocation
        location = LfgTeleportLocation(await read_int(reader, 1))

        return CMSG_LFG_TELEPORT(
            location=location,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x0370))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.location.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LFD_PARTY_LOCK_INFO_REQUEST:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LFD_PARTY_LOCK_INFO_REQUEST:
        return CMSG_LFD_PARTY_LOCK_INFO_REQUEST()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0371))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LFG_PARTY_INFO:
    infos: typing.List[LfgPartyInfo]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LFG_PARTY_INFO:
        # amount_of_infos: u8
        amount_of_infos = await read_int(reader, 1)

        # infos: LfgPartyInfo[amount_of_infos]
        infos = []
        for _ in range(0, amount_of_infos):
            infos.append(await LfgPartyInfo.read(reader))

        return SMSG_LFG_PARTY_INFO(
            infos=infos,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0372))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(len(self.infos))
        # infos: LfgPartyInfo[amount_of_infos]
        for i in self.infos:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + sum([i.size() for i in self.infos])


@dataclasses.dataclass
class SMSG_TITLE_EARNED:
    title: int
    status: TitleEarnStatus

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TITLE_EARNED:
        # title: u32
        title = await read_int(reader, 4)

        # status: TitleEarnStatus
        status = TitleEarnStatus(await read_int(reader, 4))

        return SMSG_TITLE_EARNED(
            title=title,
            status=status,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0373))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.title, self.status.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_TITLE:
    title: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_TITLE:
        # title: u32
        title = await read_int(reader, 4)

        return CMSG_SET_TITLE(
            title=title,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0374))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.title)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CANCEL_MOUNT_AURA:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_MOUNT_AURA:
        return CMSG_CANCEL_MOUNT_AURA()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0375))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ARENA_ERROR:
    unknown: int
    arena_type: ArenaType

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ARENA_ERROR:
        # unknown: u32
        unknown = await read_int(reader, 4)

        # arena_type: ArenaType
        arena_type = ArenaType(await read_int(reader, 1))

        return SMSG_ARENA_ERROR(
            unknown=unknown,
            arena_type=arena_type,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x0376))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([self.unknown, self.arena_type.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_INSPECT_ARENA_TEAMS_Client:
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_INSPECT_ARENA_TEAMS_Client:
        # player: Guid
        player = await read_int(reader, 8)

        return MSG_INSPECT_ARENA_TEAMS_Client(
            player=player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0377))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.player)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_INSPECT_ARENA_TEAMS_Server:
    player: int
    slot: int
    arena_team: int
    rating: int
    games_played_this_season: int
    wins_this_season: int
    total_games_played: int
    personal_rating: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_INSPECT_ARENA_TEAMS_Server:
        # player: Guid
        player = await read_int(reader, 8)

        # slot: u8
        slot = await read_int(reader, 1)

        # arena_team: u32
        arena_team = await read_int(reader, 4)

        # rating: u32
        rating = await read_int(reader, 4)

        # games_played_this_season: u32
        games_played_this_season = await read_int(reader, 4)

        # wins_this_season: u32
        wins_this_season = await read_int(reader, 4)

        # total_games_played: u32
        total_games_played = await read_int(reader, 4)

        # personal_rating: u32
        personal_rating = await read_int(reader, 4)

        return MSG_INSPECT_ARENA_TEAMS_Server(
            player=player,
            slot=slot,
            arena_team=arena_team,
            rating=rating,
            games_played_this_season=games_played_this_season,
            wins_this_season=wins_this_season,
            total_games_played=total_games_played,
            personal_rating=personal_rating,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(33 + 2, 0x0377))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QBIIIIII'
        _data.extend([self.player, self.slot, self.arena_team, self.rating, self.games_played_this_season, self.wins_this_season, self.total_games_played, self.personal_rating])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DEATH_RELEASE_LOC:
    map: Map
    position: Vector3d

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DEATH_RELEASE_LOC:
        # map: Map
        map = Map(await read_int(reader, 4))

        # position: Vector3d
        position = await Vector3d.read(reader)

        return SMSG_DEATH_RELEASE_LOC(
            map=map,
            position=position,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x0378))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CANCEL_TEMP_ENCHANTMENT:
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_TEMP_ENCHANTMENT:
        # slot: u32
        slot = await read_int(reader, 4)

        return CMSG_CANCEL_TEMP_ENCHANTMENT(
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0379))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.slot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_FORCED_DEATH_UPDATE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCED_DEATH_UPDATE:
        return SMSG_FORCED_DEATH_UPDATE()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x037A))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MOVE_SET_FLIGHT_SPEED_Server:
    player: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_FLIGHT_SPEED_Server:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return MSG_MOVE_SET_FLIGHT_SPEED_Server(
            player=player,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x037E))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_FLIGHT_BACK_SPEED:
    player: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_FLIGHT_BACK_SPEED:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return MSG_MOVE_SET_FLIGHT_BACK_SPEED(
            player=player,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0380))
        _fmt = "<6s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0380))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_FLIGHT_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_FLIGHT_SPEED_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_FLIGHT_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0381))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_FLIGHT_SPEED_CHANGE_ACK:
    player: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_FLIGHT_SPEED_CHANGE_ACK:
        # player: Guid
        player = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_FLIGHT_SPEED_CHANGE_ACK(
            player=player,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0382))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.player, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0383))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE_ACK:
    player: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE_ACK:
        # player: Guid
        player = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE_ACK(
            player=player,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0384))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.player, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class SMSG_SPLINE_SET_FLIGHT_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_FLIGHT_SPEED:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_FLIGHT_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0385))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_FLIGHT_BACK_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_FLIGHT_BACK_SPEED:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_FLIGHT_BACK_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0386))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_FLIGHT_SPLINE_SYNC:
    elapsed_value: float
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FLIGHT_SPLINE_SYNC:
        # elapsed_value: f32
        elapsed_value = await read_float(reader)

        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_FLIGHT_SPLINE_SYNC(
            elapsed_value=elapsed_value,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0388))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'f'
        _data.append(self.elapsed_value)
        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_SET_TAXI_BENCHMARK_MODE:
    mode: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_TAXI_BENCHMARK_MODE:
        # mode: u8
        mode = await read_int(reader, 1)

        return CMSG_SET_TAXI_BENCHMARK_MODE(
            mode=mode,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x0389))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.mode)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_REALM_SPLIT:
    realm_id: int
    state: RealmSplitState
    split_date: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_REALM_SPLIT:
        # realm_id: u32
        realm_id = await read_int(reader, 4)

        # state: RealmSplitState
        state = RealmSplitState(await read_int(reader, 4))

        # split_date: CString
        split_date = await read_cstring(reader)

        return SMSG_REALM_SPLIT(
            realm_id=realm_id,
            state=state,
            split_date=split_date,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x038B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'II{len(self.split_date)}sB'
        _data.extend([self.realm_id, self.state.value, self.split_date.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.split_date)


@dataclasses.dataclass
class CMSG_REALM_SPLIT:
    realm_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REALM_SPLIT:
        # realm_id: u32
        realm_id = await read_int(reader, 4)

        return CMSG_REALM_SPLIT(
            realm_id=realm_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x038C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.realm_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MOVE_CHNG_TRANSPORT:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_CHNG_TRANSPORT:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return CMSG_MOVE_CHNG_TRANSPORT(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x038D))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_PARTY_ASSIGNMENT_Client:
    role: PartyRole
    apply: bool
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_PARTY_ASSIGNMENT_Client:
        # role: PartyRole
        role = PartyRole(await read_int(reader, 1))

        # apply: Bool8
        apply = await read_bool(reader, 1)

        # player: Guid
        player = await read_int(reader, 8)

        return MSG_PARTY_ASSIGNMENT_Client(
            role=role,
            apply=apply,
            player=player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(10 + 4, 0x038E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBQ'
        _data.extend([self.role.value, self.apply, self.player])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TIME_SYNC_REQ:
    time_sync: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TIME_SYNC_REQ:
        # time_sync: u32
        time_sync = await read_int(reader, 4)

        return SMSG_TIME_SYNC_REQ(
            time_sync=time_sync,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0390))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.time_sync)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TIME_SYNC_RESP:
    time_sync: int
    client_ticks: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TIME_SYNC_RESP:
        # time_sync: u32
        time_sync = await read_int(reader, 4)

        # client_ticks: u32
        client_ticks = await read_int(reader, 4)

        return CMSG_TIME_SYNC_RESP(
            time_sync=time_sync,
            client_ticks=client_ticks,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0391))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.time_sync, self.client_ticks])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_RESET_FAILED_NOTIFY:
    map: Map

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RESET_FAILED_NOTIFY:
        # map: Map
        map = Map(await read_int(reader, 4))

        return SMSG_RESET_FAILED_NOTIFY(
            map=map,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0396))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LFG_DISABLED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LFG_DISABLED:
        return SMSG_LFG_DISABLED()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0398))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_UPDATE_COMBO_POINTS:
    target: int
    combo_points: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_UPDATE_COMBO_POINTS:
        # target: PackedGuid
        target = await read_packed_guid(reader)

        # combo_points: u8
        combo_points = await read_int(reader, 1)

        return SMSG_UPDATE_COMBO_POINTS(
            target=target,
            combo_points=combo_points,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x039D))
        _fmt = "<4s"
        _data = [_data]

        # target: PackedGuid
        _fmt, _data = packed_guid_write(self.target, _fmt, _data)

        # combo_points: u8
        _fmt += 'B'
        _data.append(self.combo_points)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + packed_guid_size(self.target)


@dataclasses.dataclass
class MSG_MOVE_START_DESCEND:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_DESCEND:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_DESCEND(
            guid=guid,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x03A7))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03A7))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class SMSG_DISMOUNT:
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DISMOUNT:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        return SMSG_DISMOUNT(
            player=player,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03AC))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player)


@dataclasses.dataclass
class MSG_MOVE_UPDATE_CAN_FLY_Server:
    player: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_UPDATE_CAN_FLY_Server:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_UPDATE_CAN_FLY_Server(
            player=player,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03AD))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class MSG_RAID_READY_CHECK_CONFIRM_Client:
    state: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RAID_READY_CHECK_CONFIRM_Client:
        state = None
        _size = 0

        # set: optional
        if _size < body_size:
            # state: u8
            state = await read_int(reader, 1)
            _size += 1

        return MSG_RAID_READY_CHECK_CONFIRM_Client(
            state=state,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x03AE))
        _fmt = "<6s"
        _data = [_data]

        # set: optional
        if self.state is not None:
            _fmt += 'B'
            _data.append(self.state)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 0

        # set: optional
        if self.state is not None:
            _size += 1

        return _size


@dataclasses.dataclass
class MSG_RAID_READY_CHECK_CONFIRM_Server:
    player: int
    state: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RAID_READY_CHECK_CONFIRM_Server:
        # player: Guid
        player = await read_int(reader, 8)

        # state: u8
        state = await read_int(reader, 1)

        return MSG_RAID_READY_CHECK_CONFIRM_Server(
            player=player,
            state=state,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x03AE))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.player, self.state])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_VOICE_SESSION_ENABLE:
    voice_enabled: bool
    microphone_enabled: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_VOICE_SESSION_ENABLE:
        # voice_enabled: Bool8
        voice_enabled = await read_bool(reader, 1)

        # microphone_enabled: Bool8
        microphone_enabled = await read_bool(reader, 1)

        return CMSG_VOICE_SESSION_ENABLE(
            voice_enabled=voice_enabled,
            microphone_enabled=microphone_enabled,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x03AF))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.voice_enabled, self.microphone_enabled])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GM_MESSAGECHAT:
    chat_type: ChatType
    language: Language
    sender: int
    flags: int
    message: str
    chat_tag: PlayerChatTag
    sender1: typing.Optional[str] = None
    target1: typing.Optional[NamedGUID] = None
    sender2: typing.Optional[str] = None
    target2: typing.Optional[int] = None
    target3: typing.Optional[NamedGUID] = None
    target4: typing.Optional[int] = None
    channel_name: typing.Optional[str] = None
    target5: typing.Optional[int] = None
    sender_name: typing.Optional[str] = None
    target6: typing.Optional[int] = None
    achievement_id: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GM_MESSAGECHAT:
        sender1 = None
        target1 = None
        sender2 = None
        target2 = None
        target3 = None
        target4 = None
        channel_name = None
        target5 = None
        sender_name = None
        target6 = None
        achievement_id = None
        # chat_type: ChatType
        chat_type = ChatType(await read_int(reader, 1))

        # language: Language
        language = Language(await read_int(reader, 4))

        # sender: Guid
        sender = await read_int(reader, 8)

        # flags: u32
        flags = await read_int(reader, 4)

        if chat_type in {ChatType.MONSTER_SAY, ChatType.MONSTER_PARTY, ChatType.MONSTER_YELL, ChatType.MONSTER_WHISPER, ChatType.RAID_BOSS_WHISPER, ChatType.RAID_BOSS_EMOTE, ChatType.MONSTER_EMOTE, ChatType.BATTLENET}:
            # sender1: SizedCString
            sender1 = await read_sized_cstring(reader)

            # target1: NamedGuid
            target1 = await NamedGuid.read(reader)

        elif chat_type == ChatType.WHISPER_FOREIGN:
            # sender2: SizedCString
            sender2 = await read_sized_cstring(reader)

            # target2: Guid
            target2 = await read_int(reader, 8)

        elif chat_type in {ChatType.BG_SYSTEM_NEUTRAL, ChatType.BG_SYSTEM_ALLIANCE, ChatType.BG_SYSTEM_HORDE}:
            # target3: NamedGuid
            target3 = await NamedGuid.read(reader)

        elif chat_type in {ChatType.ACHIEVEMENT, ChatType.GUILD_ACHIEVEMENT}:
            # target4: Guid
            target4 = await read_int(reader, 8)

        elif chat_type == ChatType.CHANNEL:
            # channel_name: CString
            channel_name = await read_cstring(reader)

            # target5: Guid
            target5 = await read_int(reader, 8)

        elif chat_type in {ChatType.SYSTEM, ChatType.SAY, ChatType.PARTY, ChatType.RAID, ChatType.GUILD, ChatType.OFFICER, ChatType.YELL, ChatType.WHISPER, ChatType.WHISPER_INFORM, ChatType.EMOTE, ChatType.TEXT_EMOTE, ChatType.CHANNEL_JOIN, ChatType.CHANNEL_LEAVE, ChatType.CHANNEL_LIST, ChatType.CHANNEL_NOTICE, ChatType.CHANNEL_NOTICE_USER, ChatType.AFK, ChatType.DND, ChatType.IGNORED, ChatType.SKILL, ChatType.LOOT, ChatType.MONEY, ChatType.OPENING, ChatType.TRADESKILLS, ChatType.PET_INFO, ChatType.COMBAT_MISC_INFO, ChatType.COMBAT_XP_GAIN, ChatType.COMBAT_HONOR_GAIN, ChatType.COMBAT_FACTION_CHANGE, ChatType.RAID_LEADER, ChatType.RAID_WARNING, ChatType.FILTERED, ChatType.BATTLEGROUND, ChatType.BATTLEGROUND_LEADER, ChatType.RESTRICTED, ChatType.ARENA_POINTS, ChatType.PARTY_LEADER}:
            # sender_name: SizedCString
            sender_name = await read_sized_cstring(reader)

            # target6: Guid
            target6 = await read_int(reader, 8)

        # message: SizedCString
        message = await read_sized_cstring(reader)

        # chat_tag: PlayerChatTag
        chat_tag = PlayerChatTag(await read_int(reader, 1))

        if chat_type in {ChatType.ACHIEVEMENT, ChatType.GUILD_ACHIEVEMENT}:
            # achievement_id: u32
            achievement_id = await read_int(reader, 4)

        return SMSG_GM_MESSAGECHAT(
            chat_type=chat_type,
            language=language,
            sender=sender,
            flags=flags,
            sender1=sender1,
            target1=target1,
            sender2=sender2,
            target2=target2,
            target3=target3,
            target4=target4,
            channel_name=channel_name,
            target5=target5,
            sender_name=sender_name,
            target6=target6,
            message=message,
            chat_tag=chat_tag,
            achievement_id=achievement_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03B3))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BIQI'
        _data.extend([self.chat_type.value, self.language.value, self.sender, self.flags])
        if self.chat_type in {ChatType.MONSTER_SAY, ChatType.MONSTER_PARTY, ChatType.MONSTER_YELL, ChatType.MONSTER_WHISPER, ChatType.RAID_BOSS_WHISPER, ChatType.RAID_BOSS_EMOTE, ChatType.MONSTER_EMOTE, ChatType.BATTLENET}:
            _fmt += f'I{len(self.sender1)}sB'
            _data.extend([len(self.sender1) + 1, self.sender1.encode('utf-8'), 0])
            # target1: NamedGuid
            _fmt, _data = self.target1.write(_fmt, _data)

        elif self.chat_type == ChatType.WHISPER_FOREIGN:
            _fmt += f'I{len(self.sender2)}sBQ'
            _data.extend([len(self.sender2) + 1, self.sender2.encode('utf-8'), 0, self.target2])
        elif self.chat_type in {ChatType.BG_SYSTEM_NEUTRAL, ChatType.BG_SYSTEM_ALLIANCE, ChatType.BG_SYSTEM_HORDE}:
            # target3: NamedGuid
            _fmt, _data = self.target3.write(_fmt, _data)

        elif self.chat_type in {ChatType.ACHIEVEMENT, ChatType.GUILD_ACHIEVEMENT}:
            _fmt += 'Q'
            _data.append(self.target4)
        elif self.chat_type == ChatType.CHANNEL:
            _fmt += f'{len(self.channel_name)}sBQ'
            _data.extend([self.channel_name.encode('utf-8'), 0, self.target5])
        elif self.chat_type in {ChatType.SYSTEM, ChatType.SAY, ChatType.PARTY, ChatType.RAID, ChatType.GUILD, ChatType.OFFICER, ChatType.YELL, ChatType.WHISPER, ChatType.WHISPER_INFORM, ChatType.EMOTE, ChatType.TEXT_EMOTE, ChatType.CHANNEL_JOIN, ChatType.CHANNEL_LEAVE, ChatType.CHANNEL_LIST, ChatType.CHANNEL_NOTICE, ChatType.CHANNEL_NOTICE_USER, ChatType.AFK, ChatType.DND, ChatType.IGNORED, ChatType.SKILL, ChatType.LOOT, ChatType.MONEY, ChatType.OPENING, ChatType.TRADESKILLS, ChatType.PET_INFO, ChatType.COMBAT_MISC_INFO, ChatType.COMBAT_XP_GAIN, ChatType.COMBAT_HONOR_GAIN, ChatType.COMBAT_FACTION_CHANGE, ChatType.RAID_LEADER, ChatType.RAID_WARNING, ChatType.FILTERED, ChatType.BATTLEGROUND, ChatType.BATTLEGROUND_LEADER, ChatType.RESTRICTED, ChatType.ARENA_POINTS, ChatType.PARTY_LEADER}:
            _fmt += f'I{len(self.sender_name)}sBQ'
            _data.extend([len(self.sender_name) + 1, self.sender_name.encode('utf-8'), 0, self.target6])
        # message: SizedCString
        _fmt += f'I{len(self.message)}sB'
        _data.extend([len(self.message) + 1, self.message.encode('utf-8'), 0])

        # chat_tag: PlayerChatTag
        _fmt += 'B'
        _data.append(self.chat_tag.value)

        if self.chat_type in {ChatType.ACHIEVEMENT, ChatType.GUILD_ACHIEVEMENT}:
            _fmt += 'I'
            _data.append(self.achievement_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 23 + len(self.message)

        if self.chat_type in {ChatType.MONSTER_SAY, ChatType.MONSTER_PARTY, ChatType.MONSTER_YELL, ChatType.MONSTER_WHISPER, ChatType.RAID_BOSS_WHISPER, ChatType.RAID_BOSS_EMOTE, ChatType.MONSTER_EMOTE, ChatType.BATTLENET}:
            _size += 5 + len(self.sender1) + self.target1.size()
        elif self.chat_type == ChatType.WHISPER_FOREIGN:
            _size += 13 + len(self.sender2)
        elif self.chat_type in {ChatType.BG_SYSTEM_NEUTRAL, ChatType.BG_SYSTEM_ALLIANCE, ChatType.BG_SYSTEM_HORDE}:
            _size += 0 + self.target3.size()
        elif self.chat_type in {ChatType.ACHIEVEMENT, ChatType.GUILD_ACHIEVEMENT}:
            _size += 8
        elif self.chat_type == ChatType.CHANNEL:
            _size += 9 + len(self.channel_name)
        elif self.chat_type in {ChatType.SYSTEM, ChatType.SAY, ChatType.PARTY, ChatType.RAID, ChatType.GUILD, ChatType.OFFICER, ChatType.YELL, ChatType.WHISPER, ChatType.WHISPER_INFORM, ChatType.EMOTE, ChatType.TEXT_EMOTE, ChatType.CHANNEL_JOIN, ChatType.CHANNEL_LEAVE, ChatType.CHANNEL_LIST, ChatType.CHANNEL_NOTICE, ChatType.CHANNEL_NOTICE_USER, ChatType.AFK, ChatType.DND, ChatType.IGNORED, ChatType.SKILL, ChatType.LOOT, ChatType.MONEY, ChatType.OPENING, ChatType.TRADESKILLS, ChatType.PET_INFO, ChatType.COMBAT_MISC_INFO, ChatType.COMBAT_XP_GAIN, ChatType.COMBAT_HONOR_GAIN, ChatType.COMBAT_FACTION_CHANGE, ChatType.RAID_LEADER, ChatType.RAID_WARNING, ChatType.FILTERED, ChatType.BATTLEGROUND, ChatType.BATTLEGROUND_LEADER, ChatType.RESTRICTED, ChatType.ARENA_POINTS, ChatType.PARTY_LEADER}:
            _size += 13 + len(self.sender_name)

        if self.chat_type in {ChatType.ACHIEVEMENT, ChatType.GUILD_ACHIEVEMENT}:
            _size += 4

        return _size


@dataclasses.dataclass
class CMSG_COMMENTATOR_ENABLE:
    option: CommentatorEnableOption

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_COMMENTATOR_ENABLE:
        # option: CommentatorEnableOption
        option = CommentatorEnableOption(await read_int(reader, 4))

        return CMSG_COMMENTATOR_ENABLE(
            option=option,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x03B5))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.option.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CLEAR_TARGET:
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CLEAR_TARGET:
        # target: Guid
        target = await read_int(reader, 8)

        return SMSG_CLEAR_TARGET(
            target=target,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x03BF))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.target)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CROSSED_INEBRIATION_THRESHOLD:
    player: int
    state: int
    item: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CROSSED_INEBRIATION_THRESHOLD:
        # player: Guid
        player = await read_int(reader, 8)

        # state: u32
        state = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        return SMSG_CROSSED_INEBRIATION_THRESHOLD(
            player=player,
            state=state,
            item=item,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x03C1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.player, self.state, self.item])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_KICK_REASON:
    reason: int
    text: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_KICK_REASON:
        # reason: u8
        reason = await read_int(reader, 1)

        # text: CString
        text = await read_cstring(reader)

        return SMSG_KICK_REASON(
            reason=reason,
            text=text,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03C5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'B{len(self.text)}sB'
        _data.extend([self.reason, self.text.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.text)


@dataclasses.dataclass
class MSG_RAID_READY_CHECK_FINISHED_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RAID_READY_CHECK_FINISHED_Client:
        return MSG_RAID_READY_CHECK_FINISHED_Client()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x03C6))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_COMPLAIN:
    complaint_type: SpamType
    offender: int
    unknown1: typing.Optional[int] = None
    mail_id: typing.Optional[int] = None
    unknown2: typing.Optional[int] = None
    language: typing.Optional[int] = None
    message_type: typing.Optional[int] = None
    channel_id: typing.Optional[int] = None
    time: typing.Optional[int] = None
    description: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_COMPLAIN:
        unknown1 = None
        mail_id = None
        unknown2 = None
        language = None
        message_type = None
        channel_id = None
        time = None
        description = None
        # complaint_type: SpamType
        complaint_type = SpamType(await read_int(reader, 1))

        # offender: Guid
        offender = await read_int(reader, 8)

        if complaint_type == SpamType.MAIL:
            # unknown1: u32
            unknown1 = await read_int(reader, 4)

            # mail_id: u32
            mail_id = await read_int(reader, 4)

            # unknown2: u32
            unknown2 = await read_int(reader, 4)

        elif complaint_type == SpamType.CHAT:
            # language: u32
            language = await read_int(reader, 4)

            # message_type: u32
            message_type = await read_int(reader, 4)

            # channel_id: u32
            channel_id = await read_int(reader, 4)

            # time: u32
            time = await read_int(reader, 4)

            # description: CString
            description = await read_cstring(reader)

        return CMSG_COMPLAIN(
            complaint_type=complaint_type,
            offender=offender,
            unknown1=unknown1,
            mail_id=mail_id,
            unknown2=unknown2,
            language=language,
            message_type=message_type,
            channel_id=channel_id,
            time=time,
            description=description,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x03C7))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BQ'
        _data.extend([self.complaint_type.value, self.offender])
        if self.complaint_type == SpamType.MAIL:
            _fmt += 'III'
            _data.extend([self.unknown1, self.mail_id, self.unknown2])
        elif self.complaint_type == SpamType.CHAT:
            _fmt += f'IIII{len(self.description)}sB'
            _data.extend([self.language, self.message_type, self.channel_id, self.time, self.description.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 9

        if self.complaint_type == SpamType.MAIL:
            _size += 12
        elif self.complaint_type == SpamType.CHAT:
            _size += 17 + len(self.description)

        return _size


@dataclasses.dataclass
class SMSG_COMPLAIN_RESULT:
    unknown: int
    window_result: ComplainResultWindow

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_COMPLAIN_RESULT:
        # unknown: u8
        unknown = await read_int(reader, 1)

        # window_result: ComplainResultWindow
        window_result = ComplainResultWindow(await read_int(reader, 1))

        return SMSG_COMPLAIN_RESULT(
            unknown=unknown,
            window_result=window_result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 2, 0x03C8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.unknown, self.window_result.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_FEATURE_SYSTEM_STATUS:
    complaint_status: ComplaintStatus
    voice_chat_enabled: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FEATURE_SYSTEM_STATUS:
        # complaint_status: ComplaintStatus
        complaint_status = ComplaintStatus(await read_int(reader, 1))

        # voice_chat_enabled: Bool8
        voice_chat_enabled = await read_bool(reader, 1)

        return SMSG_FEATURE_SYSTEM_STATUS(
            complaint_status=complaint_status,
            voice_chat_enabled=voice_chat_enabled,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 2, 0x03C9))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.complaint_status.value, self.voice_chat_enabled])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CHANNEL_DISPLAY_LIST:
    channel: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_DISPLAY_LIST:
        # channel: CString
        channel = await read_cstring(reader)

        return CMSG_CHANNEL_DISPLAY_LIST(
            channel=channel,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x03D2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel)}sB'
        _data.extend([self.channel.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.channel)


@dataclasses.dataclass
class CMSG_SET_ACTIVE_VOICE_CHANNEL:
    unknown1: int
    unknown2: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_ACTIVE_VOICE_CHANNEL:
        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # unknown2: CString
        unknown2 = await read_cstring(reader)

        return CMSG_SET_ACTIVE_VOICE_CHANNEL(
            unknown1=unknown1,
            unknown2=unknown2,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x03D3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'I{len(self.unknown2)}sB'
        _data.extend([self.unknown1, self.unknown2.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + len(self.unknown2)


@dataclasses.dataclass
class CMSG_GET_CHANNEL_MEMBER_COUNT:
    channel: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GET_CHANNEL_MEMBER_COUNT:
        # channel: CString
        channel = await read_cstring(reader)

        return CMSG_GET_CHANNEL_MEMBER_COUNT(
            channel=channel,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x03D4))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel)}sB'
        _data.extend([self.channel.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.channel)


@dataclasses.dataclass
class SMSG_CHANNEL_MEMBER_COUNT:
    channel: str
    flags: int
    amount_of_members: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHANNEL_MEMBER_COUNT:
        # channel: CString
        channel = await read_cstring(reader)

        # flags: u8
        flags = await read_int(reader, 1)

        # amount_of_members: u32
        amount_of_members = await read_int(reader, 4)

        return SMSG_CHANNEL_MEMBER_COUNT(
            channel=channel,
            flags=flags,
            amount_of_members=amount_of_members,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03D5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.channel)}sBBI'
        _data.extend([self.channel.encode('utf-8'), 0, self.flags, self.amount_of_members])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 6 + len(self.channel)


@dataclasses.dataclass
class CMSG_CHANNEL_VOICE_ON:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_VOICE_ON:
        return CMSG_CHANNEL_VOICE_ON()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x03D6))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_REPORT_PVP_AFK:
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REPORT_PVP_AFK:
        # player: Guid
        player = await read_int(reader, 8)

        return CMSG_REPORT_PVP_AFK(
            player=player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x03E4))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.player)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_BANKER_ACTIVATE:
    bank: int
    full_update: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_BANKER_ACTIVATE:
        # bank: Guid
        bank = await read_int(reader, 8)

        # full_update: Bool8
        full_update = await read_bool(reader, 1)

        return CMSG_GUILD_BANKER_ACTIVATE(
            bank=bank,
            full_update=full_update,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x03E6))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.bank, self.full_update])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_BANK_QUERY_TAB:
    bank: int
    tab: int
    full_update: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_BANK_QUERY_TAB:
        # bank: Guid
        bank = await read_int(reader, 8)

        # tab: u8
        tab = await read_int(reader, 1)

        # full_update: Bool8
        full_update = await read_bool(reader, 1)

        return CMSG_GUILD_BANK_QUERY_TAB(
            bank=bank,
            tab=tab,
            full_update=full_update,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(10 + 4, 0x03E7))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QBB'
        _data.extend([self.bank, self.tab, self.full_update])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GUILD_BANK_LIST:
    bank_balance: int
    tab_id: int
    amount_of_allowed_item_withdraws: int
    tab_result: GuildBankTabResult
    content_result: GuildBankContentResult
    tabs: typing.Optional[typing.List[GuildBankTab]] = None
    slot_updates: typing.Optional[typing.List[GuildBankSlot]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_BANK_LIST:
        amount_of_bank_tabs = None
        tabs = None
        amount_of_slot_updates = None
        slot_updates = None
        # bank_balance: u64
        bank_balance = await read_int(reader, 8)

        # tab_id: u8
        tab_id = await read_int(reader, 1)

        # amount_of_allowed_item_withdraws: u32
        amount_of_allowed_item_withdraws = await read_int(reader, 4)

        # tab_result: GuildBankTabResult
        tab_result = GuildBankTabResult(await read_int(reader, 1))

        if tab_result == GuildBankTabResult.PRESENT:
            # amount_of_bank_tabs: u8
            amount_of_bank_tabs = await read_int(reader, 1)

            # tabs: GuildBankTab[amount_of_bank_tabs]
            tabs = []
            for _ in range(0, amount_of_bank_tabs):
                tabs.append(await GuildBankTab.read(reader))

        # content_result: GuildBankContentResult
        content_result = GuildBankContentResult(await read_int(reader, 1))

        if content_result == GuildBankContentResult.PRESENT:
            # amount_of_slot_updates: u8
            amount_of_slot_updates = await read_int(reader, 1)

            # slot_updates: GuildBankSlot[amount_of_slot_updates]
            slot_updates = []
            for _ in range(0, amount_of_slot_updates):
                slot_updates.append(await GuildBankSlot.read(reader))

        return SMSG_GUILD_BANK_LIST(
            bank_balance=bank_balance,
            tab_id=tab_id,
            amount_of_allowed_item_withdraws=amount_of_allowed_item_withdraws,
            tab_result=tab_result,
            tabs=tabs,
            content_result=content_result,
            slot_updates=slot_updates,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03E8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QBIB'
        _data.extend([self.bank_balance, self.tab_id, self.amount_of_allowed_item_withdraws, self.tab_result.value])
        if self.tab_result == GuildBankTabResult.PRESENT:
            _fmt += 'B'
            _data.append(len(self.tabs))
            # tabs: GuildBankTab[amount_of_bank_tabs]
            for i in self.tabs:
                _fmt, _data = i.write(_fmt, _data)

        # content_result: GuildBankContentResult
        _fmt += 'B'
        _data.append(self.content_result.value)

        if self.content_result == GuildBankContentResult.PRESENT:
            _fmt += 'B'
            _data.append(len(self.slot_updates))
            # slot_updates: GuildBankSlot[amount_of_slot_updates]
            for i in self.slot_updates:
                _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 15

        if self.tab_result == GuildBankTabResult.PRESENT:
            _size += 1 + sum([i.size() for i in self.tabs])

        if self.content_result == GuildBankContentResult.PRESENT:
            _size += 1 + sum([i.size() for i in self.slot_updates])

        return _size


@dataclasses.dataclass
class CMSG_GUILD_BANK_SWAP_ITEMS:
    bank: int
    source: BankSwapSource
    unknown5: typing.List[int]
    bank_destination_tab: typing.Optional[int] = None
    bank_destination_slot: typing.Optional[int] = None
    unknown1: typing.Optional[int] = None
    bank_source_tab: typing.Optional[int] = None
    bank_source_slot: typing.Optional[int] = None
    item1: typing.Optional[int] = None
    unknown2: typing.Optional[int] = None
    amount: typing.Optional[int] = None
    bank_tab: typing.Optional[int] = None
    bank_slot: typing.Optional[int] = None
    item2: typing.Optional[int] = None
    mode: typing.Optional[BankSwapStoreMode] = None
    auto_count: typing.Optional[int] = None
    unknown3: typing.Optional[int] = None
    unknown4: typing.Optional[int] = None
    player_bag: typing.Optional[int] = None
    player_bag_slot: typing.Optional[int] = None
    bank_to_character_transfer: typing.Optional[bool] = None
    split_amount: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_BANK_SWAP_ITEMS:
        bank_destination_tab = None
        bank_destination_slot = None
        unknown1 = None
        bank_source_tab = None
        bank_source_slot = None
        item1 = None
        unknown2 = None
        amount = None
        bank_tab = None
        bank_slot = None
        item2 = None
        mode = None
        auto_count = None
        unknown3 = None
        unknown4 = None
        player_bag = None
        player_bag_slot = None
        bank_to_character_transfer = None
        split_amount = None
        _size = 0

        # bank: Guid
        bank = await read_int(reader, 8)
        _size += 8

        # source: BankSwapSource
        source = BankSwapSource(await read_int(reader, 1))
        _size += 1

        if source == BankSwapSource.BANK:
            # bank_destination_tab: u8
            bank_destination_tab = await read_int(reader, 1)
            _size += 1

            # bank_destination_slot: u8
            bank_destination_slot = await read_int(reader, 1)
            _size += 1

            # unknown1: u32
            unknown1 = await read_int(reader, 4)
            _size += 4

            # bank_source_tab: u8
            bank_source_tab = await read_int(reader, 1)
            _size += 1

            # bank_source_slot: u8
            bank_source_slot = await read_int(reader, 1)
            _size += 1

            # item1: Item
            item1 = await read_int(reader, 4)
            _size += 4

            # unknown2: u8
            unknown2 = await read_int(reader, 1)
            _size += 1

            # amount: u32
            amount = await read_int(reader, 4)
            _size += 4

        elif source == BankSwapSource.INVENTORY:
            # bank_tab: u8
            bank_tab = await read_int(reader, 1)
            _size += 1

            # bank_slot: u8
            bank_slot = await read_int(reader, 1)
            _size += 1

            # item2: Item
            item2 = await read_int(reader, 4)
            _size += 4

            # mode: BankSwapStoreMode
            mode = BankSwapStoreMode(await read_int(reader, 1))
            _size += 1

            if mode == BankSwapStoreMode.AUTOMATIC:
                # auto_count: u32
                auto_count = await read_int(reader, 4)
                _size += 4

                # unknown3: u8
                unknown3 = await read_int(reader, 1)
                _size += 1

                # unknown4: u32
                unknown4 = await read_int(reader, 4)
                _size += 4

            elif mode == BankSwapStoreMode.MANUAL:
                # player_bag: u8
                player_bag = await read_int(reader, 1)
                _size += 1

                # player_bag_slot: u8
                player_bag_slot = await read_int(reader, 1)
                _size += 1

                # bank_to_character_transfer: Bool8
                bank_to_character_transfer = await read_bool(reader, 1)
                _size += 1

                # split_amount: u32
                split_amount = await read_int(reader, 4)
                _size += 4

        # unknown5: u8[-]
        unknown5 = []
        while _size < body_size:
            unknown5.append(await read_int(reader, 1))
            _size += 1

        return CMSG_GUILD_BANK_SWAP_ITEMS(
            bank=bank,
            source=source,
            bank_destination_tab=bank_destination_tab,
            bank_destination_slot=bank_destination_slot,
            unknown1=unknown1,
            bank_source_tab=bank_source_tab,
            bank_source_slot=bank_source_slot,
            item1=item1,
            unknown2=unknown2,
            amount=amount,
            bank_tab=bank_tab,
            bank_slot=bank_slot,
            item2=item2,
            mode=mode,
            auto_count=auto_count,
            unknown3=unknown3,
            unknown4=unknown4,
            player_bag=player_bag,
            player_bag_slot=player_bag_slot,
            bank_to_character_transfer=bank_to_character_transfer,
            split_amount=split_amount,
            unknown5=unknown5,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x03E9))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.bank, self.source.value])
        if self.source == BankSwapSource.BANK:
            _fmt += 'BBIBBIBI'
            _data.extend([self.bank_destination_tab, self.bank_destination_slot, self.unknown1, self.bank_source_tab, self.bank_source_slot, self.item1, self.unknown2, self.amount])
        elif self.source == BankSwapSource.INVENTORY:
            _fmt += 'BBIB'
            _data.extend([self.bank_tab, self.bank_slot, self.item2, self.mode.value])
            if self.mode == BankSwapStoreMode.AUTOMATIC:
                _fmt += 'IBI'
                _data.extend([self.auto_count, self.unknown3, self.unknown4])
            elif self.mode == BankSwapStoreMode.MANUAL:
                _fmt += 'BBBI'
                _data.extend([self.player_bag, self.player_bag_slot, self.bank_to_character_transfer, self.split_amount])
        # unknown5: u8[-]
        _fmt += f'{len(self.unknown5)}B'
        _data.extend([*self.unknown5])

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 9 + 1 * len(self.unknown5)

        if self.source == BankSwapSource.BANK:
            _size += 17
        elif self.source == BankSwapSource.INVENTORY:
            _size += 7

            if self.mode == BankSwapStoreMode.AUTOMATIC:
                _size += 9
            elif self.mode == BankSwapStoreMode.MANUAL:
                _size += 7


        return _size


@dataclasses.dataclass
class CMSG_GUILD_BANK_BUY_TAB:
    banker: int
    tab: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_BANK_BUY_TAB:
        # banker: Guid
        banker = await read_int(reader, 8)

        # tab: u8
        tab = await read_int(reader, 1)

        return CMSG_GUILD_BANK_BUY_TAB(
            banker=banker,
            tab=tab,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x03EA))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.banker, self.tab])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_BANK_UPDATE_TAB:
    bank: int
    tab: int
    name: str
    icon: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_BANK_UPDATE_TAB:
        # bank: Guid
        bank = await read_int(reader, 8)

        # tab: u8
        tab = await read_int(reader, 1)

        # name: CString
        name = await read_cstring(reader)

        # icon: CString
        icon = await read_cstring(reader)

        return CMSG_GUILD_BANK_UPDATE_TAB(
            bank=bank,
            tab=tab,
            name=name,
            icon=icon,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x03EB))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'QB{len(self.name)}sB{len(self.icon)}sB'
        _data.extend([self.bank, self.tab, self.name.encode('utf-8'), 0, self.icon.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 11 + len(self.name) + len(self.icon)


@dataclasses.dataclass
class CMSG_GUILD_BANK_DEPOSIT_MONEY:
    bank: int
    money: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_BANK_DEPOSIT_MONEY:
        # bank: Guid
        bank = await read_int(reader, 8)

        # money: Gold
        money = await read_int(reader, 4)

        return CMSG_GUILD_BANK_DEPOSIT_MONEY(
            bank=bank,
            money=money,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x03EC))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.bank, self.money])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_BANK_WITHDRAW_MONEY:
    bank: int
    money: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_BANK_WITHDRAW_MONEY:
        # bank: Guid
        bank = await read_int(reader, 8)

        # money: Gold
        money = await read_int(reader, 4)

        return CMSG_GUILD_BANK_WITHDRAW_MONEY(
            bank=bank,
            money=money,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x03ED))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.bank, self.money])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_GUILD_BANK_LOG_QUERY_Client:
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_GUILD_BANK_LOG_QUERY_Client:
        # slot: u8
        slot = await read_int(reader, 1)

        return MSG_GUILD_BANK_LOG_QUERY_Client(
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x03EE))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.slot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_GUILD_BANK_LOG_QUERY_Server:
    unix_time: int
    slot: int
    money_logs: typing.List[MoneyLogItem]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_GUILD_BANK_LOG_QUERY_Server:
        # unix_time: u32
        unix_time = await read_int(reader, 4)

        # slot: u8
        slot = await read_int(reader, 1)

        # amount_of_money_logs: u8
        amount_of_money_logs = await read_int(reader, 1)

        # money_logs: MoneyLogItem[amount_of_money_logs]
        money_logs = []
        for _ in range(0, amount_of_money_logs):
            money_logs.append(await MoneyLogItem.read(reader))

        return MSG_GUILD_BANK_LOG_QUERY_Server(
            unix_time=unix_time,
            slot=slot,
            money_logs=money_logs,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03EE))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IBB'
        _data.extend([self.unix_time, self.slot, len(self.money_logs)])
        # money_logs: MoneyLogItem[amount_of_money_logs]
        for i in self.money_logs:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 6 + 17 * len(self.money_logs)


@dataclasses.dataclass
class CMSG_SET_CHANNEL_WATCH:
    channel: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_CHANNEL_WATCH:
        # channel: CString
        channel = await read_cstring(reader)

        return CMSG_SET_CHANNEL_WATCH(
            channel=channel,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x03EF))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel)}sB'
        _data.extend([self.channel.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.channel)


@dataclasses.dataclass
class SMSG_USERLIST_ADD:
    player: int
    player_flags: int
    flags: int
    amount_of_players: int
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_USERLIST_ADD:
        # player: Guid
        player = await read_int(reader, 8)

        # player_flags: u8
        player_flags = await read_int(reader, 1)

        # flags: u8
        flags = await read_int(reader, 1)

        # amount_of_players: u32
        amount_of_players = await read_int(reader, 4)

        # name: CString
        name = await read_cstring(reader)

        return SMSG_USERLIST_ADD(
            player=player,
            player_flags=player_flags,
            flags=flags,
            amount_of_players=amount_of_players,
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03F0))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QBBI{len(self.name)}sB'
        _data.extend([self.player, self.player_flags, self.flags, self.amount_of_players, self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 15 + len(self.name)


@dataclasses.dataclass
class SMSG_USERLIST_REMOVE:
    player: int
    flags: int
    amount_of_players: int
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_USERLIST_REMOVE:
        # player: Guid
        player = await read_int(reader, 8)

        # flags: u8
        flags = await read_int(reader, 1)

        # amount_of_players: u32
        amount_of_players = await read_int(reader, 4)

        # name: CString
        name = await read_cstring(reader)

        return SMSG_USERLIST_REMOVE(
            player=player,
            flags=flags,
            amount_of_players=amount_of_players,
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03F1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QBI{len(self.name)}sB'
        _data.extend([self.player, self.flags, self.amount_of_players, self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 14 + len(self.name)


@dataclasses.dataclass
class SMSG_USERLIST_UPDATE:
    player: int
    player_flags: int
    flags: int
    amount_of_players: int
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_USERLIST_UPDATE:
        # player: Guid
        player = await read_int(reader, 8)

        # player_flags: u8
        player_flags = await read_int(reader, 1)

        # flags: u8
        flags = await read_int(reader, 1)

        # amount_of_players: u32
        amount_of_players = await read_int(reader, 4)

        # name: CString
        name = await read_cstring(reader)

        return SMSG_USERLIST_UPDATE(
            player=player,
            player_flags=player_flags,
            flags=flags,
            amount_of_players=amount_of_players,
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03F2))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QBBI{len(self.name)}sB'
        _data.extend([self.player, self.player_flags, self.flags, self.amount_of_players, self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 15 + len(self.name)


@dataclasses.dataclass
class CMSG_CLEAR_CHANNEL_WATCH:
    channel: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CLEAR_CHANNEL_WATCH:
        # channel: CString
        channel = await read_cstring(reader)

        return CMSG_CLEAR_CHANNEL_WATCH(
            channel=channel,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x03F3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel)}sB'
        _data.extend([self.channel.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.channel)


@dataclasses.dataclass
class SMSG_INSPECT_TALENT:
    player: int
    unspent_talent_points: int
    active_spec: int
    specs: typing.List[InspectTalentSpec]
    glyphs: typing.List[int]
    talent_gear_mask: InspectTalentGearMask

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INSPECT_TALENT:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # unspent_talent_points: u32
        unspent_talent_points = await read_int(reader, 4)

        # amount_of_specs: u8
        amount_of_specs = await read_int(reader, 1)

        # active_spec: u8
        active_spec = await read_int(reader, 1)

        # specs: InspectTalentSpec[amount_of_specs]
        specs = []
        for _ in range(0, amount_of_specs):
            specs.append(await InspectTalentSpec.read(reader))

        # amount_of_glyphs: u8
        amount_of_glyphs = await read_int(reader, 1)

        # glyphs: u16[amount_of_glyphs]
        glyphs = []
        for _ in range(0, amount_of_glyphs):
            glyphs.append(await read_int(reader, 2))

        # talent_gear_mask: InspectTalentGearMask
        talent_gear_mask = await InspectTalentGearMask.read(reader)

        return SMSG_INSPECT_TALENT(
            player=player,
            unspent_talent_points=unspent_talent_points,
            active_spec=active_spec,
            specs=specs,
            glyphs=glyphs,
            talent_gear_mask=talent_gear_mask,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03F4))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # unspent_talent_points: u32
        _fmt += 'I'
        _data.append(self.unspent_talent_points)

        # amount_of_specs: u8
        _fmt += 'B'
        _data.append(len(self.specs))

        # active_spec: u8
        _fmt += 'B'
        _data.append(self.active_spec)

        # specs: InspectTalentSpec[amount_of_specs]
        for i in self.specs:
            _fmt, _data = i.write(_fmt, _data)

        # amount_of_glyphs: u8
        _fmt += 'B'
        _data.append(len(self.glyphs))

        # glyphs: u16[amount_of_glyphs]
        _fmt += f'{len(self.glyphs)}H'
        _data.extend([*self.glyphs])

        # talent_gear_mask: InspectTalentGearMask
        _fmt, _data = self.talent_gear_mask.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 7 + packed_guid_size(self.player) + sum([i.size() for i in self.specs]) + 2 * len(self.glyphs) + self.talent_gear_mask.size()


@dataclasses.dataclass
class CMSG_SPELLCLICK:
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SPELLCLICK:
        # target: Guid
        target = await read_int(reader, 8)

        return CMSG_SPELLCLICK(
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x03F8))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.target)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_LIST:
    creature: int
    master_looter: int
    group_looter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_LIST:
        # creature: Guid
        creature = await read_int(reader, 8)

        # master_looter: PackedGuid
        master_looter = await read_packed_guid(reader)

        # group_looter: PackedGuid
        group_looter = await read_packed_guid(reader)

        return SMSG_LOOT_LIST(
            creature=creature,
            master_looter=master_looter,
            group_looter=group_looter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03F9))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.creature)
        # master_looter: PackedGuid
        _fmt, _data = packed_guid_write(self.master_looter, _fmt, _data)

        # group_looter: PackedGuid
        _fmt, _data = packed_guid_write(self.group_looter, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.master_looter) + packed_guid_size(self.group_looter)


@dataclasses.dataclass
class MSG_GUILD_PERMISSIONS_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_GUILD_PERMISSIONS_Client:
        return MSG_GUILD_PERMISSIONS_Client()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x03FD))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_GUILD_PERMISSIONS_Server:
    id: int
    rights: int
    gold_limit_per_day: int
    purchased_bank_tabs: int
    bank_tabs: typing.List[BankTab]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_GUILD_PERMISSIONS_Server:
        # id: u32
        id = await read_int(reader, 4)

        # rights: u32
        rights = await read_int(reader, 4)

        # gold_limit_per_day: Gold
        gold_limit_per_day = await read_int(reader, 4)

        # purchased_bank_tabs: u8
        purchased_bank_tabs = await read_int(reader, 1)

        # bank_tabs: BankTab[6]
        bank_tabs = []
        for _ in range(0, 6):
            bank_tabs.append(await BankTab.read(reader))

        return MSG_GUILD_PERMISSIONS_Server(
            id=id,
            rights=rights,
            gold_limit_per_day=gold_limit_per_day,
            purchased_bank_tabs=purchased_bank_tabs,
            bank_tabs=bank_tabs,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(61 + 2, 0x03FD))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIB'
        _data.extend([self.id, self.rights, self.gold_limit_per_day, self.purchased_bank_tabs])
        # bank_tabs: BankTab[6]
        for i in self.bank_tabs:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_GUILD_BANK_MONEY_WITHDRAWN_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_GUILD_BANK_MONEY_WITHDRAWN_Client:
        return MSG_GUILD_BANK_MONEY_WITHDRAWN_Client()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x03FE))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_GUILD_BANK_MONEY_WITHDRAWN_Server:
    remaining_withdraw_amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_GUILD_BANK_MONEY_WITHDRAWN_Server:
        # remaining_withdraw_amount: u32
        remaining_withdraw_amount = await read_int(reader, 4)

        return MSG_GUILD_BANK_MONEY_WITHDRAWN_Server(
            remaining_withdraw_amount=remaining_withdraw_amount,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x03FE))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.remaining_withdraw_amount)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_GUILD_EVENT_LOG_QUERY_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_GUILD_EVENT_LOG_QUERY_Client:
        return MSG_GUILD_EVENT_LOG_QUERY_Client()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x03FF))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_GUILD_EVENT_LOG_QUERY_Server:
    events: typing.List[GuildLogEvent]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_GUILD_EVENT_LOG_QUERY_Server:
        # amount_of_events: u8
        amount_of_events = await read_int(reader, 1)

        # events: GuildLogEvent[amount_of_events]
        events = []
        for _ in range(0, amount_of_events):
            events.append(await GuildLogEvent.read(reader))

        return MSG_GUILD_EVENT_LOG_QUERY_Server(
            events=events,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x03FF))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(len(self.events))
        # events: GuildLogEvent[amount_of_events]
        for i in self.events:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + sum([i.size() for i in self.events])


@dataclasses.dataclass
class CMSG_GET_MIRRORIMAGE_DATA:
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GET_MIRRORIMAGE_DATA:
        # target: Guid
        target = await read_int(reader, 8)

        return CMSG_GET_MIRRORIMAGE_DATA(
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0401))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.target)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MIRRORIMAGE_DATA:
    guid: int
    display_id: int
    race: Race
    gender: Gender
    class_type: Class
    skin_color: int
    face: int
    hair_style: int
    hair_color: int
    facial_hair: int
    guild_id: int
    display_ids: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MIRRORIMAGE_DATA:
        # guid: Guid
        guid = await read_int(reader, 8)

        # display_id: u32
        display_id = await read_int(reader, 4)

        # race: Race
        race = Race(await read_int(reader, 1))

        # gender: Gender
        gender = Gender(await read_int(reader, 1))

        # class_type: Class
        class_type = Class(await read_int(reader, 1))

        # skin_color: u8
        skin_color = await read_int(reader, 1)

        # face: u8
        face = await read_int(reader, 1)

        # hair_style: u8
        hair_style = await read_int(reader, 1)

        # hair_color: u8
        hair_color = await read_int(reader, 1)

        # facial_hair: u8
        facial_hair = await read_int(reader, 1)

        # guild_id: u32
        guild_id = await read_int(reader, 4)

        # display_ids: u32[11]
        display_ids = []
        for _ in range(0, 11):
            display_ids.append(await read_int(reader, 4))

        return SMSG_MIRRORIMAGE_DATA(
            guid=guid,
            display_id=display_id,
            race=race,
            gender=gender,
            class_type=class_type,
            skin_color=skin_color,
            face=face,
            hair_style=hair_style,
            hair_color=hair_color,
            facial_hair=facial_hair,
            guild_id=guild_id,
            display_ids=display_ids,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(68 + 2, 0x0402))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QIBBBBBBBBI{len(self.display_ids)}I'
        _data.extend([self.guid, self.display_id, self.race.value, self.gender.value, self.class_type.value, self.skin_color, self.face, self.hair_style, self.hair_color, self.facial_hair, self.guild_id, *self.display_ids])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_KEEP_ALIVE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_KEEP_ALIVE:
        return CMSG_KEEP_ALIVE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0407))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_OPT_OUT_OF_LOOT:
    pass_on_loot: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_OPT_OUT_OF_LOOT:
        # pass_on_loot: Bool32
        pass_on_loot = await read_bool(reader, 4)

        return CMSG_OPT_OUT_OF_LOOT(
            pass_on_loot=pass_on_loot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0409))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.pass_on_loot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_QUERY_GUILD_BANK_TEXT_Client:
    tab: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_QUERY_GUILD_BANK_TEXT_Client:
        # tab: u8
        tab = await read_int(reader, 1)

        return MSG_QUERY_GUILD_BANK_TEXT_Client(
            tab=tab,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x040A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.tab)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_QUERY_GUILD_BANK_TEXT_Server:
    tab: int
    text: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_QUERY_GUILD_BANK_TEXT_Server:
        # tab: u8
        tab = await read_int(reader, 1)

        # text: CString
        text = await read_cstring(reader)

        return MSG_QUERY_GUILD_BANK_TEXT_Server(
            tab=tab,
            text=text,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x040A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'B{len(self.text)}sB'
        _data.extend([self.tab, self.text.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.text)


@dataclasses.dataclass
class CMSG_SET_GUILD_BANK_TEXT:
    tab: int
    text: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_GUILD_BANK_TEXT:
        # tab: u8
        tab = await read_int(reader, 1)

        # text: CString
        text = await read_cstring(reader)

        return CMSG_SET_GUILD_BANK_TEXT(
            tab=tab,
            text=text,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x040B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'B{len(self.text)}sB'
        _data.extend([self.tab, self.text.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.text)


@dataclasses.dataclass
class CMSG_GRANT_LEVEL:
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GRANT_LEVEL:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        return CMSG_GRANT_LEVEL(
            player=player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x040D))
        _fmt = "<6s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player)


@dataclasses.dataclass
class SMSG_OVERRIDE_LIGHT:
    default_id: int
    id_override: int
    fade_in_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_OVERRIDE_LIGHT:
        # default_id: u32
        default_id = await read_int(reader, 4)

        # id_override: u32
        id_override = await read_int(reader, 4)

        # fade_in_time: Seconds
        fade_in_time = await read_int(reader, 4)

        return SMSG_OVERRIDE_LIGHT(
            default_id=default_id,
            id_override=id_override,
            fade_in_time=fade_in_time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0412))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'III'
        _data.extend([self.default_id, self.id_override, self.fade_in_time])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TOTEM_CREATED:
    slot: int
    totem: int
    duration: int
    spell: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TOTEM_CREATED:
        # slot: u8
        slot = await read_int(reader, 1)

        # totem: Guid
        totem = await read_int(reader, 8)

        # duration: u32
        duration = await read_int(reader, 4)

        # spell: Spell
        spell = await read_int(reader, 4)

        return SMSG_TOTEM_CREATED(
            slot=slot,
            totem=totem,
            duration=duration,
            spell=spell,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(17 + 2, 0x0413))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BQII'
        _data.extend([self.slot, self.totem, self.duration, self.spell])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TOTEM_DESTROYED:
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TOTEM_DESTROYED:
        # slot: u8
        slot = await read_int(reader, 1)

        return CMSG_TOTEM_DESTROYED(
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x0414))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.slot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUESTGIVER_STATUS_MULTIPLE_QUERY:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_STATUS_MULTIPLE_QUERY:
        return CMSG_QUESTGIVER_STATUS_MULTIPLE_QUERY()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0417))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_STATUS_MULTIPLE:
    statuses: typing.List[QuestGiverStatusReport]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_STATUS_MULTIPLE:
        # amount_of_statuses: u32
        amount_of_statuses = await read_int(reader, 4)

        # statuses: QuestGiverStatusReport[amount_of_statuses]
        statuses = []
        for _ in range(0, amount_of_statuses):
            statuses.append(await QuestGiverStatusReport.read(reader))

        return SMSG_QUESTGIVER_STATUS_MULTIPLE(
            statuses=statuses,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0418))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.statuses))
        # statuses: QuestGiverStatusReport[amount_of_statuses]
        for i in self.statuses:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + 9 * len(self.statuses)


@dataclasses.dataclass
class CMSG_SET_PLAYER_DECLINED_NAMES:
    player: int
    name: str
    declined_names: typing.List[str]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_PLAYER_DECLINED_NAMES:
        # player: Guid
        player = await read_int(reader, 8)

        # name: CString
        name = await read_cstring(reader)

        # declined_names: CString[5]
        declined_names = []
        for _ in range(0, 5):
            declined_names.append(await read_cstring(reader))

        return CMSG_SET_PLAYER_DECLINED_NAMES(
            player=player,
            name=name,
            declined_names=declined_names,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0419))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.name)}sB'
        _data.extend([self.player, self.name.encode('utf-8'), 0])
        # declined_names: CString[5]
        for i in self.declined_names:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.name) + sum([len(i) + 1 for i in self.declined_names])


@dataclasses.dataclass
class SMSG_SET_PLAYER_DECLINED_NAMES_RESULT:
    result: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_PLAYER_DECLINED_NAMES_RESULT:
        # result: u32
        result = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_SET_PLAYER_DECLINED_NAMES_RESULT(
            result=result,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x041A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.result, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SEND_UNLEARN_SPELLS:
    spells: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SEND_UNLEARN_SPELLS:
        # amount_of_spells: u32
        amount_of_spells = await read_int(reader, 4)

        # spells: Spell[amount_of_spells]
        spells = []
        for _ in range(0, amount_of_spells):
            spells.append(await read_int(reader, 4))

        return SMSG_SEND_UNLEARN_SPELLS(
            spells=spells,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x041E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.spells))
        # spells: Spell[amount_of_spells]
        _fmt += f'len({self.spells})I'
        _data.extend(self.spells)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + 4 * len(self.spells)


@dataclasses.dataclass
class SMSG_PROPOSE_LEVEL_GRANT:
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PROPOSE_LEVEL_GRANT:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        return SMSG_PROPOSE_LEVEL_GRANT(
            player=player,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x041F))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player)


@dataclasses.dataclass
class CMSG_ACCEPT_LEVEL_GRANT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ACCEPT_LEVEL_GRANT:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return CMSG_ACCEPT_LEVEL_GRANT(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0420))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_REFER_A_FRIEND_FAILURE:
    error: ReferAFriendError
    target_name: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_REFER_A_FRIEND_FAILURE:
        target_name = None
        # error: ReferAFriendError
        error = ReferAFriendError(await read_int(reader, 4))

        if error == ReferAFriendError.NOT_IN_GROUP:
            # target_name: CString
            target_name = await read_cstring(reader)

        return SMSG_REFER_A_FRIEND_FAILURE(
            error=error,
            target_name=target_name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0421))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.error.value)
        if self.error == ReferAFriendError.NOT_IN_GROUP:
            _fmt += f'{len(self.target_name)}sB'
            _data.extend([self.target_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        if self.error == ReferAFriendError.NOT_IN_GROUP:
            _size += 1 + len(self.target_name)

        return _size


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_SET_FLYING:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_SET_FLYING:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_SET_FLYING(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0422))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_UNSET_FLYING:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_UNSET_FLYING:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_UNSET_FLYING(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0423))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_ALTER_APPEARANCE:
    hair: int
    hair_color: int
    facial_hair: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ALTER_APPEARANCE:
        # hair: u32
        hair = await read_int(reader, 4)

        # hair_color: u32
        hair_color = await read_int(reader, 4)

        # facial_hair: u32
        facial_hair = await read_int(reader, 4)

        return CMSG_ALTER_APPEARANCE(
            hair=hair,
            hair_color=hair_color,
            facial_hair=facial_hair,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0426))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'III'
        _data.extend([self.hair, self.hair_color, self.facial_hair])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ENABLE_BARBER_SHOP:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ENABLE_BARBER_SHOP:
        return SMSG_ENABLE_BARBER_SHOP()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0427))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BARBER_SHOP_RESULT:
    result: BarberShopResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BARBER_SHOP_RESULT:
        # result: BarberShopResult
        result = BarberShopResult(await read_int(reader, 4))

        return SMSG_BARBER_SHOP_RESULT(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0428))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CALENDAR_GET_CALENDAR:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CALENDAR_GET_CALENDAR:
        return CMSG_CALENDAR_GET_CALENDAR()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0429))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CALENDAR_GET_EVENT:
    event: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CALENDAR_GET_EVENT:
        # event: Guid
        event = await read_int(reader, 8)

        return CMSG_CALENDAR_GET_EVENT(
            event=event,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x042A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.event)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CALENDAR_GUILD_FILTER:
    minimum_level: int
    maximum_level: int
    minimum_rank: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CALENDAR_GUILD_FILTER:
        # minimum_level: Level32
        minimum_level = await read_int(reader, 4)

        # maximum_level: Level32
        maximum_level = await read_int(reader, 4)

        # minimum_rank: u32
        minimum_rank = await read_int(reader, 4)

        return CMSG_CALENDAR_GUILD_FILTER(
            minimum_level=minimum_level,
            maximum_level=maximum_level,
            minimum_rank=minimum_rank,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x042B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'III'
        _data.extend([self.minimum_level, self.maximum_level, self.minimum_rank])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CALENDAR_ARENA_TEAM:
    arena_team: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CALENDAR_ARENA_TEAM:
        # arena_team: u32
        arena_team = await read_int(reader, 4)

        return CMSG_CALENDAR_ARENA_TEAM(
            arena_team=arena_team,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x042C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.arena_team)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CALENDAR_ADD_EVENT:
    title: str
    description: str
    event_type: int
    repeatable: bool
    maximum_invites: int
    dungeon_id: int
    event_time: int
    time_zone_time: int
    flags: int
    invitees: typing.List[CalendarInvitee]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CALENDAR_ADD_EVENT:
        # title: CString
        title = await read_cstring(reader)

        # description: CString
        description = await read_cstring(reader)

        # event_type: u8
        event_type = await read_int(reader, 1)

        # repeatable: Bool8
        repeatable = await read_bool(reader, 1)

        # maximum_invites: u32
        maximum_invites = await read_int(reader, 4)

        # dungeon_id: u32
        dungeon_id = await read_int(reader, 4)

        # event_time: DateTime
        event_time = await read_int(reader, 4)

        # time_zone_time: DateTime
        time_zone_time = await read_int(reader, 4)

        # flags: u32
        flags = await read_int(reader, 4)

        # amount_of_invitees: u32
        amount_of_invitees = await read_int(reader, 4)

        # invitees: CalendarInvitee[amount_of_invitees]
        invitees = []
        for _ in range(0, amount_of_invitees):
            invitees.append(await CalendarInvitee.read(reader))

        return CMSG_CALENDAR_ADD_EVENT(
            title=title,
            description=description,
            event_type=event_type,
            repeatable=repeatable,
            maximum_invites=maximum_invites,
            dungeon_id=dungeon_id,
            event_time=event_time,
            time_zone_time=time_zone_time,
            flags=flags,
            invitees=invitees,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x042D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.title)}sB{len(self.description)}sBBBIIIIII'
        _data.extend([self.title.encode('utf-8'), 0, self.description.encode('utf-8'), 0, self.event_type, self.repeatable, self.maximum_invites, self.dungeon_id, self.event_time, self.time_zone_time, self.flags, len(self.invitees)])
        # invitees: CalendarInvitee[amount_of_invitees]
        for i in self.invitees:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 28 + len(self.title) + len(self.description) + sum([i.size() for i in self.invitees])


@dataclasses.dataclass
class CMSG_CALENDAR_UPDATE_EVENT:
    event: int
    invite_id: int
    title: str
    description: str
    event_type: int
    repeatable: bool
    maximum_invites: int
    dungeon_id: int
    event_time: int
    time_zone_time: int
    flags: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CALENDAR_UPDATE_EVENT:
        # event: Guid
        event = await read_int(reader, 8)

        # invite_id: Guid
        invite_id = await read_int(reader, 8)

        # title: CString
        title = await read_cstring(reader)

        # description: CString
        description = await read_cstring(reader)

        # event_type: u8
        event_type = await read_int(reader, 1)

        # repeatable: Bool8
        repeatable = await read_bool(reader, 1)

        # maximum_invites: u32
        maximum_invites = await read_int(reader, 4)

        # dungeon_id: u32
        dungeon_id = await read_int(reader, 4)

        # event_time: DateTime
        event_time = await read_int(reader, 4)

        # time_zone_time: DateTime
        time_zone_time = await read_int(reader, 4)

        # flags: u32
        flags = await read_int(reader, 4)

        return CMSG_CALENDAR_UPDATE_EVENT(
            event=event,
            invite_id=invite_id,
            title=title,
            description=description,
            event_type=event_type,
            repeatable=repeatable,
            maximum_invites=maximum_invites,
            dungeon_id=dungeon_id,
            event_time=event_time,
            time_zone_time=time_zone_time,
            flags=flags,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x042E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'QQ{len(self.title)}sB{len(self.description)}sBBBIIIII'
        _data.extend([self.event, self.invite_id, self.title.encode('utf-8'), 0, self.description.encode('utf-8'), 0, self.event_type, self.repeatable, self.maximum_invites, self.dungeon_id, self.event_time, self.time_zone_time, self.flags])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 40 + len(self.title) + len(self.description)


@dataclasses.dataclass
class CMSG_CALENDAR_REMOVE_EVENT:
    event: int
    invite_id: int
    flags: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CALENDAR_REMOVE_EVENT:
        # event: Guid
        event = await read_int(reader, 8)

        # invite_id: Guid
        invite_id = await read_int(reader, 8)

        # flags: u32
        flags = await read_int(reader, 4)

        return CMSG_CALENDAR_REMOVE_EVENT(
            event=event,
            invite_id=invite_id,
            flags=flags,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 4, 0x042F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QQI'
        _data.extend([self.event, self.invite_id, self.flags])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CALENDAR_COPY_EVENT:
    event: int
    invite_id: int
    time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CALENDAR_COPY_EVENT:
        # event: Guid
        event = await read_int(reader, 8)

        # invite_id: Guid
        invite_id = await read_int(reader, 8)

        # time: DateTime
        time = await read_int(reader, 4)

        return CMSG_CALENDAR_COPY_EVENT(
            event=event,
            invite_id=invite_id,
            time=time,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 4, 0x0430))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QQI'
        _data.extend([self.event, self.invite_id, self.time])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CALENDAR_EVENT_INVITE:
    event: int
    invite_id: int
    name: str
    pre_event: bool
    guild_event: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CALENDAR_EVENT_INVITE:
        # event: Guid
        event = await read_int(reader, 8)

        # invite_id: Guid
        invite_id = await read_int(reader, 8)

        # name: CString
        name = await read_cstring(reader)

        # pre_event: Bool8
        pre_event = await read_bool(reader, 1)

        # guild_event: Bool8
        guild_event = await read_bool(reader, 1)

        return CMSG_CALENDAR_EVENT_INVITE(
            event=event,
            invite_id=invite_id,
            name=name,
            pre_event=pre_event,
            guild_event=guild_event,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0431))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'QQ{len(self.name)}sBBB'
        _data.extend([self.event, self.invite_id, self.name.encode('utf-8'), 0, self.pre_event, self.guild_event])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 19 + len(self.name)


@dataclasses.dataclass
class CMSG_CALENDAR_EVENT_RSVP:
    event: int
    invite_id: int
    status: CalendarStatus

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CALENDAR_EVENT_RSVP:
        # event: Guid
        event = await read_int(reader, 8)

        # invite_id: Guid
        invite_id = await read_int(reader, 8)

        # status: CalendarStatus
        status = CalendarStatus(await read_int(reader, 4))

        return CMSG_CALENDAR_EVENT_RSVP(
            event=event,
            invite_id=invite_id,
            status=status,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 4, 0x0432))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QQI'
        _data.extend([self.event, self.invite_id, self.status.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CALENDAR_EVENT_REMOVE_INVITE:
    event: int
    sender_invite_id: int
    invite_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CALENDAR_EVENT_REMOVE_INVITE:
        # event: Guid
        event = await read_int(reader, 8)

        # sender_invite_id: Guid
        sender_invite_id = await read_int(reader, 8)

        # invite_id: Guid
        invite_id = await read_int(reader, 8)

        return CMSG_CALENDAR_EVENT_REMOVE_INVITE(
            event=event,
            sender_invite_id=sender_invite_id,
            invite_id=invite_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(24 + 4, 0x0433))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QQQ'
        _data.extend([self.event, self.sender_invite_id, self.invite_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CALENDAR_EVENT_STATUS:
    event: int
    invite_id: int
    sender_invite_id: int
    status: CalendarStatus

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CALENDAR_EVENT_STATUS:
        # event: Guid
        event = await read_int(reader, 8)

        # invite_id: Guid
        invite_id = await read_int(reader, 8)

        # sender_invite_id: Guid
        sender_invite_id = await read_int(reader, 8)

        # status: CalendarStatus
        status = CalendarStatus(await read_int(reader, 1))

        return CMSG_CALENDAR_EVENT_STATUS(
            event=event,
            invite_id=invite_id,
            sender_invite_id=sender_invite_id,
            status=status,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(25 + 4, 0x0434))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QQQB'
        _data.extend([self.event, self.invite_id, self.sender_invite_id, self.status.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CALENDAR_EVENT_MODERATOR_STATUS:
    event: int
    invite_id: int
    sender_invite_id: int
    rank: CalendarModeratorRank

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CALENDAR_EVENT_MODERATOR_STATUS:
        # event: Guid
        event = await read_int(reader, 8)

        # invite_id: Guid
        invite_id = await read_int(reader, 8)

        # sender_invite_id: Guid
        sender_invite_id = await read_int(reader, 8)

        # rank: CalendarModeratorRank
        rank = CalendarModeratorRank(await read_int(reader, 1))

        return CMSG_CALENDAR_EVENT_MODERATOR_STATUS(
            event=event,
            invite_id=invite_id,
            sender_invite_id=sender_invite_id,
            rank=rank,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(25 + 4, 0x0435))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QQQB'
        _data.extend([self.event, self.invite_id, self.sender_invite_id, self.rank.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CALENDAR_SEND_CALENDAR:
    invites: typing.List[SendCalendarInvite]
    events: typing.List[SendCalendarEvent]
    current_time: int
    zone_time: int
    instances: typing.List[SendCalendarInstance]
    relative_time: int
    reset_times: typing.List[SendCalendarResetTime]
    amount_of_holidays: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CALENDAR_SEND_CALENDAR:
        # amount_of_invites: u32
        amount_of_invites = await read_int(reader, 4)

        # invites: SendCalendarInvite[amount_of_invites]
        invites = []
        for _ in range(0, amount_of_invites):
            invites.append(await SendCalendarInvite.read(reader))

        # amount_of_events: u32
        amount_of_events = await read_int(reader, 4)

        # events: SendCalendarEvent[amount_of_events]
        events = []
        for _ in range(0, amount_of_events):
            events.append(await SendCalendarEvent.read(reader))

        # current_time: u32
        current_time = await read_int(reader, 4)

        # zone_time: DateTime
        zone_time = await read_int(reader, 4)

        # amount_of_instances: u32
        amount_of_instances = await read_int(reader, 4)

        # instances: SendCalendarInstance[amount_of_instances]
        instances = []
        for _ in range(0, amount_of_instances):
            instances.append(await SendCalendarInstance.read(reader))

        # relative_time: u32
        relative_time = await read_int(reader, 4)

        # amount_of_reset_times: u32
        amount_of_reset_times = await read_int(reader, 4)

        # reset_times: SendCalendarResetTime[amount_of_reset_times]
        reset_times = []
        for _ in range(0, amount_of_reset_times):
            reset_times.append(await SendCalendarResetTime.read(reader))

        # amount_of_holidays: u32
        amount_of_holidays = await read_int(reader, 4)

        return SMSG_CALENDAR_SEND_CALENDAR(
            invites=invites,
            events=events,
            current_time=current_time,
            zone_time=zone_time,
            instances=instances,
            relative_time=relative_time,
            reset_times=reset_times,
            amount_of_holidays=amount_of_holidays,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0436))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.invites))
        # invites: SendCalendarInvite[amount_of_invites]
        for i in self.invites:
            _fmt, _data = i.write(_fmt, _data)

        # amount_of_events: u32
        _fmt += 'I'
        _data.append(len(self.events))

        # events: SendCalendarEvent[amount_of_events]
        for i in self.events:
            _fmt, _data = i.write(_fmt, _data)

        # current_time: u32
        _fmt += 'I'
        _data.append(self.current_time)

        # zone_time: DateTime
        _fmt += 'I'
        _data.append(self.zone_time)

        # amount_of_instances: u32
        _fmt += 'I'
        _data.append(len(self.instances))

        # instances: SendCalendarInstance[amount_of_instances]
        for i in self.instances:
            _fmt, _data = i.write(_fmt, _data)

        # relative_time: u32
        _fmt += 'I'
        _data.append(self.relative_time)

        # amount_of_reset_times: u32
        _fmt += 'I'
        _data.append(len(self.reset_times))

        # reset_times: SendCalendarResetTime[amount_of_reset_times]
        for i in self.reset_times:
            _fmt, _data = i.write(_fmt, _data)

        # amount_of_holidays: u32
        _fmt += 'I'
        _data.append(self.amount_of_holidays)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 32 + sum([i.size() for i in self.invites]) + sum([i.size() for i in self.events]) + 20 * len(self.instances) + 12 * len(self.reset_times)


@dataclasses.dataclass
class SMSG_CALENDAR_SEND_EVENT:
    send_type: int
    creator: int
    event_id: int
    title: str
    description: str
    event_type: int
    repeatable: int
    max_invitees: int
    dungeon_id: int
    flags: int
    event_time: int
    time_zone_time: int
    guild_id: int
    invitees: typing.List[CalendarSendInvitee]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CALENDAR_SEND_EVENT:
        # send_type: u8
        send_type = await read_int(reader, 1)

        # creator: PackedGuid
        creator = await read_packed_guid(reader)

        # event_id: Guid
        event_id = await read_int(reader, 8)

        # title: CString
        title = await read_cstring(reader)

        # description: CString
        description = await read_cstring(reader)

        # event_type: u8
        event_type = await read_int(reader, 1)

        # repeatable: u8
        repeatable = await read_int(reader, 1)

        # max_invitees: u32
        max_invitees = await read_int(reader, 4)

        # dungeon_id: u32
        dungeon_id = await read_int(reader, 4)

        # flags: u32
        flags = await read_int(reader, 4)

        # event_time: DateTime
        event_time = await read_int(reader, 4)

        # time_zone_time: DateTime
        time_zone_time = await read_int(reader, 4)

        # guild_id: u32
        guild_id = await read_int(reader, 4)

        # amount_of_invitees: u32
        amount_of_invitees = await read_int(reader, 4)

        # invitees: CalendarSendInvitee[amount_of_invitees]
        invitees = []
        for _ in range(0, amount_of_invitees):
            invitees.append(await CalendarSendInvitee.read(reader))

        return SMSG_CALENDAR_SEND_EVENT(
            send_type=send_type,
            creator=creator,
            event_id=event_id,
            title=title,
            description=description,
            event_type=event_type,
            repeatable=repeatable,
            max_invitees=max_invitees,
            dungeon_id=dungeon_id,
            flags=flags,
            event_time=event_time,
            time_zone_time=time_zone_time,
            guild_id=guild_id,
            invitees=invitees,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0437))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.send_type)
        # creator: PackedGuid
        _fmt, _data = packed_guid_write(self.creator, _fmt, _data)

        # event_id: Guid
        _fmt += 'Q'
        _data.append(self.event_id)

        # title: CString
        _fmt += f'{len(self.title)}sB'
        _data.extend([self.title.encode('utf-8'), 0])

        # description: CString
        _fmt += f'{len(self.description)}sB'
        _data.extend([self.description.encode('utf-8'), 0])

        # event_type: u8
        _fmt += 'B'
        _data.append(self.event_type)

        # repeatable: u8
        _fmt += 'B'
        _data.append(self.repeatable)

        # max_invitees: u32
        _fmt += 'I'
        _data.append(self.max_invitees)

        # dungeon_id: u32
        _fmt += 'I'
        _data.append(self.dungeon_id)

        # flags: u32
        _fmt += 'I'
        _data.append(self.flags)

        # event_time: DateTime
        _fmt += 'I'
        _data.append(self.event_time)

        # time_zone_time: DateTime
        _fmt += 'I'
        _data.append(self.time_zone_time)

        # guild_id: u32
        _fmt += 'I'
        _data.append(self.guild_id)

        # amount_of_invitees: u32
        _fmt += 'I'
        _data.append(len(self.invitees))

        # invitees: CalendarSendInvitee[amount_of_invitees]
        for i in self.invitees:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 41 + packed_guid_size(self.creator) + len(self.title) + len(self.description) + sum([i.size() for i in self.invitees])


@dataclasses.dataclass
class SMSG_CALENDAR_FILTER_GUILD:
    members: typing.List[CalendarMember]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CALENDAR_FILTER_GUILD:
        # amount_of_members: u32
        amount_of_members = await read_int(reader, 4)

        # members: CalendarMember[amount_of_members]
        members = []
        for _ in range(0, amount_of_members):
            members.append(await CalendarMember.read(reader))

        return SMSG_CALENDAR_FILTER_GUILD(
            members=members,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0438))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.members))
        # members: CalendarMember[amount_of_members]
        for i in self.members:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + sum([i.size() for i in self.members])


@dataclasses.dataclass
class SMSG_CALENDAR_ARENA_TEAM:
    members: typing.List[CalendarMember]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CALENDAR_ARENA_TEAM:
        # amount_of_members: u32
        amount_of_members = await read_int(reader, 4)

        # members: CalendarMember[amount_of_members]
        members = []
        for _ in range(0, amount_of_members):
            members.append(await CalendarMember.read(reader))

        return SMSG_CALENDAR_ARENA_TEAM(
            members=members,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0439))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.members))
        # members: CalendarMember[amount_of_members]
        for i in self.members:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + sum([i.size() for i in self.members])


@dataclasses.dataclass
class SMSG_CALENDAR_EVENT_INVITE:
    invitee: int
    event_id: int
    invite_id: int
    level: int
    invite_status: int
    time: CalendarStatusTime
    is_sign_up: bool
    status_time: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CALENDAR_EVENT_INVITE:
        status_time = None
        # invitee: PackedGuid
        invitee = await read_packed_guid(reader)

        # event_id: Guid
        event_id = await read_int(reader, 8)

        # invite_id: Guid
        invite_id = await read_int(reader, 8)

        # level: Level
        level = await read_int(reader, 1)

        # invite_status: u8
        invite_status = await read_int(reader, 1)

        # time: CalendarStatusTime
        time = CalendarStatusTime(await read_int(reader, 1))

        if time == CalendarStatusTime.PRESENT:
            # status_time: DateTime
            status_time = await read_int(reader, 4)

        # is_sign_up: Bool8
        is_sign_up = await read_bool(reader, 1)

        return SMSG_CALENDAR_EVENT_INVITE(
            invitee=invitee,
            event_id=event_id,
            invite_id=invite_id,
            level=level,
            invite_status=invite_status,
            time=time,
            status_time=status_time,
            is_sign_up=is_sign_up,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x043A))
        _fmt = "<4s"
        _data = [_data]

        # invitee: PackedGuid
        _fmt, _data = packed_guid_write(self.invitee, _fmt, _data)

        # event_id: Guid
        _fmt += 'Q'
        _data.append(self.event_id)

        # invite_id: Guid
        _fmt += 'Q'
        _data.append(self.invite_id)

        # level: Level
        _fmt += 'B'
        _data.append(self.level)

        # invite_status: u8
        _fmt += 'B'
        _data.append(self.invite_status)

        # time: CalendarStatusTime
        _fmt += 'B'
        _data.append(self.time.value)

        if self.time == CalendarStatusTime.PRESENT:
            _fmt += 'I'
            _data.append(self.status_time)
        # is_sign_up: Bool8
        _fmt += 'B'
        _data.append(self.is_sign_up)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 20 + packed_guid_size(self.invitee)

        if self.time == CalendarStatusTime.PRESENT:
            _size += 4

        return _size


@dataclasses.dataclass
class SMSG_CALENDAR_EVENT_INVITE_REMOVED:
    invitee: int
    event_id: int
    flags: int
    show_alert: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CALENDAR_EVENT_INVITE_REMOVED:
        # invitee: PackedGuid
        invitee = await read_packed_guid(reader)

        # event_id: Guid
        event_id = await read_int(reader, 8)

        # flags: u32
        flags = await read_int(reader, 4)

        # show_alert: Bool8
        show_alert = await read_bool(reader, 1)

        return SMSG_CALENDAR_EVENT_INVITE_REMOVED(
            invitee=invitee,
            event_id=event_id,
            flags=flags,
            show_alert=show_alert,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x043B))
        _fmt = "<4s"
        _data = [_data]

        # invitee: PackedGuid
        _fmt, _data = packed_guid_write(self.invitee, _fmt, _data)

        # event_id: Guid
        _fmt += 'Q'
        _data.append(self.event_id)

        # flags: u32
        _fmt += 'I'
        _data.append(self.flags)

        # show_alert: Bool8
        _fmt += 'B'
        _data.append(self.show_alert)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 13 + packed_guid_size(self.invitee)


@dataclasses.dataclass
class SMSG_CALENDAR_EVENT_STATUS:
    invitee: int
    event_id: int
    event_time: int
    flags: int
    status: int
    rank: int
    status_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CALENDAR_EVENT_STATUS:
        # invitee: PackedGuid
        invitee = await read_packed_guid(reader)

        # event_id: Guid
        event_id = await read_int(reader, 8)

        # event_time: DateTime
        event_time = await read_int(reader, 4)

        # flags: u32
        flags = await read_int(reader, 4)

        # status: u8
        status = await read_int(reader, 1)

        # rank: u8
        rank = await read_int(reader, 1)

        # status_time: DateTime
        status_time = await read_int(reader, 4)

        return SMSG_CALENDAR_EVENT_STATUS(
            invitee=invitee,
            event_id=event_id,
            event_time=event_time,
            flags=flags,
            status=status,
            rank=rank,
            status_time=status_time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x043C))
        _fmt = "<4s"
        _data = [_data]

        # invitee: PackedGuid
        _fmt, _data = packed_guid_write(self.invitee, _fmt, _data)

        # event_id: Guid
        _fmt += 'Q'
        _data.append(self.event_id)

        # event_time: DateTime
        _fmt += 'I'
        _data.append(self.event_time)

        # flags: u32
        _fmt += 'I'
        _data.append(self.flags)

        # status: u8
        _fmt += 'B'
        _data.append(self.status)

        # rank: u8
        _fmt += 'B'
        _data.append(self.rank)

        # status_time: DateTime
        _fmt += 'I'
        _data.append(self.status_time)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 22 + packed_guid_size(self.invitee)


@dataclasses.dataclass
class SMSG_CALENDAR_COMMAND_RESULT:
    unknown1: int
    unknown2: int
    name: str
    result: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CALENDAR_COMMAND_RESULT:
        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # unknown2: u8
        unknown2 = await read_int(reader, 1)

        # name: CString
        name = await read_cstring(reader)

        # result: u32
        result = await read_int(reader, 4)

        return SMSG_CALENDAR_COMMAND_RESULT(
            unknown1=unknown1,
            unknown2=unknown2,
            name=name,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x043D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'IB{len(self.name)}sBI'
        _data.extend([self.unknown1, self.unknown2, self.name.encode('utf-8'), 0, self.result])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 10 + len(self.name)


@dataclasses.dataclass
class SMSG_CALENDAR_RAID_LOCKOUT_ADDED:
    time: int
    map: Map
    difficulty: int
    remaining_time: int
    instance_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CALENDAR_RAID_LOCKOUT_ADDED:
        # time: DateTime
        time = await read_int(reader, 4)

        # map: Map
        map = Map(await read_int(reader, 4))

        # difficulty: u32
        difficulty = await read_int(reader, 4)

        # remaining_time: u32
        remaining_time = await read_int(reader, 4)

        # instance_id: Guid
        instance_id = await read_int(reader, 8)

        return SMSG_CALENDAR_RAID_LOCKOUT_ADDED(
            time=time,
            map=map,
            difficulty=difficulty,
            remaining_time=remaining_time,
            instance_id=instance_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(24 + 2, 0x043E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIIQ'
        _data.extend([self.time, self.map.value, self.difficulty, self.remaining_time, self.instance_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CALENDAR_RAID_LOCKOUT_REMOVED:
    map: Map
    difficulty: int
    remaining_time: int
    instance_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CALENDAR_RAID_LOCKOUT_REMOVED:
        # map: Map
        map = Map(await read_int(reader, 4))

        # difficulty: u32
        difficulty = await read_int(reader, 4)

        # remaining_time: u32
        remaining_time = await read_int(reader, 4)

        # instance_id: Guid
        instance_id = await read_int(reader, 8)

        return SMSG_CALENDAR_RAID_LOCKOUT_REMOVED(
            map=map,
            difficulty=difficulty,
            remaining_time=remaining_time,
            instance_id=instance_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x043F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIQ'
        _data.extend([self.map.value, self.difficulty, self.remaining_time, self.instance_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CALENDAR_EVENT_INVITE_ALERT:
    event_id: int
    title: str
    event_time: int
    flags: int
    event_type: int
    dungeon_id: int
    invite_id: int
    status: int
    rank: int
    event_creator: int
    invite_sender: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CALENDAR_EVENT_INVITE_ALERT:
        # event_id: Guid
        event_id = await read_int(reader, 8)

        # title: CString
        title = await read_cstring(reader)

        # event_time: DateTime
        event_time = await read_int(reader, 4)

        # flags: u32
        flags = await read_int(reader, 4)

        # event_type: u32
        event_type = await read_int(reader, 4)

        # dungeon_id: u32
        dungeon_id = await read_int(reader, 4)

        # invite_id: Guid
        invite_id = await read_int(reader, 8)

        # status: u8
        status = await read_int(reader, 1)

        # rank: u8
        rank = await read_int(reader, 1)

        # event_creator: PackedGuid
        event_creator = await read_packed_guid(reader)

        # invite_sender: PackedGuid
        invite_sender = await read_packed_guid(reader)

        return SMSG_CALENDAR_EVENT_INVITE_ALERT(
            event_id=event_id,
            title=title,
            event_time=event_time,
            flags=flags,
            event_type=event_type,
            dungeon_id=dungeon_id,
            invite_id=invite_id,
            status=status,
            rank=rank,
            event_creator=event_creator,
            invite_sender=invite_sender,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0440))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'Q{len(self.title)}sBIIIIQBB'
        _data.extend([self.event_id, self.title.encode('utf-8'), 0, self.event_time, self.flags, self.event_type, self.dungeon_id, self.invite_id, self.status, self.rank])
        # event_creator: PackedGuid
        _fmt, _data = packed_guid_write(self.event_creator, _fmt, _data)

        # invite_sender: PackedGuid
        _fmt, _data = packed_guid_write(self.invite_sender, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 35 + len(self.title) + packed_guid_size(self.event_creator) + packed_guid_size(self.invite_sender)


@dataclasses.dataclass
class SMSG_CALENDAR_EVENT_INVITE_REMOVED_ALERT:
    event_id: int
    event_time: int
    flags: int
    status: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CALENDAR_EVENT_INVITE_REMOVED_ALERT:
        # event_id: Guid
        event_id = await read_int(reader, 8)

        # event_time: DateTime
        event_time = await read_int(reader, 4)

        # flags: u32
        flags = await read_int(reader, 4)

        # status: u8
        status = await read_int(reader, 1)

        return SMSG_CALENDAR_EVENT_INVITE_REMOVED_ALERT(
            event_id=event_id,
            event_time=event_time,
            flags=flags,
            status=status,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(17 + 2, 0x0441))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIIB'
        _data.extend([self.event_id, self.event_time, self.flags, self.status])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CALENDAR_EVENT_REMOVED_ALERT:
    show_alert: bool
    event_id: int
    event_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CALENDAR_EVENT_REMOVED_ALERT:
        # show_alert: Bool8
        show_alert = await read_bool(reader, 1)

        # event_id: Guid
        event_id = await read_int(reader, 8)

        # event_time: DateTime
        event_time = await read_int(reader, 4)

        return SMSG_CALENDAR_EVENT_REMOVED_ALERT(
            show_alert=show_alert,
            event_id=event_id,
            event_time=event_time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(13 + 2, 0x0443))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BQI'
        _data.extend([self.show_alert, self.event_id, self.event_time])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CALENDAR_EVENT_UPDATED_ALERT:
    show_alert: bool
    event_id: int
    old_event_time: int
    flags: int
    new_event_time: int
    event_type: int
    dungeon_id: int
    title: str
    description: str
    repeatable: int
    max_invitees: int
    unknown_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CALENDAR_EVENT_UPDATED_ALERT:
        # show_alert: Bool8
        show_alert = await read_bool(reader, 1)

        # event_id: Guid
        event_id = await read_int(reader, 8)

        # old_event_time: DateTime
        old_event_time = await read_int(reader, 4)

        # flags: u32
        flags = await read_int(reader, 4)

        # new_event_time: DateTime
        new_event_time = await read_int(reader, 4)

        # event_type: u8
        event_type = await read_int(reader, 1)

        # dungeon_id: u32
        dungeon_id = await read_int(reader, 4)

        # title: CString
        title = await read_cstring(reader)

        # description: CString
        description = await read_cstring(reader)

        # repeatable: u8
        repeatable = await read_int(reader, 1)

        # max_invitees: u32
        max_invitees = await read_int(reader, 4)

        # unknown_time: DateTime
        unknown_time = await read_int(reader, 4)

        return SMSG_CALENDAR_EVENT_UPDATED_ALERT(
            show_alert=show_alert,
            event_id=event_id,
            old_event_time=old_event_time,
            flags=flags,
            new_event_time=new_event_time,
            event_type=event_type,
            dungeon_id=dungeon_id,
            title=title,
            description=description,
            repeatable=repeatable,
            max_invitees=max_invitees,
            unknown_time=unknown_time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0444))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'BQIIIBI{len(self.title)}sB{len(self.description)}sBBII'
        _data.extend([self.show_alert, self.event_id, self.old_event_time, self.flags, self.new_event_time, self.event_type, self.dungeon_id, self.title.encode('utf-8'), 0, self.description.encode('utf-8'), 0, self.repeatable, self.max_invitees, self.unknown_time])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 37 + len(self.title) + len(self.description)


@dataclasses.dataclass
class SMSG_CALENDAR_EVENT_MODERATOR_STATUS_ALERT:
    invitee: int
    event_id: int
    rank: int
    show_alert: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CALENDAR_EVENT_MODERATOR_STATUS_ALERT:
        # invitee: PackedGuid
        invitee = await read_packed_guid(reader)

        # event_id: Guid
        event_id = await read_int(reader, 8)

        # rank: u8
        rank = await read_int(reader, 1)

        # show_alert: Bool8
        show_alert = await read_bool(reader, 1)

        return SMSG_CALENDAR_EVENT_MODERATOR_STATUS_ALERT(
            invitee=invitee,
            event_id=event_id,
            rank=rank,
            show_alert=show_alert,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0445))
        _fmt = "<4s"
        _data = [_data]

        # invitee: PackedGuid
        _fmt, _data = packed_guid_write(self.invitee, _fmt, _data)

        # event_id: Guid
        _fmt += 'Q'
        _data.append(self.event_id)

        # rank: u8
        _fmt += 'B'
        _data.append(self.rank)

        # show_alert: Bool8
        _fmt += 'B'
        _data.append(self.show_alert)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 10 + packed_guid_size(self.invitee)


@dataclasses.dataclass
class CMSG_CALENDAR_COMPLAIN:
    responsible_player: int
    event: int
    invite_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CALENDAR_COMPLAIN:
        # responsible_player: Guid
        responsible_player = await read_int(reader, 8)

        # event: Guid
        event = await read_int(reader, 8)

        # invite_id: Guid
        invite_id = await read_int(reader, 8)

        return CMSG_CALENDAR_COMPLAIN(
            responsible_player=responsible_player,
            event=event,
            invite_id=invite_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(24 + 4, 0x0446))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QQQ'
        _data.extend([self.responsible_player, self.event, self.invite_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CALENDAR_GET_NUM_PENDING:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CALENDAR_GET_NUM_PENDING:
        return CMSG_CALENDAR_GET_NUM_PENDING()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0447))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0447))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CALENDAR_SEND_NUM_PENDING:
    pending_events: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CALENDAR_SEND_NUM_PENDING:
        # pending_events: u32
        pending_events = await read_int(reader, 4)

        return SMSG_CALENDAR_SEND_NUM_PENDING(
            pending_events=pending_events,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0448))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.pending_events)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MOVE_SET_PITCH_RATE_Server:
    player: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_PITCH_RATE_Server:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return MSG_MOVE_SET_PITCH_RATE_Server(
            player=player,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x045B))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_PITCH_RATE_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_PITCH_RATE_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_PITCH_RATE_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x045C))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_CALENDAR_EVENT_INVITE_NOTES:
    invitee: int
    invite_id: int
    text: str
    unknown: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CALENDAR_EVENT_INVITE_NOTES:
        # invitee: PackedGuid
        invitee = await read_packed_guid(reader)

        # invite_id: Guid
        invite_id = await read_int(reader, 8)

        # text: CString
        text = await read_cstring(reader)

        # unknown: Bool8
        unknown = await read_bool(reader, 1)

        return SMSG_CALENDAR_EVENT_INVITE_NOTES(
            invitee=invitee,
            invite_id=invite_id,
            text=text,
            unknown=unknown,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0460))
        _fmt = "<4s"
        _data = [_data]

        # invitee: PackedGuid
        _fmt, _data = packed_guid_write(self.invitee, _fmt, _data)

        # invite_id: Guid
        _fmt += 'Q'
        _data.append(self.invite_id)

        # text: CString
        _fmt += f'{len(self.text)}sB'
        _data.extend([self.text.encode('utf-8'), 0])

        # unknown: Bool8
        _fmt += 'B'
        _data.append(self.unknown)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 10 + packed_guid_size(self.invitee) + len(self.text)


@dataclasses.dataclass
class SMSG_CALENDAR_EVENT_INVITE_NOTES_ALERT:
    invite_id: int
    text: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CALENDAR_EVENT_INVITE_NOTES_ALERT:
        # invite_id: Guid
        invite_id = await read_int(reader, 8)

        # text: CString
        text = await read_cstring(reader)

        return SMSG_CALENDAR_EVENT_INVITE_NOTES_ALERT(
            invite_id=invite_id,
            text=text,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0461))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'Q{len(self.text)}sB'
        _data.extend([self.invite_id, self.text.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.text)


@dataclasses.dataclass
class CMSG_UPDATE_MISSILE_TRAJECTORY:
    guid: int
    spell: int
    elevation: float
    speed: float
    position: Vector3d
    target: Vector3d

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_UPDATE_MISSILE_TRAJECTORY:
        # guid: Guid
        guid = await read_int(reader, 8)

        # spell: Spell
        spell = await read_int(reader, 4)

        # elevation: f32
        elevation = await read_float(reader)

        # speed: f32
        speed = await read_float(reader)

        # position: Vector3d
        position = await Vector3d.read(reader)

        # target: Vector3d
        target = await Vector3d.read(reader)

        return CMSG_UPDATE_MISSILE_TRAJECTORY(
            guid=guid,
            spell=spell,
            elevation=elevation,
            speed=speed,
            position=position,
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(44 + 4, 0x0462))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIff'
        _data.extend([self.guid, self.spell, self.elevation, self.speed])
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # target: Vector3d
        _fmt, _data = self.target.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_UPDATE_ACCOUNT_DATA_COMPLETE:
    data_type: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_UPDATE_ACCOUNT_DATA_COMPLETE:
        # data_type: u32
        data_type = await read_int(reader, 4)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return SMSG_UPDATE_ACCOUNT_DATA_COMPLETE(
            data_type=data_type,
            unknown1=unknown1,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0463))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.data_type, self.unknown1])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TRIGGER_MOVIE:
    movie_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRIGGER_MOVIE:
        # movie_id: u32
        movie_id = await read_int(reader, 4)

        return SMSG_TRIGGER_MOVIE(
            movie_id=movie_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0464))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.movie_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_COMPLETE_MOVIE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_COMPLETE_MOVIE:
        return CMSG_COMPLETE_MOVIE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0465))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ACHIEVEMENT_EARNED:
    player: int
    achievement: int
    earn_time: int
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ACHIEVEMENT_EARNED:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # achievement: u32
        achievement = await read_int(reader, 4)

        # earn_time: DateTime
        earn_time = await read_int(reader, 4)

        # unknown: u32
        unknown = await read_int(reader, 4)

        return SMSG_ACHIEVEMENT_EARNED(
            player=player,
            achievement=achievement,
            earn_time=earn_time,
            unknown=unknown,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0468))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # achievement: u32
        _fmt += 'I'
        _data.append(self.achievement)

        # earn_time: DateTime
        _fmt += 'I'
        _data.append(self.earn_time)

        # unknown: u32
        _fmt += 'I'
        _data.append(self.unknown)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + packed_guid_size(self.player)


@dataclasses.dataclass
class SMSG_CRITERIA_UPDATE:
    achievement: int
    progress_counter: int
    player: int
    flags: int
    time: int
    time_elapsed: int
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CRITERIA_UPDATE:
        # achievement: u32
        achievement = await read_int(reader, 4)

        # progress_counter: PackedGuid
        progress_counter = await read_packed_guid(reader)

        # player: PackedGuid
        player = await read_packed_guid(reader)

        # flags: u32
        flags = await read_int(reader, 4)

        # time: DateTime
        time = await read_int(reader, 4)

        # time_elapsed: Seconds
        time_elapsed = await read_int(reader, 4)

        # unknown: u32
        unknown = await read_int(reader, 4)

        return SMSG_CRITERIA_UPDATE(
            achievement=achievement,
            progress_counter=progress_counter,
            player=player,
            flags=flags,
            time=time,
            time_elapsed=time_elapsed,
            unknown=unknown,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x046A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.achievement)
        # progress_counter: PackedGuid
        _fmt, _data = packed_guid_write(self.progress_counter, _fmt, _data)

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # flags: u32
        _fmt += 'I'
        _data.append(self.flags)

        # time: DateTime
        _fmt += 'I'
        _data.append(self.time)

        # time_elapsed: Seconds
        _fmt += 'I'
        _data.append(self.time_elapsed)

        # unknown: u32
        _fmt += 'I'
        _data.append(self.unknown)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 20 + packed_guid_size(self.progress_counter) + packed_guid_size(self.player)


@dataclasses.dataclass
class CMSG_QUERY_INSPECT_ACHIEVEMENTS:
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUERY_INSPECT_ACHIEVEMENTS:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        return CMSG_QUERY_INSPECT_ACHIEVEMENTS(
            player=player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x046B))
        _fmt = "<6s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player)


@dataclasses.dataclass
class SMSG_RESPOND_INSPECT_ACHIEVEMENTS:
    player: int
    done: AchievementDoneArray
    in_progress: AchievementInProgressArray

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RESPOND_INSPECT_ACHIEVEMENTS:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # done: AchievementDoneArray
        done = await CacheMask.read(reader)

        # in_progress: AchievementInProgressArray
        in_progress = await CacheMask.read(reader)

        return SMSG_RESPOND_INSPECT_ACHIEVEMENTS(
            player=player,
            done=done,
            in_progress=in_progress,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x046C))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # done: AchievementDoneArray
        _fmt, _data = self.done.write(_fmt, _data)

        # in_progress: AchievementInProgressArray
        _fmt, _data = self.in_progress.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player) + self.done.size() + self.in_progress.size()


@dataclasses.dataclass
class CMSG_DISMISS_CONTROLLED_VEHICLE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_DISMISS_CONTROLLED_VEHICLE:
        return CMSG_DISMISS_CONTROLLED_VEHICLE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x046D))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTUPDATE_ADD_PVP_KILL:
    quest_id: int
    count: int
    players_slain: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTUPDATE_ADD_PVP_KILL:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # count: u32
        count = await read_int(reader, 4)

        # players_slain: u32
        players_slain = await read_int(reader, 4)

        return SMSG_QUESTUPDATE_ADD_PVP_KILL(
            quest_id=quest_id,
            count=count,
            players_slain=players_slain,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x046F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'III'
        _data.extend([self.quest_id, self.count, self.players_slain])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CALENDAR_RAID_LOCKOUT_UPDATED:
    current_time: int
    map: Map
    difficulty: int
    old_time_to_update: int
    new_time_to_update: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CALENDAR_RAID_LOCKOUT_UPDATED:
        # current_time: DateTime
        current_time = await read_int(reader, 4)

        # map: Map
        map = Map(await read_int(reader, 4))

        # difficulty: u32
        difficulty = await read_int(reader, 4)

        # old_time_to_update: Seconds
        old_time_to_update = await read_int(reader, 4)

        # new_time_to_update: Seconds
        new_time_to_update = await read_int(reader, 4)

        return SMSG_CALENDAR_RAID_LOCKOUT_UPDATED(
            current_time=current_time,
            map=map,
            difficulty=difficulty,
            old_time_to_update=old_time_to_update,
            new_time_to_update=new_time_to_update,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x0471))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIII'
        _data.extend([self.current_time, self.map.value, self.difficulty, self.old_time_to_update, self.new_time_to_update])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CHAR_CUSTOMIZE:
    player: int
    new_name: str
    gender: Gender
    skin_color: int
    hair_color: int
    hair_style: int
    facial_hair: int
    face: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHAR_CUSTOMIZE:
        # player: Guid
        player = await read_int(reader, 8)

        # new_name: CString
        new_name = await read_cstring(reader)

        # gender: Gender
        gender = Gender(await read_int(reader, 1))

        # skin_color: u8
        skin_color = await read_int(reader, 1)

        # hair_color: u8
        hair_color = await read_int(reader, 1)

        # hair_style: u8
        hair_style = await read_int(reader, 1)

        # facial_hair: u8
        facial_hair = await read_int(reader, 1)

        # face: u8
        face = await read_int(reader, 1)

        return CMSG_CHAR_CUSTOMIZE(
            player=player,
            new_name=new_name,
            gender=gender,
            skin_color=skin_color,
            hair_color=hair_color,
            hair_style=hair_style,
            facial_hair=facial_hair,
            face=face,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0473))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.new_name)}sBBBBBBB'
        _data.extend([self.player, self.new_name.encode('utf-8'), 0, self.gender.value, self.skin_color, self.hair_color, self.hair_style, self.facial_hair, self.face])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 15 + len(self.new_name)


@dataclasses.dataclass
class SMSG_CHAR_CUSTOMIZE:
    result: WorldResult
    guid: typing.Optional[int] = None
    name: typing.Optional[str] = None
    gender: typing.Optional[Gender] = None
    skin_color: typing.Optional[int] = None
    face: typing.Optional[int] = None
    hair_style: typing.Optional[int] = None
    hair_color: typing.Optional[int] = None
    facial_hair: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAR_CUSTOMIZE:
        guid = None
        name = None
        gender = None
        skin_color = None
        face = None
        hair_style = None
        hair_color = None
        facial_hair = None
        # result: WorldResult
        result = WorldResult(await read_int(reader, 1))

        if result == WorldResult.RESPONSE_SUCCESS:
            # guid: Guid
            guid = await read_int(reader, 8)

            # name: CString
            name = await read_cstring(reader)

            # gender: Gender
            gender = Gender(await read_int(reader, 1))

            # skin_color: u8
            skin_color = await read_int(reader, 1)

            # face: u8
            face = await read_int(reader, 1)

            # hair_style: u8
            hair_style = await read_int(reader, 1)

            # hair_color: u8
            hair_color = await read_int(reader, 1)

            # facial_hair: u8
            facial_hair = await read_int(reader, 1)

        return SMSG_CHAR_CUSTOMIZE(
            result=result,
            guid=guid,
            name=name,
            gender=gender,
            skin_color=skin_color,
            face=face,
            hair_style=hair_style,
            hair_color=hair_color,
            facial_hair=facial_hair,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0474))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        if self.result == WorldResult.RESPONSE_SUCCESS:
            _fmt += f'Q{len(self.name)}sBBBBBBB'
            _data.extend([self.guid, self.name.encode('utf-8'), 0, self.gender.value, self.skin_color, self.face, self.hair_style, self.hair_color, self.facial_hair])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.result == WorldResult.RESPONSE_SUCCESS:
            _size += 15 + len(self.name)

        return _size


@dataclasses.dataclass
class CMSG_REQUEST_VEHICLE_EXIT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REQUEST_VEHICLE_EXIT:
        return CMSG_REQUEST_VEHICLE_EXIT()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0476))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_REQUEST_VEHICLE_PREV_SEAT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REQUEST_VEHICLE_PREV_SEAT:
        return CMSG_REQUEST_VEHICLE_PREV_SEAT()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0477))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_REQUEST_VEHICLE_NEXT_SEAT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REQUEST_VEHICLE_NEXT_SEAT:
        return CMSG_REQUEST_VEHICLE_NEXT_SEAT()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0478))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_REQUEST_VEHICLE_SWITCH_SEAT:
    vehicle: int
    seat: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REQUEST_VEHICLE_SWITCH_SEAT:
        # vehicle: Guid
        vehicle = await read_int(reader, 8)

        # seat: u8
        seat = await read_int(reader, 1)

        return CMSG_REQUEST_VEHICLE_SWITCH_SEAT(
            vehicle=vehicle,
            seat=seat,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x0479))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.vehicle, self.seat])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PET_LEARN_TALENT:
    pet: int
    talent: int
    rank: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_LEARN_TALENT:
        # pet: Guid
        pet = await read_int(reader, 8)

        # talent: u32
        talent = await read_int(reader, 4)

        # rank: u32
        rank = await read_int(reader, 4)

        return CMSG_PET_LEARN_TALENT(
            pet=pet,
            talent=talent,
            rank=rank,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x047A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.pet, self.talent, self.rank])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SET_PHASE_SHIFT:
    new_phase: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_PHASE_SHIFT:
        # new_phase: u32
        new_phase = await read_int(reader, 4)

        return SMSG_SET_PHASE_SHIFT(
            new_phase=new_phase,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x047C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.new_phase)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ALL_ACHIEVEMENT_DATA:
    done: AchievementDoneArray
    in_progress: AchievementInProgressArray

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ALL_ACHIEVEMENT_DATA:
        # done: AchievementDoneArray
        done = await CacheMask.read(reader)

        # in_progress: AchievementInProgressArray
        in_progress = await CacheMask.read(reader)

        return SMSG_ALL_ACHIEVEMENT_DATA(
            done=done,
            in_progress=in_progress,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x047D))
        _fmt = "<4s"
        _data = [_data]

        # done: AchievementDoneArray
        _fmt, _data = self.done.write(_fmt, _data)

        # in_progress: AchievementInProgressArray
        _fmt, _data = self.in_progress.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.done.size() + self.in_progress.size()


@dataclasses.dataclass
class SMSG_POWER_UPDATE:
    unit: int
    power: Power
    amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_POWER_UPDATE:
        # unit: PackedGuid
        unit = await read_packed_guid(reader)

        # power: Power
        power = Power(await read_int(reader, 1))

        # amount: u32
        amount = await read_int(reader, 4)

        return SMSG_POWER_UPDATE(
            unit=unit,
            power=power,
            amount=amount,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0480))
        _fmt = "<4s"
        _data = [_data]

        # unit: PackedGuid
        _fmt, _data = packed_guid_write(self.unit, _fmt, _data)

        # power: Power
        _fmt += 'B'
        _data.append(self.power.value)

        # amount: u32
        _fmt += 'I'
        _data.append(self.amount)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + packed_guid_size(self.unit)


@dataclasses.dataclass
class CMSG_GAMEOBJ_REPORT_USE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GAMEOBJ_REPORT_USE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_GAMEOBJ_REPORT_USE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0481))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_HIGHEST_THREAT_UPDATE:
    unit: int
    new_victim: int
    units: typing.List[ThreatUpdateUnit]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_HIGHEST_THREAT_UPDATE:
        # unit: PackedGuid
        unit = await read_packed_guid(reader)

        # new_victim: PackedGuid
        new_victim = await read_packed_guid(reader)

        # amount_of_units: u32
        amount_of_units = await read_int(reader, 4)

        # units: ThreatUpdateUnit[amount_of_units]
        units = []
        for _ in range(0, amount_of_units):
            units.append(await ThreatUpdateUnit.read(reader))

        return SMSG_HIGHEST_THREAT_UPDATE(
            unit=unit,
            new_victim=new_victim,
            units=units,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0482))
        _fmt = "<4s"
        _data = [_data]

        # unit: PackedGuid
        _fmt, _data = packed_guid_write(self.unit, _fmt, _data)

        # new_victim: PackedGuid
        _fmt, _data = packed_guid_write(self.new_victim, _fmt, _data)

        # amount_of_units: u32
        _fmt += 'I'
        _data.append(len(self.units))

        # units: ThreatUpdateUnit[amount_of_units]
        for i in self.units:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.unit) + packed_guid_size(self.new_victim) + sum([i.size() for i in self.units])


@dataclasses.dataclass
class SMSG_THREAT_UPDATE:
    unit: int
    units: typing.List[ThreatUpdateUnit]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_THREAT_UPDATE:
        # unit: PackedGuid
        unit = await read_packed_guid(reader)

        # amount_of_units: u32
        amount_of_units = await read_int(reader, 4)

        # units: ThreatUpdateUnit[amount_of_units]
        units = []
        for _ in range(0, amount_of_units):
            units.append(await ThreatUpdateUnit.read(reader))

        return SMSG_THREAT_UPDATE(
            unit=unit,
            units=units,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0483))
        _fmt = "<4s"
        _data = [_data]

        # unit: PackedGuid
        _fmt, _data = packed_guid_write(self.unit, _fmt, _data)

        # amount_of_units: u32
        _fmt += 'I'
        _data.append(len(self.units))

        # units: ThreatUpdateUnit[amount_of_units]
        for i in self.units:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.unit) + sum([i.size() for i in self.units])


@dataclasses.dataclass
class SMSG_THREAT_REMOVE:
    unit: int
    victim: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_THREAT_REMOVE:
        # unit: PackedGuid
        unit = await read_packed_guid(reader)

        # victim: PackedGuid
        victim = await read_packed_guid(reader)

        return SMSG_THREAT_REMOVE(
            unit=unit,
            victim=victim,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0484))
        _fmt = "<4s"
        _data = [_data]

        # unit: PackedGuid
        _fmt, _data = packed_guid_write(self.unit, _fmt, _data)

        # victim: PackedGuid
        _fmt, _data = packed_guid_write(self.victim, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.unit) + packed_guid_size(self.victim)


@dataclasses.dataclass
class SMSG_THREAT_CLEAR:
    unit: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_THREAT_CLEAR:
        # unit: PackedGuid
        unit = await read_packed_guid(reader)

        return SMSG_THREAT_CLEAR(
            unit=unit,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0485))
        _fmt = "<4s"
        _data = [_data]

        # unit: PackedGuid
        _fmt, _data = packed_guid_write(self.unit, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.unit)


@dataclasses.dataclass
class SMSG_CONVERT_RUNE:
    index: int
    new_type: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CONVERT_RUNE:
        # index: u8
        index = await read_int(reader, 1)

        # new_type: u8
        new_type = await read_int(reader, 1)

        return SMSG_CONVERT_RUNE(
            index=index,
            new_type=new_type,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 2, 0x0486))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.index, self.new_type])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_RESYNC_RUNES:
    runes: typing.List[ResyncRune]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RESYNC_RUNES:
        # amount_of_runes: u32
        amount_of_runes = await read_int(reader, 4)

        # runes: ResyncRune[amount_of_runes]
        runes = []
        for _ in range(0, amount_of_runes):
            runes.append(await ResyncRune.read(reader))

        return SMSG_RESYNC_RUNES(
            runes=runes,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0487))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.runes))
        # runes: ResyncRune[amount_of_runes]
        for i in self.runes:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + 2 * len(self.runes)


@dataclasses.dataclass
class SMSG_ADD_RUNE_POWER:
    rune: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ADD_RUNE_POWER:
        # rune: u32
        rune = await read_int(reader, 4)

        return SMSG_ADD_RUNE_POWER(
            rune=rune,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0488))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.rune)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_REMOVE_GLYPH:
    glyph: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REMOVE_GLYPH:
        # glyph: u32
        glyph = await read_int(reader, 4)

        return CMSG_REMOVE_GLYPH(
            glyph=glyph,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x048A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.glyph)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_DISMISS_CRITTER:
    critter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_DISMISS_CRITTER:
        # critter: Guid
        critter = await read_int(reader, 8)

        return CMSG_DISMISS_CRITTER(
            critter=critter,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x048D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.critter)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUCTION_LIST_PENDING_SALES:
    auctioneer: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUCTION_LIST_PENDING_SALES:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        return CMSG_AUCTION_LIST_PENDING_SALES(
            auctioneer=auctioneer,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x048F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.auctioneer)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AUCTION_LIST_PENDING_SALES:
    pending_sales: typing.List[PendingAuctionSale]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_LIST_PENDING_SALES:
        # amount_of_pending_sales: u32
        amount_of_pending_sales = await read_int(reader, 4)

        # pending_sales: PendingAuctionSale[amount_of_pending_sales]
        pending_sales = []
        for _ in range(0, amount_of_pending_sales):
            pending_sales.append(await PendingAuctionSale.read(reader))

        return SMSG_AUCTION_LIST_PENDING_SALES(
            pending_sales=pending_sales,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0490))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.pending_sales))
        # pending_sales: PendingAuctionSale[amount_of_pending_sales]
        for i in self.pending_sales:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + sum([i.size() for i in self.pending_sales])


@dataclasses.dataclass
class SMSG_MODIFY_COOLDOWN:
    spell: int
    player: int
    cooldown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MODIFY_COOLDOWN:
        # spell: Spell
        spell = await read_int(reader, 4)

        # player: Guid
        player = await read_int(reader, 8)

        # cooldown: Milliseconds
        cooldown = await read_int(reader, 4)

        return SMSG_MODIFY_COOLDOWN(
            spell=spell,
            player=player,
            cooldown=cooldown,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x0491))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IQI'
        _data.extend([self.spell, self.player, self.cooldown])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PET_UPDATE_COMBO_POINTS:
    unit: int
    target: int
    combo_points: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_UPDATE_COMBO_POINTS:
        # unit: PackedGuid
        unit = await read_packed_guid(reader)

        # target: PackedGuid
        target = await read_packed_guid(reader)

        # combo_points: u8
        combo_points = await read_int(reader, 1)

        return SMSG_PET_UPDATE_COMBO_POINTS(
            unit=unit,
            target=target,
            combo_points=combo_points,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0492))
        _fmt = "<4s"
        _data = [_data]

        # unit: PackedGuid
        _fmt, _data = packed_guid_write(self.unit, _fmt, _data)

        # target: PackedGuid
        _fmt, _data = packed_guid_write(self.target, _fmt, _data)

        # combo_points: u8
        _fmt += 'B'
        _data.append(self.combo_points)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + packed_guid_size(self.unit) + packed_guid_size(self.target)


@dataclasses.dataclass
class CMSG_ENABLETAXI:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ENABLETAXI:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_ENABLETAXI(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0493))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PRE_RESURRECT:
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PRE_RESURRECT:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        return SMSG_PRE_RESURRECT(
            player=player,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0494))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player)


@dataclasses.dataclass
class SMSG_AURA_UPDATE_ALL:
    unit: int
    aura_updates: typing.List[AuraUpdate]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AURA_UPDATE_ALL:
        _size = 0

        # unit: PackedGuid
        unit = await read_packed_guid(reader)
        _size += packed_guid_size(unit)

        # aura_updates: AuraUpdate[-]
        aura_updates = []
        while _size < body_size:
            aura_updates.append(await AuraUpdate.read(reader))
            _size += aura_updates[-1].size()

        return SMSG_AURA_UPDATE_ALL(
            unit=unit,
            aura_updates=aura_updates,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0495))
        _fmt = "<4s"
        _data = [_data]

        # unit: PackedGuid
        _fmt, _data = packed_guid_write(self.unit, _fmt, _data)

        # aura_updates: AuraUpdate[-]
        for i in self.aura_updates:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.unit) + sum([i.size() for i in self.aura_updates])


@dataclasses.dataclass
class SMSG_AURA_UPDATE:
    unit: int
    aura_update: AuraUpdate

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AURA_UPDATE:
        # unit: PackedGuid
        unit = await read_packed_guid(reader)

        # aura_update: AuraUpdate
        aura_update = await AuraUpdate.read(reader)

        return SMSG_AURA_UPDATE(
            unit=unit,
            aura_update=aura_update,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0496))
        _fmt = "<4s"
        _data = [_data]

        # unit: PackedGuid
        _fmt, _data = packed_guid_write(self.unit, _fmt, _data)

        # aura_update: AuraUpdate
        _fmt, _data = self.aura_update.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.unit) + self.aura_update.size()


@dataclasses.dataclass
class SMSG_SERVER_FIRST_ACHIEVEMENT:
    name: str
    player: int
    achievement: int
    link_type: AchievementNameLinkType

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SERVER_FIRST_ACHIEVEMENT:
        # name: CString
        name = await read_cstring(reader)

        # player: Guid
        player = await read_int(reader, 8)

        # achievement: u32
        achievement = await read_int(reader, 4)

        # link_type: AchievementNameLinkType
        link_type = AchievementNameLinkType(await read_int(reader, 1))

        return SMSG_SERVER_FIRST_ACHIEVEMENT(
            name=name,
            player=player,
            achievement=achievement,
            link_type=link_type,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0498))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.name)}sBQIB'
        _data.extend([self.name.encode('utf-8'), 0, self.player, self.achievement, self.link_type.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 14 + len(self.name)


@dataclasses.dataclass
class SMSG_PET_LEARNED_SPELL:
    spell: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_LEARNED_SPELL:
        # spell: Spell
        spell = await read_int(reader, 4)

        return SMSG_PET_LEARNED_SPELL(
            spell=spell,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0499))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.spell)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PET_UNLEARNED_SPELL:
    spell: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_UNLEARNED_SPELL:
        # spell: Spell
        spell = await read_int(reader, 4)

        return SMSG_PET_UNLEARNED_SPELL(
            spell=spell,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x049A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.spell)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CHANGE_SEATS_ON_CONTROLLED_VEHICLE:
    vehicle: int
    info: MovementInfo
    accessory: int
    seat: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANGE_SEATS_ON_CONTROLLED_VEHICLE:
        # vehicle: PackedGuid
        vehicle = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # accessory: PackedGuid
        accessory = await read_packed_guid(reader)

        # seat: u8
        seat = await read_int(reader, 1)

        return CMSG_CHANGE_SEATS_ON_CONTROLLED_VEHICLE(
            vehicle=vehicle,
            info=info,
            accessory=accessory,
            seat=seat,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x049B))
        _fmt = "<6s"
        _data = [_data]

        # vehicle: PackedGuid
        _fmt, _data = packed_guid_write(self.vehicle, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # accessory: PackedGuid
        _fmt, _data = packed_guid_write(self.accessory, _fmt, _data)

        # seat: u8
        _fmt += 'B'
        _data.append(self.seat)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + packed_guid_size(self.vehicle) + self.info.size() + packed_guid_size(self.accessory)


@dataclasses.dataclass
class CMSG_HEARTH_AND_RESURRECT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_HEARTH_AND_RESURRECT:
        return CMSG_HEARTH_AND_RESURRECT()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x049C))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ON_CANCEL_EXPECTED_RIDE_VEHICLE_AURA:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ON_CANCEL_EXPECTED_RIDE_VEHICLE_AURA:
        return SMSG_ON_CANCEL_EXPECTED_RIDE_VEHICLE_AURA()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x049D))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CRITERIA_DELETED:
    criteria_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CRITERIA_DELETED:
        # criteria_id: u32
        criteria_id = await read_int(reader, 4)

        return SMSG_CRITERIA_DELETED(
            criteria_id=criteria_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x049E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.criteria_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ACHIEVEMENT_DELETED:
    achievement: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ACHIEVEMENT_DELETED:
        # achievement: u32
        achievement = await read_int(reader, 4)

        return SMSG_ACHIEVEMENT_DELETED(
            achievement=achievement,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x049F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.achievement)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BATTLEGROUND_INFO_THROTTLED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BATTLEGROUND_INFO_THROTTLED:
        return SMSG_BATTLEGROUND_INFO_THROTTLED()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x04A6))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PLAYER_VEHICLE_DATA:
    target: int
    vehicle_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAYER_VEHICLE_DATA:
        # target: PackedGuid
        target = await read_packed_guid(reader)

        # vehicle_id: u32
        vehicle_id = await read_int(reader, 4)

        return SMSG_PLAYER_VEHICLE_DATA(
            target=target,
            vehicle_id=vehicle_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x04A7))
        _fmt = "<4s"
        _data = [_data]

        # target: PackedGuid
        _fmt, _data = packed_guid_write(self.target, _fmt, _data)

        # vehicle_id: u32
        _fmt += 'I'
        _data.append(self.vehicle_id)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.target)


@dataclasses.dataclass
class CMSG_PLAYER_VEHICLE_ENTER:
    vehicle: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PLAYER_VEHICLE_ENTER:
        # vehicle: Guid
        vehicle = await read_int(reader, 8)

        return CMSG_PLAYER_VEHICLE_ENTER(
            vehicle=vehicle,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x04A8))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.vehicle)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CONTROLLER_EJECT_PASSENGER:
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CONTROLLER_EJECT_PASSENGER:
        # player: Guid
        player = await read_int(reader, 8)

        return CMSG_CONTROLLER_EJECT_PASSENGER(
            player=player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x04A9))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.player)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PET_GUIDS:
    guids: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_GUIDS:
        # amount_of_guids: u32
        amount_of_guids = await read_int(reader, 4)

        # guids: Guid[amount_of_guids]
        guids = []
        for _ in range(0, amount_of_guids):
            guids.append(await read_int(reader, 8))

        return SMSG_PET_GUIDS(
            guids=guids,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x04AA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.guids)}Q'
        _data.extend([len(self.guids), *self.guids])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + 8 * len(self.guids)


@dataclasses.dataclass
class SMSG_CLIENTCACHE_VERSION:
    version: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CLIENTCACHE_VERSION:
        # version: u32
        version = await read_int(reader, 4)

        return SMSG_CLIENTCACHE_VERSION(
            version=version,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x04AB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.version)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_REFUND_INFO_RESPONSE:
    item: int
    money_cost: int
    honor_point_cost: int
    arena_point_cost: int
    extra_items: typing.List[ItemRefundExtra]
    unknown1: int
    time_since_loss: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_REFUND_INFO_RESPONSE:
        # item: Guid
        item = await read_int(reader, 8)

        # money_cost: Gold
        money_cost = await read_int(reader, 4)

        # honor_point_cost: u32
        honor_point_cost = await read_int(reader, 4)

        # arena_point_cost: u32
        arena_point_cost = await read_int(reader, 4)

        # extra_items: ItemRefundExtra[5]
        extra_items = []
        for _ in range(0, 5):
            extra_items.append(await ItemRefundExtra.read(reader))

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # time_since_loss: u32
        time_since_loss = await read_int(reader, 4)

        return SMSG_ITEM_REFUND_INFO_RESPONSE(
            item=item,
            money_cost=money_cost,
            honor_point_cost=honor_point_cost,
            arena_point_cost=arena_point_cost,
            extra_items=extra_items,
            unknown1=unknown1,
            time_since_loss=time_since_loss,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(68 + 2, 0x04B2))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIII'
        _data.extend([self.item, self.money_cost, self.honor_point_cost, self.arena_point_cost])
        # extra_items: ItemRefundExtra[5]
        for i in self.extra_items:
            _fmt, _data = i.write(_fmt, _data)

        # unknown1: u32
        _fmt += 'I'
        _data.append(self.unknown1)

        # time_since_loss: u32
        _fmt += 'I'
        _data.append(self.time_since_loss)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ITEM_REFUND_INFO:
    item: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ITEM_REFUND_INFO:
        # item: Guid
        item = await read_int(reader, 8)

        return CMSG_ITEM_REFUND_INFO(
            item=item,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x04B3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.item)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ITEM_REFUND:
    item: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ITEM_REFUND:
        # item: Guid
        item = await read_int(reader, 8)

        return CMSG_ITEM_REFUND(
            item=item,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x04B4))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.item)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_REFUND_RESULT:
    item: int
    result: ItemRefundResult
    cost: typing.Optional[int] = None
    honor_point_cost: typing.Optional[int] = None
    arena_point_cost: typing.Optional[int] = None
    extra_items: typing.Optional[typing.List[ItemRefundExtra]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_REFUND_RESULT:
        cost = None
        honor_point_cost = None
        arena_point_cost = None
        extra_items = None
        # item: Guid
        item = await read_int(reader, 8)

        # result: ItemRefundResult
        result = ItemRefundResult(await read_int(reader, 1))

        if result == ItemRefundResult.SUCCESS:
            # cost: Gold
            cost = await read_int(reader, 4)

            # honor_point_cost: u32
            honor_point_cost = await read_int(reader, 4)

            # arena_point_cost: u32
            arena_point_cost = await read_int(reader, 4)

            # extra_items: ItemRefundExtra[5]
            extra_items = []
            for _ in range(0, 5):
                extra_items.append(await ItemRefundExtra.read(reader))

        return SMSG_ITEM_REFUND_RESULT(
            item=item,
            result=result,
            cost=cost,
            honor_point_cost=honor_point_cost,
            arena_point_cost=arena_point_cost,
            extra_items=extra_items,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x04B5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.item, self.result.value])
        if self.result == ItemRefundResult.SUCCESS:
            _fmt += 'III'
            _data.extend([self.cost, self.honor_point_cost, self.arena_point_cost])
            # extra_items: ItemRefundExtra[5]
            for i in self.extra_items:
                _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 9

        if self.result == ItemRefundResult.SUCCESS:
            _size += 52

        return _size


@dataclasses.dataclass
class CMSG_CORPSE_MAP_POSITION_QUERY:
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CORPSE_MAP_POSITION_QUERY:
        # unknown: u32
        unknown = await read_int(reader, 4)

        return CMSG_CORPSE_MAP_POSITION_QUERY(
            unknown=unknown,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x04B6))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.unknown)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CORPSE_MAP_POSITION_QUERY_RESPONSE:
    unknown1: float
    unknown2: float
    unknown3: float
    unknown4: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CORPSE_MAP_POSITION_QUERY_RESPONSE:
        # unknown1: f32
        unknown1 = await read_float(reader)

        # unknown2: f32
        unknown2 = await read_float(reader)

        # unknown3: f32
        unknown3 = await read_float(reader)

        # unknown4: f32
        unknown4 = await read_float(reader)

        return SMSG_CORPSE_MAP_POSITION_QUERY_RESPONSE(
            unknown1=unknown1,
            unknown2=unknown2,
            unknown3=unknown3,
            unknown4=unknown4,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x04B7))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'ffff'
        _data.extend([self.unknown1, self.unknown2, self.unknown3, self.unknown4])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CALENDAR_EVENT_SIGNUP:
    event_id: int
    tentative: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CALENDAR_EVENT_SIGNUP:
        # event_id: Guid
        event_id = await read_int(reader, 8)

        # tentative: Bool8
        tentative = await read_bool(reader, 1)

        return CMSG_CALENDAR_EVENT_SIGNUP(
            event_id=event_id,
            tentative=tentative,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x04BA))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.event_id, self.tentative])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CALENDAR_CLEAR_PENDING_ACTION:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CALENDAR_CLEAR_PENDING_ACTION:
        return SMSG_CALENDAR_CLEAR_PENDING_ACTION()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x04BB))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_EQUIPMENT_SET_LIST:
    equipment_sets: typing.List[EquipmentSetListItem]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_EQUIPMENT_SET_LIST:
        # amount_of_equipment_sets: u32
        amount_of_equipment_sets = await read_int(reader, 4)

        # equipment_sets: EquipmentSetListItem[amount_of_equipment_sets]
        equipment_sets = []
        for _ in range(0, amount_of_equipment_sets):
            equipment_sets.append(await EquipmentSetListItem.read(reader))

        return SMSG_EQUIPMENT_SET_LIST(
            equipment_sets=equipment_sets,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x04BC))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.equipment_sets))
        # equipment_sets: EquipmentSetListItem[amount_of_equipment_sets]
        for i in self.equipment_sets:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + sum([i.size() for i in self.equipment_sets])


@dataclasses.dataclass
class CMSG_EQUIPMENT_SET_SAVE:
    guid: int
    index: int
    name: str
    icon_name: str
    equipment: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_EQUIPMENT_SET_SAVE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # index: u32
        index = await read_int(reader, 4)

        # name: CString
        name = await read_cstring(reader)

        # icon_name: CString
        icon_name = await read_cstring(reader)

        # equipment: Guid[19]
        equipment = []
        for _ in range(0, 19):
            equipment.append(await read_int(reader, 8))

        return CMSG_EQUIPMENT_SET_SAVE(
            guid=guid,
            index=index,
            name=name,
            icon_name=icon_name,
            equipment=equipment,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x04BD))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # index: u32
        _fmt += 'I'
        _data.append(self.index)

        # name: CString
        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])

        # icon_name: CString
        _fmt += f'{len(self.icon_name)}sB'
        _data.extend([self.icon_name.encode('utf-8'), 0])

        # equipment: Guid[19]
        _fmt += f'{len(self.equipment)}Q'
        _data.extend([*self.equipment])

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 158 + packed_guid_size(self.guid) + len(self.name) + len(self.icon_name)


@dataclasses.dataclass
class CMSG_UPDATE_PROJECTILE_POSITION:
    caster: int
    spell: int
    cast_count: int
    position: Vector3d

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_UPDATE_PROJECTILE_POSITION:
        # caster: Guid
        caster = await read_int(reader, 8)

        # spell: Spell
        spell = await read_int(reader, 4)

        # cast_count: u8
        cast_count = await read_int(reader, 1)

        # position: Vector3d
        position = await Vector3d.read(reader)

        return CMSG_UPDATE_PROJECTILE_POSITION(
            caster=caster,
            spell=spell,
            cast_count=cast_count,
            position=position,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(25 + 4, 0x04BE))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIB'
        _data.extend([self.caster, self.spell, self.cast_count])
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SET_PROJECTILE_POSITION:
    caster: int
    amount_of_casts: int
    position: Vector3d

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_PROJECTILE_POSITION:
        # caster: Guid
        caster = await read_int(reader, 8)

        # amount_of_casts: u8
        amount_of_casts = await read_int(reader, 1)

        # position: Vector3d
        position = await Vector3d.read(reader)

        return SMSG_SET_PROJECTILE_POSITION(
            caster=caster,
            amount_of_casts=amount_of_casts,
            position=position,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(21 + 2, 0x04BF))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.caster, self.amount_of_casts])
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TALENTS_INFO:
    talent_type: TalentInfoType
    points_left: int
    talents: typing.Optional[typing.List[InspectTalent]] = None
    active_spec: typing.Optional[int] = None
    specs: typing.Optional[typing.List[TalentInfoSpec]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TALENTS_INFO:
        amount_of_talents = None
        talents = None
        amount_of_specs = None
        active_spec = None
        specs = None
        # talent_type: TalentInfoType
        talent_type = TalentInfoType(await read_int(reader, 1))

        # points_left: u32
        points_left = await read_int(reader, 4)

        if talent_type == TalentInfoType.PET:
            # amount_of_talents: u8
            amount_of_talents = await read_int(reader, 1)

            # talents: InspectTalent[amount_of_talents]
            talents = []
            for _ in range(0, amount_of_talents):
                talents.append(await InspectTalent.read(reader))

        elif talent_type == TalentInfoType.PLAYER:
            # amount_of_specs: u8
            amount_of_specs = await read_int(reader, 1)

            # active_spec: u8
            active_spec = await read_int(reader, 1)

            # specs: TalentInfoSpec[amount_of_specs]
            specs = []
            for _ in range(0, amount_of_specs):
                specs.append(await TalentInfoSpec.read(reader))

        return SMSG_TALENTS_INFO(
            talent_type=talent_type,
            points_left=points_left,
            talents=talents,
            active_spec=active_spec,
            specs=specs,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x04C0))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BI'
        _data.extend([self.talent_type.value, self.points_left])
        if self.talent_type == TalentInfoType.PET:
            _fmt += 'B'
            _data.append(len(self.talents))
            # talents: InspectTalent[amount_of_talents]
            for i in self.talents:
                _fmt, _data = i.write(_fmt, _data)

        elif self.talent_type == TalentInfoType.PLAYER:
            _fmt += 'BB'
            _data.extend([len(self.specs), self.active_spec])
            # specs: TalentInfoSpec[amount_of_specs]
            for i in self.specs:
                _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 5

        if self.talent_type == TalentInfoType.PET:
            _size += 1 + 5 * len(self.talents)
        elif self.talent_type == TalentInfoType.PLAYER:
            _size += 2 + sum([i.size() for i in self.specs])

        return _size


@dataclasses.dataclass
class CMSG_LEARN_PREVIEW_TALENTS:
    talents: typing.List[PreviewTalent]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LEARN_PREVIEW_TALENTS:
        # amount_of_talents: u32
        amount_of_talents = await read_int(reader, 4)

        # talents: PreviewTalent[amount_of_talents]
        talents = []
        for _ in range(0, amount_of_talents):
            talents.append(await PreviewTalent.read(reader))

        return CMSG_LEARN_PREVIEW_TALENTS(
            talents=talents,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x04C1))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.talents))
        # talents: PreviewTalent[amount_of_talents]
        for i in self.talents:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + 8 * len(self.talents)


@dataclasses.dataclass
class CMSG_LEARN_PREVIEW_TALENTS_PET:
    pet: int
    talents: typing.List[PreviewTalent]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LEARN_PREVIEW_TALENTS_PET:
        # pet: Guid
        pet = await read_int(reader, 8)

        # amount_of_talents: u32
        amount_of_talents = await read_int(reader, 4)

        # talents: PreviewTalent[amount_of_talents]
        talents = []
        for _ in range(0, amount_of_talents):
            talents.append(await PreviewTalent.read(reader))

        return CMSG_LEARN_PREVIEW_TALENTS_PET(
            pet=pet,
            talents=talents,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x04C2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.pet, len(self.talents)])
        # talents: PreviewTalent[amount_of_talents]
        for i in self.talents:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + 8 * len(self.talents)


@dataclasses.dataclass
class SMSG_ARENA_UNIT_DESTROYED:
    unit: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ARENA_UNIT_DESTROYED:
        # unit: Guid
        unit = await read_int(reader, 8)

        return SMSG_ARENA_UNIT_DESTROYED(
            unit=unit,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x04C7))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.unit)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ARENA_TEAM_CHANGE_FAILED_QUEUED:
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ARENA_TEAM_CHANGE_FAILED_QUEUED:
        # unknown: u32
        unknown = await read_int(reader, 4)

        return SMSG_ARENA_TEAM_CHANGE_FAILED_QUEUED(
            unknown=unknown,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x04C8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.unknown)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MOVE_GRAVITY_DISABLE:
    unit: int
    movement_counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_GRAVITY_DISABLE:
        # unit: PackedGuid
        unit = await read_packed_guid(reader)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        return SMSG_MOVE_GRAVITY_DISABLE(
            unit=unit,
            movement_counter=movement_counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x04CE))
        _fmt = "<4s"
        _data = [_data]

        # unit: PackedGuid
        _fmt, _data = packed_guid_write(self.unit, _fmt, _data)

        # movement_counter: u32
        _fmt += 'I'
        _data.append(self.movement_counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.unit)


@dataclasses.dataclass
class CMSG_MOVE_GRAVITY_DISABLE_ACK:
    guid: int
    unknown: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_GRAVITY_DISABLE_ACK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # unknown: u32
        unknown = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return CMSG_MOVE_GRAVITY_DISABLE_ACK(
            guid=guid,
            unknown=unknown,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x04CF))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # unknown: u32
        _fmt += 'I'
        _data.append(self.unknown)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class SMSG_MOVE_GRAVITY_ENABLE:
    unit: int
    movement_counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_GRAVITY_ENABLE:
        # unit: PackedGuid
        unit = await read_packed_guid(reader)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        return SMSG_MOVE_GRAVITY_ENABLE(
            unit=unit,
            movement_counter=movement_counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x04D0))
        _fmt = "<4s"
        _data = [_data]

        # unit: PackedGuid
        _fmt, _data = packed_guid_write(self.unit, _fmt, _data)

        # movement_counter: u32
        _fmt += 'I'
        _data.append(self.movement_counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.unit)


@dataclasses.dataclass
class CMSG_MOVE_GRAVITY_ENABLE_ACK:
    guid: int
    unknown: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_GRAVITY_ENABLE_ACK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # unknown: u32
        unknown = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return CMSG_MOVE_GRAVITY_ENABLE_ACK(
            guid=guid,
            unknown=unknown,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x04D1))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # unknown: u32
        _fmt += 'I'
        _data.append(self.unknown)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_GRAVITY_CHNG_Server:
    player: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_GRAVITY_CHNG_Server:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_GRAVITY_CHNG_Server(
            player=player,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x04D2))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_GRAVITY_DISABLE:
    unit: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_GRAVITY_DISABLE:
        # unit: PackedGuid
        unit = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_GRAVITY_DISABLE(
            unit=unit,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x04D3))
        _fmt = "<4s"
        _data = [_data]

        # unit: PackedGuid
        _fmt, _data = packed_guid_write(self.unit, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.unit)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_GRAVITY_ENABLE:
    unit: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_GRAVITY_ENABLE:
        # unit: PackedGuid
        unit = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_GRAVITY_ENABLE(
            unit=unit,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x04D4))
        _fmt = "<4s"
        _data = [_data]

        # unit: PackedGuid
        _fmt, _data = packed_guid_write(self.unit, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.unit)


@dataclasses.dataclass
class CMSG_EQUIPMENT_SET_USE:
    sets: typing.List[EquipmentSet]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_EQUIPMENT_SET_USE:
        # sets: EquipmentSet[19]
        sets = []
        for _ in range(0, 19):
            sets.append(await EquipmentSet.read(reader))

        return CMSG_EQUIPMENT_SET_USE(
            sets=sets,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(190 + 4, 0x04D5))
        _fmt = "<6s"
        _data = [_data]

        # sets: EquipmentSet[19]
        for i in self.sets:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_EQUIPMENT_SET_USE_RESULT:
    result: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_EQUIPMENT_SET_USE_RESULT:
        # result: u8
        result = await read_int(reader, 1)

        return SMSG_EQUIPMENT_SET_USE_RESULT(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x04D6))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CHAR_FACTION_CHANGE:
    guid: int
    name: str
    gender: Gender
    skin_color: int
    hair_color: int
    hair_style: int
    facial_hair: int
    face: int
    race: Race

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHAR_FACTION_CHANGE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # name: CString
        name = await read_cstring(reader)

        # gender: Gender
        gender = Gender(await read_int(reader, 1))

        # skin_color: u8
        skin_color = await read_int(reader, 1)

        # hair_color: u8
        hair_color = await read_int(reader, 1)

        # hair_style: u8
        hair_style = await read_int(reader, 1)

        # facial_hair: u8
        facial_hair = await read_int(reader, 1)

        # face: u8
        face = await read_int(reader, 1)

        # race: Race
        race = Race(await read_int(reader, 1))

        return CMSG_CHAR_FACTION_CHANGE(
            guid=guid,
            name=name,
            gender=gender,
            skin_color=skin_color,
            hair_color=hair_color,
            hair_style=hair_style,
            facial_hair=facial_hair,
            face=face,
            race=race,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x04D9))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.name)}sBBBBBBBB'
        _data.extend([self.guid, self.name.encode('utf-8'), 0, self.gender.value, self.skin_color, self.hair_color, self.hair_style, self.facial_hair, self.face, self.race.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + len(self.name)


@dataclasses.dataclass
class SMSG_CHAR_FACTION_CHANGE:
    result: WorldResult
    guid: typing.Optional[int] = None
    name: typing.Optional[str] = None
    gender: typing.Optional[Gender] = None
    skin_color: typing.Optional[int] = None
    face: typing.Optional[int] = None
    hair_style: typing.Optional[int] = None
    hair_color: typing.Optional[int] = None
    facial_hair: typing.Optional[int] = None
    race: typing.Optional[Race] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAR_FACTION_CHANGE:
        guid = None
        name = None
        gender = None
        skin_color = None
        face = None
        hair_style = None
        hair_color = None
        facial_hair = None
        race = None
        # result: WorldResult
        result = WorldResult(await read_int(reader, 1))

        if result == WorldResult.RESPONSE_SUCCESS:
            # guid: Guid
            guid = await read_int(reader, 8)

            # name: CString
            name = await read_cstring(reader)

            # gender: Gender
            gender = Gender(await read_int(reader, 1))

            # skin_color: u8
            skin_color = await read_int(reader, 1)

            # face: u8
            face = await read_int(reader, 1)

            # hair_style: u8
            hair_style = await read_int(reader, 1)

            # hair_color: u8
            hair_color = await read_int(reader, 1)

            # facial_hair: u8
            facial_hair = await read_int(reader, 1)

            # race: Race
            race = Race(await read_int(reader, 1))

        return SMSG_CHAR_FACTION_CHANGE(
            result=result,
            guid=guid,
            name=name,
            gender=gender,
            skin_color=skin_color,
            face=face,
            hair_style=hair_style,
            hair_color=hair_color,
            facial_hair=facial_hair,
            race=race,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x04DA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        if self.result == WorldResult.RESPONSE_SUCCESS:
            _fmt += f'Q{len(self.name)}sBBBBBBBB'
            _data.extend([self.guid, self.name.encode('utf-8'), 0, self.gender.value, self.skin_color, self.face, self.hair_style, self.hair_color, self.facial_hair, self.race.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.result == WorldResult.RESPONSE_SUCCESS:
            _size += 16 + len(self.name)

        return _size


@dataclasses.dataclass
class SMSG_BATTLEFIELD_MGR_ENTRY_INVITE:
    battle_id: int
    area: Area
    accept_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BATTLEFIELD_MGR_ENTRY_INVITE:
        # battle_id: u32
        battle_id = await read_int(reader, 4)

        # area: Area
        area = Area(await read_int(reader, 4))

        # accept_time: Seconds
        accept_time = await read_int(reader, 4)

        return SMSG_BATTLEFIELD_MGR_ENTRY_INVITE(
            battle_id=battle_id,
            area=area,
            accept_time=accept_time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x04DE))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'III'
        _data.extend([self.battle_id, self.area.value, self.accept_time])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BATTLEFIELD_MGR_ENTRY_INVITE_RESPONSE:
    battle_id: int
    accepted: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BATTLEFIELD_MGR_ENTRY_INVITE_RESPONSE:
        # battle_id: u32
        battle_id = await read_int(reader, 4)

        # accepted: Bool8
        accepted = await read_bool(reader, 1)

        return CMSG_BATTLEFIELD_MGR_ENTRY_INVITE_RESPONSE(
            battle_id=battle_id,
            accepted=accepted,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 4, 0x04DF))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([self.battle_id, self.accepted])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BATTLEFIELD_MGR_ENTERED:
    battle_id: int
    unknown1: int
    unknown2: int
    clear_afk: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BATTLEFIELD_MGR_ENTERED:
        # battle_id: u32
        battle_id = await read_int(reader, 4)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # unknown2: u8
        unknown2 = await read_int(reader, 1)

        # clear_afk: Bool8
        clear_afk = await read_bool(reader, 1)

        return SMSG_BATTLEFIELD_MGR_ENTERED(
            battle_id=battle_id,
            unknown1=unknown1,
            unknown2=unknown2,
            clear_afk=clear_afk,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(7 + 2, 0x04E0))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IBBB'
        _data.extend([self.battle_id, self.unknown1, self.unknown2, self.clear_afk])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BATTLEFIELD_MGR_QUEUE_INVITE:
    battle_id: int
    warmup: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BATTLEFIELD_MGR_QUEUE_INVITE:
        # battle_id: u32
        battle_id = await read_int(reader, 4)

        # warmup: u8
        warmup = await read_int(reader, 1)

        return SMSG_BATTLEFIELD_MGR_QUEUE_INVITE(
            battle_id=battle_id,
            warmup=warmup,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x04E1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([self.battle_id, self.warmup])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BATTLEFIELD_MGR_QUEUE_INVITE_RESPONSE:
    battle_id: int
    accepted: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BATTLEFIELD_MGR_QUEUE_INVITE_RESPONSE:
        # battle_id: u32
        battle_id = await read_int(reader, 4)

        # accepted: Bool8
        accepted = await read_bool(reader, 1)

        return CMSG_BATTLEFIELD_MGR_QUEUE_INVITE_RESPONSE(
            battle_id=battle_id,
            accepted=accepted,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 4, 0x04E2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([self.battle_id, self.accepted])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BATTLEFIELD_MGR_QUEUE_REQUEST_RESPONSE:
    battle_id: int
    area: Area
    queued: bool
    full: bool
    warmup: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BATTLEFIELD_MGR_QUEUE_REQUEST_RESPONSE:
        # battle_id: u32
        battle_id = await read_int(reader, 4)

        # area: Area
        area = Area(await read_int(reader, 4))

        # queued: Bool8
        queued = await read_bool(reader, 1)

        # full: Bool8
        full = await read_bool(reader, 1)

        # warmup: Bool8
        warmup = await read_bool(reader, 1)

        return SMSG_BATTLEFIELD_MGR_QUEUE_REQUEST_RESPONSE(
            battle_id=battle_id,
            area=area,
            queued=queued,
            full=full,
            warmup=warmup,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(11 + 2, 0x04E4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIBBB'
        _data.extend([self.battle_id, self.area.value, self.queued, self.full, self.warmup])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BATTLEFIELD_MGR_EJECT_PENDING:
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BATTLEFIELD_MGR_EJECT_PENDING:
        # unknown: u32
        unknown = await read_int(reader, 4)

        return SMSG_BATTLEFIELD_MGR_EJECT_PENDING(
            unknown=unknown,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x04E5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.unknown)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BATTLEFIELD_MGR_EJECTED:
    battle_id: int
    reason: int
    battle_status: int
    relocated: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BATTLEFIELD_MGR_EJECTED:
        # battle_id: u32
        battle_id = await read_int(reader, 4)

        # reason: u8
        reason = await read_int(reader, 1)

        # battle_status: u8
        battle_status = await read_int(reader, 1)

        # relocated: u8
        relocated = await read_int(reader, 1)

        return SMSG_BATTLEFIELD_MGR_EJECTED(
            battle_id=battle_id,
            reason=reason,
            battle_status=battle_status,
            relocated=relocated,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(7 + 2, 0x04E6))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IBBB'
        _data.extend([self.battle_id, self.reason, self.battle_status, self.relocated])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BATTLEFIELD_MGR_EXIT_REQUEST:
    battle_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BATTLEFIELD_MGR_EXIT_REQUEST:
        # battle_id: u32
        battle_id = await read_int(reader, 4)

        return CMSG_BATTLEFIELD_MGR_EXIT_REQUEST(
            battle_id=battle_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x04E7))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.battle_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BATTLEFIELD_MGR_STATE_CHANGE:
    unknown1: int
    unknown2: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BATTLEFIELD_MGR_STATE_CHANGE:
        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # unknown2: u32
        unknown2 = await read_int(reader, 4)

        return SMSG_BATTLEFIELD_MGR_STATE_CHANGE(
            unknown1=unknown1,
            unknown2=unknown2,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x04E8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.unknown1, self.unknown2])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_SET_RAID_DIFFICULTY_Client:
    difficulty: RaidDifficulty

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_SET_RAID_DIFFICULTY_Client:
        # difficulty: RaidDifficulty
        difficulty = RaidDifficulty(await read_int(reader, 4))

        return MSG_SET_RAID_DIFFICULTY_Client(
            difficulty=difficulty,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x04EB))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.difficulty.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_SET_RAID_DIFFICULTY_Server:
    difficulty: RaidDifficulty
    unknown1: int
    in_group: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_SET_RAID_DIFFICULTY_Server:
        # difficulty: RaidDifficulty
        difficulty = RaidDifficulty(await read_int(reader, 4))

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # in_group: Bool32
        in_group = await read_bool(reader, 4)

        return MSG_SET_RAID_DIFFICULTY_Server(
            difficulty=difficulty,
            unknown1=unknown1,
            in_group=in_group,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x04EB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'III'
        _data.extend([self.difficulty.value, self.unknown1, self.in_group])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TOGGLE_XP_GAIN:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TOGGLE_XP_GAIN:
        return SMSG_TOGGLE_XP_GAIN()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x04ED))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GMRESPONSE_DB_ERROR:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GMRESPONSE_DB_ERROR:
        return SMSG_GMRESPONSE_DB_ERROR()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x04EE))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GMRESPONSE_RECEIVED:
    response_id: int
    ticket_id: int
    message: str
    response: typing.List[str]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GMRESPONSE_RECEIVED:
        # response_id: u32
        response_id = await read_int(reader, 4)

        # ticket_id: u32
        ticket_id = await read_int(reader, 4)

        # message: CString
        message = await read_cstring(reader)

        # response: CString[4]
        response = []
        for _ in range(0, 4):
            response.append(await read_cstring(reader))

        return SMSG_GMRESPONSE_RECEIVED(
            response_id=response_id,
            ticket_id=ticket_id,
            message=message,
            response=response,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x04EF))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'II{len(self.message)}sB'
        _data.extend([self.response_id, self.ticket_id, self.message.encode('utf-8'), 0])
        # response: CString[4]
        for i in self.response:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.message) + sum([len(i) + 1 for i in self.response])


@dataclasses.dataclass
class CMSG_GMRESPONSE_RESOLVE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GMRESPONSE_RESOLVE:
        return CMSG_GMRESPONSE_RESOLVE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x04F0))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GMRESPONSE_STATUS_UPDATE:
    show_survey: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GMRESPONSE_STATUS_UPDATE:
        # show_survey: Bool8
        show_survey = await read_bool(reader, 1)

        return SMSG_GMRESPONSE_STATUS_UPDATE(
            show_survey=show_survey,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x04F1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.show_survey)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_WORLD_STATE_UI_TIMER_UPDATE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_WORLD_STATE_UI_TIMER_UPDATE:
        return CMSG_WORLD_STATE_UI_TIMER_UPDATE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x04F6))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_WORLD_STATE_UI_TIMER_UPDATE:
    time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_WORLD_STATE_UI_TIMER_UPDATE:
        # time: u32
        time = await read_int(reader, 4)

        return SMSG_WORLD_STATE_UI_TIMER_UPDATE(
            time=time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x04F7))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.time)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CHAR_RACE_CHANGE:
    player: int
    name: str
    gender: Gender
    skin_color: int
    hair_color: int
    hair_style: int
    facial_hair: int
    face: int
    race: Race

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHAR_RACE_CHANGE:
        # player: Guid
        player = await read_int(reader, 8)

        # name: CString
        name = await read_cstring(reader)

        # gender: Gender
        gender = Gender(await read_int(reader, 1))

        # skin_color: u8
        skin_color = await read_int(reader, 1)

        # hair_color: u8
        hair_color = await read_int(reader, 1)

        # hair_style: u8
        hair_style = await read_int(reader, 1)

        # facial_hair: u8
        facial_hair = await read_int(reader, 1)

        # face: u8
        face = await read_int(reader, 1)

        # race: Race
        race = Race(await read_int(reader, 1))

        return CMSG_CHAR_RACE_CHANGE(
            player=player,
            name=name,
            gender=gender,
            skin_color=skin_color,
            hair_color=hair_color,
            hair_style=hair_style,
            facial_hair=facial_hair,
            face=face,
            race=race,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x04F8))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.name)}sBBBBBBBB'
        _data.extend([self.player, self.name.encode('utf-8'), 0, self.gender.value, self.skin_color, self.hair_color, self.hair_style, self.facial_hair, self.face, self.race.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + len(self.name)


@dataclasses.dataclass
class SMSG_TALENTS_INVOLUNTARILY_RESET:
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TALENTS_INVOLUNTARILY_RESET:
        # unknown: u8
        unknown = await read_int(reader, 1)

        return SMSG_TALENTS_INVOLUNTARILY_RESET(
            unknown=unknown,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x04FA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.unknown)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_READY_FOR_ACCOUNT_DATA_TIMES:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_READY_FOR_ACCOUNT_DATA_TIMES:
        return CMSG_READY_FOR_ACCOUNT_DATA_TIMES()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x04FF))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUERY_QUESTS_COMPLETED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUERY_QUESTS_COMPLETED:
        return CMSG_QUERY_QUESTS_COMPLETED()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0500))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUERY_QUESTS_COMPLETED_RESPONSE:
    reward_quests: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUERY_QUESTS_COMPLETED_RESPONSE:
        # amount_of_reward_quests: u32
        amount_of_reward_quests = await read_int(reader, 4)

        # reward_quests: u32[amount_of_reward_quests]
        reward_quests = []
        for _ in range(0, amount_of_reward_quests):
            reward_quests.append(await read_int(reader, 4))

        return SMSG_QUERY_QUESTS_COMPLETED_RESPONSE(
            reward_quests=reward_quests,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0501))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.reward_quests)}I'
        _data.extend([len(self.reward_quests), *self.reward_quests])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + 4 * len(self.reward_quests)


@dataclasses.dataclass
class CMSG_GM_REPORT_LAG:
    lag_type: int
    map: Map
    position: Vector3d

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GM_REPORT_LAG:
        # lag_type: u32
        lag_type = await read_int(reader, 4)

        # map: Map
        map = Map(await read_int(reader, 4))

        # position: Vector3d
        position = await Vector3d.read(reader)

        return CMSG_GM_REPORT_LAG(
            lag_type=lag_type,
            map=map,
            position=position,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 4, 0x0502))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.lag_type, self.map.value])
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CORPSE_NOT_IN_INSTANCE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CORPSE_NOT_IN_INSTANCE:
        return SMSG_CORPSE_NOT_IN_INSTANCE()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0506))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CAMERA_SHAKE:
    camera_shake_id: int
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CAMERA_SHAKE:
        # camera_shake_id: u32
        camera_shake_id = await read_int(reader, 4)

        # unknown: u32
        unknown = await read_int(reader, 4)

        return SMSG_CAMERA_SHAKE(
            camera_shake_id=camera_shake_id,
            unknown=unknown,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x050A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.camera_shake_id, self.unknown])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SOCKET_GEMS_RESULT:
    item: int
    sockets: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SOCKET_GEMS_RESULT:
        # item: Guid
        item = await read_int(reader, 8)

        # sockets: u32[3]
        sockets = []
        for _ in range(0, 3):
            sockets.append(await read_int(reader, 4))

        return SMSG_SOCKET_GEMS_RESULT(
            item=item,
            sockets=sockets,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x050B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'Q{len(self.sockets)}I'
        _data.extend([self.item, *self.sockets])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_REDIRECT_CLIENT:
    ip_address: int
    port: int
    unknown: int
    hash: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_REDIRECT_CLIENT:
        # ip_address: u32
        ip_address = await read_int(reader, 4)

        # port: u16
        port = await read_int(reader, 2)

        # unknown: u32
        unknown = await read_int(reader, 4)

        # hash: u8[20]
        hash = []
        for _ in range(0, 20):
            hash.append(await read_int(reader, 1))

        return SMSG_REDIRECT_CLIENT(
            ip_address=ip_address,
            port=port,
            unknown=unknown,
            hash=hash,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(30 + 2, 0x050D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'IHI{len(self.hash)}B'
        _data.extend([self.ip_address, self.port, self.unknown, *self.hash])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MOVE_SET_COLLISION_HGT:
    unit: int
    packet_counter: int
    collision_height: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_SET_COLLISION_HGT:
        # unit: PackedGuid
        unit = await read_packed_guid(reader)

        # packet_counter: u32
        packet_counter = await read_int(reader, 4)

        # collision_height: f32
        collision_height = await read_float(reader)

        return SMSG_MOVE_SET_COLLISION_HGT(
            unit=unit,
            packet_counter=packet_counter,
            collision_height=collision_height,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0516))
        _fmt = "<4s"
        _data = [_data]

        # unit: PackedGuid
        _fmt, _data = packed_guid_write(self.unit, _fmt, _data)

        # packet_counter: u32
        _fmt += 'I'
        _data.append(self.packet_counter)

        # collision_height: f32
        _fmt += 'f'
        _data.append(self.collision_height)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.unit)


@dataclasses.dataclass
class CMSG_MOVE_SET_COLLISION_HGT_ACK:
    player: int
    movement_counter: int
    info: MovementInfo
    new_height: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_SET_COLLISION_HGT_ACK:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_height: f32
        new_height = await read_float(reader)

        return CMSG_MOVE_SET_COLLISION_HGT_ACK(
            player=player,
            movement_counter=movement_counter,
            info=info,
            new_height=new_height,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0517))
        _fmt = "<6s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # movement_counter: u32
        _fmt += 'I'
        _data.append(self.movement_counter)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_height: f32
        _fmt += 'f'
        _data.append(self.new_height)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class SMSG_MULTIPLE_MOVES:
    moves: typing.List[MiniMoveMessage]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MULTIPLE_MOVES:
        _size = 0

        # size: u32
        _size = await read_int(reader, 4)
        _size += 4

        # moves: MiniMoveMessage[-]
        moves = []
        while _size < body_size:
            moves.append(await MiniMoveMessage.read(reader))
            _size += moves[-1].size()

        return SMSG_MULTIPLE_MOVES(
            moves=moves,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x051E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.size())
        # moves: MiniMoveMessage[-]
        for i in self.moves:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + sum([i.size() for i in self.moves])


ClientOpcode = typing.Union[
    CMSG_BOOTME,
    CMSG_DBLOOKUP,
    CMSG_WORLD_TELEPORT,
    CMSG_TELEPORT_TO_UNIT,
    CMSG_CHAR_CREATE,
    CMSG_CHAR_ENUM,
    CMSG_CHAR_DELETE,
    CMSG_PLAYER_LOGIN,
    CMSG_PLAYER_LOGOUT,
    CMSG_LOGOUT_REQUEST,
    CMSG_LOGOUT_CANCEL,
    CMSG_NAME_QUERY,
    CMSG_PET_NAME_QUERY,
    CMSG_GUILD_QUERY,
    CMSG_ITEM_QUERY_SINGLE,
    CMSG_PAGE_TEXT_QUERY,
    CMSG_QUEST_QUERY,
    CMSG_GAMEOBJECT_QUERY,
    CMSG_CREATURE_QUERY,
    CMSG_WHO,
    CMSG_WHOIS,
    CMSG_CONTACT_LIST,
    CMSG_ADD_FRIEND,
    CMSG_DEL_FRIEND,
    CMSG_SET_CONTACT_NOTES,
    CMSG_ADD_IGNORE,
    CMSG_DEL_IGNORE,
    CMSG_GROUP_INVITE,
    CMSG_GROUP_CANCEL,
    CMSG_GROUP_ACCEPT,
    CMSG_GROUP_DECLINE,
    CMSG_GROUP_UNINVITE,
    CMSG_GROUP_UNINVITE_GUID,
    CMSG_GROUP_SET_LEADER,
    CMSG_LOOT_METHOD,
    CMSG_GROUP_DISBAND,
    CMSG_GUILD_CREATE,
    CMSG_GUILD_INVITE,
    CMSG_GUILD_ACCEPT,
    CMSG_GUILD_DECLINE,
    CMSG_GUILD_INFO,
    CMSG_GUILD_ROSTER,
    CMSG_GUILD_PROMOTE,
    CMSG_GUILD_DEMOTE,
    CMSG_GUILD_LEAVE,
    CMSG_GUILD_REMOVE,
    CMSG_GUILD_DISBAND,
    CMSG_GUILD_LEADER,
    CMSG_GUILD_MOTD,
    CMSG_MESSAGECHAT,
    CMSG_JOIN_CHANNEL,
    CMSG_LEAVE_CHANNEL,
    CMSG_CHANNEL_LIST,
    CMSG_CHANNEL_PASSWORD,
    CMSG_CHANNEL_SET_OWNER,
    CMSG_CHANNEL_OWNER,
    CMSG_CHANNEL_MODERATOR,
    CMSG_CHANNEL_UNMODERATOR,
    CMSG_CHANNEL_MUTE,
    CMSG_CHANNEL_UNMUTE,
    CMSG_CHANNEL_INVITE,
    CMSG_CHANNEL_KICK,
    CMSG_CHANNEL_BAN,
    CMSG_CHANNEL_UNBAN,
    CMSG_CHANNEL_ANNOUNCEMENTS,
    CMSG_CHANNEL_MODERATE,
    CMSG_USE_ITEM,
    CMSG_OPEN_ITEM,
    CMSG_READ_ITEM,
    CMSG_GAMEOBJ_USE,
    CMSG_AREATRIGGER,
    MSG_MOVE_START_FORWARD,
    MSG_MOVE_START_BACKWARD,
    MSG_MOVE_STOP,
    MSG_MOVE_START_STRAFE_LEFT,
    MSG_MOVE_START_STRAFE_RIGHT,
    MSG_MOVE_STOP_STRAFE,
    MSG_MOVE_JUMP,
    MSG_MOVE_START_TURN_LEFT,
    MSG_MOVE_START_TURN_RIGHT,
    MSG_MOVE_STOP_TURN,
    MSG_MOVE_START_PITCH_UP,
    MSG_MOVE_START_PITCH_DOWN,
    MSG_MOVE_STOP_PITCH,
    MSG_MOVE_SET_RUN_MODE,
    MSG_MOVE_SET_WALK_MODE,
    MSG_MOVE_TELEPORT_Server,
    MSG_MOVE_TELEPORT_ACK_Client,
    MSG_MOVE_FALL_LAND,
    MSG_MOVE_START_SWIM,
    MSG_MOVE_STOP_SWIM,
    MSG_MOVE_SET_FACING,
    MSG_MOVE_SET_PITCH,
    MSG_MOVE_WORLDPORT_ACK,
    CMSG_MOVE_SET_RAW_POSITION,
    CMSG_FORCE_RUN_SPEED_CHANGE_ACK,
    CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK,
    CMSG_FORCE_SWIM_SPEED_CHANGE_ACK,
    CMSG_FORCE_MOVE_ROOT_ACK,
    CMSG_FORCE_MOVE_UNROOT_ACK,
    MSG_MOVE_HEARTBEAT,
    CMSG_MOVE_KNOCK_BACK_ACK,
    CMSG_MOVE_HOVER_ACK,
    MSG_MOVE_HOVER,
    CMSG_NEXT_CINEMATIC_CAMERA,
    CMSG_COMPLETE_CINEMATIC,
    CMSG_TUTORIAL_FLAG,
    CMSG_TUTORIAL_CLEAR,
    CMSG_TUTORIAL_RESET,
    CMSG_STANDSTATECHANGE,
    CMSG_EMOTE,
    CMSG_TEXT_EMOTE,
    CMSG_AUTOSTORE_LOOT_ITEM,
    CMSG_AUTOEQUIP_ITEM,
    CMSG_AUTOSTORE_BAG_ITEM,
    CMSG_SWAP_ITEM,
    CMSG_SWAP_INV_ITEM,
    CMSG_SPLIT_ITEM,
    CMSG_AUTOEQUIP_ITEM_SLOT,
    CMSG_DESTROYITEM,
    CMSG_INSPECT,
    CMSG_INITIATE_TRADE,
    CMSG_BEGIN_TRADE,
    CMSG_BUSY_TRADE,
    CMSG_IGNORE_TRADE,
    CMSG_ACCEPT_TRADE,
    CMSG_UNACCEPT_TRADE,
    CMSG_CANCEL_TRADE,
    CMSG_SET_TRADE_ITEM,
    CMSG_CLEAR_TRADE_ITEM,
    CMSG_SET_TRADE_GOLD,
    CMSG_SET_FACTION_ATWAR,
    CMSG_SET_ACTION_BUTTON,
    CMSG_CAST_SPELL,
    CMSG_CANCEL_CAST,
    CMSG_CANCEL_AURA,
    CMSG_CANCEL_CHANNELLING,
    CMSG_SET_SELECTION,
    CMSG_DELETEEQUIPMENT_SET,
    CMSG_INSTANCE_LOCK_RESPONSE,
    CMSG_ATTACKSWING,
    CMSG_ATTACKSTOP,
    CMSG_REPOP_REQUEST,
    CMSG_RESURRECT_RESPONSE,
    CMSG_LOOT,
    CMSG_LOOT_MONEY,
    CMSG_LOOT_RELEASE,
    CMSG_DUEL_ACCEPTED,
    CMSG_DUEL_CANCELLED,
    CMSG_MOUNTSPECIAL_ANIM,
    CMSG_PET_SET_ACTION,
    CMSG_PET_ACTION,
    CMSG_PET_ABANDON,
    CMSG_PET_RENAME,
    CMSG_GOSSIP_HELLO,
    CMSG_GOSSIP_SELECT_OPTION,
    CMSG_NPC_TEXT_QUERY,
    CMSG_QUESTGIVER_STATUS_QUERY,
    CMSG_QUESTGIVER_HELLO,
    CMSG_QUESTGIVER_QUERY_QUEST,
    CMSG_QUESTGIVER_QUEST_AUTOLAUNCH,
    CMSG_QUESTGIVER_ACCEPT_QUEST,
    CMSG_QUESTGIVER_COMPLETE_QUEST,
    CMSG_QUESTGIVER_REQUEST_REWARD,
    CMSG_QUESTGIVER_CHOOSE_REWARD,
    CMSG_QUESTGIVER_CANCEL,
    CMSG_QUESTLOG_SWAP_QUEST,
    CMSG_QUESTLOG_REMOVE_QUEST,
    CMSG_QUEST_CONFIRM_ACCEPT,
    CMSG_PUSHQUESTTOPARTY,
    CMSG_LIST_INVENTORY,
    CMSG_SELL_ITEM,
    CMSG_BUY_ITEM,
    CMSG_BUY_ITEM_IN_SLOT,
    CMSG_TAXINODE_STATUS_QUERY,
    CMSG_TAXIQUERYAVAILABLENODES,
    CMSG_ACTIVATETAXI,
    CMSG_TRAINER_LIST,
    CMSG_TRAINER_BUY_SPELL,
    CMSG_BINDER_ACTIVATE,
    CMSG_BANKER_ACTIVATE,
    CMSG_BUY_BANK_SLOT,
    CMSG_PETITION_SHOWLIST,
    CMSG_PETITION_BUY,
    CMSG_PETITION_SHOW_SIGNATURES,
    CMSG_PETITION_SIGN,
    MSG_PETITION_DECLINE,
    CMSG_OFFER_PETITION,
    CMSG_TURN_IN_PETITION,
    CMSG_PETITION_QUERY,
    CMSG_BUG,
    CMSG_PLAYED_TIME,
    CMSG_QUERY_TIME,
    CMSG_RECLAIM_CORPSE,
    CMSG_WRAP_ITEM,
    MSG_MINIMAP_PING_Client,
    CMSG_PING,
    CMSG_SETSHEATHED,
    CMSG_QUEST_POI_QUERY,
    CMSG_AUTH_SESSION,
    CMSG_PET_CAST_SPELL,
    MSG_SAVE_GUILD_EMBLEM_Client,
    MSG_TABARDVENDOR_ACTIVATE,
    CMSG_ZONEUPDATE,
    MSG_RANDOM_ROLL_Client,
    CMSG_UNLEARN_SKILL,
    CMSG_GMTICKET_CREATE,
    CMSG_GMTICKET_UPDATETEXT,
    CMSG_REQUEST_ACCOUNT_DATA,
    CMSG_UPDATE_ACCOUNT_DATA,
    CMSG_GMTICKET_GETTICKET,
    CMSG_UNLEARN_TALENTS,
    MSG_CORPSE_QUERY_Client,
    CMSG_GMTICKET_DELETETICKET,
    CMSG_GMTICKET_SYSTEMSTATUS,
    CMSG_SPIRIT_HEALER_ACTIVATE,
    CMSG_CHAT_IGNORED,
    CMSG_GUILD_RANK,
    CMSG_GUILD_ADD_RANK,
    CMSG_GUILD_DEL_RANK,
    CMSG_GUILD_SET_PUBLIC_NOTE,
    CMSG_GUILD_SET_OFFICER_NOTE,
    CMSG_SEND_MAIL,
    CMSG_GET_MAIL_LIST,
    CMSG_BATTLEFIELD_LIST,
    CMSG_ITEM_TEXT_QUERY,
    CMSG_MAIL_TAKE_MONEY,
    CMSG_MAIL_TAKE_ITEM,
    CMSG_MAIL_MARK_AS_READ,
    CMSG_MAIL_RETURN_TO_SENDER,
    CMSG_MAIL_DELETE,
    CMSG_MAIL_CREATE_TEXT_ITEM,
    CMSG_LEARN_TALENT,
    CMSG_TOGGLE_PVP,
    MSG_AUCTION_HELLO_Client,
    CMSG_AUCTION_SELL_ITEM,
    CMSG_AUCTION_REMOVE_ITEM,
    CMSG_AUCTION_LIST_ITEMS,
    CMSG_AUCTION_LIST_OWNER_ITEMS,
    CMSG_AUCTION_PLACE_BID,
    CMSG_AUCTION_LIST_BIDDER_ITEMS,
    CMSG_SET_AMMO,
    CMSG_SET_ACTIVE_MOVER,
    CMSG_PET_CANCEL_AURA,
    CMSG_CANCEL_AUTO_REPEAT_SPELL,
    MSG_LIST_STABLED_PETS_Client,
    CMSG_STABLE_PET,
    CMSG_UNSTABLE_PET,
    CMSG_BUY_STABLE_SLOT,
    CMSG_STABLE_SWAP_PET,
    MSG_QUEST_PUSH_RESULT,
    CMSG_REQUEST_PET_INFO,
    CMSG_FAR_SIGHT,
    CMSG_GROUP_CHANGE_SUB_GROUP,
    CMSG_REQUEST_PARTY_MEMBER_STATS,
    CMSG_GROUP_SWAP_SUB_GROUP,
    CMSG_AUTOSTORE_BANK_ITEM,
    CMSG_AUTOBANK_ITEM,
    MSG_QUERY_NEXT_MAIL_TIME_Client,
    CMSG_GROUP_RAID_CONVERT,
    CMSG_GROUP_ASSISTANT_LEADER,
    CMSG_BUYBACK_ITEM,
    CMSG_SET_SAVED_INSTANCE_EXTEND,
    CMSG_LFG_GET_STATUS,
    CMSG_GMTICKETSYSTEM_TOGGLE,
    CMSG_CANCEL_GROWTH_AURA,
    CMSG_LOOT_ROLL,
    CMSG_LOOT_MASTER_GIVE,
    CMSG_REPAIR_ITEM,
    MSG_TALENT_WIPE_CONFIRM_Client,
    CMSG_SUMMON_RESPONSE,
    MSG_MOVE_WATER_WALK,
    CMSG_SELF_RES,
    CMSG_TOGGLE_HELM,
    CMSG_TOGGLE_CLOAK,
    CMSG_SET_ACTIONBAR_TOGGLES,
    MSG_PETITION_RENAME,
    CMSG_ITEM_NAME_QUERY,
    CMSG_CHAR_RENAME,
    CMSG_MOVE_SPLINE_DONE,
    CMSG_MOVE_FALL_RESET,
    CMSG_REQUEST_RAID_INFO,
    CMSG_MOVE_TIME_SKIPPED,
    CMSG_MOVE_FEATHER_FALL_ACK,
    CMSG_MOVE_WATER_WALK_ACK,
    CMSG_MOVE_NOT_ACTIVE_MOVER,
    CMSG_BATTLEFIELD_STATUS,
    CMSG_BATTLEFIELD_PORT,
    MSG_INSPECT_HONOR_STATS_Client,
    CMSG_BATTLEMASTER_HELLO,
    CMSG_FORCE_WALK_SPEED_CHANGE_ACK,
    CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK,
    CMSG_FORCE_TURN_RATE_CHANGE_ACK,
    MSG_PVP_LOG_DATA_Client,
    CMSG_LEAVE_BATTLEFIELD,
    CMSG_AREA_SPIRIT_HEALER_QUERY,
    CMSG_AREA_SPIRIT_HEALER_QUEUE,
    CMSG_WARDEN_DATA,
    MSG_BATTLEGROUND_PLAYER_POSITIONS_Client,
    CMSG_PET_STOP_ATTACK,
    CMSG_BATTLEMASTER_JOIN,
    CMSG_PET_UNLEARN,
    CMSG_PET_SPELL_AUTOCAST,
    CMSG_GUILD_INFO_TEXT,
    CMSG_ACTIVATETAXIEXPRESS,
    CMSG_SET_FACTION_INACTIVE,
    CMSG_SET_WATCHED_FACTION,
    CMSG_RESET_INSTANCES,
    MSG_RAID_TARGET_UPDATE_Client,
    MSG_RAID_READY_CHECK_Client,
    MSG_SET_DUNGEON_DIFFICULTY_Client,
    CMSG_GMSURVEY_SUBMIT,
    CMSG_MOVE_SET_CAN_TRANSITION_BETWEEN_SWIM_AND_FLY_ACK,
    CMSG_MOVE_SET_CAN_FLY_ACK,
    CMSG_MOVE_SET_FLY,
    CMSG_SOCKET_GEMS,
    CMSG_ARENA_TEAM_ROSTER,
    CMSG_ARENA_TEAM_INVITE,
    CMSG_ARENA_TEAM_ACCEPT,
    CMSG_ARENA_TEAM_DECLINE,
    CMSG_ARENA_TEAM_LEAVE,
    CMSG_ARENA_TEAM_REMOVE,
    CMSG_ARENA_TEAM_DISBAND,
    CMSG_ARENA_TEAM_LEADER,
    CMSG_BATTLEMASTER_JOIN_ARENA,
    MSG_MOVE_START_ASCEND,
    MSG_MOVE_STOP_ASCEND,
    CMSG_LFG_JOIN,
    CMSG_LFG_LEAVE,
    CMSG_SEARCH_LFG_JOIN,
    CMSG_SEARCH_LFG_LEAVE,
    CMSG_LFG_PROPOSAL_RESULT,
    CMSG_SET_LFG_COMMENT,
    CMSG_LFG_SET_ROLES,
    CMSG_LFG_SET_BOOT_VOTE,
    CMSG_LFD_PLAYER_LOCK_INFO_REQUEST,
    CMSG_LFG_TELEPORT,
    CMSG_LFD_PARTY_LOCK_INFO_REQUEST,
    CMSG_SET_TITLE,
    CMSG_CANCEL_MOUNT_AURA,
    MSG_INSPECT_ARENA_TEAMS_Client,
    CMSG_CANCEL_TEMP_ENCHANTMENT,
    MSG_MOVE_SET_FLIGHT_BACK_SPEED,
    CMSG_FORCE_FLIGHT_SPEED_CHANGE_ACK,
    CMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE_ACK,
    CMSG_SET_TAXI_BENCHMARK_MODE,
    CMSG_REALM_SPLIT,
    CMSG_MOVE_CHNG_TRANSPORT,
    MSG_PARTY_ASSIGNMENT_Client,
    CMSG_TIME_SYNC_RESP,
    MSG_MOVE_START_DESCEND,
    MSG_RAID_READY_CHECK_CONFIRM_Client,
    CMSG_VOICE_SESSION_ENABLE,
    CMSG_COMMENTATOR_ENABLE,
    MSG_RAID_READY_CHECK_FINISHED_Client,
    CMSG_COMPLAIN,
    CMSG_CHANNEL_DISPLAY_LIST,
    CMSG_SET_ACTIVE_VOICE_CHANNEL,
    CMSG_GET_CHANNEL_MEMBER_COUNT,
    CMSG_CHANNEL_VOICE_ON,
    CMSG_REPORT_PVP_AFK,
    CMSG_GUILD_BANKER_ACTIVATE,
    CMSG_GUILD_BANK_QUERY_TAB,
    CMSG_GUILD_BANK_SWAP_ITEMS,
    CMSG_GUILD_BANK_BUY_TAB,
    CMSG_GUILD_BANK_UPDATE_TAB,
    CMSG_GUILD_BANK_DEPOSIT_MONEY,
    CMSG_GUILD_BANK_WITHDRAW_MONEY,
    MSG_GUILD_BANK_LOG_QUERY_Client,
    CMSG_SET_CHANNEL_WATCH,
    CMSG_CLEAR_CHANNEL_WATCH,
    CMSG_SPELLCLICK,
    MSG_GUILD_PERMISSIONS_Client,
    MSG_GUILD_BANK_MONEY_WITHDRAWN_Client,
    MSG_GUILD_EVENT_LOG_QUERY_Client,
    CMSG_GET_MIRRORIMAGE_DATA,
    CMSG_KEEP_ALIVE,
    CMSG_OPT_OUT_OF_LOOT,
    MSG_QUERY_GUILD_BANK_TEXT_Client,
    CMSG_SET_GUILD_BANK_TEXT,
    CMSG_GRANT_LEVEL,
    CMSG_TOTEM_DESTROYED,
    CMSG_QUESTGIVER_STATUS_MULTIPLE_QUERY,
    CMSG_SET_PLAYER_DECLINED_NAMES,
    CMSG_ACCEPT_LEVEL_GRANT,
    CMSG_ALTER_APPEARANCE,
    CMSG_CALENDAR_GET_CALENDAR,
    CMSG_CALENDAR_GET_EVENT,
    CMSG_CALENDAR_GUILD_FILTER,
    CMSG_CALENDAR_ARENA_TEAM,
    CMSG_CALENDAR_ADD_EVENT,
    CMSG_CALENDAR_UPDATE_EVENT,
    CMSG_CALENDAR_REMOVE_EVENT,
    CMSG_CALENDAR_COPY_EVENT,
    CMSG_CALENDAR_EVENT_INVITE,
    CMSG_CALENDAR_EVENT_RSVP,
    CMSG_CALENDAR_EVENT_REMOVE_INVITE,
    CMSG_CALENDAR_EVENT_STATUS,
    CMSG_CALENDAR_EVENT_MODERATOR_STATUS,
    CMSG_CALENDAR_COMPLAIN,
    CMSG_CALENDAR_GET_NUM_PENDING,
    CMSG_UPDATE_MISSILE_TRAJECTORY,
    CMSG_COMPLETE_MOVIE,
    CMSG_QUERY_INSPECT_ACHIEVEMENTS,
    CMSG_DISMISS_CONTROLLED_VEHICLE,
    CMSG_CHAR_CUSTOMIZE,
    CMSG_REQUEST_VEHICLE_EXIT,
    CMSG_REQUEST_VEHICLE_PREV_SEAT,
    CMSG_REQUEST_VEHICLE_NEXT_SEAT,
    CMSG_REQUEST_VEHICLE_SWITCH_SEAT,
    CMSG_PET_LEARN_TALENT,
    CMSG_GAMEOBJ_REPORT_USE,
    CMSG_REMOVE_GLYPH,
    CMSG_DISMISS_CRITTER,
    CMSG_AUCTION_LIST_PENDING_SALES,
    CMSG_ENABLETAXI,
    CMSG_CHANGE_SEATS_ON_CONTROLLED_VEHICLE,
    CMSG_HEARTH_AND_RESURRECT,
    CMSG_PLAYER_VEHICLE_ENTER,
    CMSG_CONTROLLER_EJECT_PASSENGER,
    CMSG_ITEM_REFUND_INFO,
    CMSG_ITEM_REFUND,
    CMSG_CORPSE_MAP_POSITION_QUERY,
    CMSG_CALENDAR_EVENT_SIGNUP,
    CMSG_EQUIPMENT_SET_SAVE,
    CMSG_UPDATE_PROJECTILE_POSITION,
    CMSG_LEARN_PREVIEW_TALENTS,
    CMSG_LEARN_PREVIEW_TALENTS_PET,
    CMSG_MOVE_GRAVITY_DISABLE_ACK,
    CMSG_MOVE_GRAVITY_ENABLE_ACK,
    CMSG_EQUIPMENT_SET_USE,
    CMSG_CHAR_FACTION_CHANGE,
    CMSG_BATTLEFIELD_MGR_ENTRY_INVITE_RESPONSE,
    CMSG_BATTLEFIELD_MGR_QUEUE_INVITE_RESPONSE,
    CMSG_BATTLEFIELD_MGR_EXIT_REQUEST,
    MSG_SET_RAID_DIFFICULTY_Client,
    CMSG_GMRESPONSE_RESOLVE,
    CMSG_WORLD_STATE_UI_TIMER_UPDATE,
    CMSG_CHAR_RACE_CHANGE,
    CMSG_READY_FOR_ACCOUNT_DATA_TIMES,
    CMSG_QUERY_QUESTS_COMPLETED,
    CMSG_GM_REPORT_LAG,
    CMSG_MOVE_SET_COLLISION_HGT_ACK,
]

ServerOpcode = typing.Union[
    SMSG_CHAR_CREATE,
    SMSG_CHAR_ENUM,
    SMSG_CHAR_DELETE,
    SMSG_NEW_WORLD,
    SMSG_TRANSFER_PENDING,
    SMSG_TRANSFER_ABORTED,
    SMSG_CHARACTER_LOGIN_FAILED,
    SMSG_LOGIN_SETTIMESPEED,
    SMSG_LOGOUT_RESPONSE,
    SMSG_LOGOUT_COMPLETE,
    SMSG_LOGOUT_CANCEL_ACK,
    SMSG_NAME_QUERY_RESPONSE,
    SMSG_PET_NAME_QUERY_RESPONSE,
    SMSG_GUILD_QUERY_RESPONSE,
    SMSG_ITEM_QUERY_SINGLE_RESPONSE,
    SMSG_PAGE_TEXT_QUERY_RESPONSE,
    SMSG_QUEST_QUERY_RESPONSE,
    SMSG_GAMEOBJECT_QUERY_RESPONSE,
    SMSG_CREATURE_QUERY_RESPONSE,
    SMSG_WHO,
    SMSG_WHOIS,
    SMSG_CONTACT_LIST,
    SMSG_FRIEND_STATUS,
    SMSG_GROUP_INVITE,
    SMSG_GROUP_DECLINE,
    SMSG_GROUP_UNINVITE,
    SMSG_GROUP_SET_LEADER,
    SMSG_GROUP_DESTROYED,
    SMSG_GROUP_LIST,
    SMSG_PARTY_MEMBER_STATS,
    SMSG_PARTY_COMMAND_RESULT,
    SMSG_GUILD_INVITE,
    SMSG_GUILD_DECLINE,
    SMSG_GUILD_INFO,
    SMSG_GUILD_ROSTER,
    SMSG_GUILD_EVENT,
    SMSG_GUILD_COMMAND_RESULT,
    SMSG_MESSAGECHAT,
    SMSG_CHANNEL_NOTIFY,
    SMSG_CHANNEL_LIST,
    SMSG_UPDATE_OBJECT,
    SMSG_DESTROY_OBJECT,
    SMSG_READ_ITEM_OK,
    SMSG_READ_ITEM_FAILED,
    SMSG_ITEM_COOLDOWN,
    SMSG_GAMEOBJECT_CUSTOM_ANIM,
    MSG_MOVE_START_FORWARD,
    MSG_MOVE_START_BACKWARD,
    MSG_MOVE_STOP,
    MSG_MOVE_START_STRAFE_LEFT,
    MSG_MOVE_START_STRAFE_RIGHT,
    MSG_MOVE_STOP_STRAFE,
    MSG_MOVE_JUMP,
    MSG_MOVE_START_TURN_LEFT,
    MSG_MOVE_START_TURN_RIGHT,
    MSG_MOVE_STOP_TURN,
    MSG_MOVE_START_PITCH_UP,
    MSG_MOVE_START_PITCH_DOWN,
    MSG_MOVE_STOP_PITCH,
    MSG_MOVE_SET_RUN_MODE,
    MSG_MOVE_SET_WALK_MODE,
    MSG_MOVE_TELEPORT_CHEAT_Server,
    MSG_MOVE_TELEPORT_ACK_Server,
    MSG_MOVE_FALL_LAND,
    MSG_MOVE_START_SWIM,
    MSG_MOVE_STOP_SWIM,
    MSG_MOVE_SET_FACING,
    MSG_MOVE_SET_PITCH,
    MSG_MOVE_WORLDPORT_ACK,
    SMSG_MONSTER_MOVE,
    SMSG_MOVE_WATER_WALK,
    SMSG_MOVE_LAND_WALK,
    SMSG_FORCE_RUN_SPEED_CHANGE,
    SMSG_FORCE_RUN_BACK_SPEED_CHANGE,
    SMSG_FORCE_SWIM_SPEED_CHANGE,
    SMSG_FORCE_MOVE_ROOT,
    SMSG_FORCE_MOVE_UNROOT,
    MSG_MOVE_ROOT_Server,
    MSG_MOVE_UNROOT_Server,
    MSG_MOVE_HEARTBEAT,
    SMSG_MOVE_KNOCK_BACK,
    MSG_MOVE_KNOCK_BACK_Server,
    SMSG_MOVE_FEATHER_FALL,
    SMSG_MOVE_NORMAL_FALL,
    SMSG_MOVE_SET_HOVER,
    SMSG_MOVE_UNSET_HOVER,
    MSG_MOVE_HOVER,
    SMSG_TRIGGER_CINEMATIC,
    SMSG_TUTORIAL_FLAGS,
    SMSG_EMOTE,
    SMSG_TEXT_EMOTE,
    SMSG_INVENTORY_CHANGE_FAILURE,
    SMSG_TRADE_STATUS,
    SMSG_TRADE_STATUS_EXTENDED,
    SMSG_INITIALIZE_FACTIONS,
    SMSG_SET_FACTION_VISIBLE,
    SMSG_SET_FACTION_STANDING,
    SMSG_SET_PROFICIENCY,
    SMSG_ACTION_BUTTONS,
    SMSG_INITIAL_SPELLS,
    SMSG_LEARNED_SPELL,
    SMSG_SUPERCEDED_SPELL,
    SMSG_CAST_FAILED,
    SMSG_SPELL_START,
    SMSG_SPELL_GO,
    SMSG_SPELL_FAILURE,
    SMSG_SPELL_COOLDOWN,
    SMSG_COOLDOWN_EVENT,
    SMSG_PET_CAST_FAILED,
    MSG_CHANNEL_START_Server,
    MSG_CHANNEL_UPDATE_Server,
    SMSG_AI_REACTION,
    SMSG_ATTACKSTART,
    SMSG_ATTACKSTOP,
    SMSG_ATTACKSWING_NOTINRANGE,
    SMSG_ATTACKSWING_BADFACING,
    SMSG_INSTANCE_LOCK_WARNING_QUERY,
    SMSG_ATTACKSWING_DEADTARGET,
    SMSG_ATTACKSWING_CANT_ATTACK,
    SMSG_ATTACKERSTATEUPDATE,
    SMSG_CANCEL_COMBAT,
    SMSG_SPELLHEALLOG,
    SMSG_SPELLENERGIZELOG,
    SMSG_BREAK_TARGET,
    SMSG_BINDPOINTUPDATE,
    SMSG_PLAYERBOUND,
    SMSG_CLIENT_CONTROL_UPDATE,
    SMSG_RESURRECT_REQUEST,
    SMSG_LOOT_RESPONSE,
    SMSG_LOOT_RELEASE_RESPONSE,
    SMSG_LOOT_REMOVED,
    SMSG_LOOT_MONEY_NOTIFY,
    SMSG_LOOT_CLEAR_MONEY,
    SMSG_ITEM_PUSH_RESULT,
    SMSG_DUEL_REQUESTED,
    SMSG_DUEL_OUTOFBOUNDS,
    SMSG_DUEL_INBOUNDS,
    SMSG_DUEL_COMPLETE,
    SMSG_DUEL_WINNER,
    SMSG_MOUNTRESULT,
    SMSG_MOUNTSPECIAL_ANIM,
    SMSG_PET_TAME_FAILURE,
    SMSG_PET_NAME_INVALID,
    SMSG_PET_SPELLS,
    SMSG_PET_MODE,
    SMSG_GOSSIP_MESSAGE,
    SMSG_GOSSIP_COMPLETE,
    SMSG_NPC_TEXT_UPDATE,
    SMSG_QUESTGIVER_STATUS,
    SMSG_QUESTGIVER_QUEST_LIST,
    SMSG_QUESTGIVER_QUEST_DETAILS,
    SMSG_QUESTGIVER_REQUEST_ITEMS,
    SMSG_QUESTGIVER_OFFER_REWARD,
    SMSG_QUESTGIVER_QUEST_INVALID,
    SMSG_QUESTGIVER_QUEST_COMPLETE,
    SMSG_QUESTGIVER_QUEST_FAILED,
    SMSG_QUESTLOG_FULL,
    SMSG_QUESTUPDATE_FAILED,
    SMSG_QUESTUPDATE_FAILEDTIMER,
    SMSG_QUESTUPDATE_COMPLETE,
    SMSG_QUESTUPDATE_ADD_KILL,
    SMSG_QUESTUPDATE_ADD_ITEM,
    SMSG_QUEST_CONFIRM_ACCEPT,
    SMSG_LIST_INVENTORY,
    SMSG_SELL_ITEM,
    SMSG_BUY_ITEM,
    SMSG_BUY_FAILED,
    SMSG_SHOWTAXINODES,
    SMSG_TAXINODE_STATUS,
    SMSG_ACTIVATETAXIREPLY,
    SMSG_NEW_TAXI_PATH,
    SMSG_TRAINER_LIST,
    SMSG_TRAINER_BUY_SUCCEEDED,
    SMSG_TRAINER_BUY_FAILED,
    SMSG_SHOW_BANK,
    SMSG_BUY_BANK_SLOT_RESULT,
    SMSG_PETITION_SHOWLIST,
    SMSG_PETITION_SHOW_SIGNATURES,
    SMSG_PETITION_SIGN_RESULTS,
    MSG_PETITION_DECLINE,
    SMSG_TURN_IN_PETITION_RESULTS,
    SMSG_PETITION_QUERY_RESPONSE,
    SMSG_FISH_NOT_HOOKED,
    SMSG_FISH_ESCAPED,
    SMSG_NOTIFICATION,
    SMSG_PLAYED_TIME,
    SMSG_QUERY_TIME_RESPONSE,
    SMSG_LOG_XPGAIN,
    SMSG_LEVELUP_INFO,
    MSG_MINIMAP_PING_Server,
    SMSG_ENCHANTMENTLOG,
    SMSG_START_MIRROR_TIMER,
    SMSG_PAUSE_MIRROR_TIMER,
    SMSG_STOP_MIRROR_TIMER,
    SMSG_PONG,
    SMSG_CLEAR_COOLDOWN,
    SMSG_GAMEOBJECT_PAGETEXT,
    SMSG_SPELL_DELAYED,
    SMSG_QUEST_POI_QUERY_RESPONSE,
    SMSG_ITEM_TIME_UPDATE,
    SMSG_ITEM_ENCHANT_TIME_UPDATE,
    SMSG_AUTH_CHALLENGE,
    SMSG_AUTH_RESPONSE,
    MSG_SAVE_GUILD_EMBLEM_Server,
    MSG_TABARDVENDOR_ACTIVATE,
    SMSG_PLAY_SPELL_VISUAL,
    SMSG_PARTYKILLLOG,
    SMSG_COMPRESSED_UPDATE_OBJECT,
    SMSG_PLAY_SPELL_IMPACT,
    SMSG_EXPLORATION_EXPERIENCE,
    MSG_RANDOM_ROLL_Server,
    SMSG_ENVIRONMENTAL_DAMAGE_LOG,
    SMSG_LFG_PLAYER_REWARD,
    SMSG_LFG_TELEPORT_DENIED,
    SMSG_REMOVED_SPELL,
    SMSG_GMTICKET_CREATE,
    SMSG_GMTICKET_UPDATETEXT,
    SMSG_ACCOUNT_DATA_TIMES,
    SMSG_UPDATE_ACCOUNT_DATA,
    SMSG_GMTICKET_GETTICKET,
    SMSG_UPDATE_INSTANCE_ENCOUNTER_UNIT,
    SMSG_GAMEOBJECT_DESPAWN_ANIM,
    MSG_CORPSE_QUERY_Server,
    SMSG_GMTICKET_DELETETICKET,
    SMSG_CHAT_WRONG_FACTION,
    SMSG_GMTICKET_SYSTEMSTATUS,
    SMSG_QUEST_FORCE_REMOVE,
    SMSG_SPIRIT_HEALER_CONFIRM,
    SMSG_GOSSIP_POI,
    SMSG_LOGIN_VERIFY_WORLD,
    SMSG_SEND_MAIL_RESULT,
    SMSG_MAIL_LIST_RESULT,
    SMSG_BATTLEFIELD_LIST,
    SMSG_ITEM_TEXT_QUERY_RESPONSE,
    SMSG_SPELLLOGMISS,
    SMSG_SPELLLOGEXECUTE,
    SMSG_PERIODICAURALOG,
    SMSG_SPELLDAMAGESHIELD,
    SMSG_SPELLNONMELEEDAMAGELOG,
    SMSG_RESURRECT_FAILED,
    SMSG_ZONE_UNDER_ATTACK,
    MSG_AUCTION_HELLO_Server,
    SMSG_AUCTION_COMMAND_RESULT,
    SMSG_AUCTION_LIST_RESULT,
    SMSG_AUCTION_OWNER_LIST_RESULT,
    SMSG_AUCTION_BIDDER_NOTIFICATION,
    SMSG_AUCTION_OWNER_NOTIFICATION,
    SMSG_PROCRESIST,
    SMSG_DISPEL_FAILED,
    SMSG_SPELLORDAMAGE_IMMUNE,
    SMSG_AUCTION_BIDDER_LIST_RESULT,
    SMSG_SET_FLAT_SPELL_MODIFIER,
    SMSG_SET_PCT_SPELL_MODIFIER,
    SMSG_CORPSE_RECLAIM_DELAY,
    MSG_LIST_STABLED_PETS_Server,
    SMSG_STABLE_RESULT,
    MSG_QUEST_PUSH_RESULT,
    SMSG_PLAY_MUSIC,
    SMSG_PLAY_OBJECT_SOUND,
    SMSG_SPELLDISPELLOG,
    MSG_QUERY_NEXT_MAIL_TIME_Server,
    SMSG_RECEIVED_MAIL,
    SMSG_RAID_GROUP_ONLY,
    SMSG_PVP_CREDIT,
    SMSG_AUCTION_REMOVED_NOTIFICATION,
    SMSG_SERVER_MESSAGE,
    SMSG_LFG_OFFER_CONTINUE,
    SMSG_SHOW_MAILBOX,
    SMSG_CANCEL_AUTO_REPEAT,
    SMSG_STANDSTATE_UPDATE,
    SMSG_LOOT_ALL_PASSED,
    SMSG_LOOT_ROLL_WON,
    SMSG_LOOT_START_ROLL,
    SMSG_LOOT_ROLL,
    SMSG_LOOT_MASTER_LIST,
    SMSG_SET_FORCED_REACTIONS,
    SMSG_SPELL_FAILED_OTHER,
    SMSG_CHAT_PLAYER_NOT_FOUND,
    MSG_TALENT_WIPE_CONFIRM_Server,
    SMSG_SUMMON_REQUEST,
    SMSG_MONSTER_MOVE_TRANSPORT,
    SMSG_PET_BROKEN,
    MSG_MOVE_FEATHER_FALL_Server,
    MSG_MOVE_WATER_WALK,
    SMSG_FEIGN_DEATH_RESISTED,
    SMSG_DUEL_COUNTDOWN,
    SMSG_AREA_TRIGGER_MESSAGE,
    SMSG_LFG_ROLE_CHOSEN,
    SMSG_PLAYER_SKINNED,
    SMSG_DURABILITY_DAMAGE_DEATH,
    MSG_PETITION_RENAME,
    SMSG_INIT_WORLD_STATES,
    SMSG_UPDATE_WORLD_STATE,
    SMSG_ITEM_NAME_QUERY_RESPONSE,
    SMSG_PET_ACTION_FEEDBACK,
    SMSG_CHAR_RENAME,
    SMSG_INSTANCE_SAVE_CREATED,
    SMSG_RAID_INSTANCE_INFO,
    SMSG_PLAY_SOUND,
    SMSG_BATTLEFIELD_STATUS,
    MSG_INSPECT_HONOR_STATS_Server,
    SMSG_FORCE_WALK_SPEED_CHANGE,
    SMSG_FORCE_SWIM_BACK_SPEED_CHANGE,
    SMSG_FORCE_TURN_RATE_CHANGE,
    SMSG_AREA_SPIRIT_HEALER_TIME,
    SMSG_WARDEN_DATA,
    SMSG_GROUP_JOINED_BATTLEGROUND,
    MSG_BATTLEGROUND_PLAYER_POSITIONS_Server,
    SMSG_BINDER_CONFIRM,
    SMSG_BATTLEGROUND_PLAYER_JOINED,
    SMSG_BATTLEGROUND_PLAYER_LEFT,
    SMSG_ADDON_INFO,
    SMSG_PET_UNLEARN_CONFIRM,
    SMSG_PARTY_MEMBER_STATS_FULL,
    SMSG_WEATHER,
    SMSG_RAID_INSTANCE_MESSAGE,
    SMSG_COMPRESSED_MOVES,
    SMSG_CHAT_RESTRICTED,
    SMSG_SPLINE_SET_RUN_SPEED,
    SMSG_SPLINE_SET_RUN_BACK_SPEED,
    SMSG_SPLINE_SET_SWIM_SPEED,
    SMSG_SPLINE_SET_WALK_SPEED,
    SMSG_SPLINE_SET_SWIM_BACK_SPEED,
    SMSG_SPLINE_SET_TURN_RATE,
    SMSG_SPLINE_MOVE_UNROOT,
    SMSG_SPLINE_MOVE_FEATHER_FALL,
    SMSG_SPLINE_MOVE_NORMAL_FALL,
    SMSG_SPLINE_MOVE_SET_HOVER,
    SMSG_SPLINE_MOVE_UNSET_HOVER,
    SMSG_SPLINE_MOVE_WATER_WALK,
    SMSG_SPLINE_MOVE_LAND_WALK,
    SMSG_SPLINE_MOVE_START_SWIM,
    SMSG_SPLINE_MOVE_STOP_SWIM,
    SMSG_SPLINE_MOVE_SET_RUN_MODE,
    SMSG_SPLINE_MOVE_SET_WALK_MODE,
    MSG_MOVE_TIME_SKIPPED_Server,
    SMSG_SPLINE_MOVE_ROOT,
    SMSG_INVALIDATE_PLAYER,
    SMSG_INSTANCE_RESET,
    SMSG_INSTANCE_RESET_FAILED,
    SMSG_UPDATE_LAST_INSTANCE,
    MSG_RAID_TARGET_UPDATE_Server,
    MSG_RAID_READY_CHECK_Server,
    SMSG_PET_ACTION_SOUND,
    SMSG_PET_DISMISS_SOUND,
    SMSG_GM_TICKET_STATUS_UPDATE,
    MSG_SET_DUNGEON_DIFFICULTY_Server,
    SMSG_UPDATE_INSTANCE_OWNERSHIP,
    SMSG_CHAT_PLAYER_AMBIGUOUS,
    SMSG_SPELLINSTAKILLLOG,
    SMSG_SPELL_UPDATE_CHAIN_TARGETS,
    SMSG_SPELLSTEALLOG,
    SMSG_DEFENSE_MESSAGE,
    SMSG_INSTANCE_DIFFICULTY,
    SMSG_MOTD,
    SMSG_MOVE_SET_CAN_FLY,
    SMSG_MOVE_UNSET_CAN_FLY,
    SMSG_ARENA_TEAM_COMMAND_RESULT,
    SMSG_ARENA_TEAM_QUERY_RESPONSE,
    SMSG_ARENA_TEAM_ROSTER,
    SMSG_ARENA_TEAM_INVITE,
    SMSG_ARENA_TEAM_EVENT,
    MSG_MOVE_START_ASCEND,
    MSG_MOVE_STOP_ASCEND,
    SMSG_ARENA_TEAM_STATS,
    SMSG_UPDATE_LFG_LIST,
    SMSG_LFG_PROPOSAL_UPDATE,
    SMSG_LFG_ROLE_CHECK_UPDATE,
    SMSG_LFG_JOIN_RESULT,
    SMSG_LFG_QUEUE_STATUS,
    SMSG_LFG_UPDATE_PLAYER,
    SMSG_LFG_UPDATE_PARTY,
    SMSG_LFG_UPDATE_SEARCH,
    SMSG_LFG_BOOT_PROPOSAL_UPDATE,
    SMSG_LFG_PLAYER_INFO,
    SMSG_LFG_PARTY_INFO,
    SMSG_TITLE_EARNED,
    SMSG_ARENA_ERROR,
    MSG_INSPECT_ARENA_TEAMS_Server,
    SMSG_DEATH_RELEASE_LOC,
    SMSG_FORCED_DEATH_UPDATE,
    MSG_MOVE_SET_FLIGHT_SPEED_Server,
    MSG_MOVE_SET_FLIGHT_BACK_SPEED,
    SMSG_FORCE_FLIGHT_SPEED_CHANGE,
    SMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE,
    SMSG_SPLINE_SET_FLIGHT_SPEED,
    SMSG_SPLINE_SET_FLIGHT_BACK_SPEED,
    SMSG_FLIGHT_SPLINE_SYNC,
    SMSG_REALM_SPLIT,
    SMSG_TIME_SYNC_REQ,
    SMSG_RESET_FAILED_NOTIFY,
    SMSG_LFG_DISABLED,
    SMSG_UPDATE_COMBO_POINTS,
    MSG_MOVE_START_DESCEND,
    SMSG_DISMOUNT,
    MSG_MOVE_UPDATE_CAN_FLY_Server,
    MSG_RAID_READY_CHECK_CONFIRM_Server,
    SMSG_GM_MESSAGECHAT,
    SMSG_CLEAR_TARGET,
    SMSG_CROSSED_INEBRIATION_THRESHOLD,
    SMSG_KICK_REASON,
    SMSG_COMPLAIN_RESULT,
    SMSG_FEATURE_SYSTEM_STATUS,
    SMSG_CHANNEL_MEMBER_COUNT,
    SMSG_GUILD_BANK_LIST,
    MSG_GUILD_BANK_LOG_QUERY_Server,
    SMSG_USERLIST_ADD,
    SMSG_USERLIST_REMOVE,
    SMSG_USERLIST_UPDATE,
    SMSG_INSPECT_TALENT,
    SMSG_LOOT_LIST,
    MSG_GUILD_PERMISSIONS_Server,
    MSG_GUILD_BANK_MONEY_WITHDRAWN_Server,
    MSG_GUILD_EVENT_LOG_QUERY_Server,
    SMSG_MIRRORIMAGE_DATA,
    MSG_QUERY_GUILD_BANK_TEXT_Server,
    SMSG_OVERRIDE_LIGHT,
    SMSG_TOTEM_CREATED,
    SMSG_QUESTGIVER_STATUS_MULTIPLE,
    SMSG_SET_PLAYER_DECLINED_NAMES_RESULT,
    SMSG_SEND_UNLEARN_SPELLS,
    SMSG_PROPOSE_LEVEL_GRANT,
    SMSG_REFER_A_FRIEND_FAILURE,
    SMSG_SPLINE_MOVE_SET_FLYING,
    SMSG_SPLINE_MOVE_UNSET_FLYING,
    SMSG_ENABLE_BARBER_SHOP,
    SMSG_BARBER_SHOP_RESULT,
    SMSG_CALENDAR_SEND_CALENDAR,
    SMSG_CALENDAR_SEND_EVENT,
    SMSG_CALENDAR_FILTER_GUILD,
    SMSG_CALENDAR_ARENA_TEAM,
    SMSG_CALENDAR_EVENT_INVITE,
    SMSG_CALENDAR_EVENT_INVITE_REMOVED,
    SMSG_CALENDAR_EVENT_STATUS,
    SMSG_CALENDAR_COMMAND_RESULT,
    SMSG_CALENDAR_RAID_LOCKOUT_ADDED,
    SMSG_CALENDAR_RAID_LOCKOUT_REMOVED,
    SMSG_CALENDAR_EVENT_INVITE_ALERT,
    SMSG_CALENDAR_EVENT_INVITE_REMOVED_ALERT,
    SMSG_CALENDAR_EVENT_REMOVED_ALERT,
    SMSG_CALENDAR_EVENT_UPDATED_ALERT,
    SMSG_CALENDAR_EVENT_MODERATOR_STATUS_ALERT,
    CMSG_CALENDAR_GET_NUM_PENDING,
    SMSG_CALENDAR_SEND_NUM_PENDING,
    MSG_MOVE_SET_PITCH_RATE_Server,
    SMSG_FORCE_PITCH_RATE_CHANGE,
    SMSG_CALENDAR_EVENT_INVITE_NOTES,
    SMSG_CALENDAR_EVENT_INVITE_NOTES_ALERT,
    SMSG_UPDATE_ACCOUNT_DATA_COMPLETE,
    SMSG_TRIGGER_MOVIE,
    SMSG_ACHIEVEMENT_EARNED,
    SMSG_CRITERIA_UPDATE,
    SMSG_RESPOND_INSPECT_ACHIEVEMENTS,
    SMSG_QUESTUPDATE_ADD_PVP_KILL,
    SMSG_CALENDAR_RAID_LOCKOUT_UPDATED,
    SMSG_CHAR_CUSTOMIZE,
    SMSG_SET_PHASE_SHIFT,
    SMSG_ALL_ACHIEVEMENT_DATA,
    SMSG_POWER_UPDATE,
    SMSG_HIGHEST_THREAT_UPDATE,
    SMSG_THREAT_UPDATE,
    SMSG_THREAT_REMOVE,
    SMSG_THREAT_CLEAR,
    SMSG_CONVERT_RUNE,
    SMSG_RESYNC_RUNES,
    SMSG_ADD_RUNE_POWER,
    SMSG_AUCTION_LIST_PENDING_SALES,
    SMSG_MODIFY_COOLDOWN,
    SMSG_PET_UPDATE_COMBO_POINTS,
    SMSG_PRE_RESURRECT,
    SMSG_AURA_UPDATE_ALL,
    SMSG_AURA_UPDATE,
    SMSG_SERVER_FIRST_ACHIEVEMENT,
    SMSG_PET_LEARNED_SPELL,
    SMSG_PET_UNLEARNED_SPELL,
    SMSG_ON_CANCEL_EXPECTED_RIDE_VEHICLE_AURA,
    SMSG_CRITERIA_DELETED,
    SMSG_ACHIEVEMENT_DELETED,
    SMSG_BATTLEGROUND_INFO_THROTTLED,
    SMSG_PLAYER_VEHICLE_DATA,
    SMSG_PET_GUIDS,
    SMSG_CLIENTCACHE_VERSION,
    SMSG_ITEM_REFUND_INFO_RESPONSE,
    SMSG_ITEM_REFUND_RESULT,
    SMSG_CORPSE_MAP_POSITION_QUERY_RESPONSE,
    SMSG_CALENDAR_CLEAR_PENDING_ACTION,
    SMSG_EQUIPMENT_SET_LIST,
    SMSG_SET_PROJECTILE_POSITION,
    SMSG_TALENTS_INFO,
    SMSG_ARENA_UNIT_DESTROYED,
    SMSG_ARENA_TEAM_CHANGE_FAILED_QUEUED,
    SMSG_MOVE_GRAVITY_DISABLE,
    SMSG_MOVE_GRAVITY_ENABLE,
    MSG_MOVE_GRAVITY_CHNG_Server,
    SMSG_SPLINE_MOVE_GRAVITY_DISABLE,
    SMSG_SPLINE_MOVE_GRAVITY_ENABLE,
    SMSG_EQUIPMENT_SET_USE_RESULT,
    SMSG_CHAR_FACTION_CHANGE,
    SMSG_BATTLEFIELD_MGR_ENTRY_INVITE,
    SMSG_BATTLEFIELD_MGR_ENTERED,
    SMSG_BATTLEFIELD_MGR_QUEUE_INVITE,
    SMSG_BATTLEFIELD_MGR_QUEUE_REQUEST_RESPONSE,
    SMSG_BATTLEFIELD_MGR_EJECT_PENDING,
    SMSG_BATTLEFIELD_MGR_EJECTED,
    SMSG_BATTLEFIELD_MGR_STATE_CHANGE,
    MSG_SET_RAID_DIFFICULTY_Server,
    SMSG_TOGGLE_XP_GAIN,
    SMSG_GMRESPONSE_DB_ERROR,
    SMSG_GMRESPONSE_RECEIVED,
    SMSG_GMRESPONSE_STATUS_UPDATE,
    SMSG_WORLD_STATE_UI_TIMER_UPDATE,
    SMSG_TALENTS_INVOLUNTARILY_RESET,
    SMSG_QUERY_QUESTS_COMPLETED_RESPONSE,
    SMSG_CORPSE_NOT_IN_INSTANCE,
    SMSG_CAMERA_SHAKE,
    SMSG_SOCKET_GEMS_RESULT,
    SMSG_REDIRECT_CLIENT,
    SMSG_MOVE_SET_COLLISION_HGT,
    SMSG_MULTIPLE_MOVES,
]


client_opcodes: dict[int, ClientOpcode] = {
    0x0001: CMSG_BOOTME,
    0x0002: CMSG_DBLOOKUP,
    0x0008: CMSG_WORLD_TELEPORT,
    0x0009: CMSG_TELEPORT_TO_UNIT,
    0x0036: CMSG_CHAR_CREATE,
    0x0037: CMSG_CHAR_ENUM,
    0x0038: CMSG_CHAR_DELETE,
    0x003D: CMSG_PLAYER_LOGIN,
    0x004A: CMSG_PLAYER_LOGOUT,
    0x004B: CMSG_LOGOUT_REQUEST,
    0x004E: CMSG_LOGOUT_CANCEL,
    0x0050: CMSG_NAME_QUERY,
    0x0052: CMSG_PET_NAME_QUERY,
    0x0054: CMSG_GUILD_QUERY,
    0x0056: CMSG_ITEM_QUERY_SINGLE,
    0x005A: CMSG_PAGE_TEXT_QUERY,
    0x005C: CMSG_QUEST_QUERY,
    0x005E: CMSG_GAMEOBJECT_QUERY,
    0x0060: CMSG_CREATURE_QUERY,
    0x0062: CMSG_WHO,
    0x0064: CMSG_WHOIS,
    0x0066: CMSG_CONTACT_LIST,
    0x0069: CMSG_ADD_FRIEND,
    0x006A: CMSG_DEL_FRIEND,
    0x006B: CMSG_SET_CONTACT_NOTES,
    0x006C: CMSG_ADD_IGNORE,
    0x006D: CMSG_DEL_IGNORE,
    0x006E: CMSG_GROUP_INVITE,
    0x0070: CMSG_GROUP_CANCEL,
    0x0072: CMSG_GROUP_ACCEPT,
    0x0073: CMSG_GROUP_DECLINE,
    0x0075: CMSG_GROUP_UNINVITE,
    0x0076: CMSG_GROUP_UNINVITE_GUID,
    0x0078: CMSG_GROUP_SET_LEADER,
    0x007A: CMSG_LOOT_METHOD,
    0x007B: CMSG_GROUP_DISBAND,
    0x0081: CMSG_GUILD_CREATE,
    0x0082: CMSG_GUILD_INVITE,
    0x0084: CMSG_GUILD_ACCEPT,
    0x0085: CMSG_GUILD_DECLINE,
    0x0087: CMSG_GUILD_INFO,
    0x0089: CMSG_GUILD_ROSTER,
    0x008B: CMSG_GUILD_PROMOTE,
    0x008C: CMSG_GUILD_DEMOTE,
    0x008D: CMSG_GUILD_LEAVE,
    0x008E: CMSG_GUILD_REMOVE,
    0x008F: CMSG_GUILD_DISBAND,
    0x0090: CMSG_GUILD_LEADER,
    0x0091: CMSG_GUILD_MOTD,
    0x0095: CMSG_MESSAGECHAT,
    0x0097: CMSG_JOIN_CHANNEL,
    0x0098: CMSG_LEAVE_CHANNEL,
    0x009A: CMSG_CHANNEL_LIST,
    0x009C: CMSG_CHANNEL_PASSWORD,
    0x009D: CMSG_CHANNEL_SET_OWNER,
    0x009E: CMSG_CHANNEL_OWNER,
    0x009F: CMSG_CHANNEL_MODERATOR,
    0x00A0: CMSG_CHANNEL_UNMODERATOR,
    0x00A1: CMSG_CHANNEL_MUTE,
    0x00A2: CMSG_CHANNEL_UNMUTE,
    0x00A3: CMSG_CHANNEL_INVITE,
    0x00A4: CMSG_CHANNEL_KICK,
    0x00A5: CMSG_CHANNEL_BAN,
    0x00A6: CMSG_CHANNEL_UNBAN,
    0x00A7: CMSG_CHANNEL_ANNOUNCEMENTS,
    0x00A8: CMSG_CHANNEL_MODERATE,
    0x00AB: CMSG_USE_ITEM,
    0x00AC: CMSG_OPEN_ITEM,
    0x00AD: CMSG_READ_ITEM,
    0x00B1: CMSG_GAMEOBJ_USE,
    0x00B4: CMSG_AREATRIGGER,
    0x00B5: MSG_MOVE_START_FORWARD,
    0x00B6: MSG_MOVE_START_BACKWARD,
    0x00B7: MSG_MOVE_STOP,
    0x00B8: MSG_MOVE_START_STRAFE_LEFT,
    0x00B9: MSG_MOVE_START_STRAFE_RIGHT,
    0x00BA: MSG_MOVE_STOP_STRAFE,
    0x00BB: MSG_MOVE_JUMP,
    0x00BC: MSG_MOVE_START_TURN_LEFT,
    0x00BD: MSG_MOVE_START_TURN_RIGHT,
    0x00BE: MSG_MOVE_STOP_TURN,
    0x00BF: MSG_MOVE_START_PITCH_UP,
    0x00C0: MSG_MOVE_START_PITCH_DOWN,
    0x00C1: MSG_MOVE_STOP_PITCH,
    0x00C2: MSG_MOVE_SET_RUN_MODE,
    0x00C3: MSG_MOVE_SET_WALK_MODE,
    0x00C5: MSG_MOVE_TELEPORT_Server,
    0x00C7: MSG_MOVE_TELEPORT_ACK_Client,
    0x00C9: MSG_MOVE_FALL_LAND,
    0x00CA: MSG_MOVE_START_SWIM,
    0x00CB: MSG_MOVE_STOP_SWIM,
    0x00DA: MSG_MOVE_SET_FACING,
    0x00DB: MSG_MOVE_SET_PITCH,
    0x00DC: MSG_MOVE_WORLDPORT_ACK,
    0x00E1: CMSG_MOVE_SET_RAW_POSITION,
    0x00E3: CMSG_FORCE_RUN_SPEED_CHANGE_ACK,
    0x00E5: CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK,
    0x00E7: CMSG_FORCE_SWIM_SPEED_CHANGE_ACK,
    0x00E9: CMSG_FORCE_MOVE_ROOT_ACK,
    0x00EB: CMSG_FORCE_MOVE_UNROOT_ACK,
    0x00EE: MSG_MOVE_HEARTBEAT,
    0x00F0: CMSG_MOVE_KNOCK_BACK_ACK,
    0x00F6: CMSG_MOVE_HOVER_ACK,
    0x00F7: MSG_MOVE_HOVER,
    0x00FB: CMSG_NEXT_CINEMATIC_CAMERA,
    0x00FC: CMSG_COMPLETE_CINEMATIC,
    0x00FE: CMSG_TUTORIAL_FLAG,
    0x00FF: CMSG_TUTORIAL_CLEAR,
    0x0100: CMSG_TUTORIAL_RESET,
    0x0101: CMSG_STANDSTATECHANGE,
    0x0102: CMSG_EMOTE,
    0x0104: CMSG_TEXT_EMOTE,
    0x0108: CMSG_AUTOSTORE_LOOT_ITEM,
    0x010A: CMSG_AUTOEQUIP_ITEM,
    0x010B: CMSG_AUTOSTORE_BAG_ITEM,
    0x010C: CMSG_SWAP_ITEM,
    0x010D: CMSG_SWAP_INV_ITEM,
    0x010E: CMSG_SPLIT_ITEM,
    0x010F: CMSG_AUTOEQUIP_ITEM_SLOT,
    0x0111: CMSG_DESTROYITEM,
    0x0114: CMSG_INSPECT,
    0x0116: CMSG_INITIATE_TRADE,
    0x0117: CMSG_BEGIN_TRADE,
    0x0118: CMSG_BUSY_TRADE,
    0x0119: CMSG_IGNORE_TRADE,
    0x011A: CMSG_ACCEPT_TRADE,
    0x011B: CMSG_UNACCEPT_TRADE,
    0x011C: CMSG_CANCEL_TRADE,
    0x011D: CMSG_SET_TRADE_ITEM,
    0x011E: CMSG_CLEAR_TRADE_ITEM,
    0x011F: CMSG_SET_TRADE_GOLD,
    0x0125: CMSG_SET_FACTION_ATWAR,
    0x0128: CMSG_SET_ACTION_BUTTON,
    0x012E: CMSG_CAST_SPELL,
    0x012F: CMSG_CANCEL_CAST,
    0x0136: CMSG_CANCEL_AURA,
    0x013B: CMSG_CANCEL_CHANNELLING,
    0x013D: CMSG_SET_SELECTION,
    0x013E: CMSG_DELETEEQUIPMENT_SET,
    0x013F: CMSG_INSTANCE_LOCK_RESPONSE,
    0x0141: CMSG_ATTACKSWING,
    0x0142: CMSG_ATTACKSTOP,
    0x015A: CMSG_REPOP_REQUEST,
    0x015C: CMSG_RESURRECT_RESPONSE,
    0x015D: CMSG_LOOT,
    0x015E: CMSG_LOOT_MONEY,
    0x015F: CMSG_LOOT_RELEASE,
    0x016C: CMSG_DUEL_ACCEPTED,
    0x016D: CMSG_DUEL_CANCELLED,
    0x0171: CMSG_MOUNTSPECIAL_ANIM,
    0x0174: CMSG_PET_SET_ACTION,
    0x0175: CMSG_PET_ACTION,
    0x0176: CMSG_PET_ABANDON,
    0x0177: CMSG_PET_RENAME,
    0x017B: CMSG_GOSSIP_HELLO,
    0x017C: CMSG_GOSSIP_SELECT_OPTION,
    0x017F: CMSG_NPC_TEXT_QUERY,
    0x0182: CMSG_QUESTGIVER_STATUS_QUERY,
    0x0184: CMSG_QUESTGIVER_HELLO,
    0x0186: CMSG_QUESTGIVER_QUERY_QUEST,
    0x0187: CMSG_QUESTGIVER_QUEST_AUTOLAUNCH,
    0x0189: CMSG_QUESTGIVER_ACCEPT_QUEST,
    0x018A: CMSG_QUESTGIVER_COMPLETE_QUEST,
    0x018C: CMSG_QUESTGIVER_REQUEST_REWARD,
    0x018E: CMSG_QUESTGIVER_CHOOSE_REWARD,
    0x0190: CMSG_QUESTGIVER_CANCEL,
    0x0193: CMSG_QUESTLOG_SWAP_QUEST,
    0x0194: CMSG_QUESTLOG_REMOVE_QUEST,
    0x019B: CMSG_QUEST_CONFIRM_ACCEPT,
    0x019D: CMSG_PUSHQUESTTOPARTY,
    0x019E: CMSG_LIST_INVENTORY,
    0x01A0: CMSG_SELL_ITEM,
    0x01A2: CMSG_BUY_ITEM,
    0x01A3: CMSG_BUY_ITEM_IN_SLOT,
    0x01AA: CMSG_TAXINODE_STATUS_QUERY,
    0x01AC: CMSG_TAXIQUERYAVAILABLENODES,
    0x01AD: CMSG_ACTIVATETAXI,
    0x01B0: CMSG_TRAINER_LIST,
    0x01B2: CMSG_TRAINER_BUY_SPELL,
    0x01B5: CMSG_BINDER_ACTIVATE,
    0x01B7: CMSG_BANKER_ACTIVATE,
    0x01B9: CMSG_BUY_BANK_SLOT,
    0x01BB: CMSG_PETITION_SHOWLIST,
    0x01BD: CMSG_PETITION_BUY,
    0x01BE: CMSG_PETITION_SHOW_SIGNATURES,
    0x01C0: CMSG_PETITION_SIGN,
    0x01C2: MSG_PETITION_DECLINE,
    0x01C3: CMSG_OFFER_PETITION,
    0x01C4: CMSG_TURN_IN_PETITION,
    0x01C6: CMSG_PETITION_QUERY,
    0x01CA: CMSG_BUG,
    0x01CC: CMSG_PLAYED_TIME,
    0x01CE: CMSG_QUERY_TIME,
    0x01D2: CMSG_RECLAIM_CORPSE,
    0x01D3: CMSG_WRAP_ITEM,
    0x01D5: MSG_MINIMAP_PING_Client,
    0x01DC: CMSG_PING,
    0x01E0: CMSG_SETSHEATHED,
    0x01E3: CMSG_QUEST_POI_QUERY,
    0x01ED: CMSG_AUTH_SESSION,
    0x01F0: CMSG_PET_CAST_SPELL,
    0x01F1: MSG_SAVE_GUILD_EMBLEM_Client,
    0x01F2: MSG_TABARDVENDOR_ACTIVATE,
    0x01F4: CMSG_ZONEUPDATE,
    0x01FB: MSG_RANDOM_ROLL_Client,
    0x0202: CMSG_UNLEARN_SKILL,
    0x0205: CMSG_GMTICKET_CREATE,
    0x0207: CMSG_GMTICKET_UPDATETEXT,
    0x020A: CMSG_REQUEST_ACCOUNT_DATA,
    0x020B: CMSG_UPDATE_ACCOUNT_DATA,
    0x0211: CMSG_GMTICKET_GETTICKET,
    0x0213: CMSG_UNLEARN_TALENTS,
    0x0216: MSG_CORPSE_QUERY_Client,
    0x0217: CMSG_GMTICKET_DELETETICKET,
    0x021A: CMSG_GMTICKET_SYSTEMSTATUS,
    0x021C: CMSG_SPIRIT_HEALER_ACTIVATE,
    0x0225: CMSG_CHAT_IGNORED,
    0x0231: CMSG_GUILD_RANK,
    0x0232: CMSG_GUILD_ADD_RANK,
    0x0233: CMSG_GUILD_DEL_RANK,
    0x0234: CMSG_GUILD_SET_PUBLIC_NOTE,
    0x0235: CMSG_GUILD_SET_OFFICER_NOTE,
    0x0238: CMSG_SEND_MAIL,
    0x023A: CMSG_GET_MAIL_LIST,
    0x023C: CMSG_BATTLEFIELD_LIST,
    0x0243: CMSG_ITEM_TEXT_QUERY,
    0x0245: CMSG_MAIL_TAKE_MONEY,
    0x0246: CMSG_MAIL_TAKE_ITEM,
    0x0247: CMSG_MAIL_MARK_AS_READ,
    0x0248: CMSG_MAIL_RETURN_TO_SENDER,
    0x0249: CMSG_MAIL_DELETE,
    0x024A: CMSG_MAIL_CREATE_TEXT_ITEM,
    0x0251: CMSG_LEARN_TALENT,
    0x0253: CMSG_TOGGLE_PVP,
    0x0255: MSG_AUCTION_HELLO_Client,
    0x0256: CMSG_AUCTION_SELL_ITEM,
    0x0257: CMSG_AUCTION_REMOVE_ITEM,
    0x0258: CMSG_AUCTION_LIST_ITEMS,
    0x0259: CMSG_AUCTION_LIST_OWNER_ITEMS,
    0x025A: CMSG_AUCTION_PLACE_BID,
    0x0264: CMSG_AUCTION_LIST_BIDDER_ITEMS,
    0x0268: CMSG_SET_AMMO,
    0x026A: CMSG_SET_ACTIVE_MOVER,
    0x026B: CMSG_PET_CANCEL_AURA,
    0x026D: CMSG_CANCEL_AUTO_REPEAT_SPELL,
    0x026F: MSG_LIST_STABLED_PETS_Client,
    0x0270: CMSG_STABLE_PET,
    0x0271: CMSG_UNSTABLE_PET,
    0x0272: CMSG_BUY_STABLE_SLOT,
    0x0275: CMSG_STABLE_SWAP_PET,
    0x0276: MSG_QUEST_PUSH_RESULT,
    0x0279: CMSG_REQUEST_PET_INFO,
    0x027A: CMSG_FAR_SIGHT,
    0x027E: CMSG_GROUP_CHANGE_SUB_GROUP,
    0x027F: CMSG_REQUEST_PARTY_MEMBER_STATS,
    0x0280: CMSG_GROUP_SWAP_SUB_GROUP,
    0x0282: CMSG_AUTOSTORE_BANK_ITEM,
    0x0283: CMSG_AUTOBANK_ITEM,
    0x0284: MSG_QUERY_NEXT_MAIL_TIME_Client,
    0x028E: CMSG_GROUP_RAID_CONVERT,
    0x028F: CMSG_GROUP_ASSISTANT_LEADER,
    0x0290: CMSG_BUYBACK_ITEM,
    0x0292: CMSG_SET_SAVED_INSTANCE_EXTEND,
    0x0296: CMSG_LFG_GET_STATUS,
    0x029A: CMSG_GMTICKETSYSTEM_TOGGLE,
    0x029B: CMSG_CANCEL_GROWTH_AURA,
    0x02A0: CMSG_LOOT_ROLL,
    0x02A3: CMSG_LOOT_MASTER_GIVE,
    0x02A8: CMSG_REPAIR_ITEM,
    0x02AA: MSG_TALENT_WIPE_CONFIRM_Client,
    0x02AC: CMSG_SUMMON_RESPONSE,
    0x02B1: MSG_MOVE_WATER_WALK,
    0x02B3: CMSG_SELF_RES,
    0x02B9: CMSG_TOGGLE_HELM,
    0x02BA: CMSG_TOGGLE_CLOAK,
    0x02BF: CMSG_SET_ACTIONBAR_TOGGLES,
    0x02C1: MSG_PETITION_RENAME,
    0x02C4: CMSG_ITEM_NAME_QUERY,
    0x02C7: CMSG_CHAR_RENAME,
    0x02C9: CMSG_MOVE_SPLINE_DONE,
    0x02CA: CMSG_MOVE_FALL_RESET,
    0x02CD: CMSG_REQUEST_RAID_INFO,
    0x02CE: CMSG_MOVE_TIME_SKIPPED,
    0x02CF: CMSG_MOVE_FEATHER_FALL_ACK,
    0x02D0: CMSG_MOVE_WATER_WALK_ACK,
    0x02D1: CMSG_MOVE_NOT_ACTIVE_MOVER,
    0x02D3: CMSG_BATTLEFIELD_STATUS,
    0x02D5: CMSG_BATTLEFIELD_PORT,
    0x02D6: MSG_INSPECT_HONOR_STATS_Client,
    0x02D7: CMSG_BATTLEMASTER_HELLO,
    0x02DB: CMSG_FORCE_WALK_SPEED_CHANGE_ACK,
    0x02DD: CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK,
    0x02DF: CMSG_FORCE_TURN_RATE_CHANGE_ACK,
    0x02E0: MSG_PVP_LOG_DATA_Client,
    0x02E1: CMSG_LEAVE_BATTLEFIELD,
    0x02E2: CMSG_AREA_SPIRIT_HEALER_QUERY,
    0x02E3: CMSG_AREA_SPIRIT_HEALER_QUEUE,
    0x02E7: CMSG_WARDEN_DATA,
    0x02E9: MSG_BATTLEGROUND_PLAYER_POSITIONS_Client,
    0x02EA: CMSG_PET_STOP_ATTACK,
    0x02EE: CMSG_BATTLEMASTER_JOIN,
    0x02F0: CMSG_PET_UNLEARN,
    0x02F3: CMSG_PET_SPELL_AUTOCAST,
    0x02FC: CMSG_GUILD_INFO_TEXT,
    0x0312: CMSG_ACTIVATETAXIEXPRESS,
    0x0317: CMSG_SET_FACTION_INACTIVE,
    0x0318: CMSG_SET_WATCHED_FACTION,
    0x031D: CMSG_RESET_INSTANCES,
    0x0321: MSG_RAID_TARGET_UPDATE_Client,
    0x0322: MSG_RAID_READY_CHECK_Client,
    0x0329: MSG_SET_DUNGEON_DIFFICULTY_Client,
    0x032A: CMSG_GMSURVEY_SUBMIT,
    0x0340: CMSG_MOVE_SET_CAN_TRANSITION_BETWEEN_SWIM_AND_FLY_ACK,
    0x0345: CMSG_MOVE_SET_CAN_FLY_ACK,
    0x0346: CMSG_MOVE_SET_FLY,
    0x0347: CMSG_SOCKET_GEMS,
    0x034D: CMSG_ARENA_TEAM_ROSTER,
    0x034F: CMSG_ARENA_TEAM_INVITE,
    0x0351: CMSG_ARENA_TEAM_ACCEPT,
    0x0352: CMSG_ARENA_TEAM_DECLINE,
    0x0353: CMSG_ARENA_TEAM_LEAVE,
    0x0354: CMSG_ARENA_TEAM_REMOVE,
    0x0355: CMSG_ARENA_TEAM_DISBAND,
    0x0356: CMSG_ARENA_TEAM_LEADER,
    0x0358: CMSG_BATTLEMASTER_JOIN_ARENA,
    0x0359: MSG_MOVE_START_ASCEND,
    0x035A: MSG_MOVE_STOP_ASCEND,
    0x035C: CMSG_LFG_JOIN,
    0x035D: CMSG_LFG_LEAVE,
    0x035E: CMSG_SEARCH_LFG_JOIN,
    0x035F: CMSG_SEARCH_LFG_LEAVE,
    0x0362: CMSG_LFG_PROPOSAL_RESULT,
    0x0366: CMSG_SET_LFG_COMMENT,
    0x036A: CMSG_LFG_SET_ROLES,
    0x036C: CMSG_LFG_SET_BOOT_VOTE,
    0x036E: CMSG_LFD_PLAYER_LOCK_INFO_REQUEST,
    0x0370: CMSG_LFG_TELEPORT,
    0x0371: CMSG_LFD_PARTY_LOCK_INFO_REQUEST,
    0x0374: CMSG_SET_TITLE,
    0x0375: CMSG_CANCEL_MOUNT_AURA,
    0x0377: MSG_INSPECT_ARENA_TEAMS_Client,
    0x0379: CMSG_CANCEL_TEMP_ENCHANTMENT,
    0x0380: MSG_MOVE_SET_FLIGHT_BACK_SPEED,
    0x0382: CMSG_FORCE_FLIGHT_SPEED_CHANGE_ACK,
    0x0384: CMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE_ACK,
    0x0389: CMSG_SET_TAXI_BENCHMARK_MODE,
    0x038C: CMSG_REALM_SPLIT,
    0x038D: CMSG_MOVE_CHNG_TRANSPORT,
    0x038E: MSG_PARTY_ASSIGNMENT_Client,
    0x0391: CMSG_TIME_SYNC_RESP,
    0x03A7: MSG_MOVE_START_DESCEND,
    0x03AE: MSG_RAID_READY_CHECK_CONFIRM_Client,
    0x03AF: CMSG_VOICE_SESSION_ENABLE,
    0x03B5: CMSG_COMMENTATOR_ENABLE,
    0x03C6: MSG_RAID_READY_CHECK_FINISHED_Client,
    0x03C7: CMSG_COMPLAIN,
    0x03D2: CMSG_CHANNEL_DISPLAY_LIST,
    0x03D3: CMSG_SET_ACTIVE_VOICE_CHANNEL,
    0x03D4: CMSG_GET_CHANNEL_MEMBER_COUNT,
    0x03D6: CMSG_CHANNEL_VOICE_ON,
    0x03E4: CMSG_REPORT_PVP_AFK,
    0x03E6: CMSG_GUILD_BANKER_ACTIVATE,
    0x03E7: CMSG_GUILD_BANK_QUERY_TAB,
    0x03E9: CMSG_GUILD_BANK_SWAP_ITEMS,
    0x03EA: CMSG_GUILD_BANK_BUY_TAB,
    0x03EB: CMSG_GUILD_BANK_UPDATE_TAB,
    0x03EC: CMSG_GUILD_BANK_DEPOSIT_MONEY,
    0x03ED: CMSG_GUILD_BANK_WITHDRAW_MONEY,
    0x03EE: MSG_GUILD_BANK_LOG_QUERY_Client,
    0x03EF: CMSG_SET_CHANNEL_WATCH,
    0x03F3: CMSG_CLEAR_CHANNEL_WATCH,
    0x03F8: CMSG_SPELLCLICK,
    0x03FD: MSG_GUILD_PERMISSIONS_Client,
    0x03FE: MSG_GUILD_BANK_MONEY_WITHDRAWN_Client,
    0x03FF: MSG_GUILD_EVENT_LOG_QUERY_Client,
    0x0401: CMSG_GET_MIRRORIMAGE_DATA,
    0x0407: CMSG_KEEP_ALIVE,
    0x0409: CMSG_OPT_OUT_OF_LOOT,
    0x040A: MSG_QUERY_GUILD_BANK_TEXT_Client,
    0x040B: CMSG_SET_GUILD_BANK_TEXT,
    0x040D: CMSG_GRANT_LEVEL,
    0x0414: CMSG_TOTEM_DESTROYED,
    0x0417: CMSG_QUESTGIVER_STATUS_MULTIPLE_QUERY,
    0x0419: CMSG_SET_PLAYER_DECLINED_NAMES,
    0x0420: CMSG_ACCEPT_LEVEL_GRANT,
    0x0426: CMSG_ALTER_APPEARANCE,
    0x0429: CMSG_CALENDAR_GET_CALENDAR,
    0x042A: CMSG_CALENDAR_GET_EVENT,
    0x042B: CMSG_CALENDAR_GUILD_FILTER,
    0x042C: CMSG_CALENDAR_ARENA_TEAM,
    0x042D: CMSG_CALENDAR_ADD_EVENT,
    0x042E: CMSG_CALENDAR_UPDATE_EVENT,
    0x042F: CMSG_CALENDAR_REMOVE_EVENT,
    0x0430: CMSG_CALENDAR_COPY_EVENT,
    0x0431: CMSG_CALENDAR_EVENT_INVITE,
    0x0432: CMSG_CALENDAR_EVENT_RSVP,
    0x0433: CMSG_CALENDAR_EVENT_REMOVE_INVITE,
    0x0434: CMSG_CALENDAR_EVENT_STATUS,
    0x0435: CMSG_CALENDAR_EVENT_MODERATOR_STATUS,
    0x0446: CMSG_CALENDAR_COMPLAIN,
    0x0447: CMSG_CALENDAR_GET_NUM_PENDING,
    0x0462: CMSG_UPDATE_MISSILE_TRAJECTORY,
    0x0465: CMSG_COMPLETE_MOVIE,
    0x046B: CMSG_QUERY_INSPECT_ACHIEVEMENTS,
    0x046D: CMSG_DISMISS_CONTROLLED_VEHICLE,
    0x0473: CMSG_CHAR_CUSTOMIZE,
    0x0476: CMSG_REQUEST_VEHICLE_EXIT,
    0x0477: CMSG_REQUEST_VEHICLE_PREV_SEAT,
    0x0478: CMSG_REQUEST_VEHICLE_NEXT_SEAT,
    0x0479: CMSG_REQUEST_VEHICLE_SWITCH_SEAT,
    0x047A: CMSG_PET_LEARN_TALENT,
    0x0481: CMSG_GAMEOBJ_REPORT_USE,
    0x048A: CMSG_REMOVE_GLYPH,
    0x048D: CMSG_DISMISS_CRITTER,
    0x048F: CMSG_AUCTION_LIST_PENDING_SALES,
    0x0493: CMSG_ENABLETAXI,
    0x049B: CMSG_CHANGE_SEATS_ON_CONTROLLED_VEHICLE,
    0x049C: CMSG_HEARTH_AND_RESURRECT,
    0x04A8: CMSG_PLAYER_VEHICLE_ENTER,
    0x04A9: CMSG_CONTROLLER_EJECT_PASSENGER,
    0x04B3: CMSG_ITEM_REFUND_INFO,
    0x04B4: CMSG_ITEM_REFUND,
    0x04B6: CMSG_CORPSE_MAP_POSITION_QUERY,
    0x04BA: CMSG_CALENDAR_EVENT_SIGNUP,
    0x04BD: CMSG_EQUIPMENT_SET_SAVE,
    0x04BE: CMSG_UPDATE_PROJECTILE_POSITION,
    0x04C1: CMSG_LEARN_PREVIEW_TALENTS,
    0x04C2: CMSG_LEARN_PREVIEW_TALENTS_PET,
    0x04CF: CMSG_MOVE_GRAVITY_DISABLE_ACK,
    0x04D1: CMSG_MOVE_GRAVITY_ENABLE_ACK,
    0x04D5: CMSG_EQUIPMENT_SET_USE,
    0x04D9: CMSG_CHAR_FACTION_CHANGE,
    0x04DF: CMSG_BATTLEFIELD_MGR_ENTRY_INVITE_RESPONSE,
    0x04E2: CMSG_BATTLEFIELD_MGR_QUEUE_INVITE_RESPONSE,
    0x04E7: CMSG_BATTLEFIELD_MGR_EXIT_REQUEST,
    0x04EB: MSG_SET_RAID_DIFFICULTY_Client,
    0x04F0: CMSG_GMRESPONSE_RESOLVE,
    0x04F6: CMSG_WORLD_STATE_UI_TIMER_UPDATE,
    0x04F8: CMSG_CHAR_RACE_CHANGE,
    0x04FF: CMSG_READY_FOR_ACCOUNT_DATA_TIMES,
    0x0500: CMSG_QUERY_QUESTS_COMPLETED,
    0x0502: CMSG_GM_REPORT_LAG,
    0x0517: CMSG_MOVE_SET_COLLISION_HGT_ACK,
}


async def read_client_opcode_body(
    reader: asyncio.StreamReader,
    opcode: int,
    body_size: int,
) -> ClientOpcode:
    return await client_opcodes[opcode].read(reader, body_size)


server_opcodes: dict[int, ServerOpcode] = {
    0x003A: SMSG_CHAR_CREATE,
    0x003B: SMSG_CHAR_ENUM,
    0x003C: SMSG_CHAR_DELETE,
    0x003E: SMSG_NEW_WORLD,
    0x003F: SMSG_TRANSFER_PENDING,
    0x0040: SMSG_TRANSFER_ABORTED,
    0x0041: SMSG_CHARACTER_LOGIN_FAILED,
    0x0042: SMSG_LOGIN_SETTIMESPEED,
    0x004C: SMSG_LOGOUT_RESPONSE,
    0x004D: SMSG_LOGOUT_COMPLETE,
    0x004F: SMSG_LOGOUT_CANCEL_ACK,
    0x0051: SMSG_NAME_QUERY_RESPONSE,
    0x0053: SMSG_PET_NAME_QUERY_RESPONSE,
    0x0055: SMSG_GUILD_QUERY_RESPONSE,
    0x0058: SMSG_ITEM_QUERY_SINGLE_RESPONSE,
    0x005B: SMSG_PAGE_TEXT_QUERY_RESPONSE,
    0x005D: SMSG_QUEST_QUERY_RESPONSE,
    0x005F: SMSG_GAMEOBJECT_QUERY_RESPONSE,
    0x0061: SMSG_CREATURE_QUERY_RESPONSE,
    0x0063: SMSG_WHO,
    0x0065: SMSG_WHOIS,
    0x0067: SMSG_CONTACT_LIST,
    0x0068: SMSG_FRIEND_STATUS,
    0x006F: SMSG_GROUP_INVITE,
    0x0074: SMSG_GROUP_DECLINE,
    0x0077: SMSG_GROUP_UNINVITE,
    0x0079: SMSG_GROUP_SET_LEADER,
    0x007C: SMSG_GROUP_DESTROYED,
    0x007D: SMSG_GROUP_LIST,
    0x007E: SMSG_PARTY_MEMBER_STATS,
    0x007F: SMSG_PARTY_COMMAND_RESULT,
    0x0083: SMSG_GUILD_INVITE,
    0x0086: SMSG_GUILD_DECLINE,
    0x0088: SMSG_GUILD_INFO,
    0x008A: SMSG_GUILD_ROSTER,
    0x0092: SMSG_GUILD_EVENT,
    0x0093: SMSG_GUILD_COMMAND_RESULT,
    0x0096: SMSG_MESSAGECHAT,
    0x0099: SMSG_CHANNEL_NOTIFY,
    0x009B: SMSG_CHANNEL_LIST,
    0x00A9: SMSG_UPDATE_OBJECT,
    0x00AA: SMSG_DESTROY_OBJECT,
    0x00AE: SMSG_READ_ITEM_OK,
    0x00AF: SMSG_READ_ITEM_FAILED,
    0x00B0: SMSG_ITEM_COOLDOWN,
    0x00B3: SMSG_GAMEOBJECT_CUSTOM_ANIM,
    0x00B5: MSG_MOVE_START_FORWARD,
    0x00B6: MSG_MOVE_START_BACKWARD,
    0x00B7: MSG_MOVE_STOP,
    0x00B8: MSG_MOVE_START_STRAFE_LEFT,
    0x00B9: MSG_MOVE_START_STRAFE_RIGHT,
    0x00BA: MSG_MOVE_STOP_STRAFE,
    0x00BB: MSG_MOVE_JUMP,
    0x00BC: MSG_MOVE_START_TURN_LEFT,
    0x00BD: MSG_MOVE_START_TURN_RIGHT,
    0x00BE: MSG_MOVE_STOP_TURN,
    0x00BF: MSG_MOVE_START_PITCH_UP,
    0x00C0: MSG_MOVE_START_PITCH_DOWN,
    0x00C1: MSG_MOVE_STOP_PITCH,
    0x00C2: MSG_MOVE_SET_RUN_MODE,
    0x00C3: MSG_MOVE_SET_WALK_MODE,
    0x00C6: MSG_MOVE_TELEPORT_CHEAT_Server,
    0x00C7: MSG_MOVE_TELEPORT_ACK_Server,
    0x00C9: MSG_MOVE_FALL_LAND,
    0x00CA: MSG_MOVE_START_SWIM,
    0x00CB: MSG_MOVE_STOP_SWIM,
    0x00DA: MSG_MOVE_SET_FACING,
    0x00DB: MSG_MOVE_SET_PITCH,
    0x00DC: MSG_MOVE_WORLDPORT_ACK,
    0x00DD: SMSG_MONSTER_MOVE,
    0x00DE: SMSG_MOVE_WATER_WALK,
    0x00DF: SMSG_MOVE_LAND_WALK,
    0x00E2: SMSG_FORCE_RUN_SPEED_CHANGE,
    0x00E4: SMSG_FORCE_RUN_BACK_SPEED_CHANGE,
    0x00E6: SMSG_FORCE_SWIM_SPEED_CHANGE,
    0x00E8: SMSG_FORCE_MOVE_ROOT,
    0x00EA: SMSG_FORCE_MOVE_UNROOT,
    0x00EC: MSG_MOVE_ROOT_Server,
    0x00ED: MSG_MOVE_UNROOT_Server,
    0x00EE: MSG_MOVE_HEARTBEAT,
    0x00EF: SMSG_MOVE_KNOCK_BACK,
    0x00F1: MSG_MOVE_KNOCK_BACK_Server,
    0x00F2: SMSG_MOVE_FEATHER_FALL,
    0x00F3: SMSG_MOVE_NORMAL_FALL,
    0x00F4: SMSG_MOVE_SET_HOVER,
    0x00F5: SMSG_MOVE_UNSET_HOVER,
    0x00F7: MSG_MOVE_HOVER,
    0x00FA: SMSG_TRIGGER_CINEMATIC,
    0x00FD: SMSG_TUTORIAL_FLAGS,
    0x0103: SMSG_EMOTE,
    0x0105: SMSG_TEXT_EMOTE,
    0x0112: SMSG_INVENTORY_CHANGE_FAILURE,
    0x0120: SMSG_TRADE_STATUS,
    0x0121: SMSG_TRADE_STATUS_EXTENDED,
    0x0122: SMSG_INITIALIZE_FACTIONS,
    0x0123: SMSG_SET_FACTION_VISIBLE,
    0x0124: SMSG_SET_FACTION_STANDING,
    0x0127: SMSG_SET_PROFICIENCY,
    0x0129: SMSG_ACTION_BUTTONS,
    0x012A: SMSG_INITIAL_SPELLS,
    0x012B: SMSG_LEARNED_SPELL,
    0x012C: SMSG_SUPERCEDED_SPELL,
    0x0130: SMSG_CAST_FAILED,
    0x0131: SMSG_SPELL_START,
    0x0132: SMSG_SPELL_GO,
    0x0133: SMSG_SPELL_FAILURE,
    0x0134: SMSG_SPELL_COOLDOWN,
    0x0135: SMSG_COOLDOWN_EVENT,
    0x0138: SMSG_PET_CAST_FAILED,
    0x0139: MSG_CHANNEL_START_Server,
    0x013A: MSG_CHANNEL_UPDATE_Server,
    0x013C: SMSG_AI_REACTION,
    0x0143: SMSG_ATTACKSTART,
    0x0144: SMSG_ATTACKSTOP,
    0x0145: SMSG_ATTACKSWING_NOTINRANGE,
    0x0146: SMSG_ATTACKSWING_BADFACING,
    0x0147: SMSG_INSTANCE_LOCK_WARNING_QUERY,
    0x0148: SMSG_ATTACKSWING_DEADTARGET,
    0x0149: SMSG_ATTACKSWING_CANT_ATTACK,
    0x014A: SMSG_ATTACKERSTATEUPDATE,
    0x014E: SMSG_CANCEL_COMBAT,
    0x0150: SMSG_SPELLHEALLOG,
    0x0151: SMSG_SPELLENERGIZELOG,
    0x0152: SMSG_BREAK_TARGET,
    0x0155: SMSG_BINDPOINTUPDATE,
    0x0158: SMSG_PLAYERBOUND,
    0x0159: SMSG_CLIENT_CONTROL_UPDATE,
    0x015B: SMSG_RESURRECT_REQUEST,
    0x0160: SMSG_LOOT_RESPONSE,
    0x0161: SMSG_LOOT_RELEASE_RESPONSE,
    0x0162: SMSG_LOOT_REMOVED,
    0x0163: SMSG_LOOT_MONEY_NOTIFY,
    0x0165: SMSG_LOOT_CLEAR_MONEY,
    0x0166: SMSG_ITEM_PUSH_RESULT,
    0x0167: SMSG_DUEL_REQUESTED,
    0x0168: SMSG_DUEL_OUTOFBOUNDS,
    0x0169: SMSG_DUEL_INBOUNDS,
    0x016A: SMSG_DUEL_COMPLETE,
    0x016B: SMSG_DUEL_WINNER,
    0x016E: SMSG_MOUNTRESULT,
    0x0172: SMSG_MOUNTSPECIAL_ANIM,
    0x0173: SMSG_PET_TAME_FAILURE,
    0x0178: SMSG_PET_NAME_INVALID,
    0x0179: SMSG_PET_SPELLS,
    0x017A: SMSG_PET_MODE,
    0x017D: SMSG_GOSSIP_MESSAGE,
    0x017E: SMSG_GOSSIP_COMPLETE,
    0x0180: SMSG_NPC_TEXT_UPDATE,
    0x0183: SMSG_QUESTGIVER_STATUS,
    0x0185: SMSG_QUESTGIVER_QUEST_LIST,
    0x0188: SMSG_QUESTGIVER_QUEST_DETAILS,
    0x018B: SMSG_QUESTGIVER_REQUEST_ITEMS,
    0x018D: SMSG_QUESTGIVER_OFFER_REWARD,
    0x018F: SMSG_QUESTGIVER_QUEST_INVALID,
    0x0191: SMSG_QUESTGIVER_QUEST_COMPLETE,
    0x0192: SMSG_QUESTGIVER_QUEST_FAILED,
    0x0195: SMSG_QUESTLOG_FULL,
    0x0196: SMSG_QUESTUPDATE_FAILED,
    0x0197: SMSG_QUESTUPDATE_FAILEDTIMER,
    0x0198: SMSG_QUESTUPDATE_COMPLETE,
    0x0199: SMSG_QUESTUPDATE_ADD_KILL,
    0x019A: SMSG_QUESTUPDATE_ADD_ITEM,
    0x019C: SMSG_QUEST_CONFIRM_ACCEPT,
    0x019F: SMSG_LIST_INVENTORY,
    0x01A1: SMSG_SELL_ITEM,
    0x01A4: SMSG_BUY_ITEM,
    0x01A5: SMSG_BUY_FAILED,
    0x01A9: SMSG_SHOWTAXINODES,
    0x01AB: SMSG_TAXINODE_STATUS,
    0x01AE: SMSG_ACTIVATETAXIREPLY,
    0x01AF: SMSG_NEW_TAXI_PATH,
    0x01B1: SMSG_TRAINER_LIST,
    0x01B3: SMSG_TRAINER_BUY_SUCCEEDED,
    0x01B4: SMSG_TRAINER_BUY_FAILED,
    0x01B8: SMSG_SHOW_BANK,
    0x01BA: SMSG_BUY_BANK_SLOT_RESULT,
    0x01BC: SMSG_PETITION_SHOWLIST,
    0x01BF: SMSG_PETITION_SHOW_SIGNATURES,
    0x01C1: SMSG_PETITION_SIGN_RESULTS,
    0x01C2: MSG_PETITION_DECLINE,
    0x01C5: SMSG_TURN_IN_PETITION_RESULTS,
    0x01C7: SMSG_PETITION_QUERY_RESPONSE,
    0x01C8: SMSG_FISH_NOT_HOOKED,
    0x01C9: SMSG_FISH_ESCAPED,
    0x01CB: SMSG_NOTIFICATION,
    0x01CD: SMSG_PLAYED_TIME,
    0x01CF: SMSG_QUERY_TIME_RESPONSE,
    0x01D0: SMSG_LOG_XPGAIN,
    0x01D4: SMSG_LEVELUP_INFO,
    0x01D5: MSG_MINIMAP_PING_Server,
    0x01D7: SMSG_ENCHANTMENTLOG,
    0x01D9: SMSG_START_MIRROR_TIMER,
    0x01DA: SMSG_PAUSE_MIRROR_TIMER,
    0x01DB: SMSG_STOP_MIRROR_TIMER,
    0x01DD: SMSG_PONG,
    0x01DE: SMSG_CLEAR_COOLDOWN,
    0x01DF: SMSG_GAMEOBJECT_PAGETEXT,
    0x01E2: SMSG_SPELL_DELAYED,
    0x01E4: SMSG_QUEST_POI_QUERY_RESPONSE,
    0x01EA: SMSG_ITEM_TIME_UPDATE,
    0x01EB: SMSG_ITEM_ENCHANT_TIME_UPDATE,
    0x01EC: SMSG_AUTH_CHALLENGE,
    0x01EE: SMSG_AUTH_RESPONSE,
    0x01F1: MSG_SAVE_GUILD_EMBLEM_Server,
    0x01F2: MSG_TABARDVENDOR_ACTIVATE,
    0x01F3: SMSG_PLAY_SPELL_VISUAL,
    0x01F5: SMSG_PARTYKILLLOG,
    0x01F6: SMSG_COMPRESSED_UPDATE_OBJECT,
    0x01F7: SMSG_PLAY_SPELL_IMPACT,
    0x01F8: SMSG_EXPLORATION_EXPERIENCE,
    0x01FB: MSG_RANDOM_ROLL_Server,
    0x01FC: SMSG_ENVIRONMENTAL_DAMAGE_LOG,
    0x01FF: SMSG_LFG_PLAYER_REWARD,
    0x0200: SMSG_LFG_TELEPORT_DENIED,
    0x0203: SMSG_REMOVED_SPELL,
    0x0206: SMSG_GMTICKET_CREATE,
    0x0208: SMSG_GMTICKET_UPDATETEXT,
    0x0209: SMSG_ACCOUNT_DATA_TIMES,
    0x020C: SMSG_UPDATE_ACCOUNT_DATA,
    0x0212: SMSG_GMTICKET_GETTICKET,
    0x0214: SMSG_UPDATE_INSTANCE_ENCOUNTER_UNIT,
    0x0215: SMSG_GAMEOBJECT_DESPAWN_ANIM,
    0x0216: MSG_CORPSE_QUERY_Server,
    0x0218: SMSG_GMTICKET_DELETETICKET,
    0x0219: SMSG_CHAT_WRONG_FACTION,
    0x021B: SMSG_GMTICKET_SYSTEMSTATUS,
    0x021E: SMSG_QUEST_FORCE_REMOVE,
    0x0222: SMSG_SPIRIT_HEALER_CONFIRM,
    0x0224: SMSG_GOSSIP_POI,
    0x0236: SMSG_LOGIN_VERIFY_WORLD,
    0x0239: SMSG_SEND_MAIL_RESULT,
    0x023B: SMSG_MAIL_LIST_RESULT,
    0x023D: SMSG_BATTLEFIELD_LIST,
    0x0244: SMSG_ITEM_TEXT_QUERY_RESPONSE,
    0x024B: SMSG_SPELLLOGMISS,
    0x024C: SMSG_SPELLLOGEXECUTE,
    0x024E: SMSG_PERIODICAURALOG,
    0x024F: SMSG_SPELLDAMAGESHIELD,
    0x0250: SMSG_SPELLNONMELEEDAMAGELOG,
    0x0252: SMSG_RESURRECT_FAILED,
    0x0254: SMSG_ZONE_UNDER_ATTACK,
    0x0255: MSG_AUCTION_HELLO_Server,
    0x025B: SMSG_AUCTION_COMMAND_RESULT,
    0x025C: SMSG_AUCTION_LIST_RESULT,
    0x025D: SMSG_AUCTION_OWNER_LIST_RESULT,
    0x025E: SMSG_AUCTION_BIDDER_NOTIFICATION,
    0x025F: SMSG_AUCTION_OWNER_NOTIFICATION,
    0x0260: SMSG_PROCRESIST,
    0x0262: SMSG_DISPEL_FAILED,
    0x0263: SMSG_SPELLORDAMAGE_IMMUNE,
    0x0265: SMSG_AUCTION_BIDDER_LIST_RESULT,
    0x0266: SMSG_SET_FLAT_SPELL_MODIFIER,
    0x0267: SMSG_SET_PCT_SPELL_MODIFIER,
    0x0269: SMSG_CORPSE_RECLAIM_DELAY,
    0x026F: MSG_LIST_STABLED_PETS_Server,
    0x0273: SMSG_STABLE_RESULT,
    0x0276: MSG_QUEST_PUSH_RESULT,
    0x0277: SMSG_PLAY_MUSIC,
    0x0278: SMSG_PLAY_OBJECT_SOUND,
    0x027B: SMSG_SPELLDISPELLOG,
    0x0284: MSG_QUERY_NEXT_MAIL_TIME_Server,
    0x0285: SMSG_RECEIVED_MAIL,
    0x0286: SMSG_RAID_GROUP_ONLY,
    0x028C: SMSG_PVP_CREDIT,
    0x028D: SMSG_AUCTION_REMOVED_NOTIFICATION,
    0x0291: SMSG_SERVER_MESSAGE,
    0x0293: SMSG_LFG_OFFER_CONTINUE,
    0x0297: SMSG_SHOW_MAILBOX,
    0x029C: SMSG_CANCEL_AUTO_REPEAT,
    0x029D: SMSG_STANDSTATE_UPDATE,
    0x029E: SMSG_LOOT_ALL_PASSED,
    0x029F: SMSG_LOOT_ROLL_WON,
    0x02A1: SMSG_LOOT_START_ROLL,
    0x02A2: SMSG_LOOT_ROLL,
    0x02A4: SMSG_LOOT_MASTER_LIST,
    0x02A5: SMSG_SET_FORCED_REACTIONS,
    0x02A6: SMSG_SPELL_FAILED_OTHER,
    0x02A9: SMSG_CHAT_PLAYER_NOT_FOUND,
    0x02AA: MSG_TALENT_WIPE_CONFIRM_Server,
    0x02AB: SMSG_SUMMON_REQUEST,
    0x02AE: SMSG_MONSTER_MOVE_TRANSPORT,
    0x02AF: SMSG_PET_BROKEN,
    0x02B0: MSG_MOVE_FEATHER_FALL_Server,
    0x02B1: MSG_MOVE_WATER_WALK,
    0x02B4: SMSG_FEIGN_DEATH_RESISTED,
    0x02B7: SMSG_DUEL_COUNTDOWN,
    0x02B8: SMSG_AREA_TRIGGER_MESSAGE,
    0x02BB: SMSG_LFG_ROLE_CHOSEN,
    0x02BC: SMSG_PLAYER_SKINNED,
    0x02BD: SMSG_DURABILITY_DAMAGE_DEATH,
    0x02C1: MSG_PETITION_RENAME,
    0x02C2: SMSG_INIT_WORLD_STATES,
    0x02C3: SMSG_UPDATE_WORLD_STATE,
    0x02C5: SMSG_ITEM_NAME_QUERY_RESPONSE,
    0x02C6: SMSG_PET_ACTION_FEEDBACK,
    0x02C8: SMSG_CHAR_RENAME,
    0x02CB: SMSG_INSTANCE_SAVE_CREATED,
    0x02CC: SMSG_RAID_INSTANCE_INFO,
    0x02D2: SMSG_PLAY_SOUND,
    0x02D4: SMSG_BATTLEFIELD_STATUS,
    0x02D6: MSG_INSPECT_HONOR_STATS_Server,
    0x02DA: SMSG_FORCE_WALK_SPEED_CHANGE,
    0x02DC: SMSG_FORCE_SWIM_BACK_SPEED_CHANGE,
    0x02DE: SMSG_FORCE_TURN_RATE_CHANGE,
    0x02E4: SMSG_AREA_SPIRIT_HEALER_TIME,
    0x02E6: SMSG_WARDEN_DATA,
    0x02E8: SMSG_GROUP_JOINED_BATTLEGROUND,
    0x02E9: MSG_BATTLEGROUND_PLAYER_POSITIONS_Server,
    0x02EB: SMSG_BINDER_CONFIRM,
    0x02EC: SMSG_BATTLEGROUND_PLAYER_JOINED,
    0x02ED: SMSG_BATTLEGROUND_PLAYER_LEFT,
    0x02EF: SMSG_ADDON_INFO,
    0x02F1: SMSG_PET_UNLEARN_CONFIRM,
    0x02F2: SMSG_PARTY_MEMBER_STATS_FULL,
    0x02F4: SMSG_WEATHER,
    0x02FA: SMSG_RAID_INSTANCE_MESSAGE,
    0x02FB: SMSG_COMPRESSED_MOVES,
    0x02FD: SMSG_CHAT_RESTRICTED,
    0x02FE: SMSG_SPLINE_SET_RUN_SPEED,
    0x02FF: SMSG_SPLINE_SET_RUN_BACK_SPEED,
    0x0300: SMSG_SPLINE_SET_SWIM_SPEED,
    0x0301: SMSG_SPLINE_SET_WALK_SPEED,
    0x0302: SMSG_SPLINE_SET_SWIM_BACK_SPEED,
    0x0303: SMSG_SPLINE_SET_TURN_RATE,
    0x0304: SMSG_SPLINE_MOVE_UNROOT,
    0x0305: SMSG_SPLINE_MOVE_FEATHER_FALL,
    0x0306: SMSG_SPLINE_MOVE_NORMAL_FALL,
    0x0307: SMSG_SPLINE_MOVE_SET_HOVER,
    0x0308: SMSG_SPLINE_MOVE_UNSET_HOVER,
    0x0309: SMSG_SPLINE_MOVE_WATER_WALK,
    0x030A: SMSG_SPLINE_MOVE_LAND_WALK,
    0x030B: SMSG_SPLINE_MOVE_START_SWIM,
    0x030C: SMSG_SPLINE_MOVE_STOP_SWIM,
    0x030D: SMSG_SPLINE_MOVE_SET_RUN_MODE,
    0x030E: SMSG_SPLINE_MOVE_SET_WALK_MODE,
    0x0319: MSG_MOVE_TIME_SKIPPED_Server,
    0x031A: SMSG_SPLINE_MOVE_ROOT,
    0x031C: SMSG_INVALIDATE_PLAYER,
    0x031E: SMSG_INSTANCE_RESET,
    0x031F: SMSG_INSTANCE_RESET_FAILED,
    0x0320: SMSG_UPDATE_LAST_INSTANCE,
    0x0321: MSG_RAID_TARGET_UPDATE_Server,
    0x0322: MSG_RAID_READY_CHECK_Server,
    0x0324: SMSG_PET_ACTION_SOUND,
    0x0325: SMSG_PET_DISMISS_SOUND,
    0x0328: SMSG_GM_TICKET_STATUS_UPDATE,
    0x0329: MSG_SET_DUNGEON_DIFFICULTY_Server,
    0x032B: SMSG_UPDATE_INSTANCE_OWNERSHIP,
    0x032D: SMSG_CHAT_PLAYER_AMBIGUOUS,
    0x032F: SMSG_SPELLINSTAKILLLOG,
    0x0330: SMSG_SPELL_UPDATE_CHAIN_TARGETS,
    0x0333: SMSG_SPELLSTEALLOG,
    0x033A: SMSG_DEFENSE_MESSAGE,
    0x033B: SMSG_INSTANCE_DIFFICULTY,
    0x033D: SMSG_MOTD,
    0x0343: SMSG_MOVE_SET_CAN_FLY,
    0x0344: SMSG_MOVE_UNSET_CAN_FLY,
    0x0349: SMSG_ARENA_TEAM_COMMAND_RESULT,
    0x034C: SMSG_ARENA_TEAM_QUERY_RESPONSE,
    0x034E: SMSG_ARENA_TEAM_ROSTER,
    0x0350: SMSG_ARENA_TEAM_INVITE,
    0x0357: SMSG_ARENA_TEAM_EVENT,
    0x0359: MSG_MOVE_START_ASCEND,
    0x035A: MSG_MOVE_STOP_ASCEND,
    0x035B: SMSG_ARENA_TEAM_STATS,
    0x0360: SMSG_UPDATE_LFG_LIST,
    0x0361: SMSG_LFG_PROPOSAL_UPDATE,
    0x0363: SMSG_LFG_ROLE_CHECK_UPDATE,
    0x0364: SMSG_LFG_JOIN_RESULT,
    0x0365: SMSG_LFG_QUEUE_STATUS,
    0x0367: SMSG_LFG_UPDATE_PLAYER,
    0x0368: SMSG_LFG_UPDATE_PARTY,
    0x0369: SMSG_LFG_UPDATE_SEARCH,
    0x036D: SMSG_LFG_BOOT_PROPOSAL_UPDATE,
    0x036F: SMSG_LFG_PLAYER_INFO,
    0x0372: SMSG_LFG_PARTY_INFO,
    0x0373: SMSG_TITLE_EARNED,
    0x0376: SMSG_ARENA_ERROR,
    0x0377: MSG_INSPECT_ARENA_TEAMS_Server,
    0x0378: SMSG_DEATH_RELEASE_LOC,
    0x037A: SMSG_FORCED_DEATH_UPDATE,
    0x037E: MSG_MOVE_SET_FLIGHT_SPEED_Server,
    0x0380: MSG_MOVE_SET_FLIGHT_BACK_SPEED,
    0x0381: SMSG_FORCE_FLIGHT_SPEED_CHANGE,
    0x0383: SMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE,
    0x0385: SMSG_SPLINE_SET_FLIGHT_SPEED,
    0x0386: SMSG_SPLINE_SET_FLIGHT_BACK_SPEED,
    0x0388: SMSG_FLIGHT_SPLINE_SYNC,
    0x038B: SMSG_REALM_SPLIT,
    0x0390: SMSG_TIME_SYNC_REQ,
    0x0396: SMSG_RESET_FAILED_NOTIFY,
    0x0398: SMSG_LFG_DISABLED,
    0x039D: SMSG_UPDATE_COMBO_POINTS,
    0x03A7: MSG_MOVE_START_DESCEND,
    0x03AC: SMSG_DISMOUNT,
    0x03AD: MSG_MOVE_UPDATE_CAN_FLY_Server,
    0x03AE: MSG_RAID_READY_CHECK_CONFIRM_Server,
    0x03B3: SMSG_GM_MESSAGECHAT,
    0x03BF: SMSG_CLEAR_TARGET,
    0x03C1: SMSG_CROSSED_INEBRIATION_THRESHOLD,
    0x03C5: SMSG_KICK_REASON,
    0x03C8: SMSG_COMPLAIN_RESULT,
    0x03C9: SMSG_FEATURE_SYSTEM_STATUS,
    0x03D5: SMSG_CHANNEL_MEMBER_COUNT,
    0x03E8: SMSG_GUILD_BANK_LIST,
    0x03EE: MSG_GUILD_BANK_LOG_QUERY_Server,
    0x03F0: SMSG_USERLIST_ADD,
    0x03F1: SMSG_USERLIST_REMOVE,
    0x03F2: SMSG_USERLIST_UPDATE,
    0x03F4: SMSG_INSPECT_TALENT,
    0x03F9: SMSG_LOOT_LIST,
    0x03FD: MSG_GUILD_PERMISSIONS_Server,
    0x03FE: MSG_GUILD_BANK_MONEY_WITHDRAWN_Server,
    0x03FF: MSG_GUILD_EVENT_LOG_QUERY_Server,
    0x0402: SMSG_MIRRORIMAGE_DATA,
    0x040A: MSG_QUERY_GUILD_BANK_TEXT_Server,
    0x0412: SMSG_OVERRIDE_LIGHT,
    0x0413: SMSG_TOTEM_CREATED,
    0x0418: SMSG_QUESTGIVER_STATUS_MULTIPLE,
    0x041A: SMSG_SET_PLAYER_DECLINED_NAMES_RESULT,
    0x041E: SMSG_SEND_UNLEARN_SPELLS,
    0x041F: SMSG_PROPOSE_LEVEL_GRANT,
    0x0421: SMSG_REFER_A_FRIEND_FAILURE,
    0x0422: SMSG_SPLINE_MOVE_SET_FLYING,
    0x0423: SMSG_SPLINE_MOVE_UNSET_FLYING,
    0x0427: SMSG_ENABLE_BARBER_SHOP,
    0x0428: SMSG_BARBER_SHOP_RESULT,
    0x0436: SMSG_CALENDAR_SEND_CALENDAR,
    0x0437: SMSG_CALENDAR_SEND_EVENT,
    0x0438: SMSG_CALENDAR_FILTER_GUILD,
    0x0439: SMSG_CALENDAR_ARENA_TEAM,
    0x043A: SMSG_CALENDAR_EVENT_INVITE,
    0x043B: SMSG_CALENDAR_EVENT_INVITE_REMOVED,
    0x043C: SMSG_CALENDAR_EVENT_STATUS,
    0x043D: SMSG_CALENDAR_COMMAND_RESULT,
    0x043E: SMSG_CALENDAR_RAID_LOCKOUT_ADDED,
    0x043F: SMSG_CALENDAR_RAID_LOCKOUT_REMOVED,
    0x0440: SMSG_CALENDAR_EVENT_INVITE_ALERT,
    0x0441: SMSG_CALENDAR_EVENT_INVITE_REMOVED_ALERT,
    0x0443: SMSG_CALENDAR_EVENT_REMOVED_ALERT,
    0x0444: SMSG_CALENDAR_EVENT_UPDATED_ALERT,
    0x0445: SMSG_CALENDAR_EVENT_MODERATOR_STATUS_ALERT,
    0x0447: CMSG_CALENDAR_GET_NUM_PENDING,
    0x0448: SMSG_CALENDAR_SEND_NUM_PENDING,
    0x045B: MSG_MOVE_SET_PITCH_RATE_Server,
    0x045C: SMSG_FORCE_PITCH_RATE_CHANGE,
    0x0460: SMSG_CALENDAR_EVENT_INVITE_NOTES,
    0x0461: SMSG_CALENDAR_EVENT_INVITE_NOTES_ALERT,
    0x0463: SMSG_UPDATE_ACCOUNT_DATA_COMPLETE,
    0x0464: SMSG_TRIGGER_MOVIE,
    0x0468: SMSG_ACHIEVEMENT_EARNED,
    0x046A: SMSG_CRITERIA_UPDATE,
    0x046C: SMSG_RESPOND_INSPECT_ACHIEVEMENTS,
    0x046F: SMSG_QUESTUPDATE_ADD_PVP_KILL,
    0x0471: SMSG_CALENDAR_RAID_LOCKOUT_UPDATED,
    0x0474: SMSG_CHAR_CUSTOMIZE,
    0x047C: SMSG_SET_PHASE_SHIFT,
    0x047D: SMSG_ALL_ACHIEVEMENT_DATA,
    0x0480: SMSG_POWER_UPDATE,
    0x0482: SMSG_HIGHEST_THREAT_UPDATE,
    0x0483: SMSG_THREAT_UPDATE,
    0x0484: SMSG_THREAT_REMOVE,
    0x0485: SMSG_THREAT_CLEAR,
    0x0486: SMSG_CONVERT_RUNE,
    0x0487: SMSG_RESYNC_RUNES,
    0x0488: SMSG_ADD_RUNE_POWER,
    0x0490: SMSG_AUCTION_LIST_PENDING_SALES,
    0x0491: SMSG_MODIFY_COOLDOWN,
    0x0492: SMSG_PET_UPDATE_COMBO_POINTS,
    0x0494: SMSG_PRE_RESURRECT,
    0x0495: SMSG_AURA_UPDATE_ALL,
    0x0496: SMSG_AURA_UPDATE,
    0x0498: SMSG_SERVER_FIRST_ACHIEVEMENT,
    0x0499: SMSG_PET_LEARNED_SPELL,
    0x049A: SMSG_PET_UNLEARNED_SPELL,
    0x049D: SMSG_ON_CANCEL_EXPECTED_RIDE_VEHICLE_AURA,
    0x049E: SMSG_CRITERIA_DELETED,
    0x049F: SMSG_ACHIEVEMENT_DELETED,
    0x04A6: SMSG_BATTLEGROUND_INFO_THROTTLED,
    0x04A7: SMSG_PLAYER_VEHICLE_DATA,
    0x04AA: SMSG_PET_GUIDS,
    0x04AB: SMSG_CLIENTCACHE_VERSION,
    0x04B2: SMSG_ITEM_REFUND_INFO_RESPONSE,
    0x04B5: SMSG_ITEM_REFUND_RESULT,
    0x04B7: SMSG_CORPSE_MAP_POSITION_QUERY_RESPONSE,
    0x04BB: SMSG_CALENDAR_CLEAR_PENDING_ACTION,
    0x04BC: SMSG_EQUIPMENT_SET_LIST,
    0x04BF: SMSG_SET_PROJECTILE_POSITION,
    0x04C0: SMSG_TALENTS_INFO,
    0x04C7: SMSG_ARENA_UNIT_DESTROYED,
    0x04C8: SMSG_ARENA_TEAM_CHANGE_FAILED_QUEUED,
    0x04CE: SMSG_MOVE_GRAVITY_DISABLE,
    0x04D0: SMSG_MOVE_GRAVITY_ENABLE,
    0x04D2: MSG_MOVE_GRAVITY_CHNG_Server,
    0x04D3: SMSG_SPLINE_MOVE_GRAVITY_DISABLE,
    0x04D4: SMSG_SPLINE_MOVE_GRAVITY_ENABLE,
    0x04D6: SMSG_EQUIPMENT_SET_USE_RESULT,
    0x04DA: SMSG_CHAR_FACTION_CHANGE,
    0x04DE: SMSG_BATTLEFIELD_MGR_ENTRY_INVITE,
    0x04E0: SMSG_BATTLEFIELD_MGR_ENTERED,
    0x04E1: SMSG_BATTLEFIELD_MGR_QUEUE_INVITE,
    0x04E4: SMSG_BATTLEFIELD_MGR_QUEUE_REQUEST_RESPONSE,
    0x04E5: SMSG_BATTLEFIELD_MGR_EJECT_PENDING,
    0x04E6: SMSG_BATTLEFIELD_MGR_EJECTED,
    0x04E8: SMSG_BATTLEFIELD_MGR_STATE_CHANGE,
    0x04EB: MSG_SET_RAID_DIFFICULTY_Server,
    0x04ED: SMSG_TOGGLE_XP_GAIN,
    0x04EE: SMSG_GMRESPONSE_DB_ERROR,
    0x04EF: SMSG_GMRESPONSE_RECEIVED,
    0x04F1: SMSG_GMRESPONSE_STATUS_UPDATE,
    0x04F7: SMSG_WORLD_STATE_UI_TIMER_UPDATE,
    0x04FA: SMSG_TALENTS_INVOLUNTARILY_RESET,
    0x0501: SMSG_QUERY_QUESTS_COMPLETED_RESPONSE,
    0x0506: SMSG_CORPSE_NOT_IN_INSTANCE,
    0x050A: SMSG_CAMERA_SHAKE,
    0x050B: SMSG_SOCKET_GEMS_RESULT,
    0x050D: SMSG_REDIRECT_CLIENT,
    0x0516: SMSG_MOVE_SET_COLLISION_HGT,
    0x051E: SMSG_MULTIPLE_MOVES,
}


async def read_server_opcode_body(
    reader: asyncio.StreamReader,
    opcode: int,
    body_size: int,
) -> ServerOpcode:
    return await server_opcodes[opcode].read(reader, body_size)


async def read_client_opcodes_unencrypted(reader: asyncio.StreamReader) -> ClientOpcode:
    opcode_size = 2
    size_field_size = 4

    size = int.from_bytes(await reader.readexactly(opcode_size), "big")
    opcode = int.from_bytes(await reader.readexactly(size_field_size), "little")

    body_size = size - size_field_size
    body = await reader.readexactly(body_size)
    body_reader = asyncio.StreamReader()
    body_reader.feed_data(body)
    body_reader.feed_eof()

    return await read_client_opcode_body(body_reader, opcode, body_size)


async def read_client_opcodes_encrypted(
    reader: asyncio.StreamReader,
    header_crypto: wow_srp.WrathHeaderCrypto,
) -> ClientOpcode:
    size_field_size = 4
    header_size = 6

    data = await reader.readexactly(header_size)

    size, opcode = header_crypto.decrypt_client_header(data)

    body_size = size - size_field_size
    body = await reader.readexactly(body_size)
    body_reader = asyncio.StreamReader()
    body_reader.feed_data(body)
    body_reader.feed_eof()

    return await read_client_opcode_body(body_reader, opcode, body_size)


async def read_server_opcodes_unencrypted(reader: asyncio.StreamReader) -> ServerOpcode:
    opcode_size = 2
    size_field_size = 2

    size = int.from_bytes(await reader.readexactly(opcode_size), "big")
    opcode = int.from_bytes(await reader.readexactly(size_field_size), "little")

    body_size = size - size_field_size
    body = await reader.readexactly(body_size)
    body_reader = asyncio.StreamReader()
    body_reader.feed_data(body)
    body_reader.feed_eof()

    return await read_server_opcode_body(body_reader, opcode, body_size)


async def read_server_opcodes_encrypted(
    reader: asyncio.StreamReader,
    header_crypto: wow_srp.WrathHeaderCrypto,
) -> ServerOpcode:
    size_field_size = 2
    header_size = 4

    data = await reader.readexactly(header_size)

    size, opcode = header_crypto.decrypt_client_header(data)

    body_size = size - size_field_size
    body = await reader.readexactly(body_size)
    body_reader = asyncio.StreamReader()
    body_reader.feed_data(body)
    body_reader.feed_eof()

    return await read_server_opcode_body(body_reader, opcode, body_size)


async def expect_client_opcode_unencrypted(
    reader: asyncio.StreamReader,
    opcode: typing.Type[ClientOpcode],
) -> typing.Optional[ClientOpcode]:
    o = await read_client_opcodes_unencrypted(reader)
    if isinstance(o, opcode):
        return o
    else:
        return None


async def expect_client_opcode_encrypted(
    reader: asyncio.StreamReader,
    opcode: typing.Type[ClientOpcode],
    header_crypto: wow_srp.WrathHeaderCrypto,
) -> typing.Optional[ClientOpcode]:
    o = await read_client_opcodes_encrypted(reader, header_crypto)
    if isinstance(o, opcode):
        return o
    else:
        return None


async def expect_server_opcode_unencrypted(
    reader: asyncio.StreamReader,
    opcode: typing.Type[ServerOpcode],
) -> typing.Optional[ServerOpcode]:
    o = await read_server_opcodes_unencrypted(reader)
    if isinstance(o, opcode):
        return o
    else:
        return None


async def expect_server_opcode_encrypted(
    reader: asyncio.StreamReader,
    opcode: typing.Type[ServerOpcode],
    header_crypto: wow_srp.WrathHeaderCrypto,
) -> typing.Optional[ServerOpcode]:
    o = await read_server_opcodes_encrypted(reader, header_crypto)
    if isinstance(o, opcode):
        return o
    else:
        return None


