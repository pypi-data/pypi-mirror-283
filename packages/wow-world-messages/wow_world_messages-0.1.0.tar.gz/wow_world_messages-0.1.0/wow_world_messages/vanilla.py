from __future__ import annotations
import asyncio
import dataclasses
import enum
import struct
import typing
import zlib

import wow_srp
from .util import packed_guid_size
from .util import packed_guid_write
from .util import read_packed_guid
from .util import read_sized_cstring
from .util import read_bool
from .util import read_int
from .util import read_cstring
from .util import read_float

__all__ = [
    "read_client_opcodes_unencrypted",
    "read_client_opcodes_encrypted",
    "read_server_opcodes_unencrypted",
    "read_server_opcodes_encrypted",
    "expect_client_opcode_unencrypted",
    "expect_client_opcode_encrypted",
    "expect_server_opcode_unencrypted",
    "expect_server_opcode_encrypted",
    "AuraMask",
    "UpdateMask",
    "AccountDataType",
    "ActivateTaxiReply",
    "AddonType",
    "AiReaction",
    "Area",
    "AttackHand",
    "AuctionCommandAction",
    "AuctionCommandResult",
    "AuctionCommandResultTwo",
    "AuctionHouse",
    "AuraMod",
    "AuraType",
    "BagFamily",
    "BattlefieldPortAction",
    "BattlegroundBracket",
    "BattlegroundEndStatus",
    "BattlegroundWinner",
    "BgTypeId",
    "Bonding",
    "BuyBankSlotResult",
    "BuyResult",
    "BuybackSlot",
    "CastFailureReason",
    "ChatNotify",
    "ChatType",
    "CinematicSequenceId",
    "Class",
    "ClientLanguage",
    "CompressedMoveOpcode",
    "CorpseQueryResult",
    "CreatureFamily",
    "DismountResult",
    "DuelWinnerReason",
    "Emote",
    "EmoteSpecProc",
    "EnvironmentalDamageType",
    "ExperienceAwardType",
    "Faction",
    "FarSightOperation",
    "FluidSpeed",
    "FriendResult",
    "FriendStatus",
    "Gender",
    "GmTicketEscalationStatus",
    "GmTicketQueueStatus",
    "GmTicketResponse",
    "GmTicketStatus",
    "GmTicketStatusResponse",
    "GmTicketType",
    "GroupLootSetting",
    "GroupType",
    "GuildCommand",
    "GuildCommandResult",
    "GuildEmblemResult",
    "GuildEvent",
    "GuildMemberStatus",
    "HitInfo",
    "InfoBlock",
    "InstanceResetFailedReason",
    "InstanceType",
    "InventoryResult",
    "InventoryType",
    "ItemClass",
    "ItemClassAndSubClass",
    "ItemEnvTypes",
    "ItemQuality",
    "ItemSet",
    "ItemSlot",
    "ItemStatType",
    "ItemWeaponClass",
    "KeyVersion",
    "Language",
    "LfgFaction",
    "LockType",
    "LogFormat",
    "LogoutResult",
    "LogoutSpeed",
    "LootMethod",
    "LootMethodError",
    "LootSlotType",
    "MailAction",
    "MailMessageType",
    "MailResult",
    "MailResultTwo",
    "MailType",
    "Map",
    "MeetingStoneFailure",
    "MeetingStoneStatus",
    "MonsterMoveType",
    "MountResult",
    "NewItemChatAlert",
    "NewItemCreationType",
    "NewItemSource",
    "ObjectType",
    "OceanType",
    "PageTextMaterial",
    "PartyOperation",
    "PartyResult",
    "PetCommandState",
    "PetEnabled",
    "PetFeedback",
    "PetReactState",
    "PetTalkReason",
    "PetTameFailureReason",
    "PetitionResult",
    "PlayerChatTag",
    "Power",
    "PvpRank",
    "QuestCompletable",
    "QuestFailedReason",
    "QuestGiverStatus",
    "QuestPartyMessage",
    "Race",
    "RaidGroupError",
    "RaidInstanceMessage",
    "RaidTargetIndex",
    "RaidTargetUpdateType",
    "RollVote",
    "Scalp",
    "SelectionType",
    "SellItemResult",
    "ServerCategory",
    "ServerMessageType",
    "ServerRegion",
    "SheathState",
    "SheatheType",
    "SimpleSpellCastResult",
    "SizeClass",
    "Skill",
    "SkillCategory",
    "SoundType",
    "SpellCastResult",
    "SpellEffect",
    "SpellMissInfo",
    "SpellSchool",
    "SpellTriggerType",
    "StableResult",
    "StatusId",
    "SwingType",
    "Talent",
    "TextEmote",
    "TimerType",
    "TradeStatus",
    "TrainerSpellState",
    "TrainingFailureReason",
    "TransferAbortReason",
    "UnitStandState",
    "UpdateType",
    "UrlInfo",
    "WeatherChangeType",
    "WeatherType",
    "WorldResult",
    "AllowedClass",
    "AllowedRace",
    "AreaFlags",
    "Attributes",
    "AttributesEx1",
    "AttributesEx2",
    "AttributesEx3",
    "AttributesEx4",
    "CastFlags",
    "ChannelFlags",
    "ChannelMemberFlags",
    "CharacterFlags",
    "CharacterRaceFlags",
    "DefaultChannelFlags",
    "EmoteFlags",
    "FactionFlag",
    "GroupMemberOnlineStatus",
    "GroupUpdateFlags",
    "ItemFlag",
    "MovementFlags",
    "PvpFlags",
    "ReputationFlags",
    "SpellCastTargetFlags",
    "SplineFlag",
    "UpdateFlag",
    "WeaponFlags",
    "Addon",
    "AddonInfo",
    "AuctionListItem",
    "AuraLog",
    "BattlegroundPlayer",
    "BattlegroundPlayerPosition",
    "ChannelMember",
    "Vector3d",
    "MonsterMoveSpline",
    "CharacterGear",
    "Character",
    "MonsterMove",
    "CompressedMove",
    "CooldownSpell",
    "DamageInfo",
    "FactionInitializer",
    "FactionStanding",
    "ForcedReaction",
    "Friend",
    "GmSurveyQuestion",
    "GossipItem",
    "GroupListMember",
    "GuildMember",
    "InitialSpell",
    "ItemDamageType",
    "ItemSpells",
    "ItemStat",
    "ListInventoryItem",
    "LootItem",
    "Mail",
    "MovementBlock",
    "TransportInfo",
    "MovementInfo",
    "NpcTextUpdateEmote",
    "NpcTextUpdate",
    "Object",
    "PetSpellCooldown",
    "PetitionShowlist",
    "PetitionSignature",
    "QuestDetailsEmote",
    "QuestItem",
    "QuestItemRequirement",
    "QuestItemReward",
    "QuestObjective",
    "RaidInfo",
    "RaidTargetUpdate",
    "SpellCastTargets",
    "SpellCooldownStatus",
    "SpellLog",
    "SpellLogMiss",
    "SpellMiss",
    "StabledPet",
    "TradeSlot",
    "TrainerSpell",
    "Vector2d",
    "WhoPlayer",
    "WorldState",
    "CMSG_BOOTME",
    "CMSG_DBLOOKUP",
    "CMSG_WORLD_TELEPORT",
    "CMSG_TELEPORT_TO_UNIT",
    "CMSG_CHAR_CREATE",
    "CMSG_CHAR_ENUM",
    "CMSG_CHAR_DELETE",
    "SMSG_CHAR_CREATE",
    "SMSG_CHAR_ENUM",
    "SMSG_CHAR_DELETE",
    "CMSG_PLAYER_LOGIN",
    "SMSG_NEW_WORLD",
    "SMSG_TRANSFER_PENDING",
    "SMSG_TRANSFER_ABORTED",
    "SMSG_CHARACTER_LOGIN_FAILED",
    "SMSG_LOGIN_SETTIMESPEED",
    "CMSG_PLAYER_LOGOUT",
    "CMSG_LOGOUT_REQUEST",
    "SMSG_LOGOUT_RESPONSE",
    "SMSG_LOGOUT_COMPLETE",
    "CMSG_LOGOUT_CANCEL",
    "SMSG_LOGOUT_CANCEL_ACK",
    "CMSG_NAME_QUERY",
    "SMSG_NAME_QUERY_RESPONSE",
    "CMSG_PET_NAME_QUERY",
    "SMSG_PET_NAME_QUERY_RESPONSE",
    "CMSG_GUILD_QUERY",
    "SMSG_GUILD_QUERY_RESPONSE",
    "CMSG_ITEM_QUERY_SINGLE",
    "SMSG_ITEM_QUERY_SINGLE_RESPONSE",
    "CMSG_PAGE_TEXT_QUERY",
    "SMSG_PAGE_TEXT_QUERY_RESPONSE",
    "CMSG_QUEST_QUERY",
    "SMSG_QUEST_QUERY_RESPONSE",
    "CMSG_GAMEOBJECT_QUERY",
    "SMSG_GAMEOBJECT_QUERY_RESPONSE",
    "CMSG_CREATURE_QUERY",
    "SMSG_CREATURE_QUERY_RESPONSE",
    "CMSG_WHO",
    "SMSG_WHO",
    "CMSG_WHOIS",
    "SMSG_WHOIS",
    "CMSG_FRIEND_LIST",
    "SMSG_FRIEND_LIST",
    "SMSG_FRIEND_STATUS",
    "CMSG_ADD_FRIEND",
    "CMSG_DEL_FRIEND",
    "SMSG_IGNORE_LIST",
    "CMSG_ADD_IGNORE",
    "CMSG_DEL_IGNORE",
    "CMSG_GROUP_INVITE",
    "SMSG_GROUP_INVITE",
    "CMSG_GROUP_ACCEPT",
    "CMSG_GROUP_DECLINE",
    "SMSG_GROUP_DECLINE",
    "CMSG_GROUP_UNINVITE",
    "CMSG_GROUP_UNINVITE_GUID",
    "SMSG_GROUP_UNINVITE",
    "CMSG_GROUP_SET_LEADER",
    "SMSG_GROUP_SET_LEADER",
    "CMSG_LOOT_METHOD",
    "CMSG_GROUP_DISBAND",
    "SMSG_GROUP_DESTROYED",
    "SMSG_GROUP_LIST",
    "SMSG_PARTY_MEMBER_STATS",
    "SMSG_PARTY_COMMAND_RESULT",
    "CMSG_GUILD_CREATE",
    "CMSG_GUILD_INVITE",
    "SMSG_GUILD_INVITE",
    "CMSG_GUILD_ACCEPT",
    "CMSG_GUILD_DECLINE",
    "CMSG_GUILD_INFO",
    "SMSG_GUILD_INFO",
    "CMSG_GUILD_ROSTER",
    "SMSG_GUILD_ROSTER",
    "CMSG_GUILD_PROMOTE",
    "CMSG_GUILD_DEMOTE",
    "CMSG_GUILD_LEAVE",
    "CMSG_GUILD_REMOVE",
    "CMSG_GUILD_DISBAND",
    "CMSG_GUILD_LEADER",
    "CMSG_GUILD_MOTD",
    "SMSG_GUILD_EVENT",
    "SMSG_GUILD_COMMAND_RESULT",
    "CMSG_MESSAGECHAT",
    "SMSG_MESSAGECHAT",
    "CMSG_JOIN_CHANNEL",
    "CMSG_LEAVE_CHANNEL",
    "SMSG_CHANNEL_NOTIFY",
    "CMSG_CHANNEL_LIST",
    "SMSG_CHANNEL_LIST",
    "CMSG_CHANNEL_PASSWORD",
    "CMSG_CHANNEL_SET_OWNER",
    "CMSG_CHANNEL_OWNER",
    "CMSG_CHANNEL_MODERATOR",
    "CMSG_CHANNEL_UNMODERATOR",
    "CMSG_CHANNEL_MUTE",
    "CMSG_CHANNEL_UNMUTE",
    "CMSG_CHANNEL_INVITE",
    "CMSG_CHANNEL_KICK",
    "CMSG_CHANNEL_BAN",
    "CMSG_CHANNEL_UNBAN",
    "CMSG_CHANNEL_ANNOUNCEMENTS",
    "CMSG_CHANNEL_MODERATE",
    "SMSG_UPDATE_OBJECT",
    "SMSG_DESTROY_OBJECT",
    "CMSG_USE_ITEM",
    "CMSG_OPEN_ITEM",
    "CMSG_READ_ITEM",
    "SMSG_READ_ITEM_OK",
    "SMSG_READ_ITEM_FAILED",
    "SMSG_ITEM_COOLDOWN",
    "CMSG_GAMEOBJ_USE",
    "SMSG_GAMEOBJECT_CUSTOM_ANIM",
    "CMSG_AREATRIGGER",
    "MSG_MOVE_START_FORWARD_Client",
    "MSG_MOVE_START_FORWARD_Server",
    "MSG_MOVE_START_BACKWARD_Client",
    "MSG_MOVE_START_BACKWARD_Server",
    "MSG_MOVE_STOP_Client",
    "MSG_MOVE_STOP_Server",
    "MSG_MOVE_START_STRAFE_LEFT_Client",
    "MSG_MOVE_START_STRAFE_LEFT_Server",
    "MSG_MOVE_START_STRAFE_RIGHT_Client",
    "MSG_MOVE_START_STRAFE_RIGHT_Server",
    "MSG_MOVE_STOP_STRAFE_Client",
    "MSG_MOVE_STOP_STRAFE_Server",
    "MSG_MOVE_JUMP_Client",
    "MSG_MOVE_JUMP_Server",
    "MSG_MOVE_START_TURN_LEFT_Client",
    "MSG_MOVE_START_TURN_LEFT_Server",
    "MSG_MOVE_START_TURN_RIGHT_Client",
    "MSG_MOVE_START_TURN_RIGHT_Server",
    "MSG_MOVE_STOP_TURN_Client",
    "MSG_MOVE_STOP_TURN_Server",
    "MSG_MOVE_START_PITCH_UP_Client",
    "MSG_MOVE_START_PITCH_UP_Server",
    "MSG_MOVE_START_PITCH_DOWN_Client",
    "MSG_MOVE_START_PITCH_DOWN_Server",
    "MSG_MOVE_STOP_PITCH_Client",
    "MSG_MOVE_STOP_PITCH_Server",
    "MSG_MOVE_SET_RUN_MODE_Client",
    "MSG_MOVE_SET_RUN_MODE_Server",
    "MSG_MOVE_SET_WALK_MODE_Client",
    "MSG_MOVE_SET_WALK_MODE_Server",
    "MSG_MOVE_TELEPORT_ACK_Client",
    "MSG_MOVE_TELEPORT_ACK_Server",
    "MSG_MOVE_FALL_LAND_Client",
    "MSG_MOVE_FALL_LAND_Server",
    "MSG_MOVE_START_SWIM_Client",
    "MSG_MOVE_START_SWIM_Server",
    "MSG_MOVE_STOP_SWIM_Client",
    "MSG_MOVE_STOP_SWIM_Server",
    "MSG_MOVE_SET_FACING_Client",
    "MSG_MOVE_SET_FACING_Server",
    "MSG_MOVE_SET_PITCH_Client",
    "MSG_MOVE_SET_PITCH_Server",
    "MSG_MOVE_WORLDPORT_ACK",
    "SMSG_MONSTER_MOVE",
    "SMSG_MOVE_WATER_WALK",
    "SMSG_MOVE_LAND_WALK",
    "CMSG_MOVE_SET_RAW_POSITION",
    "SMSG_FORCE_RUN_SPEED_CHANGE",
    "CMSG_FORCE_RUN_SPEED_CHANGE_ACK",
    "SMSG_FORCE_RUN_BACK_SPEED_CHANGE",
    "CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK",
    "SMSG_FORCE_SWIM_SPEED_CHANGE",
    "CMSG_FORCE_SWIM_SPEED_CHANGE_ACK",
    "SMSG_FORCE_MOVE_ROOT",
    "CMSG_FORCE_MOVE_ROOT_ACK",
    "SMSG_FORCE_MOVE_UNROOT",
    "CMSG_FORCE_MOVE_UNROOT_ACK",
    "MSG_MOVE_HEARTBEAT_Client",
    "MSG_MOVE_HEARTBEAT_Server",
    "SMSG_MOVE_KNOCK_BACK",
    "CMSG_MOVE_KNOCK_BACK_ACK",
    "SMSG_MOVE_FEATHER_FALL",
    "SMSG_MOVE_NORMAL_FALL",
    "SMSG_MOVE_SET_HOVER",
    "SMSG_MOVE_UNSET_HOVER",
    "CMSG_MOVE_HOVER_ACK",
    "SMSG_TRIGGER_CINEMATIC",
    "CMSG_NEXT_CINEMATIC_CAMERA",
    "CMSG_COMPLETE_CINEMATIC",
    "SMSG_TUTORIAL_FLAGS",
    "CMSG_TUTORIAL_FLAG",
    "CMSG_TUTORIAL_CLEAR",
    "CMSG_TUTORIAL_RESET",
    "CMSG_STANDSTATECHANGE",
    "CMSG_EMOTE",
    "SMSG_EMOTE",
    "CMSG_TEXT_EMOTE",
    "SMSG_TEXT_EMOTE",
    "CMSG_AUTOSTORE_LOOT_ITEM",
    "CMSG_AUTOEQUIP_ITEM",
    "CMSG_AUTOSTORE_BAG_ITEM",
    "CMSG_SWAP_ITEM",
    "CMSG_SWAP_INV_ITEM",
    "CMSG_SPLIT_ITEM",
    "CMSG_AUTOEQUIP_ITEM_SLOT",
    "CMSG_DESTROYITEM",
    "SMSG_INVENTORY_CHANGE_FAILURE",
    "SMSG_OPEN_CONTAINER",
    "CMSG_INSPECT",
    "SMSG_INSPECT",
    "CMSG_INITIATE_TRADE",
    "CMSG_BEGIN_TRADE",
    "CMSG_BUSY_TRADE",
    "CMSG_IGNORE_TRADE",
    "CMSG_ACCEPT_TRADE",
    "CMSG_UNACCEPT_TRADE",
    "CMSG_CANCEL_TRADE",
    "CMSG_SET_TRADE_ITEM",
    "CMSG_CLEAR_TRADE_ITEM",
    "CMSG_SET_TRADE_GOLD",
    "SMSG_TRADE_STATUS",
    "SMSG_TRADE_STATUS_EXTENDED",
    "SMSG_INITIALIZE_FACTIONS",
    "SMSG_SET_FACTION_VISIBLE",
    "SMSG_SET_FACTION_STANDING",
    "CMSG_SET_FACTION_ATWAR",
    "SMSG_SET_PROFICIENCY",
    "CMSG_SET_ACTION_BUTTON",
    "SMSG_ACTION_BUTTONS",
    "SMSG_INITIAL_SPELLS",
    "SMSG_LEARNED_SPELL",
    "SMSG_SUPERCEDED_SPELL",
    "CMSG_CAST_SPELL",
    "CMSG_CANCEL_CAST",
    "SMSG_CAST_RESULT",
    "SMSG_SPELL_START",
    "SMSG_SPELL_GO",
    "SMSG_SPELL_FAILURE",
    "SMSG_SPELL_COOLDOWN",
    "SMSG_COOLDOWN_EVENT",
    "CMSG_CANCEL_AURA",
    "SMSG_UPDATE_AURA_DURATION",
    "SMSG_PET_CAST_FAILED",
    "MSG_CHANNEL_START_Server",
    "MSG_CHANNEL_UPDATE_Server",
    "CMSG_CANCEL_CHANNELLING",
    "SMSG_AI_REACTION",
    "CMSG_SET_SELECTION",
    "CMSG_SET_TARGET_OBSOLETE",
    "CMSG_ATTACKSWING",
    "CMSG_ATTACKSTOP",
    "SMSG_ATTACKSTART",
    "SMSG_ATTACKSTOP",
    "SMSG_ATTACKSWING_NOTINRANGE",
    "SMSG_ATTACKSWING_BADFACING",
    "SMSG_ATTACKSWING_NOTSTANDING",
    "SMSG_ATTACKSWING_DEADTARGET",
    "SMSG_ATTACKSWING_CANT_ATTACK",
    "SMSG_ATTACKERSTATEUPDATE",
    "SMSG_CANCEL_COMBAT",
    "SMSG_SPELLHEALLOG",
    "SMSG_SPELLENERGIZELOG",
    "SMSG_BINDPOINTUPDATE",
    "SMSG_PLAYERBOUND",
    "SMSG_CLIENT_CONTROL_UPDATE",
    "CMSG_REPOP_REQUEST",
    "SMSG_RESURRECT_REQUEST",
    "CMSG_RESURRECT_RESPONSE",
    "CMSG_LOOT",
    "CMSG_LOOT_MONEY",
    "CMSG_LOOT_RELEASE",
    "SMSG_LOOT_RESPONSE",
    "SMSG_LOOT_RELEASE_RESPONSE",
    "SMSG_LOOT_REMOVED",
    "SMSG_LOOT_MONEY_NOTIFY",
    "SMSG_LOOT_CLEAR_MONEY",
    "SMSG_ITEM_PUSH_RESULT",
    "SMSG_DUEL_REQUESTED",
    "SMSG_DUEL_OUTOFBOUNDS",
    "SMSG_DUEL_INBOUNDS",
    "SMSG_DUEL_COMPLETE",
    "SMSG_DUEL_WINNER",
    "CMSG_DUEL_ACCEPTED",
    "CMSG_DUEL_CANCELLED",
    "SMSG_MOUNTRESULT",
    "SMSG_DISMOUNTRESULT",
    "CMSG_MOUNTSPECIAL_ANIM",
    "SMSG_MOUNTSPECIAL_ANIM",
    "SMSG_PET_TAME_FAILURE",
    "CMSG_PET_SET_ACTION",
    "CMSG_PET_ACTION",
    "CMSG_PET_ABANDON",
    "CMSG_PET_RENAME",
    "SMSG_PET_NAME_INVALID",
    "SMSG_PET_SPELLS",
    "SMSG_PET_MODE",
    "CMSG_GOSSIP_HELLO",
    "CMSG_GOSSIP_SELECT_OPTION",
    "SMSG_GOSSIP_MESSAGE",
    "SMSG_GOSSIP_COMPLETE",
    "CMSG_NPC_TEXT_QUERY",
    "SMSG_NPC_TEXT_UPDATE",
    "CMSG_QUESTGIVER_STATUS_QUERY",
    "SMSG_QUESTGIVER_STATUS",
    "CMSG_QUESTGIVER_HELLO",
    "SMSG_QUESTGIVER_QUEST_LIST",
    "CMSG_QUESTGIVER_QUERY_QUEST",
    "CMSG_QUESTGIVER_QUEST_AUTOLAUNCH",
    "SMSG_QUESTGIVER_QUEST_DETAILS",
    "CMSG_QUESTGIVER_ACCEPT_QUEST",
    "CMSG_QUESTGIVER_COMPLETE_QUEST",
    "SMSG_QUESTGIVER_REQUEST_ITEMS",
    "CMSG_QUESTGIVER_REQUEST_REWARD",
    "SMSG_QUESTGIVER_OFFER_REWARD",
    "CMSG_QUESTGIVER_CHOOSE_REWARD",
    "SMSG_QUESTGIVER_QUEST_INVALID",
    "CMSG_QUESTGIVER_CANCEL",
    "SMSG_QUESTGIVER_QUEST_COMPLETE",
    "SMSG_QUESTGIVER_QUEST_FAILED",
    "CMSG_QUESTLOG_SWAP_QUEST",
    "CMSG_QUESTLOG_REMOVE_QUEST",
    "SMSG_QUESTLOG_FULL",
    "SMSG_QUESTUPDATE_FAILED",
    "SMSG_QUESTUPDATE_FAILEDTIMER",
    "SMSG_QUESTUPDATE_COMPLETE",
    "SMSG_QUESTUPDATE_ADD_KILL",
    "SMSG_QUESTUPDATE_ADD_ITEM",
    "CMSG_QUEST_CONFIRM_ACCEPT",
    "SMSG_QUEST_CONFIRM_ACCEPT",
    "CMSG_PUSHQUESTTOPARTY",
    "CMSG_LIST_INVENTORY",
    "SMSG_LIST_INVENTORY",
    "CMSG_SELL_ITEM",
    "SMSG_SELL_ITEM",
    "CMSG_BUY_ITEM",
    "CMSG_BUY_ITEM_IN_SLOT",
    "SMSG_BUY_ITEM",
    "SMSG_BUY_FAILED",
    "SMSG_SHOWTAXINODES",
    "CMSG_TAXINODE_STATUS_QUERY",
    "SMSG_TAXINODE_STATUS",
    "CMSG_TAXIQUERYAVAILABLENODES",
    "CMSG_ACTIVATETAXI",
    "SMSG_ACTIVATETAXIREPLY",
    "SMSG_NEW_TAXI_PATH",
    "CMSG_TRAINER_LIST",
    "SMSG_TRAINER_LIST",
    "CMSG_TRAINER_BUY_SPELL",
    "SMSG_TRAINER_BUY_SUCCEEDED",
    "SMSG_TRAINER_BUY_FAILED",
    "CMSG_BINDER_ACTIVATE",
    "CMSG_BANKER_ACTIVATE",
    "SMSG_SHOW_BANK",
    "CMSG_BUY_BANK_SLOT",
    "SMSG_BUY_BANK_SLOT_RESULT",
    "CMSG_PETITION_SHOWLIST",
    "SMSG_PETITION_SHOWLIST",
    "CMSG_PETITION_BUY",
    "CMSG_PETITION_SHOW_SIGNATURES",
    "SMSG_PETITION_SHOW_SIGNATURES",
    "CMSG_PETITION_SIGN",
    "SMSG_PETITION_SIGN_RESULTS",
    "MSG_PETITION_DECLINE",
    "CMSG_OFFER_PETITION",
    "CMSG_TURN_IN_PETITION",
    "SMSG_TURN_IN_PETITION_RESULTS",
    "CMSG_PETITION_QUERY",
    "SMSG_PETITION_QUERY_RESPONSE",
    "SMSG_FISH_NOT_HOOKED",
    "SMSG_FISH_ESCAPED",
    "CMSG_BUG",
    "SMSG_NOTIFICATION",
    "CMSG_PLAYED_TIME",
    "SMSG_PLAYED_TIME",
    "CMSG_QUERY_TIME",
    "SMSG_QUERY_TIME_RESPONSE",
    "SMSG_LOG_XPGAIN",
    "CMSG_RECLAIM_CORPSE",
    "CMSG_WRAP_ITEM",
    "SMSG_LEVELUP_INFO",
    "MSG_MINIMAP_PING_Client",
    "MSG_MINIMAP_PING_Server",
    "SMSG_RESISTLOG",
    "SMSG_ENCHANTMENTLOG",
    "SMSG_START_MIRROR_TIMER",
    "SMSG_PAUSE_MIRROR_TIMER",
    "SMSG_STOP_MIRROR_TIMER",
    "CMSG_PING",
    "SMSG_PONG",
    "SMSG_CLEAR_COOLDOWN",
    "SMSG_GAMEOBJECT_PAGETEXT",
    "CMSG_SETSHEATHED",
    "SMSG_SPELL_DELAYED",
    "SMSG_ITEM_TIME_UPDATE",
    "SMSG_ITEM_ENCHANT_TIME_UPDATE",
    "SMSG_AUTH_CHALLENGE",
    "CMSG_AUTH_SESSION",
    "SMSG_AUTH_RESPONSE",
    "CMSG_PET_CAST_SPELL",
    "MSG_SAVE_GUILD_EMBLEM_Server",
    "MSG_SAVE_GUILD_EMBLEM_Client",
    "MSG_TABARDVENDOR_ACTIVATE",
    "SMSG_PLAY_SPELL_VISUAL",
    "CMSG_ZONEUPDATE",
    "SMSG_PARTYKILLLOG",
    "SMSG_COMPRESSED_UPDATE_OBJECT",
    "SMSG_PLAY_SPELL_IMPACT",
    "SMSG_EXPLORATION_EXPERIENCE",
    "MSG_RANDOM_ROLL_Client",
    "MSG_RANDOM_ROLL_Server",
    "SMSG_ENVIRONMENTAL_DAMAGE_LOG",
    "MSG_LOOKING_FOR_GROUP_Client",
    "MSG_LOOKING_FOR_GROUP_Server",
    "CMSG_UNLEARN_SKILL",
    "SMSG_REMOVED_SPELL",
    "CMSG_GMTICKET_CREATE",
    "SMSG_GMTICKET_CREATE",
    "CMSG_GMTICKET_UPDATETEXT",
    "SMSG_GMTICKET_UPDATETEXT",
    "SMSG_ACCOUNT_DATA_TIMES",
    "CMSG_REQUEST_ACCOUNT_DATA",
    "CMSG_UPDATE_ACCOUNT_DATA",
    "CMSG_GMTICKET_GETTICKET",
    "SMSG_GMTICKET_GETTICKET",
    "SMSG_GAMEOBJECT_SPAWN_ANIM",
    "SMSG_GAMEOBJECT_DESPAWN_ANIM",
    "MSG_CORPSE_QUERY_Client",
    "MSG_CORPSE_QUERY_Server",
    "CMSG_GMTICKET_DELETETICKET",
    "SMSG_GMTICKET_DELETETICKET",
    "SMSG_CHAT_WRONG_FACTION",
    "CMSG_GMTICKET_SYSTEMSTATUS",
    "SMSG_GMTICKET_SYSTEMSTATUS",
    "CMSG_SPIRIT_HEALER_ACTIVATE",
    "SMSG_SET_REST_START",
    "SMSG_SPIRIT_HEALER_CONFIRM",
    "SMSG_GOSSIP_POI",
    "CMSG_CHAT_IGNORED",
    "CMSG_GUILD_RANK",
    "CMSG_GUILD_ADD_RANK",
    "CMSG_GUILD_DEL_RANK",
    "CMSG_GUILD_SET_PUBLIC_NOTE",
    "CMSG_GUILD_SET_OFFICER_NOTE",
    "SMSG_LOGIN_VERIFY_WORLD",
    "CMSG_SEND_MAIL",
    "SMSG_SEND_MAIL_RESULT",
    "CMSG_GET_MAIL_LIST",
    "SMSG_MAIL_LIST_RESULT",
    "CMSG_BATTLEFIELD_LIST",
    "SMSG_BATTLEFIELD_LIST",
    "CMSG_BATTLEFIELD_JOIN",
    "CMSG_ITEM_TEXT_QUERY",
    "SMSG_ITEM_TEXT_QUERY_RESPONSE",
    "CMSG_MAIL_TAKE_MONEY",
    "CMSG_MAIL_TAKE_ITEM",
    "CMSG_MAIL_MARK_AS_READ",
    "CMSG_MAIL_RETURN_TO_SENDER",
    "CMSG_MAIL_DELETE",
    "CMSG_MAIL_CREATE_TEXT_ITEM",
    "SMSG_SPELLLOGMISS",
    "SMSG_SPELLLOGEXECUTE",
    "SMSG_PERIODICAURALOG",
    "SMSG_SPELLDAMAGESHIELD",
    "SMSG_SPELLNONMELEEDAMAGELOG",
    "CMSG_LEARN_TALENT",
    "CMSG_TOGGLE_PVP",
    "SMSG_ZONE_UNDER_ATTACK",
    "MSG_AUCTION_HELLO_Client",
    "MSG_AUCTION_HELLO_Server",
    "CMSG_AUCTION_SELL_ITEM",
    "CMSG_AUCTION_REMOVE_ITEM",
    "CMSG_AUCTION_LIST_ITEMS",
    "CMSG_AUCTION_LIST_OWNER_ITEMS",
    "CMSG_AUCTION_PLACE_BID",
    "SMSG_AUCTION_COMMAND_RESULT",
    "SMSG_AUCTION_LIST_RESULT",
    "SMSG_AUCTION_OWNER_LIST_RESULT",
    "SMSG_AUCTION_BIDDER_NOTIFICATION",
    "SMSG_AUCTION_OWNER_NOTIFICATION",
    "SMSG_PROCRESIST",
    "SMSG_DISPEL_FAILED",
    "SMSG_SPELLORDAMAGE_IMMUNE",
    "CMSG_AUCTION_LIST_BIDDER_ITEMS",
    "SMSG_AUCTION_BIDDER_LIST_RESULT",
    "SMSG_SET_FLAT_SPELL_MODIFIER",
    "SMSG_SET_PCT_SPELL_MODIFIER",
    "CMSG_SET_AMMO",
    "SMSG_CORPSE_RECLAIM_DELAY",
    "CMSG_SET_ACTIVE_MOVER",
    "CMSG_PET_CANCEL_AURA",
    "CMSG_CANCEL_AUTO_REPEAT_SPELL",
    "MSG_LIST_STABLED_PETS_Client",
    "MSG_LIST_STABLED_PETS_Server",
    "CMSG_STABLE_PET",
    "CMSG_UNSTABLE_PET",
    "CMSG_BUY_STABLE_SLOT",
    "SMSG_STABLE_RESULT",
    "CMSG_STABLE_SWAP_PET",
    "MSG_QUEST_PUSH_RESULT",
    "SMSG_PLAY_MUSIC",
    "SMSG_PLAY_OBJECT_SOUND",
    "CMSG_REQUEST_PET_INFO",
    "CMSG_FAR_SIGHT",
    "SMSG_SPELLDISPELLOG",
    "CMSG_GROUP_CHANGE_SUB_GROUP",
    "CMSG_REQUEST_PARTY_MEMBER_STATS",
    "CMSG_GROUP_SWAP_SUB_GROUP",
    "CMSG_AUTOSTORE_BANK_ITEM",
    "CMSG_AUTOBANK_ITEM",
    "MSG_QUERY_NEXT_MAIL_TIME_Server",
    "MSG_QUERY_NEXT_MAIL_TIME_Client",
    "SMSG_RECEIVED_MAIL",
    "SMSG_RAID_GROUP_ONLY",
    "SMSG_PVP_CREDIT",
    "SMSG_AUCTION_REMOVED_NOTIFICATION",
    "CMSG_GROUP_RAID_CONVERT",
    "CMSG_GROUP_ASSISTANT_LEADER",
    "CMSG_BUYBACK_ITEM",
    "SMSG_SERVER_MESSAGE",
    "CMSG_MEETINGSTONE_JOIN",
    "CMSG_MEETINGSTONE_LEAVE",
    "SMSG_MEETINGSTONE_SETQUEUE",
    "CMSG_MEETINGSTONE_INFO",
    "SMSG_MEETINGSTONE_COMPLETE",
    "SMSG_MEETINGSTONE_IN_PROGRESS",
    "SMSG_MEETINGSTONE_MEMBER_ADDED",
    "CMSG_CANCEL_GROWTH_AURA",
    "SMSG_CANCEL_AUTO_REPEAT",
    "SMSG_STANDSTATE_UPDATE",
    "SMSG_LOOT_ALL_PASSED",
    "SMSG_LOOT_ROLL_WON",
    "CMSG_LOOT_ROLL",
    "SMSG_LOOT_START_ROLL",
    "SMSG_LOOT_ROLL",
    "CMSG_LOOT_MASTER_GIVE",
    "SMSG_LOOT_MASTER_LIST",
    "SMSG_SET_FORCED_REACTIONS",
    "SMSG_SPELL_FAILED_OTHER",
    "SMSG_GAMEOBJECT_RESET_STATE",
    "CMSG_REPAIR_ITEM",
    "SMSG_CHAT_PLAYER_NOT_FOUND",
    "MSG_TALENT_WIPE_CONFIRM_Client",
    "MSG_TALENT_WIPE_CONFIRM_Server",
    "SMSG_SUMMON_REQUEST",
    "CMSG_SUMMON_RESPONSE",
    "SMSG_MONSTER_MOVE_TRANSPORT",
    "SMSG_PET_BROKEN",
    "MSG_MOVE_FEATHER_FALL_Server",
    "MSG_MOVE_WATER_WALK",
    "CMSG_SELF_RES",
    "SMSG_FEIGN_DEATH_RESISTED",
    "SMSG_DUEL_COUNTDOWN",
    "SMSG_AREA_TRIGGER_MESSAGE",
    "CMSG_TOGGLE_HELM",
    "CMSG_TOGGLE_CLOAK",
    "SMSG_MEETINGSTONE_JOINFAILED",
    "SMSG_PLAYER_SKINNED",
    "SMSG_DURABILITY_DAMAGE_DEATH",
    "CMSG_SET_ACTIONBAR_TOGGLES",
    "MSG_PETITION_RENAME",
    "SMSG_INIT_WORLD_STATES",
    "SMSG_UPDATE_WORLD_STATE",
    "CMSG_ITEM_NAME_QUERY",
    "SMSG_ITEM_NAME_QUERY_RESPONSE",
    "SMSG_PET_ACTION_FEEDBACK",
    "CMSG_CHAR_RENAME",
    "SMSG_CHAR_RENAME",
    "CMSG_MOVE_SPLINE_DONE",
    "CMSG_MOVE_FALL_RESET",
    "SMSG_INSTANCE_SAVE_CREATED",
    "SMSG_RAID_INSTANCE_INFO",
    "CMSG_REQUEST_RAID_INFO",
    "CMSG_MOVE_TIME_SKIPPED",
    "CMSG_MOVE_FEATHER_FALL_ACK",
    "CMSG_MOVE_WATER_WALK_ACK",
    "CMSG_MOVE_NOT_ACTIVE_MOVER",
    "SMSG_PLAY_SOUND",
    "CMSG_BATTLEFIELD_STATUS",
    "SMSG_BATTLEFIELD_STATUS",
    "CMSG_BATTLEFIELD_PORT",
    "MSG_INSPECT_HONOR_STATS_Client",
    "MSG_INSPECT_HONOR_STATS_Server",
    "CMSG_BATTLEMASTER_HELLO",
    "SMSG_FORCE_WALK_SPEED_CHANGE",
    "CMSG_FORCE_WALK_SPEED_CHANGE_ACK",
    "SMSG_FORCE_SWIM_BACK_SPEED_CHANGE",
    "CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK",
    "SMSG_FORCE_TURN_RATE_CHANGE",
    "CMSG_FORCE_TURN_RATE_CHANGE_ACK",
    "MSG_PVP_LOG_DATA_Client",
    "MSG_PVP_LOG_DATA_Server",
    "CMSG_LEAVE_BATTLEFIELD",
    "CMSG_AREA_SPIRIT_HEALER_QUERY",
    "CMSG_AREA_SPIRIT_HEALER_QUEUE",
    "SMSG_AREA_SPIRIT_HEALER_TIME",
    "SMSG_WARDEN_DATA",
    "CMSG_WARDEN_DATA",
    "SMSG_GROUP_JOINED_BATTLEGROUND",
    "MSG_BATTLEGROUND_PLAYER_POSITIONS_Client",
    "MSG_BATTLEGROUND_PLAYER_POSITIONS_Server",
    "CMSG_PET_STOP_ATTACK",
    "SMSG_BINDER_CONFIRM",
    "SMSG_BATTLEGROUND_PLAYER_JOINED",
    "SMSG_BATTLEGROUND_PLAYER_LEFT",
    "CMSG_BATTLEMASTER_JOIN",
    "SMSG_ADDON_INFO",
    "CMSG_PET_UNLEARN",
    "SMSG_PET_UNLEARN_CONFIRM",
    "SMSG_PARTY_MEMBER_STATS_FULL",
    "CMSG_PET_SPELL_AUTOCAST",
    "SMSG_WEATHER",
    "SMSG_RAID_INSTANCE_MESSAGE",
    "SMSG_COMPRESSED_MOVES",
    "CMSG_GUILD_INFO_TEXT",
    "SMSG_CHAT_RESTRICTED",
    "SMSG_SPLINE_SET_RUN_SPEED",
    "SMSG_SPLINE_SET_RUN_BACK_SPEED",
    "SMSG_SPLINE_SET_SWIM_SPEED",
    "SMSG_SPLINE_SET_WALK_SPEED",
    "SMSG_SPLINE_SET_SWIM_BACK_SPEED",
    "SMSG_SPLINE_SET_TURN_RATE",
    "SMSG_SPLINE_MOVE_UNROOT",
    "SMSG_SPLINE_MOVE_FEATHER_FALL",
    "SMSG_SPLINE_MOVE_NORMAL_FALL",
    "SMSG_SPLINE_MOVE_SET_HOVER",
    "SMSG_SPLINE_MOVE_UNSET_HOVER",
    "SMSG_SPLINE_MOVE_WATER_WALK",
    "SMSG_SPLINE_MOVE_LAND_WALK",
    "SMSG_SPLINE_MOVE_START_SWIM",
    "SMSG_SPLINE_MOVE_STOP_SWIM",
    "SMSG_SPLINE_MOVE_SET_RUN_MODE",
    "SMSG_SPLINE_MOVE_SET_WALK_MODE",
    "CMSG_ACTIVATETAXIEXPRESS",
    "CMSG_SET_FACTION_INACTIVE",
    "CMSG_SET_WATCHED_FACTION",
    "MSG_MOVE_TIME_SKIPPED_Server",
    "SMSG_SPLINE_MOVE_ROOT",
    "SMSG_INVALIDATE_PLAYER",
    "CMSG_RESET_INSTANCES",
    "SMSG_INSTANCE_RESET",
    "SMSG_INSTANCE_RESET_FAILED",
    "SMSG_UPDATE_LAST_INSTANCE",
    "MSG_RAID_TARGET_UPDATE_Client",
    "MSG_RAID_TARGET_UPDATE_Server",
    "MSG_RAID_READY_CHECK_Client",
    "MSG_RAID_READY_CHECK_Server",
    "SMSG_PET_ACTION_SOUND",
    "SMSG_PET_DISMISS_SOUND",
    "SMSG_GM_TICKET_STATUS_UPDATE",
    "CMSG_GMSURVEY_SUBMIT",
    "SMSG_UPDATE_INSTANCE_OWNERSHIP",
    "SMSG_SPELLINSTAKILLLOG",
    "SMSG_SPELL_UPDATE_CHAIN_TARGETS",
    "SMSG_EXPECTED_SPAM_RECORDS",
    "SMSG_DEFENSE_MESSAGE",
]


@dataclasses.dataclass
class AuraMask:
    fields: dict[int, int]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        mask = await read_int(reader, 4)

        fields = {}
        for index in range(0, 32):
            if mask & 1 << index:
                fields[index] = await read_int(reader, 2)

        return AuraMask(fields=fields)

    def write(self, fmt, data):
        mask = 0
        for key in self.fields:
            mask |= 1 << key

        fmt += 'I'
        data.append(mask)

        fmt += f"{len(self.fields)}H"
        data.extend(list(self.fields.values()))

        return fmt, data

    def size(self):
        return 4 + len(self.fields) * 2


@dataclasses.dataclass
class UpdateMask:
    fields: dict[int, int]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        amount_of_blocks = await read_int(reader, 1)

        blocks = []
        for _ in range(0, amount_of_blocks):
            blocks.append(await read_int(reader, 4))

        fields = {}
        for block_index, block in enumerate(blocks):
            for bit in range(0, 32):
                if block & 1 << bit:
                    value = await read_int(reader, 4)
                    key = block_index * 32 + bit
                    fields[key] = value

        return UpdateMask(fields=fields)

    def write(self, fmt, data):
        highest_key = max(self.fields, default=0)
        amount_of_blocks = highest_key // 32
        if highest_key % 32 != 0:
            amount_of_blocks += 1

        fmt += 'B'
        data.append(amount_of_blocks)

        blocks = [0] * amount_of_blocks

        for key in self.fields:
            block = key // 32
            index = key % 32
            blocks[block] |= 1 << index

        fmt += f'{len(blocks)}I'
        data.extend(blocks)

        for key in sorted(self.fields):
            if isinstance(self.fields[key], float):
                fmt += 'f'
            else:
                fmt += 'I'
            data.append(self.fields[key])

        return fmt, data

    def size(self):
        highest_key = max(self.fields, default=0)
        amount_of_blocks = highest_key // 32

        extra = highest_key % 32
        if extra != 0:
            extra = 1
        else:
            extra = 0

        return 1 + (extra + amount_of_blocks + len(self.fields)) * 4


class UpdateMaskValue(enum.IntEnum):
    OBJECT_GUID = 0
    OBJECT_TYPE = 2
    OBJECT_ENTRY = 3
    OBJECT_SCALE_X = 4
    ITEM_OWNER = 6
    ITEM_CONTAINED = 8
    ITEM_CREATOR = 10
    ITEM_GIFTCREATOR = 12
    ITEM_STACK_COUNT = 14
    ITEM_DURATION = 15
    ITEM_SPELL_CHARGES = 16
    ITEM_FLAGS = 21
    ITEM_ENCHANTMENT = 22
    ITEM_PROPERTY_SEED = 43
    ITEM_RANDOM_PROPERTIES_ID = 44
    ITEM_ITEM_TEXT_ID = 45
    ITEM_DURABILITY = 46
    ITEM_MAXDURABILITY = 47
    CONTAINER_NUM_SLOTS = 48
    CONTAINER_SLOT_1 = 50
    UNIT_CHARM = 6
    UNIT_SUMMON = 8
    UNIT_CHARMEDBY = 10
    UNIT_SUMMONEDBY = 12
    UNIT_CREATEDBY = 14
    UNIT_TARGET = 16
    UNIT_PERSUADED = 18
    UNIT_CHANNEL_OBJECT = 20
    UNIT_HEALTH = 22
    UNIT_POWER1 = 23
    UNIT_POWER2 = 24
    UNIT_POWER3 = 25
    UNIT_POWER4 = 26
    UNIT_POWER5 = 27
    UNIT_MAXHEALTH = 28
    UNIT_MAXPOWER1 = 29
    UNIT_MAXPOWER2 = 30
    UNIT_MAXPOWER3 = 31
    UNIT_MAXPOWER4 = 32
    UNIT_MAXPOWER5 = 33
    UNIT_LEVEL = 34
    UNIT_FACTIONTEMPLATE = 35
    UNIT_BYTES_0 = 36
    UNIT_VIRTUAL_ITEM_SLOT_DISPLAY = 37
    UNIT_VIRTUAL_ITEM_INFO = 40
    UNIT_FLAGS = 46
    UNIT_AURA = 47
    UNIT_AURAFLAGS = 95
    UNIT_AURALEVELS = 101
    UNIT_AURAAPPLICATIONS = 113
    UNIT_AURASTATE = 125
    UNIT_BASEATTACKTIME = 126
    UNIT_RANGEDATTACKTIME = 128
    UNIT_BOUNDINGRADIUS = 129
    UNIT_COMBATREACH = 130
    UNIT_DISPLAYID = 131
    UNIT_NATIVEDISPLAYID = 132
    UNIT_MOUNTDISPLAYID = 133
    UNIT_MINDAMAGE = 134
    UNIT_MAXDAMAGE = 135
    UNIT_MINOFFHANDDAMAGE = 136
    UNIT_MAXOFFHANDDAMAGE = 137
    UNIT_BYTES_1 = 138
    UNIT_PETNUMBER = 139
    UNIT_PET_NAME_TIMESTAMP = 140
    UNIT_PETEXPERIENCE = 141
    UNIT_PETNEXTLEVELEXP = 142
    UNIT_DYNAMIC_FLAGS = 143
    UNIT_CHANNEL_SPELL = 144
    UNIT_MOD_CAST_SPEED = 145
    UNIT_CREATED_BY_SPELL = 146
    UNIT_NPC_FLAGS = 147
    UNIT_NPC_EMOTESTATE = 148
    UNIT_TRAINING_POINTS = 149
    UNIT_STRENGTH = 150
    UNIT_AGILITY = 151
    UNIT_STAMINA = 152
    UNIT_INTELLECT = 153
    UNIT_SPIRIT = 154
    UNIT_NORMAL_RESISTANCE = 155
    UNIT_HOLY_RESISTANCE = 156
    UNIT_FIRE_RESISTANCE = 157
    UNIT_NATURE_RESISTANCE = 158
    UNIT_FROST_RESISTANCE = 159
    UNIT_SHADOW_RESISTANCE = 160
    UNIT_ARCANE_RESISTANCE = 161
    UNIT_BASE_MANA = 162
    UNIT_BASE_HEALTH = 163
    UNIT_BYTES_2 = 164
    UNIT_ATTACK_POWER = 165
    UNIT_ATTACK_POWER_MODS = 166
    UNIT_ATTACK_POWER_MULTIPLIER = 167
    UNIT_RANGED_ATTACK_POWER = 168
    UNIT_RANGED_ATTACK_POWER_MODS = 169
    UNIT_RANGED_ATTACK_POWER_MULTIPLIER = 170
    UNIT_MINRANGEDDAMAGE = 171
    UNIT_MAXRANGEDDAMAGE = 172
    UNIT_POWER_COST_MODIFIER = 173
    UNIT_POWER_COST_MULTIPLIER = 180
    PLAYER_DUEL_ARBITER = 188
    PLAYER_FLAGS = 190
    PLAYER_GUILDID = 191
    PLAYER_GUILDRANK = 192
    PLAYER_FEATURES = 193
    PLAYER_BYTES_2 = 194
    PLAYER_BYTES_3 = 195
    PLAYER_DUEL_TEAM = 196
    PLAYER_GUILD_TIMESTAMP = 197
    PLAYER_QUEST_LOG_1_1 = 198
    PLAYER_QUEST_LOG_1_2 = 199
    PLAYER_QUEST_LOG_2_1 = 201
    PLAYER_QUEST_LOG_2_2 = 202
    PLAYER_QUEST_LOG_3_1 = 204
    PLAYER_QUEST_LOG_3_2 = 205
    PLAYER_QUEST_LOG_4_1 = 207
    PLAYER_QUEST_LOG_4_2 = 208
    PLAYER_QUEST_LOG_5_1 = 210
    PLAYER_QUEST_LOG_5_2 = 211
    PLAYER_QUEST_LOG_6_1 = 213
    PLAYER_QUEST_LOG_6_2 = 214
    PLAYER_QUEST_LOG_7_1 = 216
    PLAYER_QUEST_LOG_7_2 = 217
    PLAYER_QUEST_LOG_8_1 = 219
    PLAYER_QUEST_LOG_8_2 = 220
    PLAYER_QUEST_LOG_9_1 = 222
    PLAYER_QUEST_LOG_9_2 = 223
    PLAYER_QUEST_LOG_10_1 = 225
    PLAYER_QUEST_LOG_10_2 = 226
    PLAYER_QUEST_LOG_11_1 = 228
    PLAYER_QUEST_LOG_11_2 = 229
    PLAYER_QUEST_LOG_12_1 = 231
    PLAYER_QUEST_LOG_12_2 = 232
    PLAYER_QUEST_LOG_13_1 = 234
    PLAYER_QUEST_LOG_13_2 = 235
    PLAYER_QUEST_LOG_14_1 = 237
    PLAYER_QUEST_LOG_14_2 = 238
    PLAYER_QUEST_LOG_15_1 = 240
    PLAYER_QUEST_LOG_15_2 = 241
    PLAYER_QUEST_LOG_16_1 = 243
    PLAYER_QUEST_LOG_16_2 = 244
    PLAYER_QUEST_LOG_17_1 = 246
    PLAYER_QUEST_LOG_17_2 = 247
    PLAYER_QUEST_LOG_18_1 = 249
    PLAYER_QUEST_LOG_18_2 = 250
    PLAYER_QUEST_LOG_19_1 = 252
    PLAYER_QUEST_LOG_19_2 = 253
    PLAYER_QUEST_LOG_20_1 = 255
    PLAYER_QUEST_LOG_20_2 = 256
    PLAYER_VISIBLE_ITEM_0_CREATOR_LOW = 258
    PLAYER_VISIBLE_ITEM_0_CREATOR_HIGH = 259
    PLAYER_VISIBLE_ITEM_0_ITEM = 260
    PLAYER_VISIBLE_ITEM_0_ENCHANTS_LOW = 261
    PLAYER_VISIBLE_ITEM_0_ENCHANTS_HIGH = 262
    PLAYER_VISIBLE_ITEM_0_RANDOM_PROPERTY_ID = 268
    PLAYER_VISIBLE_ITEM_0_ITEM_SUFFIX_FACTOR = 269
    PLAYER_VISIBLE_ITEM_1_CREATOR_LOW = 270
    PLAYER_VISIBLE_ITEM_1_CREATOR_HIGH = 271
    PLAYER_VISIBLE_ITEM_1_ITEM = 272
    PLAYER_VISIBLE_ITEM_1_ENCHANTS_LOW = 273
    PLAYER_VISIBLE_ITEM_1_ENCHANTS_HIGH = 274
    PLAYER_VISIBLE_ITEM_1_RANDOM_PROPERTY_ID = 280
    PLAYER_VISIBLE_ITEM_1_ITEM_SUFFIX_FACTOR = 281
    PLAYER_VISIBLE_ITEM_2_CREATOR_LOW = 282
    PLAYER_VISIBLE_ITEM_2_CREATOR_HIGH = 283
    PLAYER_VISIBLE_ITEM_2_ITEM = 284
    PLAYER_VISIBLE_ITEM_2_ENCHANTS_LOW = 285
    PLAYER_VISIBLE_ITEM_2_ENCHANTS_HIGH = 286
    PLAYER_VISIBLE_ITEM_2_RANDOM_PROPERTY_ID = 292
    PLAYER_VISIBLE_ITEM_2_ITEM_SUFFIX_FACTOR = 293
    PLAYER_VISIBLE_ITEM_3_CREATOR_LOW = 294
    PLAYER_VISIBLE_ITEM_3_CREATOR_HIGH = 295
    PLAYER_VISIBLE_ITEM_3_ITEM = 296
    PLAYER_VISIBLE_ITEM_3_ENCHANTS_LOW = 297
    PLAYER_VISIBLE_ITEM_3_ENCHANTS_HIGH = 298
    PLAYER_VISIBLE_ITEM_3_RANDOM_PROPERTY_ID = 304
    PLAYER_VISIBLE_ITEM_3_ITEM_SUFFIX_FACTOR = 305
    PLAYER_VISIBLE_ITEM_4_CREATOR_LOW = 306
    PLAYER_VISIBLE_ITEM_4_CREATOR_HIGH = 307
    PLAYER_VISIBLE_ITEM_4_ITEM = 308
    PLAYER_VISIBLE_ITEM_4_ENCHANTS_LOW = 309
    PLAYER_VISIBLE_ITEM_4_ENCHANTS_HIGH = 310
    PLAYER_VISIBLE_ITEM_4_RANDOM_PROPERTY_ID = 316
    PLAYER_VISIBLE_ITEM_4_ITEM_SUFFIX_FACTOR = 317
    PLAYER_VISIBLE_ITEM_5_CREATOR_LOW = 318
    PLAYER_VISIBLE_ITEM_5_CREATOR_HIGH = 319
    PLAYER_VISIBLE_ITEM_5_ITEM = 320
    PLAYER_VISIBLE_ITEM_5_ENCHANTS_LOW = 321
    PLAYER_VISIBLE_ITEM_5_ENCHANTS_HIGH = 322
    PLAYER_VISIBLE_ITEM_5_RANDOM_PROPERTY_ID = 328
    PLAYER_VISIBLE_ITEM_5_ITEM_SUFFIX_FACTOR = 329
    PLAYER_VISIBLE_ITEM_6_CREATOR_LOW = 330
    PLAYER_VISIBLE_ITEM_6_CREATOR_HIGH = 331
    PLAYER_VISIBLE_ITEM_6_ITEM = 332
    PLAYER_VISIBLE_ITEM_6_ENCHANTS_LOW = 333
    PLAYER_VISIBLE_ITEM_6_ENCHANTS_HIGH = 334
    PLAYER_VISIBLE_ITEM_6_RANDOM_PROPERTY_ID = 340
    PLAYER_VISIBLE_ITEM_6_ITEM_SUFFIX_FACTOR = 341
    PLAYER_VISIBLE_ITEM_7_CREATOR_LOW = 342
    PLAYER_VISIBLE_ITEM_7_CREATOR_HIGH = 343
    PLAYER_VISIBLE_ITEM_7_ITEM = 344
    PLAYER_VISIBLE_ITEM_7_ENCHANTS_LOW = 345
    PLAYER_VISIBLE_ITEM_7_ENCHANTS_HIGH = 346
    PLAYER_VISIBLE_ITEM_7_RANDOM_PROPERTY_ID = 352
    PLAYER_VISIBLE_ITEM_7_ITEM_SUFFIX_FACTOR = 353
    PLAYER_VISIBLE_ITEM_8_CREATOR_LOW = 354
    PLAYER_VISIBLE_ITEM_8_CREATOR_HIGH = 355
    PLAYER_VISIBLE_ITEM_8_ITEM = 356
    PLAYER_VISIBLE_ITEM_8_ENCHANTS_LOW = 357
    PLAYER_VISIBLE_ITEM_8_ENCHANTS_HIGH = 358
    PLAYER_VISIBLE_ITEM_8_RANDOM_PROPERTY_ID = 364
    PLAYER_VISIBLE_ITEM_8_ITEM_SUFFIX_FACTOR = 365
    PLAYER_VISIBLE_ITEM_9_CREATOR_LOW = 366
    PLAYER_VISIBLE_ITEM_9_CREATOR_HIGH = 367
    PLAYER_VISIBLE_ITEM_9_ITEM = 368
    PLAYER_VISIBLE_ITEM_9_ENCHANTS_LOW = 369
    PLAYER_VISIBLE_ITEM_9_ENCHANTS_HIGH = 370
    PLAYER_VISIBLE_ITEM_9_RANDOM_PROPERTY_ID = 376
    PLAYER_VISIBLE_ITEM_9_ITEM_SUFFIX_FACTOR = 377
    PLAYER_VISIBLE_ITEM_10_CREATOR_LOW = 378
    PLAYER_VISIBLE_ITEM_10_CREATOR_HIGH = 379
    PLAYER_VISIBLE_ITEM_10_ITEM = 380
    PLAYER_VISIBLE_ITEM_10_ENCHANTS_LOW = 381
    PLAYER_VISIBLE_ITEM_10_ENCHANTS_HIGH = 382
    PLAYER_VISIBLE_ITEM_10_RANDOM_PROPERTY_ID = 388
    PLAYER_VISIBLE_ITEM_10_ITEM_SUFFIX_FACTOR = 389
    PLAYER_VISIBLE_ITEM_11_CREATOR_LOW = 390
    PLAYER_VISIBLE_ITEM_11_CREATOR_HIGH = 391
    PLAYER_VISIBLE_ITEM_11_ITEM = 392
    PLAYER_VISIBLE_ITEM_11_ENCHANTS_LOW = 393
    PLAYER_VISIBLE_ITEM_11_ENCHANTS_HIGH = 394
    PLAYER_VISIBLE_ITEM_11_RANDOM_PROPERTY_ID = 400
    PLAYER_VISIBLE_ITEM_11_ITEM_SUFFIX_FACTOR = 401
    PLAYER_VISIBLE_ITEM_12_CREATOR_LOW = 402
    PLAYER_VISIBLE_ITEM_12_CREATOR_HIGH = 403
    PLAYER_VISIBLE_ITEM_12_ITEM = 404
    PLAYER_VISIBLE_ITEM_12_ENCHANTS_LOW = 405
    PLAYER_VISIBLE_ITEM_12_ENCHANTS_HIGH = 406
    PLAYER_VISIBLE_ITEM_12_RANDOM_PROPERTY_ID = 412
    PLAYER_VISIBLE_ITEM_12_ITEM_SUFFIX_FACTOR = 413
    PLAYER_VISIBLE_ITEM_13_CREATOR_LOW = 414
    PLAYER_VISIBLE_ITEM_13_CREATOR_HIGH = 415
    PLAYER_VISIBLE_ITEM_13_ITEM = 416
    PLAYER_VISIBLE_ITEM_13_ENCHANTS_LOW = 417
    PLAYER_VISIBLE_ITEM_13_ENCHANTS_HIGH = 418
    PLAYER_VISIBLE_ITEM_13_RANDOM_PROPERTY_ID = 424
    PLAYER_VISIBLE_ITEM_13_ITEM_SUFFIX_FACTOR = 425
    PLAYER_VISIBLE_ITEM_14_CREATOR_LOW = 426
    PLAYER_VISIBLE_ITEM_14_CREATOR_HIGH = 427
    PLAYER_VISIBLE_ITEM_14_ITEM = 428
    PLAYER_VISIBLE_ITEM_14_ENCHANTS_LOW = 429
    PLAYER_VISIBLE_ITEM_14_ENCHANTS_HIGH = 430
    PLAYER_VISIBLE_ITEM_14_RANDOM_PROPERTY_ID = 436
    PLAYER_VISIBLE_ITEM_14_ITEM_SUFFIX_FACTOR = 437
    PLAYER_VISIBLE_ITEM_15_CREATOR_LOW = 438
    PLAYER_VISIBLE_ITEM_15_CREATOR_HIGH = 439
    PLAYER_VISIBLE_ITEM_15_ITEM = 440
    PLAYER_VISIBLE_ITEM_15_ENCHANTS_LOW = 441
    PLAYER_VISIBLE_ITEM_15_ENCHANTS_HIGH = 442
    PLAYER_VISIBLE_ITEM_15_RANDOM_PROPERTY_ID = 448
    PLAYER_VISIBLE_ITEM_15_ITEM_SUFFIX_FACTOR = 449
    PLAYER_VISIBLE_ITEM_16_CREATOR_LOW = 450
    PLAYER_VISIBLE_ITEM_16_CREATOR_HIGH = 451
    PLAYER_VISIBLE_ITEM_16_ITEM = 452
    PLAYER_VISIBLE_ITEM_16_ENCHANTS_LOW = 453
    PLAYER_VISIBLE_ITEM_16_ENCHANTS_HIGH = 454
    PLAYER_VISIBLE_ITEM_16_RANDOM_PROPERTY_ID = 460
    PLAYER_VISIBLE_ITEM_16_ITEM_SUFFIX_FACTOR = 461
    PLAYER_VISIBLE_ITEM_17_CREATOR_LOW = 462
    PLAYER_VISIBLE_ITEM_17_CREATOR_HIGH = 463
    PLAYER_VISIBLE_ITEM_17_ITEM = 464
    PLAYER_VISIBLE_ITEM_17_ENCHANTS_LOW = 465
    PLAYER_VISIBLE_ITEM_17_ENCHANTS_HIGH = 466
    PLAYER_VISIBLE_ITEM_17_RANDOM_PROPERTY_ID = 472
    PLAYER_VISIBLE_ITEM_17_ITEM_SUFFIX_FACTOR = 473
    PLAYER_VISIBLE_ITEM_18_CREATOR_LOW = 474
    PLAYER_VISIBLE_ITEM_18_CREATOR_HIGH = 475
    PLAYER_VISIBLE_ITEM_18_ITEM = 476
    PLAYER_VISIBLE_ITEM_18_ENCHANTS_LOW = 477
    PLAYER_VISIBLE_ITEM_18_ENCHANTS_HIGH = 478
    PLAYER_VISIBLE_ITEM_18_RANDOM_PROPERTY_ID = 484
    PLAYER_VISIBLE_ITEM_18_ITEM_SUFFIX_FACTOR = 485
    PLAYER_FIELD_INV_HEAD = 486
    PLAYER_FIELD_INV_NECK = 488
    PLAYER_FIELD_INV_SHOULDERS = 490
    PLAYER_FIELD_INV_SHIRT = 492
    PLAYER_FIELD_INV_CHEST = 494
    PLAYER_FIELD_INV_WAIST = 496
    PLAYER_FIELD_INV_LEGS = 498
    PLAYER_FIELD_INV_BOOTS = 500
    PLAYER_FIELD_INV_WRIST = 502
    PLAYER_FIELD_INV_HANDS = 504
    PLAYER_FIELD_INV_RING1 = 506
    PLAYER_FIELD_INV_RING2 = 508
    PLAYER_FIELD_INV_TRINKET1 = 510
    PLAYER_FIELD_INV_TRINKET2 = 512
    PLAYER_FIELD_INV_BACK = 514
    PLAYER_FIELD_INV_MAIN_HAND = 516
    PLAYER_FIELD_INV_OFF_HAND = 518
    PLAYER_FIELD_INV_RANGED_OR_RELIC = 520
    PLAYER_FIELD_INV_TABARD = 522
    PLAYER_FIELD_INV_BAG1 = 524
    PLAYER_FIELD_INV_BAG2 = 526
    PLAYER_FIELD_INV_BAG3 = 528
    PLAYER_FIELD_INV_BAG4 = 530
    PLAYER_FIELD_INV_INVENTORY_0 = 532
    PLAYER_FIELD_INV_INVENTORY_1 = 534
    PLAYER_FIELD_INV_INVENTORY_2 = 536
    PLAYER_FIELD_INV_INVENTORY_3 = 538
    PLAYER_FIELD_INV_INVENTORY_4 = 540
    PLAYER_FIELD_INV_INVENTORY_5 = 542
    PLAYER_FIELD_INV_INVENTORY_6 = 544
    PLAYER_FIELD_INV_INVENTORY_7 = 546
    PLAYER_FIELD_INV_INVENTORY_8 = 548
    PLAYER_FIELD_INV_INVENTORY_9 = 550
    PLAYER_FIELD_INV_INVENTORY_10 = 552
    PLAYER_FIELD_INV_INVENTORY_11 = 554
    PLAYER_FIELD_INV_INVENTORY_12 = 556
    PLAYER_FIELD_INV_INVENTORY_13 = 558
    PLAYER_FIELD_INV_INVENTORY_14 = 560
    PLAYER_FIELD_INV_INVENTORY_15 = 562
    PLAYER_FIELD_INV_BANK_1 = 564
    PLAYER_FIELD_INV_BANK_2 = 566
    PLAYER_FIELD_INV_BANK_3 = 568
    PLAYER_FIELD_INV_BANK_4 = 570
    PLAYER_FIELD_INV_BANK_5 = 572
    PLAYER_FIELD_INV_BANK_6 = 574
    PLAYER_FIELD_INV_BANK_7 = 576
    PLAYER_FIELD_INV_BANK_8 = 578
    PLAYER_FIELD_INV_BANK_9 = 580
    PLAYER_FIELD_INV_BANK_10 = 582
    PLAYER_FIELD_INV_BANK_11 = 584
    PLAYER_FIELD_INV_BANK_12 = 586
    PLAYER_FIELD_INV_BANK_13 = 588
    PLAYER_FIELD_INV_BANK_14 = 590
    PLAYER_FIELD_INV_BANK_15 = 592
    PLAYER_FIELD_INV_BANK_16 = 594
    PLAYER_FIELD_INV_BANK_17 = 596
    PLAYER_FIELD_INV_BANK_18 = 598
    PLAYER_FIELD_INV_BANK_19 = 600
    PLAYER_FIELD_INV_BANK_20 = 602
    PLAYER_FIELD_INV_BANK_21 = 604
    PLAYER_FIELD_INV_BANK_22 = 606
    PLAYER_FIELD_INV_BANK_23 = 608
    PLAYER_FIELD_INV_BANK_24 = 610
    PLAYER_FIELD_INV_BANK_BAG_SLOT_1 = 612
    PLAYER_FIELD_INV_BANK_BAG_SLOT_2 = 614
    PLAYER_FIELD_INV_BANK_BAG_SLOT_3 = 616
    PLAYER_FIELD_INV_BANK_BAG_SLOT_4 = 618
    PLAYER_FIELD_INV_BANK_BAG_SLOT_5 = 620
    PLAYER_FIELD_INV_BANK_BAG_SLOT_6 = 622
    PLAYER_FIELD_INV_VENDOR_BUYBACK_1 = 624
    PLAYER_FIELD_INV_VENDOR_BUYBACK_2 = 626
    PLAYER_FIELD_INV_VENDOR_BUYBACK_3 = 628
    PLAYER_FIELD_INV_VENDOR_BUYBACK_4 = 630
    PLAYER_FIELD_INV_VENDOR_BUYBACK_5 = 632
    PLAYER_FIELD_INV_VENDOR_BUYBACK_6 = 634
    PLAYER_FIELD_INV_VENDOR_BUYBACK_7 = 636
    PLAYER_FIELD_INV_VENDOR_BUYBACK_8 = 638
    PLAYER_FIELD_INV_VENDOR_BUYBACK_9 = 640
    PLAYER_FIELD_INV_VENDOR_BUYBACK_10 = 642
    PLAYER_FIELD_INV_VENDOR_BUYBACK_11 = 644
    PLAYER_FIELD_INV_VENDOR_BUYBACK_12 = 646
    PLAYER_FIELD_INV_KEYRING_1 = 648
    PLAYER_FIELD_INV_KEYRING_2 = 650
    PLAYER_FIELD_INV_KEYRING_3 = 652
    PLAYER_FIELD_INV_KEYRING_4 = 654
    PLAYER_FIELD_INV_KEYRING_5 = 656
    PLAYER_FIELD_INV_KEYRING_6 = 658
    PLAYER_FIELD_INV_KEYRING_7 = 660
    PLAYER_FIELD_INV_KEYRING_8 = 662
    PLAYER_FIELD_INV_KEYRING_9 = 664
    PLAYER_FIELD_INV_KEYRING_10 = 666
    PLAYER_FIELD_INV_KEYRING_11 = 668
    PLAYER_FIELD_INV_KEYRING_12 = 670
    PLAYER_FIELD_INV_KEYRING_13 = 672
    PLAYER_FIELD_INV_KEYRING_14 = 674
    PLAYER_FIELD_INV_KEYRING_15 = 676
    PLAYER_FIELD_INV_KEYRING_16 = 678
    PLAYER_FIELD_INV_KEYRING_17 = 680
    PLAYER_FIELD_INV_KEYRING_18 = 682
    PLAYER_FIELD_INV_KEYRING_19 = 684
    PLAYER_FIELD_INV_KEYRING_20 = 686
    PLAYER_FIELD_INV_KEYRING_21 = 688
    PLAYER_FIELD_INV_KEYRING_22 = 690
    PLAYER_FIELD_INV_KEYRING_23 = 692
    PLAYER_FIELD_INV_KEYRING_24 = 694
    PLAYER_FIELD_INV_KEYRING_25 = 696
    PLAYER_FIELD_INV_KEYRING_26 = 698
    PLAYER_FIELD_INV_KEYRING_27 = 700
    PLAYER_FIELD_INV_KEYRING_28 = 702
    PLAYER_FIELD_INV_KEYRING_29 = 704
    PLAYER_FIELD_INV_KEYRING_30 = 706
    PLAYER_FIELD_INV_KEYRING_31 = 708
    PLAYER_FIELD_INV_KEYRING_32 = 710
    PLAYER_FARSIGHT = 712
    PLAYER_FIELD_COMBO_TARGET = 714
    PLAYER_XP = 716
    PLAYER_NEXT_LEVEL_XP = 717
    PLAYER_SKILL_INFO_0_SKILL_0 = 718
    PLAYER_SKILL_INFO_0_SKILL_STEP_1 = 718
    PLAYER_SKILL_INFO_0_MINIMUM_0 = 719
    PLAYER_SKILL_INFO_0_MAXIMUM_1 = 719
    PLAYER_SKILL_INFO_0_PERMANENT_BONUS_0 = 720
    PLAYER_SKILL_INFO_0_TEMPORARY_BONUS_1 = 720
    PLAYER_SKILL_INFO_1_SKILL_0 = 721
    PLAYER_SKILL_INFO_1_SKILL_STEP_1 = 721
    PLAYER_SKILL_INFO_1_MINIMUM_0 = 722
    PLAYER_SKILL_INFO_1_MAXIMUM_1 = 722
    PLAYER_SKILL_INFO_1_PERMANENT_BONUS_0 = 723
    PLAYER_SKILL_INFO_1_TEMPORARY_BONUS_1 = 723
    PLAYER_SKILL_INFO_2_SKILL_0 = 724
    PLAYER_SKILL_INFO_2_SKILL_STEP_1 = 724
    PLAYER_SKILL_INFO_2_MINIMUM_0 = 725
    PLAYER_SKILL_INFO_2_MAXIMUM_1 = 725
    PLAYER_SKILL_INFO_2_PERMANENT_BONUS_0 = 726
    PLAYER_SKILL_INFO_2_TEMPORARY_BONUS_1 = 726
    PLAYER_SKILL_INFO_3_SKILL_0 = 727
    PLAYER_SKILL_INFO_3_SKILL_STEP_1 = 727
    PLAYER_SKILL_INFO_3_MINIMUM_0 = 728
    PLAYER_SKILL_INFO_3_MAXIMUM_1 = 728
    PLAYER_SKILL_INFO_3_PERMANENT_BONUS_0 = 729
    PLAYER_SKILL_INFO_3_TEMPORARY_BONUS_1 = 729
    PLAYER_SKILL_INFO_4_SKILL_0 = 730
    PLAYER_SKILL_INFO_4_SKILL_STEP_1 = 730
    PLAYER_SKILL_INFO_4_MINIMUM_0 = 731
    PLAYER_SKILL_INFO_4_MAXIMUM_1 = 731
    PLAYER_SKILL_INFO_4_PERMANENT_BONUS_0 = 732
    PLAYER_SKILL_INFO_4_TEMPORARY_BONUS_1 = 732
    PLAYER_SKILL_INFO_5_SKILL_0 = 733
    PLAYER_SKILL_INFO_5_SKILL_STEP_1 = 733
    PLAYER_SKILL_INFO_5_MINIMUM_0 = 734
    PLAYER_SKILL_INFO_5_MAXIMUM_1 = 734
    PLAYER_SKILL_INFO_5_PERMANENT_BONUS_0 = 735
    PLAYER_SKILL_INFO_5_TEMPORARY_BONUS_1 = 735
    PLAYER_SKILL_INFO_6_SKILL_0 = 736
    PLAYER_SKILL_INFO_6_SKILL_STEP_1 = 736
    PLAYER_SKILL_INFO_6_MINIMUM_0 = 737
    PLAYER_SKILL_INFO_6_MAXIMUM_1 = 737
    PLAYER_SKILL_INFO_6_PERMANENT_BONUS_0 = 738
    PLAYER_SKILL_INFO_6_TEMPORARY_BONUS_1 = 738
    PLAYER_SKILL_INFO_7_SKILL_0 = 739
    PLAYER_SKILL_INFO_7_SKILL_STEP_1 = 739
    PLAYER_SKILL_INFO_7_MINIMUM_0 = 740
    PLAYER_SKILL_INFO_7_MAXIMUM_1 = 740
    PLAYER_SKILL_INFO_7_PERMANENT_BONUS_0 = 741
    PLAYER_SKILL_INFO_7_TEMPORARY_BONUS_1 = 741
    PLAYER_SKILL_INFO_8_SKILL_0 = 742
    PLAYER_SKILL_INFO_8_SKILL_STEP_1 = 742
    PLAYER_SKILL_INFO_8_MINIMUM_0 = 743
    PLAYER_SKILL_INFO_8_MAXIMUM_1 = 743
    PLAYER_SKILL_INFO_8_PERMANENT_BONUS_0 = 744
    PLAYER_SKILL_INFO_8_TEMPORARY_BONUS_1 = 744
    PLAYER_SKILL_INFO_9_SKILL_0 = 745
    PLAYER_SKILL_INFO_9_SKILL_STEP_1 = 745
    PLAYER_SKILL_INFO_9_MINIMUM_0 = 746
    PLAYER_SKILL_INFO_9_MAXIMUM_1 = 746
    PLAYER_SKILL_INFO_9_PERMANENT_BONUS_0 = 747
    PLAYER_SKILL_INFO_9_TEMPORARY_BONUS_1 = 747
    PLAYER_SKILL_INFO_10_SKILL_0 = 748
    PLAYER_SKILL_INFO_10_SKILL_STEP_1 = 748
    PLAYER_SKILL_INFO_10_MINIMUM_0 = 749
    PLAYER_SKILL_INFO_10_MAXIMUM_1 = 749
    PLAYER_SKILL_INFO_10_PERMANENT_BONUS_0 = 750
    PLAYER_SKILL_INFO_10_TEMPORARY_BONUS_1 = 750
    PLAYER_SKILL_INFO_11_SKILL_0 = 751
    PLAYER_SKILL_INFO_11_SKILL_STEP_1 = 751
    PLAYER_SKILL_INFO_11_MINIMUM_0 = 752
    PLAYER_SKILL_INFO_11_MAXIMUM_1 = 752
    PLAYER_SKILL_INFO_11_PERMANENT_BONUS_0 = 753
    PLAYER_SKILL_INFO_11_TEMPORARY_BONUS_1 = 753
    PLAYER_SKILL_INFO_12_SKILL_0 = 754
    PLAYER_SKILL_INFO_12_SKILL_STEP_1 = 754
    PLAYER_SKILL_INFO_12_MINIMUM_0 = 755
    PLAYER_SKILL_INFO_12_MAXIMUM_1 = 755
    PLAYER_SKILL_INFO_12_PERMANENT_BONUS_0 = 756
    PLAYER_SKILL_INFO_12_TEMPORARY_BONUS_1 = 756
    PLAYER_SKILL_INFO_13_SKILL_0 = 757
    PLAYER_SKILL_INFO_13_SKILL_STEP_1 = 757
    PLAYER_SKILL_INFO_13_MINIMUM_0 = 758
    PLAYER_SKILL_INFO_13_MAXIMUM_1 = 758
    PLAYER_SKILL_INFO_13_PERMANENT_BONUS_0 = 759
    PLAYER_SKILL_INFO_13_TEMPORARY_BONUS_1 = 759
    PLAYER_SKILL_INFO_14_SKILL_0 = 760
    PLAYER_SKILL_INFO_14_SKILL_STEP_1 = 760
    PLAYER_SKILL_INFO_14_MINIMUM_0 = 761
    PLAYER_SKILL_INFO_14_MAXIMUM_1 = 761
    PLAYER_SKILL_INFO_14_PERMANENT_BONUS_0 = 762
    PLAYER_SKILL_INFO_14_TEMPORARY_BONUS_1 = 762
    PLAYER_SKILL_INFO_15_SKILL_0 = 763
    PLAYER_SKILL_INFO_15_SKILL_STEP_1 = 763
    PLAYER_SKILL_INFO_15_MINIMUM_0 = 764
    PLAYER_SKILL_INFO_15_MAXIMUM_1 = 764
    PLAYER_SKILL_INFO_15_PERMANENT_BONUS_0 = 765
    PLAYER_SKILL_INFO_15_TEMPORARY_BONUS_1 = 765
    PLAYER_SKILL_INFO_16_SKILL_0 = 766
    PLAYER_SKILL_INFO_16_SKILL_STEP_1 = 766
    PLAYER_SKILL_INFO_16_MINIMUM_0 = 767
    PLAYER_SKILL_INFO_16_MAXIMUM_1 = 767
    PLAYER_SKILL_INFO_16_PERMANENT_BONUS_0 = 768
    PLAYER_SKILL_INFO_16_TEMPORARY_BONUS_1 = 768
    PLAYER_SKILL_INFO_17_SKILL_0 = 769
    PLAYER_SKILL_INFO_17_SKILL_STEP_1 = 769
    PLAYER_SKILL_INFO_17_MINIMUM_0 = 770
    PLAYER_SKILL_INFO_17_MAXIMUM_1 = 770
    PLAYER_SKILL_INFO_17_PERMANENT_BONUS_0 = 771
    PLAYER_SKILL_INFO_17_TEMPORARY_BONUS_1 = 771
    PLAYER_SKILL_INFO_18_SKILL_0 = 772
    PLAYER_SKILL_INFO_18_SKILL_STEP_1 = 772
    PLAYER_SKILL_INFO_18_MINIMUM_0 = 773
    PLAYER_SKILL_INFO_18_MAXIMUM_1 = 773
    PLAYER_SKILL_INFO_18_PERMANENT_BONUS_0 = 774
    PLAYER_SKILL_INFO_18_TEMPORARY_BONUS_1 = 774
    PLAYER_SKILL_INFO_19_SKILL_0 = 775
    PLAYER_SKILL_INFO_19_SKILL_STEP_1 = 775
    PLAYER_SKILL_INFO_19_MINIMUM_0 = 776
    PLAYER_SKILL_INFO_19_MAXIMUM_1 = 776
    PLAYER_SKILL_INFO_19_PERMANENT_BONUS_0 = 777
    PLAYER_SKILL_INFO_19_TEMPORARY_BONUS_1 = 777
    PLAYER_SKILL_INFO_20_SKILL_0 = 778
    PLAYER_SKILL_INFO_20_SKILL_STEP_1 = 778
    PLAYER_SKILL_INFO_20_MINIMUM_0 = 779
    PLAYER_SKILL_INFO_20_MAXIMUM_1 = 779
    PLAYER_SKILL_INFO_20_PERMANENT_BONUS_0 = 780
    PLAYER_SKILL_INFO_20_TEMPORARY_BONUS_1 = 780
    PLAYER_SKILL_INFO_21_SKILL_0 = 781
    PLAYER_SKILL_INFO_21_SKILL_STEP_1 = 781
    PLAYER_SKILL_INFO_21_MINIMUM_0 = 782
    PLAYER_SKILL_INFO_21_MAXIMUM_1 = 782
    PLAYER_SKILL_INFO_21_PERMANENT_BONUS_0 = 783
    PLAYER_SKILL_INFO_21_TEMPORARY_BONUS_1 = 783
    PLAYER_SKILL_INFO_22_SKILL_0 = 784
    PLAYER_SKILL_INFO_22_SKILL_STEP_1 = 784
    PLAYER_SKILL_INFO_22_MINIMUM_0 = 785
    PLAYER_SKILL_INFO_22_MAXIMUM_1 = 785
    PLAYER_SKILL_INFO_22_PERMANENT_BONUS_0 = 786
    PLAYER_SKILL_INFO_22_TEMPORARY_BONUS_1 = 786
    PLAYER_SKILL_INFO_23_SKILL_0 = 787
    PLAYER_SKILL_INFO_23_SKILL_STEP_1 = 787
    PLAYER_SKILL_INFO_23_MINIMUM_0 = 788
    PLAYER_SKILL_INFO_23_MAXIMUM_1 = 788
    PLAYER_SKILL_INFO_23_PERMANENT_BONUS_0 = 789
    PLAYER_SKILL_INFO_23_TEMPORARY_BONUS_1 = 789
    PLAYER_SKILL_INFO_24_SKILL_0 = 790
    PLAYER_SKILL_INFO_24_SKILL_STEP_1 = 790
    PLAYER_SKILL_INFO_24_MINIMUM_0 = 791
    PLAYER_SKILL_INFO_24_MAXIMUM_1 = 791
    PLAYER_SKILL_INFO_24_PERMANENT_BONUS_0 = 792
    PLAYER_SKILL_INFO_24_TEMPORARY_BONUS_1 = 792
    PLAYER_SKILL_INFO_25_SKILL_0 = 793
    PLAYER_SKILL_INFO_25_SKILL_STEP_1 = 793
    PLAYER_SKILL_INFO_25_MINIMUM_0 = 794
    PLAYER_SKILL_INFO_25_MAXIMUM_1 = 794
    PLAYER_SKILL_INFO_25_PERMANENT_BONUS_0 = 795
    PLAYER_SKILL_INFO_25_TEMPORARY_BONUS_1 = 795
    PLAYER_SKILL_INFO_26_SKILL_0 = 796
    PLAYER_SKILL_INFO_26_SKILL_STEP_1 = 796
    PLAYER_SKILL_INFO_26_MINIMUM_0 = 797
    PLAYER_SKILL_INFO_26_MAXIMUM_1 = 797
    PLAYER_SKILL_INFO_26_PERMANENT_BONUS_0 = 798
    PLAYER_SKILL_INFO_26_TEMPORARY_BONUS_1 = 798
    PLAYER_SKILL_INFO_27_SKILL_0 = 799
    PLAYER_SKILL_INFO_27_SKILL_STEP_1 = 799
    PLAYER_SKILL_INFO_27_MINIMUM_0 = 800
    PLAYER_SKILL_INFO_27_MAXIMUM_1 = 800
    PLAYER_SKILL_INFO_27_PERMANENT_BONUS_0 = 801
    PLAYER_SKILL_INFO_27_TEMPORARY_BONUS_1 = 801
    PLAYER_SKILL_INFO_28_SKILL_0 = 802
    PLAYER_SKILL_INFO_28_SKILL_STEP_1 = 802
    PLAYER_SKILL_INFO_28_MINIMUM_0 = 803
    PLAYER_SKILL_INFO_28_MAXIMUM_1 = 803
    PLAYER_SKILL_INFO_28_PERMANENT_BONUS_0 = 804
    PLAYER_SKILL_INFO_28_TEMPORARY_BONUS_1 = 804
    PLAYER_SKILL_INFO_29_SKILL_0 = 805
    PLAYER_SKILL_INFO_29_SKILL_STEP_1 = 805
    PLAYER_SKILL_INFO_29_MINIMUM_0 = 806
    PLAYER_SKILL_INFO_29_MAXIMUM_1 = 806
    PLAYER_SKILL_INFO_29_PERMANENT_BONUS_0 = 807
    PLAYER_SKILL_INFO_29_TEMPORARY_BONUS_1 = 807
    PLAYER_SKILL_INFO_30_SKILL_0 = 808
    PLAYER_SKILL_INFO_30_SKILL_STEP_1 = 808
    PLAYER_SKILL_INFO_30_MINIMUM_0 = 809
    PLAYER_SKILL_INFO_30_MAXIMUM_1 = 809
    PLAYER_SKILL_INFO_30_PERMANENT_BONUS_0 = 810
    PLAYER_SKILL_INFO_30_TEMPORARY_BONUS_1 = 810
    PLAYER_SKILL_INFO_31_SKILL_0 = 811
    PLAYER_SKILL_INFO_31_SKILL_STEP_1 = 811
    PLAYER_SKILL_INFO_31_MINIMUM_0 = 812
    PLAYER_SKILL_INFO_31_MAXIMUM_1 = 812
    PLAYER_SKILL_INFO_31_PERMANENT_BONUS_0 = 813
    PLAYER_SKILL_INFO_31_TEMPORARY_BONUS_1 = 813
    PLAYER_SKILL_INFO_32_SKILL_0 = 814
    PLAYER_SKILL_INFO_32_SKILL_STEP_1 = 814
    PLAYER_SKILL_INFO_32_MINIMUM_0 = 815
    PLAYER_SKILL_INFO_32_MAXIMUM_1 = 815
    PLAYER_SKILL_INFO_32_PERMANENT_BONUS_0 = 816
    PLAYER_SKILL_INFO_32_TEMPORARY_BONUS_1 = 816
    PLAYER_SKILL_INFO_33_SKILL_0 = 817
    PLAYER_SKILL_INFO_33_SKILL_STEP_1 = 817
    PLAYER_SKILL_INFO_33_MINIMUM_0 = 818
    PLAYER_SKILL_INFO_33_MAXIMUM_1 = 818
    PLAYER_SKILL_INFO_33_PERMANENT_BONUS_0 = 819
    PLAYER_SKILL_INFO_33_TEMPORARY_BONUS_1 = 819
    PLAYER_SKILL_INFO_34_SKILL_0 = 820
    PLAYER_SKILL_INFO_34_SKILL_STEP_1 = 820
    PLAYER_SKILL_INFO_34_MINIMUM_0 = 821
    PLAYER_SKILL_INFO_34_MAXIMUM_1 = 821
    PLAYER_SKILL_INFO_34_PERMANENT_BONUS_0 = 822
    PLAYER_SKILL_INFO_34_TEMPORARY_BONUS_1 = 822
    PLAYER_SKILL_INFO_35_SKILL_0 = 823
    PLAYER_SKILL_INFO_35_SKILL_STEP_1 = 823
    PLAYER_SKILL_INFO_35_MINIMUM_0 = 824
    PLAYER_SKILL_INFO_35_MAXIMUM_1 = 824
    PLAYER_SKILL_INFO_35_PERMANENT_BONUS_0 = 825
    PLAYER_SKILL_INFO_35_TEMPORARY_BONUS_1 = 825
    PLAYER_SKILL_INFO_36_SKILL_0 = 826
    PLAYER_SKILL_INFO_36_SKILL_STEP_1 = 826
    PLAYER_SKILL_INFO_36_MINIMUM_0 = 827
    PLAYER_SKILL_INFO_36_MAXIMUM_1 = 827
    PLAYER_SKILL_INFO_36_PERMANENT_BONUS_0 = 828
    PLAYER_SKILL_INFO_36_TEMPORARY_BONUS_1 = 828
    PLAYER_SKILL_INFO_37_SKILL_0 = 829
    PLAYER_SKILL_INFO_37_SKILL_STEP_1 = 829
    PLAYER_SKILL_INFO_37_MINIMUM_0 = 830
    PLAYER_SKILL_INFO_37_MAXIMUM_1 = 830
    PLAYER_SKILL_INFO_37_PERMANENT_BONUS_0 = 831
    PLAYER_SKILL_INFO_37_TEMPORARY_BONUS_1 = 831
    PLAYER_SKILL_INFO_38_SKILL_0 = 832
    PLAYER_SKILL_INFO_38_SKILL_STEP_1 = 832
    PLAYER_SKILL_INFO_38_MINIMUM_0 = 833
    PLAYER_SKILL_INFO_38_MAXIMUM_1 = 833
    PLAYER_SKILL_INFO_38_PERMANENT_BONUS_0 = 834
    PLAYER_SKILL_INFO_38_TEMPORARY_BONUS_1 = 834
    PLAYER_SKILL_INFO_39_SKILL_0 = 835
    PLAYER_SKILL_INFO_39_SKILL_STEP_1 = 835
    PLAYER_SKILL_INFO_39_MINIMUM_0 = 836
    PLAYER_SKILL_INFO_39_MAXIMUM_1 = 836
    PLAYER_SKILL_INFO_39_PERMANENT_BONUS_0 = 837
    PLAYER_SKILL_INFO_39_TEMPORARY_BONUS_1 = 837
    PLAYER_SKILL_INFO_40_SKILL_0 = 838
    PLAYER_SKILL_INFO_40_SKILL_STEP_1 = 838
    PLAYER_SKILL_INFO_40_MINIMUM_0 = 839
    PLAYER_SKILL_INFO_40_MAXIMUM_1 = 839
    PLAYER_SKILL_INFO_40_PERMANENT_BONUS_0 = 840
    PLAYER_SKILL_INFO_40_TEMPORARY_BONUS_1 = 840
    PLAYER_SKILL_INFO_41_SKILL_0 = 841
    PLAYER_SKILL_INFO_41_SKILL_STEP_1 = 841
    PLAYER_SKILL_INFO_41_MINIMUM_0 = 842
    PLAYER_SKILL_INFO_41_MAXIMUM_1 = 842
    PLAYER_SKILL_INFO_41_PERMANENT_BONUS_0 = 843
    PLAYER_SKILL_INFO_41_TEMPORARY_BONUS_1 = 843
    PLAYER_SKILL_INFO_42_SKILL_0 = 844
    PLAYER_SKILL_INFO_42_SKILL_STEP_1 = 844
    PLAYER_SKILL_INFO_42_MINIMUM_0 = 845
    PLAYER_SKILL_INFO_42_MAXIMUM_1 = 845
    PLAYER_SKILL_INFO_42_PERMANENT_BONUS_0 = 846
    PLAYER_SKILL_INFO_42_TEMPORARY_BONUS_1 = 846
    PLAYER_SKILL_INFO_43_SKILL_0 = 847
    PLAYER_SKILL_INFO_43_SKILL_STEP_1 = 847
    PLAYER_SKILL_INFO_43_MINIMUM_0 = 848
    PLAYER_SKILL_INFO_43_MAXIMUM_1 = 848
    PLAYER_SKILL_INFO_43_PERMANENT_BONUS_0 = 849
    PLAYER_SKILL_INFO_43_TEMPORARY_BONUS_1 = 849
    PLAYER_SKILL_INFO_44_SKILL_0 = 850
    PLAYER_SKILL_INFO_44_SKILL_STEP_1 = 850
    PLAYER_SKILL_INFO_44_MINIMUM_0 = 851
    PLAYER_SKILL_INFO_44_MAXIMUM_1 = 851
    PLAYER_SKILL_INFO_44_PERMANENT_BONUS_0 = 852
    PLAYER_SKILL_INFO_44_TEMPORARY_BONUS_1 = 852
    PLAYER_SKILL_INFO_45_SKILL_0 = 853
    PLAYER_SKILL_INFO_45_SKILL_STEP_1 = 853
    PLAYER_SKILL_INFO_45_MINIMUM_0 = 854
    PLAYER_SKILL_INFO_45_MAXIMUM_1 = 854
    PLAYER_SKILL_INFO_45_PERMANENT_BONUS_0 = 855
    PLAYER_SKILL_INFO_45_TEMPORARY_BONUS_1 = 855
    PLAYER_SKILL_INFO_46_SKILL_0 = 856
    PLAYER_SKILL_INFO_46_SKILL_STEP_1 = 856
    PLAYER_SKILL_INFO_46_MINIMUM_0 = 857
    PLAYER_SKILL_INFO_46_MAXIMUM_1 = 857
    PLAYER_SKILL_INFO_46_PERMANENT_BONUS_0 = 858
    PLAYER_SKILL_INFO_46_TEMPORARY_BONUS_1 = 858
    PLAYER_SKILL_INFO_47_SKILL_0 = 859
    PLAYER_SKILL_INFO_47_SKILL_STEP_1 = 859
    PLAYER_SKILL_INFO_47_MINIMUM_0 = 860
    PLAYER_SKILL_INFO_47_MAXIMUM_1 = 860
    PLAYER_SKILL_INFO_47_PERMANENT_BONUS_0 = 861
    PLAYER_SKILL_INFO_47_TEMPORARY_BONUS_1 = 861
    PLAYER_SKILL_INFO_48_SKILL_0 = 862
    PLAYER_SKILL_INFO_48_SKILL_STEP_1 = 862
    PLAYER_SKILL_INFO_48_MINIMUM_0 = 863
    PLAYER_SKILL_INFO_48_MAXIMUM_1 = 863
    PLAYER_SKILL_INFO_48_PERMANENT_BONUS_0 = 864
    PLAYER_SKILL_INFO_48_TEMPORARY_BONUS_1 = 864
    PLAYER_SKILL_INFO_49_SKILL_0 = 865
    PLAYER_SKILL_INFO_49_SKILL_STEP_1 = 865
    PLAYER_SKILL_INFO_49_MINIMUM_0 = 866
    PLAYER_SKILL_INFO_49_MAXIMUM_1 = 866
    PLAYER_SKILL_INFO_49_PERMANENT_BONUS_0 = 867
    PLAYER_SKILL_INFO_49_TEMPORARY_BONUS_1 = 867
    PLAYER_SKILL_INFO_50_SKILL_0 = 868
    PLAYER_SKILL_INFO_50_SKILL_STEP_1 = 868
    PLAYER_SKILL_INFO_50_MINIMUM_0 = 869
    PLAYER_SKILL_INFO_50_MAXIMUM_1 = 869
    PLAYER_SKILL_INFO_50_PERMANENT_BONUS_0 = 870
    PLAYER_SKILL_INFO_50_TEMPORARY_BONUS_1 = 870
    PLAYER_SKILL_INFO_51_SKILL_0 = 871
    PLAYER_SKILL_INFO_51_SKILL_STEP_1 = 871
    PLAYER_SKILL_INFO_51_MINIMUM_0 = 872
    PLAYER_SKILL_INFO_51_MAXIMUM_1 = 872
    PLAYER_SKILL_INFO_51_PERMANENT_BONUS_0 = 873
    PLAYER_SKILL_INFO_51_TEMPORARY_BONUS_1 = 873
    PLAYER_SKILL_INFO_52_SKILL_0 = 874
    PLAYER_SKILL_INFO_52_SKILL_STEP_1 = 874
    PLAYER_SKILL_INFO_52_MINIMUM_0 = 875
    PLAYER_SKILL_INFO_52_MAXIMUM_1 = 875
    PLAYER_SKILL_INFO_52_PERMANENT_BONUS_0 = 876
    PLAYER_SKILL_INFO_52_TEMPORARY_BONUS_1 = 876
    PLAYER_SKILL_INFO_53_SKILL_0 = 877
    PLAYER_SKILL_INFO_53_SKILL_STEP_1 = 877
    PLAYER_SKILL_INFO_53_MINIMUM_0 = 878
    PLAYER_SKILL_INFO_53_MAXIMUM_1 = 878
    PLAYER_SKILL_INFO_53_PERMANENT_BONUS_0 = 879
    PLAYER_SKILL_INFO_53_TEMPORARY_BONUS_1 = 879
    PLAYER_SKILL_INFO_54_SKILL_0 = 880
    PLAYER_SKILL_INFO_54_SKILL_STEP_1 = 880
    PLAYER_SKILL_INFO_54_MINIMUM_0 = 881
    PLAYER_SKILL_INFO_54_MAXIMUM_1 = 881
    PLAYER_SKILL_INFO_54_PERMANENT_BONUS_0 = 882
    PLAYER_SKILL_INFO_54_TEMPORARY_BONUS_1 = 882
    PLAYER_SKILL_INFO_55_SKILL_0 = 883
    PLAYER_SKILL_INFO_55_SKILL_STEP_1 = 883
    PLAYER_SKILL_INFO_55_MINIMUM_0 = 884
    PLAYER_SKILL_INFO_55_MAXIMUM_1 = 884
    PLAYER_SKILL_INFO_55_PERMANENT_BONUS_0 = 885
    PLAYER_SKILL_INFO_55_TEMPORARY_BONUS_1 = 885
    PLAYER_SKILL_INFO_56_SKILL_0 = 886
    PLAYER_SKILL_INFO_56_SKILL_STEP_1 = 886
    PLAYER_SKILL_INFO_56_MINIMUM_0 = 887
    PLAYER_SKILL_INFO_56_MAXIMUM_1 = 887
    PLAYER_SKILL_INFO_56_PERMANENT_BONUS_0 = 888
    PLAYER_SKILL_INFO_56_TEMPORARY_BONUS_1 = 888
    PLAYER_SKILL_INFO_57_SKILL_0 = 889
    PLAYER_SKILL_INFO_57_SKILL_STEP_1 = 889
    PLAYER_SKILL_INFO_57_MINIMUM_0 = 890
    PLAYER_SKILL_INFO_57_MAXIMUM_1 = 890
    PLAYER_SKILL_INFO_57_PERMANENT_BONUS_0 = 891
    PLAYER_SKILL_INFO_57_TEMPORARY_BONUS_1 = 891
    PLAYER_SKILL_INFO_58_SKILL_0 = 892
    PLAYER_SKILL_INFO_58_SKILL_STEP_1 = 892
    PLAYER_SKILL_INFO_58_MINIMUM_0 = 893
    PLAYER_SKILL_INFO_58_MAXIMUM_1 = 893
    PLAYER_SKILL_INFO_58_PERMANENT_BONUS_0 = 894
    PLAYER_SKILL_INFO_58_TEMPORARY_BONUS_1 = 894
    PLAYER_SKILL_INFO_59_SKILL_0 = 895
    PLAYER_SKILL_INFO_59_SKILL_STEP_1 = 895
    PLAYER_SKILL_INFO_59_MINIMUM_0 = 896
    PLAYER_SKILL_INFO_59_MAXIMUM_1 = 896
    PLAYER_SKILL_INFO_59_PERMANENT_BONUS_0 = 897
    PLAYER_SKILL_INFO_59_TEMPORARY_BONUS_1 = 897
    PLAYER_SKILL_INFO_60_SKILL_0 = 898
    PLAYER_SKILL_INFO_60_SKILL_STEP_1 = 898
    PLAYER_SKILL_INFO_60_MINIMUM_0 = 899
    PLAYER_SKILL_INFO_60_MAXIMUM_1 = 899
    PLAYER_SKILL_INFO_60_PERMANENT_BONUS_0 = 900
    PLAYER_SKILL_INFO_60_TEMPORARY_BONUS_1 = 900
    PLAYER_SKILL_INFO_61_SKILL_0 = 901
    PLAYER_SKILL_INFO_61_SKILL_STEP_1 = 901
    PLAYER_SKILL_INFO_61_MINIMUM_0 = 902
    PLAYER_SKILL_INFO_61_MAXIMUM_1 = 902
    PLAYER_SKILL_INFO_61_PERMANENT_BONUS_0 = 903
    PLAYER_SKILL_INFO_61_TEMPORARY_BONUS_1 = 903
    PLAYER_SKILL_INFO_62_SKILL_0 = 904
    PLAYER_SKILL_INFO_62_SKILL_STEP_1 = 904
    PLAYER_SKILL_INFO_62_MINIMUM_0 = 905
    PLAYER_SKILL_INFO_62_MAXIMUM_1 = 905
    PLAYER_SKILL_INFO_62_PERMANENT_BONUS_0 = 906
    PLAYER_SKILL_INFO_62_TEMPORARY_BONUS_1 = 906
    PLAYER_SKILL_INFO_63_SKILL_0 = 907
    PLAYER_SKILL_INFO_63_SKILL_STEP_1 = 907
    PLAYER_SKILL_INFO_63_MINIMUM_0 = 908
    PLAYER_SKILL_INFO_63_MAXIMUM_1 = 908
    PLAYER_SKILL_INFO_63_PERMANENT_BONUS_0 = 909
    PLAYER_SKILL_INFO_63_TEMPORARY_BONUS_1 = 909
    PLAYER_SKILL_INFO_64_SKILL_0 = 910
    PLAYER_SKILL_INFO_64_SKILL_STEP_1 = 910
    PLAYER_SKILL_INFO_64_MINIMUM_0 = 911
    PLAYER_SKILL_INFO_64_MAXIMUM_1 = 911
    PLAYER_SKILL_INFO_64_PERMANENT_BONUS_0 = 912
    PLAYER_SKILL_INFO_64_TEMPORARY_BONUS_1 = 912
    PLAYER_SKILL_INFO_65_SKILL_0 = 913
    PLAYER_SKILL_INFO_65_SKILL_STEP_1 = 913
    PLAYER_SKILL_INFO_65_MINIMUM_0 = 914
    PLAYER_SKILL_INFO_65_MAXIMUM_1 = 914
    PLAYER_SKILL_INFO_65_PERMANENT_BONUS_0 = 915
    PLAYER_SKILL_INFO_65_TEMPORARY_BONUS_1 = 915
    PLAYER_SKILL_INFO_66_SKILL_0 = 916
    PLAYER_SKILL_INFO_66_SKILL_STEP_1 = 916
    PLAYER_SKILL_INFO_66_MINIMUM_0 = 917
    PLAYER_SKILL_INFO_66_MAXIMUM_1 = 917
    PLAYER_SKILL_INFO_66_PERMANENT_BONUS_0 = 918
    PLAYER_SKILL_INFO_66_TEMPORARY_BONUS_1 = 918
    PLAYER_SKILL_INFO_67_SKILL_0 = 919
    PLAYER_SKILL_INFO_67_SKILL_STEP_1 = 919
    PLAYER_SKILL_INFO_67_MINIMUM_0 = 920
    PLAYER_SKILL_INFO_67_MAXIMUM_1 = 920
    PLAYER_SKILL_INFO_67_PERMANENT_BONUS_0 = 921
    PLAYER_SKILL_INFO_67_TEMPORARY_BONUS_1 = 921
    PLAYER_SKILL_INFO_68_SKILL_0 = 922
    PLAYER_SKILL_INFO_68_SKILL_STEP_1 = 922
    PLAYER_SKILL_INFO_68_MINIMUM_0 = 923
    PLAYER_SKILL_INFO_68_MAXIMUM_1 = 923
    PLAYER_SKILL_INFO_68_PERMANENT_BONUS_0 = 924
    PLAYER_SKILL_INFO_68_TEMPORARY_BONUS_1 = 924
    PLAYER_SKILL_INFO_69_SKILL_0 = 925
    PLAYER_SKILL_INFO_69_SKILL_STEP_1 = 925
    PLAYER_SKILL_INFO_69_MINIMUM_0 = 926
    PLAYER_SKILL_INFO_69_MAXIMUM_1 = 926
    PLAYER_SKILL_INFO_69_PERMANENT_BONUS_0 = 927
    PLAYER_SKILL_INFO_69_TEMPORARY_BONUS_1 = 927
    PLAYER_SKILL_INFO_70_SKILL_0 = 928
    PLAYER_SKILL_INFO_70_SKILL_STEP_1 = 928
    PLAYER_SKILL_INFO_70_MINIMUM_0 = 929
    PLAYER_SKILL_INFO_70_MAXIMUM_1 = 929
    PLAYER_SKILL_INFO_70_PERMANENT_BONUS_0 = 930
    PLAYER_SKILL_INFO_70_TEMPORARY_BONUS_1 = 930
    PLAYER_SKILL_INFO_71_SKILL_0 = 931
    PLAYER_SKILL_INFO_71_SKILL_STEP_1 = 931
    PLAYER_SKILL_INFO_71_MINIMUM_0 = 932
    PLAYER_SKILL_INFO_71_MAXIMUM_1 = 932
    PLAYER_SKILL_INFO_71_PERMANENT_BONUS_0 = 933
    PLAYER_SKILL_INFO_71_TEMPORARY_BONUS_1 = 933
    PLAYER_SKILL_INFO_72_SKILL_0 = 934
    PLAYER_SKILL_INFO_72_SKILL_STEP_1 = 934
    PLAYER_SKILL_INFO_72_MINIMUM_0 = 935
    PLAYER_SKILL_INFO_72_MAXIMUM_1 = 935
    PLAYER_SKILL_INFO_72_PERMANENT_BONUS_0 = 936
    PLAYER_SKILL_INFO_72_TEMPORARY_BONUS_1 = 936
    PLAYER_SKILL_INFO_73_SKILL_0 = 937
    PLAYER_SKILL_INFO_73_SKILL_STEP_1 = 937
    PLAYER_SKILL_INFO_73_MINIMUM_0 = 938
    PLAYER_SKILL_INFO_73_MAXIMUM_1 = 938
    PLAYER_SKILL_INFO_73_PERMANENT_BONUS_0 = 939
    PLAYER_SKILL_INFO_73_TEMPORARY_BONUS_1 = 939
    PLAYER_SKILL_INFO_74_SKILL_0 = 940
    PLAYER_SKILL_INFO_74_SKILL_STEP_1 = 940
    PLAYER_SKILL_INFO_74_MINIMUM_0 = 941
    PLAYER_SKILL_INFO_74_MAXIMUM_1 = 941
    PLAYER_SKILL_INFO_74_PERMANENT_BONUS_0 = 942
    PLAYER_SKILL_INFO_74_TEMPORARY_BONUS_1 = 942
    PLAYER_SKILL_INFO_75_SKILL_0 = 943
    PLAYER_SKILL_INFO_75_SKILL_STEP_1 = 943
    PLAYER_SKILL_INFO_75_MINIMUM_0 = 944
    PLAYER_SKILL_INFO_75_MAXIMUM_1 = 944
    PLAYER_SKILL_INFO_75_PERMANENT_BONUS_0 = 945
    PLAYER_SKILL_INFO_75_TEMPORARY_BONUS_1 = 945
    PLAYER_SKILL_INFO_76_SKILL_0 = 946
    PLAYER_SKILL_INFO_76_SKILL_STEP_1 = 946
    PLAYER_SKILL_INFO_76_MINIMUM_0 = 947
    PLAYER_SKILL_INFO_76_MAXIMUM_1 = 947
    PLAYER_SKILL_INFO_76_PERMANENT_BONUS_0 = 948
    PLAYER_SKILL_INFO_76_TEMPORARY_BONUS_1 = 948
    PLAYER_SKILL_INFO_77_SKILL_0 = 949
    PLAYER_SKILL_INFO_77_SKILL_STEP_1 = 949
    PLAYER_SKILL_INFO_77_MINIMUM_0 = 950
    PLAYER_SKILL_INFO_77_MAXIMUM_1 = 950
    PLAYER_SKILL_INFO_77_PERMANENT_BONUS_0 = 951
    PLAYER_SKILL_INFO_77_TEMPORARY_BONUS_1 = 951
    PLAYER_SKILL_INFO_78_SKILL_0 = 952
    PLAYER_SKILL_INFO_78_SKILL_STEP_1 = 952
    PLAYER_SKILL_INFO_78_MINIMUM_0 = 953
    PLAYER_SKILL_INFO_78_MAXIMUM_1 = 953
    PLAYER_SKILL_INFO_78_PERMANENT_BONUS_0 = 954
    PLAYER_SKILL_INFO_78_TEMPORARY_BONUS_1 = 954
    PLAYER_SKILL_INFO_79_SKILL_0 = 955
    PLAYER_SKILL_INFO_79_SKILL_STEP_1 = 955
    PLAYER_SKILL_INFO_79_MINIMUM_0 = 956
    PLAYER_SKILL_INFO_79_MAXIMUM_1 = 956
    PLAYER_SKILL_INFO_79_PERMANENT_BONUS_0 = 957
    PLAYER_SKILL_INFO_79_TEMPORARY_BONUS_1 = 957
    PLAYER_SKILL_INFO_80_SKILL_0 = 958
    PLAYER_SKILL_INFO_80_SKILL_STEP_1 = 958
    PLAYER_SKILL_INFO_80_MINIMUM_0 = 959
    PLAYER_SKILL_INFO_80_MAXIMUM_1 = 959
    PLAYER_SKILL_INFO_80_PERMANENT_BONUS_0 = 960
    PLAYER_SKILL_INFO_80_TEMPORARY_BONUS_1 = 960
    PLAYER_SKILL_INFO_81_SKILL_0 = 961
    PLAYER_SKILL_INFO_81_SKILL_STEP_1 = 961
    PLAYER_SKILL_INFO_81_MINIMUM_0 = 962
    PLAYER_SKILL_INFO_81_MAXIMUM_1 = 962
    PLAYER_SKILL_INFO_81_PERMANENT_BONUS_0 = 963
    PLAYER_SKILL_INFO_81_TEMPORARY_BONUS_1 = 963
    PLAYER_SKILL_INFO_82_SKILL_0 = 964
    PLAYER_SKILL_INFO_82_SKILL_STEP_1 = 964
    PLAYER_SKILL_INFO_82_MINIMUM_0 = 965
    PLAYER_SKILL_INFO_82_MAXIMUM_1 = 965
    PLAYER_SKILL_INFO_82_PERMANENT_BONUS_0 = 966
    PLAYER_SKILL_INFO_82_TEMPORARY_BONUS_1 = 966
    PLAYER_SKILL_INFO_83_SKILL_0 = 967
    PLAYER_SKILL_INFO_83_SKILL_STEP_1 = 967
    PLAYER_SKILL_INFO_83_MINIMUM_0 = 968
    PLAYER_SKILL_INFO_83_MAXIMUM_1 = 968
    PLAYER_SKILL_INFO_83_PERMANENT_BONUS_0 = 969
    PLAYER_SKILL_INFO_83_TEMPORARY_BONUS_1 = 969
    PLAYER_SKILL_INFO_84_SKILL_0 = 970
    PLAYER_SKILL_INFO_84_SKILL_STEP_1 = 970
    PLAYER_SKILL_INFO_84_MINIMUM_0 = 971
    PLAYER_SKILL_INFO_84_MAXIMUM_1 = 971
    PLAYER_SKILL_INFO_84_PERMANENT_BONUS_0 = 972
    PLAYER_SKILL_INFO_84_TEMPORARY_BONUS_1 = 972
    PLAYER_SKILL_INFO_85_SKILL_0 = 973
    PLAYER_SKILL_INFO_85_SKILL_STEP_1 = 973
    PLAYER_SKILL_INFO_85_MINIMUM_0 = 974
    PLAYER_SKILL_INFO_85_MAXIMUM_1 = 974
    PLAYER_SKILL_INFO_85_PERMANENT_BONUS_0 = 975
    PLAYER_SKILL_INFO_85_TEMPORARY_BONUS_1 = 975
    PLAYER_SKILL_INFO_86_SKILL_0 = 976
    PLAYER_SKILL_INFO_86_SKILL_STEP_1 = 976
    PLAYER_SKILL_INFO_86_MINIMUM_0 = 977
    PLAYER_SKILL_INFO_86_MAXIMUM_1 = 977
    PLAYER_SKILL_INFO_86_PERMANENT_BONUS_0 = 978
    PLAYER_SKILL_INFO_86_TEMPORARY_BONUS_1 = 978
    PLAYER_SKILL_INFO_87_SKILL_0 = 979
    PLAYER_SKILL_INFO_87_SKILL_STEP_1 = 979
    PLAYER_SKILL_INFO_87_MINIMUM_0 = 980
    PLAYER_SKILL_INFO_87_MAXIMUM_1 = 980
    PLAYER_SKILL_INFO_87_PERMANENT_BONUS_0 = 981
    PLAYER_SKILL_INFO_87_TEMPORARY_BONUS_1 = 981
    PLAYER_SKILL_INFO_88_SKILL_0 = 982
    PLAYER_SKILL_INFO_88_SKILL_STEP_1 = 982
    PLAYER_SKILL_INFO_88_MINIMUM_0 = 983
    PLAYER_SKILL_INFO_88_MAXIMUM_1 = 983
    PLAYER_SKILL_INFO_88_PERMANENT_BONUS_0 = 984
    PLAYER_SKILL_INFO_88_TEMPORARY_BONUS_1 = 984
    PLAYER_SKILL_INFO_89_SKILL_0 = 985
    PLAYER_SKILL_INFO_89_SKILL_STEP_1 = 985
    PLAYER_SKILL_INFO_89_MINIMUM_0 = 986
    PLAYER_SKILL_INFO_89_MAXIMUM_1 = 986
    PLAYER_SKILL_INFO_89_PERMANENT_BONUS_0 = 987
    PLAYER_SKILL_INFO_89_TEMPORARY_BONUS_1 = 987
    PLAYER_SKILL_INFO_90_SKILL_0 = 988
    PLAYER_SKILL_INFO_90_SKILL_STEP_1 = 988
    PLAYER_SKILL_INFO_90_MINIMUM_0 = 989
    PLAYER_SKILL_INFO_90_MAXIMUM_1 = 989
    PLAYER_SKILL_INFO_90_PERMANENT_BONUS_0 = 990
    PLAYER_SKILL_INFO_90_TEMPORARY_BONUS_1 = 990
    PLAYER_SKILL_INFO_91_SKILL_0 = 991
    PLAYER_SKILL_INFO_91_SKILL_STEP_1 = 991
    PLAYER_SKILL_INFO_91_MINIMUM_0 = 992
    PLAYER_SKILL_INFO_91_MAXIMUM_1 = 992
    PLAYER_SKILL_INFO_91_PERMANENT_BONUS_0 = 993
    PLAYER_SKILL_INFO_91_TEMPORARY_BONUS_1 = 993
    PLAYER_SKILL_INFO_92_SKILL_0 = 994
    PLAYER_SKILL_INFO_92_SKILL_STEP_1 = 994
    PLAYER_SKILL_INFO_92_MINIMUM_0 = 995
    PLAYER_SKILL_INFO_92_MAXIMUM_1 = 995
    PLAYER_SKILL_INFO_92_PERMANENT_BONUS_0 = 996
    PLAYER_SKILL_INFO_92_TEMPORARY_BONUS_1 = 996
    PLAYER_SKILL_INFO_93_SKILL_0 = 997
    PLAYER_SKILL_INFO_93_SKILL_STEP_1 = 997
    PLAYER_SKILL_INFO_93_MINIMUM_0 = 998
    PLAYER_SKILL_INFO_93_MAXIMUM_1 = 998
    PLAYER_SKILL_INFO_93_PERMANENT_BONUS_0 = 999
    PLAYER_SKILL_INFO_93_TEMPORARY_BONUS_1 = 999
    PLAYER_SKILL_INFO_94_SKILL_0 = 1000
    PLAYER_SKILL_INFO_94_SKILL_STEP_1 = 1000
    PLAYER_SKILL_INFO_94_MINIMUM_0 = 1001
    PLAYER_SKILL_INFO_94_MAXIMUM_1 = 1001
    PLAYER_SKILL_INFO_94_PERMANENT_BONUS_0 = 1002
    PLAYER_SKILL_INFO_94_TEMPORARY_BONUS_1 = 1002
    PLAYER_SKILL_INFO_95_SKILL_0 = 1003
    PLAYER_SKILL_INFO_95_SKILL_STEP_1 = 1003
    PLAYER_SKILL_INFO_95_MINIMUM_0 = 1004
    PLAYER_SKILL_INFO_95_MAXIMUM_1 = 1004
    PLAYER_SKILL_INFO_95_PERMANENT_BONUS_0 = 1005
    PLAYER_SKILL_INFO_95_TEMPORARY_BONUS_1 = 1005
    PLAYER_SKILL_INFO_96_SKILL_0 = 1006
    PLAYER_SKILL_INFO_96_SKILL_STEP_1 = 1006
    PLAYER_SKILL_INFO_96_MINIMUM_0 = 1007
    PLAYER_SKILL_INFO_96_MAXIMUM_1 = 1007
    PLAYER_SKILL_INFO_96_PERMANENT_BONUS_0 = 1008
    PLAYER_SKILL_INFO_96_TEMPORARY_BONUS_1 = 1008
    PLAYER_SKILL_INFO_97_SKILL_0 = 1009
    PLAYER_SKILL_INFO_97_SKILL_STEP_1 = 1009
    PLAYER_SKILL_INFO_97_MINIMUM_0 = 1010
    PLAYER_SKILL_INFO_97_MAXIMUM_1 = 1010
    PLAYER_SKILL_INFO_97_PERMANENT_BONUS_0 = 1011
    PLAYER_SKILL_INFO_97_TEMPORARY_BONUS_1 = 1011
    PLAYER_SKILL_INFO_98_SKILL_0 = 1012
    PLAYER_SKILL_INFO_98_SKILL_STEP_1 = 1012
    PLAYER_SKILL_INFO_98_MINIMUM_0 = 1013
    PLAYER_SKILL_INFO_98_MAXIMUM_1 = 1013
    PLAYER_SKILL_INFO_98_PERMANENT_BONUS_0 = 1014
    PLAYER_SKILL_INFO_98_TEMPORARY_BONUS_1 = 1014
    PLAYER_SKILL_INFO_99_SKILL_0 = 1015
    PLAYER_SKILL_INFO_99_SKILL_STEP_1 = 1015
    PLAYER_SKILL_INFO_99_MINIMUM_0 = 1016
    PLAYER_SKILL_INFO_99_MAXIMUM_1 = 1016
    PLAYER_SKILL_INFO_99_PERMANENT_BONUS_0 = 1017
    PLAYER_SKILL_INFO_99_TEMPORARY_BONUS_1 = 1017
    PLAYER_SKILL_INFO_100_SKILL_0 = 1018
    PLAYER_SKILL_INFO_100_SKILL_STEP_1 = 1018
    PLAYER_SKILL_INFO_100_MINIMUM_0 = 1019
    PLAYER_SKILL_INFO_100_MAXIMUM_1 = 1019
    PLAYER_SKILL_INFO_100_PERMANENT_BONUS_0 = 1020
    PLAYER_SKILL_INFO_100_TEMPORARY_BONUS_1 = 1020
    PLAYER_SKILL_INFO_101_SKILL_0 = 1021
    PLAYER_SKILL_INFO_101_SKILL_STEP_1 = 1021
    PLAYER_SKILL_INFO_101_MINIMUM_0 = 1022
    PLAYER_SKILL_INFO_101_MAXIMUM_1 = 1022
    PLAYER_SKILL_INFO_101_PERMANENT_BONUS_0 = 1023
    PLAYER_SKILL_INFO_101_TEMPORARY_BONUS_1 = 1023
    PLAYER_SKILL_INFO_102_SKILL_0 = 1024
    PLAYER_SKILL_INFO_102_SKILL_STEP_1 = 1024
    PLAYER_SKILL_INFO_102_MINIMUM_0 = 1025
    PLAYER_SKILL_INFO_102_MAXIMUM_1 = 1025
    PLAYER_SKILL_INFO_102_PERMANENT_BONUS_0 = 1026
    PLAYER_SKILL_INFO_102_TEMPORARY_BONUS_1 = 1026
    PLAYER_SKILL_INFO_103_SKILL_0 = 1027
    PLAYER_SKILL_INFO_103_SKILL_STEP_1 = 1027
    PLAYER_SKILL_INFO_103_MINIMUM_0 = 1028
    PLAYER_SKILL_INFO_103_MAXIMUM_1 = 1028
    PLAYER_SKILL_INFO_103_PERMANENT_BONUS_0 = 1029
    PLAYER_SKILL_INFO_103_TEMPORARY_BONUS_1 = 1029
    PLAYER_SKILL_INFO_104_SKILL_0 = 1030
    PLAYER_SKILL_INFO_104_SKILL_STEP_1 = 1030
    PLAYER_SKILL_INFO_104_MINIMUM_0 = 1031
    PLAYER_SKILL_INFO_104_MAXIMUM_1 = 1031
    PLAYER_SKILL_INFO_104_PERMANENT_BONUS_0 = 1032
    PLAYER_SKILL_INFO_104_TEMPORARY_BONUS_1 = 1032
    PLAYER_SKILL_INFO_105_SKILL_0 = 1033
    PLAYER_SKILL_INFO_105_SKILL_STEP_1 = 1033
    PLAYER_SKILL_INFO_105_MINIMUM_0 = 1034
    PLAYER_SKILL_INFO_105_MAXIMUM_1 = 1034
    PLAYER_SKILL_INFO_105_PERMANENT_BONUS_0 = 1035
    PLAYER_SKILL_INFO_105_TEMPORARY_BONUS_1 = 1035
    PLAYER_SKILL_INFO_106_SKILL_0 = 1036
    PLAYER_SKILL_INFO_106_SKILL_STEP_1 = 1036
    PLAYER_SKILL_INFO_106_MINIMUM_0 = 1037
    PLAYER_SKILL_INFO_106_MAXIMUM_1 = 1037
    PLAYER_SKILL_INFO_106_PERMANENT_BONUS_0 = 1038
    PLAYER_SKILL_INFO_106_TEMPORARY_BONUS_1 = 1038
    PLAYER_SKILL_INFO_107_SKILL_0 = 1039
    PLAYER_SKILL_INFO_107_SKILL_STEP_1 = 1039
    PLAYER_SKILL_INFO_107_MINIMUM_0 = 1040
    PLAYER_SKILL_INFO_107_MAXIMUM_1 = 1040
    PLAYER_SKILL_INFO_107_PERMANENT_BONUS_0 = 1041
    PLAYER_SKILL_INFO_107_TEMPORARY_BONUS_1 = 1041
    PLAYER_SKILL_INFO_108_SKILL_0 = 1042
    PLAYER_SKILL_INFO_108_SKILL_STEP_1 = 1042
    PLAYER_SKILL_INFO_108_MINIMUM_0 = 1043
    PLAYER_SKILL_INFO_108_MAXIMUM_1 = 1043
    PLAYER_SKILL_INFO_108_PERMANENT_BONUS_0 = 1044
    PLAYER_SKILL_INFO_108_TEMPORARY_BONUS_1 = 1044
    PLAYER_SKILL_INFO_109_SKILL_0 = 1045
    PLAYER_SKILL_INFO_109_SKILL_STEP_1 = 1045
    PLAYER_SKILL_INFO_109_MINIMUM_0 = 1046
    PLAYER_SKILL_INFO_109_MAXIMUM_1 = 1046
    PLAYER_SKILL_INFO_109_PERMANENT_BONUS_0 = 1047
    PLAYER_SKILL_INFO_109_TEMPORARY_BONUS_1 = 1047
    PLAYER_SKILL_INFO_110_SKILL_0 = 1048
    PLAYER_SKILL_INFO_110_SKILL_STEP_1 = 1048
    PLAYER_SKILL_INFO_110_MINIMUM_0 = 1049
    PLAYER_SKILL_INFO_110_MAXIMUM_1 = 1049
    PLAYER_SKILL_INFO_110_PERMANENT_BONUS_0 = 1050
    PLAYER_SKILL_INFO_110_TEMPORARY_BONUS_1 = 1050
    PLAYER_SKILL_INFO_111_SKILL_0 = 1051
    PLAYER_SKILL_INFO_111_SKILL_STEP_1 = 1051
    PLAYER_SKILL_INFO_111_MINIMUM_0 = 1052
    PLAYER_SKILL_INFO_111_MAXIMUM_1 = 1052
    PLAYER_SKILL_INFO_111_PERMANENT_BONUS_0 = 1053
    PLAYER_SKILL_INFO_111_TEMPORARY_BONUS_1 = 1053
    PLAYER_SKILL_INFO_112_SKILL_0 = 1054
    PLAYER_SKILL_INFO_112_SKILL_STEP_1 = 1054
    PLAYER_SKILL_INFO_112_MINIMUM_0 = 1055
    PLAYER_SKILL_INFO_112_MAXIMUM_1 = 1055
    PLAYER_SKILL_INFO_112_PERMANENT_BONUS_0 = 1056
    PLAYER_SKILL_INFO_112_TEMPORARY_BONUS_1 = 1056
    PLAYER_SKILL_INFO_113_SKILL_0 = 1057
    PLAYER_SKILL_INFO_113_SKILL_STEP_1 = 1057
    PLAYER_SKILL_INFO_113_MINIMUM_0 = 1058
    PLAYER_SKILL_INFO_113_MAXIMUM_1 = 1058
    PLAYER_SKILL_INFO_113_PERMANENT_BONUS_0 = 1059
    PLAYER_SKILL_INFO_113_TEMPORARY_BONUS_1 = 1059
    PLAYER_SKILL_INFO_114_SKILL_0 = 1060
    PLAYER_SKILL_INFO_114_SKILL_STEP_1 = 1060
    PLAYER_SKILL_INFO_114_MINIMUM_0 = 1061
    PLAYER_SKILL_INFO_114_MAXIMUM_1 = 1061
    PLAYER_SKILL_INFO_114_PERMANENT_BONUS_0 = 1062
    PLAYER_SKILL_INFO_114_TEMPORARY_BONUS_1 = 1062
    PLAYER_SKILL_INFO_115_SKILL_0 = 1063
    PLAYER_SKILL_INFO_115_SKILL_STEP_1 = 1063
    PLAYER_SKILL_INFO_115_MINIMUM_0 = 1064
    PLAYER_SKILL_INFO_115_MAXIMUM_1 = 1064
    PLAYER_SKILL_INFO_115_PERMANENT_BONUS_0 = 1065
    PLAYER_SKILL_INFO_115_TEMPORARY_BONUS_1 = 1065
    PLAYER_SKILL_INFO_116_SKILL_0 = 1066
    PLAYER_SKILL_INFO_116_SKILL_STEP_1 = 1066
    PLAYER_SKILL_INFO_116_MINIMUM_0 = 1067
    PLAYER_SKILL_INFO_116_MAXIMUM_1 = 1067
    PLAYER_SKILL_INFO_116_PERMANENT_BONUS_0 = 1068
    PLAYER_SKILL_INFO_116_TEMPORARY_BONUS_1 = 1068
    PLAYER_SKILL_INFO_117_SKILL_0 = 1069
    PLAYER_SKILL_INFO_117_SKILL_STEP_1 = 1069
    PLAYER_SKILL_INFO_117_MINIMUM_0 = 1070
    PLAYER_SKILL_INFO_117_MAXIMUM_1 = 1070
    PLAYER_SKILL_INFO_117_PERMANENT_BONUS_0 = 1071
    PLAYER_SKILL_INFO_117_TEMPORARY_BONUS_1 = 1071
    PLAYER_SKILL_INFO_118_SKILL_0 = 1072
    PLAYER_SKILL_INFO_118_SKILL_STEP_1 = 1072
    PLAYER_SKILL_INFO_118_MINIMUM_0 = 1073
    PLAYER_SKILL_INFO_118_MAXIMUM_1 = 1073
    PLAYER_SKILL_INFO_118_PERMANENT_BONUS_0 = 1074
    PLAYER_SKILL_INFO_118_TEMPORARY_BONUS_1 = 1074
    PLAYER_SKILL_INFO_119_SKILL_0 = 1075
    PLAYER_SKILL_INFO_119_SKILL_STEP_1 = 1075
    PLAYER_SKILL_INFO_119_MINIMUM_0 = 1076
    PLAYER_SKILL_INFO_119_MAXIMUM_1 = 1076
    PLAYER_SKILL_INFO_119_PERMANENT_BONUS_0 = 1077
    PLAYER_SKILL_INFO_119_TEMPORARY_BONUS_1 = 1077
    PLAYER_SKILL_INFO_120_SKILL_0 = 1078
    PLAYER_SKILL_INFO_120_SKILL_STEP_1 = 1078
    PLAYER_SKILL_INFO_120_MINIMUM_0 = 1079
    PLAYER_SKILL_INFO_120_MAXIMUM_1 = 1079
    PLAYER_SKILL_INFO_120_PERMANENT_BONUS_0 = 1080
    PLAYER_SKILL_INFO_120_TEMPORARY_BONUS_1 = 1080
    PLAYER_SKILL_INFO_121_SKILL_0 = 1081
    PLAYER_SKILL_INFO_121_SKILL_STEP_1 = 1081
    PLAYER_SKILL_INFO_121_MINIMUM_0 = 1082
    PLAYER_SKILL_INFO_121_MAXIMUM_1 = 1082
    PLAYER_SKILL_INFO_121_PERMANENT_BONUS_0 = 1083
    PLAYER_SKILL_INFO_121_TEMPORARY_BONUS_1 = 1083
    PLAYER_SKILL_INFO_122_SKILL_0 = 1084
    PLAYER_SKILL_INFO_122_SKILL_STEP_1 = 1084
    PLAYER_SKILL_INFO_122_MINIMUM_0 = 1085
    PLAYER_SKILL_INFO_122_MAXIMUM_1 = 1085
    PLAYER_SKILL_INFO_122_PERMANENT_BONUS_0 = 1086
    PLAYER_SKILL_INFO_122_TEMPORARY_BONUS_1 = 1086
    PLAYER_SKILL_INFO_123_SKILL_0 = 1087
    PLAYER_SKILL_INFO_123_SKILL_STEP_1 = 1087
    PLAYER_SKILL_INFO_123_MINIMUM_0 = 1088
    PLAYER_SKILL_INFO_123_MAXIMUM_1 = 1088
    PLAYER_SKILL_INFO_123_PERMANENT_BONUS_0 = 1089
    PLAYER_SKILL_INFO_123_TEMPORARY_BONUS_1 = 1089
    PLAYER_SKILL_INFO_124_SKILL_0 = 1090
    PLAYER_SKILL_INFO_124_SKILL_STEP_1 = 1090
    PLAYER_SKILL_INFO_124_MINIMUM_0 = 1091
    PLAYER_SKILL_INFO_124_MAXIMUM_1 = 1091
    PLAYER_SKILL_INFO_124_PERMANENT_BONUS_0 = 1092
    PLAYER_SKILL_INFO_124_TEMPORARY_BONUS_1 = 1092
    PLAYER_SKILL_INFO_125_SKILL_0 = 1093
    PLAYER_SKILL_INFO_125_SKILL_STEP_1 = 1093
    PLAYER_SKILL_INFO_125_MINIMUM_0 = 1094
    PLAYER_SKILL_INFO_125_MAXIMUM_1 = 1094
    PLAYER_SKILL_INFO_125_PERMANENT_BONUS_0 = 1095
    PLAYER_SKILL_INFO_125_TEMPORARY_BONUS_1 = 1095
    PLAYER_SKILL_INFO_126_SKILL_0 = 1096
    PLAYER_SKILL_INFO_126_SKILL_STEP_1 = 1096
    PLAYER_SKILL_INFO_126_MINIMUM_0 = 1097
    PLAYER_SKILL_INFO_126_MAXIMUM_1 = 1097
    PLAYER_SKILL_INFO_126_PERMANENT_BONUS_0 = 1098
    PLAYER_SKILL_INFO_126_TEMPORARY_BONUS_1 = 1098
    PLAYER_SKILL_INFO_127_SKILL_0 = 1099
    PLAYER_SKILL_INFO_127_SKILL_STEP_1 = 1099
    PLAYER_SKILL_INFO_127_MINIMUM_0 = 1100
    PLAYER_SKILL_INFO_127_MAXIMUM_1 = 1100
    PLAYER_SKILL_INFO_127_PERMANENT_BONUS_0 = 1101
    PLAYER_SKILL_INFO_127_TEMPORARY_BONUS_1 = 1101
    PLAYER_CHARACTER_POINTS1 = 1102
    PLAYER_CHARACTER_POINTS2 = 1103
    PLAYER_TRACK_CREATURES = 1104
    PLAYER_TRACK_RESOURCES = 1105
    PLAYER_BLOCK_PERCENTAGE = 1106
    PLAYER_DODGE_PERCENTAGE = 1107
    PLAYER_PARRY_PERCENTAGE = 1108
    PLAYER_CRIT_PERCENTAGE = 1109
    PLAYER_RANGED_CRIT_PERCENTAGE = 1110
    PLAYER_EXPLORED_ZONES_1 = 1111
    PLAYER_REST_STATE_EXPERIENCE = 1175
    PLAYER_FIELD_COINAGE = 1176
    PLAYER_FIELD_POSSTAT0 = 1177
    PLAYER_FIELD_POSSTAT1 = 1178
    PLAYER_FIELD_POSSTAT2 = 1179
    PLAYER_FIELD_POSSTAT3 = 1180
    PLAYER_FIELD_POSSTAT4 = 1181
    PLAYER_FIELD_NEGSTAT0 = 1182
    PLAYER_FIELD_NEGSTAT1 = 1183
    PLAYER_FIELD_NEGSTAT2 = 1184
    PLAYER_FIELD_NEGSTAT3 = 1185
    PLAYER_FIELD_NEGSTAT4 = 1186
    PLAYER_FIELD_RESISTANCEBUFFMODSPOSITIVE = 1187
    PLAYER_FIELD_RESISTANCEBUFFMODSNEGATIVE = 1194
    PLAYER_FIELD_MOD_DAMAGE_DONE_POS = 1201
    PLAYER_FIELD_MOD_DAMAGE_DONE_NEG = 1208
    PLAYER_FIELD_MOD_DAMAGE_DONE_PCT = 1215
    PLAYER_FIELD_BYTES = 1222
    PLAYER_AMMO_ID = 1223
    PLAYER_SELF_RES_SPELL = 1224
    PLAYER_FIELD_PVP_MEDALS = 1225
    PLAYER_FIELD_BUYBACK_PRICE_1 = 1226
    PLAYER_FIELD_BUYBACK_TIMESTAMP_1 = 1238
    PLAYER_FIELD_SESSION_KILLS = 1250
    PLAYER_FIELD_YESTERDAY_KILLS = 1251
    PLAYER_FIELD_LAST_WEEK_KILLS = 1252
    PLAYER_FIELD_THIS_WEEK_KILLS = 1253
    PLAYER_FIELD_THIS_WEEK_CONTRIBUTION = 1254
    PLAYER_FIELD_LIFETIME_HONORBALE_KILLS = 1255
    PLAYER_FIELD_LIFETIME_DISHONORBALE_KILLS = 1256
    PLAYER_FIELD_YESTERDAY_CONTRIBUTION = 1257
    PLAYER_FIELD_LAST_WEEK_CONTRIBUTION = 1258
    PLAYER_FIELD_LAST_WEEK_RANK = 1259
    PLAYER_FIELD_BYTES2 = 1260
    PLAYER_FIELD_WATCHED_FACTION_INDEX = 1261
    PLAYER_FIELD_COMBAT_RATING_1 = 1262
    GAME_OBJECT_CREATED_BY = 6
    GAME_OBJECT_DISPLAYID = 8
    GAME_OBJECT_FLAGS = 9
    GAME_OBJECT_ROTATION = 10
    GAME_OBJECT_STATE = 14
    GAME_OBJECT_POS_X = 15
    GAME_OBJECT_POS_Y = 16
    GAME_OBJECT_POS_Z = 17
    GAME_OBJECT_FACING = 18
    GAME_OBJECT_DYN_FLAGS = 19
    GAME_OBJECT_FACTION = 20
    GAME_OBJECT_TYPE_ID = 21
    GAME_OBJECT_LEVEL = 22
    GAME_OBJECT_ARTKIT = 23
    GAME_OBJECT_ANIMPROGRESS = 24
    DYNAMIC_OBJECT_CASTER = 6
    DYNAMIC_OBJECT_BYTES = 8
    DYNAMIC_OBJECT_SPELLID = 9
    DYNAMIC_OBJECT_RADIUS = 10
    DYNAMIC_OBJECT_POS_X = 11
    DYNAMIC_OBJECT_POS_Y = 12
    DYNAMIC_OBJECT_POS_Z = 13
    DYNAMIC_OBJECT_FACING = 14
    CORPSE_OWNER = 6
    CORPSE_FACING = 8
    CORPSE_POS_X = 9
    CORPSE_POS_Y = 10
    CORPSE_POS_Z = 11
    CORPSE_DISPLAY_ID = 12
    CORPSE_ITEM = 13
    CORPSE_BYTES_1 = 32
    CORPSE_BYTES_2 = 33
    CORPSE_GUILD = 34
    CORPSE_FLAGS = 35
    CORPSE_DYNAMIC_FLAGS = 36


class AccountDataType(enum.Enum):
    GLOBAL_CONFIG_CACHE = 0
    PER_CHARACTER_CONFIG_CACHE = 1
    GLOBAL_BINDINGS_CACHE = 2
    PER_CHARACTER_BINDINGS_CACHE = 3
    GLOBAL_MACROS_CACHE = 4
    PER_CHARACTER_MACROS_CACHE = 5
    PER_CHARACTER_LAYOUT_CACHE = 6
    PER_CHARACTER_CHAT_CACHE = 7
    NUM_ACCOUNT_DATA_TYPES = 8


class ActivateTaxiReply(enum.Enum):
    OK = 0
    UNSPECIFIED_SERVER_ERROR = 1
    NO_SUCH_PATH = 2
    NOT_ENOUGH_MONEY = 3
    TOO_FAR_AWAY = 4
    NO_VENDOR_NEARBY = 5
    NOT_VISITED = 6
    PLAYER_BUSY = 7
    PLAYER_ALREADY_MOUNTED = 8
    PLAYER_SHAPE_SHIFTED = 9
    PLAYER_MOVING = 10
    SAME_NODE = 11
    NOT_STANDING = 12


class AddonType(enum.Enum):
    BANNED = 0
    ENABLED = 1
    BLIZZARD = 2


class AiReaction(enum.Enum):
    ALERT = 0
    FRIENDLY = 1
    HOSTILE = 2
    AFRAID = 3
    DESTROY = 4


class Area(enum.Enum):
    NONE = 0
    DUN_MOROGH = 1
    LONGSHORE = 2
    BADLANDS = 3
    BLASTED_LANDS = 4
    BLACKWATER_COVE = 7
    SWAMP_OF_SORROWS = 8
    NORTHSHIRE_VALLEY = 9
    DUSKWOOD = 10
    WETLANDS = 11
    ELWYNN_FOREST = 12
    THE_WORLD_TREE = 13
    DUROTAR = 14
    DUSTWALLOW_MARSH = 15
    AZSHARA = 16
    THE_BARRENS = 17
    CRYSTAL_LAKE = 18
    ZUL_GURUB0 = 19
    MOONBROOK = 20
    KUL_TIRAS = 21
    PROGRAMMER_ISLE = 22
    NORTHSHIRE_RIVER = 23
    NORTHSHIRE_ABBEY = 24
    BLACKROCK_MOUNTAIN0 = 25
    LIGHTHOUSE = 26
    WESTERN_PLAGUELANDS = 28
    NINE = 30
    THE_CEMETARY = 32
    STRANGLETHORN_VALE = 33
    ECHO_RIDGE_MINE = 34
    BOOTY_BAY = 35
    ALTERAC_MOUNTAINS = 36
    LAKE_NAZFERITI = 37
    LOCH_MODAN = 38
    WESTFALL0 = 40
    DEADWIND_PASS = 41
    DARKSHIRE = 42
    WILD_SHORE = 43
    REDRIDGE_MOUNTAINS = 44
    ARATHI_HIGHLANDS = 45
    BURNING_STEPPES = 46
    THE_HINTERLANDS = 47
    DEAD_MANS_HOLE = 49
    SEARING_GORGE = 51
    THIEVES_CAMP = 53
    JASPERLODE_MINE = 54
    VALLEY_OF_HEROES_UNUSED = 55
    HEROES_VIGIL = 56
    FARGODEEP_MINE = 57
    NORTHSHIRE_VINEYARDS = 59
    FORESTS_EDGE = 60
    THUNDER_FALLS = 61
    BRACKWELL_PUMPKIN_PATCH = 62
    THE_STONEFIELD_FARM = 63
    THE_MACLURE_VINEYARDS = 64
    ON_MAP_DUNGEON0 = 65
    ON_MAP_DUNGEON1 = 66
    ON_MAP_DUNGEON2 = 67
    LAKE_EVERSTILL = 68
    LAKESHIRE = 69
    STONEWATCH = 70
    STONEWATCH_FALLS = 71
    THE_DARK_PORTAL = 72
    THE_TAINTED_SCAR = 73
    POOL_OF_TEARS = 74
    STONARD = 75
    FALLOW_SANCTUARY = 76
    ANVILMAR = 77
    STORMWIND_MOUNTAINS = 80
    JEFF_NE_QUADRANT_CHANGED = 81
    JEFF_NW_QUADRANT = 82
    JEFF_SE_QUADRANT = 83
    JEFF_SW_QUADRANT = 84
    TIRISFAL_GLADES = 85
    STONE_CAIRN_LAKE = 86
    GOLDSHIRE = 87
    EASTVALE_LOGGING_CAMP = 88
    MIRROR_LAKE_ORCHARD = 89
    TOWER_OF_AZORA = 91
    MIRROR_LAKE = 92
    VUL_GOL_OGRE_MOUND = 93
    RAVEN_HILL = 94
    REDRIDGE_CANYONS = 95
    TOWER_OF_ILGALAR = 96
    ALTHERS_MILL = 97
    RETHBAN_CAVERNS = 98
    REBEL_CAMP = 99
    NESINGWARYS_EXPEDITION = 100
    KURZENS_COMPOUND = 101
    RUINS_OF_ZUL_KUNDA = 102
    RUINS_OF_ZUL_MAMWE = 103
    THE_VILE_REEF = 104
    MOSH_OGG_OGRE_MOUND = 105
    THE_STOCKPILE = 106
    SALDEANS_FARM = 107
    SENTINEL_HILL = 108
    FURLBROWS_PUMPKIN_FARM = 109
    JANGOLODE_MINE = 111
    GOLD_COAST_QUARRY = 113
    WESTFALL_LIGHTHOUSE = 115
    MISTY_VALLEY = 116
    GROM_GOL_BASE_CAMP = 117
    WHELGARS_EXCAVATION_SITE = 118
    WESTBROOK_GARRISON = 120
    TRANQUIL_GARDENS_CEMETERY = 121
    ZUULDAIA_RUINS = 122
    BAL_LAL_RUINS = 123
    KAL_AI_RUINS = 125
    TKASHI_RUINS = 126
    BALIA_MAH_RUINS = 127
    ZIATAJAI_RUINS = 128
    MIZJAH_RUINS = 129
    SILVERPINE_FOREST = 130
    KHARANOS = 131
    COLDRIDGE_VALLEY = 132
    GNOMEREGAN0 = 133
    GOL_BOLAR_QUARRY = 134
    FROSTMANE_HOLD = 135
    THE_GRIZZLED_DEN = 136
    BREWNALL_VILLAGE = 137
    MISTY_PINE_REFUGE = 138
    EASTERN_PLAGUELANDS = 139
    TELDRASSIL = 141
    IRONBANDS_EXCAVATION_SITE = 142
    MO_GROSH_STRONGHOLD = 143
    THELSAMAR = 144
    ALGAZ_GATE = 145
    STONEWROUGHT_DAM = 146
    THE_FARSTRIDER_LODGE = 147
    DARKSHORE = 148
    SILVER_STREAM_MINE = 149
    MENETHIL_HARBOR = 150
    DESIGNER_ISLAND = 151
    THE_BULWARK0 = 152
    RUINS_OF_LORDAERON = 153
    DEATHKNELL = 154
    NIGHT_WEBS_HOLLOW = 155
    SOLLIDEN_FARMSTEAD = 156
    AGAMAND_MILLS = 157
    AGAMAND_FAMILY_CRYPT = 158
    BRILL = 159
    WHISPERING_GARDENS = 160
    TERRACE_OF_REPOSE = 161
    BRIGHTWATER_LAKE = 162
    GUNTHERS_RETREAT = 163
    GARRENS_HAUNT = 164
    BALNIR_FARMSTEAD = 165
    COLD_HEARTH_MANOR = 166
    CRUSADER_OUTPOST = 167
    THE_NORTH_COAST = 168
    WHISPERING_SHORE = 169
    LORDAMERE_LAKE0 = 170
    FENRIS_ISLE = 172
    FAOLS_REST = 173
    DOLANAAR = 186
    DARNASSUS_UNUSED = 187
    SHADOWGLEN = 188
    STEELGRILLS_DEPOT = 189
    HEARTHGLEN = 190
    NORTHRIDGE_LUMBER_CAMP = 192
    RUINS_OF_ANDORHAL = 193
    SCHOOL_OF_NECROMANCY = 195
    UTHERS_TOMB = 196
    SORROW_HILL = 197
    THE_WEEPING_CAVE = 198
    FELSTONE_FIELD = 199
    DALSONS_TEARS = 200
    GAHRRONS_WITHERING = 201
    THE_WRITHING_HAUNT = 202
    MARDENHOLDE_KEEP = 203
    PYREWOOD_VILLAGE = 204
    DUN_MODR = 205
    WESTFALL1 = 206
    THE_GREAT_SEA0 = 207
    UNUSED_IRONCLADCOVE = 208
    SHADOWFANG_KEEP0 = 209
    ON_MAP_DUNGEON3 = 210
    ICEFLOW_LAKE = 211
    HELMS_BED_LAKE = 212
    DEEP_ELEM_MINE = 213
    THE_GREAT_SEA1 = 214
    MULGORE = 215
    ALEXSTON_FARMSTEAD = 219
    RED_CLOUD_MESA = 220
    CAMP_NARACHE = 221
    BLOODHOOF_VILLAGE = 222
    STONEBULL_LAKE = 223
    RAVAGED_CARAVAN = 224
    RED_ROCKS = 225
    THE_SKITTERING_DARK = 226
    VALGANS_FIELD = 227
    THE_SEPULCHER = 228
    OLSENS_FARTHING = 229
    THE_GREYMANE_WALL = 230
    BERENS_PERIL = 231
    THE_DAWNING_ISLES = 232
    AMBERMILL = 233
    FENRIS_KEEP = 235
    SHADOWFANG_KEEP1 = 236
    THE_DECREPIT_FERRY = 237
    MALDENS_ORCHARD = 238
    THE_IVAR_PATCH = 239
    THE_DEAD_FIELD = 240
    THE_ROTTING_ORCHARD = 241
    BRIGHTWOOD_GROVE = 242
    FORLORN_ROWE = 243
    THE_WHIPPLE_ESTATE = 244
    THE_YORGEN_FARMSTEAD = 245
    THE_CAULDRON = 246
    GRIMESILT_DIG_SITE = 247
    DREADMAUL_ROCK = 249
    RUINS_OF_THAURISSAN = 250
    FLAME_CREST = 251
    BLACKROCK_STRONGHOLD = 252
    THE_PILLAR_OF_ASH = 253
    BLACKROCK_MOUNTAIN1 = 254
    ALTAR_OF_STORMS0 = 255
    ALDRASSIL = 256
    SHADOWTHREAD_CAVE = 257
    FEL_ROCK = 258
    LAKE_AL_AMETH = 259
    STARBREEZE_VILLAGE = 260
    GNARLPINE_HOLD = 261
    BAN_ETHIL_BARROW_DEN = 262
    THE_CLEFT = 263
    THE_ORACLE_GLADE = 264
    WELLSPRING_RIVER = 265
    WELLSPRING_LAKE = 266
    HILLSBRAD_FOOTHILLS = 267
    AZSHARA_CRATER = 268
    DUN_ALGAZ0 = 269
    SOUTHSHORE0 = 271
    TARREN_MILL0 = 272
    DURNHOLDE_KEEP0 = 275
    UNUSED_STONEWROUGHT_PASS = 276
    THE_FOOTHILL_CAVERNS = 277
    LORDAMERE_INTERNMENT_CAMP = 278
    DALARAN = 279
    STRAHNBRAD = 280
    RUINS_OF_ALTERAC = 281
    CRUSHRIDGE_HOLD = 282
    SLAUGHTER_HOLLOW = 283
    THE_UPLANDS = 284
    SOUTHPOINT_TOWER0 = 285
    HILLSBRAD_FIELDS0 = 286
    HILLSBRAD = 287
    AZURELODE_MINE0 = 288
    NETHANDER_STEAD0 = 289
    DUN_GAROK0 = 290
    THORADINS_WALL0 = 293
    EASTERN_STRAND0 = 294
    WESTERN_STRAND0 = 295
    SOUTH_SEAS_UNUSED = 296
    JAGUERO_ISLE = 297
    BARADIN_BAY = 298
    MENETHIL_BAY = 299
    MISTY_REED_STRAND = 300
    THE_SAVAGE_COAST = 301
    THE_CRYSTAL_SHORE = 302
    SHELL_BEACH = 303
    NORTH_TIDES_RUN = 305
    SOUTH_TIDES_RUN = 306
    THE_OVERLOOK_CLIFFS = 307
    THE_FORBIDDING_SEA0 = 308
    IRONBEARDS_TOMB = 309
    CRYSTALVEIN_MINE = 310
    RUINS_OF_ABORAZ = 311
    JANEIROS_POINT = 312
    NORTHFOLD_MANOR = 313
    GO_SHEK_FARM = 314
    DABYRIES_FARMSTEAD = 315
    BOULDERFIST_HALL = 316
    WITHERBARK_VILLAGE = 317
    DRYWHISKER_GORGE = 318
    REFUGE_POINTE = 320
    HAMMERFALL = 321
    BLACKWATER_SHIPWRECKS = 322
    O_BREENS_CAMP = 323
    STROMGARDE_KEEP = 324
    THE_TOWER_OF_ARATHOR = 325
    THE_SANCTUM = 326
    FALDIRS_COVE = 327
    THE_DROWNED_REEF = 328
    THANDOL_SPAN0 = 330
    ASHENVALE = 331
    THE_GREAT_SEA2 = 332
    CIRCLE_OF_EAST_BINDING = 333
    CIRCLE_OF_WEST_BINDING = 334
    CIRCLE_OF_INNER_BINDING = 335
    CIRCLE_OF_OUTER_BINDING = 336
    APOCRYPHANS_REST = 337
    ANGOR_FORTRESS = 338
    LETHLOR_RAVINE = 339
    KARGATH = 340
    CAMP_KOSH = 341
    CAMP_BOFF = 342
    CAMP_WURG = 343
    CAMP_CAGG = 344
    AGMONDS_END = 345
    HAMMERTOES_DIGSITE = 346
    DUSTBELCH_GROTTO = 347
    AERIE_PEAK = 348
    WILDHAMMER_KEEP = 349
    QUEL_DANIL_LODGE = 350
    SKULK_ROCK = 351
    ZUN_WATHA = 352
    SHADRA_ALOR = 353
    JINTHA_ALOR = 354
    THE_ALTAR_OF_ZUL = 355
    SERADANE = 356
    FERALAS = 357
    BRAMBLEBLADE_RAVINE = 358
    BAEL_MODAN = 359
    THE_VENTURE_CO_MINE = 360
    FELWOOD = 361
    RAZOR_HILL = 362
    VALLEY_OF_TRIALS = 363
    THE_DEN = 364
    BURNING_BLADE_COVEN = 365
    KOLKAR_CRAG = 366
    SEN_JIN_VILLAGE = 367
    ECHO_ISLES = 368
    THUNDER_RIDGE = 369
    DRYGULCH_RAVINE = 370
    DUSTWIND_CAVE = 371
    TIRAGARDE_KEEP = 372
    SCUTTLE_COAST = 373
    BLADEFIST_BAY = 374
    DEADEYE_SHORE = 375
    SOUTHFURY_RIVER0 = 377
    CAMP_TAURAJO = 378
    FAR_WATCH_POST = 379
    THE_CROSSROADS = 380
    BOULDER_LODE_MINE = 381
    THE_SLUDGE_FEN = 382
    THE_DRY_HILLS = 383
    DREADMIST_PEAK = 384
    NORTHWATCH_HOLD = 385
    THE_FORGOTTEN_POOLS = 386
    LUSHWATER_OASIS = 387
    THE_STAGNANT_OASIS = 388
    FIELD_OF_GIANTS = 390
    THE_MERCHANT_COAST = 391
    RATCHET = 392
    DARKSPEAR_STRAND = 393
    DARROWMERE_LAKE_UNUSED = 394
    CAER_DARROW_UNUSED = 395
    WINTERHOOF_WATER_WELL = 396
    THUNDERHORN_WATER_WELL = 397
    WILDMANE_WATER_WELL = 398
    SKYLINE_RIDGE = 399
    THOUSAND_NEEDLES = 400
    THE_TIDUS_STAIR = 401
    SHADY_REST_INN = 403
    BAEL_DUN_DIGSITE = 404
    DESOLACE = 405
    STONETALON_MOUNTAINS = 406
    ORGRIMMAR_UNUSED = 407
    GILLIJIMS_ISLE = 408
    ISLAND_OF_DOCTOR_LAPIDIS = 409
    RAZORWIND_CANYON = 410
    BATHRANS_HAUNT = 411
    THE_RUINS_OF_ORDIL_ARAN = 412
    MAESTRAS_POST = 413
    THE_ZORAM_STRAND = 414
    ASTRANAAR = 415
    THE_SHRINE_OF_AESSINA = 416
    FIRE_SCAR_SHRINE = 417
    THE_RUINS_OF_STARDUST = 418
    THE_HOWLING_VALE = 419
    SILVERWIND_REFUGE = 420
    MYSTRAL_LAKE = 421
    FALLEN_SKY_LAKE = 422
    IRIS_LAKE = 424
    MOONWELL = 425
    RAYNEWOOD_RETREAT = 426
    THE_SHADY_NOOK = 427
    NIGHT_RUN = 428
    XAVIAN = 429
    SATYRNAAR = 430
    SPLINTERTREE_POST = 431
    THE_DOR_DANIL_BARROW_DEN = 432
    FALFARREN_RIVER = 433
    FELFIRE_HILL = 434
    DEMON_FALL_CANYON = 435
    DEMON_FALL_RIDGE = 436
    WARSONG_LUMBER_CAMP = 437
    BOUGH_SHADOW = 438
    THE_SHIMMERING_FLATS = 439
    TANARIS = 440
    LAKE_FALATHIM = 441
    AUBERDINE = 442
    RUINS_OF_MATHYSTRA = 443
    TOWER_OF_ALTHALAXX = 444
    CLIFFSPRING_FALLS = 445
    BASHAL_ARAN = 446
    AMETH_ARAN = 447
    GROVE_OF_THE_ANCIENTS = 448
    THE_MASTERS_GLAIVE = 449
    REMTRAVELS_EXCAVATION = 450
    MISTS_EDGE = 452
    THE_LONG_WASH = 453
    WILDBEND_RIVER = 454
    BLACKWOOD_DEN = 455
    CLIFFSPRING_RIVER = 456
    THE_VEILED_SEA0 = 457
    GOLD_ROAD = 458
    SCARLET_WATCH_POST = 459
    SUN_ROCK_RETREAT = 460
    WINDSHEAR_CRAG = 461
    CRAGPOOL_LAKE = 463
    MIRKFALLON_LAKE = 464
    THE_CHARRED_VALE = 465
    VALLEY_OF_THE_BLOODFURIES = 466
    STONETALON_PEAK = 467
    THE_TALON_DEN = 468
    GREATWOOD_VALE = 469
    THUNDER_BLUFF_UNUSED = 470
    BRAVE_WIND_MESA = 471
    FIRE_STONE_MESA = 472
    MANTLE_ROCK = 473
    HUNTER_RISE_UNUSED = 474
    SPIRIT_RISE_UNUSED = 475
    ELDER_RISE_UNUSED = 476
    RUINS_OF_JUBUWAL = 477
    POOLS_OF_ARLITHRIEN = 478
    THE_RUSTMAUL_DIG_SITE = 479
    CAMP_E_THOK = 480
    SPLITHOOF_CRAG = 481
    HIGHPERCH = 482
    THE_SCREECHING_CANYON = 483
    FREEWIND_POST = 484
    THE_GREAT_LIFT0 = 485
    GALAK_HOLD = 486
    ROGUEFEATHER_DEN = 487
    THE_WEATHERED_NOOK = 488
    THALANAAR = 489
    UN_GORO_CRATER = 490
    RAZORFEN_KRAUL0 = 491
    RAVEN_HILL_CEMETERY = 492
    MOONGLADE = 493
    DELETE_ME0 = 495
    BRACKENWALL_VILLAGE = 496
    SWAMPLIGHT_MANOR = 497
    BLOODFEN_BURROW = 498
    DARKMIST_CAVERN = 499
    MOGGLE_POINT = 500
    BEEZILS_WRECK = 501
    WITCH_HILL = 502
    SENTRY_POINT = 503
    NORTH_POINT_TOWER = 504
    WEST_POINT_TOWER = 505
    LOST_POINT = 506
    BLUEFEN = 507
    STONEMAUL_RUINS = 508
    THE_DEN_OF_FLAME = 509
    THE_DRAGONMURK = 510
    WYRMBOG = 511
    ONYXIAS_LAIR_UNUSED = 512
    THERAMORE_ISLE = 513
    FOOTHOLD_CITADEL = 514
    IRONCLAD_PRISON = 515
    DUSTWALLOW_BAY = 516
    TIDEFURY_COVE = 517
    DREADMURK_SHORE = 518
    ADDLES_STEAD = 536
    FIRE_PLUME_RIDGE = 537
    LAKKARI_TAR_PITS = 538
    TERROR_RUN = 539
    THE_SLITHERING_SCAR = 540
    MARSHALS_REFUGE = 541
    FUNGAL_ROCK = 542
    GOLAKKA_HOT_SPRINGS = 543
    THE_LOCH = 556
    BEGGARS_HAUNT = 576
    KODO_GRAVEYARD = 596
    GHOST_WALKER_POST = 597
    SAR_THERIS_STRAND = 598
    THUNDER_AXE_FORTRESS = 599
    BOLGANS_HOLE = 600
    MANNOROC_COVEN = 602
    SARGERON = 603
    MAGRAM_VILLAGE = 604
    GELKIS_VILLAGE = 606
    VALLEY_OF_SPEARS = 607
    NIJELS_POINT = 608
    KOLKAR_VILLAGE = 609
    HYJAL = 616
    WINTERSPRING = 618
    BLACKWOLF_RIVER = 636
    KODO_ROCK = 637
    HIDDEN_PATH = 638
    SPIRIT_ROCK = 639
    SHRINE_OF_THE_DORMANT_FLAME = 640
    LAKE_ELUNE_ARA = 656
    THE_HARBORAGE = 657
    OUTLAND = 676
    CRAFTSMENS_TERRACE_UNUSED = 696
    TRADESMENS_TERRACE_UNUSED = 697
    THE_TEMPLE_GARDENS_UNUSED = 698
    TEMPLE_OF_ELUNE_UNUSED = 699
    CENARION_ENCLAVE_UNUSED = 700
    WARRIORS_TERRACE_UNUSED = 701
    RUT_THERAN_VILLAGE = 702
    IRONBANDS_COMPOUND = 716
    THE_STOCKADE = 717
    WAILING_CAVERNS = 718
    BLACKFATHOM_DEEPS0 = 719
    FRAY_ISLAND = 720
    GNOMEREGAN1 = 721
    RAZORFEN_DOWNS0 = 722
    BAN_ETHIL_HOLLOW = 736
    SCARLET_MONASTERY = 796
    JERODS_LANDING = 797
    RIDGEPOINT_TOWER = 798
    THE_DARKENED_BANK = 799
    COLDRIDGE_PASS = 800
    CHILL_BREEZE_VALLEY = 801
    SHIMMER_RIDGE = 802
    AMBERSTILL_RANCH = 803
    THE_TUNDRID_HILLS = 804
    SOUTH_GATE_PASS0 = 805
    SOUTH_GATE_OUTPOST = 806
    NORTH_GATE_PASS0 = 807
    NORTH_GATE_OUTPOST = 808
    GATES_OF_IRONFORGE = 809
    STILLWATER_POND = 810
    NIGHTMARE_VALE = 811
    VENOMWEB_VALE = 812
    THE_BULWARK1 = 813
    SOUTHFURY_RIVER1 = 814
    SOUTHFURY_RIVER2 = 815
    RAZORMANE_GROUNDS = 816
    SKULL_ROCK = 817
    PALEMANE_ROCK = 818
    WINDFURY_RIDGE = 819
    THE_GOLDEN_PLAINS = 820
    THE_ROLLING_PLAINS = 821
    DUN_ALGAZ1 = 836
    DUN_ALGAZ2 = 837
    NORTH_GATE_PASS1 = 838
    SOUTH_GATE_PASS1 = 839
    TWILIGHT_GROVE = 856
    GM_ISLAND = 876
    DELETE_ME1 = 877
    SOUTHFURY_RIVER3 = 878
    SOUTHFURY_RIVER4 = 879
    THANDOL_SPAN1 = 880
    THANDOL_SPAN2 = 881
    PURGATION_ISLE = 896
    THE_JANSEN_STEAD = 916
    THE_DEAD_ACRE = 917
    THE_MOLSEN_FARM = 918
    STENDELS_POND = 919
    THE_DAGGER_HILLS = 920
    DEMONTS_PLACE = 921
    THE_DUST_PLAINS = 922
    STONESPLINTER_VALLEY = 923
    VALLEY_OF_KINGS = 924
    ALGAZ_STATION = 925
    BUCKLEBREE_FARM = 926
    THE_SHINING_STRAND = 927
    NORTH_TIDES_HOLLOW = 928
    GRIZZLEPAW_RIDGE = 936
    THE_VERDANT_FIELDS = 956
    GADGETZAN = 976
    STEAMWHEEDLE_PORT = 977
    ZUL_FARRAK0 = 978
    SANDSORROW_WATCH = 979
    THISTLESHRUB_VALLEY = 980
    THE_GAPING_CHASM = 981
    THE_NOXIOUS_LAIR = 982
    DUNEMAUL_COMPOUND = 983
    EASTMOON_RUINS = 984
    WATERSPRING_FIELD = 985
    ZALASHJIS_DEN = 986
    LANDS_END_BEACH = 987
    WAVESTRIDER_BEACH = 988
    ULDUM = 989
    VALLEY_OF_THE_WATCHERS = 990
    GUNSTANS_POST = 991
    SOUTHMOON_RUINS = 992
    RENDERS_CAMP = 996
    RENDERS_VALLEY = 997
    RENDERS_ROCK = 998
    STONEWATCH_TOWER = 999
    GALARDELL_VALLEY = 1000
    LAKERIDGE_HIGHWAY = 1001
    THREE_CORNERS = 1002
    DIREFORGE_HILL = 1016
    RAPTOR_RIDGE = 1017
    BLACK_CHANNEL_MARSH = 1018
    THE_GREEN_BELT0 = 1019
    MOSSHIDE_FEN = 1020
    THELGEN_ROCK = 1021
    BLUEGILL_MARSH = 1022
    SALTSPRAY_GLEN = 1023
    SUNDOWN_MARSH = 1024
    THE_GREEN_BELT1 = 1025
    ANGERFANG_ENCAMPMENT = 1036
    GRIM_BATOL = 1037
    DRAGONMAW_GATES = 1038
    THE_LOST_FLEET = 1039
    DARROW_HILL0 = 1056
    THORADINS_WALL1 = 1057
    WEBWINDER_PATH = 1076
    THE_HUSHED_BANK = 1097
    MANOR_MISTMANTLE = 1098
    CAMP_MOJACHE = 1099
    GRIMTOTEM_COMPOUND = 1100
    THE_WRITHING_DEEP = 1101
    WILDWIND_LAKE = 1102
    GORDUNNI_OUTPOST = 1103
    MOK_GORDUN = 1104
    FERAL_SCAR_VALE = 1105
    FRAYFEATHER_HIGHLANDS = 1106
    IDLEWIND_LAKE = 1107
    THE_FORGOTTEN_COAST = 1108
    EAST_PILLAR = 1109
    WEST_PILLAR = 1110
    DREAM_BOUGH = 1111
    JADEMIR_LAKE = 1112
    ONEIROS = 1113
    RUINS_OF_RAVENWIND = 1114
    RAGE_SCAR_HOLD = 1115
    FEATHERMOON_STRONGHOLD = 1116
    RUINS_OF_SOLARSAL = 1117
    LOWER_WILDS_UNUSED = 1118
    THE_TWIN_COLOSSALS = 1119
    SARDOR_ISLE = 1120
    ISLE_OF_DREAD = 1121
    HIGH_WILDERNESS = 1136
    LOWER_WILDS = 1137
    SOUTHERN_BARRENS = 1156
    SOUTHERN_GOLD_ROAD = 1157
    ZUL_FARRAK1 = 1176
    UNUSED_ALCAZ_ISLAND = 1196
    TIMBERMAW_HOLD0 = 1216
    VANNDIR_ENCAMPMENT = 1217
    TEST_AZSHARA = 1218
    LEGASH_ENCAMPMENT = 1219
    THALASSIAN_BASE_CAMP = 1220
    RUINS_OF_ELDARATH = 1221
    HETAERAS_CLUTCH = 1222
    TEMPLE_OF_ZIN_MALOR = 1223
    BEARS_HEAD = 1224
    URSOLAN = 1225
    TEMPLE_OF_ARKKORAN = 1226
    BAY_OF_STORMS = 1227
    THE_SHATTERED_STRAND = 1228
    TOWER_OF_ELDARA = 1229
    JAGGED_REEF = 1230
    SOUTHRIDGE_BEACH = 1231
    RAVENCREST_MONUMENT = 1232
    FORLORN_RIDGE = 1233
    LAKE_MENNAR = 1234
    SHADOWSONG_SHRINE = 1235
    HALDARR_ENCAMPMENT = 1236
    VALORMOK = 1237
    THE_RUINED_REACHES = 1256
    THE_TALONDEEP_PATH0 = 1276
    THE_TALONDEEP_PATH1 = 1277
    ROCKTUSK_FARM = 1296
    JAGGEDSWINE_FARM = 1297
    RAZORFEN_DOWNS1 = 1316
    LOST_RIGGER_COVE = 1336
    ULDAMAN0 = 1337
    LORDAMERE_LAKE1 = 1338
    LORDAMERE_LAKE2 = 1339
    GALLOWS_CORNER = 1357
    SILITHUS = 1377
    EMERALD_FOREST = 1397
    SUNKEN_TEMPLE = 1417
    DREADMAUL_HOLD = 1437
    NETHERGARDE_KEEP = 1438
    DREADMAUL_POST = 1439
    SERPENTS_COIL = 1440
    ALTAR_OF_STORMS1 = 1441
    FIREWATCH_RIDGE = 1442
    THE_SLAG_PIT = 1443
    THE_SEA_OF_CINDERS = 1444
    BLACKROCK_MOUNTAIN2 = 1445
    THORIUM_POINT = 1446
    GARRISON_ARMORY = 1457
    THE_TEMPLE_OF_ATAL_HAKKAR = 1477
    UNDERCITY = 1497
    ULDAMAN1 = 1517
    NOT_USED_DEADMINES = 1518
    STORMWIND_CITY = 1519
    IRONFORGE = 1537
    SPLITHOOF_HOLD = 1557
    THE_CAPE_OF_STRANGLETHORN = 1577
    SOUTHERN_SAVAGE_COAST = 1578
    UNUSED_THE_DEADMINES_002 = 1579
    UNUSED_IRONCLAD_COVE_003 = 1580
    THE_DEADMINES = 1581
    IRONCLAD_COVE = 1582
    BLACKROCK_SPIRE = 1583
    BLACKROCK_DEPTHS = 1584
    RAPTOR_GROUNDS_UNUSED = 1597
    GROL_DOM_FARM_UNUSED = 1598
    MORSHAN_BASE_CAMP = 1599
    HONORS_STAND_UNUSED = 1600
    BLACKTHORN_RIDGE_UNUSED = 1601
    BRAMBLESCAR_UNUSED = 1602
    AGAMA_GOR_UNUSED = 1603
    VALLEY_OF_HEROES = 1617
    ORGRIMMAR = 1637
    THUNDER_BLUFF = 1638
    ELDER_RISE = 1639
    SPIRIT_RISE = 1640
    HUNTER_RISE = 1641
    DARNASSUS = 1657
    CENARION_ENCLAVE = 1658
    CRAFTSMENS_TERRACE = 1659
    WARRIORS_TERRACE = 1660
    THE_TEMPLE_GARDENS = 1661
    TRADESMENS_TERRACE = 1662
    GAVINS_NAZE = 1677
    SOFERAS_NAZE = 1678
    CORRAHNS_DAGGER = 1679
    THE_HEADLAND = 1680
    MISTY_SHORE = 1681
    DANDREDS_FOLD = 1682
    GROWLESS_CAVE = 1683
    CHILLWIND_POINT = 1684
    RAPTOR_GROUNDS = 1697
    BRAMBLESCAR = 1698
    THORN_HILL = 1699
    AGAMA_GOR = 1700
    BLACKTHORN_RIDGE = 1701
    HONORS_STAND = 1702
    THE_MORSHAN_RAMPART = 1703
    GROL_DOM_FARM = 1704
    RAZORFEN_KRAUL1 = 1717
    THE_GREAT_LIFT1 = 1718
    MISTVALE_VALLEY = 1737
    NEK_MANI_WELLSPRING = 1738
    BLOODSAIL_COMPOUND = 1739
    VENTURE_CO_BASE_CAMP = 1740
    GURUBASHI_ARENA = 1741
    SPIRIT_DEN = 1742
    THE_CRIMSON_VEIL = 1757
    THE_RIPTIDE = 1758
    THE_DAMSELS_LUCK = 1759
    VENTURE_CO_OPERATIONS_CENTER = 1760
    DEADWOOD_VILLAGE = 1761
    FELPAW_VILLAGE = 1762
    JAEDENAR = 1763
    BLOODVENOM_RIVER = 1764
    BLOODVENOM_FALLS = 1765
    SHATTER_SCAR_VALE = 1766
    IRONTREE_WOODS = 1767
    IRONTREE_CAVERN = 1768
    TIMBERMAW_HOLD1 = 1769
    SHADOW_HOLD = 1770
    SHRINE_OF_THE_DECEIVER = 1771
    ITHARIUSS_CAVE = 1777
    SORROWMURK = 1778
    DRAENIL_DUR_VILLAGE = 1779
    SPLINTERSPEAR_JUNCTION = 1780
    STAGALBOG = 1797
    THE_SHIFTING_MIRE = 1798
    STAGALBOG_CAVE = 1817
    WITHERBARK_CAVERNS = 1837
    THORADINS_WALL2 = 1857
    BOULDER_GOR = 1858
    VALLEY_OF_FANGS = 1877
    THE_DUSTBOWL = 1878
    MIRAGE_FLATS = 1879
    FEATHERBEARDS_HOVEL = 1880
    SHINDIGGERS_CAMP = 1881
    PLAGUEMIST_RAVINE = 1882
    VALORWIND_LAKE = 1883
    AGOL_WATHA = 1884
    HIRI_WATHA = 1885
    THE_CREEPING_RUIN = 1886
    BOGENS_LEDGE = 1887
    THE_MAKERS_TERRACE = 1897
    DUSTWIND_GULCH = 1898
    SHAOL_WATHA = 1917
    NOONSHADE_RUINS = 1937
    BROKEN_PILLAR = 1938
    ABYSSAL_SANDS = 1939
    SOUTHBREAK_SHORE = 1940
    CAVERNS_OF_TIME0 = 1941
    THE_MARSHLANDS = 1942
    IRONSTONE_PLATEAU = 1943
    BLACKCHAR_CAVE = 1957
    TANNER_CAMP = 1958
    DUSTFIRE_VALLEY = 1959
    ZUL_GURUB1 = 1977
    MISTY_REED_POST = 1978
    BLOODVENOM_POST = 1997
    TALONBRANCH_GLADE = 1998
    STRATHOLME0 = 2017
    UNUSED_SHADOWFANG_KEEP_003 = 2037
    SCHOLOMANCE = 2057
    TWILIGHT_VALE = 2077
    TWILIGHT_SHORE = 2078
    ALCAZ_ISLAND = 2079
    DARKCLOUD_PINNACLE = 2097
    DAWNING_WOOD_CATACOMBS = 2098
    STONEWATCH_KEEP = 2099
    MARAUDON = 2100
    STOUTLAGER_INN = 2101
    THUNDERBREW_DISTILLERY = 2102
    MENETHIL_KEEP = 2103
    DEEPWATER_TAVERN = 2104
    SHADOW_GRAVE = 2117
    BRILL_TOWN_HALL = 2118
    GALLOWS_END_TAVERN = 2119
    THE_POOLS_OF_VISION_UNUSED = 2137
    DREADMIST_DEN = 2138
    BAEL_DUN_KEEP = 2157
    EMBERSTRIFES_DEN = 2158
    ONYXIAS_LAIR = 2159
    WINDSHEAR_MINE = 2160
    ROLANDS_DOOM = 2161
    BATTLE_RING = 2177
    THE_POOLS_OF_VISION = 2197
    SHADOWBREAK_RAVINE = 2198
    BROKEN_SPEAR_VILLAGE = 2217
    WHITEREACH_POST = 2237
    GORNIA = 2238
    ZANES_EYE_CRATER = 2239
    MIRAGE_RACEWAY = 2240
    FROSTSABER_ROCK = 2241
    THE_HIDDEN_GROVE = 2242
    TIMBERMAW_POST = 2243
    WINTERFALL_VILLAGE = 2244
    MAZTHORIL = 2245
    FROSTFIRE_HOT_SPRINGS = 2246
    ICE_THISTLE_HILLS = 2247
    DUN_MANDARR = 2248
    FROSTWHISPER_GORGE = 2249
    OWL_WING_THICKET = 2250
    LAKE_KEL_THERIL = 2251
    THE_RUINS_OF_KEL_THERIL = 2252
    STARFALL_VILLAGE = 2253
    BAN_THALLOW_BARROW_DEN = 2254
    EVERLOOK = 2255
    DARKWHISPER_GORGE = 2256
    DEEPRUN_TRAM = 2257
    THE_FUNGAL_VALE = 2258
    UNUSED_THE_MARRIS_STEAD = 2259
    THE_MARRIS_STEAD = 2260
    THE_UNDERCROFT = 2261
    DARROWSHIRE = 2262
    CROWN_GUARD_TOWER = 2263
    CORINS_CROSSING = 2264
    SCARLET_BASE_CAMP = 2265
    TYRS_HAND = 2266
    THE_SCARLET_BASILICA = 2267
    LIGHTS_HOPE_CHAPEL = 2268
    BROWMAN_MILL = 2269
    THE_NOXIOUS_GLADE = 2270
    EASTWALL_TOWER = 2271
    NORTHDALE = 2272
    ZUL_MASHAR = 2273
    MAZRA_ALOR = 2274
    NORTHPASS_TOWER = 2275
    QUEL_LITHIEN_LODGE = 2276
    PLAGUEWOOD = 2277
    SCOURGEHOLD = 2278
    STRATHOLME1 = 2279
    UNUSED_STRATHOLME = 2280
    DARROWMERE_LAKE0 = 2297
    CAER_DARROW = 2298
    DARROWMERE_LAKE1 = 2299
    CAVERNS_OF_TIME1 = 2300
    THISTLEFUR_VILLAGE = 2301
    THE_QUAGMIRE = 2302
    WINDBREAK_CANYON = 2303
    SOUTH_SEAS0 = 2317
    THE_GREAT_SEA3 = 2318
    THE_GREAT_SEA4 = 2319
    THE_GREAT_SEA5 = 2320
    THE_GREAT_SEA6 = 2321
    THE_VEILED_SEA1 = 2322
    THE_VEILED_SEA2 = 2323
    THE_VEILED_SEA3 = 2324
    THE_VEILED_SEA4 = 2325
    THE_VEILED_SEA5 = 2326
    RAZOR_HILL_BARRACKS = 2337
    SOUTH_SEAS1 = 2338
    THE_GREAT_SEA7 = 2339
    BLOODTOOTH_CAMP = 2357
    FOREST_SONG = 2358
    GREENPAW_VILLAGE = 2359
    SILVERWING_OUTPOST = 2360
    NIGHTHAVEN = 2361
    SHRINE_OF_REMULOS = 2362
    STORMRAGE_BARROW_DENS = 2363
    THE_GREAT_SEA8 = 2364
    THE_GREAT_SEA9 = 2365
    THE_BLACK_MORASS = 2366
    OLD_HILLSBRAD_FOOTHILLS = 2367
    TARREN_MILL1 = 2368
    SOUTHSHORE1 = 2369
    DURNHOLDE_KEEP1 = 2370
    DUN_GAROK1 = 2371
    HILLSBRAD_FIELDS1 = 2372
    EASTERN_STRAND1 = 2373
    NETHANDER_STEAD1 = 2374
    DARROW_HILL1 = 2375
    SOUTHPOINT_TOWER1 = 2376
    THORADINS_WALL3 = 2377
    WESTERN_STRAND1 = 2378
    AZURELODE_MINE1 = 2379
    THE_GREAT_SEA10 = 2397
    THE_GREAT_SEA11 = 2398
    THE_GREAT_SEA12 = 2399
    THE_FORBIDDING_SEA1 = 2400
    THE_FORBIDDING_SEA2 = 2401
    THE_FORBIDDING_SEA3 = 2402
    THE_FORBIDDING_SEA4 = 2403
    TETHRIS_ARAN = 2404
    ETHEL_RETHOR = 2405
    RANAZJAR_ISLE = 2406
    KORMEKS_HUT = 2407
    SHADOWPREY_VILLAGE = 2408
    BLACKROCK_PASS = 2417
    MORGANS_VIGIL = 2418
    SLITHER_ROCK = 2419
    TERROR_WING_PATH = 2420
    DRACO_DAR = 2421
    RAGEFIRE_CHASM = 2437
    NIGHTSONG_WOODS = 2457
    THE_VEILED_SEA6 = 2477
    MORLOS_ARAN = 2478
    EMERALD_SANCTUARY = 2479
    JADEFIRE_GLEN = 2480
    RUINS_OF_CONSTELLAS = 2481
    BITTER_REACHES = 2497
    RISE_OF_THE_DEFILER = 2517
    LARISS_PAVILION = 2518
    WOODPAW_HILLS = 2519
    WOODPAW_DEN = 2520
    VERDANTIS_RIVER = 2521
    RUINS_OF_ISILDIEN = 2522
    GRIMTOTEM_POST = 2537
    CAMP_APARAJE = 2538
    MALAKA_JIN = 2539
    BOULDERSLIDE_RAVINE = 2540
    SISHIR_CANYON = 2541
    DIRE_MAUL0 = 2557
    DEADWIND_RAVINE = 2558
    DIAMONDHEAD_RIVER = 2559
    ARIDENS_CAMP = 2560
    THE_VICE = 2561
    KARAZHAN = 2562
    MORGANS_PLOT = 2563
    DIRE_MAUL1 = 2577
    ALTERAC_VALLEY0 = 2597
    SCRABBLESCREWS_CAMP = 2617
    JADEFIRE_RUN = 2618
    THONDRORIL_RIVER0 = 2619
    THONDRORIL_RIVER1 = 2620
    LAKE_MERELDAR = 2621
    PESTILENT_SCAR = 2622
    THE_INFECTIS_SCAR = 2623
    BLACKWOOD_LAKE = 2624
    EASTWALL_GATE = 2625
    TERRORWEB_TUNNEL = 2626
    TERRORDALE = 2627
    KARGATHIA_KEEP = 2637
    VALLEY_OF_BONES = 2657
    BLACKWING_LAIR = 2677
    DEADMANS_CROSSING = 2697
    MOLTEN_CORE = 2717
    THE_SCARAB_WALL = 2737
    SOUTHWIND_VILLAGE = 2738
    TWILIGHT_BASE_CAMP = 2739
    THE_CRYSTAL_VALE = 2740
    THE_SCARAB_DAIS = 2741
    HIVE_ASHI = 2742
    HIVE_ZORA = 2743
    HIVE_REGAL = 2744
    SHRINE_OF_THE_FALLEN_WARRIOR = 2757
    UNUSED_ALTERAC_VALLEY = 2777
    BLACKFATHOM_DEEPS1 = 2797
    ON_MAP_DUNGEON4 = 2817
    THE_MASTERS_CELLAR = 2837
    STONEWROUGHT_PASS = 2838
    ALTERAC_VALLEY1 = 2839
    THE_RUMBLE_CAGE = 2857
    CHUNK_TEST = 2877
    ZORAMGAR_OUTPOST = 2897
    HALL_OF_LEGENDS = 2917
    CHAMPIONS_HALL = 2918
    GROSH_GOK_COMPOUND = 2937
    SLEEPING_GORGE = 2938
    IRONDEEP_MINE = 2957
    STONEHEARTH_OUTPOST = 2958
    DUN_BALDAR = 2959
    ICEWING_PASS = 2960
    FROSTWOLF_VILLAGE = 2961
    TOWER_POINT = 2962
    COLDTOOTH_MINE = 2963
    WINTERAX_HOLD = 2964
    ICEBLOOD_GARRISON = 2977
    FROSTWOLF_KEEP = 2978
    TOR_KREN_FARM = 2979
    FROST_DAGGER_PASS = 3017
    IRONSTONE_CAMP = 3037
    WEAZELS_CRATER = 3038
    TAHONDA_RUINS = 3039
    FIELD_OF_STRIFE = 3057
    ICEWING_CAVERN = 3058
    VALORS_REST = 3077
    THE_SWARMING_PILLAR = 3097
    TWILIGHT_POST = 3098
    TWILIGHT_OUTPOST = 3099
    RAVAGED_TWILIGHT_CAMP = 3100
    SHALZARUS_LAIR = 3117
    TALRENDIS_POINT = 3137
    RETHRESS_SANCTUM = 3138
    MOON_HORROR_DEN = 3139
    SCALEBEARDS_CAVE = 3140
    BOULDERSLIDE_CAVERN = 3157
    WARSONG_LABOR_CAMP = 3177
    CHILLWIND_CAMP = 3197
    THE_MAUL = 3217
    THE_MAUL_UNUSED = 3237
    BONES_OF_GRAKKAROND = 3257
    WARSONG_GULCH = 3277
    FROSTWOLF_GRAVEYARD = 3297
    FROSTWOLF_PASS = 3298
    DUN_BALDAR_PASS = 3299
    ICEBLOOD_GRAVEYARD = 3300
    SNOWFALL_GRAVEYARD = 3301
    STONEHEARTH_GRAVEYARD = 3302
    STORMPIKE_GRAVEYARD = 3303
    ICEWING_BUNKER = 3304
    STONEHEARTH_BUNKER = 3305
    WILDPAW_RIDGE = 3306
    REVANTUSK_VILLAGE = 3317
    ROCK_OF_DUROTAN = 3318
    SILVERWING_GROVE = 3319
    WARSONG_LUMBER_MILL = 3320
    SILVERWING_HOLD = 3321
    WILDPAW_CAVERN = 3337
    THE_VEILED_CLEFT = 3338
    YOJAMBA_ISLE = 3357
    ARATHI_BASIN = 3358
    THE_COIL = 3377
    ALTAR_OF_HIR_EEK = 3378
    SHADRA_ZAAR = 3379
    HAKKARI_GROUNDS = 3380
    NAZE_OF_SHIRVALLAH = 3381
    TEMPLE_OF_BETHEKK = 3382
    THE_BLOODFIRE_PIT = 3383
    ALTAR_OF_THE_BLOOD_GOD = 3384
    ZANZAS_RISE = 3397
    EDGE_OF_MADNESS = 3398
    TROLLBANE_HALL = 3417
    DEFILERS_DEN = 3418
    PAGLES_POINTE = 3419
    FARM = 3420
    BLACKSMITH = 3421
    LUMBER_MILL = 3422
    GOLD_MINE = 3423
    STABLES = 3424
    CENARION_HOLD = 3425
    STAGHELM_POINT = 3426
    BRONZEBEARD_ENCAMPMENT = 3427
    AHN_QIRAJ = 3428
    RUINS_OF_AHN_QIRAJ0 = 3429
    TWILIGHTS_RUN = 3446
    ORTELLS_HIDEOUT = 3447
    SCARAB_TERRACE = 3448
    GENERALS_TERRACE = 3449
    THE_RESERVOIR = 3450
    THE_HATCHERY = 3451
    THE_COMB = 3452
    WATCHERS_TERRACE = 3453
    RUINS_OF_AHN_QIRAJ1 = 3454
    NAXXRAMAS = 3456
    CITY = 3459
    GATES_OF_AHN_QIRAJ = 3478
    RAVENHOLDT_MANOR = 3486


class AttackHand(enum.Enum):
    MAIN_HAND = 0
    OFF_HAND = 1


class AuctionCommandAction(enum.Enum):
    STARTED = 0
    REMOVED = 1
    BID_PLACED = 2


class AuctionCommandResult(enum.Enum):
    OK = 0
    ERR_INVENTORY = 1
    ERR_DATABASE = 2
    ERR_NOT_ENOUGH_MONEY = 3
    ERR_ITEM_NOT_FOUND = 4
    ERR_HIGHER_BID = 5
    ERR_BID_INCREMENT = 7
    ERR_BID_OWN = 10
    ERR_RESTRICTED_ACCOUNT = 13


class AuctionCommandResultTwo(enum.Enum):
    OK = 0
    ERR_INVENTORY = 1
    ERR_DATABASE = 2
    ERR_NOT_ENOUGH_MONEY = 3
    ERR_ITEM_NOT_FOUND = 4
    ERR_HIGHER_BID = 5
    ERR_BID_INCREMENT = 7
    ERR_BID_OWN = 10
    ERR_RESTRICTED_ACCOUNT = 13


class AuctionHouse(enum.Enum):
    STORMWIND = 1
    ALLIANCE = 2
    DARNASSUS = 3
    UNDERCITY = 4
    THUNDER_BLUFF = 5
    HORDE = 6
    GOBLIN = 7


class AuraMod(enum.Enum):
    NONE = 0
    BIND_SIGHT = 1
    MOD_POSSESS = 2
    PERIODIC_DAMAGE = 3
    DUMMY = 4
    MOD_CONFUSE = 5
    MOD_CHARM = 6
    MOD_FEAR = 7
    PERIODIC_HEAL = 8
    MOD_ATTACKSPEED = 9
    MOD_THREAT = 10
    MOD_TAUNT = 11
    MOD_STUN = 12
    MOD_DAMAGE_DONE = 13
    MOD_DAMAGE_TAKEN = 14
    DAMAGE_SHIELD = 15
    MOD_STEALTH = 16
    MOD_STEALTH_DETECT = 17
    MOD_INVISIBILITY = 18
    MOD_INVISIBILITY_DETECTION = 19
    OBS_MOD_HEALTH = 20
    OBS_MOD_MANA = 21
    MOD_RESISTANCE = 22
    PERIODIC_TRIGGER_SPELL = 23
    PERIODIC_ENERGIZE = 24
    MOD_PACIFY = 25
    MOD_ROOT = 26
    MOD_SILENCE = 27
    REFLECT_SPELLS = 28
    MOD_STAT = 29
    MOD_SKILL = 30
    MOD_INCREASE_SPEED = 31
    MOD_INCREASE_MOUNTED_SPEED = 32
    MOD_DECREASE_SPEED = 33
    MOD_INCREASE_HEALTH = 34
    MOD_INCREASE_ENERGY = 35
    MOD_SHAPESHIFT = 36
    EFFECT_IMMUNITY = 37
    STATE_IMMUNITY = 38
    SCHOOL_IMMUNITY = 39
    DAMAGE_IMMUNITY = 40
    DISPEL_IMMUNITY = 41
    PROC_TRIGGER_SPELL = 42
    PROC_TRIGGER_DAMAGE = 43
    TRACK_CREATURES = 44
    TRACK_RESOURCES = 45
    MOD_PARRY_SKILL = 46
    MOD_PARRY_PERCENT = 47
    MOD_DODGE_SKILL = 48
    MOD_DODGE_PERCENT = 49
    MOD_BLOCK_SKILL = 50
    MOD_BLOCK_PERCENT = 51
    MOD_CRIT_PERCENT = 52
    PERIODIC_LEECH = 53
    MOD_HIT_CHANCE = 54
    MOD_SPELL_HIT_CHANCE = 55
    TRANSFORM = 56
    MOD_SPELL_CRIT_CHANCE = 57
    MOD_INCREASE_SWIM_SPEED = 58
    MOD_DAMAGE_DONE_CREATURE = 59
    MOD_PACIFY_SILENCE = 60
    MOD_SCALE = 61
    PERIODIC_HEALTH_FUNNEL = 62
    PERIODIC_MANA_FUNNEL = 63
    PERIODIC_MANA_LEECH = 64
    MOD_CASTING_SPEED_NOT_STACK = 65
    FEIGN_DEATH = 66
    MOD_DISARM = 67
    MOD_STALKED = 68
    SCHOOL_ABSORB = 69
    EXTRA_ATTACKS = 70
    MOD_SPELL_CRIT_CHANCE_SCHOOL = 71
    MOD_POWER_COST_SCHOOL_PCT = 72
    MOD_POWER_COST_SCHOOL = 73
    REFLECT_SPELLS_SCHOOL = 74
    MOD_LANGUAGE = 75
    FAR_SIGHT = 76
    MECHANIC_IMMUNITY = 77
    MOUNTED = 78
    MOD_DAMAGE_PERCENT_DONE = 79
    MOD_PERCENT_STAT = 80
    SPLIT_DAMAGE_PCT = 81
    WATER_BREATHING = 82
    MOD_BASE_RESISTANCE = 83
    MOD_REGEN = 84
    MOD_POWER_REGEN = 85
    CHANNEL_DEATH_ITEM = 86
    MOD_DAMAGE_PERCENT_TAKEN = 87
    MOD_HEALTH_REGEN_PERCENT = 88
    PERIODIC_DAMAGE_PERCENT = 89
    MOD_RESIST_CHANCE = 90
    MOD_DETECT_RANGE = 91
    PREVENTS_FLEEING = 92
    MOD_UNATTACKABLE = 93
    INTERRUPT_REGEN = 94
    GHOST = 95
    SPELL_MAGNET = 96
    MANA_SHIELD = 97
    MOD_SKILL_TALENT = 98
    MOD_ATTACK_POWER = 99
    AURAS_VISIBLE = 100
    MOD_RESISTANCE_PCT = 101
    MOD_MELEE_ATTACK_POWER_VERSUS = 102
    MOD_TOTAL_THREAT = 103
    WATER_WALK = 104
    FEATHER_FALL = 105
    HOVER = 106
    ADD_FLAT_MODIFIER = 107
    ADD_PCT_MODIFIER = 108
    ADD_TARGET_TRIGGER = 109
    MOD_POWER_REGEN_PERCENT = 110
    ADD_CASTER_HIT_TRIGGER = 111
    OVERRIDE_CLASS_SCRIPTS = 112
    MOD_RANGED_DAMAGE_TAKEN = 113
    MOD_RANGED_DAMAGE_TAKEN_PCT = 114
    MOD_HEALING = 115
    MOD_REGEN_DURING_COMBAT = 116
    MOD_MECHANIC_RESISTANCE = 117
    MOD_HEALING_PCT = 118
    SHARE_PET_TRACKING = 119
    UNTRACKABLE = 120
    EMPATHY = 121
    MOD_OFFHAND_DAMAGE_PCT = 122
    MOD_TARGET_RESISTANCE = 123
    MOD_RANGED_ATTACK_POWER = 124
    MOD_MELEE_DAMAGE_TAKEN = 125
    MOD_MELEE_DAMAGE_TAKEN_PCT = 126
    RANGED_ATTACK_POWER_ATTACKER_BONUS = 127
    MOD_POSSESS_PET = 128
    MOD_SPEED_ALWAYS = 129
    MOD_MOUNTED_SPEED_ALWAYS = 130
    MOD_RANGED_ATTACK_POWER_VERSUS = 131
    MOD_INCREASE_ENERGY_PERCENT = 132
    MOD_INCREASE_HEALTH_PERCENT = 133
    MOD_MANA_REGEN_INTERRUPT = 134
    MOD_HEALING_DONE = 135
    MOD_HEALING_DONE_PERCENT = 136
    MOD_TOTAL_STAT_PERCENTAGE = 137
    MOD_MELEE_HASTE = 138
    FORCE_REACTION = 139
    MOD_RANGED_HASTE = 140
    MOD_RANGED_AMMO_HASTE = 141
    MOD_BASE_RESISTANCE_PCT = 142
    MOD_RESISTANCE_EXCLUSIVE = 143
    SAFE_FALL = 144
    CHARISMA = 145
    PERSUADED = 146
    MECHANIC_IMMUNITY_MASK = 147
    RETAIN_COMBO_POINTS = 148
    RESIST_PUSHBACK = 149
    MOD_SHIELD_BLOCKVALUE_PCT = 150
    TRACK_STEALTHED = 151
    MOD_DETECTED_RANGE = 152
    SPLIT_DAMAGE_FLAT = 153
    MOD_STEALTH_LEVEL = 154
    MOD_WATER_BREATHING = 155
    MOD_REPUTATION_GAIN = 156
    PET_DAMAGE_MULTI = 157
    MOD_SHIELD_BLOCKVALUE = 158
    NO_PVP_CREDIT = 159
    MOD_AOE_AVOIDANCE = 160
    MOD_HEALTH_REGEN_IN_COMBAT = 161
    POWER_BURN_MANA = 162
    MOD_CRIT_DAMAGE_BONUS = 163
    UNKNOWN164 = 164
    MELEE_ATTACK_POWER_ATTACKER_BONUS = 165
    MOD_ATTACK_POWER_PCT = 166
    MOD_RANGED_ATTACK_POWER_PCT = 167
    MOD_DAMAGE_DONE_VERSUS = 168
    MOD_CRIT_PERCENT_VERSUS = 169
    DETECT_AMORE = 170
    MOD_SPEED_NOT_STACK = 171
    MOD_MOUNTED_SPEED_NOT_STACK = 172
    ALLOW_CHAMPION_SPELLS = 173
    MOD_SPELL_DAMAGE_OF_STAT_PERCENT = 174
    MOD_SPELL_HEALING_OF_STAT_PERCENT = 175
    SPIRIT_OF_REDEMPTION = 176
    AOE_CHARM = 177
    MOD_DEBUFF_RESISTANCE = 178
    MOD_ATTACKER_SPELL_CRIT_CHANCE = 179
    MOD_FLAT_SPELL_DAMAGE_VERSUS = 180
    MOD_FLAT_SPELL_CRIT_DAMAGE_VERSUS = 181
    MOD_RESISTANCE_OF_STAT_PERCENT = 182
    MOD_CRITICAL_THREAT = 183
    MOD_ATTACKER_MELEE_HIT_CHANCE = 184
    MOD_ATTACKER_RANGED_HIT_CHANCE = 185
    MOD_ATTACKER_SPELL_HIT_CHANCE = 186
    MOD_ATTACKER_MELEE_CRIT_CHANCE = 187
    MOD_ATTACKER_RANGED_CRIT_CHANCE = 188
    MOD_RATING = 189
    MOD_FACTION_REPUTATION_GAIN = 190
    USE_NORMAL_MOVEMENT_SPEED = 191


class AuraType(enum.Enum):
    NONE = 0
    BIND_SIGHT = 1
    MOD_POSSESS = 2
    PERIODIC_DAMAGE = 3
    DUMMY = 4
    MOD_CONFUSE = 5
    MOD_CHARM = 6
    MOD_FEAR = 7
    PERIODIC_HEAL = 8
    MOD_ATTACKSPEED = 9
    MOD_THREAT = 10
    MOD_TAUNT = 11
    MOD_STUN = 12
    MOD_DAMAGE_DONE = 13
    MOD_DAMAGE_TAKEN = 14
    DAMAGE_SHIELD = 15
    MOD_STEALTH = 16
    MOD_STEALTH_DETECT = 17
    MOD_INVISIBILITY = 18
    MOD_INVISIBILITY_DETECTION = 19
    OBS_MOD_HEALTH = 20
    OBS_MOD_MANA = 21
    MOD_RESISTANCE = 22
    PERIODIC_TRIGGER_SPELL = 23
    PERIODIC_ENERGIZE = 24
    MOD_PACIFY = 25
    MOD_ROOT = 26
    MOD_SILENCE = 27
    REFLECT_SPELLS = 28
    MOD_STAT = 29
    MOD_SKILL = 30
    MOD_INCREASE_SPEED = 31
    MOD_INCREASE_MOUNTED_SPEED = 32
    MOD_DECREASE_SPEED = 33
    MOD_INCREASE_HEALTH = 34
    MOD_INCREASE_ENERGY = 35
    MOD_SHAPESHIFT = 36
    EFFECT_IMMUNITY = 37
    STATE_IMMUNITY = 38
    SCHOOL_IMMUNITY = 39
    DAMAGE_IMMUNITY = 40
    DISPEL_IMMUNITY = 41
    PROC_TRIGGER_SPELL = 42
    PROC_TRIGGER_DAMAGE = 43
    TRACK_CREATURES = 44
    TRACK_RESOURCES = 45
    UNKNOWN46 = 46
    MOD_PARRY_PERCENT = 47
    UNKNOWN48 = 48
    MOD_DODGE_PERCENT = 49
    MOD_BLOCK_SKILL = 50
    MOD_BLOCK_PERCENT = 51
    MOD_CRIT_PERCENT = 52
    PERIODIC_LEECH = 53
    MOD_HIT_CHANCE = 54
    MOD_SPELL_HIT_CHANCE = 55
    TRANSFORM = 56
    MOD_SPELL_CRIT_CHANCE = 57
    MOD_INCREASE_SWIM_SPEED = 58
    MOD_DAMAGE_DONE_CREATURE = 59
    MOD_PACIFY_SILENCE = 60
    MOD_SCALE = 61
    PERIODIC_HEALTH_FUNNEL = 62
    PERIODIC_MANA_FUNNEL = 63
    PERIODIC_MANA_LEECH = 64
    MOD_CASTING_SPEED_NOT_STACK = 65
    FEIGN_DEATH = 66
    MOD_DISARM = 67
    MOD_STALKED = 68
    SCHOOL_ABSORB = 69
    EXTRA_ATTACKS = 70
    MOD_SPELL_CRIT_CHANCE_SCHOOL = 71
    MOD_POWER_COST_SCHOOL_PCT = 72
    MOD_POWER_COST_SCHOOL = 73
    REFLECT_SPELLS_SCHOOL = 74
    MOD_LANGUAGE = 75
    FAR_SIGHT = 76
    MECHANIC_IMMUNITY = 77
    MOUNTED = 78
    MOD_DAMAGE_PERCENT_DONE = 79
    MOD_PERCENT_STAT = 80
    SPLIT_DAMAGE_PCT = 81
    WATER_BREATHING = 82
    MOD_BASE_RESISTANCE = 83
    MOD_REGEN = 84
    MOD_POWER_REGEN = 85
    CHANNEL_DEATH_ITEM = 86
    MOD_DAMAGE_PERCENT_TAKEN = 87
    MOD_HEALTH_REGEN_PERCENT = 88
    PERIODIC_DAMAGE_PERCENT = 89
    MOD_RESIST_CHANCE = 90
    MOD_DETECT_RANGE = 91
    PREVENTS_FLEEING = 92
    MOD_UNATTACKABLE = 93
    INTERRUPT_REGEN = 94
    GHOST = 95
    SPELL_MAGNET = 96
    MANA_SHIELD = 97
    MOD_SKILL_TALENT = 98
    MOD_ATTACK_POWER = 99
    AURAS_VISIBLE = 100
    MOD_RESISTANCE_PCT = 101
    MOD_MELEE_ATTACK_POWER_VERSUS = 102
    MOD_TOTAL_THREAT = 103
    WATER_WALK = 104
    FEATHER_FALL = 105
    HOVER = 106
    ADD_FLAT_MODIFIER = 107
    ADD_PCT_MODIFIER = 108
    ADD_TARGET_TRIGGER = 109
    MOD_POWER_REGEN_PERCENT = 110
    ADD_CASTER_HIT_TRIGGER = 111
    OVERRIDE_CLASS_SCRIPTS = 112
    MOD_RANGED_DAMAGE_TAKEN = 113
    MOD_RANGED_DAMAGE_TAKEN_PCT = 114
    MOD_HEALING = 115
    MOD_REGEN_DURING_COMBAT = 116
    MOD_MECHANIC_RESISTANCE = 117
    MOD_HEALING_PCT = 118
    SHARE_PET_TRACKING = 119
    UNTRACKABLE = 120
    EMPATHY = 121
    MOD_OFFHAND_DAMAGE_PCT = 122
    MOD_TARGET_RESISTANCE = 123
    MOD_RANGED_ATTACK_POWER = 124
    MOD_MELEE_DAMAGE_TAKEN = 125
    MOD_MELEE_DAMAGE_TAKEN_PCT = 126
    RANGED_ATTACK_POWER_ATTACKER_BONUS = 127
    MOD_POSSESS_PET = 128
    MOD_SPEED_ALWAYS = 129
    MOD_MOUNTED_SPEED_ALWAYS = 130
    MOD_RANGED_ATTACK_POWER_VERSUS = 131
    MOD_INCREASE_ENERGY_PERCENT = 132
    MOD_INCREASE_HEALTH_PERCENT = 133
    MOD_MANA_REGEN_INTERRUPT = 134
    MOD_HEALING_DONE = 135
    MOD_HEALING_DONE_PERCENT = 136
    MOD_TOTAL_STAT_PERCENTAGE = 137
    MOD_MELEE_HASTE = 138
    FORCE_REACTION = 139
    MOD_RANGED_HASTE = 140
    MOD_RANGED_AMMO_HASTE = 141
    MOD_BASE_RESISTANCE_PCT = 142
    MOD_RESISTANCE_EXCLUSIVE = 143
    SAFE_FALL = 144
    CHARISMA = 145
    PERSUADED = 146
    MECHANIC_IMMUNITY_MASK = 147
    RETAIN_COMBO_POINTS = 148
    RESIST_PUSHBACK = 149
    MOD_SHIELD_BLOCKVALUE_PCT = 150
    TRACK_STEALTHED = 151
    MOD_DETECTED_RANGE = 152
    SPLIT_DAMAGE_FLAT = 153
    MOD_STEALTH_LEVEL = 154
    MOD_WATER_BREATHING = 155
    MOD_REPUTATION_GAIN = 156
    PET_DAMAGE_MULTI = 157
    MOD_SHIELD_BLOCKVALUE = 158
    NO_PVP_CREDIT = 159
    MOD_AOE_AVOIDANCE = 160
    MOD_HEALTH_REGEN_IN_COMBAT = 161
    POWER_BURN_MANA = 162
    MOD_CRIT_DAMAGE_BONUS = 163
    UNKNOWN164 = 164
    MELEE_ATTACK_POWER_ATTACKER_BONUS = 165
    MOD_ATTACK_POWER_PCT = 166
    MOD_RANGED_ATTACK_POWER_PCT = 167
    MOD_DAMAGE_DONE_VERSUS = 168
    MOD_CRIT_PERCENT_VERSUS = 169
    DETECT_AMORE = 170
    MOD_SPEED_NOT_STACK = 171
    MOD_MOUNTED_SPEED_NOT_STACK = 172
    ALLOW_CHAMPION_SPELLS = 173
    MOD_SPELL_DAMAGE_OF_STAT_PERCENT = 174
    MOD_SPELL_HEALING_OF_STAT_PERCENT = 175
    SPIRIT_OF_REDEMPTION = 176
    AOE_CHARM = 177
    MOD_DEBUFF_RESISTANCE = 178
    MOD_ATTACKER_SPELL_CRIT_CHANCE = 179
    MOD_FLAT_SPELL_DAMAGE_VERSUS = 180
    MOD_FLAT_SPELL_CRIT_DAMAGE_VERSUS = 181
    MOD_RESISTANCE_OF_STAT_PERCENT = 182
    MOD_CRITICAL_THREAT = 183
    MOD_ATTACKER_MELEE_HIT_CHANCE = 184
    MOD_ATTACKER_RANGED_HIT_CHANCE = 185
    MOD_ATTACKER_SPELL_HIT_CHANCE = 186
    MOD_ATTACKER_MELEE_CRIT_CHANCE = 187
    MOD_ATTACKER_RANGED_CRIT_CHANCE = 188
    MOD_RATING = 189
    MOD_FACTION_REPUTATION_GAIN = 190
    USE_NORMAL_MOVEMENT_SPEED = 191


class BagFamily(enum.Enum):
    NONE = 0
    ARROWS = 1
    BULLETS = 2
    SOUL_SHARDS = 3
    UNKNOWN4 = 4
    UNKNOWN5 = 5
    HERBS = 6
    ENCHANTING_SUPPLIES = 7
    ENGINEERING_SUPPLIES = 8
    KEYS = 9


class BattlefieldPortAction(enum.Enum):
    LEAVE_QUEUE = 0
    ENTER_BATTLE = 1


class BattlegroundBracket(enum.Enum):
    TENS = 0
    TWENTIES = 1
    THIRTIES = 2
    FORTIES = 3
    FIFTIES = 4
    SIXTY = 5


class BattlegroundEndStatus(enum.Enum):
    NOT_ENDED = 0
    ENDED = 1


class BattlegroundWinner(enum.Enum):
    HORDE = 0
    ALLIANCE = 1
    NONE = 2


class BgTypeId(enum.Enum):
    NOT_ELIGIBLE = 0
    QUEUED_FOR_AV = 1
    QUEUED_FOR_WSG = 2
    QUEUED_FOR_AB = 3
    REMOVE_FROM_QUEUE = 4294967294


class Bonding(enum.Enum):
    NO_BIND = 0
    PICK_UP = 1
    EQUIP = 2
    USE = 3
    QUEST_ITEM = 4
    QUEST_ITEM1 = 5


class BuyBankSlotResult(enum.Enum):
    FAILED_TOO_MANY = 0
    INSUFFICIENT_FUNDS = 1
    NOT_BANKER = 2
    OK = 3


class BuyResult(enum.Enum):
    CANT_FIND_ITEM = 0
    ITEM_ALREADY_SOLD = 1
    NOT_ENOUGH_MONEY = 2
    SELLER_DONT_LIKE_YOU = 4
    DISTANCE_TOO_FAR = 5
    ITEM_SOLD_OUT = 7
    CANT_CARRY_MORE = 8
    RANK_REQUIRE = 11
    REPUTATION_REQUIRE = 12


class BuybackSlot(enum.Enum):
    SLOT1 = 69
    SLOT2 = 70
    SLOT3 = 71
    SLOT4 = 72
    SLOT5 = 73
    SLOT6 = 74
    SLOT7 = 75
    SLOT8 = 76
    SLOT9 = 77
    SLOT10 = 78
    SLOT11 = 79
    SLOT12 = 80
    SLOT13 = 81


class CastFailureReason(enum.Enum):
    AFFECTING_COMBAT = 0
    ALREADY_AT_FULL_HEALTH = 1
    ALREADY_AT_FULL_POWER = 2
    ALREADY_BEING_TAMED = 3
    ALREADY_HAVE_CHARM = 4
    ALREADY_HAVE_SUMMON = 5
    ALREADY_OPEN = 6
    AURA_BOUNCED = 7
    AUTOTRACK_INTERRUPTED = 8
    BAD_IMPLICIT_TARGETS = 9
    BAD_TARGETS = 10
    CANT_BE_CHARMED = 11
    CANT_BE_DISENCHANTED = 12
    CANT_BE_PROSPECTED = 13
    CANT_CAST_ON_TAPPED = 14
    CANT_DUEL_WHILE_INVISIBLE = 15
    CANT_DUEL_WHILE_STEALTHED = 16
    CANT_STEALTH = 17
    CASTER_AURASTATE = 18
    CASTER_DEAD = 19
    CHARMED = 20
    CHEST_IN_USE = 21
    CONFUSED = 22
    DONT_REPORT = 23
    EQUIPPED_ITEM = 24
    EQUIPPED_ITEM_CLASS = 25
    EQUIPPED_ITEM_CLASS_MAINHAND = 26
    EQUIPPED_ITEM_CLASS_OFFHAND = 27
    ERROR = 28
    FIZZLE = 29
    FLEEING = 30
    FOOD_LOWLEVEL = 31
    HIGHLEVEL = 32
    HUNGER_SATIATED = 33
    IMMUNE = 34
    INTERRUPTED = 35
    INTERRUPTED_COMBAT = 36
    ITEM_ALREADY_ENCHANTED = 37
    ITEM_GONE = 38
    ITEM_NOT_FOUND = 39
    ITEM_NOT_READY = 40
    LEVEL_REQUIREMENT = 41
    LINE_OF_SIGHT = 42
    LOWLEVEL = 43
    LOW_CASTLEVEL = 44
    MAINHAND_EMPTY = 45
    MOVING = 46
    NEED_AMMO = 47
    NEED_AMMO_POUCH = 48
    NEED_EXOTIC_AMMO = 49
    NOPATH = 50
    NOT_BEHIND = 51
    NOT_FISHABLE = 52
    NOT_HERE = 53
    NOT_INFRONT = 54
    NOT_IN_CONTROL = 55
    NOT_KNOWN = 56
    NOT_MOUNTED = 57
    NOT_ON_TAXI = 58
    NOT_ON_TRANSPORT = 59
    NOT_READY = 60
    NOT_SHAPESHIFT = 61
    NOT_STANDING = 62
    NOT_TRADEABLE = 63
    NOT_TRADING = 64
    NOT_UNSHEATHED = 65
    NOT_WHILE_GHOST = 66
    NO_AMMO = 67
    NO_CHARGES_REMAIN = 68
    NO_CHAMPION = 69
    NO_COMBO_POINTS = 70
    NO_DUELING = 71
    NO_ENDURANCE = 72
    NO_FISH = 73
    NO_ITEMS_WHILE_SHAPESHIFTED = 74
    NO_MOUNTS_ALLOWED = 75
    NO_PET = 76
    NO_POWER = 77
    NOTHING_TO_DISPEL = 78
    NOTHING_TO_STEAL = 79
    ONLY_ABOVEWATER = 80
    ONLY_DAYTIME = 81
    ONLY_INDOORS = 82
    ONLY_MOUNTED = 83
    ONLY_NIGHTTIME = 84
    ONLY_OUTDOORS = 85
    ONLY_SHAPESHIFT = 86
    ONLY_STEALTHED = 87
    ONLY_UNDERWATER = 88
    OUT_OF_RANGE = 89
    PACIFIED = 90
    POSSESSED = 91
    REAGENTS = 92
    REQUIRES_AREA = 93
    REQUIRES_SPELL_FOCUS = 94
    ROOTED = 95
    SILENCED = 96
    SPELL_IN_PROGRESS = 97
    SPELL_LEARNED = 98
    SPELL_UNAVAILABLE = 99
    STUNNED = 100
    TARGETS_DEAD = 101
    TARGET_AFFECTING_COMBAT = 102
    TARGET_AURASTATE = 103
    TARGET_DUELING = 104
    TARGET_ENEMY = 105
    TARGET_ENRAGED = 106
    TARGET_FRIENDLY = 107
    TARGET_IN_COMBAT = 108
    TARGET_IS_PLAYER = 109
    TARGET_NOT_DEAD = 110
    TARGET_NOT_IN_PARTY = 111
    TARGET_NOT_LOOTED = 112
    TARGET_NOT_PLAYER = 113
    TARGET_NO_POCKETS = 114
    TARGET_NO_WEAPONS = 115
    TARGET_UNSKINNABLE = 116
    THIRST_SATIATED = 117
    TOO_CLOSE = 118
    TOO_MANY_OF_ITEM = 119
    TOTEMS = 120
    TRAINING_POINTS = 121
    TRY_AGAIN = 122
    UNIT_NOT_BEHIND = 123
    UNIT_NOT_INFRONT = 124
    WRONG_PET_FOOD = 125
    NOT_WHILE_FATIGUED = 126
    TARGET_NOT_IN_INSTANCE = 127
    NOT_WHILE_TRADING = 128
    TARGET_NOT_IN_RAID = 129
    DISENCHANT_WHILE_LOOTING = 130
    PROSPECT_WHILE_LOOTING = 131
    PROSPECT_NEED_MORE = 132
    TARGET_FREEFORALL = 133
    NO_EDIBLE_CORPSES = 134
    ONLY_BATTLEGROUNDS = 135
    TARGET_NOT_GHOST = 136
    TOO_MANY_SKILLS = 137
    TRANSFORM_UNUSABLE = 138
    WRONG_WEATHER = 139
    DAMAGE_IMMUNE = 140
    PREVENTED_BY_MECHANIC = 141
    PLAY_TIME = 142
    REPUTATION = 143
    MIN_SKILL = 144
    UNKNOWN = 145


class ChatNotify(enum.Enum):
    JOINED_NOTICE = 0
    LEFT_NOTICE = 1
    YOU_JOINED_NOTICE = 2
    YOU_LEFT_NOTICE = 3
    WRONG_PASSWORD_NOTICE = 4
    NOT_MEMBER_NOTICE = 5
    NOT_MODERATOR_NOTICE = 6
    PASSWORD_CHANGED_NOTICE = 7
    OWNER_CHANGED_NOTICE = 8
    PLAYER_NOT_FOUND_NOTICE = 9
    NOT_OWNER_NOTICE = 10
    CHANNEL_OWNER_NOTICE = 11
    MODE_CHANGE_NOTICE = 12
    ANNOUNCEMENTS_ON_NOTICE = 13
    ANNOUNCEMENTS_OFF_NOTICE = 14
    MODERATION_ON_NOTICE = 15
    MODERATION_OFF_NOTICE = 16
    MUTED_NOTICE = 17
    PLAYER_KICKED_NOTICE = 18
    BANNED_NOTICE = 19
    PLAYER_BANNED_NOTICE = 20
    PLAYER_UNBANNED_NOTICE = 21
    PLAYER_NOT_BANNED_NOTICE = 22
    PLAYER_ALREADY_MEMBER_NOTICE = 23
    INVITE_NOTICE = 24
    INVITE_WRONG_FACTION_NOTICE = 25
    WRONG_FACTION_NOTICE = 26
    INVALID_NAME_NOTICE = 27
    NOT_MODERATED_NOTICE = 28
    PLAYER_INVITED_NOTICE = 29
    PLAYER_INVITE_BANNED_NOTICE = 30
    THROTTLED_NOTICE = 31


class ChatType(enum.Enum):
    SAY = 0
    PARTY = 1
    RAID = 2
    GUILD = 3
    OFFICER = 4
    YELL = 5
    WHISPER = 6
    WHISPER_INFORM = 7
    EMOTE = 8
    TEXT_EMOTE = 9
    SYSTEM = 10
    MONSTER_SAY = 11
    MONSTER_YELL = 12
    MONSTER_EMOTE = 13
    CHANNEL = 14
    CHANNEL_JOIN = 15
    CHANNEL_LEAVE = 16
    CHANNEL_LIST = 17
    CHANNEL_NOTICE = 18
    CHANNEL_NOTICE_USER = 19
    AFK = 20
    DND = 21
    IGNORED = 22
    SKILL = 23
    LOOT = 24
    MONSTER_WHISPER = 26
    BG_SYSTEM_NEUTRAL = 82
    BG_SYSTEM_ALLIANCE = 83
    BG_SYSTEM_HORDE = 84
    RAID_LEADER = 87
    RAID_WARNING = 88
    RAID_BOSS_WHISPER = 89
    RAID_BOSS_EMOTE = 90
    BATTLEGROUND = 92
    BATTLEGROUND_LEADER = 93


class CinematicSequenceId(enum.Enum):
    GOBLIN = 0
    UNDEAD = 2
    ORC = 21
    DWARF = 41
    NIGHT_ELF = 61
    HUMAN = 81
    GNOME = 101
    TROLL = 121
    TAUREN = 141


class Class(enum.Enum):
    WARRIOR = 1
    PALADIN = 2
    HUNTER = 3
    ROGUE = 4
    PRIEST = 5
    SHAMAN = 7
    MAGE = 8
    WARLOCK = 9
    DRUID = 11


class ClientLanguage(enum.Enum):
    ENGLISH = 0
    KOREAN = 1
    FRENCH = 2
    GERMAN = 3
    CHINESE = 4
    TAIWANESE = 5
    SPANISH_SPAIN = 6
    SPANISH_LATIN_AMERICA = 7


class CompressedMoveOpcode(enum.Enum):
    SMSG_MONSTER_MOVE = 221
    SMSG_MONSTER_MOVE_TRANSPORT = 686
    SMSG_SPLINE_SET_RUN_SPEED = 766
    SMSG_SPLINE_MOVE_UNROOT = 772
    SMSG_SPLINE_MOVE_SET_RUN_MODE = 781
    SMSG_SPLINE_MOVE_SET_WALK_MODE = 782


class CorpseQueryResult(enum.Enum):
    NOT_FOUND = 0
    FOUND = 1


class CreatureFamily(enum.Enum):
    NONE = 0
    WOLF = 1
    CAT = 2
    SPIDER = 3
    BEAR = 4
    BOAR = 5
    CROCOLISK = 6
    CARRION_BIRD = 7
    CRAB = 8
    GORILLA = 9
    RAPTOR = 11
    TALLSTRIDER = 12
    FELHUNTER = 15
    VOIDWALKER = 16
    SUCCUBUS = 17
    DOOMGUARD = 19
    SCORPID = 20
    TURTLE = 21
    IMP = 23
    BAT = 24
    HYENA = 25
    OWL = 26
    WIND_SERPENT = 27
    REMOTE_CONTROL = 28


class DismountResult(enum.Enum):
    NOT_MOUNTED = 1
    OK = 3


class DuelWinnerReason(enum.Enum):
    WON = 0
    FLED = 1


class Emote(enum.Enum):
    ONESHOT_NONE = 0
    ONESHOT_TALK = 1
    ONESHOT_BOW = 2
    ONESHOT_WAVE = 3
    ONESHOT_CHEER = 4
    ONESHOT_EXCLAMATION = 5
    ONESHOT_QUESTION = 6
    ONESHOT_EAT = 7
    STATE_DANCE = 10
    ONESHOT_LAUGH = 11
    STATE_SLEEP = 12
    STATE_SIT = 13
    ONESHOT_RUDE = 14
    ONESHOT_ROAR = 15
    ONESHOT_KNEEL = 16
    ONESHOT_KISS = 17
    ONESHOT_CRY = 18
    ONESHOT_CHICKEN = 19
    ONESHOT_BEG = 20
    ONESHOT_APPLAUD = 21
    ONESHOT_SHOUT = 22
    ONESHOT_FLEX = 23
    ONESHOT_SHY = 24
    ONESHOT_POINT = 25
    STATE_STAND = 26
    STATE_READYUNARMED = 27
    STATE_WORK_SHEATHED = 28
    STATE_POINT = 29
    STATE_NONE = 30
    ONESHOT_WOUND = 33
    ONESHOT_WOUNDCRITICAL = 34
    ONESHOT_ATTACKUNARMED = 35
    ONESHOT_ATTACK1H = 36
    ONESHOT_ATTACK2HTIGHT = 37
    ONESHOT_ATTACK2HLOOSE = 38
    ONESHOT_PARRYUNARMED = 39
    ONESHOT_PARRYSHIELD = 43
    ONESHOT_READYUNARMED = 44
    ONESHOT_READY1H = 45
    ONESHOT_READYBOW = 48
    ONESHOT_SPELLPRECAST = 50
    ONESHOT_SPELLCAST = 51
    ONESHOT_BATTLEROAR = 53
    ONESHOT_SPECIALATTACK1H = 54
    ONESHOT_KICK = 60
    ONESHOT_ATTACKTHROWN = 61
    STATE_STUN = 64
    STATE_DEAD = 65
    ONESHOT_SALUTE = 66
    STATE_KNEEL = 68
    STATE_USESTANDING = 69
    ONESHOT_WAVE_NOSHEATHE = 70
    ONESHOT_CHEER_NOSHEATHE = 71
    ONESHOT_EAT_NOSHEATHE = 92
    STATE_STUN_NOSHEATHE = 93
    ONESHOT_DANCE = 94
    ONESHOT_SALUTE_NOSHEATH = 113
    STATE_USESTANDING_NOSHEATHE = 133
    ONESHOT_LAUGH_NOSHEATHE = 153
    STATE_WORK = 173
    STATE_SPELLPRECAST = 193
    ONESHOT_READYRIFLE = 213
    STATE_READYRIFLE = 214
    STATE_WORK_MINING = 233
    STATE_WORK_CHOPWOOD = 234
    STATE_APPLAUD = 253
    ONESHOT_LIFTOFF = 254
    ONESHOT_YES = 273
    ONESHOT_NO = 274
    ONESHOT_TRAIN = 275
    ONESHOT_LAND = 293
    STATE_AT_EASE = 313
    STATE_READY1H = 333
    STATE_SPELLKNEELSTART = 353
    STATE_SUBMERGED = 373
    ONESHOT_SUBMERGE = 374
    STATE_READY2H = 375
    STATE_READYBOW = 376
    ONESHOT_MOUNTSPECIAL = 377
    STATE_TALK = 378
    STATE_FISHING = 379
    ONESHOT_FISHING = 380
    ONESHOT_LOOT = 381
    STATE_WHIRLWIND = 382
    STATE_DROWNED = 383
    STATE_HOLD_BOW = 384
    STATE_HOLD_RIFLE = 385
    STATE_HOLD_THROWN = 386
    ONESHOT_DROWN = 387
    ONESHOT_STOMP = 388
    ONESHOT_ATTACKOFF = 389
    ONESHOT_ATTACKOFFPIERCE = 390
    STATE_ROAR = 391
    STATE_LAUGH = 392
    ONESHOT_CREATURE_SPECIAL = 393
    ONESHOT_JUMPLANDRUN = 394
    ONESHOT_JUMPEND = 395
    ONESHOT_TALK_NOSHEATHE = 396
    ONESHOT_POINT_NOSHEATHE = 397
    STATE_CANNIBALIZE = 398
    ONESHOT_JUMPSTART = 399
    STATE_DANCESPECIAL = 400
    ONESHOT_DANCESPECIAL = 401
    ONESHOT_CUSTOMSPELL01 = 402
    ONESHOT_CUSTOMSPELL02 = 403
    ONESHOT_CUSTOMSPELL03 = 404
    ONESHOT_CUSTOMSPELL04 = 405
    ONESHOT_CUSTOMSPELL05 = 406
    ONESHOT_CUSTOMSPELL06 = 407
    ONESHOT_CUSTOMSPELL07 = 408
    ONESHOT_CUSTOMSPELL08 = 409
    ONESHOT_CUSTOMSPELL09 = 410
    ONESHOT_CUSTOMSPELL10 = 411
    STATE_EXCLAIM = 412
    STATE_SIT_CHAIR_MED = 415
    STATE_SPELLEFFECT_HOLD = 422
    STATE_EAT_NO_SHEATHE = 423


class EmoteSpecProc(enum.Enum):
    NO_LOOP = 0
    LOOP = 1
    LOOP_WITH_SOUND = 2


class EnvironmentalDamageType(enum.Enum):
    EXHAUSTED = 0
    DROWNING = 1
    FALL = 2
    LAVA = 3
    SLIME = 4
    FIRE = 5


class ExperienceAwardType(enum.Enum):
    KILL = 0
    NON_KILL = 1


class Faction(enum.Enum):
    NONE = 0
    PLAYER_HUMAN = 1
    PLAYER_ORC = 2
    PLAYER_DWARF = 3
    PLAYER_NIGHT_ELF = 4
    PLAYER_UNDEAD = 5
    PLAYER_TAUREN = 6
    CREATURE = 7
    PLAYER_GNOME = 8
    PLAYER_TROLL = 9
    MONSTER = 14
    DEFIAS_BROTHERHOOD = 15
    GNOLL_RIVERPAW = 16
    GNOLL_REDRIDGE = 17
    GNOLL_SHADOWHIDE = 18
    MURLOC = 19
    UNDEAD_SCOURGE = 20
    BOOTY_BAY = 21
    BEAST_SPIDER = 22
    BEAST_BOAR = 23
    WORGEN = 24
    KOBOLD = 25
    TROLL_BLOODSCALP = 26
    TROLL_SKULLSPLITTER = 27
    PREY = 28
    BEAST_WOLF = 29
    DEFIAS_BROTHERHOOD_TRAITOR = 30
    FRIENDLY = 31
    TROGG = 32
    TROLL_FROSTMANE = 33
    ORC_BLACKROCK = 34
    VILLIAN = 35
    VICTIM = 36
    BEAST_BEAR = 37
    OGRE = 38
    KURZENS_MERCENARIES = 39
    ESCORTEE = 40
    VENTURE_COMPANY = 41
    BEAST_RAPTOR = 42
    BASILISK = 43
    DRAGONFLIGHT_GREEN = 44
    LOST_ONES = 45
    BLACKSMITHING_ARMORSMITHING = 46
    IRONFORGE = 47
    DARK_IRON_DWARVES = 48
    HUMAN_NIGHT_WATCH = 49
    DRAGONFLIGHT_RED = 50
    GNOLL_MOSSHIDE = 51
    ORC_DRAGONMAW = 52
    GNOME_LEPER = 53
    GNOMEREGAN_EXILES = 54
    LEOPARD = 55
    SCARLET_CRUSADE = 56
    GNOLL_ROTHIDE = 57
    BEAST_GORILLA = 58
    THORIUM_BROTHERHOOD = 59
    NAGA = 60
    DALARAN = 61
    FORLORN_SPIRIT = 62
    DARKHOWL = 63
    GRELL = 64
    FURBOLG = 65
    HORDE_GENERIC = 66
    HORDE = 67
    UNDERCITY = 68
    DARNASSUS = 69
    SYNDICATE = 70
    HILLSBRAD_MILITIA = 71
    STORMWIND = 72
    DEMON = 73
    ELEMENTAL = 74
    SPIRIT = 75
    ORGRIMMAR = 76
    TREASURE = 77
    GNOLL_MUDSNOUT = 78
    HILLSBRAD_SOUTHSHORE_MAYOR = 79
    DRAGONFLIGHT_BLACK = 80
    THUNDER_BLUFF = 81
    TROLL_WITHERBARK = 82
    LEATHERWORKING_ELEMENTAL = 83
    QUILBOAR_RAZORMANE = 84
    QUILBOAR_BRISTLEBACK = 85
    LEATHERWORKING_DRAGONSCALE = 86
    BLOODSAIL_BUCCANEERS = 87
    BLACKFATHOM = 88
    MAKRURA = 89
    CENTAUR_KOLKAR = 90
    CENTAUR_GALAK = 91
    GELKIS_CLAN_CENTAUR = 92
    MAGRAM_CLAN_CENTAUR = 93
    MARAUDINE = 94
    THERAMORE = 108
    QUILBOAR_RAZORFEN = 109
    QUILBOAR_RAZORMANE_2 = 110
    QUILBOAR_DEATHSHEAD = 111
    ENEMY = 128
    AMBIENT = 148
    NETHERGARDE_CARAVAN = 168
    STEAMWHEEDLE_CARTEL = 169
    ALLIANCE_GENERIC = 189
    NETHERGARDE = 209
    WAILING_CAVERNS = 229
    SILITHID = 249
    SILVERMOON_REMNANT = 269
    ZANDALAR_TRIBE = 270
    BLACKSMITHING_WEAPONSMITHING = 289
    SCORPID = 309
    BEAST_BAT = 310
    TITAN = 311
    TASKMASTER_FIZZULE = 329
    RAVENHOLDT = 349
    GADGETZAN = 369
    GNOMEREGAN_BUG = 389
    HARPY = 409
    BURNING_BLADE = 429
    SHADOWSILK_POACHER = 449
    SEARING_SPIDER = 450
    ALLIANCE = 469
    RATCHET = 470
    WILDHAMMER_CLAN = 471
    GOBLIN_DARK_IRON_BAR_PATRON = 489
    THE_LEAGUE_OF_ARATHOR = 509
    THE_DEFILERS = 510
    GIANT = 511
    ARGENT_DAWN = 529
    DARKSPEAR_TROLLS = 530
    DRAGONFLIGHT_BRONZE = 531
    DRAGONFLIGHT_BLUE = 532
    LEATHERWORKING_TRIBAL = 549
    ENGINEERING_GOBLIN = 550
    ENGINEERING_GNOME = 551
    BLACKSMITHING_HAMMERSMITHING = 569
    BLACKSMITHING_AXESMITHING = 570
    BLACKSMITHING_SWORDSMITHING = 571
    TROLL_VILEBRANCH = 572
    SOUTHSEA_FREEBOOTERS = 573
    CAER_DARROW = 574
    FURBOLG_UNCORRUPTED = 575
    TIMBERMAW_HOLD = 576
    EVERLOOK = 577
    WINTERSABER_TRAINERS = 589
    CENARION_CIRCLE = 609
    SHATTERSPEAR_TROLLS = 629
    RAVASAUR_TRAINERS = 630
    MAJORDOMO_EXECUTUS = 649
    BEAST_CARRION_BIRD = 669
    BEAST_CAT = 670
    BEAST_CRAB = 671
    BEAST_CROCILISK = 672
    BEAST_HYENA = 673
    BEAST_OWL = 674
    BEAST_SCORPID = 675
    BEAST_TALLSTRIDER = 676
    BEAST_TURTLE = 677
    BEAST_WIND_SERPENT = 678
    TRAINING_DUMMY = 679
    DRAGONFLIGHT_BLACK_BAIT = 689
    BATTLEGROUND_NEUTRAL = 709
    FROSTWOLF_CLAN = 729
    STORMPIKE_GUARD = 730
    HYDRAXIAN_WATERLORDS = 749
    SULFURON_FIRELORDS = 750
    GIZLOCKS_DUMMY = 769
    GIZLOCKS_CHARM = 770
    GIZLOCK = 771
    MORO_GAI = 789
    SPIRIT_GUIDE_ALLIANCE = 790
    SHEN_DRALAR = 809
    OGRE_CAPTAIN_KROMCRUSH = 829
    SPIRIT_GUIDE_HORDE = 849
    JAEDENAR = 869
    WARSONG_OUTRIDERS = 889
    SILVERWING_SENTINELS = 890
    ALLIANCE_FORCES = 891
    HORDE_FORCES = 892
    REVANTUSK_TROLLS = 893
    DARKMOON_FAIRE = 909
    BROOD_OF_NOZDORMU = 910
    MIGHT_OF_KALIMDOR = 912
    ARMIES_OF_C_THUN = 915
    SILITHID_ATTACKERS = 916
    THE_IRONFORGE_BRIGADE = 917
    RC_ENEMIES = 918
    RC_OBJECTS = 919
    RED = 920
    BLUE = 921
    SCOURGE_INVADERS = 928
    TEST_FACTION_NOT_A_REAL_FACTION = 931
    TOWOW_FLAG = 950
    TOWOW_FLAG_TRIGGER_ALLIANCE_DND = 951
    TOWOW_FLAG_TRIGGER_HORDE_DND = 954


class FarSightOperation(enum.Enum):
    REMOVE = 0
    ADD = 1


class FluidSpeed(enum.Enum):
    STILL = 0
    SLOW = 4
    RAPID = 8


class FriendResult(enum.Enum):
    DB_ERROR = 0
    LIST_FULL = 1
    ONLINE = 2
    OFFLINE = 3
    NOT_FOUND = 4
    REMOVED = 5
    ADDED_ONLINE = 6
    ADDED_OFFLINE = 7
    ALREADY = 8
    SELF = 9
    ENEMY = 10
    IGNORE_FULL = 11
    IGNORE_SELF = 12
    IGNORE_NOT_FOUND = 13
    IGNORE_ALREADY = 14
    IGNORE_ADDED = 15
    IGNORE_REMOVED = 16
    IGNORE_AMBIGUOUS = 17
    MUTE_FULL = 18
    MUTE_SELF = 19
    MUTE_NOT_FOUND = 20
    MUTE_ALREADY = 21
    MUTE_ADDED = 22
    MUTE_REMOVED = 23
    MUTE_AMBIGUOUS = 24
    UNKNOWN19 = 25
    UNKNOWN20 = 26


class FriendStatus(enum.Enum):
    OFFLINE = 0
    ONLINE = 1
    AFK = 2
    UNKNOWN3 = 3
    DND = 4


class Gender(enum.Enum):
    MALE = 0
    FEMALE = 1
    NONE = 2


class GmTicketEscalationStatus(enum.Enum):
    GMTICKET_ASSIGNEDTOGM_STATUS_NOT_ASSIGNED = 0
    GMTICKET_ASSIGNEDTOGM_STATUS_ASSIGNED = 1
    GMTICKET_ASSIGNEDTOGM_STATUS_ESCALATED = 2


class GmTicketQueueStatus(enum.Enum):
    ENABLED = 1
    DISABLED = 0


class GmTicketResponse(enum.Enum):
    NOT_EXIST = 0
    ALREADY_EXIST = 1
    CREATE_SUCCESS = 2
    CREATE_ERROR = 3
    UPDATE_SUCCESS = 4
    UPDATE_ERROR = 5
    TICKET_DELETED = 9


class GmTicketStatus(enum.Enum):
    DB_ERROR = 0
    HAS_TEXT = 6
    DEFAULT = 10


class GmTicketStatusResponse(enum.Enum):
    UPDATED = 1
    CLOSED = 2
    SURVEY = 3


class GmTicketType(enum.Enum):
    STUCK = 1
    BEHAVIOR_HARASSMENT = 2
    GUILD = 3
    ITEM = 4
    ENVIRONMENTAL = 5
    NONQUEST_CREEP = 6
    QUEST_QUESTNPC = 7
    TECHNICAL = 8
    ACCOUNT_BILLING = 9
    CHARACTER = 10


class GroupLootSetting(enum.Enum):
    FREE_FOR_ALL = 0
    ROUND_ROBIN = 1
    MASTER_LOOT = 2
    GROUP_LOOT = 3
    NEED_BEFORE_GREED = 4


class GroupType(enum.Enum):
    NORMAL = 0
    RAID = 1


class GuildCommand(enum.Enum):
    CREATE = 0
    INVITE = 1
    QUIT = 3
    FOUNDER = 14
    UNKNOWN19 = 19
    UNKNOWN20 = 20


class GuildCommandResult(enum.Enum):
    PLAYER_NO_MORE_IN_GUILD = 0
    GUILD_INTERNAL = 1
    ALREADY_IN_GUILD = 2
    ALREADY_IN_GUILD_S = 3
    INVITED_TO_GUILD = 4
    ALREADY_INVITED_TO_GUILD_S = 5
    GUILD_NAME_INVALID = 6
    GUILD_NAME_EXISTS_S = 7
    GUILD_PERMISSIONS_OR_LEADER = 8
    GUILD_PLAYER_NOT_IN_GUILD = 9
    GUILD_PLAYER_NOT_IN_GUILD_S = 10
    GUILD_PLAYER_NOT_FOUND_S = 11
    GUILD_NOT_ALLIED = 12
    GUILD_RANK_TOO_HIGH_S = 13
    GUILD_RANK_TOO_LOW_S = 14


class GuildEmblemResult(enum.Enum):
    SUCCESS = 0
    INVALID_TABARD_COLORS = 1
    NO_GUILD = 2
    NOT_GUILD_MASTER = 3
    NOT_ENOUGH_MONEY = 4
    NO_MESSAGE = 5


class GuildEvent(enum.Enum):
    PROMOTION = 0
    DEMOTION = 1
    MOTD = 2
    JOINED = 3
    LEFT = 4
    REMOVED = 5
    LEADER_IS = 6
    LEADER_CHANGED = 7
    DISBANDED = 8
    TABARD_CHANGED = 9
    UNKNOWN10 = 10
    ROSTER_UPDATE = 11
    SIGNED_ON = 12
    SIGNED_OFF = 13


class GuildMemberStatus(enum.Enum):
    OFFLINE = 0
    ONLINE = 1


class HitInfo(enum.Enum):
    NORMAL_SWING = 0
    UNK1 = 1
    AFFECTS_VICTIM = 2
    LEFT_SWING = 4
    EARLY_CRITICAL_HIT = 8
    MISS = 16
    ABSORB = 32
    RESIST = 64
    CRITICAL_HIT = 128
    UNK9 = 256
    UNK10 = 8192
    GLANCING = 16384
    CRUSHING = 32768
    NO_ACTION = 65536
    SWING_NO_HIT_SOUND = 524288


class InfoBlock(enum.Enum):
    UNAVAILABLE = 0
    AVAILABLE = 1


class InstanceResetFailedReason(enum.Enum):
    GENERAL = 0
    OFFLINE = 1
    ZONING = 2
    SILENTLY = 3


class InstanceType(enum.Enum):
    NORMAL = 0
    GROUP_INSTANCE = 1
    RAID_INSTANCE = 2
    BATTLEGROUND = 3
    WORLD_ZONE = 4
    BATTLEGROUND2 = 5


class InventoryResult(enum.Enum):
    OK = 0
    CANT_EQUIP_LEVEL_I = 1
    CANT_EQUIP_SKILL = 2
    ITEM_DOESNT_GO_TO_SLOT = 3
    BAG_FULL = 4
    NONEMPTY_BAG_OVER_OTHER_BAG = 5
    CANT_TRADE_EQUIP_BAGS = 6
    ONLY_AMMO_CAN_GO_HERE = 7
    NO_REQUIRED_PROFICIENCY = 8
    NO_EQUIPMENT_SLOT_AVAILABLE = 9
    YOU_CAN_NEVER_USE_THAT_ITEM = 10
    YOU_CAN_NEVER_USE_THAT_ITEM2 = 11
    NO_EQUIPMENT_SLOT_AVAILABLE2 = 12
    CANT_EQUIP_WITH_TWOHANDED = 13
    CANT_DUAL_WIELD = 14
    ITEM_DOESNT_GO_INTO_BAG = 15
    ITEM_DOESNT_GO_INTO_BAG2 = 16
    CANT_CARRY_MORE_OF_THIS = 17
    NO_EQUIPMENT_SLOT_AVAILABLE3 = 18
    ITEM_CANT_STACK = 19
    ITEM_CANT_BE_EQUIPPED = 20
    ITEMS_CANT_BE_SWAPPED = 21
    SLOT_IS_EMPTY = 22
    ITEM_NOT_FOUND = 23
    CANT_DROP_SOULBOUND = 24
    OUT_OF_RANGE = 25
    TRIED_TO_SPLIT_MORE_THAN_COUNT = 26
    COULDNT_SPLIT_ITEMS = 27
    MISSING_REAGENT = 28
    NOT_ENOUGH_MONEY = 29
    NOT_A_BAG = 30
    CAN_ONLY_DO_WITH_EMPTY_BAGS = 31
    DONT_OWN_THAT_ITEM = 32
    CAN_EQUIP_ONLY1_QUIVER = 33
    MUST_PURCHASE_THAT_BAG_SLOT = 34
    TOO_FAR_AWAY_FROM_BANK = 35
    ITEM_LOCKED = 36
    YOU_ARE_STUNNED = 37
    YOU_ARE_DEAD = 38
    CANT_DO_RIGHT_NOW = 39
    INT_BAG_ERROR = 40
    CAN_EQUIP_ONLY1_BOLT = 41
    CAN_EQUIP_ONLY1_AMMOPOUCH = 42
    STACKABLE_CANT_BE_WRAPPED = 43
    EQUIPPED_CANT_BE_WRAPPED = 44
    WRAPPED_CANT_BE_WRAPPED = 45
    BOUND_CANT_BE_WRAPPED = 46
    UNIQUE_CANT_BE_WRAPPED = 47
    BAGS_CANT_BE_WRAPPED = 48
    ALREADY_LOOTED = 49
    INVENTORY_FULL = 50
    BANK_FULL = 51
    ITEM_IS_CURRENTLY_SOLD_OUT = 52
    BAG_FULL3 = 53
    ITEM_NOT_FOUND2 = 54
    ITEM_CANT_STACK2 = 55
    BAG_FULL4 = 56
    ITEM_SOLD_OUT = 57
    OBJECT_IS_BUSY = 58
    NONE = 59
    NOT_IN_COMBAT = 60
    NOT_WHILE_DISARMED = 61
    BAG_FULL6 = 62
    CANT_EQUIP_RANK = 63
    CANT_EQUIP_REPUTATION = 64
    TOO_MANY_SPECIAL_BAGS = 65
    LOOT_CANT_LOOT_THAT_NOW = 66


class InventoryType(enum.Enum):
    NON_EQUIP = 0
    HEAD = 1
    NECK = 2
    SHOULDERS = 3
    BODY = 4
    CHEST = 5
    WAIST = 6
    LEGS = 7
    FEET = 8
    WRISTS = 9
    HANDS = 10
    FINGER = 11
    TRINKET = 12
    WEAPON = 13
    SHIELD = 14
    RANGED = 15
    CLOAK = 16
    TWO_HANDED_WEAPON = 17
    BAG = 18
    TABARD = 19
    ROBE = 20
    WEAPON_MAIN_HAND = 21
    WEAPON_OFF_HAND = 22
    HOLDABLE = 23
    AMMO = 24
    THROWN = 25
    RANGED_RIGHT = 26
    QUIVER = 27
    RELIC = 28


class ItemClass(enum.Enum):
    CONSUMABLE = 0
    CONTAINER = 1
    WEAPON = 2
    GEM = 3
    ARMOR = 4
    REAGENT = 5
    PROJECTILE = 6
    TRADE_GOODS = 7
    GENERIC = 8
    RECIPE = 9
    MONEY = 10
    QUIVER = 11
    QUEST = 12
    KEY = 13
    PERMANENT = 14
    MISC = 15


class ItemClassAndSubClass(enum.Enum):
    CONSUMABLE = 0
    CHEESE_OR_BREAD_OBSOLETE = 4294967296
    LIQUID_OBSOLETE = 8589934592
    BAG = 1
    SOUL_BAG = 4294967297
    HERB_BAG = 8589934593
    ENCHANTING_BAG = 12884901889
    ENGINEERING_BAG = 17179869185
    ONE_HANDED_AXE = 2
    TWO_HANDED_AXE = 4294967298
    BOW = 8589934594
    GUN = 12884901890
    ONE_HANDED_MACE = 17179869186
    TWO_HANDED_MACE = 21474836482
    POLEARM = 25769803778
    ONE_HANDED_SWORD = 30064771074
    TWO_HANDED_SWORD = 34359738370
    OBSOLETE_WEAPON = 38654705666
    STAFF = 42949672962
    ONE_HANDED_EXOTIC = 47244640258
    TWO_HANDED_EXOTIC = 51539607554
    FIST_WEAPON = 55834574850
    MISCELLANEOUS_WEAPON = 60129542146
    DAGGER = 64424509442
    THROWN = 68719476738
    SPEAR = 73014444034
    CROSSBOW = 77309411330
    WAND = 81604378626
    FISHING_POLE = 85899345922
    JEWELRY_OBSOLETE = 3
    MISCELLANEOUS_ARMOR = 4
    CLOTH_ARMOR = 4294967300
    LEATHER_ARMOR = 8589934596
    MAIL_ARMOR = 12884901892
    PLATE_ARMOR = 17179869188
    BUCKLER_OBSOLETE = 21474836484
    SHIELD = 25769803780
    LIBRAM = 30064771076
    IDOL = 34359738372
    TOTEM = 38654705668
    REAGENT = 5
    WAND_OBSOLETE = 6
    BOLT_OBSOLETE = 4294967302
    ARROW = 8589934598
    BULLET = 12884901894
    THROWN_OBSOLETE = 17179869190
    TRADE_GOOD = 7
    PART_TRADE_GOOD = 4294967303
    EXPLOSIVE_TRADE_GOOD = 8589934599
    DEVICE_TRADE_GOOD = 12884901895
    GENERIC_OBSOLETE = 8
    BOOK = 9
    LEATHERWORKING_RECIPE = 4294967305
    TAILORING_RECIPE = 8589934601
    ENGINEERING_RECIPE = 12884901897
    BLACKSMITHING_RECIPE = 17179869193
    COOKING_RECIPE = 21474836489
    ALCHEMY_RECIPE = 25769803785
    FIRST_AID_RECIPE = 30064771081
    ENCHANTING_RECIPE = 34359738377
    FISHING_RECIPE = 38654705673
    MONEY_OBSOLETE = 10
    QUIVER_OBSOLETE = 11
    QUIVER_OBSOLETE1 = 4294967307
    QUIVER = 8589934603
    AMMO_POUCH = 12884901899
    QUEST = 12
    KEY = 13
    LOCKPICK = 4294967309
    PERMANENT = 14
    JUNK = 15


class ItemEnvTypes(enum.Enum):
    SHIELD = 0
    METAL_WEAPON = 1
    WOOD_WEAPON = 2


class ItemQuality(enum.Enum):
    POOR = 0
    NORMAL = 1
    UNCOMMON = 2
    RARE = 3
    EPIC = 4
    LEGENDARY = 5
    ARTIFACT = 6


class ItemSet(enum.Enum):
    NONE = 0
    THE_GLADIATOR = 1
    DAL_RENDS_ARMS = 41
    SPIDERS_KISS = 65
    THE_POSTMASTER = 81
    CADAVEROUS_GARB = 121
    NECROPILE_RAIMENT = 122
    BLOODMAIL_REGALIA = 123
    DEATHBONE_GUARDIAN = 124
    VOLCANIC_ARMOR = 141
    STORMSHROUD_ARMOR = 142
    DEVILSAUR_ARMOR = 143
    IRONFEATHER_ARMOR = 144
    DEFIAS_LEATHER = 161
    EMBRACE_OF_THE_VIPER = 162
    CHAIN_OF_THE_SCARLET_CRUSADE = 163
    MAGISTERS_REGALIA = 181
    VESTMENTS_OF_THE_DEVOUT = 182
    DREADMIST_RAIMENT = 183
    SHADOWCRAFT_ARMOR = 184
    WILDHEART_RAIMENT = 185
    BEASTSTALKER_ARMOR = 186
    THE_ELEMENTS = 187
    LIGHTFORGE_ARMOR = 188
    BATTLEGEAR_OF_VALOR = 189
    ARCANIST_REGALIA = 201
    VESTMENTS_OF_PROPHECY = 202
    FELHEART_RAIMENT = 203
    NIGHTSLAYER_ARMOR = 204
    CENARION_RAIMENT = 205
    GIANTSTALKER_ARMOR = 206
    THE_EARTHFURY = 207
    LAWBRINGER_ARMOR = 208
    BATTLEGEAR_OF_MIGHT = 209
    NETHERWIND_REGALIA = 210
    VESTMENTS_OF_TRANSCENDENCE = 211
    NEMESIS_RAIMENT = 212
    BLOODFANG_ARMOR = 213
    STORMRAGE_RAIMENT = 214
    DRAGONSTALKER_ARMOR = 215
    THE_TEN_STORMS = 216
    JUDGEMENT_ARMOR = 217
    BATTLEGEAR_OF_WRATH = 218
    GARB_OF_THERO_SHAN = 221
    SHARD_OF_THE_GODS = 241
    SPIRIT_OF_ESKHANDAR = 261
    CHAMPIONS_BATTLEGEAR = 281
    LIEUTENANT_COMMANDERS_BATTLEGEAR = 282
    CHAMPIONS_EARTHSHAKER = 301
    IMPERIAL_PLATE = 321
    CHAMPIONS_REGALIA = 341
    CHAMPIONS_RAIMENT = 342
    LIEUTENANT_COMMANDERS_REGALIA = 343
    LIEUTENANT_COMMANDERS_RAIMENT = 344
    CHAMPIONS_THREADS = 345
    LIEUTENANT_COMMANDERS_THREADS = 346
    CHAMPIONS_VESTMENTS = 347
    LIEUTENANT_COMMANDERS_VESTMENTS = 348
    CHAMPIONS_PURSUIT = 361
    LIEUTENANT_COMMANDERS_PURSUIT = 362
    LIEUTENANT_COMMANDERS_SANCTUARY = 381
    CHAMPIONS_SANCTUARY = 382
    WARLORDS_BATTLEGEAR = 383
    FIELD_MARSHALS_BATTLEGEAR = 384
    WARLORDS_EARTHSHAKER = 386
    WARLORDS_REGALIA = 387
    FIELD_MARSHALS_REGALIA = 388
    FIELD_MARSHALS_RAIMENT = 389
    WARLORDS_RAIMENT = 390
    WARLORDS_THREADS = 391
    FIELD_MARSHALS_THREADS = 392
    WARLORDS_VESTMENTS = 393
    FIELD_MARSHALS_VESTMENTS = 394
    FIELD_MARSHALS_PURSUIT = 395
    WARLORDS_PURSUIT = 396
    FIELD_MARSHALS_SANCTUARY = 397
    WARLORDS_SANCTUARY = 398
    LIEUTENANT_COMMANDERS_AEGIS = 401
    FIELD_MARSHALS_AEGIS = 402
    BLOODVINE_GARB = 421
    PRIMAL_BATSKIN = 441
    BLOOD_TIGER_HARNESS = 442
    BLOODSOUL_EMBRACE = 443
    THE_DARKSOUL = 444
    THE_TWIN_BLADES_OF_HAKKARI = 461
    ZANZILS_CONCENTRATION = 462
    PRIMAL_BLESSING = 463
    OVERLORDS_RESOLUTION = 464
    PRAYER_OF_THE_PRIMAL = 465
    MAJOR_MOJO_INFUSION = 466
    THE_HIGHLANDERS_RESOLUTION = 467
    THE_HIGHLANDERS_RESOLVE = 468
    THE_HIGHLANDERS_DETERMINATION = 469
    THE_HIGHLANDERS_FORTITUDE = 470
    THE_HIGHLANDERS_PURPOSE = 471
    THE_HIGHLANDERS_WILL = 472
    THE_HIGHLANDERS_INTENT = 473
    VINDICATORS_BATTLEGEAR = 474
    FREETHINKERS_ARMOR = 475
    AUGURS_REGALIA = 476
    PREDATORS_ARMOR = 477
    MADCAPS_OUTFIT = 478
    HARUSPEXS_GARB = 479
    CONFESSORS_RAIMENT = 480
    DEMONIACS_THREADS = 481
    ILLUSIONISTS_ATTIRE = 482
    THE_DEFILERS_DETERMINATION = 483
    THE_DEFILERS_FORTITUDE = 484
    THE_DEFILERS_INTENT = 485
    THE_DEFILERS_PURPOSE = 486
    THE_DEFILERS_RESOLUTION = 487
    THE_DEFILERS_WILL = 488
    BLACK_DRAGON_MAIL = 489
    GREEN_DRAGON_MAIL = 490
    BLUE_DRAGON_MAIL = 491
    TWILIGHT_TRAPPINGS = 492
    GENESIS_RAIMENT = 493
    SYMBOLS_OF_UNENDING_LIFE = 494
    BATTLEGEAR_OF_UNYIELDING_STRENGTH = 495
    CONQUERORS_BATTLEGEAR = 496
    DEATHDEALERS_EMBRACE = 497
    EMBLEMS_OF_VEILED_SHADOWS = 498
    DOOMCALLERS_ATTIRE = 499
    IMPLEMENTS_OF_UNSPOKEN_NAMES = 500
    STORMCALLERS_GARB = 501
    GIFT_OF_THE_GATHERING_STORM = 502
    ENIGMA_VESTMENTS = 503
    TRAPPINGS_OF_VAULTED_SECRETS = 504
    AVENGERS_BATTLEGEAR = 505
    BATTLEGEAR_OF_ETERNAL_JUSTICE = 506
    GARMENTS_OF_THE_ORACLE = 507
    FINERY_OF_INFINITE_WISDOM = 508
    STRIKERS_GARB = 509
    TRAPPINGS_OF_THE_UNSEEN_PATH = 510
    BATTLEGEAR_OF_HEROISM = 511
    DARKMANTLE_ARMOR = 512
    FERALHEART_RAIMENT = 513
    VESTMENTS_OF_THE_VIRTUOUS = 514
    BEASTMASTER_ARMOR = 515
    SOULFORGE_ARMOR = 516
    SORCERERS_REGALIA = 517
    DEATHMIST_RAIMENT = 518
    THE_FIVE_THUNDERS = 519
    IRONWEAVE_BATTLESUIT = 520
    DREAMWALKER_RAIMENT = 521
    CHAMPIONS_GUARD = 522
    DREADNAUGHTS_BATTLEGEAR = 523
    BONESCYTHE_ARMOR = 524
    VESTMENTS_OF_FAITH = 525
    FROSTFIRE_REGALIA = 526
    THE_EARTHSHATTERER = 527
    REDEMPTION_ARMOR = 528
    PLAGUEHEART_RAIMENT = 529
    CRYPTSTALKER_ARMOR = 530
    BATTLEGEAR_OF_UNDEAD_SLAYING = 533
    UNDEAD_SLAYERS_ARMOR = 534
    GARB_OF_THE_UNDEAD_SLAYER = 535
    REGALIA_OF_UNDEAD_CLEANSING = 536
    CHAMPIONS_BATTLEARMOR = 537
    CHAMPIONS_STORMCALLER = 538
    CHAMPIONS_REFUGE = 539
    CHAMPIONS_INVESTITURE = 540
    CHAMPIONS_DREADGEAR = 541
    CHAMPIONS_ARCANUM = 542
    CHAMPIONS_PURSUANCE = 543
    LIEUTENANT_COMMANDERS_REDOUBT = 544
    LIEUTENANT_COMMANDERS_BATTLEARMOR = 545
    LIEUTENANT_COMMANDERS_ARCANUM = 546
    LIEUTENANT_COMMANDERS_DREADGEAR = 547
    LIEUTENANT_COMMANDERS_GUARD = 548
    LIEUTENANT_COMMANDERS_INVESTITURE = 549
    LIEUTENANT_COMMANDERS_PURSUANCE = 550
    LIEUTENANT_COMMANDERS_REFUGE = 551


class ItemSlot(enum.Enum):
    HEAD = 0
    NECK = 1
    SHOULDERS = 2
    SHIRT = 3
    CHEST = 4
    WAIST = 5
    LEGS = 6
    BOOTS = 7
    WRIST = 8
    HANDS = 9
    RING1 = 10
    RING2 = 11
    TRINKET1 = 12
    TRINKET2 = 13
    BACK = 14
    MAIN_HAND = 15
    OFF_HAND = 16
    RANGED_OR_RELIC = 17
    TABARD = 18
    BAG1 = 19
    BAG2 = 20
    BAG3 = 21
    BAG4 = 22
    INVENTORY_0 = 23
    INVENTORY_1 = 24
    INVENTORY_2 = 25
    INVENTORY_3 = 26
    INVENTORY_4 = 27
    INVENTORY_5 = 28
    INVENTORY_6 = 29
    INVENTORY_7 = 30
    INVENTORY_8 = 31
    INVENTORY_9 = 32
    INVENTORY_10 = 33
    INVENTORY_11 = 34
    INVENTORY_12 = 35
    INVENTORY_13 = 36
    INVENTORY_14 = 37
    INVENTORY_15 = 38
    BANK_1 = 39
    BANK_2 = 40
    BANK_3 = 41
    BANK_4 = 42
    BANK_5 = 43
    BANK_6 = 44
    BANK_7 = 45
    BANK_8 = 46
    BANK_9 = 47
    BANK_10 = 48
    BANK_11 = 49
    BANK_12 = 50
    BANK_13 = 51
    BANK_14 = 52
    BANK_15 = 53
    BANK_16 = 54
    BANK_17 = 55
    BANK_18 = 56
    BANK_19 = 57
    BANK_20 = 58
    BANK_21 = 59
    BANK_22 = 60
    BANK_23 = 61
    BANK_24 = 62
    BANK_BAG_SLOT_1 = 63
    BANK_BAG_SLOT_2 = 64
    BANK_BAG_SLOT_3 = 65
    BANK_BAG_SLOT_4 = 66
    BANK_BAG_SLOT_5 = 67
    BANK_BAG_SLOT_6 = 68
    VENDOR_BUYBACK_1 = 69
    VENDOR_BUYBACK_2 = 70
    VENDOR_BUYBACK_3 = 71
    VENDOR_BUYBACK_4 = 72
    VENDOR_BUYBACK_5 = 73
    VENDOR_BUYBACK_6 = 74
    VENDOR_BUYBACK_7 = 75
    VENDOR_BUYBACK_8 = 76
    VENDOR_BUYBACK_9 = 77
    VENDOR_BUYBACK_10 = 78
    VENDOR_BUYBACK_11 = 79
    VENDOR_BUYBACK_12 = 80
    KEYRING_1 = 81
    KEYRING_2 = 82
    KEYRING_3 = 83
    KEYRING_4 = 84
    KEYRING_5 = 85
    KEYRING_6 = 86
    KEYRING_7 = 87
    KEYRING_8 = 88
    KEYRING_9 = 89
    KEYRING_10 = 90
    KEYRING_11 = 91
    KEYRING_12 = 92
    KEYRING_13 = 93
    KEYRING_14 = 94
    KEYRING_15 = 95
    KEYRING_16 = 96
    KEYRING_17 = 97
    KEYRING_18 = 98
    KEYRING_19 = 99
    KEYRING_20 = 100
    KEYRING_21 = 101
    KEYRING_22 = 102
    KEYRING_23 = 103
    KEYRING_24 = 104
    KEYRING_25 = 105
    KEYRING_26 = 106
    KEYRING_27 = 107
    KEYRING_28 = 108
    KEYRING_29 = 109
    KEYRING_30 = 110
    KEYRING_31 = 111
    KEYRING_32 = 112


class ItemStatType(enum.Enum):
    MANA = 0
    HEALTH = 1
    AGILITY = 3
    STRENGTH = 4
    INTELLECT = 5
    SPIRIT = 6
    STAMINA = 7


class ItemWeaponClass(enum.Enum):
    ITEM = 0
    WEAPON = 1


class KeyVersion(enum.Enum):
    ZERO = 0
    ONE = 1
    TWO = 2
    THREE = 3
    FOUR = 4
    FIVE = 5
    SIX = 6
    SEVEN = 7
    EIGHT = 8
    NINE = 9


class Language(enum.Enum):
    UNIVERSAL = 0
    ORCISH = 1
    DARNASSIAN = 2
    TAURAHE = 3
    DWARVISH = 6
    COMMON = 7
    DEMONIC = 8
    TITAN = 9
    THALASSIAN = 10
    DRACONIC = 11
    KALIMAG = 12
    GNOMISH = 13
    TROLL = 14
    GUTTERSPEAK = 33
    ADDON = 4294967295


class LfgFaction(enum.Enum):
    NEUTRAL = -1
    HORDE = 0
    ALLIANCE = 1


class LockType(enum.Enum):
    NONE = 0
    ITEM_REQUIRED = 1
    LOCKTYPE_REFERENCE = 2


class LogFormat(enum.Enum):
    DEFAULT = 0
    DEBUG = 1


class LogoutResult(enum.Enum):
    SUCCESS = 0
    FAILURE_IN_COMBAT = 1
    FAILURE_FROZEN_BY_GM = 2
    FAILURE_JUMPING_OR_FALLING = 3


class LogoutSpeed(enum.Enum):
    DELAYED = 0
    INSTANT = 1


class LootMethod(enum.Enum):
    ERROR = 0
    CORPSE = 1
    PICKPOCKETING = 2
    FISHING = 3
    DISENCHANTING = 4
    SKINNING = 6
    FISHINGHOLE = 20
    FISHING_FAIL = 21
    INSIGNIA = 22


class LootMethodError(enum.Enum):
    DIDNT_KILL = 0
    TOO_FAR = 4
    BAD_FACING = 5
    LOCKED = 6
    NOTSTANDING = 8
    STUNNED = 9
    PLAYER_NOT_FOUND = 10
    PLAY_TIME_EXCEEDED = 11
    MASTER_INV_FULL = 12
    MASTER_UNIQUE_ITEM = 13
    MASTER_OTHER = 14
    ALREADY_PICKPOCKETED = 15
    NOT_WHILE_SHAPESHIFTED = 16


class LootSlotType(enum.Enum):
    TYPE_ALLOW_LOOT = 0
    TYPE_ROLL_ONGOING = 1
    TYPE_MASTER = 2
    TYPE_LOCKED = 3
    TYPE_OWNER = 4


class MailAction(enum.Enum):
    SEND = 0
    MONEY_TAKEN = 1
    ITEM_TAKEN = 2
    RETURNED_TO_SENDER = 3
    DELETED = 4
    MADE_PERMANENT = 5


class MailMessageType(enum.Enum):
    NORMAL = 0
    AUCTION = 2
    CREATURE = 3
    GAMEOBJECT = 4
    ITEM = 5


class MailResult(enum.Enum):
    OK = 0
    ERR_EQUIP_ERROR = 1
    ERR_CANNOT_SEND_TO_SELF = 2
    ERR_NOT_ENOUGH_MONEY = 3
    ERR_RECIPIENT_NOT_FOUND = 4
    ERR_NOT_YOUR_TEAM = 5
    ERR_INTERNAL_ERROR = 6
    ERR_DISABLED_FOR_TRIAL_ACC = 14
    ERR_RECIPIENT_CAP_REACHED = 15
    ERR_CANT_SEND_WRAPPED_COD = 16
    ERR_MAIL_AND_CHAT_SUSPENDED = 17
    ERR_TOO_MANY_ATTACHMENTS = 18
    ERR_MAIL_ATTACHMENT_INVALID = 19


class MailResultTwo(enum.Enum):
    OK = 0
    ERR_EQUIP_ERROR = 1
    ERR_CANNOT_SEND_TO_SELF = 2
    ERR_NOT_ENOUGH_MONEY = 3
    ERR_RECIPIENT_NOT_FOUND = 4
    ERR_NOT_YOUR_TEAM = 5
    ERR_INTERNAL_ERROR = 6
    ERR_DISABLED_FOR_TRIAL_ACC = 14
    ERR_RECIPIENT_CAP_REACHED = 15
    ERR_CANT_SEND_WRAPPED_COD = 16
    ERR_MAIL_AND_CHAT_SUSPENDED = 17
    ERR_TOO_MANY_ATTACHMENTS = 18
    ERR_MAIL_ATTACHMENT_INVALID = 19


class MailType(enum.Enum):
    NORMAL = 0
    AUCTION = 2
    CREATURE = 3
    GAMEOBJECT = 4
    ITEM = 5


class Map(enum.Enum):
    EASTERN_KINGDOMS = 0
    KALIMDOR = 1
    TESTING = 13
    SCOTT_TEST = 25
    CASH_TEST = 29
    ALTERAC_VALLEY = 30
    SHADOWFANG_KEEP = 33
    STORMWIND_STOCKADE = 34
    STORMWIND_PRISON = 35
    DEADMINES = 36
    AZSHARA_CRATER = 37
    COLLINS_TEST = 42
    WAILING_CAVERNS = 43
    MONASTERY_UNUSED = 44
    RAZORFEN_KRAUL = 47
    BLACKFATHOM_DEEPS = 48
    ULDAMAN = 70
    GNOMEREGAN = 90
    SUNKEN_TEMPLE = 109
    RAZORFEN_DOWNS = 129
    EMERALD_DREAM = 169
    SCARLET_MONASTERY = 189
    ZUL_FARRAK = 209
    BLACKROCK_SPIRE = 229
    BLACKROCK_DEPTHS = 230
    ONYXIAS_LAIR = 249
    OPENING_OF_THE_DARK_PORTAL = 269
    SCHOLOMANCE = 289
    ZUL_GURUB = 309
    STRATHOLME = 329
    MARAUDON = 349
    DEEPRUN_TRAM = 369
    RAGEFIRE_CHASM = 389
    MOLTEN_CORE = 409
    DIRE_MAUL = 429
    ALLIANCE_PVP_BARRACKS = 449
    HORDE_PVP_BARRACKS = 450
    DEVELOPMENT_LAND = 451
    BLACKWING_LAIR = 469
    WARSONG_GULCH = 489
    RUINS_OF_AHN_QIRAJ = 509
    ARATHI_BASIN = 529
    AHN_QIRAJ_TEMPLE = 531
    NAXXRAMAS = 533


class MeetingStoneFailure(enum.Enum):
    MEETINGSTONE_FAIL_PARTYLEADER = 1
    MEETINGSTONE_FAIL_FULL_GROUP = 2
    MEETINGSTONE_FAIL_RAID_GROUP = 3


class MeetingStoneStatus(enum.Enum):
    LEAVE_QUEUE = 0
    JOINED_QUEUE = 1
    PARTY_MEMBER_LEFT_LFG = 2
    PARTY_MEMBER_REMOVED_PARTY_REMOVED = 3
    LOOKING_FOR_NEW_PARTY_IN_QUEUE = 4
    NONE = 5


class MonsterMoveType(enum.Enum):
    NORMAL = 0
    STOP = 1
    FACING_SPOT = 2
    FACING_TARGET = 3
    FACING_ANGLE = 4


class MountResult(enum.Enum):
    INVALID_MOUNTEE = 0
    TOO_FAR_AWAY = 1
    ALREADY_MOUNTED = 2
    NOT_MOUNTABLE = 3
    NOT_YOUR_PET = 4
    OTHER = 5
    LOOTING = 6
    RACE_CANT_MOUNT = 7
    SHAPESHIFTED = 8
    FORCED_DISMOUNT = 9
    OK = 10


class NewItemChatAlert(enum.Enum):
    DO_NOT_SHOW = 0
    SHOW = 1


class NewItemCreationType(enum.Enum):
    RECEIVED = 0
    CREATED = 1


class NewItemSource(enum.Enum):
    LOOTED = 0
    FROM_NPC = 1


class ObjectType(enum.Enum):
    OBJECT = 0
    ITEM = 1
    CONTAINER = 2
    UNIT = 3
    PLAYER = 4
    GAME_OBJECT = 5
    DYNAMIC_OBJECT = 6
    CORPSE = 7


class OceanType(enum.Enum):
    FIRE = 0
    SLIME = 2
    WATER = 3


class PageTextMaterial(enum.Enum):
    NONE = 0
    PARCHMENT = 1
    STONE = 2
    MARBLE = 3
    SILVER = 4
    BRONZE = 5
    VALENTINE = 6


class PartyOperation(enum.Enum):
    INVITE = 0
    LEAVE = 2


class PartyResult(enum.Enum):
    SUCCESS = 0
    BAD_PLAYER_NAME = 1
    TARGET_NOT_IN_GROUP = 2
    GROUP_FULL = 3
    ALREADY_IN_GROUP = 4
    NOT_IN_GROUP = 5
    NOT_LEADER = 6
    PLAYER_WRONG_FACTION = 7
    IGNORING_YOU = 8


class PetCommandState(enum.Enum):
    STAY = 0
    FOLLOW = 1
    ATTACK = 2
    DISMISS = 3


class PetEnabled(enum.Enum):
    ENABLED = 8
    DISABLED = 0


class PetFeedback(enum.Enum):
    PET_DEAD = 1
    NOTHING_TO_ATTACK = 2
    CANT_ATTACK_TARGET = 3
    NO_PATH_TO = 4


class PetReactState(enum.Enum):
    PASSIVE = 0
    DEFENSIVE = 1
    AGGRESSIVE = 2


class PetTalkReason(enum.Enum):
    SPECIAL_SPELL = 0
    ATTACK = 1


class PetTameFailureReason(enum.Enum):
    INVALID_CREATURE = 1
    TOO_MANY = 2
    CREATURE_ALREADY_OWNED = 3
    NOT_TAMEABLE = 4
    ANOTHER_SUMMON_ACTIVE = 5
    UNITS_CANT_TAME = 6
    NO_PET_AVAILABLE = 7
    INTERNAL_ERROR = 8
    TOO_HIGH_LEVEL = 9
    DEAD = 10
    NOT_DEAD = 11
    UNKNOWN_ERROR = 12


class PetitionResult(enum.Enum):
    OK = 0
    ALREADY_SIGNED = 1
    ALREADY_IN_GUILD = 2
    CANT_SIGN_OWN = 3
    NEED_MORE = 4
    NOT_SERVER = 5


class PlayerChatTag(enum.Enum):
    NONE = 0
    AFK = 1
    DND = 2
    GM = 3


class Power(enum.Enum):
    MANA = 0
    RAGE = 1
    FOCUS = 2
    ENERGY = 3
    HAPPINESS = 4
    HEALTH = 254


class PvpRank(enum.Enum):
    NO_RANK = 0
    PARIAH = 1
    OUTLAW = 2
    EXILED = 3
    DISHONORED = 4
    RANK1 = 5
    RANK2 = 6
    RANK3 = 7
    RANK4 = 8
    RANK5 = 9
    RANK6 = 10
    RANK7 = 11
    RANK8 = 12
    RANK9 = 13
    RANK10 = 14
    RANK11 = 15
    RANK12 = 16
    RANK13 = 17
    RANK14 = 18
    FACTION_LEADER = 19


class QuestCompletable(enum.Enum):
    NOT_COMPLETABLE = 0
    COMPLETEABLE = 3


class QuestFailedReason(enum.Enum):
    DONT_HAVE_REQ = 0
    QUEST_FAILED_LOW_LEVEL = 1
    QUEST_FAILED_REQS = 2
    QUEST_FAILED_INVENTORY_FULL = 4
    QUEST_FAILED_WRONG_RACE = 6
    QUEST_ONLY_ONE_TIMED = 12
    QUEST_ALREADY_ON = 13
    QUEST_FAILED_DUPLICATE_ITEM = 17
    QUEST_FAILED_MISSING_ITEMS = 20
    QUEST_FAILED_NOT_ENOUGH_MONEY = 22


class QuestGiverStatus(enum.Enum):
    NONE = 0
    UNAVAILABLE = 1
    CHAT = 2
    INCOMPLETE = 3
    REWARD_REP = 4
    AVAILABLE = 5
    REWARD_OLD = 6
    REWARD2 = 7


class QuestPartyMessage(enum.Enum):
    SHARING_QUEST = 0
    CANT_TAKE_QUEST = 1
    ACCEPT_QUEST = 2
    DECLINE_QUEST = 3
    TOO_FAR = 4
    BUSY = 5
    LOG_FULL = 6
    HAVE_QUEST = 7
    FINISH_QUEST = 8


class Race(enum.Enum):
    HUMAN = 1
    ORC = 2
    DWARF = 3
    NIGHT_ELF = 4
    UNDEAD = 5
    TAUREN = 6
    GNOME = 7
    TROLL = 8
    GOBLIN = 9


class RaidGroupError(enum.Enum):
    REQUIRED = 1
    FULL = 2


class RaidInstanceMessage(enum.Enum):
    WARNING_HOURS = 1
    WARNING_MIN = 2
    WARNING_MIN_SOON = 3
    WELCOME = 4


class RaidTargetIndex(enum.Enum):
    UNKNOWN0 = 0
    UNKNOWN1 = 1
    UNKNOWN2 = 2
    UNKNOWN3 = 3
    UNKNOWN4 = 4
    UNKNOWN5 = 5
    UNKNOWN6 = 6
    UNKNOWN7 = 7
    UNKNOWN8 = 8
    REQUEST_ICONS = 255


class RaidTargetUpdateType(enum.Enum):
    PARTIAL = 0
    FULL = 1


class RollVote(enum.Enum):
    PASS = 0
    NEED = 1
    GREED = 2


class Scalp(enum.Enum):
    HAIR = 0
    BALD = 1


class SelectionType(enum.Enum):
    BASE_SKIN = 0
    FACE = 1
    FACIAL_HAIR = 2
    HAIR = 3
    UNDERWEAR = 4


class SellItemResult(enum.Enum):
    CANT_FIND_ITEM = 1
    CANT_SELL_ITEM = 2
    CANT_FIND_VENDOR = 3
    YOU_DONT_OWN_THAT_ITEM = 4
    UNK = 5
    ONLY_EMPTY_BAG = 6


class ServerCategory(enum.Enum):
    ONE = 1
    TWO = 2
    THREE = 3
    FIVE = 5


class ServerMessageType(enum.Enum):
    SHUTDOWN_TIME = 1
    RESTART_TIME = 2
    CUSTOM = 3
    SHUTDOWN_CANCELLED = 4
    RESTART_CANCELLED = 5


class ServerRegion(enum.Enum):
    UNITED_STATES = 1
    KOREA = 2
    EUROPE = 3
    TAIWAN = 4
    CHINA = 5
    TEST_SERVER = 99
    QA_SERVER = 101


class SheathState(enum.Enum):
    UNARMED = 0
    MELEE = 1
    RANGED = 2


class SheatheType(enum.Enum):
    NONE = 0
    MAIN_HAND = 1
    OFF_HAND = 2
    LARGE_WEAPON_LEFT = 3
    LARGE_WEAPON_RIGHT = 4
    HIP_WEAPON_LEFT = 5
    HIP_WEAPON_RIGHT = 6
    SHIELD = 7


class SimpleSpellCastResult(enum.Enum):
    SUCCESS = 0
    FAILURE = 2


class SizeClass(enum.Enum):
    NONE = -1
    SMALL = 0
    MEDIUM = 1
    LARGE = 2
    GIANT = 3
    COLOSSAL = 4


class Skill(enum.Enum):
    NONE = 0
    FROST = 6
    FIRE = 8
    ARMS = 26
    COMBAT = 38
    SUBTLETY = 39
    POISONS = 40
    SWORDS = 43
    AXES = 44
    BOWS = 45
    GUNS = 46
    BEAST_MASTERY = 50
    SURVIVAL = 51
    MACES = 54
    TWO_HANDED_SWORDS = 55
    HOLY = 56
    SHADOW = 78
    DEFENSE = 95
    LANGUAGE_COMMON = 98
    RACIAL_DWARVEN = 101
    LANGUAGE_ORCISH = 109
    LANGUAGE_DWARVEN = 111
    LANGUAGE_DARNASSIAN = 113
    LANGUAGE_TAURAHE = 115
    DUAL_WIELD = 118
    RACIAL_TAUREN = 124
    ORC_RACIAL = 125
    RACIAL_NIGHT_ELF = 126
    FIRST_AID = 129
    FERAL_COMBAT = 134
    STAVES = 136
    LANGUAGE_THALASSIAN = 137
    LANGUAGE_DRACONIC = 138
    LANGUAGE_DEMON_TONGUE = 139
    LANGUAGE_TITAN = 140
    LANGUAGE_OLD_TONGUE = 141
    SURVIVAL2 = 142
    RIDING_HORSE = 148
    RIDING_WOLF = 149
    RIDING_TIGER = 150
    RIDING_RAM = 152
    SWIMMING = 155
    TWO_HANDED_MACES = 160
    UNARMED = 162
    MARKSMANSHIP = 163
    BLACKSMITHING = 164
    LEATHERWORKING = 165
    ALCHEMY = 171
    TWO_HANDED_AXES = 172
    DAGGERS = 173
    THROWN = 176
    HERBALISM = 182
    GENERIC_DND = 183
    RETRIBUTION = 184
    COOKING = 185
    MINING = 186
    PET_IMP = 188
    PET_FELHUNTER = 189
    TAILORING = 197
    ENGINEERING = 202
    PET_SPIDER = 203
    PET_VOIDWALKER = 204
    PET_SUCCUBUS = 205
    PET_INFERNAL = 206
    PET_DOOMGUARD = 207
    PET_WOLF = 208
    PET_CAT = 209
    PET_BEAR = 210
    PET_BOAR = 211
    PET_CROCILISK = 212
    PET_CARRION_BIRD = 213
    PET_CRAB = 214
    PET_GORILLA = 215
    PET_RAPTOR = 217
    PET_TALLSTRIDER = 218
    RACIAL_UNDED = 220
    CROSSBOWS = 226
    WANDS = 228
    POLEARMS = 229
    PET_SCORPID = 236
    ARCANE = 237
    PET_TURTLE = 251
    ASSASSINATION = 253
    FURY = 256
    PROTECTION = 257
    BEAST_TRAINING = 261
    PROTECTION2 = 267
    PET_TALENTS = 270
    PLATE_MAIL = 293
    LANGUAGE_GNOMISH = 313
    LANGUAGE_TROLL = 315
    ENCHANTING = 333
    DEMONOLOGY = 354
    AFFLICTION = 355
    FISHING = 356
    ENHANCEMENT = 373
    RESTORATION = 374
    ELEMENTAL_COMBAT = 375
    SKINNING = 393
    MAIL = 413
    LEATHER = 414
    CLOTH = 415
    SHIELD = 433
    FIST_WEAPONS = 473
    RIDING_RAPTOR = 533
    RIDING_MECHANOSTRIDER = 553
    RIDING_UNDEAD_HORSE = 554
    RESTORATION2 = 573
    BALANCE = 574
    DESTRUCTION = 593
    HOLY2 = 594
    DISCIPLINE = 613
    LOCKPICKING = 633
    PET_BAT = 653
    PET_HYENA = 654
    PET_OWL = 655
    PET_WIND_SERPENT = 656
    LANGUAGE_GUTTERSPEAK = 673
    RIDING_KODO = 713
    RACIAL_TROLL = 733
    RACIAL_GNOME = 753
    RACIAL_HUMAN = 754
    PET_EVENT_RC = 758
    RIDING = 762


class SkillCategory(enum.Enum):
    ATTRIBUTE = 5
    WEAPON = 6
    CLASS = 7
    ARMOR = 8
    SECONDARY_PROFESSION = 9
    LANGUAGE = 10
    PRIMARY_PROFESSION = 11
    GENERIC = 12


class SoundType(enum.Enum):
    UNUSED = 0
    SPELLS = 1
    UI = 2
    FOOTSTEPS = 3
    WEAPON_IMPACT = 4
    WEAPON_MISS = 6
    PICK_UP_PUT_DOWN = 9
    NPC_COMBAT = 10
    ERRORS = 12
    OBJECTS = 14
    DEATH = 16
    NPC_GREETINGS = 17
    TEST = 18
    ARMOUR_FOLEY = 19
    FOOTSTEPS_2 = 20
    WATER_CHARACTER = 21
    WATER_LIQUID = 22
    TRADESKILLS = 23
    DOODADS = 25
    SPELL_FIZZLE = 26
    NPC_LOOPS = 27
    ZONE_MUSIC = 28
    EMOTES = 29
    NARRATION_MUSIC = 30
    NARRATION = 31
    ZONE_AMBIENCE = 50


class SpellCastResult(enum.Enum):
    AFFECTING_COMBAT = 0
    ALREADY_AT_FULL_HEALTH = 1
    ALREADY_AT_FULL_MANA = 2
    ALREADY_BEING_TAMED = 3
    ALREADY_HAVE_CHARM = 4
    ALREADY_HAVE_SUMMON = 5
    ALREADY_OPEN = 6
    MORE_POWERFUL_SPELL_ACTIVE = 7
    BAD_IMPLICIT_TARGETS = 9
    BAD_TARGETS = 10
    CANT_BE_CHARMED = 11
    CANT_BE_DISENCHANTED = 12
    CANT_BE_PROSPECTED = 13
    CANT_CAST_ON_TAPPED = 14
    CANT_DUEL_WHILE_INVISIBLE = 15
    CANT_DUEL_WHILE_STEALTHED = 16
    CANT_TOO_CLOSE_TO_ENEMY = 17
    CANT_DO_THAT_YET = 18
    CASTER_DEAD = 19
    CHARMED = 20
    CHEST_IN_USE = 21
    CONFUSED = 22
    DONT_REPORT = 23
    EQUIPPED_ITEM = 24
    EQUIPPED_ITEM_CLASS = 25
    EQUIPPED_ITEM_CLASS_MAINHAND = 26
    EQUIPPED_ITEM_CLASS_OFFHAND = 27
    ERROR = 28
    FIZZLE = 29
    FLEEING = 30
    FOOD_LOWLEVEL = 31
    HIGHLEVEL = 32
    IMMUNE = 34
    INTERRUPTED = 35
    INTERRUPTED_COMBAT = 36
    ITEM_ALREADY_ENCHANTED = 37
    ITEM_GONE = 38
    ENCHANT_NOT_EXISTING_ITEM = 39
    ITEM_NOT_READY = 40
    LEVEL_REQUIREMENT = 41
    LINE_OF_SIGHT = 42
    LOWLEVEL = 43
    SKILL_NOT_HIGH_ENOUGH = 44
    MAINHAND_EMPTY = 45
    MOVING = 46
    NEED_AMMO = 47
    NEED_REQUIRES_SOMETHING = 48
    NEED_EXOTIC_AMMO = 49
    NOPATH = 50
    NOT_BEHIND = 51
    NOT_FISHABLE = 52
    NOT_HERE = 53
    NOT_INFRONT = 54
    NOT_IN_CONTROL = 55
    NOT_KNOWN = 56
    NOT_MOUNTED = 57
    NOT_ON_TAXI = 58
    NOT_ON_TRANSPORT = 59
    NOT_READY = 60
    NOT_SHAPESHIFT = 61
    NOT_STANDING = 62
    NOT_TRADEABLE = 63
    NOT_TRADING = 64
    NOT_UNSHEATHED = 65
    NOT_WHILE_GHOST = 66
    NO_AMMO = 67
    NO_CHARGES_REMAIN = 68
    NO_CHAMPION = 69
    NO_COMBO_POINTS = 70
    NO_DUELING = 71
    NO_ENDURANCE = 72
    NO_FISH = 73
    NO_ITEMS_WHILE_SHAPESHIFTED = 74
    NO_MOUNTS_ALLOWED = 75
    NO_PET = 76
    NO_POWER = 77
    NOTHING_TO_DISPEL = 78
    NOTHING_TO_STEAL = 79
    ONLY_ABOVEWATER = 80
    ONLY_DAYTIME = 81
    ONLY_INDOORS = 82
    ONLY_MOUNTED = 83
    ONLY_NIGHTTIME = 84
    ONLY_OUTDOORS = 85
    ONLY_SHAPESHIFT = 86
    ONLY_STEALTHED = 87
    ONLY_UNDERWATER = 88
    OUT_OF_RANGE = 89
    PACIFIED = 90
    POSSESSED = 91
    REQUIRES_AREA = 93
    REQUIRES_SPELL_FOCUS = 94
    ROOTED = 95
    SILENCED = 96
    SPELL_IN_PROGRESS = 97
    SPELL_LEARNED = 98
    SPELL_UNAVAILABLE = 99
    STUNNED = 100
    TARGETS_DEAD = 101
    TARGET_AFFECTING_COMBAT = 102
    TARGET_AURASTATE = 103
    TARGET_DUELING = 104
    TARGET_ENEMY = 105
    TARGET_ENRAGED = 106
    TARGET_FRIENDLY = 107
    TARGET_IN_COMBAT = 108
    TARGET_IS_PLAYER = 109
    TARGET_NOT_DEAD = 110
    TARGET_NOT_IN_PARTY = 111
    TARGET_NOT_LOOTED = 112
    TARGET_NOT_PLAYER = 113
    TARGET_NO_POCKETS = 114
    TARGET_NO_WEAPONS = 115
    TARGET_UNSKINNABLE = 116
    THIRST_SATIATED = 117
    TOO_CLOSE = 118
    TOO_MANY_OF_ITEM = 119
    TRAINING_POINTS = 121
    TRY_AGAIN = 122
    UNIT_NOT_BEHIND = 123
    UNIT_NOT_INFRONT = 124
    WRONG_PET_FOOD = 125
    NOT_WHILE_FATIGUED = 126
    TARGET_NOT_IN_INSTANCE = 127
    NOT_WHILE_TRADING = 128
    TARGET_NOT_IN_RAID = 129
    DISENCHANT_WHILE_LOOTING = 130
    PROSPECT_WHILE_LOOTING = 131
    TARGET_FREEFORALL = 133
    NO_EDIBLE_CORPSES = 134
    ONLY_BATTLEGROUNDS = 135
    TARGET_NOT_GHOST = 136
    TOO_MANY_SKILLS = 137
    CANT_USE_NEW_ITEM = 138
    WRONG_WEATHER = 139
    DAMAGE_IMMUNE = 140
    PREVENTED_BY_MECHANIC = 141
    PLAY_TIME = 142
    REPUTATION = 143
    MIN_SKILL = 144
    UNKNOWN = 145


class SpellEffect(enum.Enum):
    NONE = 0
    INSTAKILL = 1
    SCHOOL_DAMAGE = 2
    DUMMY = 3
    PORTAL_TELEPORT = 4
    TELEPORT_UNITS = 5
    APPLY_AURA = 6
    ENVIRONMENTAL_DAMAGE = 7
    POWER_DRAIN = 8
    HEALTH_LEECH = 9
    HEAL = 10
    BIND = 11
    PORTAL = 12
    RITUAL_BASE = 13
    RITUAL_SPECIALIZE = 14
    RITUAL_ACTIVATE_PORTAL = 15
    QUEST_COMPLETE = 16
    WEAPON_DAMAGE_NOSCHOOL = 17
    RESURRECT = 18
    ADD_EXTRA_ATTACKS = 19
    DODGE = 20
    EVADE = 21
    PARRY = 22
    BLOCK = 23
    CREATE_ITEM = 24
    WEAPON = 25
    DEFENSE = 26
    PERSISTENT_AREA_AURA = 27
    SUMMON = 28
    LEAP = 29
    ENERGIZE = 30
    WEAPON_PERCENT_DAMAGE = 31
    TRIGGER_MISSILE = 32
    OPEN_LOCK = 33
    SUMMON_CHANGE_ITEM = 34
    APPLY_AREA_AURA_PARTY = 35
    LEARN_SPELL = 36
    SPELL_DEFENSE = 37
    DISPEL = 38
    LANGUAGE = 39
    DUAL_WIELD = 40
    SUMMON_WILD = 41
    SUMMON_GUARDIAN = 42
    TELEPORT_UNITS_FACE_CASTER = 43
    SKILL_STEP = 44
    ADD_HONOR = 45
    SPAWN = 46
    TRADE_SKILL = 47
    STEALTH = 48
    DETECT = 49
    TRANS_DOOR = 50
    FORCE_CRITICAL_HIT = 51
    GUARANTEE_HIT = 52
    ENCHANT_ITEM = 53
    ENCHANT_ITEM_TEMPORARY = 54
    TAMECREATURE = 55
    SUMMON_PET = 56
    LEARN_PET_SPELL = 57
    WEAPON_DAMAGE = 58
    OPEN_LOCK_ITEM = 59
    PROFICIENCY = 60
    SEND_EVENT = 61
    POWER_BURN = 62
    THREAT = 63
    TRIGGER_SPELL = 64
    HEALTH_FUNNEL = 65
    POWER_FUNNEL = 66
    HEAL_MAX_HEALTH = 67
    INTERRUPT_CAST = 68
    DISTRACT = 69
    PULL = 70
    PICKPOCKET = 71
    ADD_FARSIGHT = 72
    SUMMON_POSSESSED = 73
    SUMMON_TOTEM = 74
    HEAL_MECHANICAL = 75
    SUMMON_OBJECT_WILD = 76
    SCRIPT_EFFECT = 77
    ATTACK = 78
    SANCTUARY = 79
    ADD_COMBO_POINTS = 80
    CREATE_HOUSE = 81
    BIND_SIGHT = 82
    DUEL = 83
    STUCK = 84
    SUMMON_PLAYER = 85
    ACTIVATE_OBJECT = 86
    SUMMON_TOTEM_SLOT1 = 87
    SUMMON_TOTEM_SLOT2 = 88
    SUMMON_TOTEM_SLOT3 = 89
    SUMMON_TOTEM_SLOT4 = 90
    THREAT_ALL = 91
    ENCHANT_HELD_ITEM = 92
    SUMMON_PHANTASM = 93
    SELF_RESURRECT = 94
    SKINNING = 95
    CHARGE = 96
    SUMMON_CRITTER = 97
    KNOCK_BACK = 98
    DISENCHANT = 99
    INEBRIATE = 100
    FEED_PET = 101
    DISMISS_PET = 102
    REPUTATION = 103
    SUMMON_OBJECT_SLOT1 = 104
    SUMMON_OBJECT_SLOT2 = 105
    SUMMON_OBJECT_SLOT3 = 106
    SUMMON_OBJECT_SLOT4 = 107
    DISPEL_MECHANIC = 108
    SUMMON_DEAD_PET = 109
    DESTROY_ALL_TOTEMS = 110
    DURABILITY_DAMAGE = 111
    SUMMON_DEMON = 112
    RESURRECT_NEW = 113
    ATTACK_ME = 114
    DURABILITY_DAMAGE_PCT = 115
    SKIN_PLAYER_CORPSE = 116
    SPIRIT_HEAL = 117
    SKILL = 118
    APPLY_AREA_AURA_PET = 119
    TELEPORT_GRAVEYARD = 120
    NORMALIZED_WEAPON_DMG = 121
    UNKNOWN122 = 122
    SEND_TAXI = 123
    PLAYER_PULL = 124
    MODIFY_THREAT_PERCENT = 125
    UNKNOWN126 = 126
    UNKNOWN127 = 127


class SpellMissInfo(enum.Enum):
    NONE = 0
    MISS = 1
    RESIST = 2
    DODGE = 3
    PARRY = 4
    BLOCK = 5
    EVADE = 6
    IMMUNE = 7
    IMMUNE2 = 8
    DEFLECT = 9
    ABSORB = 10
    REFLECT = 11


class SpellSchool(enum.Enum):
    NORMAL = 0
    HOLY = 1
    FIRE = 2
    NATURE = 3
    FROST = 4
    SHADOW = 5
    ARCANE = 6


class SpellTriggerType(enum.Enum):
    ON_USE = 0
    ON_EQUIP = 1
    CHANCE_ON_HIT = 2


class StableResult(enum.Enum):
    ERR_MONEY = 1
    ERR_STABLE = 6
    SUCCESS_STABLE = 8
    SUCCESS_UNSTABLE = 9
    SUCCESS_BUY_SLOT = 10


class StatusId(enum.Enum):
    NONE = 0
    WAIT_QUEUE = 1
    WAIT_JOIN = 2
    IN_PROGRESS = 3
    WAIT_LEAVE = 4


class SwingType(enum.Enum):
    LIGHT = 0
    MEDIUM = 1
    HEAVY = 2


class Talent(enum.Enum):
    BURNING_SOUL = 23
    IMPROVED_FIRE_WARD = 24
    IMPROVED_SCORCH = 25
    IMPROVED_FIREBALL = 26
    IMPROVED_FIRE_BLAST = 27
    FLAME_THROWING = 28
    PYROBLAST = 29
    IMPACT = 30
    IMPROVED_FLAMESTRIKE = 31
    BLAST_WAVE = 32
    CRITICAL_MASS = 33
    IGNITE = 34
    FIRE_POWER = 35
    COMBUSTION = 36
    IMPROVED_FROSTBOLT = 37
    FROSTBITE = 38
    PIERCING_ICE = 61
    IMPROVED_FROST_NOVA = 62
    IMPROVED_BLIZZARD = 63
    IMPROVED_CONE_OF_COLD = 64
    PERMAFROST = 65
    FROST_CHANNELING = 66
    SHATTER = 67
    WINTERS_CHILL = 68
    COLD_SNAP = 69
    FROST_WARDING = 70
    ICE_BARRIER = 71
    ICE_BLOCK = 72
    ICE_SHARDS = 73
    ARCANE_SUBTLETY = 74
    ARCANE_CONCENTRATION = 75
    ARCANE_FOCUS = 76
    ARCANE_MIND = 77
    MAGE_WAND_SPECIALIZATION = 78
    IMPROVED_ARCANE_MISSILES = 80
    IMPROVED_ARCANE_EXPLOSION = 81
    MAGIC_ATTUNEMENT = 82
    IMPROVED_MANA_SHIELD = 83
    ARCANE_RESILIENCE = 85
    PRESENCE_OF_MIND = 86
    ARCANE_POWER = 87
    IMPROVED_COUNTERSPELL = 88
    DEEP_WOUNDS = 121
    WARRIOR_SWORD_SPECIALIZATION = 123
    IMPROVED_HEROIC_STRIKE = 124
    WARRIOR_MACE_SPECIALIZATION = 125
    IMPROVED_CHARGE = 126
    IMPROVED_REND = 127
    IMPROVED_THUNDER_CLAP = 128
    IMPROVED_HAMSTRING = 129
    WARRIOR_DEFLECTION = 130
    IMPROVED_OVERPOWER = 131
    AXE_SPECIALIZATION = 132
    SWEEPING_STRIKES = 133
    POLEARM_SPECIALIZATION = 134
    MORTAL_STRIKE = 135
    WARRIOR_TWO_HANDED_WEAPON_SPECIALIZATION = 136
    ANGER_MANAGEMENT = 137
    WARRIOR_ANTICIPATION = 138
    WARRIOR_TOUGHNESS = 140
    IRON_WILL = 141
    IMPROVED_BLOODRAGE = 142
    IMPROVED_TAUNT = 143
    DEFIANCE = 144
    IMPROVED_SHIELD_BLOCK = 145
    IMPROVED_SUNDER_ARMOR = 146
    IMPROVED_REVENGE = 147
    SHIELD_SLAM = 148
    IMPROVED_SHIELD_BASH = 149
    IMPROVED_SHIELD_WALL = 150
    IMPROVED_DISARM = 151
    CONCUSSION_BLOW = 152
    LAST_STAND = 153
    IMPROVED_BATTLE_SHOUT = 154
    ENRAGE = 155
    WARRIOR_FLURRY = 156
    CRUELTY = 157
    BOOMING_VOICE = 158
    UNBRIDLED_WRATH = 159
    PIERCING_HOWL = 160
    IMPROVED_DEMORALIZING_SHOUT = 161
    DEATH_WISH = 165
    IMPROVED_CLEAVE = 166
    BLOODTHIRST = 167
    IMPROVED_SLAM = 168
    ROGUE_PRECISION = 181
    DAGGER_SPECIALIZATION = 182
    FIST_WEAPON_SPECIALIZATION = 183
    ROGUE_MACE_SPECIALIZATION = 184
    ROGUE_LIGHTNING_REFLEXES = 186
    ROGUE_DEFLECTION = 187
    IMPROVED_SINISTER_STRIKE = 201
    IMPROVED_BACKSTAB = 202
    IMPROVED_GOUGE = 203
    ENDURANCE = 204
    ADRENALINE_RUSH = 205
    IMPROVED_KICK = 206
    ROGUE_DUAL_WIELD_SPECIALIZATION = 221
    IMPROVED_SPRINT = 222
    BLADE_FLURRY = 223
    MASTER_OF_DECEPTION = 241
    ROGUE_SWORD_SPECIALIZATION = 242
    CAMOUFLAGE = 244
    INITIATIVE = 245
    SETUP = 246
    ELUSIVENESS = 247
    OPPORTUNITY = 261
    IMPROVED_SAP = 262
    IMPROVED_AMBUSH = 263
    DIRTY_DEEDS = 265
    IMPROVED_POISONS = 268
    LETHALITY = 269
    MALICE = 270
    REMORSELESS_ATTACKS = 272
    RUTHLESSNESS = 273
    MURDER = 274
    IMPROVED_EVISCERATE = 276
    IMPROVED_SLICE_AND_DICE = 277
    IMPROVED_EXPOSE_ARMOR = 278
    IMPROVED_KIDNEY_SHOT = 279
    COLD_BLOOD = 280
    RELENTLESS_STRIKES = 281
    SEAL_FATE = 283
    PREPARATION = 284
    RIPOSTE = 301
    GHOSTLY_STRIKE = 303
    MARTYRDOM = 321
    POWER_INFUSION = 322
    MENTAL_AGILITY = 341
    UNBREAKABLE_WILL = 342
    IMPROVED_POWER_WORD_SHIELD = 343
    IMPROVED_POWER_WORD_FORTITUDE = 344
    PRIEST_WAND_SPECIALIZATION = 345
    IMPROVED_INNER_FIRE = 346
    MEDITATION = 347
    INNER_FOCUS = 348
    IMPROVED_MANA_BURN = 350
    DIVINE_SPIRIT = 351
    SILENT_RESOLVE = 352
    INSPIRATION = 361
    PREMEDITATION = 381
    VIGOR = 382
    HOLY_SPECIALIZATION = 401
    SPIRITUAL_GUIDANCE = 402
    SEARING_LIGHT = 403
    SPIRITUAL_HEALING = 404
    IMPROVED_RENEW = 406
    IMPROVED_HEALING = 408
    PRIEST_HEALING_FOCUS = 410
    SPELL_WARDING = 411
    IMPROVED_PRAYER_OF_HEALING = 413
    ARCANE_INSTABILITY = 421
    HOLY_NOVA = 442
    SHADOW_WEAVING = 461
    DARKNESS = 462
    SHADOW_FOCUS = 463
    BLACKOUT = 464
    SPIRIT_TAP = 465
    SHADOW_AFFINITY = 466
    IMPROVED_MIND_BLAST = 481
    IMPROVED_SHADOW_WORD_PAIN = 482
    IMPROVED_FADE = 483
    VAMPIRIC_EMBRACE = 484
    MIND_FLAY = 501
    SHADOWFORM = 521
    SILENCE = 541
    IMPROVED_PSYCHIC_SCREAM = 542
    CALL_OF_FLAME = 561
    CALL_OF_THUNDER = 562
    CONCUSSION = 563
    CONVECTION = 564
    ELEMENTAL_FURY = 565
    IMPROVED_FIRE_TOTEMS = 567
    EARTHS_GRASP = 572
    ELEMENTAL_MASTERY = 573
    ELEMENTAL_FOCUS = 574
    REVERBERATION = 575
    ANCESTRAL_HEALING = 581
    TOTEMIC_MASTERY = 582
    NATURES_GUIDANCE = 583
    IMPROVED_HEALING_WAVE = 586
    SHAMAN_HEALING_FOCUS = 587
    RESTORATIVE_TOTEMS = 588
    IMPROVED_REINCARNATION = 589
    MANA_TIDE_TOTEM = 590
    SHAMAN_NATURES_SWIFTNESS = 591
    PURIFICATION = 592
    TIDAL_FOCUS = 593
    TIDAL_MASTERY = 594
    TOTEMIC_FOCUS = 595
    SHAMAN_ANTICIPATION = 601
    SHAMAN_FLURRY = 602
    IMPROVED_GHOST_WOLF = 605
    IMPROVED_LIGHTNING_SHIELD = 607
    GUARDIAN_TOTEMS = 609
    ENHANCING_TOTEMS = 610
    ELEMENTAL_WEAPONS = 611
    SHAMAN_SHIELD_SPECIALIZATION = 612
    THUNDERING_STRIKES = 613
    ANCESTRAL_KNOWLEDGE = 614
    SHAMAN_TOUGHNESS = 615
    PARRY = 616
    TWO_HANDED_AXES_AND_MACES = 617
    TACTICAL_MASTERY = 641
    BLOOD_CRAZE = 661
    IMPALE = 662
    HEMORRHAGE = 681
    VILE_POISONS = 682
    WARRIOR_ONE_HANDED_WEAPON_SPECIALIZATION = 702
    LIGHTNING_MASTERY = 721
    ARCTIC_REACH = 741
    NATURES_GRASP = 761
    IMPROVED_WRATH = 762
    IMPROVED_MOONFIRE = 763
    NATURES_REACH = 764
    NATURAL_SHAPESHIFTER = 781
    IMPROVED_THORNS = 782
    MOONGLOW = 783
    IMPROVED_STARFIRE = 784
    IMPROVED_ENTANGLING_ROOTS = 787
    OMEN_OF_CLARITY = 788
    NATURES_GRACE = 789
    MOONFURY = 790
    NATURAL_WEAPONS = 791
    DRUID_VENGEANCE = 792
    MOONKIN_FORM = 793
    DRUID_THICK_HIDE = 794
    FERAL_AGGRESSION = 795
    DRUID_FEROCITY = 796
    BRUTAL_IMPACT = 797
    SHARPENED_CLAWS = 798
    FERAL_INSTINCT = 799
    BLOOD_FRENZY = 800
    PRIMAL_FURY = 801
    IMPROVED_SHRED = 802
    PREDATORY_STRIKES = 803
    FERAL_CHARGE = 804
    SAVAGE_FURY = 805
    FELINE_SWIFTNESS = 807
    HEART_OF_THE_WILD = 808
    LEADER_OF_THE_PACK = 809
    IMPROVED_MARK_OF_THE_WILD = 821
    FUROR = 822
    NATURES_FOCUS = 823
    IMPROVED_HEALING_TOUCH = 824
    IMPROVED_REGROWTH = 825
    IMPROVED_ENRAGE = 826
    INSECT_SWARM = 827
    GIFT_OF_NATURE = 828
    REFLECTION = 829
    IMPROVED_REJUVENATION = 830
    DRUID_NATURES_SWIFTNESS = 831
    SUBTLETY = 841
    IMPROVED_TRANQUILITY = 842
    TRANQUIL_SPIRIT = 843
    SWIFTMEND = 844
    SHADOW_REACH = 881
    STORMSTRIKE = 901
    IMPROVED_NATURES_GRASP = 921
    CATACLYSM = 941
    BANE = 943
    IMPROVED_SHADOW_BOLT = 944
    IMPROVED_IMMOLATE = 961
    SHADOWBURN = 963
    DESTRUCTIVE_REACH = 964
    IMPROVED_SEARING_PAIN = 965
    EMBERSTORM = 966
    RUIN = 967
    CONFLAGRATE = 968
    DEVASTATION = 981
    AFTERMATH = 982
    IMPROVED_FIREBOLT = 983
    IMPROVED_LASH_OF_PAIN = 984
    INTENSITY = 985
    PYROCLASM = 986
    FEL_CONCENTRATION = 1001
    NIGHTFALL = 1002
    IMPROVED_CORRUPTION = 1003
    IMPROVED_DRAIN_LIFE = 1004
    SUPPRESSION = 1005
    IMPROVED_CURSE_OF_WEAKNESS = 1006
    IMPROVED_LIFE_TAP = 1007
    GRIM_REACH = 1021
    DARK_PACT = 1022
    SIPHON_LIFE = 1041
    SHADOW_MASTERY = 1042
    AMPLIFY_CURSE = 1061
    CURSE_OF_EXHAUSTION = 1081
    IMPROVED_CURSE_OF_EXHAUSTION = 1082
    IMPROVED_DRAIN_SOUL = 1101
    IMPROVED_DRAIN_MANA = 1121
    AGGRESSION = 1122
    SERRATED_BLADES = 1123
    INCINERATE = 1141
    ARCANE_MEDITATION = 1142
    FAERIE_FIRE_FERAL = 1162
    DIVINE_FURY = 1181
    MENTAL_STRENGTH = 1201
    FORCE_OF_WILL = 1202
    IMPROVED_HEALTHSTONE = 1221
    IMPROVED_IMP = 1222
    DEMONIC_EMBRACE = 1223
    IMPROVED_HEALTH_FUNNEL = 1224
    IMPROVED_VOIDWALKER = 1225
    FEL_DOMINATION = 1226
    MASTER_SUMMONER = 1227
    FEL_STAMINA = 1241
    FEL_INTELLECT = 1242
    IMPROVED_SUCCUBUS = 1243
    MASTER_DEMONOLOGIST = 1244
    IMPROVED_FIRESTONE = 1261
    UNHOLY_POWER = 1262
    IMPROVED_SPELLSTONE = 1263
    DEMONIC_SACRIFICE = 1281
    SOUL_LINK = 1282
    IMPROVED_ENSLAVE_DEMON = 1283
    IMPROVED_CURSE_OF_AGONY = 1284
    HUMANOID_SLAYING = 1301
    HUNTER_LIGHTNING_REFLEXES = 1303
    ENTRAPMENT = 1304
    IMPROVED_WING_CLIP = 1305
    CLEVER_TRAPS = 1306
    DETERRENCE = 1308
    IMPROVED_FEIGN_DEATH = 1309
    SUREFOOTED = 1310
    HUNTER_DEFLECTION = 1311
    COUNTERATTACK = 1312
    KILLER_INSTINCT = 1321
    TRAP_MASTERY = 1322
    WYVERN_STING = 1325
    IMPROVED_CONCUSSIVE_SHOT = 1341
    EFFICIENCY = 1342
    IMPROVED_HUNTERS_MARK = 1343
    LETHAL_SHOTS = 1344
    AIMED_SHOT = 1345
    IMPROVED_ARCANE_SHOT = 1346
    BARRAGE = 1347
    IMPROVED_SERPENT_STING = 1348
    MORTAL_SHOTS = 1349
    IMPROVED_SCORPID_STING = 1351
    HAWK_EYE = 1352
    SCATTER_SHOT = 1353
    TRUESHOT_AURA = 1361
    RANGED_WEAPON_SPECIALIZATION = 1362
    IMPROVED_ASPECT_OF_THE_MONKEY = 1381
    IMPROVED_ASPECT_OF_THE_HAWK = 1382
    PATHFINDING = 1384
    IMPROVED_MEND_PET = 1385
    BESTIAL_WRATH = 1386
    INTIMIDATION = 1387
    SPIRIT_BOND = 1388
    ENDURANCE_TRAINING = 1389
    BESTIAL_DISCIPLINE = 1390
    BESTIAL_SWIFTNESS = 1391
    HUNTER_FEROCITY = 1393
    HUNTER_THICK_HIDE = 1395
    UNLEASHED_FURY = 1396
    FRENZY = 1397
    IMPROVED_BLESSING_OF_MIGHT = 1401
    PALADIN_VENGEANCE = 1402
    PALADIN_DEFLECTION = 1403
    IMPROVED_RETRIBUTION_AURA = 1405
    BENEDICTION = 1407
    SANCTITY_AURA = 1409
    PALADIN_TWO_HANDED_WEAPON_SPECIALIZATION = 1410
    CONVICTION = 1411
    REDOUBT = 1421
    IMPROVED_DEVOTION_AURA = 1422
    PALADIN_TOUGHNESS = 1423
    PALADIN_SHIELD_SPECIALIZATION = 1424
    GUARDIANS_FAVOR = 1425
    RECKONING = 1426
    PALADIN_ONE_HANDED_WEAPON_SPECIALIZATION = 1429
    HOLY_SHIELD = 1430
    BLESSING_OF_SANCTUARY = 1431
    SPIRITUAL_FOCUS = 1432
    DIVINE_FAVOR = 1433
    CONSECRATION = 1435
    REPENTANCE = 1441
    BLESSING_OF_KINGS = 1442
    IMPROVED_LAY_ON_HANDS = 1443
    HEALING_LIGHT = 1444
    IMPROVED_BLESSING_OF_WISDOM = 1446
    DIVINE_INTELLECT = 1449
    DIVINE_STRENGTH = 1450
    ILLUMINATION = 1461
    IMPROVED_SEAL_OF_RIGHTEOUSNESS = 1463
    IMPROVED_SEAL_OF_THE_CRUSADER = 1464
    LASTING_JUDGEMENT = 1465
    SEAL_OF_COMMAND = 1481
    IMPROVED_RIGHTEOUS_FURY = 1501
    HOLY_SHOCK = 1502
    IMPROVED_HAMMER_OF_JUSTICE = 1521
    IMPROVED_BERSERKER_RAGE = 1541
    IMPROVED_EXECUTE = 1542
    IMPROVED_INTERCEPT = 1543
    SPIRIT_OF_REDEMPTION = 1561
    WARRIOR_DUAL_WIELD_SPECIALIZATION = 1581
    WARRIOR_SHIELD_SPECIALIZATION = 1601
    SAVAGE_STRIKES = 1621
    SURVIVALIST = 1622
    MONSTER_SLAYING = 1623
    IMPROVED_EYES_OF_THE_BEAST = 1624
    IMPROVED_REVIVE_PET = 1625
    IMPROVED_CONCENTRATION_AURA = 1626
    HOLY_POWER = 1627
    UNYIELDING_FAITH = 1628
    PALADIN_ANTICIPATION = 1629
    PALADIN_PRECISION = 1630
    IMPROVED_JUDGEMENT = 1631
    EYE_FOR_AN_EYE = 1632
    VINDICATION = 1633
    PURSUIT_OF_JUSTICE = 1634
    HOLY_REACH = 1635
    BLESSED_RECOVERY = 1636
    LIGHTWELL = 1637
    IMPROVED_VAMPIRIC_EMBRACE = 1638
    MASTER_OF_ELEMENTS = 1639
    ELEMENTAL_WARDING = 1640
    STORM_REACH = 1641
    EYE_OF_THE_STORM = 1642
    WEAPON_MASTERY = 1643
    ELEMENTAL_DEVASTATION = 1645
    HEALING_GRACE = 1646
    IMPROVED_WEAPON_TOTEMS = 1647
    HEALING_WAY = 1648
    ELEMENTAL_PRECISION = 1649
    MAGIC_ABSORPTION = 1650
    SLEIGHT_OF_HAND = 1700
    HEIGHTENED_SENSES = 1701
    DEADLINESS = 1702
    WEAPON_EXPERTISE = 1703


class TextEmote(enum.Enum):
    AGREE = 1
    AMAZE = 2
    ANGRY = 3
    APOLOGIZE = 4
    APPLAUD = 5
    BASHFUL = 6
    BECKON = 7
    BEG = 8
    BITE = 9
    BLEED = 10
    BLINK = 11
    BLUSH = 12
    BONK = 13
    BORED = 14
    BOUNCE = 15
    BRB = 16
    BOW = 17
    BURP = 18
    BYE = 19
    CACKLE = 20
    CHEER = 21
    CHICKEN = 22
    CHUCKLE = 23
    CLAP = 24
    CONFUSED = 25
    CONGRATULATE = 26
    COUGH = 27
    COWER = 28
    CRACK = 29
    CRINGE = 30
    CRY = 31
    CURIOUS = 32
    CURTSEY = 33
    DANCE = 34
    DRINK = 35
    DROOL = 36
    EAT = 37
    EYE = 38
    FART = 39
    FIDGET = 40
    FLEX = 41
    FROWN = 42
    GASP = 43
    GAZE = 44
    GIGGLE = 45
    GLARE = 46
    GLOAT = 47
    GREET = 48
    GRIN = 49
    GROAN = 50
    GROVEL = 51
    GUFFAW = 52
    HAIL = 53
    HAPPY = 54
    HELLO = 55
    HUG = 56
    HUNGRY = 57
    KISS = 58
    KNEEL = 59
    LAUGH = 60
    LAYDOWN = 61
    MASSAGE = 62
    MOAN = 63
    MOON = 64
    MOURN = 65
    NO = 66
    NOD = 67
    NOSE_PICK = 68
    PANIC = 69
    PEER = 70
    PLEAD = 71
    POINT = 72
    POKE = 73
    PRAY = 74
    ROAR = 75
    ROFL = 76
    RUDE = 77
    SALUTE = 78
    SCRATCH = 79
    SEXY = 80
    SHAKE = 81
    SHOUT = 82
    SHRUG = 83
    SHY = 84
    SIGH = 85
    SIT = 86
    SLEEP = 87
    SNARL = 88
    SPIT = 89
    STARE = 90
    SURPRISED = 91
    SURRENDER = 92
    TALK = 93
    TALK_EX = 94
    TALK_Q = 95
    TAP = 96
    THANK = 97
    THREATEN = 98
    TIRED = 99
    VICTORY = 100
    WAVE = 101
    WELCOME = 102
    WHINE = 103
    WHISTLE = 104
    WORK = 105
    YAWN = 106
    BOGGLE = 107
    CALM = 108
    COLD = 109
    COMFORT = 110
    CUDDLE = 111
    DUCK = 112
    INSULT = 113
    INTRODUCE = 114
    JK = 115
    LICK = 116
    LISTEN = 117
    LOST = 118
    MOCK = 119
    PONDER = 120
    POUNCE = 121
    PRAISE = 122
    PURR = 123
    PUZZLE = 124
    RAISE = 125
    READY = 126
    SHIMMY = 127
    SHIVER = 128
    SHOO = 129
    SLAP = 130
    SMIRK = 131
    SNIFF = 132
    SNUB = 133
    SOOTHE = 134
    STINK = 135
    TAUNT = 136
    TEASE = 137
    THIRSTY = 138
    VETO = 139
    SNICKER = 140
    STAND = 141
    TICKLE = 142
    VIOLIN = 143
    SMILE = 163
    RASP = 183
    PITY = 203
    GROWL = 204
    BARK = 205
    SCARED = 223
    FLOP = 224
    LOVE = 225
    MOO = 226
    COMMEND = 243
    TRAIN = 264
    HELPME = 303
    INCOMING = 304
    CHARGE = 305
    FLEE = 306
    ATTACK_MY_TARGET = 307
    OOM = 323
    FOLLOW = 324
    WAIT = 325
    HEAL_ME = 326
    OPEN_FIRE = 327
    FLIRT = 328
    JOKE = 329
    GOLF_CLAP = 343
    WINK = 363
    PAT = 364


class TimerType(enum.Enum):
    FATIGUE = 0
    BREATH = 1
    FEIGN_DEATH = 2
    ENVIRONMENTAL = 3


class TradeStatus(enum.Enum):
    BUSY = 0
    BEGIN_TRADE = 1
    OPEN_WINDOW = 2
    TRADE_CANCELED = 3
    TRADE_ACCEPT = 4
    BUSY_2 = 5
    NO_TARGET = 6
    BACK_TO_TRADE = 7
    TRADE_COMPLETE = 8
    TRADE_REJECTED = 9
    TARGET_TO_FAR = 10
    WRONG_FACTION = 11
    CLOSE_WINDOW = 12
    UNKNOWN_13 = 13
    IGNORE_YOU = 14
    YOU_STUNNED = 15
    TARGET_STUNNED = 16
    YOU_DEAD = 17
    TARGET_DEAD = 18
    YOU_LOGOUT = 19
    TARGET_LOGOUT = 20
    TRIAL_ACCOUNT = 21
    ONLY_CONJURED = 22
    NOT_ON_TAPLIST = 23


class TrainerSpellState(enum.Enum):
    GREEN = 0
    RED = 1
    GRAY = 2


class TrainingFailureReason(enum.Enum):
    UNAVAILABLE = 0
    NOT_ENOUGH_MONEY = 1
    NOT_ENOUGH_SKILL = 2


class TransferAbortReason(enum.Enum):
    NONE = 0
    IS_FULL = 1
    NOT_FOUND = 2
    TOO_MANY_INSTANCES = 3
    ZONE_IS_IN_COMBAT = 5


class UnitStandState(enum.Enum):
    STAND = 0
    SIT = 1
    SIT_CHAIR = 2
    SLEEP = 3
    SIT_LOW_CHAIR = 4
    SIT_MEDIUM_CHAIR = 5
    SIT_HIGH_CHAIR = 6
    DEAD = 7
    KNEEL = 8
    CUSTOM = 9


class UpdateType(enum.Enum):
    VALUES = 0
    MOVEMENT = 1
    CREATE_OBJECT = 2
    CREATE_OBJECT2 = 3
    OUT_OF_RANGE_OBJECTS = 4
    NEAR_OBJECTS = 5


class UrlInfo(enum.Enum):
    UNAVAILABLE = 0
    AVAILABLE = 1


class WeatherChangeType(enum.Enum):
    SMOOTH = 0
    INSTANT = 1


class WeatherType(enum.Enum):
    FINE = 0
    RAIN = 1
    SNOW = 2
    STORM = 3


class WorldResult(enum.Enum):
    RESPONSE_SUCCESS = 0
    RESPONSE_FAILURE = 1
    RESPONSE_CANCELLED = 2
    RESPONSE_DISCONNECTED = 3
    RESPONSE_FAILED_TO_CONNECT = 4
    RESPONSE_CONNECTED = 5
    RESPONSE_VERSION_MISMATCH = 6
    CSTATUS_CONNECTING = 7
    CSTATUS_NEGOTIATING_SECURITY = 8
    CSTATUS_NEGOTIATION_COMPLETE = 9
    CSTATUS_NEGOTIATION_FAILED = 10
    CSTATUS_AUTHENTICATING = 11
    AUTH_OK = 12
    AUTH_FAILED = 13
    AUTH_REJECT = 14
    AUTH_BAD_SERVER_PROOF = 15
    AUTH_UNAVAILABLE = 16
    AUTH_SYSTEM_ERROR = 17
    AUTH_BILLING_ERROR = 18
    AUTH_BILLING_EXPIRED = 19
    AUTH_VERSION_MISMATCH = 20
    AUTH_UNKNOWN_ACCOUNT = 21
    AUTH_INCORRECT_PASSWORD = 22
    AUTH_SESSION_EXPIRED = 23
    AUTH_SERVER_SHUTTING_DOWN = 24
    AUTH_ALREADY_LOGGING_IN = 25
    AUTH_LOGIN_SERVER_NOT_FOUND = 26
    AUTH_WAIT_QUEUE = 27
    AUTH_BANNED = 28
    AUTH_ALREADY_ONLINE = 29
    AUTH_NO_TIME = 30
    AUTH_DB_BUSY = 31
    AUTH_SUSPENDED = 32
    AUTH_PARENTAL_CONTROL = 33
    REALM_LIST_IN_PROGRESS = 34
    REALM_LIST_SUCCESS = 35
    REALM_LIST_FAILED = 36
    REALM_LIST_INVALID = 37
    REALM_LIST_REALM_NOT_FOUND = 38
    ACCOUNT_CREATE_IN_PROGRESS = 39
    ACCOUNT_CREATE_SUCCESS = 40
    ACCOUNT_CREATE_FAILED = 41
    CHAR_LIST_RETRIEVING = 42
    CHAR_LIST_RETRIEVED = 43
    CHAR_LIST_FAILED = 44
    CHAR_CREATE_IN_PROGRESS = 45
    CHAR_CREATE_SUCCESS = 46
    CHAR_CREATE_ERROR = 47
    CHAR_CREATE_FAILED = 48
    CHAR_CREATE_NAME_IN_USE = 49
    CHAR_CREATE_DISABLED = 50
    CHAR_CREATE_PVP_TEAMS_VIOLATION = 51
    CHAR_CREATE_SERVER_LIMIT = 52
    CHAR_CREATE_ACCOUNT_LIMIT = 53
    CHAR_CREATE_SERVER_QUEUE = 54
    CHAR_CREATE_ONLY_EXISTING = 55
    CHAR_DELETE_IN_PROGRESS = 56
    CHAR_DELETE_SUCCESS = 57
    CHAR_DELETE_FAILED = 58
    CHAR_DELETE_FAILED_LOCKED_FOR_TRANSFER = 59
    CHAR_LOGIN_IN_PROGRESS = 60
    CHAR_LOGIN_SUCCESS = 61
    CHAR_LOGIN_NO_WORLD = 62
    CHAR_LOGIN_DUPLICATE_CHARACTER = 63
    CHAR_LOGIN_NO_INSTANCES = 64
    CHAR_LOGIN_FAILED = 65
    CHAR_LOGIN_DISABLED = 66
    CHAR_LOGIN_NO_CHARACTER = 67
    CHAR_LOGIN_LOCKED_FOR_TRANSFER = 68
    CHAR_NAME_NO_NAME = 69
    CHAR_NAME_TOO_SHORT = 70
    CHAR_NAME_TOO_LONG = 71
    CHAR_NAME_ONLY_LETTERS = 72
    CHAR_NAME_MIXED_LANGUAGES = 73
    CHAR_NAME_PROFANE = 74
    CHAR_NAME_RESERVED = 75
    CHAR_NAME_INVALID_APOSTROPHE = 76
    CHAR_NAME_MULTIPLE_APOSTROPHES = 77
    CHAR_NAME_THREE_CONSECUTIVE = 78
    CHAR_NAME_INVALID_SPACE = 79
    CHAR_NAME_SUCCESS = 80
    CHAR_NAME_FAILURE = 81


class AllowedClass(enum.Flag):
    ALL = 0
    WARRIOR = 1
    PALADIN = 2
    HUNTER = 4
    ROGUE = 8
    PRIEST = 16
    SHAMAN = 64
    MAGE = 128
    WARLOCK = 256
    DRUID = 1024


class AllowedRace(enum.Flag):
    ALL = 0
    HUMAN = 1
    ORC = 2
    DWARF = 4
    NIGHT_ELF = 8
    UNDEAD = 16
    TAUREN = 32
    GNOME = 64
    TROLL = 128
    GOBLIN = 256


class AreaFlags(enum.Flag):
    SNOW = 1
    UNK = 2
    DEVELOPMENT = 4
    UNK2 = 8
    UNK3 = 16
    CITY_SLAVE = 32
    CITY_ALLOW_DUELS = 64
    UNK4 = 128
    CITY = 256
    TEST = 512


class Attributes(enum.Flag):
    NONE = 0
    PROC_FAILURE_BURNS_CHARGE = 1
    USES_RANGED_SLOT = 2
    ON_NEXT_SWING_NO_DAMAGE = 4
    NEED_EXOTIC_AMMO = 8
    IS_ABILITY = 16
    IS_TRADESKILL = 32
    PASSIVE = 64
    DO_NOT_DISPLAY = 128
    DO_NOT_LOG = 256
    HELD_ITEM_ONLY = 512
    ON_NEXT_SWING = 1024
    WEARER_CASTS_PROC_TRIGGER = 2048
    DAYTIME_ONLY = 4096
    NIGHT_ONLY = 8192
    ONLY_INDOORS = 16384
    ONLY_OUTDOORS = 32768
    NOT_SHAPESHIFT = 65536
    ONLY_STEALTHED = 131072
    DO_NOT_SHEATH = 262144
    SCALES_WITH_CREATURE_LEVEL = 524288
    CANCELS_AUTO_ATTACK_COMBAT = 1048576
    NO_ACTIVE_DEFENSE = 2097152
    TRACK_TARGET_IN_CAST_PLAYER_ONLY = 4194304
    ALLOW_CAST_WHILE_DEAD = 8388608
    ALLOW_WHILE_MOUNTED = 16777216
    COOLDOWN_ON_EVENT = 33554432
    AURA_IS_DEBUFF = 67108864
    ALLOW_WHILE_SITTING = 134217728
    NOT_IN_COMBAT_ONLY_PEACEFUL = 268435456
    NO_IMMUNITIES = 536870912
    HEARTBEAT_RESIST = 1073741824
    NO_AURA_CANCEL = 2147483648


class AttributesEx1(enum.Flag):
    NONE = 0
    DISMISS_PET_FIRST = 1
    USE_ALL_MANA = 2
    IS_CHANNELED = 4
    NO_REDIRECTION = 8
    NO_SKILL_INCREASE = 16
    ALLOW_WHILE_STEALTHED = 32
    IS_SELF_CHANNELED = 64
    NO_REFLECTION = 128
    ONLY_PEACEFUL_TARGETS = 256
    INITIATES_COMBAT_ENABLES_AUTO_ATTACK = 512
    NO_THREAT = 1024
    AURA_UNIQUE = 2048
    FAILURE_BREAKS_STEALTH = 4096
    TOGGLE_FARSIGHT = 8192
    TRACK_TARGET_IN_CHANNEL = 16384
    IMMUNITY_PURGES_EFFECT = 32768
    IMMUNITY_TO_HOSTILE_AND_FRIENDLY_EFFECTS = 65536
    NO_AUTOCAST_AI = 131072
    PREVENTS_ANIM = 262144
    EXCLUDE_CASTER = 524288
    FINISHING_MOVE_DAMAGE = 1048576
    THREAT_ONLY_ON_MISS = 2097152
    FINISHING_MOVE_DURATION = 4194304
    UNK23 = 8388608
    SPECIAL_SKILLUP = 16777216
    AURA_STAYS_AFTER_COMBAT = 33554432
    REQUIRE_ALL_TARGETS = 67108864
    DISCOUNT_POWER_ON_MISS = 134217728
    NO_AURA_ICON = 268435456
    NAME_IN_CHANNEL_BAR = 536870912
    COMBO_ON_BLOCK = 1073741824
    CAST_WHEN_LEARNED = 2147483648


class AttributesEx2(enum.Flag):
    NONE = 0
    ALLOW_DEAD_TARGET = 1
    NO_SHAPESHIFT_UI = 2
    IGNORE_LINE_OF_SIGHT = 4
    ALLOW_LOW_LEVEL_BUFF = 8
    USE_SHAPESHIFT_BAR = 16
    AUTO_REPEAT = 32
    CANNOT_CAST_ON_TAPPED = 64
    DO_NOT_REPORT_SPELL_FAILURE = 128
    INCLUDE_IN_ADVANCED_COMBAT_LOG = 256
    ALWAYS_CAST_AS_UNIT = 512
    SPECIAL_TAMING_FLAG = 1024
    NO_TARGET_PER_SECOND_COSTS = 2048
    CHAIN_FROM_CASTER = 4096
    ENCHANT_OWN_ITEM_ONLY = 8192
    ALLOW_WHILE_INVISIBLE = 16384
    UNK15 = 32768
    NO_ACTIVE_PETS = 65536
    DO_NOT_RESET_COMBAT_TIMERS = 131072
    REQ_DEAD_PET = 262144
    ALLOW_WHILE_NOT_SHAPESHIFTED = 524288
    INITIATE_COMBAT_POST_CAST = 1048576
    FAIL_ON_ALL_TARGETS_IMMUNE = 2097152
    NO_INITIAL_THREAT = 4194304
    PROC_COOLDOWN_ON_FAILURE = 8388608
    ITEM_CAST_WITH_OWNER_SKILL = 16777216
    DONT_BLOCK_MANA_REGEN = 33554432
    NO_SCHOOL_IMMUNITIES = 67108864
    IGNORE_WEAPONSKILL = 134217728
    NOT_AN_ACTION = 268435456
    CANT_CRIT = 536870912
    ACTIVE_THREAT = 1073741824
    RETAIN_ITEM_CAST = 2147483648


class AttributesEx3(enum.Flag):
    NONE = 0
    PVP_ENABLING = 1
    NO_PROC_EQUIP_REQUIREMENT = 2
    NO_CASTING_BAR_TEXT = 4
    COMPLETELY_BLOCKED = 8
    NO_RES_TIMER = 16
    NO_DURABILITY_LOSS = 32
    NO_AVOIDANCE = 64
    DOT_STACKING_RULE = 128
    ONLY_ON_PLAYER = 256
    NOT_A_PROC = 512
    REQUIRES_MAIN_HAND_WEAPON = 1024
    ONLY_BATTLEGROUNDS = 2048
    ONLY_ON_GHOSTS = 4096
    HIDE_CHANNEL_BAR = 8192
    HIDE_IN_RAID_FILTER = 16384
    NORMAL_RANGED_ATTACK = 32768
    SUPPRESS_CASTER_PROCS = 65536
    SUPPRESS_TARGET_PROCS = 131072
    ALWAYS_HIT = 262144
    INSTANT_TARGET_PROCS = 524288
    ALLOW_AURA_WHILE_DEAD = 1048576
    ONLY_PROC_OUTDOORS = 2097152
    CASTING_CANCELS_AUTOREPEAT = 4194304
    NO_DAMAGE_HISTORY = 8388608
    REQUIRES_OFFHAND_WEAPON = 16777216
    TREAT_AS_PERIODIC = 33554432
    CAN_PROC_FROM_PROCS = 67108864
    ONLY_PROC_ON_CASTER = 134217728
    IGNORE_CASTER_AND_TARGET_RESTRICTIONS = 268435456
    IGNORE_CASTER_MODIFIERS = 536870912
    DO_NOT_DISPLAY_RANGE = 1073741824
    NOT_ON_AOE_IMMUNE = 2147483648


class AttributesEx4(enum.Flag):
    NONE = 0
    NO_CAST_LOG = 1
    CLASS_TRIGGER_ONLY_ON_TARGET = 2
    AURA_EXPIRES_OFFLINE = 4
    NO_HELPFUL_THREAT = 8
    NO_HARMFUL_THREAT = 16
    ALLOW_CLIENT_TARGETING = 32
    CANNOT_BE_STOLEN = 64
    ALLOW_CAST_WHILE_CASTING = 128
    IGNORE_DAMAGE_TAKEN_MODIFIERS = 256
    COMBAT_FEEDBACK_WHEN_USABLE = 512
    WEAPON_SPEED_COST_SCALING = 1024
    NO_PARTIAL_IMMUNITY = 2048


class CastFlags(enum.Flag):
    NONE = 0
    HIDDEN_COMBATLOG = 1
    UNKNOWN2 = 2
    UNKNOWN3 = 4
    UNKNOWN4 = 8
    UNKNOWN5 = 16
    AMMO = 32
    UNKNOWN7 = 64
    UNKNOWN8 = 128
    UNKNOWN9 = 256


class ChannelFlags(enum.Flag):
    NONE = 0
    CUSTOM = 1
    TRADE = 4
    NOT_LFG = 8
    GENERAL = 16
    CITY = 32
    LFG = 64
    VOICE = 128


class ChannelMemberFlags(enum.Flag):
    NONE = 0
    OWNER = 1
    MODERATOR = 4
    VOICED = 8
    MUTED = 16
    CUSTOM = 32
    MICROPHONE_MUTE = 64


class CharacterFlags(enum.Flag):
    NONE = 0
    LOCKED_FOR_TRANSFER = 4
    HIDE_HELM = 1024
    HIDE_CLOAK = 2048
    GHOST = 8192
    RENAME = 16384


class CharacterRaceFlags(enum.Flag):
    NONE = 0
    NOT_PLAYABLE = 1
    BARE_FEET = 2
    CAN_CURRENT_FORM_MOUNT = 4
    UNKNOWN2 = 8


class DefaultChannelFlags(enum.Flag):
    NONE = 0
    INITIAL = 1
    ZONE_DEPENDENCY = 2
    GLOBAL = 4
    TRADE = 8
    CITY_ONLY = 16
    CITY_ONLY_2 = 32
    DEFENCE = 65536
    UNSELECTED = 262144


class EmoteFlags(enum.Flag):
    TALK = 8
    QUESTION = 16
    EXCLAMATION = 32
    SHOUT = 64
    LAUGH = 128


class FactionFlag(enum.Flag):
    VISIBLE = 1
    AT_WAR = 2
    HIDDEN = 4
    INVISIBLE_FORCED = 8
    PEACE_FORCED = 16
    INACTIVE = 32
    RIVAL = 64


class GroupMemberOnlineStatus(enum.Flag):
    OFFLINE = 0
    ONLINE = 1
    PVP = 2
    DEAD = 4
    GHOST = 8
    PVP_FFA = 16
    ZONE_OUT = 32
    AFK = 64
    DND = 128


class GroupUpdateFlags(enum.Flag):
    NONE = 0
    STATUS = 1
    CUR_HP = 2
    MAX_HP = 4
    POWER_TYPE = 8
    CUR_POWER = 16
    MAX_POWER = 32
    LEVEL = 64
    ZONE = 128
    POSITION = 256
    AURAS = 512
    AURAS_2 = 1024
    PET_GUID = 2048
    PET_NAME = 4096
    PET_MODEL_ID = 8192
    PET_CUR_HP = 16384
    PET_MAX_HP = 32768
    PET_POWER_TYPE = 65536
    PET_CUR_POWER = 131072
    PET_MAX_POWER = 262144
    PET_AURAS = 524288
    PET_AURAS_2 = 1048576
    MODE_OFFLINE = 268435456


class ItemFlag(enum.Flag):
    NONE = 0
    NO_PICKUP = 1
    CONJURED = 2
    LOOTABLE = 4
    DEPRECATED = 16
    INDESTRUCTIBLE = 32
    PLAYER_CAST = 64
    NO_EQUIP_COOLDOWN = 128
    INT_BONUS_INSTEAD = 256
    WRAPPER = 512
    IGNORE_BAG_SPACE = 1024
    PARTY_LOOT = 2048
    CHARTER = 8192
    HAS_TEXT = 16384
    NO_DISENCHANT = 32768
    REAL_DURATION = 65536
    NO_CREATOR = 131072


class MovementFlags(enum.Flag):
    NONE = 0
    FORWARD = 1
    BACKWARD = 2
    STRAFE_LEFT = 4
    STRAFE_RIGHT = 8
    TURN_LEFT = 16
    TURN_RIGHT = 32
    PITCH_UP = 64
    PITCH_DOWN = 128
    WALK_MODE = 256
    ON_TRANSPORT = 512
    LEVITATING = 1024
    FIXED_Z = 2048
    ROOT = 4096
    JUMPING = 8192
    FALLINGFAR = 16384
    SWIMMING = 2097152
    SPLINE_ENABLED = 4194304
    CAN_FLY = 8388608
    FLYING = 16777216
    ONTRANSPORT = 33554432
    SPLINE_ELEVATION = 67108864
    WATERWALKING = 268435456
    SAFE_FALL = 536870912
    HOVER = 1073741824


class PvpFlags(enum.Flag):
    PVP_FLAGGED = 2048
    ATTACK_PVPING_PLAYERS = 4096


class ReputationFlags(enum.Flag):
    VISIBLE_TO_CLIENT = 1
    ENABLE_AT_WAR = 2
    HIDE_IN_CLIENT = 4
    FORCE_HIDE_IN_CLIENT = 8
    FORCE_AT_PEACE = 16
    FACTION_INACTIVE = 32


class SpellCastTargetFlags(enum.Flag):
    SELF = 0
    UNUSED1 = 1
    UNIT = 2
    UNUSED2 = 4
    UNUSED3 = 8
    ITEM = 16
    SOURCE_LOCATION = 32
    DEST_LOCATION = 64
    OBJECT_UNK = 128
    UNIT_UNK = 256
    PVP_CORPSE = 512
    UNIT_CORPSE = 1024
    GAMEOBJECT = 2048
    TRADE_ITEM = 4096
    STRING = 8192
    UNK1 = 16384
    CORPSE = 32768


class SplineFlag(enum.Flag):
    NONE = 0
    DONE = 1
    FALLING = 2
    UNKNOWN3 = 4
    UNKNOWN4 = 8
    UNKNOWN5 = 16
    UNKNOWN6 = 32
    UNKNOWN7 = 64
    UNKNOWN8 = 128
    RUN_MODE = 256
    FLYING = 512
    NO_SPLINE = 1024
    UNKNOWN12 = 2048
    UNKNOWN13 = 4096
    UNKNOWN14 = 8192
    UNKNOWN15 = 16384
    UNKNOWN16 = 32768
    FINAL_POINT = 65536
    FINAL_TARGET = 131072
    FINAL_ANGLE = 262144
    UNKNOWN19 = 524288
    CYCLIC = 1048576
    ENTER_CYCLE = 2097152
    FROZEN = 4194304
    UNKNOWN23 = 8388608
    UNKNOWN24 = 16777216
    UNKNOWN25 = 33554432
    UNKNOWN26 = 67108864
    UNKNOWN27 = 134217728
    UNKNOWN28 = 268435456
    UNKNOWN29 = 536870912
    UNKNOWN30 = 1073741824
    UNKNOWN31 = 2147483648


class UpdateFlag(enum.Flag):
    NONE = 0
    SELF = 1
    TRANSPORT = 2
    MELEE_ATTACKING = 4
    HIGH_GUID = 8
    ALL = 16
    LIVING = 32
    HAS_POSITION = 64


class WeaponFlags(enum.Flag):
    WEAPON_NOT_AFFECTED_BY_ANIMATION = 0
    SHEATHE_WEAPONS_AUTOMATICALLY = 4
    SHEATHE_WEAPONS_AUTOMATICALLY_2 = 16
    UNSHEATHE_WEAPONS = 32


@dataclasses.dataclass
class Addon:
    addon_type: AddonType
    info_block: InfoBlock
    url_info: UrlInfo
    key_version: typing.Optional[KeyVersion] = None
    public_key: typing.Optional[typing.List[int]] = None
    update_available_flag: typing.Optional[int] = None
    url: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Addon:
        key_version = None
        public_key = None
        update_available_flag = None
        url = None
        # addon_type: AddonType
        addon_type = AddonType(await read_int(reader, 1))

        # info_block: InfoBlock
        info_block = InfoBlock(await read_int(reader, 1))

        if info_block == InfoBlock.AVAILABLE:
            # key_version: KeyVersion
            key_version = KeyVersion(await read_int(reader, 1))

            if key_version in {KeyVersion.ONE, KeyVersion.TWO, KeyVersion.THREE, KeyVersion.FOUR, KeyVersion.FIVE, KeyVersion.SIX, KeyVersion.SEVEN, KeyVersion.EIGHT, KeyVersion.NINE}:
                # public_key: u8[256]
                public_key = []
                for _ in range(0, 256):
                    public_key.append(await read_int(reader, 1))

            # update_available_flag: u32
            update_available_flag = await read_int(reader, 4)

        # url_info: UrlInfo
        url_info = UrlInfo(await read_int(reader, 1))

        if url_info == UrlInfo.AVAILABLE:
            # url: CString
            url = await read_cstring(reader)

        return Addon(
            addon_type=addon_type,
            info_block=info_block,
            key_version=key_version,
            public_key=public_key,
            update_available_flag=update_available_flag,
            url_info=url_info,
            url=url,
        )

    def write(self, _fmt, _data):
        _fmt += 'BB'
        _data.extend([self.addon_type.value, self.info_block.value])
        if self.info_block == InfoBlock.AVAILABLE:
            _fmt += 'B'
            _data.append(self.key_version.value)
            if self.key_version in {KeyVersion.ONE, KeyVersion.TWO, KeyVersion.THREE, KeyVersion.FOUR, KeyVersion.FIVE, KeyVersion.SIX, KeyVersion.SEVEN, KeyVersion.EIGHT, KeyVersion.NINE}:
                _fmt += f'{len(self.public_key)}B'
                _data.extend([*self.public_key])
            # update_available_flag: u32
            _fmt += 'I'
            _data.append(self.update_available_flag)

        # url_info: UrlInfo
        _fmt += 'B'
        _data.append(self.url_info.value)

        if self.url_info == UrlInfo.AVAILABLE:
            _fmt += f'{len(self.url)}sB'
            _data.extend([self.url.encode('utf-8'), 0])
        return _fmt, _data

    def size(self) -> int:
        _size = 3

        if self.info_block == InfoBlock.AVAILABLE:
            _size += 5

            if self.key_version in {KeyVersion.ONE, KeyVersion.TWO, KeyVersion.THREE, KeyVersion.FOUR, KeyVersion.FIVE, KeyVersion.SIX, KeyVersion.SEVEN, KeyVersion.EIGHT, KeyVersion.NINE}:
                _size += 256


        if self.url_info == UrlInfo.AVAILABLE:
            _size += 1 + len(self.url)

        return _size


@dataclasses.dataclass
class AddonInfo:
    addon_name: str
    addon_has_signature: int
    addon_crc: int
    addon_extra_crc: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> AddonInfo:
        # addon_name: CString
        addon_name = await read_cstring(reader)

        # addon_has_signature: u8
        addon_has_signature = await read_int(reader, 1)

        # addon_crc: u32
        addon_crc = await read_int(reader, 4)

        # addon_extra_crc: u32
        addon_extra_crc = await read_int(reader, 4)

        return AddonInfo(
            addon_name=addon_name,
            addon_has_signature=addon_has_signature,
            addon_crc=addon_crc,
            addon_extra_crc=addon_extra_crc,
        )

    def write(self, _fmt, _data):
        _fmt += f'{len(self.addon_name)}sBBII'
        _data.extend([self.addon_name.encode('utf-8'), 0, self.addon_has_signature, self.addon_crc, self.addon_extra_crc])
        return _fmt, _data

    def size(self) -> int:
        return 10 + len(self.addon_name)


@dataclasses.dataclass
class AuctionListItem:
    id: int
    item: int
    item_enchantment: int
    item_random_property_id: int
    item_suffix_factor: int
    item_count: int
    item_charges: int
    item_owner: int
    start_bid: int
    minimum_bid: int
    buyout_amount: int
    time_left: int
    highest_bidder: int
    highest_bid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> AuctionListItem:
        # id: u32
        id = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        # item_enchantment: u32
        item_enchantment = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # item_suffix_factor: u32
        item_suffix_factor = await read_int(reader, 4)

        # item_count: u32
        item_count = await read_int(reader, 4)

        # item_charges: u32
        item_charges = await read_int(reader, 4)

        # item_owner: Guid
        item_owner = await read_int(reader, 8)

        # start_bid: u32
        start_bid = await read_int(reader, 4)

        # minimum_bid: u32
        minimum_bid = await read_int(reader, 4)

        # buyout_amount: u32
        buyout_amount = await read_int(reader, 4)

        # time_left: Milliseconds
        time_left = await read_int(reader, 4)

        # highest_bidder: Guid
        highest_bidder = await read_int(reader, 8)

        # highest_bid: u32
        highest_bid = await read_int(reader, 4)

        return AuctionListItem(
            id=id,
            item=item,
            item_enchantment=item_enchantment,
            item_random_property_id=item_random_property_id,
            item_suffix_factor=item_suffix_factor,
            item_count=item_count,
            item_charges=item_charges,
            item_owner=item_owner,
            start_bid=start_bid,
            minimum_bid=minimum_bid,
            buyout_amount=buyout_amount,
            time_left=time_left,
            highest_bidder=highest_bidder,
            highest_bid=highest_bid,
        )

    def write(self, _fmt, _data):
        _fmt += 'IIIIIIIQIIIIQI'
        _data.extend([self.id, self.item, self.item_enchantment, self.item_random_property_id, self.item_suffix_factor, self.item_count, self.item_charges, self.item_owner, self.start_bid, self.minimum_bid, self.buyout_amount, self.time_left, self.highest_bidder, self.highest_bid])
        return _fmt, _data


@dataclasses.dataclass
class AuraLog:
    aura_type: AuraType
    damage1: typing.Optional[int] = None
    school: typing.Optional[SpellSchool] = None
    absorbed: typing.Optional[int] = None
    resisted: typing.Optional[int] = None
    damage2: typing.Optional[int] = None
    misc_value1: typing.Optional[int] = None
    damage3: typing.Optional[int] = None
    misc_value2: typing.Optional[int] = None
    damage: typing.Optional[int] = None
    gain_multiplier: typing.Optional[float] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> AuraLog:
        damage1 = None
        school = None
        absorbed = None
        resisted = None
        damage2 = None
        misc_value1 = None
        damage3 = None
        misc_value2 = None
        damage = None
        gain_multiplier = None
        # aura_type: AuraType
        aura_type = AuraType(await read_int(reader, 4))

        if aura_type in {AuraType.PERIODIC_DAMAGE, AuraType.PERIODIC_DAMAGE_PERCENT}:
            # damage1: u32
            damage1 = await read_int(reader, 4)

            # school: SpellSchool
            school = SpellSchool(await read_int(reader, 1))

            # absorbed: u32
            absorbed = await read_int(reader, 4)

            # resisted: u32
            resisted = await read_int(reader, 4)

        elif aura_type in {AuraType.PERIODIC_HEAL, AuraType.OBS_MOD_HEALTH}:
            # damage2: u32
            damage2 = await read_int(reader, 4)

        elif aura_type in {AuraType.OBS_MOD_MANA, AuraType.PERIODIC_ENERGIZE}:
            # misc_value1: u32
            misc_value1 = await read_int(reader, 4)

            # damage3: u32
            damage3 = await read_int(reader, 4)

        elif aura_type == AuraType.PERIODIC_MANA_LEECH:
            # misc_value2: u32
            misc_value2 = await read_int(reader, 4)

            # damage: u32
            damage = await read_int(reader, 4)

            # gain_multiplier: f32
            gain_multiplier = await read_float(reader)

        return AuraLog(
            aura_type=aura_type,
            damage1=damage1,
            school=school,
            absorbed=absorbed,
            resisted=resisted,
            damage2=damage2,
            misc_value1=misc_value1,
            damage3=damage3,
            misc_value2=misc_value2,
            damage=damage,
            gain_multiplier=gain_multiplier,
        )

    def write(self, _fmt, _data):
        _fmt += 'I'
        _data.append(self.aura_type.value)
        if self.aura_type in {AuraType.PERIODIC_DAMAGE, AuraType.PERIODIC_DAMAGE_PERCENT}:
            _fmt += 'IBII'
            _data.extend([self.damage1, self.school.value, self.absorbed, self.resisted])
        elif self.aura_type in {AuraType.PERIODIC_HEAL, AuraType.OBS_MOD_HEALTH}:
            _fmt += 'I'
            _data.append(self.damage2)
        elif self.aura_type in {AuraType.OBS_MOD_MANA, AuraType.PERIODIC_ENERGIZE}:
            _fmt += 'II'
            _data.extend([self.misc_value1, self.damage3])
        elif self.aura_type == AuraType.PERIODIC_MANA_LEECH:
            _fmt += 'IIf'
            _data.extend([self.misc_value2, self.damage, self.gain_multiplier])
        return _fmt, _data

    def size(self) -> int:
        _size = 4

        if self.aura_type in {AuraType.PERIODIC_DAMAGE, AuraType.PERIODIC_DAMAGE_PERCENT}:
            _size += 13
        elif self.aura_type in {AuraType.PERIODIC_HEAL, AuraType.OBS_MOD_HEALTH}:
            _size += 4
        elif self.aura_type in {AuraType.OBS_MOD_MANA, AuraType.PERIODIC_ENERGIZE}:
            _size += 8
        elif self.aura_type == AuraType.PERIODIC_MANA_LEECH:
            _size += 12

        return _size


@dataclasses.dataclass
class BattlegroundPlayer:
    player: int
    rank: PvpRank
    killing_blows: int
    honorable_kills: int
    deaths: int
    bonus_honor: int
    fields: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> BattlegroundPlayer:
        # player: Guid
        player = await read_int(reader, 8)

        # rank: PvpRank
        rank = PvpRank(await read_int(reader, 4))

        # killing_blows: u32
        killing_blows = await read_int(reader, 4)

        # honorable_kills: u32
        honorable_kills = await read_int(reader, 4)

        # deaths: u32
        deaths = await read_int(reader, 4)

        # bonus_honor: u32
        bonus_honor = await read_int(reader, 4)

        # amount_of_extra_fields: u32
        amount_of_extra_fields = await read_int(reader, 4)

        # fields: u32[amount_of_extra_fields]
        fields = []
        for _ in range(0, amount_of_extra_fields):
            fields.append(await read_int(reader, 4))

        return BattlegroundPlayer(
            player=player,
            rank=rank,
            killing_blows=killing_blows,
            honorable_kills=honorable_kills,
            deaths=deaths,
            bonus_honor=bonus_honor,
            fields=fields,
        )

    def write(self, _fmt, _data):
        _fmt += f'QIIIIII{len(self.fields)}I'
        _data.extend([self.player, self.rank.value, self.killing_blows, self.honorable_kills, self.deaths, self.bonus_honor, len(self.fields), *self.fields])
        return _fmt, _data

    def size(self) -> int:
        return 32 + 4 * len(self.fields)


@dataclasses.dataclass
class BattlegroundPlayerPosition:
    player: int
    position_x: float
    position_y: float

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> BattlegroundPlayerPosition:
        # player: Guid
        player = await read_int(reader, 8)

        # position_x: f32
        position_x = await read_float(reader)

        # position_y: f32
        position_y = await read_float(reader)

        return BattlegroundPlayerPosition(
            player=player,
            position_x=position_x,
            position_y=position_y,
        )

    def write(self, _fmt, _data):
        _fmt += 'Qff'
        _data.extend([self.player, self.position_x, self.position_y])
        return _fmt, _data


@dataclasses.dataclass
class ChannelMember:
    guid: int
    member_flags: ChannelMemberFlags

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ChannelMember:
        # guid: Guid
        guid = await read_int(reader, 8)

        # member_flags: ChannelMemberFlags
        member_flags = ChannelMemberFlags(await read_int(reader, 1))

        return ChannelMember(
            guid=guid,
            member_flags=member_flags,
        )

    def write(self, _fmt, _data):
        _fmt += 'QB'
        _data.extend([self.guid, self.member_flags.value])
        return _fmt, _data


@dataclasses.dataclass
class Vector3d:
    x: float
    y: float
    z: float

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Vector3d:
        # x: f32
        x = await read_float(reader)

        # y: f32
        y = await read_float(reader)

        # z: f32
        z = await read_float(reader)

        return Vector3d(
            x=x,
            y=y,
            z=z,
        )

    def write(self, _fmt, _data):
        _fmt += 'fff'
        _data.extend([self.x, self.y, self.z])
        return _fmt, _data


@dataclasses.dataclass
class MonsterMoveSpline:
    splines: list[Vector3d]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        def packed_to_vec(packed: int) -> Vector3d:
            x = float(packed & 0x7FF) / 4
            y = float((packed >> 11) & 0x7FF) / 4
            z = float((packed >> 22) & 0x3FF) / 4
            return Vector3d(x=x, y=y, z=z)

        amount_of_splines = await read_int(reader, 4)

        if amount_of_splines == 0:
            return MonsterMoveSpline(splines=[])

        splines = [await Vector3d.read(reader)]

        for i in range(1, amount_of_splines): # subtract the 'real' one
            packed = await read_int(reader, 4)
            splines.append(packed_to_vec(packed))

        return MonsterMoveSpline(splines=splines)

    def write(self, fmt, data):
        def vec_to_packed(vec: Vector3d) -> int:
            packed = 0
            packed |= int(vec.x / 0.25) & 0x7FF
            packed |= (int(vec.y / 0.25) & 0x7FF) << 11
            packed |= (int(vec.z / 0.25) & 0x3FF) << 22
            return packed
        amount_of_splines = len(self.splines)
        fmt += 'I'
        data.append(amount_of_splines)

        if amount_of_splines == 0:
            return fmt, data

        fmt, data = self.splines[0].write(fmt, data)

        for i in range(1, amount_of_splines):
            packed = vec_to_packed(self.splines[i])
            fmt += 'I'
            data.append(packed)

        return fmt, data

    def size(self):
        if len(self.splines) == 0:
            return 4

        return 4 + 3 * 4 + (len(self.splines) - 1) * 4


@dataclasses.dataclass
class CharacterGear:
    equipment_display_id: int
    inventory_type: InventoryType

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> CharacterGear:
        # equipment_display_id: u32
        equipment_display_id = await read_int(reader, 4)

        # inventory_type: InventoryType
        inventory_type = InventoryType(await read_int(reader, 1))

        return CharacterGear(
            equipment_display_id=equipment_display_id,
            inventory_type=inventory_type,
        )

    def write(self, _fmt, _data):
        _fmt += 'IB'
        _data.extend([self.equipment_display_id, self.inventory_type.value])
        return _fmt, _data


@dataclasses.dataclass
class Character:
    guid: int
    name: str
    race: Race
    class_type: Class
    gender: Gender
    skin: int
    face: int
    hair_style: int
    hair_color: int
    facial_hair: int
    level: int
    area: Area
    map: Map
    position: Vector3d
    guild_id: int
    flags: CharacterFlags
    first_login: bool
    pet_display_id: int
    pet_level: int
    pet_family: CreatureFamily
    equipment: typing.List[CharacterGear]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Character:
        # guid: Guid
        guid = await read_int(reader, 8)

        # name: CString
        name = await read_cstring(reader)

        # race: Race
        race = Race(await read_int(reader, 1))

        # class_type: Class
        class_type = Class(await read_int(reader, 1))

        # gender: Gender
        gender = Gender(await read_int(reader, 1))

        # skin: u8
        skin = await read_int(reader, 1)

        # face: u8
        face = await read_int(reader, 1)

        # hair_style: u8
        hair_style = await read_int(reader, 1)

        # hair_color: u8
        hair_color = await read_int(reader, 1)

        # facial_hair: u8
        facial_hair = await read_int(reader, 1)

        # level: Level
        level = await read_int(reader, 1)

        # area: Area
        area = Area(await read_int(reader, 4))

        # map: Map
        map = Map(await read_int(reader, 4))

        # position: Vector3d
        position = await Vector3d.read(reader)

        # guild_id: u32
        guild_id = await read_int(reader, 4)

        # flags: CharacterFlags
        flags = CharacterFlags(await read_int(reader, 4))

        # first_login: Bool8
        first_login = await read_bool(reader, 1)

        # pet_display_id: u32
        pet_display_id = await read_int(reader, 4)

        # pet_level: Level32
        pet_level = await read_int(reader, 4)

        # pet_family: CreatureFamily
        pet_family = CreatureFamily(await read_int(reader, 4))

        # equipment: CharacterGear[19]
        equipment = []
        for _ in range(0, 19):
            equipment.append(await CharacterGear.read(reader))

        # first_bag_display_id: u32
        _first_bag_display_id = await read_int(reader, 4)

        # first_bag_inventory_id: u8
        _first_bag_inventory_id = await read_int(reader, 1)

        return Character(
            guid=guid,
            name=name,
            race=race,
            class_type=class_type,
            gender=gender,
            skin=skin,
            face=face,
            hair_style=hair_style,
            hair_color=hair_color,
            facial_hair=facial_hair,
            level=level,
            area=area,
            map=map,
            position=position,
            guild_id=guild_id,
            flags=flags,
            first_login=first_login,
            pet_display_id=pet_display_id,
            pet_level=pet_level,
            pet_family=pet_family,
            equipment=equipment,
        )

    def write(self, _fmt, _data):
        _fmt += f'Q{len(self.name)}sBBBBBBBBBBII'
        _data.extend([self.guid, self.name.encode('utf-8'), 0, self.race.value, self.class_type.value, self.gender.value, self.skin, self.face, self.hair_style, self.hair_color, self.facial_hair, self.level, self.area.value, self.map.value])
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # guild_id: u32
        _fmt += 'I'
        _data.append(self.guild_id)

        # flags: CharacterFlags
        _fmt += 'I'
        _data.append(self.flags.value)

        # first_login: Bool8
        _fmt += 'B'
        _data.append(self.first_login)

        # pet_display_id: u32
        _fmt += 'I'
        _data.append(self.pet_display_id)

        # pet_level: Level32
        _fmt += 'I'
        _data.append(self.pet_level)

        # pet_family: CreatureFamily
        _fmt += 'I'
        _data.append(self.pet_family.value)

        # equipment: CharacterGear[19]
        for i in self.equipment:
            _fmt, _data = i.write(_fmt, _data)

        # first_bag_display_id: u32
        _fmt += 'I'
        _data.append(0)

        # first_bag_inventory_id: u8
        _fmt += 'B'
        _data.append(0)

        return _fmt, _data

    def size(self) -> int:
        return 159 + len(self.name)


@dataclasses.dataclass
class MonsterMove:
    spline_point: Vector3d
    spline_id: int
    move_type: MonsterMoveType
    target: typing.Optional[int] = None
    angle: typing.Optional[float] = None
    position: typing.Optional[Vector3d] = None
    spline_flags: typing.Optional[SplineFlag] = None
    duration: typing.Optional[int] = None
    splines: typing.Optional[MonsterMoveSpline] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> MonsterMove:
        target = None
        angle = None
        position = None
        spline_flags = None
        duration = None
        splines = None
        # spline_point: Vector3d
        spline_point = await Vector3d.read(reader)

        # spline_id: u32
        spline_id = await read_int(reader, 4)

        # move_type: MonsterMoveType
        move_type = MonsterMoveType(await read_int(reader, 1))

        if move_type == MonsterMoveType.FACING_TARGET:
            # target: Guid
            target = await read_int(reader, 8)

        elif move_type == MonsterMoveType.FACING_ANGLE:
            # angle: f32
            angle = await read_float(reader)

        elif move_type == MonsterMoveType.FACING_SPOT:
            # position: Vector3d
            position = await Vector3d.read(reader)

        if move_type in {MonsterMoveType.NORMAL, MonsterMoveType.FACING_SPOT, MonsterMoveType.FACING_TARGET, MonsterMoveType.FACING_ANGLE}:
            # spline_flags: SplineFlag
            spline_flags = SplineFlag(await read_int(reader, 4))

            # duration: u32
            duration = await read_int(reader, 4)

            # splines: MonsterMoveSpline
            splines = await MonsterMoveSpline.read(reader)

        return MonsterMove(
            spline_point=spline_point,
            spline_id=spline_id,
            move_type=move_type,
            target=target,
            angle=angle,
            position=position,
            spline_flags=spline_flags,
            duration=duration,
            splines=splines,
        )

    def write(self, _fmt, _data):
        # spline_point: Vector3d
        _fmt, _data = self.spline_point.write(_fmt, _data)

        # spline_id: u32
        _fmt += 'I'
        _data.append(self.spline_id)

        # move_type: MonsterMoveType
        _fmt += 'B'
        _data.append(self.move_type.value)

        if self.move_type == MonsterMoveType.FACING_TARGET:
            _fmt += 'Q'
            _data.append(self.target)
        elif self.move_type == MonsterMoveType.FACING_ANGLE:
            _fmt += 'f'
            _data.append(self.angle)
        elif self.move_type == MonsterMoveType.FACING_SPOT:
            # position: Vector3d
            _fmt, _data = self.position.write(_fmt, _data)

        if self.move_type in {MonsterMoveType.NORMAL, MonsterMoveType.FACING_SPOT, MonsterMoveType.FACING_TARGET, MonsterMoveType.FACING_ANGLE}:
            _fmt += 'II'
            _data.extend([self.spline_flags.value, self.duration])
            # splines: MonsterMoveSpline
            _fmt, _data = self.splines.write(_fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        _size = 17

        if self.move_type == MonsterMoveType.FACING_TARGET:
            _size += 8
        elif self.move_type == MonsterMoveType.FACING_ANGLE:
            _size += 4
        elif self.move_type == MonsterMoveType.FACING_SPOT:
            _size += 12

        if self.move_type in {MonsterMoveType.NORMAL, MonsterMoveType.FACING_SPOT, MonsterMoveType.FACING_TARGET, MonsterMoveType.FACING_ANGLE}:
            _size += 8 + self.splines.size()

        return _size


@dataclasses.dataclass
class CompressedMove:
    opcode: CompressedMoveOpcode
    guid: int
    speed: typing.Optional[float] = None
    monster_move: typing.Optional[MonsterMove] = None
    transport: typing.Optional[int] = None
    monster_move_transport: typing.Optional[MonsterMove] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> CompressedMove:
        speed = None
        monster_move = None
        transport = None
        monster_move_transport = None
        # size: u8
        _size = await read_int(reader, 1)

        # opcode: CompressedMoveOpcode
        opcode = CompressedMoveOpcode(await read_int(reader, 2))

        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        if opcode == CompressedMoveOpcode.SMSG_SPLINE_SET_RUN_SPEED:
            # speed: f32
            speed = await read_float(reader)

        elif opcode == CompressedMoveOpcode.SMSG_MONSTER_MOVE:
            # monster_move: MonsterMove
            monster_move = await MonsterMove.read(reader)

        elif opcode == CompressedMoveOpcode.SMSG_MONSTER_MOVE_TRANSPORT:
            # transport: PackedGuid
            transport = await read_packed_guid(reader)

            # monster_move_transport: MonsterMove
            monster_move_transport = await MonsterMove.read(reader)

        return CompressedMove(
            opcode=opcode,
            guid=guid,
            speed=speed,
            monster_move=monster_move,
            transport=transport,
            monster_move_transport=monster_move_transport,
        )

    def write(self, _fmt, _data):
        _fmt += 'BH'
        _data.extend([self.size(), self.opcode.value])
        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        if self.opcode == CompressedMoveOpcode.SMSG_SPLINE_SET_RUN_SPEED:
            _fmt += 'f'
            _data.append(self.speed)
        elif self.opcode == CompressedMoveOpcode.SMSG_MONSTER_MOVE:
            # monster_move: MonsterMove
            _fmt, _data = self.monster_move.write(_fmt, _data)

        elif self.opcode == CompressedMoveOpcode.SMSG_MONSTER_MOVE_TRANSPORT:
            # transport: PackedGuid
            _fmt, _data = packed_guid_write(self.transport, _fmt, _data)

            # monster_move_transport: MonsterMove
            _fmt, _data = self.monster_move_transport.write(_fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        _size = 3 + packed_guid_size(self.guid)

        if self.opcode == CompressedMoveOpcode.SMSG_SPLINE_SET_RUN_SPEED:
            _size += 4
        elif self.opcode == CompressedMoveOpcode.SMSG_MONSTER_MOVE:
            _size += 0 + self.monster_move.size()
        elif self.opcode == CompressedMoveOpcode.SMSG_MONSTER_MOVE_TRANSPORT:
            _size += 0 + packed_guid_size(self.transport) + self.monster_move_transport.size()

        return _size


@dataclasses.dataclass
class CooldownSpell:
    spell_id: int
    item_id: int
    spell_category: int
    cooldown: int
    category_cooldown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> CooldownSpell:
        # spell_id: u16
        spell_id = await read_int(reader, 2)

        # item_id: u16
        item_id = await read_int(reader, 2)

        # spell_category: u16
        spell_category = await read_int(reader, 2)

        # cooldown: Milliseconds
        cooldown = await read_int(reader, 4)

        # category_cooldown: Milliseconds
        category_cooldown = await read_int(reader, 4)

        return CooldownSpell(
            spell_id=spell_id,
            item_id=item_id,
            spell_category=spell_category,
            cooldown=cooldown,
            category_cooldown=category_cooldown,
        )

    def write(self, _fmt, _data):
        _fmt += 'HHHII'
        _data.extend([self.spell_id, self.item_id, self.spell_category, self.cooldown, self.category_cooldown])
        return _fmt, _data


@dataclasses.dataclass
class DamageInfo:
    spell_school_mask: int
    damage_float: float
    damage_uint: int
    absorb: int
    resist: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> DamageInfo:
        # spell_school_mask: u32
        spell_school_mask = await read_int(reader, 4)

        # damage_float: f32
        damage_float = await read_float(reader)

        # damage_uint: u32
        damage_uint = await read_int(reader, 4)

        # absorb: u32
        absorb = await read_int(reader, 4)

        # resist: u32
        resist = await read_int(reader, 4)

        return DamageInfo(
            spell_school_mask=spell_school_mask,
            damage_float=damage_float,
            damage_uint=damage_uint,
            absorb=absorb,
            resist=resist,
        )

    def write(self, _fmt, _data):
        _fmt += 'IfIII'
        _data.extend([self.spell_school_mask, self.damage_float, self.damage_uint, self.absorb, self.resist])
        return _fmt, _data


@dataclasses.dataclass
class FactionInitializer:
    flag: FactionFlag
    standing: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> FactionInitializer:
        # flag: FactionFlag
        flag = FactionFlag(await read_int(reader, 1))

        # standing: u32
        standing = await read_int(reader, 4)

        return FactionInitializer(
            flag=flag,
            standing=standing,
        )

    def write(self, _fmt, _data):
        _fmt += 'BI'
        _data.extend([self.flag.value, self.standing])
        return _fmt, _data


@dataclasses.dataclass
class FactionStanding:
    faction: Faction
    standing: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> FactionStanding:
        # faction: Faction
        faction = Faction(await read_int(reader, 2))

        # standing: u32
        standing = await read_int(reader, 4)

        return FactionStanding(
            faction=faction,
            standing=standing,
        )

    def write(self, _fmt, _data):
        _fmt += 'HI'
        _data.extend([self.faction.value, self.standing])
        return _fmt, _data


@dataclasses.dataclass
class ForcedReaction:
    faction: Faction
    reputation_rank: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ForcedReaction:
        # faction: Faction
        faction = Faction(await read_int(reader, 2))

        # reputation_rank: u32
        reputation_rank = await read_int(reader, 4)

        return ForcedReaction(
            faction=faction,
            reputation_rank=reputation_rank,
        )

    def write(self, _fmt, _data):
        _fmt += 'HI'
        _data.extend([self.faction.value, self.reputation_rank])
        return _fmt, _data


@dataclasses.dataclass
class Friend:
    guid: int
    status: FriendStatus
    area: typing.Optional[Area] = None
    level: typing.Optional[int] = None
    class_type: typing.Optional[Class] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Friend:
        area = None
        level = None
        class_type = None
        # guid: Guid
        guid = await read_int(reader, 8)

        # status: FriendStatus
        status = FriendStatus(await read_int(reader, 1))

        if status in {FriendStatus.ONLINE, FriendStatus.AFK, FriendStatus.UNKNOWN3, FriendStatus.DND}:
            # area: Area
            area = Area(await read_int(reader, 4))

            # level: Level32
            level = await read_int(reader, 4)

            # class_type: Class
            class_type = Class(await read_int(reader, 4))

        return Friend(
            guid=guid,
            status=status,
            area=area,
            level=level,
            class_type=class_type,
        )

    def write(self, _fmt, _data):
        _fmt += 'QB'
        _data.extend([self.guid, self.status.value])
        if self.status in {FriendStatus.ONLINE, FriendStatus.AFK, FriendStatus.UNKNOWN3, FriendStatus.DND}:
            _fmt += 'III'
            _data.extend([self.area.value, self.level, self.class_type.value])
        return _fmt, _data

    def size(self) -> int:
        _size = 9

        if self.status in {FriendStatus.ONLINE, FriendStatus.AFK, FriendStatus.UNKNOWN3, FriendStatus.DND}:
            _size += 12

        return _size


@dataclasses.dataclass
class GmSurveyQuestion:
    question_id: int
    answer: int
    comment: str

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GmSurveyQuestion:
        # question_id: u32
        question_id = await read_int(reader, 4)

        # answer: u8
        answer = await read_int(reader, 1)

        # comment: CString
        comment = await read_cstring(reader)

        return GmSurveyQuestion(
            question_id=question_id,
            answer=answer,
            comment=comment,
        )

    def write(self, _fmt, _data):
        _fmt += f'IB{len(self.comment)}sB'
        _data.extend([self.question_id, self.answer, self.comment.encode('utf-8'), 0])
        return _fmt, _data

    def size(self) -> int:
        return 6 + len(self.comment)


@dataclasses.dataclass
class GossipItem:
    id: int
    item_icon: int
    coded: bool
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GossipItem:
        # id: u32
        id = await read_int(reader, 4)

        # item_icon: u8
        item_icon = await read_int(reader, 1)

        # coded: Bool8
        coded = await read_bool(reader, 1)

        # message: CString
        message = await read_cstring(reader)

        return GossipItem(
            id=id,
            item_icon=item_icon,
            coded=coded,
            message=message,
        )

    def write(self, _fmt, _data):
        _fmt += f'IBB{len(self.message)}sB'
        _data.extend([self.id, self.item_icon, self.coded, self.message.encode('utf-8'), 0])
        return _fmt, _data

    def size(self) -> int:
        return 7 + len(self.message)


@dataclasses.dataclass
class GroupListMember:
    name: str
    guid: int
    is_online: bool
    flags: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GroupListMember:
        # name: CString
        name = await read_cstring(reader)

        # guid: Guid
        guid = await read_int(reader, 8)

        # is_online: Bool8
        is_online = await read_bool(reader, 1)

        # flags: u8
        flags = await read_int(reader, 1)

        return GroupListMember(
            name=name,
            guid=guid,
            is_online=is_online,
            flags=flags,
        )

    def write(self, _fmt, _data):
        _fmt += f'{len(self.name)}sBQBB'
        _data.extend([self.name.encode('utf-8'), 0, self.guid, self.is_online, self.flags])
        return _fmt, _data

    def size(self) -> int:
        return 11 + len(self.name)


@dataclasses.dataclass
class GuildMember:
    guid: int
    status: GuildMemberStatus
    name: str
    rank: int
    level: int
    class_type: Class
    area: Area
    public_note: str
    officer_note: str
    time_offline: typing.Optional[float] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> GuildMember:
        time_offline = None
        # guid: Guid
        guid = await read_int(reader, 8)

        # status: GuildMemberStatus
        status = GuildMemberStatus(await read_int(reader, 1))

        # name: CString
        name = await read_cstring(reader)

        # rank: u32
        rank = await read_int(reader, 4)

        # level: Level
        level = await read_int(reader, 1)

        # class_type: Class
        class_type = Class(await read_int(reader, 1))

        # area: Area
        area = Area(await read_int(reader, 4))

        if status == GuildMemberStatus.OFFLINE:
            # time_offline: f32
            time_offline = await read_float(reader)

        # public_note: CString
        public_note = await read_cstring(reader)

        # officer_note: CString
        officer_note = await read_cstring(reader)

        return GuildMember(
            guid=guid,
            status=status,
            name=name,
            rank=rank,
            level=level,
            class_type=class_type,
            area=area,
            time_offline=time_offline,
            public_note=public_note,
            officer_note=officer_note,
        )

    def write(self, _fmt, _data):
        _fmt += f'QB{len(self.name)}sBIBBI'
        _data.extend([self.guid, self.status.value, self.name.encode('utf-8'), 0, self.rank, self.level, self.class_type.value, self.area.value])
        if self.status == GuildMemberStatus.OFFLINE:
            _fmt += 'f'
            _data.append(self.time_offline)
        # public_note: CString
        _fmt += f'{len(self.public_note)}sB'
        _data.extend([self.public_note.encode('utf-8'), 0])

        # officer_note: CString
        _fmt += f'{len(self.officer_note)}sB'
        _data.extend([self.officer_note.encode('utf-8'), 0])

        return _fmt, _data

    def size(self) -> int:
        _size = 22 + len(self.name) + len(self.public_note) + len(self.officer_note)

        if self.status == GuildMemberStatus.OFFLINE:
            _size += 4

        return _size


@dataclasses.dataclass
class InitialSpell:
    spell_id: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> InitialSpell:
        # spell_id: u16
        spell_id = await read_int(reader, 2)

        # unknown1: u16
        unknown1 = await read_int(reader, 2)

        return InitialSpell(
            spell_id=spell_id,
            unknown1=unknown1,
        )

    def write(self, _fmt, _data):
        _fmt += 'HH'
        _data.extend([self.spell_id, self.unknown1])
        return _fmt, _data


@dataclasses.dataclass
class ItemDamageType:
    damage_minimum: float
    damage_maximum: float
    school: SpellSchool

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ItemDamageType:
        # damage_minimum: f32
        damage_minimum = await read_float(reader)

        # damage_maximum: f32
        damage_maximum = await read_float(reader)

        # school: SpellSchool
        school = SpellSchool(await read_int(reader, 4))

        return ItemDamageType(
            damage_minimum=damage_minimum,
            damage_maximum=damage_maximum,
            school=school,
        )

    def write(self, _fmt, _data):
        _fmt += 'ffI'
        _data.extend([self.damage_minimum, self.damage_maximum, self.school.value])
        return _fmt, _data


@dataclasses.dataclass
class ItemSpells:
    spell: int
    spell_trigger: SpellTriggerType
    spell_charges: int
    spell_cooldown: int
    spell_category: int
    spell_category_cooldown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ItemSpells:
        # spell: Spell
        spell = await read_int(reader, 4)

        # spell_trigger: SpellTriggerType
        spell_trigger = SpellTriggerType(await read_int(reader, 4))

        # spell_charges: i32
        spell_charges = await read_int(reader, 4)

        # spell_cooldown: i32
        spell_cooldown = await read_int(reader, 4)

        # spell_category: u32
        spell_category = await read_int(reader, 4)

        # spell_category_cooldown: i32
        spell_category_cooldown = await read_int(reader, 4)

        return ItemSpells(
            spell=spell,
            spell_trigger=spell_trigger,
            spell_charges=spell_charges,
            spell_cooldown=spell_cooldown,
            spell_category=spell_category,
            spell_category_cooldown=spell_category_cooldown,
        )

    def write(self, _fmt, _data):
        _fmt += 'IIiiIi'
        _data.extend([self.spell, self.spell_trigger.value, self.spell_charges, self.spell_cooldown, self.spell_category, self.spell_category_cooldown])
        return _fmt, _data


@dataclasses.dataclass
class ItemStat:
    stat_type: ItemStatType
    value: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ItemStat:
        # stat_type: ItemStatType
        stat_type = ItemStatType(await read_int(reader, 4))

        # value: i32
        value = await read_int(reader, 4)

        return ItemStat(
            stat_type=stat_type,
            value=value,
        )

    def write(self, _fmt, _data):
        _fmt += 'Ii'
        _data.extend([self.stat_type.value, self.value])
        return _fmt, _data


@dataclasses.dataclass
class ListInventoryItem:
    item_stack_count: int
    item: int
    item_display_id: int
    max_items: int
    price: int
    max_durability: int
    durability: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> ListInventoryItem:
        # item_stack_count: u32
        item_stack_count = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        # item_display_id: u32
        item_display_id = await read_int(reader, 4)

        # max_items: u32
        max_items = await read_int(reader, 4)

        # price: Gold
        price = await read_int(reader, 4)

        # max_durability: u32
        max_durability = await read_int(reader, 4)

        # durability: u32
        durability = await read_int(reader, 4)

        return ListInventoryItem(
            item_stack_count=item_stack_count,
            item=item,
            item_display_id=item_display_id,
            max_items=max_items,
            price=price,
            max_durability=max_durability,
            durability=durability,
        )

    def write(self, _fmt, _data):
        _fmt += 'IIIIIII'
        _data.extend([self.item_stack_count, self.item, self.item_display_id, self.max_items, self.price, self.max_durability, self.durability])
        return _fmt, _data


@dataclasses.dataclass
class LootItem:
    index: int
    item: int
    ty: LootSlotType

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> LootItem:
        # index: u8
        index = await read_int(reader, 1)

        # item: Item
        item = await read_int(reader, 4)

        # ty: LootSlotType
        ty = LootSlotType(await read_int(reader, 1))

        return LootItem(
            index=index,
            item=item,
            ty=ty,
        )

    def write(self, _fmt, _data):
        _fmt += 'BIB'
        _data.extend([self.index, self.item, self.ty.value])
        return _fmt, _data


@dataclasses.dataclass
class Mail:
    message_id: int
    message_type: MailType
    subject: str
    item_text_id: int
    unknown1: int
    stationery: int
    item: int
    item_enchant_id: int
    item_random_property_id: int
    item_suffix_factor: int
    item_stack_size: int
    item_spell_charges: int
    max_durability: int
    durability: int
    money: int
    cash_on_delivery_amount: int
    checked_timestamp: int
    expiration_time: float
    mail_template_id: int
    sender: typing.Optional[int] = None
    sender_id: typing.Optional[int] = None
    auction_id: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Mail:
        sender = None
        sender_id = None
        auction_id = None
        # message_id: u32
        message_id = await read_int(reader, 4)

        # message_type: MailType
        message_type = MailType(await read_int(reader, 1))

        if message_type == MailType.NORMAL:
            # sender: Guid
            sender = await read_int(reader, 8)

        elif message_type in {MailType.CREATURE, MailType.GAMEOBJECT}:
            # sender_id: u32
            sender_id = await read_int(reader, 4)

        elif message_type == MailType.AUCTION:
            # auction_id: u32
            auction_id = await read_int(reader, 4)

        # subject: CString
        subject = await read_cstring(reader)

        # item_text_id: u32
        item_text_id = await read_int(reader, 4)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # stationery: u32
        stationery = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        # item_enchant_id: u32
        item_enchant_id = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # item_suffix_factor: u32
        item_suffix_factor = await read_int(reader, 4)

        # item_stack_size: u8
        item_stack_size = await read_int(reader, 1)

        # item_spell_charges: u32
        item_spell_charges = await read_int(reader, 4)

        # max_durability: u32
        max_durability = await read_int(reader, 4)

        # durability: u32
        durability = await read_int(reader, 4)

        # money: Gold
        money = await read_int(reader, 4)

        # cash_on_delivery_amount: u32
        cash_on_delivery_amount = await read_int(reader, 4)

        # checked_timestamp: u32
        checked_timestamp = await read_int(reader, 4)

        # expiration_time: f32
        expiration_time = await read_float(reader)

        # mail_template_id: u32
        mail_template_id = await read_int(reader, 4)

        return Mail(
            message_id=message_id,
            message_type=message_type,
            sender=sender,
            sender_id=sender_id,
            auction_id=auction_id,
            subject=subject,
            item_text_id=item_text_id,
            unknown1=unknown1,
            stationery=stationery,
            item=item,
            item_enchant_id=item_enchant_id,
            item_random_property_id=item_random_property_id,
            item_suffix_factor=item_suffix_factor,
            item_stack_size=item_stack_size,
            item_spell_charges=item_spell_charges,
            max_durability=max_durability,
            durability=durability,
            money=money,
            cash_on_delivery_amount=cash_on_delivery_amount,
            checked_timestamp=checked_timestamp,
            expiration_time=expiration_time,
            mail_template_id=mail_template_id,
        )

    def write(self, _fmt, _data):
        _fmt += 'IB'
        _data.extend([self.message_id, self.message_type.value])
        if self.message_type == MailType.NORMAL:
            _fmt += 'Q'
            _data.append(self.sender)
        elif self.message_type in {MailType.CREATURE, MailType.GAMEOBJECT}:
            _fmt += 'I'
            _data.append(self.sender_id)
        elif self.message_type == MailType.AUCTION:
            _fmt += 'I'
            _data.append(self.auction_id)
        # subject: CString
        _fmt += f'{len(self.subject)}sB'
        _data.extend([self.subject.encode('utf-8'), 0])

        # item_text_id: u32
        _fmt += 'I'
        _data.append(self.item_text_id)

        # unknown1: u32
        _fmt += 'I'
        _data.append(self.unknown1)

        # stationery: u32
        _fmt += 'I'
        _data.append(self.stationery)

        # item: Item
        _fmt += 'I'
        _data.append(self.item)

        # item_enchant_id: u32
        _fmt += 'I'
        _data.append(self.item_enchant_id)

        # item_random_property_id: u32
        _fmt += 'I'
        _data.append(self.item_random_property_id)

        # item_suffix_factor: u32
        _fmt += 'I'
        _data.append(self.item_suffix_factor)

        # item_stack_size: u8
        _fmt += 'B'
        _data.append(self.item_stack_size)

        # item_spell_charges: u32
        _fmt += 'I'
        _data.append(self.item_spell_charges)

        # max_durability: u32
        _fmt += 'I'
        _data.append(self.max_durability)

        # durability: u32
        _fmt += 'I'
        _data.append(self.durability)

        # money: Gold
        _fmt += 'I'
        _data.append(self.money)

        # cash_on_delivery_amount: u32
        _fmt += 'I'
        _data.append(self.cash_on_delivery_amount)

        # checked_timestamp: u32
        _fmt += 'I'
        _data.append(self.checked_timestamp)

        # expiration_time: f32
        _fmt += 'f'
        _data.append(self.expiration_time)

        # mail_template_id: u32
        _fmt += 'I'
        _data.append(self.mail_template_id)

        return _fmt, _data

    def size(self) -> int:
        _size = 67 + len(self.subject)

        if self.message_type == MailType.NORMAL:
            _size += 8
        elif self.message_type in {MailType.CREATURE, MailType.GAMEOBJECT}:
            _size += 4
        elif self.message_type == MailType.AUCTION:
            _size += 4

        return _size


@dataclasses.dataclass
class MovementBlock:
    update_flag: UpdateFlag
    flags: typing.Optional[MovementFlags] = None
    timestamp: typing.Optional[int] = None
    living_position: typing.Optional[Vector3d] = None
    living_orientation: typing.Optional[float] = None
    transport_guid: typing.Optional[int] = None
    transport_position: typing.Optional[Vector3d] = None
    transport_orientation: typing.Optional[float] = None
    pitch: typing.Optional[float] = None
    fall_time: typing.Optional[float] = None
    z_speed: typing.Optional[float] = None
    cos_angle: typing.Optional[float] = None
    sin_angle: typing.Optional[float] = None
    xy_speed: typing.Optional[float] = None
    spline_elevation: typing.Optional[float] = None
    walking_speed: typing.Optional[float] = None
    running_speed: typing.Optional[float] = None
    backwards_running_speed: typing.Optional[float] = None
    swimming_speed: typing.Optional[float] = None
    backwards_swimming_speed: typing.Optional[float] = None
    turn_rate: typing.Optional[float] = None
    spline_flags: typing.Optional[SplineFlag] = None
    angle: typing.Optional[float] = None
    target: typing.Optional[int] = None
    spline_final_point: typing.Optional[Vector3d] = None
    time_passed: typing.Optional[int] = None
    duration: typing.Optional[int] = None
    id: typing.Optional[int] = None
    nodes: typing.Optional[typing.List[Vector3d]] = None
    final_node: typing.Optional[Vector3d] = None
    position: typing.Optional[Vector3d] = None
    orientation: typing.Optional[float] = None
    unknown0: typing.Optional[int] = None
    unknown1: typing.Optional[int] = None
    guid: typing.Optional[int] = None
    transport_progress_in_ms: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> MovementBlock:
        flags = None
        timestamp = None
        living_position = None
        living_orientation = None
        transport_guid = None
        transport_position = None
        transport_orientation = None
        pitch = None
        fall_time = None
        z_speed = None
        cos_angle = None
        sin_angle = None
        xy_speed = None
        spline_elevation = None
        walking_speed = None
        running_speed = None
        backwards_running_speed = None
        swimming_speed = None
        backwards_swimming_speed = None
        turn_rate = None
        spline_flags = None
        angle = None
        target = None
        spline_final_point = None
        time_passed = None
        duration = None
        id = None
        amount_of_nodes = None
        nodes = None
        final_node = None
        position = None
        orientation = None
        unknown0 = None
        unknown1 = None
        guid = None
        transport_progress_in_ms = None
        # update_flag: UpdateFlag
        update_flag = UpdateFlag(await read_int(reader, 1))

        if UpdateFlag.LIVING in update_flag:
            # flags: MovementFlags
            flags = MovementFlags(await read_int(reader, 4))

            # timestamp: u32
            timestamp = await read_int(reader, 4)

            # living_position: Vector3d
            living_position = await Vector3d.read(reader)

            # living_orientation: f32
            living_orientation = await read_float(reader)

            if MovementFlags.ON_TRANSPORT in flags:
                # transport_guid: PackedGuid
                transport_guid = await read_packed_guid(reader)

                # transport_position: Vector3d
                transport_position = await Vector3d.read(reader)

                # transport_orientation: f32
                transport_orientation = await read_float(reader)

            if MovementFlags.SWIMMING in flags:
                # pitch: f32
                pitch = await read_float(reader)

            # fall_time: f32
            fall_time = await read_float(reader)

            if MovementFlags.JUMPING in flags:
                # z_speed: f32
                z_speed = await read_float(reader)

                # cos_angle: f32
                cos_angle = await read_float(reader)

                # sin_angle: f32
                sin_angle = await read_float(reader)

                # xy_speed: f32
                xy_speed = await read_float(reader)

            if MovementFlags.SPLINE_ELEVATION in flags:
                # spline_elevation: f32
                spline_elevation = await read_float(reader)

            # walking_speed: f32
            walking_speed = await read_float(reader)

            # running_speed: f32
            running_speed = await read_float(reader)

            # backwards_running_speed: f32
            backwards_running_speed = await read_float(reader)

            # swimming_speed: f32
            swimming_speed = await read_float(reader)

            # backwards_swimming_speed: f32
            backwards_swimming_speed = await read_float(reader)

            # turn_rate: f32
            turn_rate = await read_float(reader)

            if MovementFlags.SPLINE_ENABLED in flags:
                # spline_flags: SplineFlag
                spline_flags = SplineFlag(await read_int(reader, 4))

                if SplineFlag.FINAL_ANGLE in spline_flags:
                    # angle: f32
                    angle = await read_float(reader)

                elif SplineFlag.FINAL_TARGET in spline_flags:
                    # target: u64
                    target = await read_int(reader, 8)

                elif SplineFlag.FINAL_POINT in spline_flags:
                    # spline_final_point: Vector3d
                    spline_final_point = await Vector3d.read(reader)

                # time_passed: u32
                time_passed = await read_int(reader, 4)

                # duration: u32
                duration = await read_int(reader, 4)

                # id: u32
                id = await read_int(reader, 4)

                # amount_of_nodes: u32
                amount_of_nodes = await read_int(reader, 4)

                # nodes: Vector3d[amount_of_nodes]
                nodes = []
                for _ in range(0, amount_of_nodes):
                    nodes.append(await Vector3d.read(reader))

                # final_node: Vector3d
                final_node = await Vector3d.read(reader)

        elif UpdateFlag.HAS_POSITION in update_flag:
            # position: Vector3d
            position = await Vector3d.read(reader)

            # orientation: f32
            orientation = await read_float(reader)

        if UpdateFlag.HIGH_GUID in update_flag:
            # unknown0: u32
            unknown0 = await read_int(reader, 4)

        if UpdateFlag.ALL in update_flag:
            # unknown1: u32
            unknown1 = await read_int(reader, 4)

        if UpdateFlag.MELEE_ATTACKING in update_flag:
            # guid: PackedGuid
            guid = await read_packed_guid(reader)

        if UpdateFlag.TRANSPORT in update_flag:
            # transport_progress_in_ms: u32
            transport_progress_in_ms = await read_int(reader, 4)

        return MovementBlock(
            update_flag=update_flag,
            flags=flags,
            timestamp=timestamp,
            living_position=living_position,
            living_orientation=living_orientation,
            transport_guid=transport_guid,
            transport_position=transport_position,
            transport_orientation=transport_orientation,
            pitch=pitch,
            fall_time=fall_time,
            z_speed=z_speed,
            cos_angle=cos_angle,
            sin_angle=sin_angle,
            xy_speed=xy_speed,
            spline_elevation=spline_elevation,
            walking_speed=walking_speed,
            running_speed=running_speed,
            backwards_running_speed=backwards_running_speed,
            swimming_speed=swimming_speed,
            backwards_swimming_speed=backwards_swimming_speed,
            turn_rate=turn_rate,
            spline_flags=spline_flags,
            angle=angle,
            target=target,
            spline_final_point=spline_final_point,
            time_passed=time_passed,
            duration=duration,
            id=id,
            nodes=nodes,
            final_node=final_node,
            position=position,
            orientation=orientation,
            unknown0=unknown0,
            unknown1=unknown1,
            guid=guid,
            transport_progress_in_ms=transport_progress_in_ms,
        )

    def write(self, _fmt, _data):
        _fmt += 'B'
        _data.append(self.update_flag.value)
        if UpdateFlag.LIVING in self.update_flag:
            _fmt += 'II'
            _data.extend([self.flags.value, self.timestamp])
            # living_position: Vector3d
            _fmt, _data = self.living_position.write(_fmt, _data)

            # living_orientation: f32
            _fmt += 'f'
            _data.append(self.living_orientation)

            if MovementFlags.ON_TRANSPORT in self.flags:
                # transport_guid: PackedGuid
                _fmt, _data = packed_guid_write(self.transport_guid, _fmt, _data)

                # transport_position: Vector3d
                _fmt, _data = self.transport_position.write(_fmt, _data)

                # transport_orientation: f32
                _fmt += 'f'
                _data.append(self.transport_orientation)

            if MovementFlags.SWIMMING in self.flags:
                _fmt += 'f'
                _data.append(self.pitch)
            # fall_time: f32
            _fmt += 'f'
            _data.append(self.fall_time)

            if MovementFlags.JUMPING in self.flags:
                _fmt += 'ffff'
                _data.extend([self.z_speed, self.cos_angle, self.sin_angle, self.xy_speed])
            if MovementFlags.SPLINE_ELEVATION in self.flags:
                _fmt += 'f'
                _data.append(self.spline_elevation)
            # walking_speed: f32
            _fmt += 'f'
            _data.append(self.walking_speed)

            # running_speed: f32
            _fmt += 'f'
            _data.append(self.running_speed)

            # backwards_running_speed: f32
            _fmt += 'f'
            _data.append(self.backwards_running_speed)

            # swimming_speed: f32
            _fmt += 'f'
            _data.append(self.swimming_speed)

            # backwards_swimming_speed: f32
            _fmt += 'f'
            _data.append(self.backwards_swimming_speed)

            # turn_rate: f32
            _fmt += 'f'
            _data.append(self.turn_rate)

            if MovementFlags.SPLINE_ENABLED in self.flags:
                _fmt += 'I'
                _data.append(self.spline_flags.value)
                if SplineFlag.FINAL_ANGLE in self.spline_flags:
                    _fmt += 'f'
                    _data.append(self.angle)
                elif SplineFlag.FINAL_TARGET in self.spline_flags:
                    _fmt += 'Q'
                    _data.append(self.target)
                elif SplineFlag.FINAL_POINT in self.spline_flags:
                    # spline_final_point: Vector3d
                    _fmt, _data = self.spline_final_point.write(_fmt, _data)

                # time_passed: u32
                _fmt += 'I'
                _data.append(self.time_passed)

                # duration: u32
                _fmt += 'I'
                _data.append(self.duration)

                # id: u32
                _fmt += 'I'
                _data.append(self.id)

                # amount_of_nodes: u32
                _fmt += 'I'
                _data.append(len(self.nodes))

                # nodes: Vector3d[amount_of_nodes]
                for i in self.nodes:
                    _fmt, _data = i.write(_fmt, _data)

                # final_node: Vector3d
                _fmt, _data = self.final_node.write(_fmt, _data)

        elif UpdateFlag.HAS_POSITION in self.update_flag:
            # position: Vector3d
            _fmt, _data = self.position.write(_fmt, _data)

            # orientation: f32
            _fmt += 'f'
            _data.append(self.orientation)

        if UpdateFlag.HIGH_GUID in self.update_flag:
            _fmt += 'I'
            _data.append(self.unknown0)
        if UpdateFlag.ALL in self.update_flag:
            _fmt += 'I'
            _data.append(self.unknown1)
        if UpdateFlag.MELEE_ATTACKING in self.update_flag:
            # guid: PackedGuid
            _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        if UpdateFlag.TRANSPORT in self.update_flag:
            _fmt += 'I'
            _data.append(self.transport_progress_in_ms)
        return _fmt, _data

    def size(self) -> int:
        _size = 1

        if UpdateFlag.LIVING in self.update_flag:
            _size += 52

            if MovementFlags.ON_TRANSPORT in self.flags:
                _size += 16 + packed_guid_size(self.transport_guid)

            if MovementFlags.SWIMMING in self.flags:
                _size += 4

            if MovementFlags.JUMPING in self.flags:
                _size += 16

            if MovementFlags.SPLINE_ELEVATION in self.flags:
                _size += 4

            if MovementFlags.SPLINE_ENABLED in self.flags:
                _size += 32 + 12 * len(self.nodes)

                if SplineFlag.FINAL_ANGLE in self.spline_flags:
                    _size += 4
                elif SplineFlag.FINAL_TARGET in self.spline_flags:
                    _size += 8
                elif SplineFlag.FINAL_POINT in self.spline_flags:
                    _size += 12


        elif UpdateFlag.HAS_POSITION in self.update_flag:
            _size += 16

        if UpdateFlag.HIGH_GUID in self.update_flag:
            _size += 4

        if UpdateFlag.ALL in self.update_flag:
            _size += 4

        if UpdateFlag.MELEE_ATTACKING in self.update_flag:
            _size += 0 + packed_guid_size(self.guid)

        if UpdateFlag.TRANSPORT in self.update_flag:
            _size += 4

        return _size


@dataclasses.dataclass
class TransportInfo:
    guid: int
    position: Vector3d
    orientation: float
    timestamp: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> TransportInfo:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # position: Vector3d
        position = await Vector3d.read(reader)

        # orientation: f32
        orientation = await read_float(reader)

        # timestamp: u32
        timestamp = await read_int(reader, 4)

        return TransportInfo(
            guid=guid,
            position=position,
            orientation=orientation,
            timestamp=timestamp,
        )

    def write(self, _fmt, _data):
        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # orientation: f32
        _fmt += 'f'
        _data.append(self.orientation)

        # timestamp: u32
        _fmt += 'I'
        _data.append(self.timestamp)

        return _fmt, _data

    def size(self) -> int:
        return 20 + packed_guid_size(self.guid)


@dataclasses.dataclass
class MovementInfo:
    flags: MovementFlags
    timestamp: int
    position: Vector3d
    orientation: float
    fall_time: float
    transport: typing.Optional[TransportInfo] = None
    pitch: typing.Optional[float] = None
    z_speed: typing.Optional[float] = None
    cos_angle: typing.Optional[float] = None
    sin_angle: typing.Optional[float] = None
    xy_speed: typing.Optional[float] = None
    spline_elevation: typing.Optional[float] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> MovementInfo:
        transport = None
        pitch = None
        z_speed = None
        cos_angle = None
        sin_angle = None
        xy_speed = None
        spline_elevation = None
        # flags: MovementFlags
        flags = MovementFlags(await read_int(reader, 4))

        # timestamp: u32
        timestamp = await read_int(reader, 4)

        # position: Vector3d
        position = await Vector3d.read(reader)

        # orientation: f32
        orientation = await read_float(reader)

        if MovementFlags.ON_TRANSPORT in flags:
            # transport: TransportInfo
            transport = await TransportInfo.read(reader)

        if MovementFlags.SWIMMING in flags:
            # pitch: f32
            pitch = await read_float(reader)

        # fall_time: f32
        fall_time = await read_float(reader)

        if MovementFlags.JUMPING in flags:
            # z_speed: f32
            z_speed = await read_float(reader)

            # cos_angle: f32
            cos_angle = await read_float(reader)

            # sin_angle: f32
            sin_angle = await read_float(reader)

            # xy_speed: f32
            xy_speed = await read_float(reader)

        if MovementFlags.SPLINE_ELEVATION in flags:
            # spline_elevation: f32
            spline_elevation = await read_float(reader)

        return MovementInfo(
            flags=flags,
            timestamp=timestamp,
            position=position,
            orientation=orientation,
            transport=transport,
            pitch=pitch,
            fall_time=fall_time,
            z_speed=z_speed,
            cos_angle=cos_angle,
            sin_angle=sin_angle,
            xy_speed=xy_speed,
            spline_elevation=spline_elevation,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.flags.value, self.timestamp])
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # orientation: f32
        _fmt += 'f'
        _data.append(self.orientation)

        if MovementFlags.ON_TRANSPORT in self.flags:
            # transport: TransportInfo
            _fmt, _data = self.transport.write(_fmt, _data)

        if MovementFlags.SWIMMING in self.flags:
            _fmt += 'f'
            _data.append(self.pitch)
        # fall_time: f32
        _fmt += 'f'
        _data.append(self.fall_time)

        if MovementFlags.JUMPING in self.flags:
            _fmt += 'ffff'
            _data.extend([self.z_speed, self.cos_angle, self.sin_angle, self.xy_speed])
        if MovementFlags.SPLINE_ELEVATION in self.flags:
            _fmt += 'f'
            _data.append(self.spline_elevation)
        return _fmt, _data

    def size(self) -> int:
        _size = 28

        if MovementFlags.ON_TRANSPORT in self.flags:
            _size += 0 + self.transport.size()

        if MovementFlags.SWIMMING in self.flags:
            _size += 4

        if MovementFlags.JUMPING in self.flags:
            _size += 16

        if MovementFlags.SPLINE_ELEVATION in self.flags:
            _size += 4

        return _size


@dataclasses.dataclass
class NpcTextUpdateEmote:
    delay: int
    emote: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> NpcTextUpdateEmote:
        # delay: u32
        delay = await read_int(reader, 4)

        # emote: u32
        emote = await read_int(reader, 4)

        return NpcTextUpdateEmote(
            delay=delay,
            emote=emote,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.delay, self.emote])
        return _fmt, _data


@dataclasses.dataclass
class NpcTextUpdate:
    probability: float
    texts: typing.List[str]
    language: Language
    emotes: typing.List[NpcTextUpdateEmote]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> NpcTextUpdate:
        # probability: f32
        probability = await read_float(reader)

        # texts: CString[2]
        texts = []
        for _ in range(0, 2):
            texts.append(await read_cstring(reader))

        # language: Language
        language = Language(await read_int(reader, 4))

        # emotes: NpcTextUpdateEmote[3]
        emotes = []
        for _ in range(0, 3):
            emotes.append(await NpcTextUpdateEmote.read(reader))

        return NpcTextUpdate(
            probability=probability,
            texts=texts,
            language=language,
            emotes=emotes,
        )

    def write(self, _fmt, _data):
        _fmt += 'f'
        _data.append(self.probability)
        # texts: CString[2]
        for i in self.texts:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        # language: Language
        _fmt += 'I'
        _data.append(self.language.value)

        # emotes: NpcTextUpdateEmote[3]
        for i in self.emotes:
            _fmt, _data = i.write(_fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        return 32 + sum([len(i) + 1 for i in self.texts])


@dataclasses.dataclass
class Object:
    update_type: UpdateType
    guid1: typing.Optional[int] = None
    mask1: typing.Optional[UpdateMask] = None
    guid2: typing.Optional[int] = None
    movement1: typing.Optional[MovementBlock] = None
    guid3: typing.Optional[int] = None
    object_type: typing.Optional[ObjectType] = None
    movement2: typing.Optional[MovementBlock] = None
    mask2: typing.Optional[UpdateMask] = None
    guids: typing.Optional[typing.List[int]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Object:
        guid1 = None
        mask1 = None
        guid2 = None
        movement1 = None
        guid3 = None
        object_type = None
        movement2 = None
        mask2 = None
        count = None
        guids = None
        # update_type: UpdateType
        update_type = UpdateType(await read_int(reader, 1))

        if update_type == UpdateType.VALUES:
            # guid1: PackedGuid
            guid1 = await read_packed_guid(reader)

            # mask1: UpdateMask
            mask1 = await UpdateMask.read(reader)

        elif update_type == UpdateType.MOVEMENT:
            # guid2: PackedGuid
            guid2 = await read_packed_guid(reader)

            # movement1: MovementBlock
            movement1 = await MovementBlock.read(reader)

        elif update_type in {UpdateType.CREATE_OBJECT, UpdateType.CREATE_OBJECT2}:
            # guid3: PackedGuid
            guid3 = await read_packed_guid(reader)

            # object_type: ObjectType
            object_type = ObjectType(await read_int(reader, 1))

            # movement2: MovementBlock
            movement2 = await MovementBlock.read(reader)

            # mask2: UpdateMask
            mask2 = await UpdateMask.read(reader)

        elif update_type in {UpdateType.OUT_OF_RANGE_OBJECTS, UpdateType.NEAR_OBJECTS}:
            # count: u32
            count = await read_int(reader, 4)

            # guids: PackedGuid[count]
            guids = []
            for _ in range(0, count):
                guids.append(await read_packed_guid(reader))

        return Object(
            update_type=update_type,
            guid1=guid1,
            mask1=mask1,
            guid2=guid2,
            movement1=movement1,
            guid3=guid3,
            object_type=object_type,
            movement2=movement2,
            mask2=mask2,
            guids=guids,
        )

    def write(self, _fmt, _data):
        _fmt += 'B'
        _data.append(self.update_type.value)
        if self.update_type == UpdateType.VALUES:
            # guid1: PackedGuid
            _fmt, _data = packed_guid_write(self.guid1, _fmt, _data)

            # mask1: UpdateMask
            _fmt, _data = self.mask1.write(_fmt, _data)

        elif self.update_type == UpdateType.MOVEMENT:
            # guid2: PackedGuid
            _fmt, _data = packed_guid_write(self.guid2, _fmt, _data)

            # movement1: MovementBlock
            _fmt, _data = self.movement1.write(_fmt, _data)

        elif self.update_type in {UpdateType.CREATE_OBJECT, UpdateType.CREATE_OBJECT2}:
            # guid3: PackedGuid
            _fmt, _data = packed_guid_write(self.guid3, _fmt, _data)

            # object_type: ObjectType
            _fmt += 'B'
            _data.append(self.object_type.value)

            # movement2: MovementBlock
            _fmt, _data = self.movement2.write(_fmt, _data)

            # mask2: UpdateMask
            _fmt, _data = self.mask2.write(_fmt, _data)

        elif self.update_type in {UpdateType.OUT_OF_RANGE_OBJECTS, UpdateType.NEAR_OBJECTS}:
            _fmt += 'I'
            _data.append(len(self.guids))
            # guids: PackedGuid[count]
            for i in self.guids:
                _fmt, _data = packed_guid_write(i, _fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        _size = 1

        if self.update_type == UpdateType.VALUES:
            _size += 0 + packed_guid_size(self.guid1) + self.mask1.size()
        elif self.update_type == UpdateType.MOVEMENT:
            _size += 0 + packed_guid_size(self.guid2) + self.movement1.size()
        elif self.update_type in {UpdateType.CREATE_OBJECT, UpdateType.CREATE_OBJECT2}:
            _size += 1 + packed_guid_size(self.guid3) + self.movement2.size() + self.mask2.size()
        elif self.update_type in {UpdateType.OUT_OF_RANGE_OBJECTS, UpdateType.NEAR_OBJECTS}:
            _size += 4 + sum([packed_guid_size(i) for i in self.guids])

        return _size


@dataclasses.dataclass
class PetSpellCooldown:
    spell: int
    spell_category: int
    cooldown: int
    category_cooldown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> PetSpellCooldown:
        # spell: Spell16
        spell = await read_int(reader, 2)

        # spell_category: u16
        spell_category = await read_int(reader, 2)

        # cooldown: Milliseconds
        cooldown = await read_int(reader, 4)

        # category_cooldown: Milliseconds
        category_cooldown = await read_int(reader, 4)

        return PetSpellCooldown(
            spell=spell,
            spell_category=spell_category,
            cooldown=cooldown,
            category_cooldown=category_cooldown,
        )

    def write(self, _fmt, _data):
        _fmt += 'HHII'
        _data.extend([self.spell, self.spell_category, self.cooldown, self.category_cooldown])
        return _fmt, _data


@dataclasses.dataclass
class PetitionShowlist:
    index: int
    charter_entry: int
    charter_display_id: int
    guild_charter_cost: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> PetitionShowlist:
        # index: u32
        index = await read_int(reader, 4)

        # charter_entry: u32
        charter_entry = await read_int(reader, 4)

        # charter_display_id: u32
        charter_display_id = await read_int(reader, 4)

        # guild_charter_cost: u32
        guild_charter_cost = await read_int(reader, 4)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return PetitionShowlist(
            index=index,
            charter_entry=charter_entry,
            charter_display_id=charter_display_id,
            guild_charter_cost=guild_charter_cost,
            unknown1=unknown1,
        )

    def write(self, _fmt, _data):
        _fmt += 'IIIII'
        _data.extend([self.index, self.charter_entry, self.charter_display_id, self.guild_charter_cost, self.unknown1])
        return _fmt, _data


@dataclasses.dataclass
class PetitionSignature:
    signer: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> PetitionSignature:
        # signer: Guid
        signer = await read_int(reader, 8)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return PetitionSignature(
            signer=signer,
            unknown1=unknown1,
        )

    def write(self, _fmt, _data):
        _fmt += 'QI'
        _data.extend([self.signer, self.unknown1])
        return _fmt, _data


@dataclasses.dataclass
class QuestDetailsEmote:
    emote: int
    emote_delay: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> QuestDetailsEmote:
        # emote: u32
        emote = await read_int(reader, 4)

        # emote_delay: Milliseconds
        emote_delay = await read_int(reader, 4)

        return QuestDetailsEmote(
            emote=emote,
            emote_delay=emote_delay,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.emote, self.emote_delay])
        return _fmt, _data


@dataclasses.dataclass
class QuestItem:
    quest_id: int
    quest_icon: int
    level: int
    title: str

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> QuestItem:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # quest_icon: u32
        quest_icon = await read_int(reader, 4)

        # level: Level32
        level = await read_int(reader, 4)

        # title: CString
        title = await read_cstring(reader)

        return QuestItem(
            quest_id=quest_id,
            quest_icon=quest_icon,
            level=level,
            title=title,
        )

    def write(self, _fmt, _data):
        _fmt += f'III{len(self.title)}sB'
        _data.extend([self.quest_id, self.quest_icon, self.level, self.title.encode('utf-8'), 0])
        return _fmt, _data

    def size(self) -> int:
        return 13 + len(self.title)


@dataclasses.dataclass
class QuestItemRequirement:
    item: int
    item_count: int
    item_display_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> QuestItemRequirement:
        # item: Item
        item = await read_int(reader, 4)

        # item_count: u32
        item_count = await read_int(reader, 4)

        # item_display_id: u32
        item_display_id = await read_int(reader, 4)

        return QuestItemRequirement(
            item=item,
            item_count=item_count,
            item_display_id=item_display_id,
        )

    def write(self, _fmt, _data):
        _fmt += 'III'
        _data.extend([self.item, self.item_count, self.item_display_id])
        return _fmt, _data


@dataclasses.dataclass
class QuestItemReward:
    item: int
    item_count: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> QuestItemReward:
        # item: Item
        item = await read_int(reader, 4)

        # item_count: u32
        item_count = await read_int(reader, 4)

        return QuestItemReward(
            item=item,
            item_count=item_count,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.item, self.item_count])
        return _fmt, _data


@dataclasses.dataclass
class QuestObjective:
    creature_id: int
    kill_count: int
    required_item_id: int
    required_item_count: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> QuestObjective:
        # creature_id: u32
        creature_id = await read_int(reader, 4)

        # kill_count: u32
        kill_count = await read_int(reader, 4)

        # required_item_id: u32
        required_item_id = await read_int(reader, 4)

        # required_item_count: u32
        required_item_count = await read_int(reader, 4)

        return QuestObjective(
            creature_id=creature_id,
            kill_count=kill_count,
            required_item_id=required_item_id,
            required_item_count=required_item_count,
        )

    def write(self, _fmt, _data):
        _fmt += 'IIII'
        _data.extend([self.creature_id, self.kill_count, self.required_item_id, self.required_item_count])
        return _fmt, _data


@dataclasses.dataclass
class RaidInfo:
    map: Map
    reset_time: int
    instance_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> RaidInfo:
        # map: Map
        map = Map(await read_int(reader, 4))

        # reset_time: u32
        reset_time = await read_int(reader, 4)

        # instance_id: u32
        instance_id = await read_int(reader, 4)

        return RaidInfo(
            map=map,
            reset_time=reset_time,
            instance_id=instance_id,
        )

    def write(self, _fmt, _data):
        _fmt += 'III'
        _data.extend([self.map.value, self.reset_time, self.instance_id])
        return _fmt, _data


@dataclasses.dataclass
class RaidTargetUpdate:
    index: RaidTargetIndex
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> RaidTargetUpdate:
        # index: RaidTargetIndex
        index = RaidTargetIndex(await read_int(reader, 1))

        # guid: Guid
        guid = await read_int(reader, 8)

        return RaidTargetUpdate(
            index=index,
            guid=guid,
        )

    def write(self, _fmt, _data):
        _fmt += 'BQ'
        _data.extend([self.index.value, self.guid])
        return _fmt, _data


@dataclasses.dataclass
class SpellCastTargets:
    target_flags: SpellCastTargetFlags
    unit_target: typing.Optional[int] = None
    gameobject: typing.Optional[int] = None
    object_unk: typing.Optional[int] = None
    item: typing.Optional[int] = None
    trade_item: typing.Optional[int] = None
    source: typing.Optional[Vector3d] = None
    destination: typing.Optional[Vector3d] = None
    target_string: typing.Optional[str] = None
    corpse: typing.Optional[int] = None
    pvp_corpse: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SpellCastTargets:
        unit_target = None
        gameobject = None
        object_unk = None
        item = None
        trade_item = None
        source = None
        destination = None
        target_string = None
        corpse = None
        pvp_corpse = None
        # target_flags: SpellCastTargetFlags
        target_flags = SpellCastTargetFlags(await read_int(reader, 2))

        if SpellCastTargetFlags.UNIT in target_flags:
            # unit_target: PackedGuid
            unit_target = await read_packed_guid(reader)

        if SpellCastTargetFlags.GAMEOBJECT in target_flags:
            # gameobject: PackedGuid
            gameobject = await read_packed_guid(reader)

        elif SpellCastTargetFlags.OBJECT_UNK in target_flags:
            # object_unk: PackedGuid
            object_unk = await read_packed_guid(reader)

        if SpellCastTargetFlags.ITEM in target_flags:
            # item: PackedGuid
            item = await read_packed_guid(reader)

        elif SpellCastTargetFlags.TRADE_ITEM in target_flags:
            # trade_item: PackedGuid
            trade_item = await read_packed_guid(reader)

        if SpellCastTargetFlags.SOURCE_LOCATION in target_flags:
            # source: Vector3d
            source = await Vector3d.read(reader)

        if SpellCastTargetFlags.DEST_LOCATION in target_flags:
            # destination: Vector3d
            destination = await Vector3d.read(reader)

        if SpellCastTargetFlags.STRING in target_flags:
            # target_string: CString
            target_string = await read_cstring(reader)

        if SpellCastTargetFlags.CORPSE in target_flags:
            # corpse: PackedGuid
            corpse = await read_packed_guid(reader)

        elif SpellCastTargetFlags.PVP_CORPSE in target_flags:
            # pvp_corpse: PackedGuid
            pvp_corpse = await read_packed_guid(reader)

        return SpellCastTargets(
            target_flags=target_flags,
            unit_target=unit_target,
            gameobject=gameobject,
            object_unk=object_unk,
            item=item,
            trade_item=trade_item,
            source=source,
            destination=destination,
            target_string=target_string,
            corpse=corpse,
            pvp_corpse=pvp_corpse,
        )

    def write(self, _fmt, _data):
        _fmt += 'H'
        _data.append(self.target_flags.value)
        if SpellCastTargetFlags.UNIT in self.target_flags:
            # unit_target: PackedGuid
            _fmt, _data = packed_guid_write(self.unit_target, _fmt, _data)

        if SpellCastTargetFlags.GAMEOBJECT in self.target_flags:
            # gameobject: PackedGuid
            _fmt, _data = packed_guid_write(self.gameobject, _fmt, _data)

        elif SpellCastTargetFlags.OBJECT_UNK in self.target_flags:
            # object_unk: PackedGuid
            _fmt, _data = packed_guid_write(self.object_unk, _fmt, _data)

        if SpellCastTargetFlags.ITEM in self.target_flags:
            # item: PackedGuid
            _fmt, _data = packed_guid_write(self.item, _fmt, _data)

        elif SpellCastTargetFlags.TRADE_ITEM in self.target_flags:
            # trade_item: PackedGuid
            _fmt, _data = packed_guid_write(self.trade_item, _fmt, _data)

        if SpellCastTargetFlags.SOURCE_LOCATION in self.target_flags:
            # source: Vector3d
            _fmt, _data = self.source.write(_fmt, _data)

        if SpellCastTargetFlags.DEST_LOCATION in self.target_flags:
            # destination: Vector3d
            _fmt, _data = self.destination.write(_fmt, _data)

        if SpellCastTargetFlags.STRING in self.target_flags:
            _fmt += f'{len(self.target_string)}sB'
            _data.extend([self.target_string.encode('utf-8'), 0])
        if SpellCastTargetFlags.CORPSE in self.target_flags:
            # corpse: PackedGuid
            _fmt, _data = packed_guid_write(self.corpse, _fmt, _data)

        elif SpellCastTargetFlags.PVP_CORPSE in self.target_flags:
            # pvp_corpse: PackedGuid
            _fmt, _data = packed_guid_write(self.pvp_corpse, _fmt, _data)

        return _fmt, _data

    def size(self) -> int:
        _size = 2

        if SpellCastTargetFlags.UNIT in self.target_flags:
            _size += 0 + packed_guid_size(self.unit_target)

        if SpellCastTargetFlags.GAMEOBJECT in self.target_flags:
            _size += 0 + packed_guid_size(self.gameobject)
        elif SpellCastTargetFlags.OBJECT_UNK in self.target_flags:
            _size += 0 + packed_guid_size(self.object_unk)

        if SpellCastTargetFlags.ITEM in self.target_flags:
            _size += 0 + packed_guid_size(self.item)
        elif SpellCastTargetFlags.TRADE_ITEM in self.target_flags:
            _size += 0 + packed_guid_size(self.trade_item)

        if SpellCastTargetFlags.SOURCE_LOCATION in self.target_flags:
            _size += 12

        if SpellCastTargetFlags.DEST_LOCATION in self.target_flags:
            _size += 12

        if SpellCastTargetFlags.STRING in self.target_flags:
            _size += 1 + len(self.target_string)

        if SpellCastTargetFlags.CORPSE in self.target_flags:
            _size += 0 + packed_guid_size(self.corpse)
        elif SpellCastTargetFlags.PVP_CORPSE in self.target_flags:
            _size += 0 + packed_guid_size(self.pvp_corpse)

        return _size


@dataclasses.dataclass
class SpellCooldownStatus:
    id: int
    cooldown_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SpellCooldownStatus:
        # id: Spell
        id = await read_int(reader, 4)

        # cooldown_time: Milliseconds
        cooldown_time = await read_int(reader, 4)

        return SpellCooldownStatus(
            id=id,
            cooldown_time=cooldown_time,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.id, self.cooldown_time])
        return _fmt, _data


@dataclasses.dataclass
class SpellLog:
    effect: SpellEffect
    target1: typing.Optional[int] = None
    amount: typing.Optional[int] = None
    power: typing.Optional[Power] = None
    multiplier: typing.Optional[float] = None
    target2: typing.Optional[int] = None
    heal_amount: typing.Optional[int] = None
    heal_critical: typing.Optional[int] = None
    target3: typing.Optional[int] = None
    energize_amount: typing.Optional[int] = None
    energize_power: typing.Optional[int] = None
    target4: typing.Optional[int] = None
    extra_attacks: typing.Optional[int] = None
    item: typing.Optional[int] = None
    target5: typing.Optional[int] = None
    interrupted_spell: typing.Optional[int] = None
    target6: typing.Optional[int] = None
    item_to_damage: typing.Optional[int] = None
    unknown5: typing.Optional[int] = None
    feed_pet_item: typing.Optional[int] = None
    target7: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SpellLog:
        target1 = None
        amount = None
        power = None
        multiplier = None
        target2 = None
        heal_amount = None
        heal_critical = None
        target3 = None
        energize_amount = None
        energize_power = None
        target4 = None
        extra_attacks = None
        item = None
        target5 = None
        interrupted_spell = None
        target6 = None
        item_to_damage = None
        unknown5 = None
        feed_pet_item = None
        target7 = None
        # effect: SpellEffect
        effect = SpellEffect(await read_int(reader, 4))

        # amount_of_logs: u32
        _amount_of_logs = await read_int(reader, 4)

        if effect == SpellEffect.POWER_DRAIN:
            # target1: Guid
            target1 = await read_int(reader, 8)

            # amount: u32
            amount = await read_int(reader, 4)

            # power: Power
            power = Power(await read_int(reader, 4))

            # multiplier: f32
            multiplier = await read_float(reader)

        elif effect in {SpellEffect.HEAL, SpellEffect.HEAL_MAX_HEALTH}:
            # target2: Guid
            target2 = await read_int(reader, 8)

            # heal_amount: u32
            heal_amount = await read_int(reader, 4)

            # heal_critical: u32
            heal_critical = await read_int(reader, 4)

        elif effect == SpellEffect.ENERGIZE:
            # target3: Guid
            target3 = await read_int(reader, 8)

            # energize_amount: u32
            energize_amount = await read_int(reader, 4)

            # energize_power: u32
            energize_power = await read_int(reader, 4)

        elif effect == SpellEffect.ADD_EXTRA_ATTACKS:
            # target4: Guid
            target4 = await read_int(reader, 8)

            # extra_attacks: u32
            extra_attacks = await read_int(reader, 4)

        elif effect == SpellEffect.CREATE_ITEM:
            # item: Item
            item = await read_int(reader, 4)

        elif effect == SpellEffect.INTERRUPT_CAST:
            # target5: Guid
            target5 = await read_int(reader, 8)

            # interrupted_spell: Spell
            interrupted_spell = await read_int(reader, 4)

        elif effect == SpellEffect.DURABILITY_DAMAGE:
            # target6: Guid
            target6 = await read_int(reader, 8)

            # item_to_damage: Item
            item_to_damage = await read_int(reader, 4)

            # unknown5: u32
            unknown5 = await read_int(reader, 4)

        elif effect == SpellEffect.FEED_PET:
            # feed_pet_item: Item
            feed_pet_item = await read_int(reader, 4)

        elif effect in {SpellEffect.INSTAKILL, SpellEffect.RESURRECT, SpellEffect.DISPEL, SpellEffect.THREAT, SpellEffect.DISTRACT, SpellEffect.SANCTUARY, SpellEffect.THREAT_ALL, SpellEffect.DISPEL_MECHANIC, SpellEffect.RESURRECT_NEW, SpellEffect.ATTACK_ME, SpellEffect.SKIN_PLAYER_CORPSE, SpellEffect.MODIFY_THREAT_PERCENT, SpellEffect.UNKNOWN126, SpellEffect.OPEN_LOCK, SpellEffect.OPEN_LOCK_ITEM, SpellEffect.DISMISS_PET, SpellEffect.TRANS_DOOR, SpellEffect.SUMMON, SpellEffect.SUMMON_PET, SpellEffect.SUMMON_WILD, SpellEffect.SUMMON_GUARDIAN, SpellEffect.SUMMON_TOTEM_SLOT1, SpellEffect.SUMMON_TOTEM_SLOT2, SpellEffect.SUMMON_TOTEM_SLOT3, SpellEffect.SUMMON_TOTEM_SLOT4, SpellEffect.SUMMON_POSSESSED, SpellEffect.SUMMON_TOTEM, SpellEffect.SUMMON_CRITTER, SpellEffect.SUMMON_OBJECT_WILD, SpellEffect.SUMMON_OBJECT_SLOT1, SpellEffect.SUMMON_OBJECT_SLOT2, SpellEffect.SUMMON_OBJECT_SLOT3, SpellEffect.SUMMON_OBJECT_SLOT4, SpellEffect.SUMMON_DEMON}:
            # target7: Guid
            target7 = await read_int(reader, 8)

        return SpellLog(
            effect=effect,
            target1=target1,
            amount=amount,
            power=power,
            multiplier=multiplier,
            target2=target2,
            heal_amount=heal_amount,
            heal_critical=heal_critical,
            target3=target3,
            energize_amount=energize_amount,
            energize_power=energize_power,
            target4=target4,
            extra_attacks=extra_attacks,
            item=item,
            target5=target5,
            interrupted_spell=interrupted_spell,
            target6=target6,
            item_to_damage=item_to_damage,
            unknown5=unknown5,
            feed_pet_item=feed_pet_item,
            target7=target7,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.effect.value, 1])
        if self.effect == SpellEffect.POWER_DRAIN:
            _fmt += 'QIIf'
            _data.extend([self.target1, self.amount, self.power.value, self.multiplier])
        elif self.effect in {SpellEffect.HEAL, SpellEffect.HEAL_MAX_HEALTH}:
            _fmt += 'QII'
            _data.extend([self.target2, self.heal_amount, self.heal_critical])
        elif self.effect == SpellEffect.ENERGIZE:
            _fmt += 'QII'
            _data.extend([self.target3, self.energize_amount, self.energize_power])
        elif self.effect == SpellEffect.ADD_EXTRA_ATTACKS:
            _fmt += 'QI'
            _data.extend([self.target4, self.extra_attacks])
        elif self.effect == SpellEffect.CREATE_ITEM:
            _fmt += 'I'
            _data.append(self.item)
        elif self.effect == SpellEffect.INTERRUPT_CAST:
            _fmt += 'QI'
            _data.extend([self.target5, self.interrupted_spell])
        elif self.effect == SpellEffect.DURABILITY_DAMAGE:
            _fmt += 'QII'
            _data.extend([self.target6, self.item_to_damage, self.unknown5])
        elif self.effect == SpellEffect.FEED_PET:
            _fmt += 'I'
            _data.append(self.feed_pet_item)
        elif self.effect in {SpellEffect.INSTAKILL, SpellEffect.RESURRECT, SpellEffect.DISPEL, SpellEffect.THREAT, SpellEffect.DISTRACT, SpellEffect.SANCTUARY, SpellEffect.THREAT_ALL, SpellEffect.DISPEL_MECHANIC, SpellEffect.RESURRECT_NEW, SpellEffect.ATTACK_ME, SpellEffect.SKIN_PLAYER_CORPSE, SpellEffect.MODIFY_THREAT_PERCENT, SpellEffect.UNKNOWN126, SpellEffect.OPEN_LOCK, SpellEffect.OPEN_LOCK_ITEM, SpellEffect.DISMISS_PET, SpellEffect.TRANS_DOOR, SpellEffect.SUMMON, SpellEffect.SUMMON_PET, SpellEffect.SUMMON_WILD, SpellEffect.SUMMON_GUARDIAN, SpellEffect.SUMMON_TOTEM_SLOT1, SpellEffect.SUMMON_TOTEM_SLOT2, SpellEffect.SUMMON_TOTEM_SLOT3, SpellEffect.SUMMON_TOTEM_SLOT4, SpellEffect.SUMMON_POSSESSED, SpellEffect.SUMMON_TOTEM, SpellEffect.SUMMON_CRITTER, SpellEffect.SUMMON_OBJECT_WILD, SpellEffect.SUMMON_OBJECT_SLOT1, SpellEffect.SUMMON_OBJECT_SLOT2, SpellEffect.SUMMON_OBJECT_SLOT3, SpellEffect.SUMMON_OBJECT_SLOT4, SpellEffect.SUMMON_DEMON}:
            _fmt += 'Q'
            _data.append(self.target7)
        return _fmt, _data

    def size(self) -> int:
        _size = 8

        if self.effect == SpellEffect.POWER_DRAIN:
            _size += 20
        elif self.effect in {SpellEffect.HEAL, SpellEffect.HEAL_MAX_HEALTH}:
            _size += 16
        elif self.effect == SpellEffect.ENERGIZE:
            _size += 16
        elif self.effect == SpellEffect.ADD_EXTRA_ATTACKS:
            _size += 12
        elif self.effect == SpellEffect.CREATE_ITEM:
            _size += 4
        elif self.effect == SpellEffect.INTERRUPT_CAST:
            _size += 12
        elif self.effect == SpellEffect.DURABILITY_DAMAGE:
            _size += 16
        elif self.effect == SpellEffect.FEED_PET:
            _size += 4
        elif self.effect in {SpellEffect.INSTAKILL, SpellEffect.RESURRECT, SpellEffect.DISPEL, SpellEffect.THREAT, SpellEffect.DISTRACT, SpellEffect.SANCTUARY, SpellEffect.THREAT_ALL, SpellEffect.DISPEL_MECHANIC, SpellEffect.RESURRECT_NEW, SpellEffect.ATTACK_ME, SpellEffect.SKIN_PLAYER_CORPSE, SpellEffect.MODIFY_THREAT_PERCENT, SpellEffect.UNKNOWN126, SpellEffect.OPEN_LOCK, SpellEffect.OPEN_LOCK_ITEM, SpellEffect.DISMISS_PET, SpellEffect.TRANS_DOOR, SpellEffect.SUMMON, SpellEffect.SUMMON_PET, SpellEffect.SUMMON_WILD, SpellEffect.SUMMON_GUARDIAN, SpellEffect.SUMMON_TOTEM_SLOT1, SpellEffect.SUMMON_TOTEM_SLOT2, SpellEffect.SUMMON_TOTEM_SLOT3, SpellEffect.SUMMON_TOTEM_SLOT4, SpellEffect.SUMMON_POSSESSED, SpellEffect.SUMMON_TOTEM, SpellEffect.SUMMON_CRITTER, SpellEffect.SUMMON_OBJECT_WILD, SpellEffect.SUMMON_OBJECT_SLOT1, SpellEffect.SUMMON_OBJECT_SLOT2, SpellEffect.SUMMON_OBJECT_SLOT3, SpellEffect.SUMMON_OBJECT_SLOT4, SpellEffect.SUMMON_DEMON}:
            _size += 8

        return _size


@dataclasses.dataclass
class SpellLogMiss:
    target: int
    miss_info: SpellMissInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SpellLogMiss:
        # target: Guid
        target = await read_int(reader, 8)

        # miss_info: SpellMissInfo
        miss_info = SpellMissInfo(await read_int(reader, 1))

        return SpellLogMiss(
            target=target,
            miss_info=miss_info,
        )

    def write(self, _fmt, _data):
        _fmt += 'QB'
        _data.extend([self.target, self.miss_info.value])
        return _fmt, _data


@dataclasses.dataclass
class SpellMiss:
    target: int
    miss_info: SpellMissInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> SpellMiss:
        # target: Guid
        target = await read_int(reader, 8)

        # miss_info: SpellMissInfo
        miss_info = SpellMissInfo(await read_int(reader, 1))

        return SpellMiss(
            target=target,
            miss_info=miss_info,
        )

    def write(self, _fmt, _data):
        _fmt += 'QB'
        _data.extend([self.target, self.miss_info.value])
        return _fmt, _data


@dataclasses.dataclass
class StabledPet:
    pet_number: int
    entry: int
    level: int
    name: str
    loyalty: int
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> StabledPet:
        # pet_number: u32
        pet_number = await read_int(reader, 4)

        # entry: u32
        entry = await read_int(reader, 4)

        # level: Level32
        level = await read_int(reader, 4)

        # name: CString
        name = await read_cstring(reader)

        # loyalty: u32
        loyalty = await read_int(reader, 4)

        # slot: u8
        slot = await read_int(reader, 1)

        return StabledPet(
            pet_number=pet_number,
            entry=entry,
            level=level,
            name=name,
            loyalty=loyalty,
            slot=slot,
        )

    def write(self, _fmt, _data):
        _fmt += f'III{len(self.name)}sBIB'
        _data.extend([self.pet_number, self.entry, self.level, self.name.encode('utf-8'), 0, self.loyalty, self.slot])
        return _fmt, _data

    def size(self) -> int:
        return 18 + len(self.name)


@dataclasses.dataclass
class TradeSlot:
    trade_slot_number: int
    item: int
    display_id: int
    stack_count: int
    wrapped: bool
    gift_wrapper: int
    enchantment: int
    item_creator: int
    spell_charges: int
    item_suffix_factor: int
    item_random_properties_id: int
    lock_id: int
    max_durability: int
    durability: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> TradeSlot:
        # trade_slot_number: u8
        trade_slot_number = await read_int(reader, 1)

        # item: Item
        item = await read_int(reader, 4)

        # display_id: u32
        display_id = await read_int(reader, 4)

        # stack_count: u32
        stack_count = await read_int(reader, 4)

        # wrapped: Bool32
        wrapped = await read_bool(reader, 4)

        # gift_wrapper: Guid
        gift_wrapper = await read_int(reader, 8)

        # enchantment: u32
        enchantment = await read_int(reader, 4)

        # item_creator: Guid
        item_creator = await read_int(reader, 8)

        # spell_charges: u32
        spell_charges = await read_int(reader, 4)

        # item_suffix_factor: u32
        item_suffix_factor = await read_int(reader, 4)

        # item_random_properties_id: u32
        item_random_properties_id = await read_int(reader, 4)

        # lock_id: u32
        lock_id = await read_int(reader, 4)

        # max_durability: u32
        max_durability = await read_int(reader, 4)

        # durability: u32
        durability = await read_int(reader, 4)

        return TradeSlot(
            trade_slot_number=trade_slot_number,
            item=item,
            display_id=display_id,
            stack_count=stack_count,
            wrapped=wrapped,
            gift_wrapper=gift_wrapper,
            enchantment=enchantment,
            item_creator=item_creator,
            spell_charges=spell_charges,
            item_suffix_factor=item_suffix_factor,
            item_random_properties_id=item_random_properties_id,
            lock_id=lock_id,
            max_durability=max_durability,
            durability=durability,
        )

    def write(self, _fmt, _data):
        _fmt += 'BIIIIQIQIIIIII'
        _data.extend([self.trade_slot_number, self.item, self.display_id, self.stack_count, self.wrapped, self.gift_wrapper, self.enchantment, self.item_creator, self.spell_charges, self.item_suffix_factor, self.item_random_properties_id, self.lock_id, self.max_durability, self.durability])
        return _fmt, _data


@dataclasses.dataclass
class TrainerSpell:
    spell: int
    state: TrainerSpellState
    spell_cost: int
    talent_point_cost: int
    first_rank: int
    required_level: int
    required_skill: Skill
    required_skill_value: int
    required_spells: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> TrainerSpell:
        # spell: Spell
        spell = await read_int(reader, 4)

        # state: TrainerSpellState
        state = TrainerSpellState(await read_int(reader, 1))

        # spell_cost: u32
        spell_cost = await read_int(reader, 4)

        # talent_point_cost: u32
        talent_point_cost = await read_int(reader, 4)

        # first_rank: u32
        first_rank = await read_int(reader, 4)

        # required_level: u8
        required_level = await read_int(reader, 1)

        # required_skill: Skill
        required_skill = Skill(await read_int(reader, 4))

        # required_skill_value: u32
        required_skill_value = await read_int(reader, 4)

        # required_spells: u32[3]
        required_spells = []
        for _ in range(0, 3):
            required_spells.append(await read_int(reader, 4))

        return TrainerSpell(
            spell=spell,
            state=state,
            spell_cost=spell_cost,
            talent_point_cost=talent_point_cost,
            first_rank=first_rank,
            required_level=required_level,
            required_skill=required_skill,
            required_skill_value=required_skill_value,
            required_spells=required_spells,
        )

    def write(self, _fmt, _data):
        _fmt += f'IBIIIBII{len(self.required_spells)}I'
        _data.extend([self.spell, self.state.value, self.spell_cost, self.talent_point_cost, self.first_rank, self.required_level, self.required_skill.value, self.required_skill_value, *self.required_spells])
        return _fmt, _data


@dataclasses.dataclass
class Vector2d:
    x: float
    y: float

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> Vector2d:
        # x: f32
        x = await read_float(reader)

        # y: f32
        y = await read_float(reader)

        return Vector2d(
            x=x,
            y=y,
        )

    def write(self, _fmt, _data):
        _fmt += 'ff'
        _data.extend([self.x, self.y])
        return _fmt, _data


@dataclasses.dataclass
class WhoPlayer:
    name: str
    guild: str
    level: int
    class_type: Class
    race: Race
    area: Area
    party_status: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> WhoPlayer:
        # name: CString
        name = await read_cstring(reader)

        # guild: CString
        guild = await read_cstring(reader)

        # level: Level32
        level = await read_int(reader, 4)

        # class_type: Class
        class_type = Class(await read_int(reader, 1))

        # race: Race
        race = Race(await read_int(reader, 1))

        # area: Area
        area = Area(await read_int(reader, 4))

        # party_status: u32
        party_status = await read_int(reader, 4)

        return WhoPlayer(
            name=name,
            guild=guild,
            level=level,
            class_type=class_type,
            race=race,
            area=area,
            party_status=party_status,
        )

    def write(self, _fmt, _data):
        _fmt += f'{len(self.name)}sB{len(self.guild)}sBIBBII'
        _data.extend([self.name.encode('utf-8'), 0, self.guild.encode('utf-8'), 0, self.level, self.class_type.value, self.race.value, self.area.value, self.party_status])
        return _fmt, _data

    def size(self) -> int:
        return 16 + len(self.name) + len(self.guild)


@dataclasses.dataclass
class WorldState:
    state: int
    value: int

    @staticmethod
    async def read(reader: asyncio.StreamReader) -> WorldState:
        # state: u32
        state = await read_int(reader, 4)

        # value: u32
        value = await read_int(reader, 4)

        return WorldState(
            state=state,
            value=value,
        )

    def write(self, _fmt, _data):
        _fmt += 'II'
        _data.extend([self.state, self.value])
        return _fmt, _data


@dataclasses.dataclass
class CMSG_BOOTME:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BOOTME:
        return CMSG_BOOTME()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0001))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_DBLOOKUP:
    query: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_DBLOOKUP:
        # query: CString
        query = await read_cstring(reader)

        return CMSG_DBLOOKUP(
            query=query,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0002))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.query)}sB'
        _data.extend([self.query.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.query)


@dataclasses.dataclass
class CMSG_WORLD_TELEPORT:
    time: int
    map: Map
    position: Vector3d
    orientation: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_WORLD_TELEPORT:
        # time: Milliseconds
        time = await read_int(reader, 4)

        # map: Map
        map = Map(await read_int(reader, 4))

        # position: Vector3d
        position = await Vector3d.read(reader)

        # orientation: f32
        orientation = await read_float(reader)

        return CMSG_WORLD_TELEPORT(
            time=time,
            map=map,
            position=position,
            orientation=orientation,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(24 + 4, 0x0008))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.time, self.map.value])
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # orientation: f32
        _fmt += 'f'
        _data.append(self.orientation)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TELEPORT_TO_UNIT:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TELEPORT_TO_UNIT:
        # name: CString
        name = await read_cstring(reader)

        return CMSG_TELEPORT_TO_UNIT(
            name=name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0009))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class CMSG_CHAR_CREATE:
    name: str
    race: Race
    class_type: Class
    gender: Gender
    skin_color: int
    face: int
    hair_style: int
    hair_color: int
    facial_hair: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHAR_CREATE:
        # name: CString
        name = await read_cstring(reader)

        # race: Race
        race = Race(await read_int(reader, 1))

        # class_type: Class
        class_type = Class(await read_int(reader, 1))

        # gender: Gender
        gender = Gender(await read_int(reader, 1))

        # skin_color: u8
        skin_color = await read_int(reader, 1)

        # face: u8
        face = await read_int(reader, 1)

        # hair_style: u8
        hair_style = await read_int(reader, 1)

        # hair_color: u8
        hair_color = await read_int(reader, 1)

        # facial_hair: u8
        facial_hair = await read_int(reader, 1)

        # outfit_id: u8
        _outfit_id = await read_int(reader, 1)

        return CMSG_CHAR_CREATE(
            name=name,
            race=race,
            class_type=class_type,
            gender=gender,
            skin_color=skin_color,
            face=face,
            hair_style=hair_style,
            hair_color=hair_color,
            facial_hair=facial_hair,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0036))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sBBBBBBBBBB'
        _data.extend([self.name.encode('utf-8'), 0, self.race.value, self.class_type.value, self.gender.value, self.skin_color, self.face, self.hair_style, self.hair_color, self.facial_hair, 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 10 + len(self.name)


@dataclasses.dataclass
class CMSG_CHAR_ENUM:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHAR_ENUM:
        return CMSG_CHAR_ENUM()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0037))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CHAR_DELETE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHAR_DELETE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_CHAR_DELETE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0038))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CHAR_CREATE:
    result: WorldResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAR_CREATE:
        # result: WorldResult
        result = WorldResult(await read_int(reader, 1))

        return SMSG_CHAR_CREATE(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x003A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CHAR_ENUM:
    characters: typing.List[Character]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAR_ENUM:
        # amount_of_characters: u8
        amount_of_characters = await read_int(reader, 1)

        # characters: Character[amount_of_characters]
        characters = []
        for _ in range(0, amount_of_characters):
            characters.append(await Character.read(reader))

        return SMSG_CHAR_ENUM(
            characters=characters,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x003B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(len(self.characters))
        # characters: Character[amount_of_characters]
        for i in self.characters:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + sum([i.size() for i in self.characters])


@dataclasses.dataclass
class SMSG_CHAR_DELETE:
    result: WorldResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAR_DELETE:
        # result: WorldResult
        result = WorldResult(await read_int(reader, 1))

        return SMSG_CHAR_DELETE(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x003C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PLAYER_LOGIN:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PLAYER_LOGIN:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_PLAYER_LOGIN(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x003D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_NEW_WORLD:
    map: Map
    position: Vector3d
    orientation: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_NEW_WORLD:
        # map: Map
        map = Map(await read_int(reader, 4))

        # position: Vector3d
        position = await Vector3d.read(reader)

        # orientation: f32
        orientation = await read_float(reader)

        return SMSG_NEW_WORLD(
            map=map,
            position=position,
            orientation=orientation,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x003E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # orientation: f32
        _fmt += 'f'
        _data.append(self.orientation)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TRANSFER_PENDING:
    map: Map
    transport: typing.Optional[int] = None
    transport_map: typing.Optional[Map] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRANSFER_PENDING:
        transport = None
        transport_map = None
        _size = 0

        # map: Map
        map = Map(await read_int(reader, 4))
        _size += 4

        # has_transport: optional
        if _size < body_size:
            # transport: u32
            transport = await read_int(reader, 4)
            _size += 4

            # transport_map: Map
            transport_map = Map(await read_int(reader, 4))
            _size += 4

        return SMSG_TRANSFER_PENDING(
            map=map,
            transport=transport,
            transport_map=transport_map,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x003F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        # has_transport: optional
        if self.transport is not None and self.transport_map is not None:
            _fmt += 'II'
            _data.extend([self.transport, self.transport_map.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        # has_transport: optional
        if self.transport is not None and self.transport_map is not None:
            _size += 8

        return _size


@dataclasses.dataclass
class SMSG_TRANSFER_ABORTED:
    map: Map
    reason: TransferAbortReason
    argument: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRANSFER_ABORTED:
        # map: Map
        map = Map(await read_int(reader, 4))

        # reason: TransferAbortReason
        reason = TransferAbortReason(await read_int(reader, 1))

        # argument: u8
        argument = await read_int(reader, 1)

        return SMSG_TRANSFER_ABORTED(
            map=map,
            reason=reason,
            argument=argument,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(6 + 2, 0x0040))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IBB'
        _data.extend([self.map.value, self.reason.value, self.argument])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CHARACTER_LOGIN_FAILED:
    result: WorldResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHARACTER_LOGIN_FAILED:
        # result: WorldResult
        result = WorldResult(await read_int(reader, 1))

        return SMSG_CHARACTER_LOGIN_FAILED(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x0041))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOGIN_SETTIMESPEED:
    datetime: int
    timescale: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOGIN_SETTIMESPEED:
        # datetime: DateTime
        datetime = await read_int(reader, 4)

        # timescale: f32
        timescale = await read_float(reader)

        return SMSG_LOGIN_SETTIMESPEED(
            datetime=datetime,
            timescale=timescale,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0042))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'If'
        _data.extend([self.datetime, self.timescale])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PLAYER_LOGOUT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PLAYER_LOGOUT:
        return CMSG_PLAYER_LOGOUT()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x004A))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LOGOUT_REQUEST:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOGOUT_REQUEST:
        return CMSG_LOGOUT_REQUEST()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x004B))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOGOUT_RESPONSE:
    result: LogoutResult
    speed: LogoutSpeed

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOGOUT_RESPONSE:
        # result: LogoutResult
        result = LogoutResult(await read_int(reader, 4))

        # speed: LogoutSpeed
        speed = LogoutSpeed(await read_int(reader, 1))

        return SMSG_LOGOUT_RESPONSE(
            result=result,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x004C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([self.result.value, self.speed.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOGOUT_COMPLETE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOGOUT_COMPLETE:
        return SMSG_LOGOUT_COMPLETE()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x004D))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LOGOUT_CANCEL:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOGOUT_CANCEL:
        return CMSG_LOGOUT_CANCEL()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x004E))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOGOUT_CANCEL_ACK:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOGOUT_CANCEL_ACK:
        return SMSG_LOGOUT_CANCEL_ACK()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x004F))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_NAME_QUERY:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_NAME_QUERY:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_NAME_QUERY(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0050))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_NAME_QUERY_RESPONSE:
    guid: int
    character_name: str
    realm_name: str
    race: Race
    gender: Gender
    class_type: Class

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_NAME_QUERY_RESPONSE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # character_name: CString
        character_name = await read_cstring(reader)

        # realm_name: CString
        realm_name = await read_cstring(reader)

        # race: Race
        race = Race(await read_int(reader, 4))

        # gender: Gender
        gender = Gender(await read_int(reader, 4))

        # class_type: Class
        class_type = Class(await read_int(reader, 4))

        return SMSG_NAME_QUERY_RESPONSE(
            guid=guid,
            character_name=character_name,
            realm_name=realm_name,
            race=race,
            gender=gender,
            class_type=class_type,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0051))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'Q{len(self.character_name)}sB{len(self.realm_name)}sBIII'
        _data.extend([self.guid, self.character_name.encode('utf-8'), 0, self.realm_name.encode('utf-8'), 0, self.race.value, self.gender.value, self.class_type.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 22 + len(self.character_name) + len(self.realm_name)


@dataclasses.dataclass
class CMSG_PET_NAME_QUERY:
    pet_number: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_NAME_QUERY:
        # pet_number: u32
        pet_number = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_PET_NAME_QUERY(
            pet_number=pet_number,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0052))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.pet_number, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PET_NAME_QUERY_RESPONSE:
    pet_number: int
    name: str
    pet_name_timestamp: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_NAME_QUERY_RESPONSE:
        # pet_number: u32
        pet_number = await read_int(reader, 4)

        # name: CString
        name = await read_cstring(reader)

        # pet_name_timestamp: u32
        pet_name_timestamp = await read_int(reader, 4)

        return SMSG_PET_NAME_QUERY_RESPONSE(
            pet_number=pet_number,
            name=name,
            pet_name_timestamp=pet_name_timestamp,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0053))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.name)}sBI'
        _data.extend([self.pet_number, self.name.encode('utf-8'), 0, self.pet_name_timestamp])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.name)


@dataclasses.dataclass
class CMSG_GUILD_QUERY:
    guild_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_QUERY:
        # guild_id: u32
        guild_id = await read_int(reader, 4)

        return CMSG_GUILD_QUERY(
            guild_id=guild_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0054))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.guild_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GUILD_QUERY_RESPONSE:
    id: int
    name: str
    rank_names: typing.List[str]
    emblem_style: int
    emblem_color: int
    border_style: int
    border_color: int
    background_color: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_QUERY_RESPONSE:
        # id: u32
        id = await read_int(reader, 4)

        # name: CString
        name = await read_cstring(reader)

        # rank_names: CString[10]
        rank_names = []
        for _ in range(0, 10):
            rank_names.append(await read_cstring(reader))

        # emblem_style: u32
        emblem_style = await read_int(reader, 4)

        # emblem_color: u32
        emblem_color = await read_int(reader, 4)

        # border_style: u32
        border_style = await read_int(reader, 4)

        # border_color: u32
        border_color = await read_int(reader, 4)

        # background_color: u32
        background_color = await read_int(reader, 4)

        return SMSG_GUILD_QUERY_RESPONSE(
            id=id,
            name=name,
            rank_names=rank_names,
            emblem_style=emblem_style,
            emblem_color=emblem_color,
            border_style=border_style,
            border_color=border_color,
            background_color=background_color,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0055))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.name)}sB'
        _data.extend([self.id, self.name.encode('utf-8'), 0])
        # rank_names: CString[10]
        for i in self.rank_names:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        # emblem_style: u32
        _fmt += 'I'
        _data.append(self.emblem_style)

        # emblem_color: u32
        _fmt += 'I'
        _data.append(self.emblem_color)

        # border_style: u32
        _fmt += 'I'
        _data.append(self.border_style)

        # border_color: u32
        _fmt += 'I'
        _data.append(self.border_color)

        # background_color: u32
        _fmt += 'I'
        _data.append(self.background_color)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 25 + len(self.name) + sum([len(i) + 1 for i in self.rank_names])


@dataclasses.dataclass
class CMSG_ITEM_QUERY_SINGLE:
    item: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ITEM_QUERY_SINGLE:
        # item: Item
        item = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_ITEM_QUERY_SINGLE(
            item=item,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0056))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.item, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_QUERY_SINGLE_RESPONSE:
    item: int
    class_and_sub_class: typing.Optional[ItemClassAndSubClass] = None
    name1: typing.Optional[str] = None
    name2: typing.Optional[str] = None
    name3: typing.Optional[str] = None
    name4: typing.Optional[str] = None
    display_id: typing.Optional[int] = None
    quality: typing.Optional[ItemQuality] = None
    flags: typing.Optional[ItemFlag] = None
    buy_price: typing.Optional[int] = None
    sell_price: typing.Optional[int] = None
    inventory_type: typing.Optional[InventoryType] = None
    allowed_class: typing.Optional[AllowedClass] = None
    allowed_race: typing.Optional[AllowedRace] = None
    item_level: typing.Optional[int] = None
    required_level: typing.Optional[int] = None
    required_skill: typing.Optional[Skill] = None
    required_skill_rank: typing.Optional[int] = None
    required_spell: typing.Optional[int] = None
    required_honor_rank: typing.Optional[int] = None
    required_city_rank: typing.Optional[int] = None
    required_faction: typing.Optional[Faction] = None
    required_faction_rank: typing.Optional[int] = None
    max_count: typing.Optional[int] = None
    stackable: typing.Optional[int] = None
    container_slots: typing.Optional[int] = None
    stats: typing.Optional[typing.List[ItemStat]] = None
    damages: typing.Optional[typing.List[ItemDamageType]] = None
    armor: typing.Optional[int] = None
    holy_resistance: typing.Optional[int] = None
    fire_resistance: typing.Optional[int] = None
    nature_resistance: typing.Optional[int] = None
    frost_resistance: typing.Optional[int] = None
    shadow_resistance: typing.Optional[int] = None
    arcane_resistance: typing.Optional[int] = None
    delay: typing.Optional[int] = None
    ammo_type: typing.Optional[int] = None
    ranged_range_modification: typing.Optional[float] = None
    spells: typing.Optional[typing.List[ItemSpells]] = None
    bonding: typing.Optional[Bonding] = None
    description: typing.Optional[str] = None
    page_text: typing.Optional[int] = None
    language: typing.Optional[Language] = None
    page_text_material: typing.Optional[PageTextMaterial] = None
    start_quest: typing.Optional[int] = None
    lock_id: typing.Optional[int] = None
    material: typing.Optional[int] = None
    sheathe_type: typing.Optional[SheatheType] = None
    random_property: typing.Optional[int] = None
    block: typing.Optional[int] = None
    item_set: typing.Optional[ItemSet] = None
    max_durability: typing.Optional[int] = None
    area: typing.Optional[Area] = None
    map: typing.Optional[Map] = None
    bag_family: typing.Optional[BagFamily] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_QUERY_SINGLE_RESPONSE:
        class_and_sub_class = None
        name1 = None
        name2 = None
        name3 = None
        name4 = None
        display_id = None
        quality = None
        flags = None
        buy_price = None
        sell_price = None
        inventory_type = None
        allowed_class = None
        allowed_race = None
        item_level = None
        required_level = None
        required_skill = None
        required_skill_rank = None
        required_spell = None
        required_honor_rank = None
        required_city_rank = None
        required_faction = None
        required_faction_rank = None
        max_count = None
        stackable = None
        container_slots = None
        stats = None
        damages = None
        armor = None
        holy_resistance = None
        fire_resistance = None
        nature_resistance = None
        frost_resistance = None
        shadow_resistance = None
        arcane_resistance = None
        delay = None
        ammo_type = None
        ranged_range_modification = None
        spells = None
        bonding = None
        description = None
        page_text = None
        language = None
        page_text_material = None
        start_quest = None
        lock_id = None
        material = None
        sheathe_type = None
        random_property = None
        block = None
        item_set = None
        max_durability = None
        area = None
        map = None
        bag_family = None
        _size = 0

        # item: Item
        item = await read_int(reader, 4)
        _size += 4

        # found: optional
        if _size < body_size:
            # class_and_sub_class: ItemClassAndSubClass
            class_and_sub_class = ItemClassAndSubClass(await read_int(reader, 8))
            _size += 8

            # name1: CString
            name1 = await read_cstring(reader)
            _size += len(name1) + 1

            # name2: CString
            name2 = await read_cstring(reader)
            _size += len(name2) + 1

            # name3: CString
            name3 = await read_cstring(reader)
            _size += len(name3) + 1

            # name4: CString
            name4 = await read_cstring(reader)
            _size += len(name4) + 1

            # display_id: u32
            display_id = await read_int(reader, 4)
            _size += 4

            # quality: ItemQuality
            quality = ItemQuality(await read_int(reader, 4))
            _size += 4

            # flags: ItemFlag
            flags = ItemFlag(await read_int(reader, 4))
            _size += 4

            # buy_price: Gold
            buy_price = await read_int(reader, 4)
            _size += 4

            # sell_price: Gold
            sell_price = await read_int(reader, 4)
            _size += 4

            # inventory_type: InventoryType
            inventory_type = InventoryType(await read_int(reader, 4))
            _size += 4

            # allowed_class: AllowedClass
            allowed_class = AllowedClass(await read_int(reader, 4))
            _size += 4

            # allowed_race: AllowedRace
            allowed_race = AllowedRace(await read_int(reader, 4))
            _size += 4

            # item_level: Level32
            item_level = await read_int(reader, 4)
            _size += 4

            # required_level: Level32
            required_level = await read_int(reader, 4)
            _size += 4

            # required_skill: Skill
            required_skill = Skill(await read_int(reader, 4))
            _size += 4

            # required_skill_rank: u32
            required_skill_rank = await read_int(reader, 4)
            _size += 4

            # required_spell: Spell
            required_spell = await read_int(reader, 4)
            _size += 4

            # required_honor_rank: u32
            required_honor_rank = await read_int(reader, 4)
            _size += 4

            # required_city_rank: u32
            required_city_rank = await read_int(reader, 4)
            _size += 4

            # required_faction: Faction
            required_faction = Faction(await read_int(reader, 4))
            _size += 4

            # required_faction_rank: u32
            required_faction_rank = await read_int(reader, 4)
            _size += 4

            # max_count: u32
            max_count = await read_int(reader, 4)
            _size += 4

            # stackable: u32
            stackable = await read_int(reader, 4)
            _size += 4

            # container_slots: u32
            container_slots = await read_int(reader, 4)
            _size += 4

            # stats: ItemStat[10]
            stats = []
            for _ in range(0, 10):
                stats.append(await ItemStat.read(reader))
                _size += 8

            # damages: ItemDamageType[5]
            damages = []
            for _ in range(0, 5):
                damages.append(await ItemDamageType.read(reader))
                _size += 12

            # armor: i32
            armor = await read_int(reader, 4)
            _size += 4

            # holy_resistance: i32
            holy_resistance = await read_int(reader, 4)
            _size += 4

            # fire_resistance: i32
            fire_resistance = await read_int(reader, 4)
            _size += 4

            # nature_resistance: i32
            nature_resistance = await read_int(reader, 4)
            _size += 4

            # frost_resistance: i32
            frost_resistance = await read_int(reader, 4)
            _size += 4

            # shadow_resistance: i32
            shadow_resistance = await read_int(reader, 4)
            _size += 4

            # arcane_resistance: i32
            arcane_resistance = await read_int(reader, 4)
            _size += 4

            # delay: u32
            delay = await read_int(reader, 4)
            _size += 4

            # ammo_type: u32
            ammo_type = await read_int(reader, 4)
            _size += 4

            # ranged_range_modification: f32
            ranged_range_modification = await read_float(reader)
            _size += 4

            # spells: ItemSpells[5]
            spells = []
            for _ in range(0, 5):
                spells.append(await ItemSpells.read(reader))
                _size += 24

            # bonding: Bonding
            bonding = Bonding(await read_int(reader, 4))
            _size += 4

            # description: CString
            description = await read_cstring(reader)
            _size += len(description) + 1

            # page_text: u32
            page_text = await read_int(reader, 4)
            _size += 4

            # language: Language
            language = Language(await read_int(reader, 4))
            _size += 4

            # page_text_material: PageTextMaterial
            page_text_material = PageTextMaterial(await read_int(reader, 4))
            _size += 4

            # start_quest: u32
            start_quest = await read_int(reader, 4)
            _size += 4

            # lock_id: u32
            lock_id = await read_int(reader, 4)
            _size += 4

            # material: u32
            material = await read_int(reader, 4)
            _size += 4

            # sheathe_type: SheatheType
            sheathe_type = SheatheType(await read_int(reader, 4))
            _size += 4

            # random_property: u32
            random_property = await read_int(reader, 4)
            _size += 4

            # block: u32
            block = await read_int(reader, 4)
            _size += 4

            # item_set: ItemSet
            item_set = ItemSet(await read_int(reader, 4))
            _size += 4

            # max_durability: u32
            max_durability = await read_int(reader, 4)
            _size += 4

            # area: Area
            area = Area(await read_int(reader, 4))
            _size += 4

            # map: Map
            map = Map(await read_int(reader, 4))
            _size += 4

            # bag_family: BagFamily
            bag_family = BagFamily(await read_int(reader, 4))
            _size += 4

        return SMSG_ITEM_QUERY_SINGLE_RESPONSE(
            item=item,
            class_and_sub_class=class_and_sub_class,
            name1=name1,
            name2=name2,
            name3=name3,
            name4=name4,
            display_id=display_id,
            quality=quality,
            flags=flags,
            buy_price=buy_price,
            sell_price=sell_price,
            inventory_type=inventory_type,
            allowed_class=allowed_class,
            allowed_race=allowed_race,
            item_level=item_level,
            required_level=required_level,
            required_skill=required_skill,
            required_skill_rank=required_skill_rank,
            required_spell=required_spell,
            required_honor_rank=required_honor_rank,
            required_city_rank=required_city_rank,
            required_faction=required_faction,
            required_faction_rank=required_faction_rank,
            max_count=max_count,
            stackable=stackable,
            container_slots=container_slots,
            stats=stats,
            damages=damages,
            armor=armor,
            holy_resistance=holy_resistance,
            fire_resistance=fire_resistance,
            nature_resistance=nature_resistance,
            frost_resistance=frost_resistance,
            shadow_resistance=shadow_resistance,
            arcane_resistance=arcane_resistance,
            delay=delay,
            ammo_type=ammo_type,
            ranged_range_modification=ranged_range_modification,
            spells=spells,
            bonding=bonding,
            description=description,
            page_text=page_text,
            language=language,
            page_text_material=page_text_material,
            start_quest=start_quest,
            lock_id=lock_id,
            material=material,
            sheathe_type=sheathe_type,
            random_property=random_property,
            block=block,
            item_set=item_set,
            max_durability=max_durability,
            area=area,
            map=map,
            bag_family=bag_family,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0058))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.item)
        # found: optional
        if self.class_and_sub_class is not None and self.name1 is not None and self.name2 is not None and self.name3 is not None and self.name4 is not None and self.display_id is not None and self.quality is not None and self.flags is not None and self.buy_price is not None and self.sell_price is not None and self.inventory_type is not None and self.allowed_class is not None and self.allowed_race is not None and self.item_level is not None and self.required_level is not None and self.required_skill is not None and self.required_skill_rank is not None and self.required_spell is not None and self.required_honor_rank is not None and self.required_city_rank is not None and self.required_faction is not None and self.required_faction_rank is not None and self.max_count is not None and self.stackable is not None and self.container_slots is not None and self.stats is not None and self.damages is not None and self.armor is not None and self.holy_resistance is not None and self.fire_resistance is not None and self.nature_resistance is not None and self.frost_resistance is not None and self.shadow_resistance is not None and self.arcane_resistance is not None and self.delay is not None and self.ammo_type is not None and self.ranged_range_modification is not None and self.spells is not None and self.bonding is not None and self.description is not None and self.page_text is not None and self.language is not None and self.page_text_material is not None and self.start_quest is not None and self.lock_id is not None and self.material is not None and self.sheathe_type is not None and self.random_property is not None and self.block is not None and self.item_set is not None and self.max_durability is not None and self.area is not None and self.map is not None and self.bag_family is not None:
            _fmt += f'Q{len(self.name1)}sB{len(self.name2)}sB{len(self.name3)}sB{len(self.name4)}sBIIIIIIIIIIIIIIIIIIII'
            _data.extend([self.class_and_sub_class.value, self.name1.encode('utf-8'), 0, self.name2.encode('utf-8'), 0, self.name3.encode('utf-8'), 0, self.name4.encode('utf-8'), 0, self.display_id, self.quality.value, self.flags.value, self.buy_price, self.sell_price, self.inventory_type.value, self.allowed_class.value, self.allowed_race.value, self.item_level, self.required_level, self.required_skill.value, self.required_skill_rank, self.required_spell, self.required_honor_rank, self.required_city_rank, self.required_faction.value, self.required_faction_rank, self.max_count, self.stackable, self.container_slots])
            # stats: ItemStat[10]
            for i in self.stats:
                _fmt, _data = i.write(_fmt, _data)

            # damages: ItemDamageType[5]
            for i in self.damages:
                _fmt, _data = i.write(_fmt, _data)

            # armor: i32
            _fmt += 'i'
            _data.append(self.armor)

            # holy_resistance: i32
            _fmt += 'i'
            _data.append(self.holy_resistance)

            # fire_resistance: i32
            _fmt += 'i'
            _data.append(self.fire_resistance)

            # nature_resistance: i32
            _fmt += 'i'
            _data.append(self.nature_resistance)

            # frost_resistance: i32
            _fmt += 'i'
            _data.append(self.frost_resistance)

            # shadow_resistance: i32
            _fmt += 'i'
            _data.append(self.shadow_resistance)

            # arcane_resistance: i32
            _fmt += 'i'
            _data.append(self.arcane_resistance)

            # delay: u32
            _fmt += 'I'
            _data.append(self.delay)

            # ammo_type: u32
            _fmt += 'I'
            _data.append(self.ammo_type)

            # ranged_range_modification: f32
            _fmt += 'f'
            _data.append(self.ranged_range_modification)

            # spells: ItemSpells[5]
            for i in self.spells:
                _fmt, _data = i.write(_fmt, _data)

            # bonding: Bonding
            _fmt += 'I'
            _data.append(self.bonding.value)

            # description: CString
            _fmt += f'{len(self.description)}sB'
            _data.extend([self.description.encode('utf-8'), 0])

            # page_text: u32
            _fmt += 'I'
            _data.append(self.page_text)

            # language: Language
            _fmt += 'I'
            _data.append(self.language.value)

            # page_text_material: PageTextMaterial
            _fmt += 'I'
            _data.append(self.page_text_material.value)

            # start_quest: u32
            _fmt += 'I'
            _data.append(self.start_quest)

            # lock_id: u32
            _fmt += 'I'
            _data.append(self.lock_id)

            # material: u32
            _fmt += 'I'
            _data.append(self.material)

            # sheathe_type: SheatheType
            _fmt += 'I'
            _data.append(self.sheathe_type.value)

            # random_property: u32
            _fmt += 'I'
            _data.append(self.random_property)

            # block: u32
            _fmt += 'I'
            _data.append(self.block)

            # item_set: ItemSet
            _fmt += 'I'
            _data.append(self.item_set.value)

            # max_durability: u32
            _fmt += 'I'
            _data.append(self.max_durability)

            # area: Area
            _fmt += 'I'
            _data.append(self.area.value)

            # map: Map
            _fmt += 'I'
            _data.append(self.map.value)

            # bag_family: BagFamily
            _fmt += 'I'
            _data.append(self.bag_family.value)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        # found: optional
        if self.class_and_sub_class is not None and self.name1 is not None and self.name2 is not None and self.name3 is not None and self.name4 is not None and self.display_id is not None and self.quality is not None and self.flags is not None and self.buy_price is not None and self.sell_price is not None and self.inventory_type is not None and self.allowed_class is not None and self.allowed_race is not None and self.item_level is not None and self.required_level is not None and self.required_skill is not None and self.required_skill_rank is not None and self.required_spell is not None and self.required_honor_rank is not None and self.required_city_rank is not None and self.required_faction is not None and self.required_faction_rank is not None and self.max_count is not None and self.stackable is not None and self.container_slots is not None and self.stats is not None and self.damages is not None and self.armor is not None and self.holy_resistance is not None and self.fire_resistance is not None and self.nature_resistance is not None and self.frost_resistance is not None and self.shadow_resistance is not None and self.arcane_resistance is not None and self.delay is not None and self.ammo_type is not None and self.ranged_range_modification is not None and self.spells is not None and self.bonding is not None and self.description is not None and self.page_text is not None and self.language is not None and self.page_text_material is not None and self.start_quest is not None and self.lock_id is not None and self.material is not None and self.sheathe_type is not None and self.random_property is not None and self.block is not None and self.item_set is not None and self.max_durability is not None and self.area is not None and self.map is not None and self.bag_family is not None:
            _size += 453 + len(self.name1) + len(self.name2) + len(self.name3) + len(self.name4) + len(self.description)

        return _size


@dataclasses.dataclass
class CMSG_PAGE_TEXT_QUERY:
    page_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PAGE_TEXT_QUERY:
        # page_id: u32
        page_id = await read_int(reader, 4)

        return CMSG_PAGE_TEXT_QUERY(
            page_id=page_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x005A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.page_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PAGE_TEXT_QUERY_RESPONSE:
    page_id: int
    text: str
    next_page_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PAGE_TEXT_QUERY_RESPONSE:
        # page_id: u32
        page_id = await read_int(reader, 4)

        # text: CString
        text = await read_cstring(reader)

        # next_page_id: u32
        next_page_id = await read_int(reader, 4)

        return SMSG_PAGE_TEXT_QUERY_RESPONSE(
            page_id=page_id,
            text=text,
            next_page_id=next_page_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x005B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.text)}sBI'
        _data.extend([self.page_id, self.text.encode('utf-8'), 0, self.next_page_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.text)


@dataclasses.dataclass
class CMSG_QUEST_QUERY:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUEST_QUERY:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return CMSG_QUEST_QUERY(
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x005C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.quest_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUEST_QUERY_RESPONSE:
    quest_id: int
    quest_method: int
    quest_level: int
    zone_or_sort: int
    quest_type: int
    reputation_objective_faction: Faction
    reputation_objective_value: int
    required_opposite_faction: Faction
    required_opposite_reputation_value: int
    next_quest_in_chain: int
    money_reward: int
    max_level_money_reward: int
    reward_spell: int
    source_item_id: int
    quest_flags: int
    rewards: typing.List[QuestItemReward]
    choice_rewards: typing.List[QuestItemReward]
    point_map_id: int
    position: Vector2d
    point_opt: int
    title: str
    objective_text: str
    details: str
    end_text: str
    objectives: typing.List[QuestObjective]
    objective_texts: typing.List[str]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUEST_QUERY_RESPONSE:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # quest_method: u32
        quest_method = await read_int(reader, 4)

        # quest_level: Level32
        quest_level = await read_int(reader, 4)

        # zone_or_sort: u32
        zone_or_sort = await read_int(reader, 4)

        # quest_type: u32
        quest_type = await read_int(reader, 4)

        # reputation_objective_faction: Faction
        reputation_objective_faction = Faction(await read_int(reader, 2))

        # reputation_objective_value: u32
        reputation_objective_value = await read_int(reader, 4)

        # required_opposite_faction: Faction
        required_opposite_faction = Faction(await read_int(reader, 2))

        # required_opposite_reputation_value: u32
        required_opposite_reputation_value = await read_int(reader, 4)

        # next_quest_in_chain: u32
        next_quest_in_chain = await read_int(reader, 4)

        # money_reward: Gold
        money_reward = await read_int(reader, 4)

        # max_level_money_reward: Gold
        max_level_money_reward = await read_int(reader, 4)

        # reward_spell: u32
        reward_spell = await read_int(reader, 4)

        # source_item_id: u32
        source_item_id = await read_int(reader, 4)

        # quest_flags: u32
        quest_flags = await read_int(reader, 4)

        # rewards: QuestItemReward[4]
        rewards = []
        for _ in range(0, 4):
            rewards.append(await QuestItemReward.read(reader))

        # choice_rewards: QuestItemReward[6]
        choice_rewards = []
        for _ in range(0, 6):
            choice_rewards.append(await QuestItemReward.read(reader))

        # point_map_id: u32
        point_map_id = await read_int(reader, 4)

        # position: Vector2d
        position = await Vector2d.read(reader)

        # point_opt: u32
        point_opt = await read_int(reader, 4)

        # title: CString
        title = await read_cstring(reader)

        # objective_text: CString
        objective_text = await read_cstring(reader)

        # details: CString
        details = await read_cstring(reader)

        # end_text: CString
        end_text = await read_cstring(reader)

        # objectives: QuestObjective[4]
        objectives = []
        for _ in range(0, 4):
            objectives.append(await QuestObjective.read(reader))

        # objective_texts: CString[4]
        objective_texts = []
        for _ in range(0, 4):
            objective_texts.append(await read_cstring(reader))

        return SMSG_QUEST_QUERY_RESPONSE(
            quest_id=quest_id,
            quest_method=quest_method,
            quest_level=quest_level,
            zone_or_sort=zone_or_sort,
            quest_type=quest_type,
            reputation_objective_faction=reputation_objective_faction,
            reputation_objective_value=reputation_objective_value,
            required_opposite_faction=required_opposite_faction,
            required_opposite_reputation_value=required_opposite_reputation_value,
            next_quest_in_chain=next_quest_in_chain,
            money_reward=money_reward,
            max_level_money_reward=max_level_money_reward,
            reward_spell=reward_spell,
            source_item_id=source_item_id,
            quest_flags=quest_flags,
            rewards=rewards,
            choice_rewards=choice_rewards,
            point_map_id=point_map_id,
            position=position,
            point_opt=point_opt,
            title=title,
            objective_text=objective_text,
            details=details,
            end_text=end_text,
            objectives=objectives,
            objective_texts=objective_texts,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x005D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIIIHIHIIIIIII'
        _data.extend([self.quest_id, self.quest_method, self.quest_level, self.zone_or_sort, self.quest_type, self.reputation_objective_faction.value, self.reputation_objective_value, self.required_opposite_faction.value, self.required_opposite_reputation_value, self.next_quest_in_chain, self.money_reward, self.max_level_money_reward, self.reward_spell, self.source_item_id, self.quest_flags])
        # rewards: QuestItemReward[4]
        for i in self.rewards:
            _fmt, _data = i.write(_fmt, _data)

        # choice_rewards: QuestItemReward[6]
        for i in self.choice_rewards:
            _fmt, _data = i.write(_fmt, _data)

        # point_map_id: u32
        _fmt += 'I'
        _data.append(self.point_map_id)

        # position: Vector2d
        _fmt, _data = self.position.write(_fmt, _data)

        # point_opt: u32
        _fmt += 'I'
        _data.append(self.point_opt)

        # title: CString
        _fmt += f'{len(self.title)}sB'
        _data.extend([self.title.encode('utf-8'), 0])

        # objective_text: CString
        _fmt += f'{len(self.objective_text)}sB'
        _data.extend([self.objective_text.encode('utf-8'), 0])

        # details: CString
        _fmt += f'{len(self.details)}sB'
        _data.extend([self.details.encode('utf-8'), 0])

        # end_text: CString
        _fmt += f'{len(self.end_text)}sB'
        _data.extend([self.end_text.encode('utf-8'), 0])

        # objectives: QuestObjective[4]
        for i in self.objectives:
            _fmt, _data = i.write(_fmt, _data)

        # objective_texts: CString[4]
        for i in self.objective_texts:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 220 + len(self.title) + len(self.objective_text) + len(self.details) + len(self.end_text) + sum([len(i) + 1 for i in self.objective_texts])


@dataclasses.dataclass
class CMSG_GAMEOBJECT_QUERY:
    entry_id: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GAMEOBJECT_QUERY:
        # entry_id: u32
        entry_id = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_GAMEOBJECT_QUERY(
            entry_id=entry_id,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x005E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.entry_id, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GAMEOBJECT_QUERY_RESPONSE:
    entry_id: int
    info_type: typing.Optional[int] = None
    display_id: typing.Optional[int] = None
    name1: typing.Optional[str] = None
    name2: typing.Optional[str] = None
    name3: typing.Optional[str] = None
    name4: typing.Optional[str] = None
    name5: typing.Optional[str] = None
    raw_data: typing.Optional[typing.List[int]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GAMEOBJECT_QUERY_RESPONSE:
        info_type = None
        display_id = None
        name1 = None
        name2 = None
        name3 = None
        name4 = None
        name5 = None
        raw_data = None
        _size = 0

        # entry_id: u32
        entry_id = await read_int(reader, 4)
        _size += 4

        # found: optional
        if _size < body_size:
            # info_type: u32
            info_type = await read_int(reader, 4)
            _size += 4

            # display_id: u32
            display_id = await read_int(reader, 4)
            _size += 4

            # name1: CString
            name1 = await read_cstring(reader)
            _size += len(name1) + 1

            # name2: CString
            name2 = await read_cstring(reader)
            _size += len(name2) + 1

            # name3: CString
            name3 = await read_cstring(reader)
            _size += len(name3) + 1

            # name4: CString
            name4 = await read_cstring(reader)
            _size += len(name4) + 1

            # name5: CString
            name5 = await read_cstring(reader)
            _size += len(name5) + 1

            # raw_data: u32[6]
            raw_data = []
            for _ in range(0, 6):
                raw_data.append(await read_int(reader, 4))
                _size += 4

        return SMSG_GAMEOBJECT_QUERY_RESPONSE(
            entry_id=entry_id,
            info_type=info_type,
            display_id=display_id,
            name1=name1,
            name2=name2,
            name3=name3,
            name4=name4,
            name5=name5,
            raw_data=raw_data,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x005F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.entry_id)
        # found: optional
        if self.info_type is not None and self.display_id is not None and self.name1 is not None and self.name2 is not None and self.name3 is not None and self.name4 is not None and self.name5 is not None and self.raw_data is not None:
            _fmt += f'II{len(self.name1)}sB{len(self.name2)}sB{len(self.name3)}sB{len(self.name4)}sB{len(self.name5)}sB{len(self.raw_data)}I'
            _data.extend([self.info_type, self.display_id, self.name1.encode('utf-8'), 0, self.name2.encode('utf-8'), 0, self.name3.encode('utf-8'), 0, self.name4.encode('utf-8'), 0, self.name5.encode('utf-8'), 0, *self.raw_data])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        # found: optional
        if self.info_type is not None and self.display_id is not None and self.name1 is not None and self.name2 is not None and self.name3 is not None and self.name4 is not None and self.name5 is not None and self.raw_data is not None:
            _size += 37 + len(self.name1) + len(self.name2) + len(self.name3) + len(self.name4) + len(self.name5)

        return _size


@dataclasses.dataclass
class CMSG_CREATURE_QUERY:
    creature: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CREATURE_QUERY:
        # creature: u32
        creature = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_CREATURE_QUERY(
            creature=creature,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0060))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.creature, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CREATURE_QUERY_RESPONSE:
    creature_entry: int
    name1: typing.Optional[str] = None
    name2: typing.Optional[str] = None
    name3: typing.Optional[str] = None
    name4: typing.Optional[str] = None
    sub_name: typing.Optional[str] = None
    type_flags: typing.Optional[int] = None
    creature_type: typing.Optional[int] = None
    creature_family: typing.Optional[CreatureFamily] = None
    creature_rank: typing.Optional[int] = None
    unknown0: typing.Optional[int] = None
    spell_data_id: typing.Optional[int] = None
    display_id: typing.Optional[int] = None
    civilian: typing.Optional[int] = None
    racial_leader: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CREATURE_QUERY_RESPONSE:
        name1 = None
        name2 = None
        name3 = None
        name4 = None
        sub_name = None
        type_flags = None
        creature_type = None
        creature_family = None
        creature_rank = None
        unknown0 = None
        spell_data_id = None
        display_id = None
        civilian = None
        racial_leader = None
        _size = 0

        # creature_entry: u32
        creature_entry = await read_int(reader, 4)
        _size += 4

        # found: optional
        if _size < body_size:
            # name1: CString
            name1 = await read_cstring(reader)
            _size += len(name1) + 1

            # name2: CString
            name2 = await read_cstring(reader)
            _size += len(name2) + 1

            # name3: CString
            name3 = await read_cstring(reader)
            _size += len(name3) + 1

            # name4: CString
            name4 = await read_cstring(reader)
            _size += len(name4) + 1

            # sub_name: CString
            sub_name = await read_cstring(reader)
            _size += len(sub_name) + 1

            # type_flags: u32
            type_flags = await read_int(reader, 4)
            _size += 4

            # creature_type: u32
            creature_type = await read_int(reader, 4)
            _size += 4

            # creature_family: CreatureFamily
            creature_family = CreatureFamily(await read_int(reader, 4))
            _size += 4

            # creature_rank: u32
            creature_rank = await read_int(reader, 4)
            _size += 4

            # unknown0: u32
            unknown0 = await read_int(reader, 4)
            _size += 4

            # spell_data_id: u32
            spell_data_id = await read_int(reader, 4)
            _size += 4

            # display_id: u32
            display_id = await read_int(reader, 4)
            _size += 4

            # civilian: u8
            civilian = await read_int(reader, 1)
            _size += 1

            # racial_leader: u8
            racial_leader = await read_int(reader, 1)
            _size += 1

        return SMSG_CREATURE_QUERY_RESPONSE(
            creature_entry=creature_entry,
            name1=name1,
            name2=name2,
            name3=name3,
            name4=name4,
            sub_name=sub_name,
            type_flags=type_flags,
            creature_type=creature_type,
            creature_family=creature_family,
            creature_rank=creature_rank,
            unknown0=unknown0,
            spell_data_id=spell_data_id,
            display_id=display_id,
            civilian=civilian,
            racial_leader=racial_leader,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0061))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.creature_entry)
        # found: optional
        if self.name1 is not None and self.name2 is not None and self.name3 is not None and self.name4 is not None and self.sub_name is not None and self.type_flags is not None and self.creature_type is not None and self.creature_family is not None and self.creature_rank is not None and self.unknown0 is not None and self.spell_data_id is not None and self.display_id is not None and self.civilian is not None and self.racial_leader is not None:
            _fmt += f'{len(self.name1)}sB{len(self.name2)}sB{len(self.name3)}sB{len(self.name4)}sB{len(self.sub_name)}sBIIIIIIIBB'
            _data.extend([self.name1.encode('utf-8'), 0, self.name2.encode('utf-8'), 0, self.name3.encode('utf-8'), 0, self.name4.encode('utf-8'), 0, self.sub_name.encode('utf-8'), 0, self.type_flags, self.creature_type, self.creature_family.value, self.creature_rank, self.unknown0, self.spell_data_id, self.display_id, self.civilian, self.racial_leader])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        # found: optional
        if self.name1 is not None and self.name2 is not None and self.name3 is not None and self.name4 is not None and self.sub_name is not None and self.type_flags is not None and self.creature_type is not None and self.creature_family is not None and self.creature_rank is not None and self.unknown0 is not None and self.spell_data_id is not None and self.display_id is not None and self.civilian is not None and self.racial_leader is not None:
            _size += 35 + len(self.name1) + len(self.name2) + len(self.name3) + len(self.name4) + len(self.sub_name)

        return _size


@dataclasses.dataclass
class CMSG_WHO:
    minimum_level: int
    maximum_level: int
    player_name: str
    guild_name: str
    race_mask: int
    class_mask: int
    zones: typing.List[int]
    search_strings: typing.List[str]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_WHO:
        # minimum_level: Level32
        minimum_level = await read_int(reader, 4)

        # maximum_level: Level32
        maximum_level = await read_int(reader, 4)

        # player_name: CString
        player_name = await read_cstring(reader)

        # guild_name: CString
        guild_name = await read_cstring(reader)

        # race_mask: u32
        race_mask = await read_int(reader, 4)

        # class_mask: u32
        class_mask = await read_int(reader, 4)

        # amount_of_zones: u32
        amount_of_zones = await read_int(reader, 4)

        # zones: u32[amount_of_zones]
        zones = []
        for _ in range(0, amount_of_zones):
            zones.append(await read_int(reader, 4))

        # amount_of_strings: u32
        amount_of_strings = await read_int(reader, 4)

        # search_strings: CString[amount_of_strings]
        search_strings = []
        for _ in range(0, amount_of_strings):
            search_strings.append(await read_cstring(reader))

        return CMSG_WHO(
            minimum_level=minimum_level,
            maximum_level=maximum_level,
            player_name=player_name,
            guild_name=guild_name,
            race_mask=race_mask,
            class_mask=class_mask,
            zones=zones,
            search_strings=search_strings,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0062))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'II{len(self.player_name)}sB{len(self.guild_name)}sBIII{len(self.zones)}II'
        _data.extend([self.minimum_level, self.maximum_level, self.player_name.encode('utf-8'), 0, self.guild_name.encode('utf-8'), 0, self.race_mask, self.class_mask, len(self.zones), *self.zones, len(self.search_strings)])
        # search_strings: CString[amount_of_strings]
        for i in self.search_strings:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 26 + len(self.player_name) + len(self.guild_name) + 4 * len(self.zones) + sum([len(i) + 1 for i in self.search_strings])


@dataclasses.dataclass
class SMSG_WHO:
    online_players: int
    players: typing.List[WhoPlayer]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_WHO:
        # listed_players: u32
        listed_players = await read_int(reader, 4)

        # online_players: u32
        online_players = await read_int(reader, 4)

        # players: WhoPlayer[listed_players]
        players = []
        for _ in range(0, listed_players):
            players.append(await WhoPlayer.read(reader))

        return SMSG_WHO(
            online_players=online_players,
            players=players,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0063))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([len(self.players), self.online_players])
        # players: WhoPlayer[listed_players]
        for i in self.players:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + sum([i.size() for i in self.players])


@dataclasses.dataclass
class CMSG_WHOIS:
    character: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_WHOIS:
        # character: CString
        character = await read_cstring(reader)

        return CMSG_WHOIS(
            character=character,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0064))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.character)}sB'
        _data.extend([self.character.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.character)


@dataclasses.dataclass
class SMSG_WHOIS:
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_WHOIS:
        # message: CString
        message = await read_cstring(reader)

        return SMSG_WHOIS(
            message=message,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0065))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.message)}sB'
        _data.extend([self.message.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.message)


@dataclasses.dataclass
class CMSG_FRIEND_LIST:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FRIEND_LIST:
        return CMSG_FRIEND_LIST()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0066))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_FRIEND_LIST:
    friends: typing.List[Friend]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FRIEND_LIST:
        # amount_of_friends: u8
        amount_of_friends = await read_int(reader, 1)

        # friends: Friend[amount_of_friends]
        friends = []
        for _ in range(0, amount_of_friends):
            friends.append(await Friend.read(reader))

        return SMSG_FRIEND_LIST(
            friends=friends,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0067))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(len(self.friends))
        # friends: Friend[amount_of_friends]
        for i in self.friends:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + sum([i.size() for i in self.friends])


@dataclasses.dataclass
class SMSG_FRIEND_STATUS:
    result: FriendResult
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FRIEND_STATUS:
        # result: FriendResult
        result = FriendResult(await read_int(reader, 1))

        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_FRIEND_STATUS(
            result=result,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x0068))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BQ'
        _data.extend([self.result.value, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ADD_FRIEND:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ADD_FRIEND:
        # name: CString
        name = await read_cstring(reader)

        return CMSG_ADD_FRIEND(
            name=name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0069))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class CMSG_DEL_FRIEND:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_DEL_FRIEND:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_DEL_FRIEND(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x006A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_IGNORE_LIST:
    ignored: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_IGNORE_LIST:
        # amount_of_ignored: u8
        amount_of_ignored = await read_int(reader, 1)

        # ignored: u64[amount_of_ignored]
        ignored = []
        for _ in range(0, amount_of_ignored):
            ignored.append(await read_int(reader, 8))

        return SMSG_IGNORE_LIST(
            ignored=ignored,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x006B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'B{len(self.ignored)}Q'
        _data.extend([len(self.ignored), *self.ignored])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + 8 * len(self.ignored)


@dataclasses.dataclass
class CMSG_ADD_IGNORE:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ADD_IGNORE:
        # name: CString
        name = await read_cstring(reader)

        return CMSG_ADD_IGNORE(
            name=name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x006C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class CMSG_DEL_IGNORE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_DEL_IGNORE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_DEL_IGNORE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x006D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_INVITE:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_INVITE:
        # name: CString
        name = await read_cstring(reader)

        return CMSG_GROUP_INVITE(
            name=name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x006E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class SMSG_GROUP_INVITE:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GROUP_INVITE:
        # name: CString
        name = await read_cstring(reader)

        return SMSG_GROUP_INVITE(
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x006F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class CMSG_GROUP_ACCEPT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_ACCEPT:
        return CMSG_GROUP_ACCEPT()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0072))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_DECLINE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_DECLINE:
        return CMSG_GROUP_DECLINE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0073))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GROUP_DECLINE:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GROUP_DECLINE:
        # name: CString
        name = await read_cstring(reader)

        return SMSG_GROUP_DECLINE(
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0074))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class CMSG_GROUP_UNINVITE:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_UNINVITE:
        # name: CString
        name = await read_cstring(reader)

        return CMSG_GROUP_UNINVITE(
            name=name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0075))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class CMSG_GROUP_UNINVITE_GUID:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_UNINVITE_GUID:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_GROUP_UNINVITE_GUID(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0076))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GROUP_UNINVITE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GROUP_UNINVITE:
        return SMSG_GROUP_UNINVITE()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0077))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_SET_LEADER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_SET_LEADER:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_GROUP_SET_LEADER(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0078))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GROUP_SET_LEADER:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GROUP_SET_LEADER:
        # name: CString
        name = await read_cstring(reader)

        return SMSG_GROUP_SET_LEADER(
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0079))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class CMSG_LOOT_METHOD:
    loot_setting: GroupLootSetting
    loot_master: int
    loot_threshold: ItemQuality

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOOT_METHOD:
        # loot_setting: GroupLootSetting
        loot_setting = GroupLootSetting(await read_int(reader, 4))

        # loot_master: Guid
        loot_master = await read_int(reader, 8)

        # loot_threshold: ItemQuality
        loot_threshold = ItemQuality(await read_int(reader, 4))

        return CMSG_LOOT_METHOD(
            loot_setting=loot_setting,
            loot_master=loot_master,
            loot_threshold=loot_threshold,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x007A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQI'
        _data.extend([self.loot_setting.value, self.loot_master, self.loot_threshold.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_DISBAND:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_DISBAND:
        return CMSG_GROUP_DISBAND()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x007B))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GROUP_DESTROYED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GROUP_DESTROYED:
        return SMSG_GROUP_DESTROYED()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x007C))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GROUP_LIST:
    group_type: GroupType
    flags: int
    members: typing.List[GroupListMember]
    leader: int
    loot_setting: typing.Optional[GroupLootSetting] = None
    master_loot: typing.Optional[int] = None
    loot_threshold: typing.Optional[ItemQuality] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GROUP_LIST:
        loot_setting = None
        master_loot = None
        loot_threshold = None
        _size = 0

        # group_type: GroupType
        group_type = GroupType(await read_int(reader, 1))
        _size += 1

        # flags: u8
        flags = await read_int(reader, 1)
        _size += 1

        # amount_of_members: u32
        amount_of_members = await read_int(reader, 4)
        _size += 4

        # members: GroupListMember[amount_of_members]
        members = []
        for _ in range(0, amount_of_members):
            members.append(await GroupListMember.read(reader))
            _size += members[-1].size()

        # leader: Guid
        leader = await read_int(reader, 8)
        _size += 8

        # group_not_empty: optional
        if _size < body_size:
            # loot_setting: GroupLootSetting
            loot_setting = GroupLootSetting(await read_int(reader, 1))
            _size += 1

            # master_loot: Guid
            master_loot = await read_int(reader, 8)
            _size += 8

            # loot_threshold: ItemQuality
            loot_threshold = ItemQuality(await read_int(reader, 1))
            _size += 1

        return SMSG_GROUP_LIST(
            group_type=group_type,
            flags=flags,
            members=members,
            leader=leader,
            loot_setting=loot_setting,
            master_loot=master_loot,
            loot_threshold=loot_threshold,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x007D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BBI'
        _data.extend([self.group_type.value, self.flags, len(self.members)])
        # members: GroupListMember[amount_of_members]
        for i in self.members:
            _fmt, _data = i.write(_fmt, _data)

        # leader: Guid
        _fmt += 'Q'
        _data.append(self.leader)

        # group_not_empty: optional
        if self.loot_setting is not None and self.master_loot is not None and self.loot_threshold is not None:
            _fmt += 'BQB'
            _data.extend([self.loot_setting.value, self.master_loot, self.loot_threshold.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 14 + sum([i.size() for i in self.members])

        # group_not_empty: optional
        if self.loot_setting is not None and self.master_loot is not None and self.loot_threshold is not None:
            _size += 10

        return _size


@dataclasses.dataclass
class SMSG_PARTY_MEMBER_STATS:
    guid: int
    mask: GroupUpdateFlags
    status: typing.Optional[GroupMemberOnlineStatus] = None
    current_health: typing.Optional[int] = None
    max_health: typing.Optional[int] = None
    power: typing.Optional[Power] = None
    current_power: typing.Optional[int] = None
    max_power: typing.Optional[int] = None
    level: typing.Optional[int] = None
    area: typing.Optional[Area] = None
    position_x: typing.Optional[int] = None
    position_y: typing.Optional[int] = None
    auras: typing.Optional[AuraMask] = None
    negative_auras: typing.Optional[AuraMask] = None
    pet: typing.Optional[int] = None
    pet_name: typing.Optional[str] = None
    pet_display_id: typing.Optional[int] = None
    pet_current_health: typing.Optional[int] = None
    pet_max_health: typing.Optional[int] = None
    pet_power_type: typing.Optional[Power] = None
    pet_current_power: typing.Optional[int] = None
    pet_max_power: typing.Optional[int] = None
    pet_auras: typing.Optional[AuraMask] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PARTY_MEMBER_STATS:
        status = None
        current_health = None
        max_health = None
        power = None
        current_power = None
        max_power = None
        level = None
        area = None
        position_x = None
        position_y = None
        auras = None
        negative_auras = None
        pet = None
        pet_name = None
        pet_display_id = None
        pet_current_health = None
        pet_max_health = None
        pet_power_type = None
        pet_current_power = None
        pet_max_power = None
        pet_auras = None
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # mask: GroupUpdateFlags
        mask = GroupUpdateFlags(await read_int(reader, 4))

        if GroupUpdateFlags.STATUS in mask:
            # status: GroupMemberOnlineStatus
            status = GroupMemberOnlineStatus(await read_int(reader, 1))

        if GroupUpdateFlags.CUR_HP in mask:
            # current_health: u16
            current_health = await read_int(reader, 2)

        if GroupUpdateFlags.MAX_HP in mask:
            # max_health: u16
            max_health = await read_int(reader, 2)

        if GroupUpdateFlags.POWER_TYPE in mask:
            # power: Power
            power = Power(await read_int(reader, 1))

        if GroupUpdateFlags.CUR_POWER in mask:
            # current_power: u16
            current_power = await read_int(reader, 2)

        if GroupUpdateFlags.MAX_POWER in mask:
            # max_power: u16
            max_power = await read_int(reader, 2)

        if GroupUpdateFlags.LEVEL in mask:
            # level: Level16
            level = await read_int(reader, 2)

        if GroupUpdateFlags.ZONE in mask:
            # area: Area
            area = Area(await read_int(reader, 4))

        if GroupUpdateFlags.POSITION in mask:
            # position_x: u16
            position_x = await read_int(reader, 2)

            # position_y: u16
            position_y = await read_int(reader, 2)

        if GroupUpdateFlags.AURAS in mask:
            # auras: AuraMask
            auras = await AuraMask.read(reader)

        if GroupUpdateFlags.AURAS_2 in mask:
            # negative_auras: AuraMask
            negative_auras = await AuraMask.read(reader)

        if GroupUpdateFlags.PET_GUID in mask:
            # pet: Guid
            pet = await read_int(reader, 8)

        if GroupUpdateFlags.PET_NAME in mask:
            # pet_name: CString
            pet_name = await read_cstring(reader)

        if GroupUpdateFlags.PET_MODEL_ID in mask:
            # pet_display_id: u16
            pet_display_id = await read_int(reader, 2)

        if GroupUpdateFlags.PET_CUR_HP in mask:
            # pet_current_health: u16
            pet_current_health = await read_int(reader, 2)

        if GroupUpdateFlags.PET_MAX_HP in mask:
            # pet_max_health: u16
            pet_max_health = await read_int(reader, 2)

        if GroupUpdateFlags.PET_POWER_TYPE in mask:
            # pet_power_type: Power
            pet_power_type = Power(await read_int(reader, 1))

        if GroupUpdateFlags.PET_CUR_POWER in mask:
            # pet_current_power: u16
            pet_current_power = await read_int(reader, 2)

        if GroupUpdateFlags.PET_MAX_POWER in mask:
            # pet_max_power: u16
            pet_max_power = await read_int(reader, 2)

        if GroupUpdateFlags.PET_AURAS in mask:
            # pet_auras: AuraMask
            pet_auras = await AuraMask.read(reader)

        return SMSG_PARTY_MEMBER_STATS(
            guid=guid,
            mask=mask,
            status=status,
            current_health=current_health,
            max_health=max_health,
            power=power,
            current_power=current_power,
            max_power=max_power,
            level=level,
            area=area,
            position_x=position_x,
            position_y=position_y,
            auras=auras,
            negative_auras=negative_auras,
            pet=pet,
            pet_name=pet_name,
            pet_display_id=pet_display_id,
            pet_current_health=pet_current_health,
            pet_max_health=pet_max_health,
            pet_power_type=pet_power_type,
            pet_current_power=pet_current_power,
            pet_max_power=pet_max_power,
            pet_auras=pet_auras,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x007E))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # mask: GroupUpdateFlags
        _fmt += 'I'
        _data.append(self.mask.value)

        if GroupUpdateFlags.STATUS in self.mask:
            _fmt += 'B'
            _data.append(self.status.value)
        if GroupUpdateFlags.CUR_HP in self.mask:
            _fmt += 'H'
            _data.append(self.current_health)
        if GroupUpdateFlags.MAX_HP in self.mask:
            _fmt += 'H'
            _data.append(self.max_health)
        if GroupUpdateFlags.POWER_TYPE in self.mask:
            _fmt += 'B'
            _data.append(self.power.value)
        if GroupUpdateFlags.CUR_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.current_power)
        if GroupUpdateFlags.MAX_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.max_power)
        if GroupUpdateFlags.LEVEL in self.mask:
            _fmt += 'H'
            _data.append(self.level)
        if GroupUpdateFlags.ZONE in self.mask:
            _fmt += 'I'
            _data.append(self.area.value)
        if GroupUpdateFlags.POSITION in self.mask:
            _fmt += 'HH'
            _data.extend([self.position_x, self.position_y])
        if GroupUpdateFlags.AURAS in self.mask:
            # auras: AuraMask
            _fmt, _data = self.auras.write(_fmt, _data)

        if GroupUpdateFlags.AURAS_2 in self.mask:
            # negative_auras: AuraMask
            _fmt, _data = self.negative_auras.write(_fmt, _data)

        if GroupUpdateFlags.PET_GUID in self.mask:
            _fmt += 'Q'
            _data.append(self.pet)
        if GroupUpdateFlags.PET_NAME in self.mask:
            _fmt += f'{len(self.pet_name)}sB'
            _data.extend([self.pet_name.encode('utf-8'), 0])
        if GroupUpdateFlags.PET_MODEL_ID in self.mask:
            _fmt += 'H'
            _data.append(self.pet_display_id)
        if GroupUpdateFlags.PET_CUR_HP in self.mask:
            _fmt += 'H'
            _data.append(self.pet_current_health)
        if GroupUpdateFlags.PET_MAX_HP in self.mask:
            _fmt += 'H'
            _data.append(self.pet_max_health)
        if GroupUpdateFlags.PET_POWER_TYPE in self.mask:
            _fmt += 'B'
            _data.append(self.pet_power_type.value)
        if GroupUpdateFlags.PET_CUR_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.pet_current_power)
        if GroupUpdateFlags.PET_MAX_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.pet_max_power)
        if GroupUpdateFlags.PET_AURAS in self.mask:
            # pet_auras: AuraMask
            _fmt, _data = self.pet_auras.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4 + packed_guid_size(self.guid)

        if GroupUpdateFlags.STATUS in self.mask:
            _size += 1

        if GroupUpdateFlags.CUR_HP in self.mask:
            _size += 2

        if GroupUpdateFlags.MAX_HP in self.mask:
            _size += 2

        if GroupUpdateFlags.POWER_TYPE in self.mask:
            _size += 1

        if GroupUpdateFlags.CUR_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.MAX_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.LEVEL in self.mask:
            _size += 2

        if GroupUpdateFlags.ZONE in self.mask:
            _size += 4

        if GroupUpdateFlags.POSITION in self.mask:
            _size += 4

        if GroupUpdateFlags.AURAS in self.mask:
            _size += 0 + self.auras.size()

        if GroupUpdateFlags.AURAS_2 in self.mask:
            _size += 0 + self.negative_auras.size()

        if GroupUpdateFlags.PET_GUID in self.mask:
            _size += 8

        if GroupUpdateFlags.PET_NAME in self.mask:
            _size += 1 + len(self.pet_name)

        if GroupUpdateFlags.PET_MODEL_ID in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_CUR_HP in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_MAX_HP in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_POWER_TYPE in self.mask:
            _size += 1

        if GroupUpdateFlags.PET_CUR_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_MAX_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_AURAS in self.mask:
            _size += 0 + self.pet_auras.size()

        return _size


@dataclasses.dataclass
class SMSG_PARTY_COMMAND_RESULT:
    operation: PartyOperation
    member: str
    result: PartyResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PARTY_COMMAND_RESULT:
        # operation: PartyOperation
        operation = PartyOperation(await read_int(reader, 4))

        # member: CString
        member = await read_cstring(reader)

        # result: PartyResult
        result = PartyResult(await read_int(reader, 4))

        return SMSG_PARTY_COMMAND_RESULT(
            operation=operation,
            member=member,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x007F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.member)}sBI'
        _data.extend([self.operation.value, self.member.encode('utf-8'), 0, self.result.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.member)


@dataclasses.dataclass
class CMSG_GUILD_CREATE:
    guild_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_CREATE:
        # guild_name: CString
        guild_name = await read_cstring(reader)

        return CMSG_GUILD_CREATE(
            guild_name=guild_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0081))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.guild_name)}sB'
        _data.extend([self.guild_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.guild_name)


@dataclasses.dataclass
class CMSG_GUILD_INVITE:
    invited_player: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_INVITE:
        # invited_player: CString
        invited_player = await read_cstring(reader)

        return CMSG_GUILD_INVITE(
            invited_player=invited_player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0082))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.invited_player)}sB'
        _data.extend([self.invited_player.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.invited_player)


@dataclasses.dataclass
class SMSG_GUILD_INVITE:
    player_name: str
    guild_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_INVITE:
        # player_name: CString
        player_name = await read_cstring(reader)

        # guild_name: CString
        guild_name = await read_cstring(reader)

        return SMSG_GUILD_INVITE(
            player_name=player_name,
            guild_name=guild_name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0083))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.player_name)}sB{len(self.guild_name)}sB'
        _data.extend([self.player_name.encode('utf-8'), 0, self.guild_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.player_name) + len(self.guild_name)


@dataclasses.dataclass
class CMSG_GUILD_ACCEPT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_ACCEPT:
        return CMSG_GUILD_ACCEPT()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0084))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_DECLINE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_DECLINE:
        return CMSG_GUILD_DECLINE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0085))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_INFO:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_INFO:
        return CMSG_GUILD_INFO()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0087))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GUILD_INFO:
    guild_name: str
    created_day: int
    created_month: int
    created_year: int
    amount_of_characters_in_guild: int
    amount_of_accounts_in_guild: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_INFO:
        # guild_name: CString
        guild_name = await read_cstring(reader)

        # created_day: u32
        created_day = await read_int(reader, 4)

        # created_month: u32
        created_month = await read_int(reader, 4)

        # created_year: u32
        created_year = await read_int(reader, 4)

        # amount_of_characters_in_guild: u32
        amount_of_characters_in_guild = await read_int(reader, 4)

        # amount_of_accounts_in_guild: u32
        amount_of_accounts_in_guild = await read_int(reader, 4)

        return SMSG_GUILD_INFO(
            guild_name=guild_name,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            amount_of_characters_in_guild=amount_of_characters_in_guild,
            amount_of_accounts_in_guild=amount_of_accounts_in_guild,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0088))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.guild_name)}sBIIIII'
        _data.extend([self.guild_name.encode('utf-8'), 0, self.created_day, self.created_month, self.created_year, self.amount_of_characters_in_guild, self.amount_of_accounts_in_guild])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 21 + len(self.guild_name)


@dataclasses.dataclass
class CMSG_GUILD_ROSTER:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_ROSTER:
        return CMSG_GUILD_ROSTER()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0089))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GUILD_ROSTER:
    motd: str
    guild_info: str
    rights: typing.List[int]
    members: typing.List[GuildMember]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_ROSTER:
        # amount_of_members: u32
        amount_of_members = await read_int(reader, 4)

        # motd: CString
        motd = await read_cstring(reader)

        # guild_info: CString
        guild_info = await read_cstring(reader)

        # amount_of_rights: u32
        amount_of_rights = await read_int(reader, 4)

        # rights: u32[amount_of_rights]
        rights = []
        for _ in range(0, amount_of_rights):
            rights.append(await read_int(reader, 4))

        # members: GuildMember[amount_of_members]
        members = []
        for _ in range(0, amount_of_members):
            members.append(await GuildMember.read(reader))

        return SMSG_GUILD_ROSTER(
            motd=motd,
            guild_info=guild_info,
            rights=rights,
            members=members,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x008A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.motd)}sB{len(self.guild_info)}sBI{len(self.rights)}I'
        _data.extend([len(self.members), self.motd.encode('utf-8'), 0, self.guild_info.encode('utf-8'), 0, len(self.rights), *self.rights])
        # members: GuildMember[amount_of_members]
        for i in self.members:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 10 + len(self.motd) + len(self.guild_info) + 4 * len(self.rights) + sum([i.size() for i in self.members])


@dataclasses.dataclass
class CMSG_GUILD_PROMOTE:
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_PROMOTE:
        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_GUILD_PROMOTE(
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x008B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.player_name)}sB'
        _data.extend([self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.player_name)


@dataclasses.dataclass
class CMSG_GUILD_DEMOTE:
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_DEMOTE:
        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_GUILD_DEMOTE(
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x008C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.player_name)}sB'
        _data.extend([self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.player_name)


@dataclasses.dataclass
class CMSG_GUILD_LEAVE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_LEAVE:
        return CMSG_GUILD_LEAVE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x008D))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_REMOVE:
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_REMOVE:
        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_GUILD_REMOVE(
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x008E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.player_name)}sB'
        _data.extend([self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.player_name)


@dataclasses.dataclass
class CMSG_GUILD_DISBAND:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_DISBAND:
        return CMSG_GUILD_DISBAND()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x008F))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_LEADER:
    new_guild_leader_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_LEADER:
        # new_guild_leader_name: CString
        new_guild_leader_name = await read_cstring(reader)

        return CMSG_GUILD_LEADER(
            new_guild_leader_name=new_guild_leader_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0090))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.new_guild_leader_name)}sB'
        _data.extend([self.new_guild_leader_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.new_guild_leader_name)


@dataclasses.dataclass
class CMSG_GUILD_MOTD:
    message_of_the_day: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_MOTD:
        # message_of_the_day: CString
        message_of_the_day = await read_cstring(reader)

        return CMSG_GUILD_MOTD(
            message_of_the_day=message_of_the_day,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0091))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.message_of_the_day)}sB'
        _data.extend([self.message_of_the_day.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.message_of_the_day)


@dataclasses.dataclass
class SMSG_GUILD_EVENT:
    event: GuildEvent
    event_descriptions: typing.List[str]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_EVENT:
        # event: GuildEvent
        event = GuildEvent(await read_int(reader, 1))

        # amount_of_events: u8
        amount_of_events = await read_int(reader, 1)

        # event_descriptions: CString[amount_of_events]
        event_descriptions = []
        for _ in range(0, amount_of_events):
            event_descriptions.append(await read_cstring(reader))

        return SMSG_GUILD_EVENT(
            event=event,
            event_descriptions=event_descriptions,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0092))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.event.value, len(self.event_descriptions)])
        # event_descriptions: CString[amount_of_events]
        for i in self.event_descriptions:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + sum([len(i) + 1 for i in self.event_descriptions])


@dataclasses.dataclass
class SMSG_GUILD_COMMAND_RESULT:
    command: GuildCommand
    string: str
    result: GuildCommandResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GUILD_COMMAND_RESULT:
        # command: GuildCommand
        command = GuildCommand(await read_int(reader, 4))

        # string: CString
        string = await read_cstring(reader)

        # result: GuildCommandResult
        result = GuildCommandResult(await read_int(reader, 4))

        return SMSG_GUILD_COMMAND_RESULT(
            command=command,
            string=string,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0093))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.string)}sBI'
        _data.extend([self.command.value, self.string.encode('utf-8'), 0, self.result.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.string)


@dataclasses.dataclass
class CMSG_MESSAGECHAT:
    chat_type: ChatType
    language: Language
    message: str
    target_player: typing.Optional[str] = None
    channel: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MESSAGECHAT:
        target_player = None
        channel = None
        # chat_type: ChatType
        chat_type = ChatType(await read_int(reader, 4))

        # language: Language
        language = Language(await read_int(reader, 4))

        if chat_type == ChatType.WHISPER:
            # target_player: CString
            target_player = await read_cstring(reader)

        elif chat_type == ChatType.CHANNEL:
            # channel: CString
            channel = await read_cstring(reader)

        # message: CString
        message = await read_cstring(reader)

        return CMSG_MESSAGECHAT(
            chat_type=chat_type,
            language=language,
            target_player=target_player,
            channel=channel,
            message=message,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0095))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.chat_type.value, self.language.value])
        if self.chat_type == ChatType.WHISPER:
            _fmt += f'{len(self.target_player)}sB'
            _data.extend([self.target_player.encode('utf-8'), 0])
        elif self.chat_type == ChatType.CHANNEL:
            _fmt += f'{len(self.channel)}sB'
            _data.extend([self.channel.encode('utf-8'), 0])
        # message: CString
        _fmt += f'{len(self.message)}sB'
        _data.extend([self.message.encode('utf-8'), 0])

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 9 + len(self.message)

        if self.chat_type == ChatType.WHISPER:
            _size += 1 + len(self.target_player)
        elif self.chat_type == ChatType.CHANNEL:
            _size += 1 + len(self.channel)

        return _size


@dataclasses.dataclass
class SMSG_MESSAGECHAT:
    chat_type: ChatType
    language: Language
    message: str
    tag: PlayerChatTag
    monster_name: typing.Optional[str] = None
    monster: typing.Optional[int] = None
    speech_bubble_credit: typing.Optional[int] = None
    chat_credit: typing.Optional[int] = None
    sender1: typing.Optional[int] = None
    sender_name: typing.Optional[str] = None
    target: typing.Optional[int] = None
    channel_name: typing.Optional[str] = None
    player_rank: typing.Optional[int] = None
    player: typing.Optional[int] = None
    sender2: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MESSAGECHAT:
        monster_name = None
        monster = None
        speech_bubble_credit = None
        chat_credit = None
        sender1 = None
        sender_name = None
        target = None
        channel_name = None
        player_rank = None
        player = None
        sender2 = None
        # chat_type: ChatType
        chat_type = ChatType(await read_int(reader, 1))

        # language: Language
        language = Language(await read_int(reader, 4))

        if chat_type in {ChatType.MONSTER_WHISPER, ChatType.RAID_BOSS_EMOTE, ChatType.MONSTER_EMOTE}:
            # monster_name: SizedCString
            monster_name = await read_sized_cstring(reader)

            # monster: Guid
            monster = await read_int(reader, 8)

        elif chat_type in {ChatType.SAY, ChatType.PARTY, ChatType.YELL}:
            # speech_bubble_credit: Guid
            speech_bubble_credit = await read_int(reader, 8)

            # chat_credit: Guid
            chat_credit = await read_int(reader, 8)

        elif chat_type in {ChatType.MONSTER_SAY, ChatType.MONSTER_YELL}:
            # sender1: Guid
            sender1 = await read_int(reader, 8)

            # sender_name: SizedCString
            sender_name = await read_sized_cstring(reader)

            # target: Guid
            target = await read_int(reader, 8)

        elif chat_type == ChatType.CHANNEL:
            # channel_name: CString
            channel_name = await read_cstring(reader)

            # player_rank: u32
            player_rank = await read_int(reader, 4)

            # player: Guid
            player = await read_int(reader, 8)

        elif chat_type in {ChatType.RAID, ChatType.GUILD, ChatType.OFFICER, ChatType.WHISPER, ChatType.WHISPER_INFORM, ChatType.EMOTE, ChatType.TEXT_EMOTE, ChatType.SYSTEM, ChatType.CHANNEL_JOIN, ChatType.CHANNEL_LEAVE, ChatType.CHANNEL_LIST, ChatType.CHANNEL_NOTICE, ChatType.CHANNEL_NOTICE_USER, ChatType.AFK, ChatType.DND, ChatType.IGNORED, ChatType.SKILL, ChatType.LOOT, ChatType.BG_SYSTEM_NEUTRAL, ChatType.BG_SYSTEM_ALLIANCE, ChatType.BG_SYSTEM_HORDE, ChatType.RAID_LEADER, ChatType.RAID_WARNING, ChatType.RAID_BOSS_WHISPER, ChatType.BATTLEGROUND, ChatType.BATTLEGROUND_LEADER}:
            # sender2: Guid
            sender2 = await read_int(reader, 8)

        # message: SizedCString
        message = await read_sized_cstring(reader)

        # tag: PlayerChatTag
        tag = PlayerChatTag(await read_int(reader, 1))

        return SMSG_MESSAGECHAT(
            chat_type=chat_type,
            language=language,
            monster_name=monster_name,
            monster=monster,
            speech_bubble_credit=speech_bubble_credit,
            chat_credit=chat_credit,
            sender1=sender1,
            sender_name=sender_name,
            target=target,
            channel_name=channel_name,
            player_rank=player_rank,
            player=player,
            sender2=sender2,
            message=message,
            tag=tag,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0096))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BI'
        _data.extend([self.chat_type.value, self.language.value])
        if self.chat_type in {ChatType.MONSTER_WHISPER, ChatType.RAID_BOSS_EMOTE, ChatType.MONSTER_EMOTE}:
            _fmt += f'I{len(self.monster_name)}sBQ'
            _data.extend([len(self.monster_name) + 1, self.monster_name.encode('utf-8'), 0, self.monster])
        elif self.chat_type in {ChatType.SAY, ChatType.PARTY, ChatType.YELL}:
            _fmt += 'QQ'
            _data.extend([self.speech_bubble_credit, self.chat_credit])
        elif self.chat_type in {ChatType.MONSTER_SAY, ChatType.MONSTER_YELL}:
            _fmt += f'QI{len(self.sender_name)}sBQ'
            _data.extend([self.sender1, len(self.sender_name) + 1, self.sender_name.encode('utf-8'), 0, self.target])
        elif self.chat_type == ChatType.CHANNEL:
            _fmt += f'{len(self.channel_name)}sBIQ'
            _data.extend([self.channel_name.encode('utf-8'), 0, self.player_rank, self.player])
        elif self.chat_type in {ChatType.RAID, ChatType.GUILD, ChatType.OFFICER, ChatType.WHISPER, ChatType.WHISPER_INFORM, ChatType.EMOTE, ChatType.TEXT_EMOTE, ChatType.SYSTEM, ChatType.CHANNEL_JOIN, ChatType.CHANNEL_LEAVE, ChatType.CHANNEL_LIST, ChatType.CHANNEL_NOTICE, ChatType.CHANNEL_NOTICE_USER, ChatType.AFK, ChatType.DND, ChatType.IGNORED, ChatType.SKILL, ChatType.LOOT, ChatType.BG_SYSTEM_NEUTRAL, ChatType.BG_SYSTEM_ALLIANCE, ChatType.BG_SYSTEM_HORDE, ChatType.RAID_LEADER, ChatType.RAID_WARNING, ChatType.RAID_BOSS_WHISPER, ChatType.BATTLEGROUND, ChatType.BATTLEGROUND_LEADER}:
            _fmt += 'Q'
            _data.append(self.sender2)
        # message: SizedCString
        _fmt += f'I{len(self.message)}sB'
        _data.extend([len(self.message) + 1, self.message.encode('utf-8'), 0])

        # tag: PlayerChatTag
        _fmt += 'B'
        _data.append(self.tag.value)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 11 + len(self.message)

        if self.chat_type in {ChatType.MONSTER_WHISPER, ChatType.RAID_BOSS_EMOTE, ChatType.MONSTER_EMOTE}:
            _size += 13 + len(self.monster_name)
        elif self.chat_type in {ChatType.SAY, ChatType.PARTY, ChatType.YELL}:
            _size += 16
        elif self.chat_type in {ChatType.MONSTER_SAY, ChatType.MONSTER_YELL}:
            _size += 21 + len(self.sender_name)
        elif self.chat_type == ChatType.CHANNEL:
            _size += 13 + len(self.channel_name)
        elif self.chat_type in {ChatType.RAID, ChatType.GUILD, ChatType.OFFICER, ChatType.WHISPER, ChatType.WHISPER_INFORM, ChatType.EMOTE, ChatType.TEXT_EMOTE, ChatType.SYSTEM, ChatType.CHANNEL_JOIN, ChatType.CHANNEL_LEAVE, ChatType.CHANNEL_LIST, ChatType.CHANNEL_NOTICE, ChatType.CHANNEL_NOTICE_USER, ChatType.AFK, ChatType.DND, ChatType.IGNORED, ChatType.SKILL, ChatType.LOOT, ChatType.BG_SYSTEM_NEUTRAL, ChatType.BG_SYSTEM_ALLIANCE, ChatType.BG_SYSTEM_HORDE, ChatType.RAID_LEADER, ChatType.RAID_WARNING, ChatType.RAID_BOSS_WHISPER, ChatType.BATTLEGROUND, ChatType.BATTLEGROUND_LEADER}:
            _size += 8

        return _size


@dataclasses.dataclass
class CMSG_JOIN_CHANNEL:
    channel_name: str
    channel_password: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_JOIN_CHANNEL:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # channel_password: CString
        channel_password = await read_cstring(reader)

        return CMSG_JOIN_CHANNEL(
            channel_name=channel_name,
            channel_password=channel_password,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0097))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.channel_password)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.channel_password.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.channel_password)


@dataclasses.dataclass
class CMSG_LEAVE_CHANNEL:
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LEAVE_CHANNEL:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        return CMSG_LEAVE_CHANNEL(
            channel_name=channel_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0098))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.channel_name)


@dataclasses.dataclass
class SMSG_CHANNEL_NOTIFY:
    notify_type: ChatNotify
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHANNEL_NOTIFY:
        # notify_type: ChatNotify
        notify_type = ChatNotify(await read_int(reader, 1))

        # channel_name: CString
        channel_name = await read_cstring(reader)

        return SMSG_CHANNEL_NOTIFY(
            notify_type=notify_type,
            channel_name=channel_name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0099))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'B{len(self.channel_name)}sB'
        _data.extend([self.notify_type.value, self.channel_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name)


@dataclasses.dataclass
class CMSG_CHANNEL_LIST:
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_LIST:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        return CMSG_CHANNEL_LIST(
            channel_name=channel_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x009A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.channel_name)


@dataclasses.dataclass
class SMSG_CHANNEL_LIST:
    channel_name: str
    channel_flags: ChannelFlags
    members: typing.List[ChannelMember]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHANNEL_LIST:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # channel_flags: ChannelFlags
        channel_flags = ChannelFlags(await read_int(reader, 1))

        # amount_of_members: u32
        amount_of_members = await read_int(reader, 4)

        # members: ChannelMember[amount_of_members]
        members = []
        for _ in range(0, amount_of_members):
            members.append(await ChannelMember.read(reader))

        return SMSG_CHANNEL_LIST(
            channel_name=channel_name,
            channel_flags=channel_flags,
            members=members,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x009B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sBBI'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.channel_flags.value, len(self.members)])
        # members: ChannelMember[amount_of_members]
        for i in self.members:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 6 + len(self.channel_name) + 9 * len(self.members)


@dataclasses.dataclass
class CMSG_CHANNEL_PASSWORD:
    channel_name: str
    channel_password: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_PASSWORD:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # channel_password: CString
        channel_password = await read_cstring(reader)

        return CMSG_CHANNEL_PASSWORD(
            channel_name=channel_name,
            channel_password=channel_password,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x009C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.channel_password)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.channel_password.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.channel_password)


@dataclasses.dataclass
class CMSG_CHANNEL_SET_OWNER:
    channel_name: str
    new_owner: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_SET_OWNER:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # new_owner: CString
        new_owner = await read_cstring(reader)

        return CMSG_CHANNEL_SET_OWNER(
            channel_name=channel_name,
            new_owner=new_owner,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x009D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.new_owner)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.new_owner.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.new_owner)


@dataclasses.dataclass
class CMSG_CHANNEL_OWNER:
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_OWNER:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        return CMSG_CHANNEL_OWNER(
            channel_name=channel_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x009E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.channel_name)


@dataclasses.dataclass
class CMSG_CHANNEL_MODERATOR:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_MODERATOR:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_MODERATOR(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x009F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_UNMODERATOR:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_UNMODERATOR:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_UNMODERATOR(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_MUTE:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_MUTE:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_MUTE(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A1))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_UNMUTE:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_UNMUTE:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_UNMUTE(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_INVITE:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_INVITE:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_INVITE(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_KICK:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_KICK:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_KICK(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A4))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_BAN:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_BAN:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_BAN(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A5))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_UNBAN:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_UNBAN:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        # player_name: CString
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_UNBAN(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A6))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB{len(self.player_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0, self.player_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.channel_name) + len(self.player_name)


@dataclasses.dataclass
class CMSG_CHANNEL_ANNOUNCEMENTS:
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_ANNOUNCEMENTS:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        return CMSG_CHANNEL_ANNOUNCEMENTS(
            channel_name=channel_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A7))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.channel_name)


@dataclasses.dataclass
class CMSG_CHANNEL_MODERATE:
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHANNEL_MODERATE:
        # channel_name: CString
        channel_name = await read_cstring(reader)

        return CMSG_CHANNEL_MODERATE(
            channel_name=channel_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00A8))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.channel_name)}sB'
        _data.extend([self.channel_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.channel_name)


@dataclasses.dataclass
class SMSG_UPDATE_OBJECT:
    has_transport: int
    objects: typing.List[Object]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_UPDATE_OBJECT:
        # amount_of_objects: u32
        amount_of_objects = await read_int(reader, 4)

        # has_transport: u8
        has_transport = await read_int(reader, 1)

        # objects: Object[amount_of_objects]
        objects = []
        for _ in range(0, amount_of_objects):
            objects.append(await Object.read(reader))

        return SMSG_UPDATE_OBJECT(
            has_transport=has_transport,
            objects=objects,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00A9))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([len(self.objects), self.has_transport])
        # objects: Object[amount_of_objects]
        for i in self.objects:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + sum([i.size() for i in self.objects])


@dataclasses.dataclass
class SMSG_DESTROY_OBJECT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DESTROY_OBJECT:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_DESTROY_OBJECT(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x00AA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_USE_ITEM:
    bag_index: int
    bag_slot: int
    spell_index: int
    targets: SpellCastTargets

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_USE_ITEM:
        # bag_index: u8
        bag_index = await read_int(reader, 1)

        # bag_slot: u8
        bag_slot = await read_int(reader, 1)

        # spell_index: u8
        spell_index = await read_int(reader, 1)

        # targets: SpellCastTargets
        targets = await SpellCastTargets.read(reader)

        return CMSG_USE_ITEM(
            bag_index=bag_index,
            bag_slot=bag_slot,
            spell_index=spell_index,
            targets=targets,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00AB))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBB'
        _data.extend([self.bag_index, self.bag_slot, self.spell_index])
        # targets: SpellCastTargets
        _fmt, _data = self.targets.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 3 + self.targets.size()


@dataclasses.dataclass
class CMSG_OPEN_ITEM:
    bag_index: int
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_OPEN_ITEM:
        # bag_index: u8
        bag_index = await read_int(reader, 1)

        # slot: u8
        slot = await read_int(reader, 1)

        return CMSG_OPEN_ITEM(
            bag_index=bag_index,
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x00AC))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.bag_index, self.slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_READ_ITEM:
    bag_index: int
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_READ_ITEM:
        # bag_index: u8
        bag_index = await read_int(reader, 1)

        # slot: u8
        slot = await read_int(reader, 1)

        return CMSG_READ_ITEM(
            bag_index=bag_index,
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x00AD))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.bag_index, self.slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_READ_ITEM_OK:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_READ_ITEM_OK:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_READ_ITEM_OK(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x00AE))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_READ_ITEM_FAILED:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_READ_ITEM_FAILED:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_READ_ITEM_FAILED(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x00AF))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_COOLDOWN:
    guid: int
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_COOLDOWN:
        # guid: Guid
        guid = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        return SMSG_ITEM_COOLDOWN(
            guid=guid,
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x00B0))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GAMEOBJ_USE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GAMEOBJ_USE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_GAMEOBJ_USE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x00B1))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GAMEOBJECT_CUSTOM_ANIM:
    guid: int
    animation_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GAMEOBJECT_CUSTOM_ANIM:
        # guid: Guid
        guid = await read_int(reader, 8)

        # animation_id: u32
        animation_id = await read_int(reader, 4)

        return SMSG_GAMEOBJECT_CUSTOM_ANIM(
            guid=guid,
            animation_id=animation_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x00B3))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.animation_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AREATRIGGER:
    trigger_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AREATRIGGER:
        # trigger_id: u32
        trigger_id = await read_int(reader, 4)

        return CMSG_AREATRIGGER(
            trigger_id=trigger_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x00B4))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.trigger_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MOVE_START_FORWARD_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_FORWARD_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_FORWARD_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00B5))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_FORWARD_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_FORWARD_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_FORWARD_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00B5))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_BACKWARD_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_BACKWARD_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_BACKWARD_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00B6))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_BACKWARD_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_BACKWARD_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_BACKWARD_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00B6))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00B7))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00B7))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_STRAFE_LEFT_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_STRAFE_LEFT_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_STRAFE_LEFT_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00B8))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_STRAFE_LEFT_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_STRAFE_LEFT_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_STRAFE_LEFT_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00B8))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_STRAFE_RIGHT_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_STRAFE_RIGHT_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_STRAFE_RIGHT_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00B9))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_STRAFE_RIGHT_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_STRAFE_RIGHT_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_STRAFE_RIGHT_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00B9))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_STRAFE_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_STRAFE_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_STRAFE_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00BA))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_STRAFE_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_STRAFE_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_STRAFE_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00BA))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_JUMP_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_JUMP_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_JUMP_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00BB))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_JUMP_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_JUMP_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_JUMP_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00BB))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_TURN_LEFT_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_TURN_LEFT_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_TURN_LEFT_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00BC))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_TURN_LEFT_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_TURN_LEFT_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_TURN_LEFT_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00BC))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_TURN_RIGHT_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_TURN_RIGHT_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_TURN_RIGHT_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00BD))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_TURN_RIGHT_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_TURN_RIGHT_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_TURN_RIGHT_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00BD))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_TURN_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_TURN_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_TURN_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00BE))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_TURN_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_TURN_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_TURN_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00BE))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_PITCH_UP_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_PITCH_UP_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_PITCH_UP_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00BF))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_PITCH_UP_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_PITCH_UP_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_PITCH_UP_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00BF))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_PITCH_DOWN_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_PITCH_DOWN_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_PITCH_DOWN_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00C0))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_PITCH_DOWN_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_PITCH_DOWN_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_PITCH_DOWN_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00C0))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_PITCH_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_PITCH_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_PITCH_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00C1))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_PITCH_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_PITCH_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_PITCH_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00C1))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_RUN_MODE_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_RUN_MODE_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_RUN_MODE_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00C2))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_RUN_MODE_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_RUN_MODE_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_RUN_MODE_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00C2))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_WALK_MODE_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_WALK_MODE_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_WALK_MODE_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00C3))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_WALK_MODE_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_WALK_MODE_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_WALK_MODE_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00C3))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_TELEPORT_ACK_Client:
    guid: int
    movement_counter: int
    time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_TELEPORT_ACK_Client:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # time: Milliseconds
        time = await read_int(reader, 4)

        return MSG_MOVE_TELEPORT_ACK_Client(
            guid=guid,
            movement_counter=movement_counter,
            time=time,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00C7))
        _fmt = "<6s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # movement_counter: u32
        _fmt += 'I'
        _data.append(self.movement_counter)

        # time: Milliseconds
        _fmt += 'I'
        _data.append(self.time)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class MSG_MOVE_TELEPORT_ACK_Server:
    guid: int
    movement_counter: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_TELEPORT_ACK_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_TELEPORT_ACK_Server(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00C7))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # movement_counter: u32
        _fmt += 'I'
        _data.append(self.movement_counter)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_FALL_LAND_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_FALL_LAND_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_FALL_LAND_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00C9))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_FALL_LAND_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_FALL_LAND_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_FALL_LAND_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00C9))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_SWIM_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_SWIM_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_SWIM_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00CA))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_START_SWIM_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_START_SWIM_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_SWIM_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00CA))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_SWIM_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_SWIM_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_SWIM_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00CB))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_STOP_SWIM_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_STOP_SWIM_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_SWIM_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00CB))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_FACING_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_FACING_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_FACING_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00DA))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_FACING_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_FACING_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_FACING_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00DA))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_PITCH_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_PITCH_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_PITCH_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00DB))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_SET_PITCH_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_SET_PITCH_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_PITCH_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00DB))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_WORLDPORT_ACK:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_WORLDPORT_ACK:
        return MSG_MOVE_WORLDPORT_ACK()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x00DC))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x00DC))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MONSTER_MOVE:
    guid: int
    spline_point: Vector3d
    spline_id: int
    move_type: MonsterMoveType
    spline_flags: SplineFlag
    duration: int
    splines: MonsterMoveSpline
    target: typing.Optional[int] = None
    angle: typing.Optional[float] = None
    position: typing.Optional[Vector3d] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MONSTER_MOVE:
        target = None
        angle = None
        position = None
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # spline_point: Vector3d
        spline_point = await Vector3d.read(reader)

        # spline_id: u32
        spline_id = await read_int(reader, 4)

        # move_type: MonsterMoveType
        move_type = MonsterMoveType(await read_int(reader, 1))

        if move_type == MonsterMoveType.FACING_TARGET:
            # target: Guid
            target = await read_int(reader, 8)

        elif move_type == MonsterMoveType.FACING_ANGLE:
            # angle: f32
            angle = await read_float(reader)

        elif move_type == MonsterMoveType.FACING_SPOT:
            # position: Vector3d
            position = await Vector3d.read(reader)

        # spline_flags: SplineFlag
        spline_flags = SplineFlag(await read_int(reader, 4))

        # duration: u32
        duration = await read_int(reader, 4)

        # splines: MonsterMoveSpline
        splines = await MonsterMoveSpline.read(reader)

        return SMSG_MONSTER_MOVE(
            guid=guid,
            spline_point=spline_point,
            spline_id=spline_id,
            move_type=move_type,
            target=target,
            angle=angle,
            position=position,
            spline_flags=spline_flags,
            duration=duration,
            splines=splines,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00DD))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # spline_point: Vector3d
        _fmt, _data = self.spline_point.write(_fmt, _data)

        # spline_id: u32
        _fmt += 'I'
        _data.append(self.spline_id)

        # move_type: MonsterMoveType
        _fmt += 'B'
        _data.append(self.move_type.value)

        if self.move_type == MonsterMoveType.FACING_TARGET:
            _fmt += 'Q'
            _data.append(self.target)
        elif self.move_type == MonsterMoveType.FACING_ANGLE:
            _fmt += 'f'
            _data.append(self.angle)
        elif self.move_type == MonsterMoveType.FACING_SPOT:
            # position: Vector3d
            _fmt, _data = self.position.write(_fmt, _data)

        # spline_flags: SplineFlag
        _fmt += 'I'
        _data.append(self.spline_flags.value)

        # duration: u32
        _fmt += 'I'
        _data.append(self.duration)

        # splines: MonsterMoveSpline
        _fmt, _data = self.splines.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 25 + packed_guid_size(self.guid) + self.splines.size()

        if self.move_type == MonsterMoveType.FACING_TARGET:
            _size += 8
        elif self.move_type == MonsterMoveType.FACING_ANGLE:
            _size += 4
        elif self.move_type == MonsterMoveType.FACING_SPOT:
            _size += 12

        return _size


@dataclasses.dataclass
class SMSG_MOVE_WATER_WALK:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_WATER_WALK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_WATER_WALK(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00DE))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_MOVE_LAND_WALK:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_LAND_WALK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_LAND_WALK(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00DF))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_MOVE_SET_RAW_POSITION:
    position: Vector3d
    orientation: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_SET_RAW_POSITION:
        # position: Vector3d
        position = await Vector3d.read(reader)

        # orientation: f32
        orientation = await read_float(reader)

        return CMSG_MOVE_SET_RAW_POSITION(
            position=position,
            orientation=orientation,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x00E1))
        _fmt = "<6s"
        _data = [_data]

        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # orientation: f32
        _fmt += 'f'
        _data.append(self.orientation)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_FORCE_RUN_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_RUN_SPEED_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_RUN_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00E2))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_RUN_SPEED_CHANGE_ACK:
    guid: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_RUN_SPEED_CHANGE_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_RUN_SPEED_CHANGE_ACK(
            guid=guid,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00E3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_RUN_BACK_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_RUN_BACK_SPEED_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_RUN_BACK_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00E4))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK:
    guid: int
    movement_counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00E5))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.movement_counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_SWIM_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_SWIM_SPEED_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_SWIM_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00E6))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_SWIM_SPEED_CHANGE_ACK:
    guid: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_SWIM_SPEED_CHANGE_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_SWIM_SPEED_CHANGE_ACK(
            guid=guid,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00E7))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_MOVE_ROOT:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_MOVE_ROOT:
        # guid: Guid
        guid = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_FORCE_MOVE_ROOT(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x00E8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.counter])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_FORCE_MOVE_ROOT_ACK:
    guid: int
    movement_counter: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_MOVE_ROOT_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return CMSG_FORCE_MOVE_ROOT_ACK(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00E9))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.movement_counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_MOVE_UNROOT:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_MOVE_UNROOT:
        # guid: Guid
        guid = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_FORCE_MOVE_UNROOT(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x00EA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.counter])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_FORCE_MOVE_UNROOT_ACK:
    guid: int
    movement_counter: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_MOVE_UNROOT_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return CMSG_FORCE_MOVE_UNROOT_ACK(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00EB))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.movement_counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_HEARTBEAT_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_HEARTBEAT_Client:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_HEARTBEAT_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00EE))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_HEARTBEAT_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_HEARTBEAT_Server:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_HEARTBEAT_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00EE))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info.size()


@dataclasses.dataclass
class SMSG_MOVE_KNOCK_BACK:
    guid: int
    movement_counter: int
    v_cos: float
    v_sin: float
    horizontal_speed: float
    vertical_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_KNOCK_BACK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # v_cos: f32
        v_cos = await read_float(reader)

        # v_sin: f32
        v_sin = await read_float(reader)

        # horizontal_speed: f32
        horizontal_speed = await read_float(reader)

        # vertical_speed: f32
        vertical_speed = await read_float(reader)

        return SMSG_MOVE_KNOCK_BACK(
            guid=guid,
            movement_counter=movement_counter,
            v_cos=v_cos,
            v_sin=v_sin,
            horizontal_speed=horizontal_speed,
            vertical_speed=vertical_speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00EF))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # movement_counter: u32
        _fmt += 'I'
        _data.append(self.movement_counter)

        # v_cos: f32
        _fmt += 'f'
        _data.append(self.v_cos)

        # v_sin: f32
        _fmt += 'f'
        _data.append(self.v_sin)

        # horizontal_speed: f32
        _fmt += 'f'
        _data.append(self.horizontal_speed)

        # vertical_speed: f32
        _fmt += 'f'
        _data.append(self.vertical_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 20 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_MOVE_KNOCK_BACK_ACK:
    guid: int
    counter: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_KNOCK_BACK_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return CMSG_MOVE_KNOCK_BACK_ACK(
            guid=guid,
            counter=counter,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00F0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + self.info.size()


@dataclasses.dataclass
class SMSG_MOVE_FEATHER_FALL:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_FEATHER_FALL:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_FEATHER_FALL(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00F2))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_MOVE_NORMAL_FALL:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_NORMAL_FALL:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_NORMAL_FALL(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00F3))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_MOVE_SET_HOVER:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_SET_HOVER:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_SET_HOVER(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00F4))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_MOVE_UNSET_HOVER:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOVE_UNSET_HOVER:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # counter: u32
        counter = await read_int(reader, 4)

        return SMSG_MOVE_UNSET_HOVER(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x00F5))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # counter: u32
        _fmt += 'I'
        _data.append(self.counter)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_MOVE_HOVER_ACK:
    guid: int
    counter: int
    info: MovementInfo
    is_applied: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_HOVER_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # is_applied: u32
        is_applied = await read_int(reader, 4)

        return CMSG_MOVE_HOVER_ACK(
            guid=guid,
            counter=counter,
            info=info,
            is_applied=is_applied,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x00F6))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # is_applied: u32
        _fmt += 'I'
        _data.append(self.is_applied)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class SMSG_TRIGGER_CINEMATIC:
    cinematic_sequence_id: CinematicSequenceId

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRIGGER_CINEMATIC:
        # cinematic_sequence_id: CinematicSequenceId
        cinematic_sequence_id = CinematicSequenceId(await read_int(reader, 4))

        return SMSG_TRIGGER_CINEMATIC(
            cinematic_sequence_id=cinematic_sequence_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x00FA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.cinematic_sequence_id.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_NEXT_CINEMATIC_CAMERA:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_NEXT_CINEMATIC_CAMERA:
        return CMSG_NEXT_CINEMATIC_CAMERA()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x00FB))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_COMPLETE_CINEMATIC:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_COMPLETE_CINEMATIC:
        return CMSG_COMPLETE_CINEMATIC()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x00FC))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TUTORIAL_FLAGS:
    tutorial_data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TUTORIAL_FLAGS:
        # tutorial_data: u32[8]
        tutorial_data = []
        for _ in range(0, 8):
            tutorial_data.append(await read_int(reader, 4))

        return SMSG_TUTORIAL_FLAGS(
            tutorial_data=tutorial_data,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(32 + 2, 0x00FD))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.tutorial_data)}I'
        _data.extend([*self.tutorial_data])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TUTORIAL_FLAG:
    tutorial_flag: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TUTORIAL_FLAG:
        # tutorial_flag: u32
        tutorial_flag = await read_int(reader, 4)

        return CMSG_TUTORIAL_FLAG(
            tutorial_flag=tutorial_flag,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x00FE))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.tutorial_flag)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TUTORIAL_CLEAR:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TUTORIAL_CLEAR:
        return CMSG_TUTORIAL_CLEAR()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x00FF))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TUTORIAL_RESET:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TUTORIAL_RESET:
        return CMSG_TUTORIAL_RESET()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0100))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_STANDSTATECHANGE:
    animation_state: UnitStandState

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_STANDSTATECHANGE:
        # animation_state: UnitStandState
        animation_state = UnitStandState(await read_int(reader, 4))

        return CMSG_STANDSTATECHANGE(
            animation_state=animation_state,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0101))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.animation_state.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_EMOTE:
    emote: Emote

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_EMOTE:
        # emote: Emote
        emote = Emote(await read_int(reader, 4))

        return CMSG_EMOTE(
            emote=emote,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0102))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.emote.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_EMOTE:
    emote: Emote
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_EMOTE:
        # emote: Emote
        emote = Emote(await read_int(reader, 4))

        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_EMOTE(
            emote=emote,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0103))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.emote.value, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TEXT_EMOTE:
    text_emote: TextEmote
    emote: int
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TEXT_EMOTE:
        # text_emote: TextEmote
        text_emote = TextEmote(await read_int(reader, 4))

        # emote: u32
        emote = await read_int(reader, 4)

        # target: Guid
        target = await read_int(reader, 8)

        return CMSG_TEXT_EMOTE(
            text_emote=text_emote,
            emote=emote,
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x0104))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IIQ'
        _data.extend([self.text_emote.value, self.emote, self.target])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TEXT_EMOTE:
    guid: int
    text_emote: TextEmote
    emote: int
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TEXT_EMOTE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # text_emote: TextEmote
        text_emote = TextEmote(await read_int(reader, 4))

        # emote: u32
        emote = await read_int(reader, 4)

        # name: SizedCString
        name = await read_sized_cstring(reader)

        return SMSG_TEXT_EMOTE(
            guid=guid,
            text_emote=text_emote,
            emote=emote,
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0105))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QIII{len(self.name)}sB'
        _data.extend([self.guid, self.text_emote.value, self.emote, len(self.name) + 1, self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 21 + len(self.name)


@dataclasses.dataclass
class CMSG_AUTOSTORE_LOOT_ITEM:
    item_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUTOSTORE_LOOT_ITEM:
        # item_slot: u8
        item_slot = await read_int(reader, 1)

        return CMSG_AUTOSTORE_LOOT_ITEM(
            item_slot=item_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x0108))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.item_slot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUTOEQUIP_ITEM:
    source_bag: int
    source_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUTOEQUIP_ITEM:
        # source_bag: u8
        source_bag = await read_int(reader, 1)

        # source_slot: u8
        source_slot = await read_int(reader, 1)

        return CMSG_AUTOEQUIP_ITEM(
            source_bag=source_bag,
            source_slot=source_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x010A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.source_bag, self.source_slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUTOSTORE_BAG_ITEM:
    source_bag: int
    source_slot: int
    destination_bag: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUTOSTORE_BAG_ITEM:
        # source_bag: u8
        source_bag = await read_int(reader, 1)

        # source_slot: u8
        source_slot = await read_int(reader, 1)

        # destination_bag: u8
        destination_bag = await read_int(reader, 1)

        return CMSG_AUTOSTORE_BAG_ITEM(
            source_bag=source_bag,
            source_slot=source_slot,
            destination_bag=destination_bag,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(3 + 4, 0x010B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBB'
        _data.extend([self.source_bag, self.source_slot, self.destination_bag])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SWAP_ITEM:
    destination_bag: int
    destionation_slot: int
    source_bag: int
    source_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SWAP_ITEM:
        # destination_bag: u8
        destination_bag = await read_int(reader, 1)

        # destionation_slot: u8
        destionation_slot = await read_int(reader, 1)

        # source_bag: u8
        source_bag = await read_int(reader, 1)

        # source_slot: u8
        source_slot = await read_int(reader, 1)

        return CMSG_SWAP_ITEM(
            destination_bag=destination_bag,
            destionation_slot=destionation_slot,
            source_bag=source_bag,
            source_slot=source_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x010C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBBB'
        _data.extend([self.destination_bag, self.destionation_slot, self.source_bag, self.source_slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SWAP_INV_ITEM:
    source_slot: ItemSlot
    destination_slot: ItemSlot

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SWAP_INV_ITEM:
        # source_slot: ItemSlot
        source_slot = ItemSlot(await read_int(reader, 1))

        # destination_slot: ItemSlot
        destination_slot = ItemSlot(await read_int(reader, 1))

        return CMSG_SWAP_INV_ITEM(
            source_slot=source_slot,
            destination_slot=destination_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x010D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.source_slot.value, self.destination_slot.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SPLIT_ITEM:
    source_bag: int
    source_slot: int
    destination_bag: int
    destination_slot: int
    amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SPLIT_ITEM:
        # source_bag: u8
        source_bag = await read_int(reader, 1)

        # source_slot: u8
        source_slot = await read_int(reader, 1)

        # destination_bag: u8
        destination_bag = await read_int(reader, 1)

        # destination_slot: u8
        destination_slot = await read_int(reader, 1)

        # amount: u8
        amount = await read_int(reader, 1)

        return CMSG_SPLIT_ITEM(
            source_bag=source_bag,
            source_slot=source_slot,
            destination_bag=destination_bag,
            destination_slot=destination_slot,
            amount=amount,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 4, 0x010E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBBBB'
        _data.extend([self.source_bag, self.source_slot, self.destination_bag, self.destination_slot, self.amount])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUTOEQUIP_ITEM_SLOT:
    guid: int
    destination_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUTOEQUIP_ITEM_SLOT:
        # guid: Guid
        guid = await read_int(reader, 8)

        # destination_slot: u8
        destination_slot = await read_int(reader, 1)

        return CMSG_AUTOEQUIP_ITEM_SLOT(
            guid=guid,
            destination_slot=destination_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x010F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.destination_slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_DESTROYITEM:
    bag: int
    slot: int
    amount: int
    unknown1: int
    unknown2: int
    unknown3: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_DESTROYITEM:
        # bag: u8
        bag = await read_int(reader, 1)

        # slot: u8
        slot = await read_int(reader, 1)

        # amount: u8
        amount = await read_int(reader, 1)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # unknown2: u8
        unknown2 = await read_int(reader, 1)

        # unknown3: u8
        unknown3 = await read_int(reader, 1)

        return CMSG_DESTROYITEM(
            bag=bag,
            slot=slot,
            amount=amount,
            unknown1=unknown1,
            unknown2=unknown2,
            unknown3=unknown3,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(6 + 4, 0x0111))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBBBBB'
        _data.extend([self.bag, self.slot, self.amount, self.unknown1, self.unknown2, self.unknown3])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_INVENTORY_CHANGE_FAILURE:
    result: InventoryResult
    required_level: typing.Optional[int] = None
    item1: typing.Optional[int] = None
    item2: typing.Optional[int] = None
    bag_type_subclass: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INVENTORY_CHANGE_FAILURE:
        required_level = None
        item1 = None
        item2 = None
        bag_type_subclass = None
        # result: InventoryResult
        result = InventoryResult(await read_int(reader, 1))

        if result == InventoryResult.CANT_EQUIP_LEVEL_I:
            # required_level: Level32
            required_level = await read_int(reader, 4)

        if result in {InventoryResult.CANT_EQUIP_LEVEL_I, InventoryResult.CANT_EQUIP_SKILL, InventoryResult.ITEM_DOESNT_GO_TO_SLOT, InventoryResult.BAG_FULL, InventoryResult.NONEMPTY_BAG_OVER_OTHER_BAG, InventoryResult.CANT_TRADE_EQUIP_BAGS, InventoryResult.ONLY_AMMO_CAN_GO_HERE, InventoryResult.NO_REQUIRED_PROFICIENCY, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE, InventoryResult.YOU_CAN_NEVER_USE_THAT_ITEM, InventoryResult.YOU_CAN_NEVER_USE_THAT_ITEM2, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE2, InventoryResult.CANT_EQUIP_WITH_TWOHANDED, InventoryResult.CANT_DUAL_WIELD, InventoryResult.ITEM_DOESNT_GO_INTO_BAG, InventoryResult.ITEM_DOESNT_GO_INTO_BAG2, InventoryResult.CANT_CARRY_MORE_OF_THIS, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE3, InventoryResult.ITEM_CANT_STACK, InventoryResult.ITEM_CANT_BE_EQUIPPED, InventoryResult.ITEMS_CANT_BE_SWAPPED, InventoryResult.SLOT_IS_EMPTY, InventoryResult.ITEM_NOT_FOUND, InventoryResult.CANT_DROP_SOULBOUND, InventoryResult.OUT_OF_RANGE, InventoryResult.TRIED_TO_SPLIT_MORE_THAN_COUNT, InventoryResult.COULDNT_SPLIT_ITEMS, InventoryResult.MISSING_REAGENT, InventoryResult.NOT_ENOUGH_MONEY, InventoryResult.NOT_A_BAG, InventoryResult.CAN_ONLY_DO_WITH_EMPTY_BAGS, InventoryResult.DONT_OWN_THAT_ITEM, InventoryResult.CAN_EQUIP_ONLY1_QUIVER, InventoryResult.MUST_PURCHASE_THAT_BAG_SLOT, InventoryResult.TOO_FAR_AWAY_FROM_BANK, InventoryResult.ITEM_LOCKED, InventoryResult.YOU_ARE_STUNNED, InventoryResult.YOU_ARE_DEAD, InventoryResult.CANT_DO_RIGHT_NOW, InventoryResult.INT_BAG_ERROR, InventoryResult.CAN_EQUIP_ONLY1_BOLT, InventoryResult.CAN_EQUIP_ONLY1_AMMOPOUCH, InventoryResult.STACKABLE_CANT_BE_WRAPPED, InventoryResult.EQUIPPED_CANT_BE_WRAPPED, InventoryResult.WRAPPED_CANT_BE_WRAPPED, InventoryResult.BOUND_CANT_BE_WRAPPED, InventoryResult.UNIQUE_CANT_BE_WRAPPED, InventoryResult.BAGS_CANT_BE_WRAPPED, InventoryResult.ALREADY_LOOTED, InventoryResult.INVENTORY_FULL, InventoryResult.BANK_FULL, InventoryResult.ITEM_IS_CURRENTLY_SOLD_OUT, InventoryResult.BAG_FULL3, InventoryResult.ITEM_NOT_FOUND2, InventoryResult.ITEM_CANT_STACK2, InventoryResult.BAG_FULL4, InventoryResult.ITEM_SOLD_OUT, InventoryResult.OBJECT_IS_BUSY, InventoryResult.NONE, InventoryResult.NOT_IN_COMBAT, InventoryResult.NOT_WHILE_DISARMED, InventoryResult.BAG_FULL6, InventoryResult.CANT_EQUIP_RANK, InventoryResult.CANT_EQUIP_REPUTATION, InventoryResult.TOO_MANY_SPECIAL_BAGS, InventoryResult.LOOT_CANT_LOOT_THAT_NOW}:
            # item1: Guid
            item1 = await read_int(reader, 8)

            # item2: Guid
            item2 = await read_int(reader, 8)

            # bag_type_subclass: u8
            bag_type_subclass = await read_int(reader, 1)

        return SMSG_INVENTORY_CHANGE_FAILURE(
            result=result,
            required_level=required_level,
            item1=item1,
            item2=item2,
            bag_type_subclass=bag_type_subclass,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0112))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        if self.result == InventoryResult.CANT_EQUIP_LEVEL_I:
            _fmt += 'I'
            _data.append(self.required_level)
        if self.result in {InventoryResult.CANT_EQUIP_LEVEL_I, InventoryResult.CANT_EQUIP_SKILL, InventoryResult.ITEM_DOESNT_GO_TO_SLOT, InventoryResult.BAG_FULL, InventoryResult.NONEMPTY_BAG_OVER_OTHER_BAG, InventoryResult.CANT_TRADE_EQUIP_BAGS, InventoryResult.ONLY_AMMO_CAN_GO_HERE, InventoryResult.NO_REQUIRED_PROFICIENCY, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE, InventoryResult.YOU_CAN_NEVER_USE_THAT_ITEM, InventoryResult.YOU_CAN_NEVER_USE_THAT_ITEM2, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE2, InventoryResult.CANT_EQUIP_WITH_TWOHANDED, InventoryResult.CANT_DUAL_WIELD, InventoryResult.ITEM_DOESNT_GO_INTO_BAG, InventoryResult.ITEM_DOESNT_GO_INTO_BAG2, InventoryResult.CANT_CARRY_MORE_OF_THIS, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE3, InventoryResult.ITEM_CANT_STACK, InventoryResult.ITEM_CANT_BE_EQUIPPED, InventoryResult.ITEMS_CANT_BE_SWAPPED, InventoryResult.SLOT_IS_EMPTY, InventoryResult.ITEM_NOT_FOUND, InventoryResult.CANT_DROP_SOULBOUND, InventoryResult.OUT_OF_RANGE, InventoryResult.TRIED_TO_SPLIT_MORE_THAN_COUNT, InventoryResult.COULDNT_SPLIT_ITEMS, InventoryResult.MISSING_REAGENT, InventoryResult.NOT_ENOUGH_MONEY, InventoryResult.NOT_A_BAG, InventoryResult.CAN_ONLY_DO_WITH_EMPTY_BAGS, InventoryResult.DONT_OWN_THAT_ITEM, InventoryResult.CAN_EQUIP_ONLY1_QUIVER, InventoryResult.MUST_PURCHASE_THAT_BAG_SLOT, InventoryResult.TOO_FAR_AWAY_FROM_BANK, InventoryResult.ITEM_LOCKED, InventoryResult.YOU_ARE_STUNNED, InventoryResult.YOU_ARE_DEAD, InventoryResult.CANT_DO_RIGHT_NOW, InventoryResult.INT_BAG_ERROR, InventoryResult.CAN_EQUIP_ONLY1_BOLT, InventoryResult.CAN_EQUIP_ONLY1_AMMOPOUCH, InventoryResult.STACKABLE_CANT_BE_WRAPPED, InventoryResult.EQUIPPED_CANT_BE_WRAPPED, InventoryResult.WRAPPED_CANT_BE_WRAPPED, InventoryResult.BOUND_CANT_BE_WRAPPED, InventoryResult.UNIQUE_CANT_BE_WRAPPED, InventoryResult.BAGS_CANT_BE_WRAPPED, InventoryResult.ALREADY_LOOTED, InventoryResult.INVENTORY_FULL, InventoryResult.BANK_FULL, InventoryResult.ITEM_IS_CURRENTLY_SOLD_OUT, InventoryResult.BAG_FULL3, InventoryResult.ITEM_NOT_FOUND2, InventoryResult.ITEM_CANT_STACK2, InventoryResult.BAG_FULL4, InventoryResult.ITEM_SOLD_OUT, InventoryResult.OBJECT_IS_BUSY, InventoryResult.NONE, InventoryResult.NOT_IN_COMBAT, InventoryResult.NOT_WHILE_DISARMED, InventoryResult.BAG_FULL6, InventoryResult.CANT_EQUIP_RANK, InventoryResult.CANT_EQUIP_REPUTATION, InventoryResult.TOO_MANY_SPECIAL_BAGS, InventoryResult.LOOT_CANT_LOOT_THAT_NOW}:
            _fmt += 'QQB'
            _data.extend([self.item1, self.item2, self.bag_type_subclass])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.result == InventoryResult.CANT_EQUIP_LEVEL_I:
            _size += 4

        if self.result in {InventoryResult.CANT_EQUIP_LEVEL_I, InventoryResult.CANT_EQUIP_SKILL, InventoryResult.ITEM_DOESNT_GO_TO_SLOT, InventoryResult.BAG_FULL, InventoryResult.NONEMPTY_BAG_OVER_OTHER_BAG, InventoryResult.CANT_TRADE_EQUIP_BAGS, InventoryResult.ONLY_AMMO_CAN_GO_HERE, InventoryResult.NO_REQUIRED_PROFICIENCY, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE, InventoryResult.YOU_CAN_NEVER_USE_THAT_ITEM, InventoryResult.YOU_CAN_NEVER_USE_THAT_ITEM2, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE2, InventoryResult.CANT_EQUIP_WITH_TWOHANDED, InventoryResult.CANT_DUAL_WIELD, InventoryResult.ITEM_DOESNT_GO_INTO_BAG, InventoryResult.ITEM_DOESNT_GO_INTO_BAG2, InventoryResult.CANT_CARRY_MORE_OF_THIS, InventoryResult.NO_EQUIPMENT_SLOT_AVAILABLE3, InventoryResult.ITEM_CANT_STACK, InventoryResult.ITEM_CANT_BE_EQUIPPED, InventoryResult.ITEMS_CANT_BE_SWAPPED, InventoryResult.SLOT_IS_EMPTY, InventoryResult.ITEM_NOT_FOUND, InventoryResult.CANT_DROP_SOULBOUND, InventoryResult.OUT_OF_RANGE, InventoryResult.TRIED_TO_SPLIT_MORE_THAN_COUNT, InventoryResult.COULDNT_SPLIT_ITEMS, InventoryResult.MISSING_REAGENT, InventoryResult.NOT_ENOUGH_MONEY, InventoryResult.NOT_A_BAG, InventoryResult.CAN_ONLY_DO_WITH_EMPTY_BAGS, InventoryResult.DONT_OWN_THAT_ITEM, InventoryResult.CAN_EQUIP_ONLY1_QUIVER, InventoryResult.MUST_PURCHASE_THAT_BAG_SLOT, InventoryResult.TOO_FAR_AWAY_FROM_BANK, InventoryResult.ITEM_LOCKED, InventoryResult.YOU_ARE_STUNNED, InventoryResult.YOU_ARE_DEAD, InventoryResult.CANT_DO_RIGHT_NOW, InventoryResult.INT_BAG_ERROR, InventoryResult.CAN_EQUIP_ONLY1_BOLT, InventoryResult.CAN_EQUIP_ONLY1_AMMOPOUCH, InventoryResult.STACKABLE_CANT_BE_WRAPPED, InventoryResult.EQUIPPED_CANT_BE_WRAPPED, InventoryResult.WRAPPED_CANT_BE_WRAPPED, InventoryResult.BOUND_CANT_BE_WRAPPED, InventoryResult.UNIQUE_CANT_BE_WRAPPED, InventoryResult.BAGS_CANT_BE_WRAPPED, InventoryResult.ALREADY_LOOTED, InventoryResult.INVENTORY_FULL, InventoryResult.BANK_FULL, InventoryResult.ITEM_IS_CURRENTLY_SOLD_OUT, InventoryResult.BAG_FULL3, InventoryResult.ITEM_NOT_FOUND2, InventoryResult.ITEM_CANT_STACK2, InventoryResult.BAG_FULL4, InventoryResult.ITEM_SOLD_OUT, InventoryResult.OBJECT_IS_BUSY, InventoryResult.NONE, InventoryResult.NOT_IN_COMBAT, InventoryResult.NOT_WHILE_DISARMED, InventoryResult.BAG_FULL6, InventoryResult.CANT_EQUIP_RANK, InventoryResult.CANT_EQUIP_REPUTATION, InventoryResult.TOO_MANY_SPECIAL_BAGS, InventoryResult.LOOT_CANT_LOOT_THAT_NOW}:
            _size += 17

        return _size


@dataclasses.dataclass
class SMSG_OPEN_CONTAINER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_OPEN_CONTAINER:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_OPEN_CONTAINER(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0113))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_INSPECT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_INSPECT:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_INSPECT(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0114))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_INSPECT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INSPECT:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_INSPECT(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0115))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_INITIATE_TRADE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_INITIATE_TRADE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_INITIATE_TRADE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0116))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BEGIN_TRADE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BEGIN_TRADE:
        return CMSG_BEGIN_TRADE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0117))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BUSY_TRADE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BUSY_TRADE:
        return CMSG_BUSY_TRADE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0118))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_IGNORE_TRADE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_IGNORE_TRADE:
        return CMSG_IGNORE_TRADE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0119))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ACCEPT_TRADE:
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ACCEPT_TRADE:
        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return CMSG_ACCEPT_TRADE(
            unknown1=unknown1,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x011A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.unknown1)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_UNACCEPT_TRADE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_UNACCEPT_TRADE:
        return CMSG_UNACCEPT_TRADE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x011B))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CANCEL_TRADE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_TRADE:
        return CMSG_CANCEL_TRADE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x011C))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_TRADE_ITEM:
    trade_slot: int
    bag: int
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_TRADE_ITEM:
        # trade_slot: u8
        trade_slot = await read_int(reader, 1)

        # bag: u8
        bag = await read_int(reader, 1)

        # slot: u8
        slot = await read_int(reader, 1)

        return CMSG_SET_TRADE_ITEM(
            trade_slot=trade_slot,
            bag=bag,
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(3 + 4, 0x011D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBB'
        _data.extend([self.trade_slot, self.bag, self.slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CLEAR_TRADE_ITEM:
    trade_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CLEAR_TRADE_ITEM:
        # trade_slot: u8
        trade_slot = await read_int(reader, 1)

        return CMSG_CLEAR_TRADE_ITEM(
            trade_slot=trade_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x011E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.trade_slot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_TRADE_GOLD:
    gold: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_TRADE_GOLD:
        # gold: Gold
        gold = await read_int(reader, 4)

        return CMSG_SET_TRADE_GOLD(
            gold=gold,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x011F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.gold)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TRADE_STATUS:
    status: TradeStatus
    unknown1: typing.Optional[int] = None
    inventory_result: typing.Optional[InventoryResult] = None
    target_error: typing.Optional[bool] = None
    item_limit_category_id: typing.Optional[int] = None
    slot: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRADE_STATUS:
        unknown1 = None
        inventory_result = None
        target_error = None
        item_limit_category_id = None
        slot = None
        # status: TradeStatus
        status = TradeStatus(await read_int(reader, 4))

        if status == TradeStatus.BEGIN_TRADE:
            # unknown1: Guid
            unknown1 = await read_int(reader, 8)

        elif status == TradeStatus.CLOSE_WINDOW:
            # inventory_result: InventoryResult
            inventory_result = InventoryResult(await read_int(reader, 4))

            # target_error: Bool8
            target_error = await read_bool(reader, 1)

            # item_limit_category_id: u32
            item_limit_category_id = await read_int(reader, 4)

        elif status in {TradeStatus.ONLY_CONJURED, TradeStatus.NOT_ON_TAPLIST}:
            # slot: u8
            slot = await read_int(reader, 1)

        return SMSG_TRADE_STATUS(
            status=status,
            unknown1=unknown1,
            inventory_result=inventory_result,
            target_error=target_error,
            item_limit_category_id=item_limit_category_id,
            slot=slot,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0120))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.status.value)
        if self.status == TradeStatus.BEGIN_TRADE:
            _fmt += 'Q'
            _data.append(self.unknown1)
        elif self.status == TradeStatus.CLOSE_WINDOW:
            _fmt += 'IBI'
            _data.extend([self.inventory_result.value, self.target_error, self.item_limit_category_id])
        elif self.status in {TradeStatus.ONLY_CONJURED, TradeStatus.NOT_ON_TAPLIST}:
            _fmt += 'B'
            _data.append(self.slot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        if self.status == TradeStatus.BEGIN_TRADE:
            _size += 8
        elif self.status == TradeStatus.CLOSE_WINDOW:
            _size += 9
        elif self.status in {TradeStatus.ONLY_CONJURED, TradeStatus.NOT_ON_TAPLIST}:
            _size += 1

        return _size


@dataclasses.dataclass
class SMSG_TRADE_STATUS_EXTENDED:
    self_player: bool
    trade_slot_count1: int
    trade_slot_count2: int
    money_in_trade: int
    spell_on_lowest_slot: int
    trade_slots: typing.List[TradeSlot]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRADE_STATUS_EXTENDED:
        # self_player: Bool8
        self_player = await read_bool(reader, 1)

        # trade_slot_count1: u32
        trade_slot_count1 = await read_int(reader, 4)

        # trade_slot_count2: u32
        trade_slot_count2 = await read_int(reader, 4)

        # money_in_trade: Gold
        money_in_trade = await read_int(reader, 4)

        # spell_on_lowest_slot: Spell
        spell_on_lowest_slot = await read_int(reader, 4)

        # trade_slots: TradeSlot[7]
        trade_slots = []
        for _ in range(0, 7):
            trade_slots.append(await TradeSlot.read(reader))

        return SMSG_TRADE_STATUS_EXTENDED(
            self_player=self_player,
            trade_slot_count1=trade_slot_count1,
            trade_slot_count2=trade_slot_count2,
            money_in_trade=money_in_trade,
            spell_on_lowest_slot=spell_on_lowest_slot,
            trade_slots=trade_slots,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(444 + 2, 0x0121))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BIIII'
        _data.extend([self.self_player, self.trade_slot_count1, self.trade_slot_count2, self.money_in_trade, self.spell_on_lowest_slot])
        # trade_slots: TradeSlot[7]
        for i in self.trade_slots:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_INITIALIZE_FACTIONS:
    factions: typing.List[FactionInitializer]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INITIALIZE_FACTIONS:
        # amount_of_factions: u32
        amount_of_factions = await read_int(reader, 4)

        # factions: FactionInitializer[amount_of_factions]
        factions = []
        for _ in range(0, amount_of_factions):
            factions.append(await FactionInitializer.read(reader))

        return SMSG_INITIALIZE_FACTIONS(
            factions=factions,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0122))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.factions))
        # factions: FactionInitializer[amount_of_factions]
        for i in self.factions:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + 5 * len(self.factions)


@dataclasses.dataclass
class SMSG_SET_FACTION_VISIBLE:
    faction: Faction

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_FACTION_VISIBLE:
        # faction: Faction
        faction = Faction(await read_int(reader, 2))

        return SMSG_SET_FACTION_VISIBLE(
            faction=faction,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 2, 0x0123))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'H'
        _data.append(self.faction.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SET_FACTION_STANDING:
    faction_standings: typing.List[FactionStanding]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_FACTION_STANDING:
        # amount_of_faction_standings: u32
        amount_of_faction_standings = await read_int(reader, 4)

        # faction_standings: FactionStanding[amount_of_faction_standings]
        faction_standings = []
        for _ in range(0, amount_of_faction_standings):
            faction_standings.append(await FactionStanding.read(reader))

        return SMSG_SET_FACTION_STANDING(
            faction_standings=faction_standings,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0124))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.faction_standings))
        # faction_standings: FactionStanding[amount_of_faction_standings]
        for i in self.faction_standings:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + 6 * len(self.faction_standings)


@dataclasses.dataclass
class CMSG_SET_FACTION_ATWAR:
    faction: Faction
    flags: FactionFlag

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_FACTION_ATWAR:
        # faction: Faction
        faction = Faction(await read_int(reader, 2))

        # flags: FactionFlag
        flags = FactionFlag(await read_int(reader, 1))

        return CMSG_SET_FACTION_ATWAR(
            faction=faction,
            flags=flags,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(3 + 4, 0x0125))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'HB'
        _data.extend([self.faction.value, self.flags.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SET_PROFICIENCY:
    class_type: ItemClass
    item_sub_class_mask: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_PROFICIENCY:
        # class_type: ItemClass
        class_type = ItemClass(await read_int(reader, 1))

        # item_sub_class_mask: u32
        item_sub_class_mask = await read_int(reader, 4)

        return SMSG_SET_PROFICIENCY(
            class_type=class_type,
            item_sub_class_mask=item_sub_class_mask,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x0127))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BI'
        _data.extend([self.class_type.value, self.item_sub_class_mask])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_ACTION_BUTTON:
    button: int
    action: int
    misc: int
    action_type: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_ACTION_BUTTON:
        # button: u8
        button = await read_int(reader, 1)

        # action: u16
        action = await read_int(reader, 2)

        # misc: u8
        misc = await read_int(reader, 1)

        # action_type: u8
        action_type = await read_int(reader, 1)

        return CMSG_SET_ACTION_BUTTON(
            button=button,
            action=action,
            misc=misc,
            action_type=action_type,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 4, 0x0128))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BHBB'
        _data.extend([self.button, self.action, self.misc, self.action_type])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ACTION_BUTTONS:
    data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ACTION_BUTTONS:
        # data: u32[120]
        data = []
        for _ in range(0, 120):
            data.append(await read_int(reader, 4))

        return SMSG_ACTION_BUTTONS(
            data=data,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(480 + 2, 0x0129))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.data)}I'
        _data.extend([*self.data])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_INITIAL_SPELLS:
    unknown1: int
    initial_spells: typing.List[InitialSpell]
    cooldowns: typing.List[CooldownSpell]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INITIAL_SPELLS:
        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # spell_count: u16
        spell_count = await read_int(reader, 2)

        # initial_spells: InitialSpell[spell_count]
        initial_spells = []
        for _ in range(0, spell_count):
            initial_spells.append(await InitialSpell.read(reader))

        # cooldown_count: u16
        cooldown_count = await read_int(reader, 2)

        # cooldowns: CooldownSpell[cooldown_count]
        cooldowns = []
        for _ in range(0, cooldown_count):
            cooldowns.append(await CooldownSpell.read(reader))

        return SMSG_INITIAL_SPELLS(
            unknown1=unknown1,
            initial_spells=initial_spells,
            cooldowns=cooldowns,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x012A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BH'
        _data.extend([self.unknown1, len(self.initial_spells)])
        # initial_spells: InitialSpell[spell_count]
        for i in self.initial_spells:
            _fmt, _data = i.write(_fmt, _data)

        # cooldown_count: u16
        _fmt += 'H'
        _data.append(len(self.cooldowns))

        # cooldowns: CooldownSpell[cooldown_count]
        for i in self.cooldowns:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + 4 * len(self.initial_spells) + 14 * len(self.cooldowns)


@dataclasses.dataclass
class SMSG_LEARNED_SPELL:
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LEARNED_SPELL:
        # id: Spell
        id = await read_int(reader, 4)

        return SMSG_LEARNED_SPELL(
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x012B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SUPERCEDED_SPELL:
    new_spell_id: int
    old_spell_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SUPERCEDED_SPELL:
        # new_spell_id: u16
        new_spell_id = await read_int(reader, 2)

        # old_spell_id: u16
        old_spell_id = await read_int(reader, 2)

        return SMSG_SUPERCEDED_SPELL(
            new_spell_id=new_spell_id,
            old_spell_id=old_spell_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x012C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'HH'
        _data.extend([self.new_spell_id, self.old_spell_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CAST_SPELL:
    spell: int
    targets: SpellCastTargets

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CAST_SPELL:
        # spell: Spell
        spell = await read_int(reader, 4)

        # targets: SpellCastTargets
        targets = await SpellCastTargets.read(reader)

        return CMSG_CAST_SPELL(
            spell=spell,
            targets=targets,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x012E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.spell)
        # targets: SpellCastTargets
        _fmt, _data = self.targets.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + self.targets.size()


@dataclasses.dataclass
class CMSG_CANCEL_CAST:
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_CAST:
        # id: Spell
        id = await read_int(reader, 4)

        return CMSG_CANCEL_CAST(
            id=id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x012F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CAST_RESULT:
    spell: int
    result: SimpleSpellCastResult
    reason: typing.Optional[CastFailureReason] = None
    required_spell_focus: typing.Optional[int] = None
    area: typing.Optional[Area] = None
    equipped_item_class: typing.Optional[int] = None
    equipped_item_subclass_mask: typing.Optional[int] = None
    equipped_item_inventory_type_mask: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CAST_RESULT:
        reason = None
        required_spell_focus = None
        area = None
        equipped_item_class = None
        equipped_item_subclass_mask = None
        equipped_item_inventory_type_mask = None
        # spell: Spell
        spell = await read_int(reader, 4)

        # result: SimpleSpellCastResult
        result = SimpleSpellCastResult(await read_int(reader, 1))

        if result == SimpleSpellCastResult.SUCCESS:
            # reason: CastFailureReason
            reason = CastFailureReason(await read_int(reader, 1))

            if reason == CastFailureReason.REQUIRES_SPELL_FOCUS:
                # required_spell_focus: u32
                required_spell_focus = await read_int(reader, 4)

            elif reason == CastFailureReason.REQUIRES_AREA:
                # area: Area
                area = Area(await read_int(reader, 4))

            elif reason == CastFailureReason.EQUIPPED_ITEM_CLASS:
                # equipped_item_class: u32
                equipped_item_class = await read_int(reader, 4)

                # equipped_item_subclass_mask: u32
                equipped_item_subclass_mask = await read_int(reader, 4)

                # equipped_item_inventory_type_mask: u32
                equipped_item_inventory_type_mask = await read_int(reader, 4)

        return SMSG_CAST_RESULT(
            spell=spell,
            result=result,
            reason=reason,
            required_spell_focus=required_spell_focus,
            area=area,
            equipped_item_class=equipped_item_class,
            equipped_item_subclass_mask=equipped_item_subclass_mask,
            equipped_item_inventory_type_mask=equipped_item_inventory_type_mask,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0130))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([self.spell, self.result.value])
        if self.result == SimpleSpellCastResult.SUCCESS:
            _fmt += 'B'
            _data.append(self.reason.value)
            if self.reason == CastFailureReason.REQUIRES_SPELL_FOCUS:
                _fmt += 'I'
                _data.append(self.required_spell_focus)
            elif self.reason == CastFailureReason.REQUIRES_AREA:
                _fmt += 'I'
                _data.append(self.area.value)
            elif self.reason == CastFailureReason.EQUIPPED_ITEM_CLASS:
                _fmt += 'III'
                _data.extend([self.equipped_item_class, self.equipped_item_subclass_mask, self.equipped_item_inventory_type_mask])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 5

        if self.result == SimpleSpellCastResult.SUCCESS:
            _size += 1

            if self.reason == CastFailureReason.REQUIRES_SPELL_FOCUS:
                _size += 4
            elif self.reason == CastFailureReason.REQUIRES_AREA:
                _size += 4
            elif self.reason == CastFailureReason.EQUIPPED_ITEM_CLASS:
                _size += 12


        return _size


@dataclasses.dataclass
class SMSG_SPELL_START:
    cast_item: int
    caster: int
    spell: int
    flags: CastFlags
    timer: int
    targets: SpellCastTargets
    ammo_display_id: typing.Optional[int] = None
    ammo_inventory_type: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELL_START:
        ammo_display_id = None
        ammo_inventory_type = None
        # cast_item: PackedGuid
        cast_item = await read_packed_guid(reader)

        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # spell: Spell
        spell = await read_int(reader, 4)

        # flags: CastFlags
        flags = CastFlags(await read_int(reader, 2))

        # timer: u32
        timer = await read_int(reader, 4)

        # targets: SpellCastTargets
        targets = await SpellCastTargets.read(reader)

        if CastFlags.AMMO in flags:
            # ammo_display_id: u32
            ammo_display_id = await read_int(reader, 4)

            # ammo_inventory_type: u32
            ammo_inventory_type = await read_int(reader, 4)

        return SMSG_SPELL_START(
            cast_item=cast_item,
            caster=caster,
            spell=spell,
            flags=flags,
            timer=timer,
            targets=targets,
            ammo_display_id=ammo_display_id,
            ammo_inventory_type=ammo_inventory_type,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0131))
        _fmt = "<4s"
        _data = [_data]

        # cast_item: PackedGuid
        _fmt, _data = packed_guid_write(self.cast_item, _fmt, _data)

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # flags: CastFlags
        _fmt += 'H'
        _data.append(self.flags.value)

        # timer: u32
        _fmt += 'I'
        _data.append(self.timer)

        # targets: SpellCastTargets
        _fmt, _data = self.targets.write(_fmt, _data)

        if CastFlags.AMMO in self.flags:
            _fmt += 'II'
            _data.extend([self.ammo_display_id, self.ammo_inventory_type])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 10 + packed_guid_size(self.cast_item) + packed_guid_size(self.caster) + self.targets.size()

        if CastFlags.AMMO in self.flags:
            _size += 8

        return _size


@dataclasses.dataclass
class SMSG_SPELL_GO:
    cast_item: int
    caster: int
    spell: int
    flags: CastFlags
    hits: typing.List[int]
    misses: typing.List[SpellMiss]
    targets: SpellCastTargets
    ammo_display_id: typing.Optional[int] = None
    ammo_inventory_type: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELL_GO:
        ammo_display_id = None
        ammo_inventory_type = None
        # cast_item: PackedGuid
        cast_item = await read_packed_guid(reader)

        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # spell: Spell
        spell = await read_int(reader, 4)

        # flags: CastFlags
        flags = CastFlags(await read_int(reader, 2))

        # amount_of_hits: u8
        amount_of_hits = await read_int(reader, 1)

        # hits: Guid[amount_of_hits]
        hits = []
        for _ in range(0, amount_of_hits):
            hits.append(await read_int(reader, 8))

        # amount_of_misses: u8
        amount_of_misses = await read_int(reader, 1)

        # misses: SpellMiss[amount_of_misses]
        misses = []
        for _ in range(0, amount_of_misses):
            misses.append(await SpellMiss.read(reader))

        # targets: SpellCastTargets
        targets = await SpellCastTargets.read(reader)

        if CastFlags.AMMO in flags:
            # ammo_display_id: u32
            ammo_display_id = await read_int(reader, 4)

            # ammo_inventory_type: u32
            ammo_inventory_type = await read_int(reader, 4)

        return SMSG_SPELL_GO(
            cast_item=cast_item,
            caster=caster,
            spell=spell,
            flags=flags,
            hits=hits,
            misses=misses,
            targets=targets,
            ammo_display_id=ammo_display_id,
            ammo_inventory_type=ammo_inventory_type,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0132))
        _fmt = "<4s"
        _data = [_data]

        # cast_item: PackedGuid
        _fmt, _data = packed_guid_write(self.cast_item, _fmt, _data)

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # flags: CastFlags
        _fmt += 'H'
        _data.append(self.flags.value)

        # amount_of_hits: u8
        _fmt += 'B'
        _data.append(len(self.hits))

        # hits: Guid[amount_of_hits]
        _fmt += f'{len(self.hits)}Q'
        _data.extend([*self.hits])

        # amount_of_misses: u8
        _fmt += 'B'
        _data.append(len(self.misses))

        # misses: SpellMiss[amount_of_misses]
        for i in self.misses:
            _fmt, _data = i.write(_fmt, _data)

        # targets: SpellCastTargets
        _fmt, _data = self.targets.write(_fmt, _data)

        if CastFlags.AMMO in self.flags:
            _fmt += 'II'
            _data.extend([self.ammo_display_id, self.ammo_inventory_type])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 8 + packed_guid_size(self.cast_item) + packed_guid_size(self.caster) + 8 * len(self.hits) + 9 * len(self.misses) + self.targets.size()

        if CastFlags.AMMO in self.flags:
            _size += 8

        return _size


@dataclasses.dataclass
class SMSG_SPELL_FAILURE:
    guid: int
    spell: int
    result: SpellCastResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELL_FAILURE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # spell: Spell
        spell = await read_int(reader, 4)

        # result: SpellCastResult
        result = SpellCastResult(await read_int(reader, 1))

        return SMSG_SPELL_FAILURE(
            guid=guid,
            spell=spell,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(13 + 2, 0x0133))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIB'
        _data.extend([self.guid, self.spell, self.result.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELL_COOLDOWN:
    guid: int
    cooldowns: typing.List[SpellCooldownStatus]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELL_COOLDOWN:
        _size = 0

        # guid: Guid
        guid = await read_int(reader, 8)
        _size += 8

        # cooldowns: SpellCooldownStatus[-]
        cooldowns = []
        while _size < body_size:
            cooldowns.append(await SpellCooldownStatus.read(reader))
            _size += 8

        return SMSG_SPELL_COOLDOWN(
            guid=guid,
            cooldowns=cooldowns,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0134))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        # cooldowns: SpellCooldownStatus[-]
        for i in self.cooldowns:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + 8 * len(self.cooldowns)


@dataclasses.dataclass
class SMSG_COOLDOWN_EVENT:
    id: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_COOLDOWN_EVENT:
        # id: Spell
        id = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_COOLDOWN_EVENT(
            id=id,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0135))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.id, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CANCEL_AURA:
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_AURA:
        # id: Spell
        id = await read_int(reader, 4)

        return CMSG_CANCEL_AURA(
            id=id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0136))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_UPDATE_AURA_DURATION:
    aura_slot: int
    aura_duration: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_UPDATE_AURA_DURATION:
        # aura_slot: u8
        aura_slot = await read_int(reader, 1)

        # aura_duration: u32
        aura_duration = await read_int(reader, 4)

        return SMSG_UPDATE_AURA_DURATION(
            aura_slot=aura_slot,
            aura_duration=aura_duration,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x0137))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BI'
        _data.extend([self.aura_slot, self.aura_duration])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PET_CAST_FAILED:
    id: int
    unknown1: int
    result: SpellCastResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_CAST_FAILED:
        # id: Spell
        id = await read_int(reader, 4)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # result: SpellCastResult
        result = SpellCastResult(await read_int(reader, 1))

        return SMSG_PET_CAST_FAILED(
            id=id,
            unknown1=unknown1,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(6 + 2, 0x0138))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IBB'
        _data.extend([self.id, self.unknown1, self.result.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_CHANNEL_START_Server:
    spell: int
    duration: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_CHANNEL_START_Server:
        # spell: Spell
        spell = await read_int(reader, 4)

        # duration: u32
        duration = await read_int(reader, 4)

        return MSG_CHANNEL_START_Server(
            spell=spell,
            duration=duration,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0139))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.spell, self.duration])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_CHANNEL_UPDATE_Server:
    time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_CHANNEL_UPDATE_Server:
        # time: u32
        time = await read_int(reader, 4)

        return MSG_CHANNEL_UPDATE_Server(
            time=time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x013A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.time)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CANCEL_CHANNELLING:
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_CHANNELLING:
        # id: Spell
        id = await read_int(reader, 4)

        return CMSG_CANCEL_CHANNELLING(
            id=id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x013B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AI_REACTION:
    guid: int
    reaction: AiReaction

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AI_REACTION:
        # guid: Guid
        guid = await read_int(reader, 8)

        # reaction: AiReaction
        reaction = AiReaction(await read_int(reader, 4))

        return SMSG_AI_REACTION(
            guid=guid,
            reaction=reaction,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x013C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.reaction.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_SELECTION:
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_SELECTION:
        # target: Guid
        target = await read_int(reader, 8)

        return CMSG_SET_SELECTION(
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x013D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.target)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_TARGET_OBSOLETE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_TARGET_OBSOLETE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_SET_TARGET_OBSOLETE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x013E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ATTACKSWING:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ATTACKSWING:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_ATTACKSWING(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0141))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ATTACKSTOP:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ATTACKSTOP:
        return CMSG_ATTACKSTOP()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0142))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ATTACKSTART:
    attacker: int
    victim: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKSTART:
        # attacker: Guid
        attacker = await read_int(reader, 8)

        # victim: Guid
        victim = await read_int(reader, 8)

        return SMSG_ATTACKSTART(
            attacker=attacker,
            victim=victim,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x0143))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQ'
        _data.extend([self.attacker, self.victim])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ATTACKSTOP:
    player: int
    enemy: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKSTOP:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # enemy: PackedGuid
        enemy = await read_packed_guid(reader)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return SMSG_ATTACKSTOP(
            player=player,
            enemy=enemy,
            unknown1=unknown1,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0144))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # enemy: PackedGuid
        _fmt, _data = packed_guid_write(self.enemy, _fmt, _data)

        # unknown1: u32
        _fmt += 'I'
        _data.append(self.unknown1)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.player) + packed_guid_size(self.enemy)


@dataclasses.dataclass
class SMSG_ATTACKSWING_NOTINRANGE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKSWING_NOTINRANGE:
        return SMSG_ATTACKSWING_NOTINRANGE()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0145))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ATTACKSWING_BADFACING:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKSWING_BADFACING:
        return SMSG_ATTACKSWING_BADFACING()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0146))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ATTACKSWING_NOTSTANDING:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKSWING_NOTSTANDING:
        return SMSG_ATTACKSWING_NOTSTANDING()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0147))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ATTACKSWING_DEADTARGET:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKSWING_DEADTARGET:
        return SMSG_ATTACKSWING_DEADTARGET()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0148))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ATTACKSWING_CANT_ATTACK:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKSWING_CANT_ATTACK:
        return SMSG_ATTACKSWING_CANT_ATTACK()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0149))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ATTACKERSTATEUPDATE:
    hit_info: HitInfo
    attacker: int
    target: int
    total_damage: int
    damages: typing.List[DamageInfo]
    damage_state: int
    unknown1: int
    spell_id: int
    blocked_amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ATTACKERSTATEUPDATE:
        # hit_info: HitInfo
        hit_info = HitInfo(await read_int(reader, 4))

        # attacker: PackedGuid
        attacker = await read_packed_guid(reader)

        # target: PackedGuid
        target = await read_packed_guid(reader)

        # total_damage: u32
        total_damage = await read_int(reader, 4)

        # amount_of_damages: u8
        amount_of_damages = await read_int(reader, 1)

        # damages: DamageInfo[amount_of_damages]
        damages = []
        for _ in range(0, amount_of_damages):
            damages.append(await DamageInfo.read(reader))

        # damage_state: u32
        damage_state = await read_int(reader, 4)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # spell_id: u32
        spell_id = await read_int(reader, 4)

        # blocked_amount: u32
        blocked_amount = await read_int(reader, 4)

        return SMSG_ATTACKERSTATEUPDATE(
            hit_info=hit_info,
            attacker=attacker,
            target=target,
            total_damage=total_damage,
            damages=damages,
            damage_state=damage_state,
            unknown1=unknown1,
            spell_id=spell_id,
            blocked_amount=blocked_amount,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x014A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.hit_info.value)
        # attacker: PackedGuid
        _fmt, _data = packed_guid_write(self.attacker, _fmt, _data)

        # target: PackedGuid
        _fmt, _data = packed_guid_write(self.target, _fmt, _data)

        # total_damage: u32
        _fmt += 'I'
        _data.append(self.total_damage)

        # amount_of_damages: u8
        _fmt += 'B'
        _data.append(len(self.damages))

        # damages: DamageInfo[amount_of_damages]
        for i in self.damages:
            _fmt, _data = i.write(_fmt, _data)

        # damage_state: u32
        _fmt += 'I'
        _data.append(self.damage_state)

        # unknown1: u32
        _fmt += 'I'
        _data.append(self.unknown1)

        # spell_id: u32
        _fmt += 'I'
        _data.append(self.spell_id)

        # blocked_amount: u32
        _fmt += 'I'
        _data.append(self.blocked_amount)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 25 + packed_guid_size(self.attacker) + packed_guid_size(self.target) + 20 * len(self.damages)


@dataclasses.dataclass
class SMSG_CANCEL_COMBAT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CANCEL_COMBAT:
        return SMSG_CANCEL_COMBAT()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x014E))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELLHEALLOG:
    victim: int
    caster: int
    id: int
    damage: int
    critical: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLHEALLOG:
        # victim: PackedGuid
        victim = await read_packed_guid(reader)

        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # id: Spell
        id = await read_int(reader, 4)

        # damage: u32
        damage = await read_int(reader, 4)

        # critical: Bool8
        critical = await read_bool(reader, 1)

        return SMSG_SPELLHEALLOG(
            victim=victim,
            caster=caster,
            id=id,
            damage=damage,
            critical=critical,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0150))
        _fmt = "<4s"
        _data = [_data]

        # victim: PackedGuid
        _fmt, _data = packed_guid_write(self.victim, _fmt, _data)

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # id: Spell
        _fmt += 'I'
        _data.append(self.id)

        # damage: u32
        _fmt += 'I'
        _data.append(self.damage)

        # critical: Bool8
        _fmt += 'B'
        _data.append(self.critical)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + packed_guid_size(self.victim) + packed_guid_size(self.caster)


@dataclasses.dataclass
class SMSG_SPELLENERGIZELOG:
    victim: int
    caster: int
    spell: int
    power: Power
    damage: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLENERGIZELOG:
        # victim: PackedGuid
        victim = await read_packed_guid(reader)

        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # spell: Spell
        spell = await read_int(reader, 4)

        # power: Power
        power = Power(await read_int(reader, 4))

        # damage: u32
        damage = await read_int(reader, 4)

        return SMSG_SPELLENERGIZELOG(
            victim=victim,
            caster=caster,
            spell=spell,
            power=power,
            damage=damage,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0151))
        _fmt = "<4s"
        _data = [_data]

        # victim: PackedGuid
        _fmt, _data = packed_guid_write(self.victim, _fmt, _data)

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # power: Power
        _fmt += 'I'
        _data.append(self.power.value)

        # damage: u32
        _fmt += 'I'
        _data.append(self.damage)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + packed_guid_size(self.victim) + packed_guid_size(self.caster)


@dataclasses.dataclass
class SMSG_BINDPOINTUPDATE:
    position: Vector3d
    map: Map
    area: Area

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BINDPOINTUPDATE:
        # position: Vector3d
        position = await Vector3d.read(reader)

        # map: Map
        map = Map(await read_int(reader, 4))

        # area: Area
        area = Area(await read_int(reader, 4))

        return SMSG_BINDPOINTUPDATE(
            position=position,
            map=map,
            area=area,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x0155))
        _fmt = "<4s"
        _data = [_data]

        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # map: Map
        _fmt += 'I'
        _data.append(self.map.value)

        # area: Area
        _fmt += 'I'
        _data.append(self.area.value)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PLAYERBOUND:
    guid: int
    area: Area

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAYERBOUND:
        # guid: Guid
        guid = await read_int(reader, 8)

        # area: Area
        area = Area(await read_int(reader, 4))

        return SMSG_PLAYERBOUND(
            guid=guid,
            area=area,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0158))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.area.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CLIENT_CONTROL_UPDATE:
    guid: int
    allow_movement: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CLIENT_CONTROL_UPDATE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # allow_movement: Bool8
        allow_movement = await read_bool(reader, 1)

        return SMSG_CLIENT_CONTROL_UPDATE(
            guid=guid,
            allow_movement=allow_movement,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0159))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # allow_movement: Bool8
        _fmt += 'B'
        _data.append(self.allow_movement)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_REPOP_REQUEST:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REPOP_REQUEST:
        return CMSG_REPOP_REQUEST()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x015A))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_RESURRECT_REQUEST:
    guid: int
    name: str
    player: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RESURRECT_REQUEST:
        # guid: Guid
        guid = await read_int(reader, 8)

        # name: SizedCString
        name = await read_sized_cstring(reader)

        # player: Bool8
        player = await read_bool(reader, 1)

        return SMSG_RESURRECT_REQUEST(
            guid=guid,
            name=name,
            player=player,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x015B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QI{len(self.name)}sBB'
        _data.extend([self.guid, len(self.name) + 1, self.name.encode('utf-8'), 0, self.player])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 14 + len(self.name)


@dataclasses.dataclass
class CMSG_RESURRECT_RESPONSE:
    guid: int
    status: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_RESURRECT_RESPONSE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # status: u8
        status = await read_int(reader, 1)

        return CMSG_RESURRECT_RESPONSE(
            guid=guid,
            status=status,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x015C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.status])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LOOT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOOT:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_LOOT(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x015D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LOOT_MONEY:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOOT_MONEY:
        return CMSG_LOOT_MONEY()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x015E))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LOOT_RELEASE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOOT_RELEASE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_LOOT_RELEASE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x015F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_RESPONSE:
    guid: int
    loot_method: LootMethod
    gold: int
    items: typing.List[LootItem]
    loot_error: typing.Optional[LootMethodError] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_RESPONSE:
        loot_error = None
        # guid: Guid
        guid = await read_int(reader, 8)

        # loot_method: LootMethod
        loot_method = LootMethod(await read_int(reader, 1))

        if loot_method == LootMethod.ERROR:
            # loot_error: LootMethodError
            loot_error = LootMethodError(await read_int(reader, 1))

        # gold: Gold
        gold = await read_int(reader, 4)

        # amount_of_items: u8
        amount_of_items = await read_int(reader, 1)

        # items: LootItem[amount_of_items]
        items = []
        for _ in range(0, amount_of_items):
            items.append(await LootItem.read(reader))

        return SMSG_LOOT_RESPONSE(
            guid=guid,
            loot_method=loot_method,
            loot_error=loot_error,
            gold=gold,
            items=items,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0160))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.loot_method.value])
        if self.loot_method == LootMethod.ERROR:
            _fmt += 'B'
            _data.append(self.loot_error.value)
        # gold: Gold
        _fmt += 'I'
        _data.append(self.gold)

        # amount_of_items: u8
        _fmt += 'B'
        _data.append(len(self.items))

        # items: LootItem[amount_of_items]
        for i in self.items:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 14 + 6 * len(self.items)

        if self.loot_method == LootMethod.ERROR:
            _size += 1

        return _size


@dataclasses.dataclass
class SMSG_LOOT_RELEASE_RESPONSE:
    guid: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_RELEASE_RESPONSE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        return SMSG_LOOT_RELEASE_RESPONSE(
            guid=guid,
            unknown1=unknown1,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x0161))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.unknown1])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_REMOVED:
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_REMOVED:
        # slot: u8
        slot = await read_int(reader, 1)

        return SMSG_LOOT_REMOVED(
            slot=slot,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x0162))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.slot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_MONEY_NOTIFY:
    amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_MONEY_NOTIFY:
        # amount: u32
        amount = await read_int(reader, 4)

        return SMSG_LOOT_MONEY_NOTIFY(
            amount=amount,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0163))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.amount)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_CLEAR_MONEY:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_CLEAR_MONEY:
        return SMSG_LOOT_CLEAR_MONEY()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0165))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_PUSH_RESULT:
    guid: int
    source: NewItemSource
    creation_type: NewItemCreationType
    alert_chat: NewItemChatAlert
    bag_slot: int
    item_slot: int
    item: int
    item_suffix_factor: int
    item_random_property_id: int
    item_count: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_PUSH_RESULT:
        # guid: Guid
        guid = await read_int(reader, 8)

        # source: NewItemSource
        source = NewItemSource(await read_int(reader, 4))

        # creation_type: NewItemCreationType
        creation_type = NewItemCreationType(await read_int(reader, 4))

        # alert_chat: NewItemChatAlert
        alert_chat = NewItemChatAlert(await read_int(reader, 4))

        # bag_slot: u8
        bag_slot = await read_int(reader, 1)

        # item_slot: u32
        item_slot = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        # item_suffix_factor: u32
        item_suffix_factor = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # item_count: u32
        item_count = await read_int(reader, 4)

        return SMSG_ITEM_PUSH_RESULT(
            guid=guid,
            source=source,
            creation_type=creation_type,
            alert_chat=alert_chat,
            bag_slot=bag_slot,
            item_slot=item_slot,
            item=item,
            item_suffix_factor=item_suffix_factor,
            item_random_property_id=item_random_property_id,
            item_count=item_count,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(41 + 2, 0x0166))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIIIBIIIII'
        _data.extend([self.guid, self.source.value, self.creation_type.value, self.alert_chat.value, self.bag_slot, self.item_slot, self.item, self.item_suffix_factor, self.item_random_property_id, self.item_count])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DUEL_REQUESTED:
    initiator: int
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DUEL_REQUESTED:
        # initiator: Guid
        initiator = await read_int(reader, 8)

        # target: Guid
        target = await read_int(reader, 8)

        return SMSG_DUEL_REQUESTED(
            initiator=initiator,
            target=target,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x0167))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQ'
        _data.extend([self.initiator, self.target])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DUEL_OUTOFBOUNDS:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DUEL_OUTOFBOUNDS:
        return SMSG_DUEL_OUTOFBOUNDS()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0168))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DUEL_INBOUNDS:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DUEL_INBOUNDS:
        return SMSG_DUEL_INBOUNDS()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0169))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DUEL_COMPLETE:
    ended_without_interruption: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DUEL_COMPLETE:
        # ended_without_interruption: Bool8
        ended_without_interruption = await read_bool(reader, 1)

        return SMSG_DUEL_COMPLETE(
            ended_without_interruption=ended_without_interruption,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x016A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.ended_without_interruption)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DUEL_WINNER:
    reason: DuelWinnerReason
    opponent_name: str
    initiator_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DUEL_WINNER:
        # reason: DuelWinnerReason
        reason = DuelWinnerReason(await read_int(reader, 1))

        # opponent_name: CString
        opponent_name = await read_cstring(reader)

        # initiator_name: CString
        initiator_name = await read_cstring(reader)

        return SMSG_DUEL_WINNER(
            reason=reason,
            opponent_name=opponent_name,
            initiator_name=initiator_name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x016B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'B{len(self.opponent_name)}sB{len(self.initiator_name)}sB'
        _data.extend([self.reason.value, self.opponent_name.encode('utf-8'), 0, self.initiator_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 3 + len(self.opponent_name) + len(self.initiator_name)


@dataclasses.dataclass
class CMSG_DUEL_ACCEPTED:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_DUEL_ACCEPTED:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_DUEL_ACCEPTED(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x016C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_DUEL_CANCELLED:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_DUEL_CANCELLED:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_DUEL_CANCELLED(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x016D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MOUNTRESULT:
    result: MountResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOUNTRESULT:
        # result: MountResult
        result = MountResult(await read_int(reader, 4))

        return SMSG_MOUNTRESULT(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x016E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DISMOUNTRESULT:
    result: DismountResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DISMOUNTRESULT:
        # result: DismountResult
        result = DismountResult(await read_int(reader, 4))

        return SMSG_DISMOUNTRESULT(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x016F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MOUNTSPECIAL_ANIM:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOUNTSPECIAL_ANIM:
        return CMSG_MOUNTSPECIAL_ANIM()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0171))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MOUNTSPECIAL_ANIM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MOUNTSPECIAL_ANIM:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_MOUNTSPECIAL_ANIM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0172))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PET_TAME_FAILURE:
    reason: PetTameFailureReason

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_TAME_FAILURE:
        # reason: PetTameFailureReason
        reason = PetTameFailureReason(await read_int(reader, 1))

        return SMSG_PET_TAME_FAILURE(
            reason=reason,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x0173))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.reason.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PET_SET_ACTION:
    guid: int
    position1: int
    data1: int
    position2: typing.Optional[int] = None
    data2: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_SET_ACTION:
        position2 = None
        data2 = None
        _size = 0

        # guid: Guid
        guid = await read_int(reader, 8)
        _size += 8

        # position1: u32
        position1 = await read_int(reader, 4)
        _size += 4

        # data1: u32
        data1 = await read_int(reader, 4)
        _size += 4

        # extra: optional
        if _size < body_size:
            # position2: u32
            position2 = await read_int(reader, 4)
            _size += 4

            # data2: u32
            data2 = await read_int(reader, 4)
            _size += 4

        return CMSG_PET_SET_ACTION(
            guid=guid,
            position1=position1,
            data1=data1,
            position2=position2,
            data2=data2,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0174))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.guid, self.position1, self.data1])
        # extra: optional
        if self.position2 is not None and self.data2 is not None:
            _fmt += 'II'
            _data.extend([self.position2, self.data2])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 16

        # extra: optional
        if self.position2 is not None and self.data2 is not None:
            _size += 8

        return _size


@dataclasses.dataclass
class CMSG_PET_ACTION:
    pet: int
    data: int
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_ACTION:
        # pet: Guid
        pet = await read_int(reader, 8)

        # data: u32
        data = await read_int(reader, 4)

        # target: Guid
        target = await read_int(reader, 8)

        return CMSG_PET_ACTION(
            pet=pet,
            data=data,
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 4, 0x0175))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIQ'
        _data.extend([self.pet, self.data, self.target])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PET_ABANDON:
    pet: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_ABANDON:
        # pet: Guid
        pet = await read_int(reader, 8)

        return CMSG_PET_ABANDON(
            pet=pet,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0176))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.pet)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PET_RENAME:
    pet: int
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_RENAME:
        # pet: Guid
        pet = await read_int(reader, 8)

        # name: CString
        name = await read_cstring(reader)

        return CMSG_PET_RENAME(
            pet=pet,
            name=name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0177))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.name)}sB'
        _data.extend([self.pet, self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.name)


@dataclasses.dataclass
class SMSG_PET_NAME_INVALID:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_NAME_INVALID:
        return SMSG_PET_NAME_INVALID()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0178))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PET_SPELLS:
    pet: int
    duration: typing.Optional[int] = None
    react: typing.Optional[PetReactState] = None
    command: typing.Optional[PetCommandState] = None
    unknown: typing.Optional[int] = None
    pet_enabled: typing.Optional[PetEnabled] = None
    action_bars: typing.Optional[typing.List[int]] = None
    spells: typing.Optional[typing.List[int]] = None
    cooldowns: typing.Optional[typing.List[PetSpellCooldown]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_SPELLS:
        duration = None
        react = None
        command = None
        unknown = None
        pet_enabled = None
        action_bars = None
        amount_of_spells = None
        spells = None
        amount_of_cooldowns = None
        cooldowns = None
        _size = 0

        # pet: Guid
        pet = await read_int(reader, 8)
        _size += 8

        # action_bars: optional
        if _size < body_size:
            # duration: u32
            duration = await read_int(reader, 4)
            _size += 4

            # react: PetReactState
            react = PetReactState(await read_int(reader, 1))
            _size += 1

            # command: PetCommandState
            command = PetCommandState(await read_int(reader, 1))
            _size += 1

            # unknown: u8
            unknown = await read_int(reader, 1)
            _size += 1

            # pet_enabled: PetEnabled
            pet_enabled = PetEnabled(await read_int(reader, 1))
            _size += 1

            # action_bars: u32[10]
            action_bars = []
            for _ in range(0, 10):
                action_bars.append(await read_int(reader, 4))
                _size += 4

            # amount_of_spells: u8
            amount_of_spells = await read_int(reader, 1)
            _size += 1

            # spells: u32[amount_of_spells]
            spells = []
            for _ in range(0, amount_of_spells):
                spells.append(await read_int(reader, 4))
                _size += 4

            # amount_of_cooldowns: u8
            amount_of_cooldowns = await read_int(reader, 1)
            _size += 1

            # cooldowns: PetSpellCooldown[amount_of_cooldowns]
            cooldowns = []
            for _ in range(0, amount_of_cooldowns):
                cooldowns.append(await PetSpellCooldown.read(reader))
                _size += 12

        return SMSG_PET_SPELLS(
            pet=pet,
            duration=duration,
            react=react,
            command=command,
            unknown=unknown,
            pet_enabled=pet_enabled,
            action_bars=action_bars,
            spells=spells,
            cooldowns=cooldowns,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0179))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.pet)
        # action_bars: optional
        if self.duration is not None and self.react is not None and self.command is not None and self.unknown is not None and self.pet_enabled is not None and self.action_bars is not None and self.spells is not None and self.cooldowns is not None:
            _fmt += f'IBBBB{len(self.action_bars)}IB{len(self.spells)}IB'
            _data.extend([self.duration, self.react.value, self.command.value, self.unknown, self.pet_enabled.value, *self.action_bars, len(self.spells), *self.spells, len(self.cooldowns)])
            # cooldowns: PetSpellCooldown[amount_of_cooldowns]
            for i in self.cooldowns:
                _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 8

        # action_bars: optional
        if self.duration is not None and self.react is not None and self.command is not None and self.unknown is not None and self.pet_enabled is not None and self.action_bars is not None and self.spells is not None and self.cooldowns is not None:
            _size += 50 + 4 * len(self.spells) + 12 * len(self.cooldowns)

        return _size


@dataclasses.dataclass
class SMSG_PET_MODE:
    guid: int
    react_state: PetReactState
    command_state: PetCommandState
    unknown1: int
    pet_enabled: PetEnabled

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_MODE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # react_state: PetReactState
        react_state = PetReactState(await read_int(reader, 1))

        # command_state: PetCommandState
        command_state = PetCommandState(await read_int(reader, 1))

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # pet_enabled: PetEnabled
        pet_enabled = PetEnabled(await read_int(reader, 1))

        return SMSG_PET_MODE(
            guid=guid,
            react_state=react_state,
            command_state=command_state,
            unknown1=unknown1,
            pet_enabled=pet_enabled,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x017A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QBBBB'
        _data.extend([self.guid, self.react_state.value, self.command_state.value, self.unknown1, self.pet_enabled.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GOSSIP_HELLO:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GOSSIP_HELLO:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_GOSSIP_HELLO(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x017B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GOSSIP_SELECT_OPTION:
    guid: int
    gossip_list_id: int
    code: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GOSSIP_SELECT_OPTION:
        code = None
        _size = 0

        # guid: Guid
        guid = await read_int(reader, 8)
        _size += 8

        # gossip_list_id: u32
        gossip_list_id = await read_int(reader, 4)
        _size += 4

        # unknown: optional
        if _size < body_size:
            # code: CString
            code = await read_cstring(reader)
            _size += len(code) + 1

        return CMSG_GOSSIP_SELECT_OPTION(
            guid=guid,
            gossip_list_id=gossip_list_id,
            code=code,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x017C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.gossip_list_id])
        # unknown: optional
        if self.code is not None:
            _fmt += f'{len(self.code)}sB'
            _data.extend([self.code.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 12

        # unknown: optional
        if self.code is not None:
            _size += 1 + len(self.code)

        return _size


@dataclasses.dataclass
class SMSG_GOSSIP_MESSAGE:
    guid: int
    title_text_id: int
    gossips: typing.List[GossipItem]
    quests: typing.List[QuestItem]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GOSSIP_MESSAGE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # title_text_id: u32
        title_text_id = await read_int(reader, 4)

        # amount_of_gossip_items: u32
        amount_of_gossip_items = await read_int(reader, 4)

        # gossips: GossipItem[amount_of_gossip_items]
        gossips = []
        for _ in range(0, amount_of_gossip_items):
            gossips.append(await GossipItem.read(reader))

        # amount_of_quests: u32
        amount_of_quests = await read_int(reader, 4)

        # quests: QuestItem[amount_of_quests]
        quests = []
        for _ in range(0, amount_of_quests):
            quests.append(await QuestItem.read(reader))

        return SMSG_GOSSIP_MESSAGE(
            guid=guid,
            title_text_id=title_text_id,
            gossips=gossips,
            quests=quests,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x017D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.guid, self.title_text_id, len(self.gossips)])
        # gossips: GossipItem[amount_of_gossip_items]
        for i in self.gossips:
            _fmt, _data = i.write(_fmt, _data)

        # amount_of_quests: u32
        _fmt += 'I'
        _data.append(len(self.quests))

        # quests: QuestItem[amount_of_quests]
        for i in self.quests:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 20 + sum([i.size() for i in self.gossips]) + sum([i.size() for i in self.quests])


@dataclasses.dataclass
class SMSG_GOSSIP_COMPLETE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GOSSIP_COMPLETE:
        return SMSG_GOSSIP_COMPLETE()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x017E))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_NPC_TEXT_QUERY:
    text_id: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_NPC_TEXT_QUERY:
        # text_id: u32
        text_id = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_NPC_TEXT_QUERY(
            text_id=text_id,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x017F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.text_id, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_NPC_TEXT_UPDATE:
    text_id: int
    texts: typing.List[NpcTextUpdate]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_NPC_TEXT_UPDATE:
        # text_id: u32
        text_id = await read_int(reader, 4)

        # texts: NpcTextUpdate[8]
        texts = []
        for _ in range(0, 8):
            texts.append(await NpcTextUpdate.read(reader))

        return SMSG_NPC_TEXT_UPDATE(
            text_id=text_id,
            texts=texts,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0180))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.text_id)
        # texts: NpcTextUpdate[8]
        for i in self.texts:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + sum([i.size() for i in self.texts])


@dataclasses.dataclass
class CMSG_QUESTGIVER_STATUS_QUERY:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_STATUS_QUERY:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_QUESTGIVER_STATUS_QUERY(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0182))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_STATUS:
    guid: int
    status: QuestGiverStatus

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_STATUS:
        # guid: Guid
        guid = await read_int(reader, 8)

        # status: QuestGiverStatus
        status = QuestGiverStatus(await read_int(reader, 4))

        return SMSG_QUESTGIVER_STATUS(
            guid=guid,
            status=status,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0183))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.status.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUESTGIVER_HELLO:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_HELLO:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_QUESTGIVER_HELLO(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0184))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_QUEST_LIST:
    npc: int
    title: str
    emote_delay: int
    emote: int
    quest_items: typing.List[QuestItem]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_QUEST_LIST:
        # npc: Guid
        npc = await read_int(reader, 8)

        # title: CString
        title = await read_cstring(reader)

        # emote_delay: u32
        emote_delay = await read_int(reader, 4)

        # emote: u32
        emote = await read_int(reader, 4)

        # amount_of_entries: u8
        amount_of_entries = await read_int(reader, 1)

        # quest_items: QuestItem[amount_of_entries]
        quest_items = []
        for _ in range(0, amount_of_entries):
            quest_items.append(await QuestItem.read(reader))

        return SMSG_QUESTGIVER_QUEST_LIST(
            npc=npc,
            title=title,
            emote_delay=emote_delay,
            emote=emote,
            quest_items=quest_items,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0185))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'Q{len(self.title)}sBIIB'
        _data.extend([self.npc, self.title.encode('utf-8'), 0, self.emote_delay, self.emote, len(self.quest_items)])
        # quest_items: QuestItem[amount_of_entries]
        for i in self.quest_items:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 18 + len(self.title) + sum([i.size() for i in self.quest_items])


@dataclasses.dataclass
class CMSG_QUESTGIVER_QUERY_QUEST:
    guid: int
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_QUERY_QUEST:
        # guid: Guid
        guid = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return CMSG_QUESTGIVER_QUERY_QUEST(
            guid=guid,
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0186))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.quest_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUESTGIVER_QUEST_AUTOLAUNCH:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_QUEST_AUTOLAUNCH:
        return CMSG_QUESTGIVER_QUEST_AUTOLAUNCH()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0187))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_QUEST_DETAILS:
    guid: int
    quest_id: int
    title: str
    details: str
    objectives: str
    auto_finish: bool
    choice_item_rewards: typing.List[QuestItemReward]
    item_rewards: typing.List[QuestItemReward]
    money_reward: int
    reward_spell: int
    emotes: typing.List[QuestDetailsEmote]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_QUEST_DETAILS:
        # guid: Guid
        guid = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # title: CString
        title = await read_cstring(reader)

        # details: CString
        details = await read_cstring(reader)

        # objectives: CString
        objectives = await read_cstring(reader)

        # auto_finish: Bool32
        auto_finish = await read_bool(reader, 4)

        # amount_of_choice_item_rewards: u32
        amount_of_choice_item_rewards = await read_int(reader, 4)

        # choice_item_rewards: QuestItemReward[amount_of_choice_item_rewards]
        choice_item_rewards = []
        for _ in range(0, amount_of_choice_item_rewards):
            choice_item_rewards.append(await QuestItemReward.read(reader))

        # amount_of_item_rewards: u32
        amount_of_item_rewards = await read_int(reader, 4)

        # item_rewards: QuestItemReward[amount_of_item_rewards]
        item_rewards = []
        for _ in range(0, amount_of_item_rewards):
            item_rewards.append(await QuestItemReward.read(reader))

        # money_reward: Gold
        money_reward = await read_int(reader, 4)

        # reward_spell: Spell
        reward_spell = await read_int(reader, 4)

        # amount_of_emotes: u32
        amount_of_emotes = await read_int(reader, 4)

        # emotes: QuestDetailsEmote[amount_of_emotes]
        emotes = []
        for _ in range(0, amount_of_emotes):
            emotes.append(await QuestDetailsEmote.read(reader))

        return SMSG_QUESTGIVER_QUEST_DETAILS(
            guid=guid,
            quest_id=quest_id,
            title=title,
            details=details,
            objectives=objectives,
            auto_finish=auto_finish,
            choice_item_rewards=choice_item_rewards,
            item_rewards=item_rewards,
            money_reward=money_reward,
            reward_spell=reward_spell,
            emotes=emotes,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0188))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QI{len(self.title)}sB{len(self.details)}sB{len(self.objectives)}sBII'
        _data.extend([self.guid, self.quest_id, self.title.encode('utf-8'), 0, self.details.encode('utf-8'), 0, self.objectives.encode('utf-8'), 0, self.auto_finish, len(self.choice_item_rewards)])
        # choice_item_rewards: QuestItemReward[amount_of_choice_item_rewards]
        for i in self.choice_item_rewards:
            _fmt, _data = i.write(_fmt, _data)

        # amount_of_item_rewards: u32
        _fmt += 'I'
        _data.append(len(self.item_rewards))

        # item_rewards: QuestItemReward[amount_of_item_rewards]
        for i in self.item_rewards:
            _fmt, _data = i.write(_fmt, _data)

        # money_reward: Gold
        _fmt += 'I'
        _data.append(self.money_reward)

        # reward_spell: Spell
        _fmt += 'I'
        _data.append(self.reward_spell)

        # amount_of_emotes: u32
        _fmt += 'I'
        _data.append(len(self.emotes))

        # emotes: QuestDetailsEmote[amount_of_emotes]
        for i in self.emotes:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 39 + len(self.title) + len(self.details) + len(self.objectives) + 8 * len(self.choice_item_rewards) + 8 * len(self.item_rewards) + 8 * len(self.emotes)


@dataclasses.dataclass
class CMSG_QUESTGIVER_ACCEPT_QUEST:
    guid: int
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_ACCEPT_QUEST:
        # guid: Guid
        guid = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return CMSG_QUESTGIVER_ACCEPT_QUEST(
            guid=guid,
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0189))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.quest_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUESTGIVER_COMPLETE_QUEST:
    guid: int
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_COMPLETE_QUEST:
        # guid: Guid
        guid = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return CMSG_QUESTGIVER_COMPLETE_QUEST(
            guid=guid,
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x018A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.quest_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_REQUEST_ITEMS:
    npc: int
    quest_id: int
    title: str
    request_items_text: str
    emote_delay: int
    emote: int
    auto_finish: bool
    required_money: int
    required_items: typing.List[QuestItemRequirement]
    unknown1: int
    completable: QuestCompletable
    flags2: int
    flags3: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_REQUEST_ITEMS:
        # npc: Guid
        npc = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # title: CString
        title = await read_cstring(reader)

        # request_items_text: CString
        request_items_text = await read_cstring(reader)

        # emote_delay: u32
        emote_delay = await read_int(reader, 4)

        # emote: u32
        emote = await read_int(reader, 4)

        # auto_finish: Bool32
        auto_finish = await read_bool(reader, 4)

        # required_money: Gold
        required_money = await read_int(reader, 4)

        # amount_of_required_items: u32
        amount_of_required_items = await read_int(reader, 4)

        # required_items: QuestItemRequirement[amount_of_required_items]
        required_items = []
        for _ in range(0, amount_of_required_items):
            required_items.append(await QuestItemRequirement.read(reader))

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # completable: QuestCompletable
        completable = QuestCompletable(await read_int(reader, 4))

        # flags2: u32
        flags2 = await read_int(reader, 4)

        # flags3: u32
        flags3 = await read_int(reader, 4)

        return SMSG_QUESTGIVER_REQUEST_ITEMS(
            npc=npc,
            quest_id=quest_id,
            title=title,
            request_items_text=request_items_text,
            emote_delay=emote_delay,
            emote=emote,
            auto_finish=auto_finish,
            required_money=required_money,
            required_items=required_items,
            unknown1=unknown1,
            completable=completable,
            flags2=flags2,
            flags3=flags3,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x018B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QI{len(self.title)}sB{len(self.request_items_text)}sBIIIII'
        _data.extend([self.npc, self.quest_id, self.title.encode('utf-8'), 0, self.request_items_text.encode('utf-8'), 0, self.emote_delay, self.emote, self.auto_finish, self.required_money, len(self.required_items)])
        # required_items: QuestItemRequirement[amount_of_required_items]
        for i in self.required_items:
            _fmt, _data = i.write(_fmt, _data)

        # unknown1: u32
        _fmt += 'I'
        _data.append(self.unknown1)

        # completable: QuestCompletable
        _fmt += 'I'
        _data.append(self.completable.value)

        # flags2: u32
        _fmt += 'I'
        _data.append(self.flags2)

        # flags3: u32
        _fmt += 'I'
        _data.append(self.flags3)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 50 + len(self.title) + len(self.request_items_text) + 12 * len(self.required_items)


@dataclasses.dataclass
class CMSG_QUESTGIVER_REQUEST_REWARD:
    guid: int
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_REQUEST_REWARD:
        # guid: Guid
        guid = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return CMSG_QUESTGIVER_REQUEST_REWARD(
            guid=guid,
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x018C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.quest_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_OFFER_REWARD:
    npc: int
    quest_id: int
    title: str
    offer_reward_text: str
    auto_finish: bool
    emotes: typing.List[NpcTextUpdateEmote]
    choice_item_rewards: typing.List[QuestItemRequirement]
    item_rewards: typing.List[QuestItemRequirement]
    money_reward: int
    reward_spell: int
    reward_spell_cast: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_OFFER_REWARD:
        # npc: Guid
        npc = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # title: CString
        title = await read_cstring(reader)

        # offer_reward_text: CString
        offer_reward_text = await read_cstring(reader)

        # auto_finish: Bool32
        auto_finish = await read_bool(reader, 4)

        # amount_of_emotes: u32
        amount_of_emotes = await read_int(reader, 4)

        # emotes: NpcTextUpdateEmote[amount_of_emotes]
        emotes = []
        for _ in range(0, amount_of_emotes):
            emotes.append(await NpcTextUpdateEmote.read(reader))

        # amount_of_choice_item_rewards: u32
        amount_of_choice_item_rewards = await read_int(reader, 4)

        # choice_item_rewards: QuestItemRequirement[amount_of_choice_item_rewards]
        choice_item_rewards = []
        for _ in range(0, amount_of_choice_item_rewards):
            choice_item_rewards.append(await QuestItemRequirement.read(reader))

        # amount_of_item_rewards: u32
        amount_of_item_rewards = await read_int(reader, 4)

        # item_rewards: QuestItemRequirement[amount_of_item_rewards]
        item_rewards = []
        for _ in range(0, amount_of_item_rewards):
            item_rewards.append(await QuestItemRequirement.read(reader))

        # money_reward: Gold
        money_reward = await read_int(reader, 4)

        # reward_spell: Spell
        reward_spell = await read_int(reader, 4)

        # reward_spell_cast: Spell
        reward_spell_cast = await read_int(reader, 4)

        return SMSG_QUESTGIVER_OFFER_REWARD(
            npc=npc,
            quest_id=quest_id,
            title=title,
            offer_reward_text=offer_reward_text,
            auto_finish=auto_finish,
            emotes=emotes,
            choice_item_rewards=choice_item_rewards,
            item_rewards=item_rewards,
            money_reward=money_reward,
            reward_spell=reward_spell,
            reward_spell_cast=reward_spell_cast,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x018D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QI{len(self.title)}sB{len(self.offer_reward_text)}sBII'
        _data.extend([self.npc, self.quest_id, self.title.encode('utf-8'), 0, self.offer_reward_text.encode('utf-8'), 0, self.auto_finish, len(self.emotes)])
        # emotes: NpcTextUpdateEmote[amount_of_emotes]
        for i in self.emotes:
            _fmt, _data = i.write(_fmt, _data)

        # amount_of_choice_item_rewards: u32
        _fmt += 'I'
        _data.append(len(self.choice_item_rewards))

        # choice_item_rewards: QuestItemRequirement[amount_of_choice_item_rewards]
        for i in self.choice_item_rewards:
            _fmt, _data = i.write(_fmt, _data)

        # amount_of_item_rewards: u32
        _fmt += 'I'
        _data.append(len(self.item_rewards))

        # item_rewards: QuestItemRequirement[amount_of_item_rewards]
        for i in self.item_rewards:
            _fmt, _data = i.write(_fmt, _data)

        # money_reward: Gold
        _fmt += 'I'
        _data.append(self.money_reward)

        # reward_spell: Spell
        _fmt += 'I'
        _data.append(self.reward_spell)

        # reward_spell_cast: Spell
        _fmt += 'I'
        _data.append(self.reward_spell_cast)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 42 + len(self.title) + len(self.offer_reward_text) + 8 * len(self.emotes) + 12 * len(self.choice_item_rewards) + 12 * len(self.item_rewards)


@dataclasses.dataclass
class CMSG_QUESTGIVER_CHOOSE_REWARD:
    guid: int
    quest_id: int
    reward: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_CHOOSE_REWARD:
        # guid: Guid
        guid = await read_int(reader, 8)

        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # reward: u32
        reward = await read_int(reader, 4)

        return CMSG_QUESTGIVER_CHOOSE_REWARD(
            guid=guid,
            quest_id=quest_id,
            reward=reward,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x018E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.guid, self.quest_id, self.reward])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_QUEST_INVALID:
    msg: QuestFailedReason

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_QUEST_INVALID:
        # msg: QuestFailedReason
        msg = QuestFailedReason(await read_int(reader, 4))

        return SMSG_QUESTGIVER_QUEST_INVALID(
            msg=msg,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x018F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.msg.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUESTGIVER_CANCEL:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTGIVER_CANCEL:
        return CMSG_QUESTGIVER_CANCEL()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0190))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_QUEST_COMPLETE:
    quest_id: int
    unknown: int
    experience_reward: int
    money_reward: int
    item_rewards: typing.List[QuestItemReward]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_QUEST_COMPLETE:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # unknown: u32
        unknown = await read_int(reader, 4)

        # experience_reward: u32
        experience_reward = await read_int(reader, 4)

        # money_reward: Gold
        money_reward = await read_int(reader, 4)

        # amount_of_item_rewards: u32
        amount_of_item_rewards = await read_int(reader, 4)

        # item_rewards: QuestItemReward[amount_of_item_rewards]
        item_rewards = []
        for _ in range(0, amount_of_item_rewards):
            item_rewards.append(await QuestItemReward.read(reader))

        return SMSG_QUESTGIVER_QUEST_COMPLETE(
            quest_id=quest_id,
            unknown=unknown,
            experience_reward=experience_reward,
            money_reward=money_reward,
            item_rewards=item_rewards,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0191))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIII'
        _data.extend([self.quest_id, self.unknown, self.experience_reward, self.money_reward, len(self.item_rewards)])
        # item_rewards: QuestItemReward[amount_of_item_rewards]
        for i in self.item_rewards:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 20 + 8 * len(self.item_rewards)


@dataclasses.dataclass
class SMSG_QUESTGIVER_QUEST_FAILED:
    quest_id: int
    reason: QuestFailedReason

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTGIVER_QUEST_FAILED:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # reason: QuestFailedReason
        reason = QuestFailedReason(await read_int(reader, 4))

        return SMSG_QUESTGIVER_QUEST_FAILED(
            quest_id=quest_id,
            reason=reason,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0192))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.quest_id, self.reason.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUESTLOG_SWAP_QUEST:
    slot1: int
    slot2: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTLOG_SWAP_QUEST:
        # slot1: u8
        slot1 = await read_int(reader, 1)

        # slot2: u8
        slot2 = await read_int(reader, 1)

        return CMSG_QUESTLOG_SWAP_QUEST(
            slot1=slot1,
            slot2=slot2,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x0193))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.slot1, self.slot2])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUESTLOG_REMOVE_QUEST:
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUESTLOG_REMOVE_QUEST:
        # slot: u8
        slot = await read_int(reader, 1)

        return CMSG_QUESTLOG_REMOVE_QUEST(
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x0194))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.slot)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTLOG_FULL:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTLOG_FULL:
        return SMSG_QUESTLOG_FULL()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0195))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTUPDATE_FAILED:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTUPDATE_FAILED:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return SMSG_QUESTUPDATE_FAILED(
            quest_id=quest_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0196))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.quest_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTUPDATE_FAILEDTIMER:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTUPDATE_FAILEDTIMER:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return SMSG_QUESTUPDATE_FAILEDTIMER(
            quest_id=quest_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0197))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.quest_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTUPDATE_COMPLETE:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTUPDATE_COMPLETE:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return SMSG_QUESTUPDATE_COMPLETE(
            quest_id=quest_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0198))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.quest_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTUPDATE_ADD_KILL:
    quest_id: int
    creature_id: int
    kill_count: int
    required_kill_count: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTUPDATE_ADD_KILL:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # creature_id: u32
        creature_id = await read_int(reader, 4)

        # kill_count: u32
        kill_count = await read_int(reader, 4)

        # required_kill_count: u32
        required_kill_count = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_QUESTUPDATE_ADD_KILL(
            quest_id=quest_id,
            creature_id=creature_id,
            kill_count=kill_count,
            required_kill_count=required_kill_count,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(24 + 2, 0x0199))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIIQ'
        _data.extend([self.quest_id, self.creature_id, self.kill_count, self.required_kill_count, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUESTUPDATE_ADD_ITEM:
    required_item_id: int
    items_required: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUESTUPDATE_ADD_ITEM:
        # required_item_id: u32
        required_item_id = await read_int(reader, 4)

        # items_required: u32
        items_required = await read_int(reader, 4)

        return SMSG_QUESTUPDATE_ADD_ITEM(
            required_item_id=required_item_id,
            items_required=items_required,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x019A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.required_item_id, self.items_required])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUEST_CONFIRM_ACCEPT:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUEST_CONFIRM_ACCEPT:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return CMSG_QUEST_CONFIRM_ACCEPT(
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x019B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.quest_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUEST_CONFIRM_ACCEPT:
    quest_id: int
    quest_title: str
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUEST_CONFIRM_ACCEPT:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        # quest_title: CString
        quest_title = await read_cstring(reader)

        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_QUEST_CONFIRM_ACCEPT(
            quest_id=quest_id,
            quest_title=quest_title,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x019C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.quest_title)}sBQ'
        _data.extend([self.quest_id, self.quest_title.encode('utf-8'), 0, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 13 + len(self.quest_title)


@dataclasses.dataclass
class CMSG_PUSHQUESTTOPARTY:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PUSHQUESTTOPARTY:
        # quest_id: u32
        quest_id = await read_int(reader, 4)

        return CMSG_PUSHQUESTTOPARTY(
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x019D))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.quest_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LIST_INVENTORY:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LIST_INVENTORY:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_LIST_INVENTORY(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x019E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LIST_INVENTORY:
    vendor: int
    items: typing.List[ListInventoryItem]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LIST_INVENTORY:
        # vendor: Guid
        vendor = await read_int(reader, 8)

        # amount_of_items: u8
        amount_of_items = await read_int(reader, 1)

        # items: ListInventoryItem[amount_of_items]
        items = []
        for _ in range(0, amount_of_items):
            items.append(await ListInventoryItem.read(reader))

        return SMSG_LIST_INVENTORY(
            vendor=vendor,
            items=items,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x019F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.vendor, len(self.items)])
        # items: ListInventoryItem[amount_of_items]
        for i in self.items:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + 28 * len(self.items)


@dataclasses.dataclass
class CMSG_SELL_ITEM:
    vendor: int
    item: int
    amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SELL_ITEM:
        # vendor: Guid
        vendor = await read_int(reader, 8)

        # item: Guid
        item = await read_int(reader, 8)

        # amount: u8
        amount = await read_int(reader, 1)

        return CMSG_SELL_ITEM(
            vendor=vendor,
            item=item,
            amount=amount,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(17 + 4, 0x01A0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QQB'
        _data.extend([self.vendor, self.item, self.amount])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SELL_ITEM:
    guid: int
    item: int
    result: SellItemResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SELL_ITEM:
        # guid: Guid
        guid = await read_int(reader, 8)

        # item: Guid
        item = await read_int(reader, 8)

        # result: SellItemResult
        result = SellItemResult(await read_int(reader, 1))

        return SMSG_SELL_ITEM(
            guid=guid,
            item=item,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(17 + 2, 0x01A1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQB'
        _data.extend([self.guid, self.item, self.result.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BUY_ITEM:
    vendor: int
    item: int
    amount: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BUY_ITEM:
        # vendor: Guid
        vendor = await read_int(reader, 8)

        # item: Item
        item = await read_int(reader, 4)

        # amount: u8
        amount = await read_int(reader, 1)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        return CMSG_BUY_ITEM(
            vendor=vendor,
            item=item,
            amount=amount,
            unknown1=unknown1,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(14 + 4, 0x01A2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIBB'
        _data.extend([self.vendor, self.item, self.amount, self.unknown1])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BUY_ITEM_IN_SLOT:
    vendor: int
    item: int
    bag: int
    bag_slot: int
    amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BUY_ITEM_IN_SLOT:
        # vendor: Guid
        vendor = await read_int(reader, 8)

        # item: Item
        item = await read_int(reader, 4)

        # bag: Guid
        bag = await read_int(reader, 8)

        # bag_slot: u8
        bag_slot = await read_int(reader, 1)

        # amount: u8
        amount = await read_int(reader, 1)

        return CMSG_BUY_ITEM_IN_SLOT(
            vendor=vendor,
            item=item,
            bag=bag,
            bag_slot=bag_slot,
            amount=amount,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(22 + 4, 0x01A3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIQBB'
        _data.extend([self.vendor, self.item, self.bag, self.bag_slot, self.amount])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BUY_ITEM:
    guid: int
    vendor_slot: int
    amount_for_sale: int
    amount_bought: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BUY_ITEM:
        # guid: Guid
        guid = await read_int(reader, 8)

        # vendor_slot: u32
        vendor_slot = await read_int(reader, 4)

        # amount_for_sale: u32
        amount_for_sale = await read_int(reader, 4)

        # amount_bought: u32
        amount_bought = await read_int(reader, 4)

        return SMSG_BUY_ITEM(
            guid=guid,
            vendor_slot=vendor_slot,
            amount_for_sale=amount_for_sale,
            amount_bought=amount_bought,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x01A4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIII'
        _data.extend([self.guid, self.vendor_slot, self.amount_for_sale, self.amount_bought])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BUY_FAILED:
    guid: int
    item: int
    result: BuyResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BUY_FAILED:
        # guid: Guid
        guid = await read_int(reader, 8)

        # item: Item
        item = await read_int(reader, 4)

        # result: BuyResult
        result = BuyResult(await read_int(reader, 1))

        return SMSG_BUY_FAILED(
            guid=guid,
            item=item,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(13 + 2, 0x01A5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIB'
        _data.extend([self.guid, self.item, self.result.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SHOWTAXINODES:
    unknown1: int
    guid: int
    nearest_node: int
    nodes: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SHOWTAXINODES:
        _size = 0

        # unknown1: u32
        unknown1 = await read_int(reader, 4)
        _size += 4

        # guid: Guid
        guid = await read_int(reader, 8)
        _size += 8

        # nearest_node: u32
        nearest_node = await read_int(reader, 4)
        _size += 4

        # nodes: u32[-]
        nodes = []
        while _size < body_size:
            nodes.append(await read_int(reader, 4))
            _size += 4

        return SMSG_SHOWTAXINODES(
            unknown1=unknown1,
            guid=guid,
            nearest_node=nearest_node,
            nodes=nodes,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01A9))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'IQI{len(self.nodes)}I'
        _data.extend([self.unknown1, self.guid, self.nearest_node, *self.nodes])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + 4 * len(self.nodes)


@dataclasses.dataclass
class CMSG_TAXINODE_STATUS_QUERY:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TAXINODE_STATUS_QUERY:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_TAXINODE_STATUS_QUERY(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01AA))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TAXINODE_STATUS:
    guid: int
    taxi_mask_node_known: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TAXINODE_STATUS:
        # guid: Guid
        guid = await read_int(reader, 8)

        # taxi_mask_node_known: Bool8
        taxi_mask_node_known = await read_bool(reader, 1)

        return SMSG_TAXINODE_STATUS(
            guid=guid,
            taxi_mask_node_known=taxi_mask_node_known,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x01AB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.taxi_mask_node_known])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TAXIQUERYAVAILABLENODES:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TAXIQUERYAVAILABLENODES:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_TAXIQUERYAVAILABLENODES(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01AC))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ACTIVATETAXI:
    guid: int
    source_node: int
    destination_node: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ACTIVATETAXI:
        # guid: Guid
        guid = await read_int(reader, 8)

        # source_node: u32
        source_node = await read_int(reader, 4)

        # destination_node: u32
        destination_node = await read_int(reader, 4)

        return CMSG_ACTIVATETAXI(
            guid=guid,
            source_node=source_node,
            destination_node=destination_node,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x01AD))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.guid, self.source_node, self.destination_node])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ACTIVATETAXIREPLY:
    reply: ActivateTaxiReply

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ACTIVATETAXIREPLY:
        # reply: ActivateTaxiReply
        reply = ActivateTaxiReply(await read_int(reader, 4))

        return SMSG_ACTIVATETAXIREPLY(
            reply=reply,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01AE))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.reply.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_NEW_TAXI_PATH:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_NEW_TAXI_PATH:
        return SMSG_NEW_TAXI_PATH()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x01AF))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TRAINER_LIST:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TRAINER_LIST:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_TRAINER_LIST(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01B0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TRAINER_LIST:
    guid: int
    trainer_type: int
    spells: typing.List[TrainerSpell]
    greeting: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRAINER_LIST:
        # guid: Guid
        guid = await read_int(reader, 8)

        # trainer_type: u32
        trainer_type = await read_int(reader, 4)

        # amount_of_spells: u32
        amount_of_spells = await read_int(reader, 4)

        # spells: TrainerSpell[amount_of_spells]
        spells = []
        for _ in range(0, amount_of_spells):
            spells.append(await TrainerSpell.read(reader))

        # greeting: CString
        greeting = await read_cstring(reader)

        return SMSG_TRAINER_LIST(
            guid=guid,
            trainer_type=trainer_type,
            spells=spells,
            greeting=greeting,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01B1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.guid, self.trainer_type, len(self.spells)])
        # spells: TrainerSpell[amount_of_spells]
        for i in self.spells:
            _fmt, _data = i.write(_fmt, _data)

        # greeting: CString
        _fmt += f'{len(self.greeting)}sB'
        _data.extend([self.greeting.encode('utf-8'), 0])

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 17 + 38 * len(self.spells) + len(self.greeting)


@dataclasses.dataclass
class CMSG_TRAINER_BUY_SPELL:
    guid: int
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TRAINER_BUY_SPELL:
        # guid: Guid
        guid = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        return CMSG_TRAINER_BUY_SPELL(
            guid=guid,
            id=id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x01B2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TRAINER_BUY_SUCCEEDED:
    guid: int
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRAINER_BUY_SUCCEEDED:
        # guid: Guid
        guid = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        return SMSG_TRAINER_BUY_SUCCEEDED(
            guid=guid,
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01B3))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TRAINER_BUY_FAILED:
    guid: int
    id: int
    error: TrainingFailureReason

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TRAINER_BUY_FAILED:
        # guid: Guid
        guid = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        # error: TrainingFailureReason
        error = TrainingFailureReason(await read_int(reader, 4))

        return SMSG_TRAINER_BUY_FAILED(
            guid=guid,
            id=id,
            error=error,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x01B4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.guid, self.id, self.error.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BINDER_ACTIVATE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BINDER_ACTIVATE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_BINDER_ACTIVATE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01B5))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BANKER_ACTIVATE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BANKER_ACTIVATE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_BANKER_ACTIVATE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01B7))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SHOW_BANK:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SHOW_BANK:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_SHOW_BANK(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01B8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BUY_BANK_SLOT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BUY_BANK_SLOT:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_BUY_BANK_SLOT(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01B9))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BUY_BANK_SLOT_RESULT:
    result: BuyBankSlotResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BUY_BANK_SLOT_RESULT:
        # result: BuyBankSlotResult
        result = BuyBankSlotResult(await read_int(reader, 4))

        return SMSG_BUY_BANK_SLOT_RESULT(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01BA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PETITION_SHOWLIST:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PETITION_SHOWLIST:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_PETITION_SHOWLIST(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01BB))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PETITION_SHOWLIST:
    npc: int
    petitions: typing.List[PetitionShowlist]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PETITION_SHOWLIST:
        # npc: Guid
        npc = await read_int(reader, 8)

        # amount_of_petitions: u8
        amount_of_petitions = await read_int(reader, 1)

        # petitions: PetitionShowlist[amount_of_petitions]
        petitions = []
        for _ in range(0, amount_of_petitions):
            petitions.append(await PetitionShowlist.read(reader))

        return SMSG_PETITION_SHOWLIST(
            npc=npc,
            petitions=petitions,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01BC))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.npc, len(self.petitions)])
        # petitions: PetitionShowlist[amount_of_petitions]
        for i in self.petitions:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + 20 * len(self.petitions)


@dataclasses.dataclass
class CMSG_PETITION_BUY:
    npc: int
    unknown1: int
    unknown2: int
    name: str
    unknown3: int
    unknown4: int
    unknown5: int
    unknown6: int
    unknown7: int
    unknown8: int
    unknown9: int
    unknown10: int
    unknown11: int
    unknown12: int
    unknown13: int
    unknown14: int
    index: int
    unknown15: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PETITION_BUY:
        # npc: Guid
        npc = await read_int(reader, 8)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # unknown2: Guid
        unknown2 = await read_int(reader, 8)

        # name: CString
        name = await read_cstring(reader)

        # unknown3: u32
        unknown3 = await read_int(reader, 4)

        # unknown4: u32
        unknown4 = await read_int(reader, 4)

        # unknown5: u32
        unknown5 = await read_int(reader, 4)

        # unknown6: u32
        unknown6 = await read_int(reader, 4)

        # unknown7: u32
        unknown7 = await read_int(reader, 4)

        # unknown8: u32
        unknown8 = await read_int(reader, 4)

        # unknown9: u32
        unknown9 = await read_int(reader, 4)

        # unknown10: u32
        unknown10 = await read_int(reader, 4)

        # unknown11: u32
        unknown11 = await read_int(reader, 4)

        # unknown12: u32
        unknown12 = await read_int(reader, 4)

        # unknown13: u16
        unknown13 = await read_int(reader, 2)

        # unknown14: u8
        unknown14 = await read_int(reader, 1)

        # index: u32
        index = await read_int(reader, 4)

        # unknown15: u32
        unknown15 = await read_int(reader, 4)

        return CMSG_PETITION_BUY(
            npc=npc,
            unknown1=unknown1,
            unknown2=unknown2,
            name=name,
            unknown3=unknown3,
            unknown4=unknown4,
            unknown5=unknown5,
            unknown6=unknown6,
            unknown7=unknown7,
            unknown8=unknown8,
            unknown9=unknown9,
            unknown10=unknown10,
            unknown11=unknown11,
            unknown12=unknown12,
            unknown13=unknown13,
            unknown14=unknown14,
            index=index,
            unknown15=unknown15,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x01BD))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'QIQ{len(self.name)}sBIIIIIIIIIIHBII'
        _data.extend([self.npc, self.unknown1, self.unknown2, self.name.encode('utf-8'), 0, self.unknown3, self.unknown4, self.unknown5, self.unknown6, self.unknown7, self.unknown8, self.unknown9, self.unknown10, self.unknown11, self.unknown12, self.unknown13, self.unknown14, self.index, self.unknown15])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 72 + len(self.name)


@dataclasses.dataclass
class CMSG_PETITION_SHOW_SIGNATURES:
    item: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PETITION_SHOW_SIGNATURES:
        # item: Guid
        item = await read_int(reader, 8)

        return CMSG_PETITION_SHOW_SIGNATURES(
            item=item,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01BE))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.item)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PETITION_SHOW_SIGNATURES:
    item: int
    owner: int
    petition: int
    signatures: typing.List[PetitionSignature]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PETITION_SHOW_SIGNATURES:
        # item: Guid
        item = await read_int(reader, 8)

        # owner: Guid
        owner = await read_int(reader, 8)

        # petition: u32
        petition = await read_int(reader, 4)

        # amount_of_signatures: u8
        amount_of_signatures = await read_int(reader, 1)

        # signatures: PetitionSignature[amount_of_signatures]
        signatures = []
        for _ in range(0, amount_of_signatures):
            signatures.append(await PetitionSignature.read(reader))

        return SMSG_PETITION_SHOW_SIGNATURES(
            item=item,
            owner=owner,
            petition=petition,
            signatures=signatures,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01BF))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQIB'
        _data.extend([self.item, self.owner, self.petition, len(self.signatures)])
        # signatures: PetitionSignature[amount_of_signatures]
        for i in self.signatures:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 21 + 12 * len(self.signatures)


@dataclasses.dataclass
class CMSG_PETITION_SIGN:
    petition: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PETITION_SIGN:
        # petition: Guid
        petition = await read_int(reader, 8)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        return CMSG_PETITION_SIGN(
            petition=petition,
            unknown1=unknown1,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x01C0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.petition, self.unknown1])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PETITION_SIGN_RESULTS:
    petition: int
    owner: int
    result: PetitionResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PETITION_SIGN_RESULTS:
        # petition: Guid
        petition = await read_int(reader, 8)

        # owner: Guid
        owner = await read_int(reader, 8)

        # result: PetitionResult
        result = PetitionResult(await read_int(reader, 4))

        return SMSG_PETITION_SIGN_RESULTS(
            petition=petition,
            owner=owner,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x01C1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQI'
        _data.extend([self.petition, self.owner, self.result.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_PETITION_DECLINE:
    petition: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_PETITION_DECLINE:
        # petition: Guid
        petition = await read_int(reader, 8)

        return MSG_PETITION_DECLINE(
            petition=petition,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01C2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.petition)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01C2))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.petition)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_OFFER_PETITION:
    petition: int
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_OFFER_PETITION:
        # petition: Guid
        petition = await read_int(reader, 8)

        # target: Guid
        target = await read_int(reader, 8)

        return CMSG_OFFER_PETITION(
            petition=petition,
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x01C3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QQ'
        _data.extend([self.petition, self.target])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TURN_IN_PETITION:
    petition: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TURN_IN_PETITION:
        # petition: Guid
        petition = await read_int(reader, 8)

        return CMSG_TURN_IN_PETITION(
            petition=petition,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01C4))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.petition)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_TURN_IN_PETITION_RESULTS:
    result: PetitionResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_TURN_IN_PETITION_RESULTS:
        # result: PetitionResult
        result = PetitionResult(await read_int(reader, 4))

        return SMSG_TURN_IN_PETITION_RESULTS(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01C5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PETITION_QUERY:
    guild_id: int
    petition: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PETITION_QUERY:
        # guild_id: u32
        guild_id = await read_int(reader, 4)

        # petition: Guid
        petition = await read_int(reader, 8)

        return CMSG_PETITION_QUERY(
            guild_id=guild_id,
            petition=petition,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x01C6))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.guild_id, self.petition])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PETITION_QUERY_RESPONSE:
    petition_id: int
    charter_owner: int
    guild_name: str
    body_text: str
    unknown_flags: int
    minimum_signatures: int
    maximum_signatures: int
    deadline: int
    issue_date: int
    allowed_guild_id: int
    allowed_class: AllowedClass
    allowed_race: AllowedRace
    allowed_genders: int
    allowed_minimum_level: int
    allowed_maximum_level: int
    todo_amount_of_signers: int
    number_of_choices: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PETITION_QUERY_RESPONSE:
        # petition_id: u32
        petition_id = await read_int(reader, 4)

        # charter_owner: Guid
        charter_owner = await read_int(reader, 8)

        # guild_name: CString
        guild_name = await read_cstring(reader)

        # body_text: CString
        body_text = await read_cstring(reader)

        # unknown_flags: u32
        unknown_flags = await read_int(reader, 4)

        # minimum_signatures: u32
        minimum_signatures = await read_int(reader, 4)

        # maximum_signatures: u32
        maximum_signatures = await read_int(reader, 4)

        # deadline: u32
        deadline = await read_int(reader, 4)

        # issue_date: u32
        issue_date = await read_int(reader, 4)

        # allowed_guild_id: u32
        allowed_guild_id = await read_int(reader, 4)

        # allowed_class: AllowedClass
        allowed_class = AllowedClass(await read_int(reader, 4))

        # allowed_race: AllowedRace
        allowed_race = AllowedRace(await read_int(reader, 4))

        # allowed_genders: u16
        allowed_genders = await read_int(reader, 2)

        # allowed_minimum_level: Level32
        allowed_minimum_level = await read_int(reader, 4)

        # allowed_maximum_level: Level32
        allowed_maximum_level = await read_int(reader, 4)

        # todo_amount_of_signers: u32
        todo_amount_of_signers = await read_int(reader, 4)

        # number_of_choices: u32
        number_of_choices = await read_int(reader, 4)

        return SMSG_PETITION_QUERY_RESPONSE(
            petition_id=petition_id,
            charter_owner=charter_owner,
            guild_name=guild_name,
            body_text=body_text,
            unknown_flags=unknown_flags,
            minimum_signatures=minimum_signatures,
            maximum_signatures=maximum_signatures,
            deadline=deadline,
            issue_date=issue_date,
            allowed_guild_id=allowed_guild_id,
            allowed_class=allowed_class,
            allowed_race=allowed_race,
            allowed_genders=allowed_genders,
            allowed_minimum_level=allowed_minimum_level,
            allowed_maximum_level=allowed_maximum_level,
            todo_amount_of_signers=todo_amount_of_signers,
            number_of_choices=number_of_choices,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01C7))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'IQ{len(self.guild_name)}sB{len(self.body_text)}sBIIIIIIIIHIIII'
        _data.extend([self.petition_id, self.charter_owner, self.guild_name.encode('utf-8'), 0, self.body_text.encode('utf-8'), 0, self.unknown_flags, self.minimum_signatures, self.maximum_signatures, self.deadline, self.issue_date, self.allowed_guild_id, self.allowed_class.value, self.allowed_race.value, self.allowed_genders, self.allowed_minimum_level, self.allowed_maximum_level, self.todo_amount_of_signers, self.number_of_choices])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 64 + len(self.guild_name) + len(self.body_text)


@dataclasses.dataclass
class SMSG_FISH_NOT_HOOKED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FISH_NOT_HOOKED:
        return SMSG_FISH_NOT_HOOKED()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x01C8))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_FISH_ESCAPED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FISH_ESCAPED:
        return SMSG_FISH_ESCAPED()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x01C9))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BUG:
    suggestion: int
    content: str
    bug_type: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BUG:
        # suggestion: u32
        suggestion = await read_int(reader, 4)

        # content: SizedCString
        content = await read_sized_cstring(reader)

        # bug_type: SizedCString
        bug_type = await read_sized_cstring(reader)

        return CMSG_BUG(
            suggestion=suggestion,
            content=content,
            bug_type=bug_type,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x01CA))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'II{len(self.content)}sBI{len(self.bug_type)}sB'
        _data.extend([self.suggestion, len(self.content) + 1, self.content.encode('utf-8'), 0, len(self.bug_type) + 1, self.bug_type.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 14 + len(self.content) + len(self.bug_type)


@dataclasses.dataclass
class SMSG_NOTIFICATION:
    notification: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_NOTIFICATION:
        # notification: CString
        notification = await read_cstring(reader)

        return SMSG_NOTIFICATION(
            notification=notification,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01CB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.notification)}sB'
        _data.extend([self.notification.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.notification)


@dataclasses.dataclass
class CMSG_PLAYED_TIME:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PLAYED_TIME:
        return CMSG_PLAYED_TIME()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x01CC))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PLAYED_TIME:
    total_played_time: int
    level_played_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAYED_TIME:
        # total_played_time: u32
        total_played_time = await read_int(reader, 4)

        # level_played_time: u32
        level_played_time = await read_int(reader, 4)

        return SMSG_PLAYED_TIME(
            total_played_time=total_played_time,
            level_played_time=level_played_time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01CD))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.total_played_time, self.level_played_time])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_QUERY_TIME:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_QUERY_TIME:
        return CMSG_QUERY_TIME()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x01CE))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_QUERY_TIME_RESPONSE:
    time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_QUERY_TIME_RESPONSE:
        # time: u32
        time = await read_int(reader, 4)

        return SMSG_QUERY_TIME_RESPONSE(
            time=time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01CF))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.time)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOG_XPGAIN:
    target: int
    total_exp: int
    exp_type: ExperienceAwardType
    experience_without_rested: typing.Optional[int] = None
    exp_group_bonus: typing.Optional[float] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOG_XPGAIN:
        experience_without_rested = None
        exp_group_bonus = None
        # target: Guid
        target = await read_int(reader, 8)

        # total_exp: u32
        total_exp = await read_int(reader, 4)

        # exp_type: ExperienceAwardType
        exp_type = ExperienceAwardType(await read_int(reader, 1))

        if exp_type == ExperienceAwardType.NON_KILL:
            # experience_without_rested: u32
            experience_without_rested = await read_int(reader, 4)

            # exp_group_bonus: f32
            exp_group_bonus = await read_float(reader)

        return SMSG_LOG_XPGAIN(
            target=target,
            total_exp=total_exp,
            exp_type=exp_type,
            experience_without_rested=experience_without_rested,
            exp_group_bonus=exp_group_bonus,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01D0))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIB'
        _data.extend([self.target, self.total_exp, self.exp_type.value])
        if self.exp_type == ExperienceAwardType.NON_KILL:
            _fmt += 'If'
            _data.extend([self.experience_without_rested, self.exp_group_bonus])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 13

        if self.exp_type == ExperienceAwardType.NON_KILL:
            _size += 8

        return _size


@dataclasses.dataclass
class CMSG_RECLAIM_CORPSE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_RECLAIM_CORPSE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_RECLAIM_CORPSE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01D2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_WRAP_ITEM:
    gift_bag_index: int
    gift_slot: int
    item_bag_index: int
    item_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_WRAP_ITEM:
        # gift_bag_index: u8
        gift_bag_index = await read_int(reader, 1)

        # gift_slot: u8
        gift_slot = await read_int(reader, 1)

        # item_bag_index: u8
        item_bag_index = await read_int(reader, 1)

        # item_slot: u8
        item_slot = await read_int(reader, 1)

        return CMSG_WRAP_ITEM(
            gift_bag_index=gift_bag_index,
            gift_slot=gift_slot,
            item_bag_index=item_bag_index,
            item_slot=item_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x01D3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BBBB'
        _data.extend([self.gift_bag_index, self.gift_slot, self.item_bag_index, self.item_slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LEVELUP_INFO:
    new_level: int
    health: int
    mana: int
    rage: int
    focus: int
    energy: int
    happiness: int
    strength: int
    agility: int
    stamina: int
    intellect: int
    spirit: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LEVELUP_INFO:
        # new_level: Level32
        new_level = await read_int(reader, 4)

        # health: u32
        health = await read_int(reader, 4)

        # mana: u32
        mana = await read_int(reader, 4)

        # rage: u32
        rage = await read_int(reader, 4)

        # focus: u32
        focus = await read_int(reader, 4)

        # energy: u32
        energy = await read_int(reader, 4)

        # happiness: u32
        happiness = await read_int(reader, 4)

        # strength: u32
        strength = await read_int(reader, 4)

        # agility: u32
        agility = await read_int(reader, 4)

        # stamina: u32
        stamina = await read_int(reader, 4)

        # intellect: u32
        intellect = await read_int(reader, 4)

        # spirit: u32
        spirit = await read_int(reader, 4)

        return SMSG_LEVELUP_INFO(
            new_level=new_level,
            health=health,
            mana=mana,
            rage=rage,
            focus=focus,
            energy=energy,
            happiness=happiness,
            strength=strength,
            agility=agility,
            stamina=stamina,
            intellect=intellect,
            spirit=spirit,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(48 + 2, 0x01D4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIIIIIIIIII'
        _data.extend([self.new_level, self.health, self.mana, self.rage, self.focus, self.energy, self.happiness, self.strength, self.agility, self.stamina, self.intellect, self.spirit])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MINIMAP_PING_Client:
    position_x: float
    position_y: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MINIMAP_PING_Client:
        # position_x: f32
        position_x = await read_float(reader)

        # position_y: f32
        position_y = await read_float(reader)

        return MSG_MINIMAP_PING_Client(
            position_x=position_x,
            position_y=position_y,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01D5))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'ff'
        _data.extend([self.position_x, self.position_y])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MINIMAP_PING_Server:
    guid: int
    position_x: float
    position_y: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MINIMAP_PING_Server:
        # guid: Guid
        guid = await read_int(reader, 8)

        # position_x: f32
        position_x = await read_float(reader)

        # position_y: f32
        position_y = await read_float(reader)

        return MSG_MINIMAP_PING_Server(
            guid=guid,
            position_x=position_x,
            position_y=position_y,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x01D5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Qff'
        _data.extend([self.guid, self.position_x, self.position_y])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_RESISTLOG:
    guid1: int
    guid2: int
    unknown1: int
    unknown2: float
    unknown3: float
    unknown4: int
    unknown5: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RESISTLOG:
        # guid1: Guid
        guid1 = await read_int(reader, 8)

        # guid2: Guid
        guid2 = await read_int(reader, 8)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # unknown2: f32
        unknown2 = await read_float(reader)

        # unknown3: f32
        unknown3 = await read_float(reader)

        # unknown4: u32
        unknown4 = await read_int(reader, 4)

        # unknown5: u32
        unknown5 = await read_int(reader, 4)

        return SMSG_RESISTLOG(
            guid1=guid1,
            guid2=guid2,
            unknown1=unknown1,
            unknown2=unknown2,
            unknown3=unknown3,
            unknown4=unknown4,
            unknown5=unknown5,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(36 + 2, 0x01D6))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQIffII'
        _data.extend([self.guid1, self.guid2, self.unknown1, self.unknown2, self.unknown3, self.unknown4, self.unknown5])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ENCHANTMENTLOG:
    target: int
    caster: int
    item: int
    spell: int
    show_affiliation: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ENCHANTMENTLOG:
        # target: Guid
        target = await read_int(reader, 8)

        # caster: Guid
        caster = await read_int(reader, 8)

        # item: Item
        item = await read_int(reader, 4)

        # spell: Spell
        spell = await read_int(reader, 4)

        # show_affiliation: Bool8
        show_affiliation = await read_bool(reader, 1)

        return SMSG_ENCHANTMENTLOG(
            target=target,
            caster=caster,
            item=item,
            spell=spell,
            show_affiliation=show_affiliation,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(25 + 2, 0x01D7))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQIIB'
        _data.extend([self.target, self.caster, self.item, self.spell, self.show_affiliation])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_START_MIRROR_TIMER:
    timer: TimerType
    time_remaining: int
    duration: int
    scale: int
    is_frozen: bool
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_START_MIRROR_TIMER:
        # timer: TimerType
        timer = TimerType(await read_int(reader, 4))

        # time_remaining: u32
        time_remaining = await read_int(reader, 4)

        # duration: u32
        duration = await read_int(reader, 4)

        # scale: u32
        scale = await read_int(reader, 4)

        # is_frozen: Bool8
        is_frozen = await read_bool(reader, 1)

        # id: Spell
        id = await read_int(reader, 4)

        return SMSG_START_MIRROR_TIMER(
            timer=timer,
            time_remaining=time_remaining,
            duration=duration,
            scale=scale,
            is_frozen=is_frozen,
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(21 + 2, 0x01D9))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIIBI'
        _data.extend([self.timer.value, self.time_remaining, self.duration, self.scale, self.is_frozen, self.id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PAUSE_MIRROR_TIMER:
    timer: TimerType
    is_frozen: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PAUSE_MIRROR_TIMER:
        # timer: TimerType
        timer = TimerType(await read_int(reader, 4))

        # is_frozen: Bool8
        is_frozen = await read_bool(reader, 1)

        return SMSG_PAUSE_MIRROR_TIMER(
            timer=timer,
            is_frozen=is_frozen,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x01DA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([self.timer.value, self.is_frozen])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_STOP_MIRROR_TIMER:
    timer: TimerType

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_STOP_MIRROR_TIMER:
        # timer: TimerType
        timer = TimerType(await read_int(reader, 4))

        return SMSG_STOP_MIRROR_TIMER(
            timer=timer,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01DB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.timer.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PING:
    sequence_id: int
    round_time_in_ms: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PING:
        # sequence_id: u32
        sequence_id = await read_int(reader, 4)

        # round_time_in_ms: u32
        round_time_in_ms = await read_int(reader, 4)

        return CMSG_PING(
            sequence_id=sequence_id,
            round_time_in_ms=round_time_in_ms,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01DC))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.sequence_id, self.round_time_in_ms])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PONG:
    sequence_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PONG:
        # sequence_id: u32
        sequence_id = await read_int(reader, 4)

        return SMSG_PONG(
            sequence_id=sequence_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01DD))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.sequence_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CLEAR_COOLDOWN:
    id: int
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CLEAR_COOLDOWN:
        # id: Spell
        id = await read_int(reader, 4)

        # target: Guid
        target = await read_int(reader, 8)

        return SMSG_CLEAR_COOLDOWN(
            id=id,
            target=target,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01DE))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.id, self.target])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GAMEOBJECT_PAGETEXT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GAMEOBJECT_PAGETEXT:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_GAMEOBJECT_PAGETEXT(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01DF))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SETSHEATHED:
    sheathed: SheathState

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SETSHEATHED:
        # sheathed: SheathState
        sheathed = SheathState(await read_int(reader, 4))

        return CMSG_SETSHEATHED(
            sheathed=sheathed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x01E0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.sheathed.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELL_DELAYED:
    guid: int
    delay_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELL_DELAYED:
        # guid: Guid
        guid = await read_int(reader, 8)

        # delay_time: u32
        delay_time = await read_int(reader, 4)

        return SMSG_SPELL_DELAYED(
            guid=guid,
            delay_time=delay_time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01E2))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.delay_time])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_TIME_UPDATE:
    guid: int
    duration: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_TIME_UPDATE:
        # guid: Guid
        guid = await read_int(reader, 8)

        # duration: u32
        duration = await read_int(reader, 4)

        return SMSG_ITEM_TIME_UPDATE(
            guid=guid,
            duration=duration,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01EA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.duration])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_ENCHANT_TIME_UPDATE:
    item: int
    slot: int
    duration: int
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_ENCHANT_TIME_UPDATE:
        # item: Guid
        item = await read_int(reader, 8)

        # slot: u32
        slot = await read_int(reader, 4)

        # duration: u32
        duration = await read_int(reader, 4)

        # player: Guid
        player = await read_int(reader, 8)

        return SMSG_ITEM_ENCHANT_TIME_UPDATE(
            item=item,
            slot=slot,
            duration=duration,
            player=player,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(24 + 2, 0x01EB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIIQ'
        _data.extend([self.item, self.slot, self.duration, self.player])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AUTH_CHALLENGE:
    server_seed: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUTH_CHALLENGE:
        # server_seed: u32
        server_seed = await read_int(reader, 4)

        return SMSG_AUTH_CHALLENGE(
            server_seed=server_seed,
        )

    def write_unencrypted(self, writer: typing.Union[asyncio.StreamWriter, bytearray]):
        _data = bytearray(4)
        struct.pack_into(">H", _data, 0, 4 + 2)
        struct.pack_into("<H", _data, 2, 0x01EC)
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.server_seed)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUTH_SESSION:
    build: int
    server_id: int
    username: str
    client_seed: int
    client_proof: typing.List[int]
    addon_info: typing.List[AddonInfo]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUTH_SESSION:
        _size = 0

        # build: u32
        build = await read_int(reader, 4)
        _size += 4

        # server_id: u32
        server_id = await read_int(reader, 4)
        _size += 4

        # username: CString
        username = await read_cstring(reader)
        _size += len(username) + 1

        # client_seed: u32
        client_seed = await read_int(reader, 4)
        _size += 4

        # client_proof: u8[20]
        client_proof = []
        for _ in range(0, 20):
            client_proof.append(await read_int(reader, 1))
            _size += 1

        # addon_info: AddonInfo[-]
        # {d.name}_decompressed_size: u32
        _size += 4  # decompressed_size

        addon_info_decompressed_size = await read_int(reader, 4)
        addon_info_bytes = await reader.readexactly(body_size - _size)

        addon_info_reader = reader
        if len(addon_info_bytes) != 0:
            addon_info_bytes = zlib.decompress(addon_info_bytes, bufsize=addon_info_decompressed_size)
            addon_info_reader = asyncio.StreamReader()
            addon_info_reader.feed_data(addon_info_bytes)
            addon_info_reader.feed_eof()

        addon_info = []
        while not addon_info_reader.at_eof():
            addon_info.append(await AddonInfo.read(addon_info_reader))
            _size += addon_info[-1].size()

        return CMSG_AUTH_SESSION(
            build=build,
            server_id=server_id,
            username=username,
            client_seed=client_seed,
            client_proof=client_proof,
            addon_info=addon_info,
        )

    def write_unencrypted(self, writer: typing.Union[asyncio.StreamWriter, bytearray]):
        _data = bytearray(6)
        struct.pack_into(">H", _data, 0, self.size() + 4)
        struct.pack_into("<I", _data, 2, 0x01ED)
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'II{len(self.username)}sBI{len(self.client_proof)}B'
        _data.extend([self.build, self.server_id, self.username.encode('utf-8'), 0, self.client_seed, *self.client_proof])
        # addon_info: AddonInfo[-]
        _addon_info_fmt = ''
        _addon_info_data = []

        _addon_info_decompressed_size = 0
        if len(self.addon_info) != 0:
            for i in self.addon_info:
                _addon_info_fmt, _addon_info_data = i.write(_addon_info_fmt, _addon_info_data)
            _addon_info_bytes = struct.pack(_addon_info_fmt, *_addon_info_data)
            _addon_info_decompressed_size = len(_addon_info_bytes)
            _addon_info_bytes = list(_addon_info_bytes)

            _fmt += 'I'
            _data.append(_addon_info_decompressed_size)

            _fmt += f'{len(_addon_info_bytes)}B'
            _data.extend(list(_addon_info_bytes))
        else:
            _fmt += 'I'
            _data.append(_addon_info_decompressed_size)


        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 33 + len(self.username)

        # addon_info: AddonInfo[-]
        _addon_info_fmt = ''
        _addon_info_data = []

        if len(self.addon_info) != 0:
            for i in self.addon_info:
                _addon_info_fmt, _addon_info_data = i.write(_addon_info_fmt, _addon_info_data)
            _addon_info_bytes = struct.pack(_addon_info_fmt, *_addon_info_data)
            _size += len(_addon_info_bytes) + 4
        else:
            _size += 4

        return _size


@dataclasses.dataclass
class SMSG_AUTH_RESPONSE:
    result: WorldResult
    billing_time: typing.Optional[int] = None
    billing_flags: typing.Optional[int] = None
    billing_rested: typing.Optional[int] = None
    queue_position: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUTH_RESPONSE:
        billing_time = None
        billing_flags = None
        billing_rested = None
        queue_position = None
        # result: WorldResult
        result = WorldResult(await read_int(reader, 1))

        if result == WorldResult.AUTH_OK:
            # billing_time: u32
            billing_time = await read_int(reader, 4)

            # billing_flags: u8
            billing_flags = await read_int(reader, 1)

            # billing_rested: u32
            billing_rested = await read_int(reader, 4)

        elif result == WorldResult.AUTH_WAIT_QUEUE:
            # queue_position: u32
            queue_position = await read_int(reader, 4)

        return SMSG_AUTH_RESPONSE(
            result=result,
            billing_time=billing_time,
            billing_flags=billing_flags,
            billing_rested=billing_rested,
            queue_position=queue_position,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01EE))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        if self.result == WorldResult.AUTH_OK:
            _fmt += 'IBI'
            _data.extend([self.billing_time, self.billing_flags, self.billing_rested])
        elif self.result == WorldResult.AUTH_WAIT_QUEUE:
            _fmt += 'I'
            _data.append(self.queue_position)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.result == WorldResult.AUTH_OK:
            _size += 9
        elif self.result == WorldResult.AUTH_WAIT_QUEUE:
            _size += 4

        return _size


@dataclasses.dataclass
class CMSG_PET_CAST_SPELL:
    guid: int
    id: int
    targets: SpellCastTargets

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_CAST_SPELL:
        # guid: Guid
        guid = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        # targets: SpellCastTargets
        targets = await SpellCastTargets.read(reader)

        return CMSG_PET_CAST_SPELL(
            guid=guid,
            id=id,
            targets=targets,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x01F0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.id])
        # targets: SpellCastTargets
        _fmt, _data = self.targets.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 12 + self.targets.size()


@dataclasses.dataclass
class MSG_SAVE_GUILD_EMBLEM_Server:
    result: GuildEmblemResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_SAVE_GUILD_EMBLEM_Server:
        # result: GuildEmblemResult
        result = GuildEmblemResult(await read_int(reader, 4))

        return MSG_SAVE_GUILD_EMBLEM_Server(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01F1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_SAVE_GUILD_EMBLEM_Client:
    vendor: int
    emblem_style: int
    emblem_color: int
    border_style: int
    border_color: int
    background_color: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_SAVE_GUILD_EMBLEM_Client:
        # vendor: Guid
        vendor = await read_int(reader, 8)

        # emblem_style: u32
        emblem_style = await read_int(reader, 4)

        # emblem_color: u32
        emblem_color = await read_int(reader, 4)

        # border_style: u32
        border_style = await read_int(reader, 4)

        # border_color: u32
        border_color = await read_int(reader, 4)

        # background_color: u32
        background_color = await read_int(reader, 4)

        return MSG_SAVE_GUILD_EMBLEM_Client(
            vendor=vendor,
            emblem_style=emblem_style,
            emblem_color=emblem_color,
            border_style=border_style,
            border_color=border_color,
            background_color=background_color,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(28 + 4, 0x01F1))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIIIII'
        _data.extend([self.vendor, self.emblem_style, self.emblem_color, self.border_style, self.border_color, self.background_color])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_TABARDVENDOR_ACTIVATE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_TABARDVENDOR_ACTIVATE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return MSG_TABARDVENDOR_ACTIVATE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01F2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01F2))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PLAY_SPELL_VISUAL:
    guid: int
    spell_art_kit: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAY_SPELL_VISUAL:
        # guid: Guid
        guid = await read_int(reader, 8)

        # spell_art_kit: u32
        spell_art_kit = await read_int(reader, 4)

        return SMSG_PLAY_SPELL_VISUAL(
            guid=guid,
            spell_art_kit=spell_art_kit,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01F3))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.spell_art_kit])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ZONEUPDATE:
    area: Area

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ZONEUPDATE:
        # area: Area
        area = Area(await read_int(reader, 4))

        return CMSG_ZONEUPDATE(
            area=area,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x01F4))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.area.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PARTYKILLLOG:
    player_with_killing_blow: int
    victim: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PARTYKILLLOG:
        # player_with_killing_blow: Guid
        player_with_killing_blow = await read_int(reader, 8)

        # victim: Guid
        victim = await read_int(reader, 8)

        return SMSG_PARTYKILLLOG(
            player_with_killing_blow=player_with_killing_blow,
            victim=victim,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x01F5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQ'
        _data.extend([self.player_with_killing_blow, self.victim])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_COMPRESSED_UPDATE_OBJECT:
    has_transport: int
    objects: typing.List[Object]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_COMPRESSED_UPDATE_OBJECT:
        decompressed_size = await read_int(reader, 4)
        compressed_bytes = await reader.readexactly(body_size - 4)
        decompressed_bytes = zlib.decompress(compressed_bytes, bufsize=decompressed_size)
        reader = asyncio.StreamReader()
        reader.feed_data(decompressed_bytes)
        reader.feed_eof()


        # amount_of_objects: u32
        amount_of_objects = await read_int(reader, 4)

        # has_transport: u8
        has_transport = await read_int(reader, 1)

        # objects: Object[amount_of_objects]
        objects = []
        for _ in range(0, amount_of_objects):
            objects.append(await Object.read(reader))

        return SMSG_COMPRESSED_UPDATE_OBJECT(
            has_transport=has_transport,
            objects=objects,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x01F6))
        _fmt = "<4s"
        _data = [_data]

        _compressed_fmt = "<"
        _compressed_data = []

        _fmt += 'IB'
        _data.extend([len(self.objects), self.has_transport])
        # objects: Object[amount_of_objects]
        for i in self.objects:
            _compressed_fmt, _compressed_data = i.write(_compressed_fmt, _compressed_data)

        _uncompressed_data = struct.pack(_compressed_fmt, *_compressed_data)
        _compressed_data = zlib.compress(_uncompressed_data)

        _fmt += 'I'
        _data.append(len(_uncompressed_data))

        _fmt += f'{len(_compressed_data)}s'
        _data.append(_compressed_data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _fmt = ''
        _data = []

        # amount_of_objects: u32
        _fmt += 'I'
        _data.append(len(self.objects))

        # has_transport: u8
        _fmt += 'B'
        _data.append(self.has_transport)

        # objects: Object[amount_of_objects]
        for i in self.objects:
            _fmt, _data = i.write(_fmt, _data)

        _uncompressed_data = struct.pack(_fmt, *_data)
        _compressed_data = zlib.compress(_uncompressed_data)
        return len(_compressed_data) + 4


@dataclasses.dataclass
class SMSG_PLAY_SPELL_IMPACT:
    guid: int
    spell_visual_kit: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAY_SPELL_IMPACT:
        # guid: Guid
        guid = await read_int(reader, 8)

        # spell_visual_kit: u32
        spell_visual_kit = await read_int(reader, 4)

        return SMSG_PLAY_SPELL_IMPACT(
            guid=guid,
            spell_visual_kit=spell_visual_kit,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01F7))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.spell_visual_kit])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_EXPLORATION_EXPERIENCE:
    area: Area
    experience: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_EXPLORATION_EXPERIENCE:
        # area: Area
        area = Area(await read_int(reader, 4))

        # experience: u32
        experience = await read_int(reader, 4)

        return SMSG_EXPLORATION_EXPERIENCE(
            area=area,
            experience=experience,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01F8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.area.value, self.experience])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_RANDOM_ROLL_Client:
    minimum: int
    maximum: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RANDOM_ROLL_Client:
        # minimum: u32
        minimum = await read_int(reader, 4)

        # maximum: u32
        maximum = await read_int(reader, 4)

        return MSG_RANDOM_ROLL_Client(
            minimum=minimum,
            maximum=maximum,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01FB))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.minimum, self.maximum])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_RANDOM_ROLL_Server:
    minimum: int
    maximum: int
    actual_roll: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RANDOM_ROLL_Server:
        # minimum: u32
        minimum = await read_int(reader, 4)

        # maximum: u32
        maximum = await read_int(reader, 4)

        # actual_roll: u32
        actual_roll = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return MSG_RANDOM_ROLL_Server(
            minimum=minimum,
            maximum=maximum,
            actual_roll=actual_roll,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x01FB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIQ'
        _data.extend([self.minimum, self.maximum, self.actual_roll, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ENVIRONMENTAL_DAMAGE_LOG:
    guid: int
    damage_type: EnvironmentalDamageType
    damage: int
    absorb: int
    resist: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ENVIRONMENTAL_DAMAGE_LOG:
        # guid: Guid
        guid = await read_int(reader, 8)

        # damage_type: EnvironmentalDamageType
        damage_type = EnvironmentalDamageType(await read_int(reader, 1))

        # damage: u32
        damage = await read_int(reader, 4)

        # absorb: u32
        absorb = await read_int(reader, 4)

        # resist: u32
        resist = await read_int(reader, 4)

        return SMSG_ENVIRONMENTAL_DAMAGE_LOG(
            guid=guid,
            damage_type=damage_type,
            damage=damage,
            absorb=absorb,
            resist=resist,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(21 + 2, 0x01FC))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QBIII'
        _data.extend([self.guid, self.damage_type.value, self.damage, self.absorb, self.resist])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_LOOKING_FOR_GROUP_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_LOOKING_FOR_GROUP_Client:
        return MSG_LOOKING_FOR_GROUP_Client()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x01FF))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_LOOKING_FOR_GROUP_Server:
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_LOOKING_FOR_GROUP_Server:
        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return MSG_LOOKING_FOR_GROUP_Server(
            unknown1=unknown1,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01FF))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.unknown1)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_UNLEARN_SKILL:
    skill: Skill

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_UNLEARN_SKILL:
        # skill: Skill
        skill = Skill(await read_int(reader, 4))

        return CMSG_UNLEARN_SKILL(
            skill=skill,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0202))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.skill.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_REMOVED_SPELL:
    spell: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_REMOVED_SPELL:
        # spell: Spell16
        spell = await read_int(reader, 2)

        return SMSG_REMOVED_SPELL(
            spell=spell,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 2, 0x0203))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'H'
        _data.append(self.spell)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GMTICKET_CREATE:
    category: GmTicketType
    map: Map
    position: Vector3d
    message: str
    reserved_for_future_use: str
    chat_data_line_count: typing.Optional[int] = None
    compressed_chat_data: typing.Optional[typing.List[int]] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GMTICKET_CREATE:
        chat_data_line_count = None
        compressed_chat_data = None
        _size = 0

        # category: GmTicketType
        category = GmTicketType(await read_int(reader, 1))
        _size += 1

        # map: Map
        map = Map(await read_int(reader, 4))
        _size += 4

        # position: Vector3d
        position = await Vector3d.read(reader)
        _size += 12

        # message: CString
        message = await read_cstring(reader)
        _size += len(message) + 1

        # reserved_for_future_use: CString
        reserved_for_future_use = await read_cstring(reader)
        _size += len(reserved_for_future_use) + 1

        if category == GmTicketType.BEHAVIOR_HARASSMENT:
            # chat_data_line_count: u32
            chat_data_line_count = await read_int(reader, 4)
            _size += 4

            # compressed_chat_data: u8[-]
            # {d.name}_decompressed_size: u32
            _size += 4  # decompressed_size

            compressed_chat_data_decompressed_size = await read_int(reader, 4)
            compressed_chat_data_bytes = await reader.readexactly(body_size - _size)

            compressed_chat_data_reader = reader
            if len(compressed_chat_data_bytes) != 0:
                compressed_chat_data_bytes = zlib.decompress(compressed_chat_data_bytes, bufsize=compressed_chat_data_decompressed_size)
                compressed_chat_data_reader = asyncio.StreamReader()
                compressed_chat_data_reader.feed_data(compressed_chat_data_bytes)
                compressed_chat_data_reader.feed_eof()

            compressed_chat_data = []
            while not compressed_chat_data_reader.at_eof():
                compressed_chat_data.append(await read_int(compressed_chat_data_reader, 1))
                _size += 1

        return CMSG_GMTICKET_CREATE(
            category=category,
            map=map,
            position=position,
            message=message,
            reserved_for_future_use=reserved_for_future_use,
            chat_data_line_count=chat_data_line_count,
            compressed_chat_data=compressed_chat_data,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0205))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BI'
        _data.extend([self.category.value, self.map.value])
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # message: CString
        _fmt += f'{len(self.message)}sB'
        _data.extend([self.message.encode('utf-8'), 0])

        # reserved_for_future_use: CString
        _fmt += f'{len(self.reserved_for_future_use)}sB'
        _data.extend([self.reserved_for_future_use.encode('utf-8'), 0])

        if self.category == GmTicketType.BEHAVIOR_HARASSMENT:
            _fmt += 'I'
            _data.append(self.chat_data_line_count)
            # compressed_chat_data: u8[-]
            _compressed_chat_data_fmt = ''
            _compressed_chat_data_data = []

            _compressed_chat_data_decompressed_size = 0
            if len(self.compressed_chat_data) != 0:
                _compressed_chat_data_fmt += f'{len(self.compressed_chat_data)}B'
                _compressed_chat_data_data.extend(self.compressed_chat_data)
                _compressed_chat_data_bytes = struct.pack(_compressed_chat_data_fmt, *_compressed_chat_data_data)
                _compressed_chat_data_decompressed_size = len(_compressed_chat_data_bytes)
                _compressed_chat_data_bytes = list(_compressed_chat_data_bytes)

                _fmt += 'I'
                _data.append(_compressed_chat_data_decompressed_size)

                _fmt += f'{len(_compressed_chat_data_bytes)}B'
                _data.extend(list(_compressed_chat_data_bytes))
            else:
                _fmt += 'I'
                _data.append(_compressed_chat_data_decompressed_size)


        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 19 + len(self.message) + len(self.reserved_for_future_use)

        if self.category == GmTicketType.BEHAVIOR_HARASSMENT:
            _size += 4

            # compressed_chat_data: u8[-]
            _compressed_chat_data_fmt = ''
            _compressed_chat_data_data = []

            if len(self.compressed_chat_data) != 0:
                _compressed_chat_data_fmt += f'{len(self.compressed_chat_data)}B'
                _compressed_chat_data_data.extend(self.compressed_chat_data)
                _compressed_chat_data_bytes = struct.pack(_compressed_chat_data_fmt, *_compressed_chat_data_data)
                _size += len(_compressed_chat_data_bytes) + 4
            else:
                _size += 4


        return _size


@dataclasses.dataclass
class SMSG_GMTICKET_CREATE:
    response: GmTicketResponse

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GMTICKET_CREATE:
        # response: GmTicketResponse
        response = GmTicketResponse(await read_int(reader, 4))

        return SMSG_GMTICKET_CREATE(
            response=response,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0206))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.response.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GMTICKET_UPDATETEXT:
    ticket_type: GmTicketType
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GMTICKET_UPDATETEXT:
        # ticket_type: GmTicketType
        ticket_type = GmTicketType(await read_int(reader, 1))

        # message: CString
        message = await read_cstring(reader)

        return CMSG_GMTICKET_UPDATETEXT(
            ticket_type=ticket_type,
            message=message,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0207))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'B{len(self.message)}sB'
        _data.extend([self.ticket_type.value, self.message.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.message)


@dataclasses.dataclass
class SMSG_GMTICKET_UPDATETEXT:
    response: GmTicketResponse

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GMTICKET_UPDATETEXT:
        # response: GmTicketResponse
        response = GmTicketResponse(await read_int(reader, 4))

        return SMSG_GMTICKET_UPDATETEXT(
            response=response,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0208))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.response.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ACCOUNT_DATA_TIMES:
    data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ACCOUNT_DATA_TIMES:
        # data: u32[32]
        data = []
        for _ in range(0, 32):
            data.append(await read_int(reader, 4))

        return SMSG_ACCOUNT_DATA_TIMES(
            data=data,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(128 + 2, 0x0209))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.data)}I'
        _data.extend([*self.data])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_REQUEST_ACCOUNT_DATA:
    data_type: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REQUEST_ACCOUNT_DATA:
        # data_type: u32
        data_type = await read_int(reader, 4)

        return CMSG_REQUEST_ACCOUNT_DATA(
            data_type=data_type,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x020A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.data_type)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_UPDATE_ACCOUNT_DATA:
    data_type: AccountDataType
    compressed_data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_UPDATE_ACCOUNT_DATA:
        _size = 0

        # data_type: AccountDataType
        data_type = AccountDataType(await read_int(reader, 4))
        _size += 4

        # compressed_data: u8[-]
        # {d.name}_decompressed_size: u32
        _size += 4  # decompressed_size

        compressed_data_decompressed_size = await read_int(reader, 4)
        compressed_data_bytes = await reader.readexactly(body_size - _size)

        compressed_data_reader = reader
        if len(compressed_data_bytes) != 0:
            compressed_data_bytes = zlib.decompress(compressed_data_bytes, bufsize=compressed_data_decompressed_size)
            compressed_data_reader = asyncio.StreamReader()
            compressed_data_reader.feed_data(compressed_data_bytes)
            compressed_data_reader.feed_eof()

        compressed_data = []
        while not compressed_data_reader.at_eof():
            compressed_data.append(await read_int(compressed_data_reader, 1))
            _size += 1

        return CMSG_UPDATE_ACCOUNT_DATA(
            data_type=data_type,
            compressed_data=compressed_data,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x020B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.data_type.value)
        # compressed_data: u8[-]
        _compressed_data_fmt = ''
        _compressed_data_data = []

        _compressed_data_decompressed_size = 0
        if len(self.compressed_data) != 0:
            _compressed_data_fmt += f'{len(self.compressed_data)}B'
            _compressed_data_data.extend(self.compressed_data)
            _compressed_data_bytes = struct.pack(_compressed_data_fmt, *_compressed_data_data)
            _compressed_data_decompressed_size = len(_compressed_data_bytes)
            _compressed_data_bytes = list(_compressed_data_bytes)

            _fmt += 'I'
            _data.append(_compressed_data_decompressed_size)

            _fmt += f'{len(_compressed_data_bytes)}B'
            _data.extend(list(_compressed_data_bytes))
        else:
            _fmt += 'I'
            _data.append(_compressed_data_decompressed_size)


        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        # compressed_data: u8[-]
        _compressed_data_fmt = ''
        _compressed_data_data = []

        if len(self.compressed_data) != 0:
            _compressed_data_fmt += f'{len(self.compressed_data)}B'
            _compressed_data_data.extend(self.compressed_data)
            _compressed_data_bytes = struct.pack(_compressed_data_fmt, *_compressed_data_data)
            _size += len(_compressed_data_bytes) + 4
        else:
            _size += 4

        return _size


@dataclasses.dataclass
class CMSG_GMTICKET_GETTICKET:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GMTICKET_GETTICKET:
        return CMSG_GMTICKET_GETTICKET()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0211))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GMTICKET_GETTICKET:
    status: GmTicketStatus
    text: typing.Optional[str] = None
    ticket_type: typing.Optional[GmTicketType] = None
    days_since_ticket_creation: typing.Optional[float] = None
    days_since_oldest_ticket_creation: typing.Optional[float] = None
    days_since_last_updated: typing.Optional[float] = None
    escalation_status: typing.Optional[GmTicketEscalationStatus] = None
    read_by_gm: typing.Optional[bool] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GMTICKET_GETTICKET:
        text = None
        ticket_type = None
        days_since_ticket_creation = None
        days_since_oldest_ticket_creation = None
        days_since_last_updated = None
        escalation_status = None
        read_by_gm = None
        # status: GmTicketStatus
        status = GmTicketStatus(await read_int(reader, 4))

        if status == GmTicketStatus.HAS_TEXT:
            # text: CString
            text = await read_cstring(reader)

            # ticket_type: GmTicketType
            ticket_type = GmTicketType(await read_int(reader, 1))

            # days_since_ticket_creation: f32
            days_since_ticket_creation = await read_float(reader)

            # days_since_oldest_ticket_creation: f32
            days_since_oldest_ticket_creation = await read_float(reader)

            # days_since_last_updated: f32
            days_since_last_updated = await read_float(reader)

            # escalation_status: GmTicketEscalationStatus
            escalation_status = GmTicketEscalationStatus(await read_int(reader, 1))

            # read_by_gm: Bool8
            read_by_gm = await read_bool(reader, 1)

        return SMSG_GMTICKET_GETTICKET(
            status=status,
            text=text,
            ticket_type=ticket_type,
            days_since_ticket_creation=days_since_ticket_creation,
            days_since_oldest_ticket_creation=days_since_oldest_ticket_creation,
            days_since_last_updated=days_since_last_updated,
            escalation_status=escalation_status,
            read_by_gm=read_by_gm,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0212))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.status.value)
        if self.status == GmTicketStatus.HAS_TEXT:
            _fmt += f'{len(self.text)}sBBfffBB'
            _data.extend([self.text.encode('utf-8'), 0, self.ticket_type.value, self.days_since_ticket_creation, self.days_since_oldest_ticket_creation, self.days_since_last_updated, self.escalation_status.value, self.read_by_gm])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4

        if self.status == GmTicketStatus.HAS_TEXT:
            _size += 16 + len(self.text)

        return _size


@dataclasses.dataclass
class SMSG_GAMEOBJECT_SPAWN_ANIM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GAMEOBJECT_SPAWN_ANIM:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_GAMEOBJECT_SPAWN_ANIM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0214))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GAMEOBJECT_DESPAWN_ANIM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GAMEOBJECT_DESPAWN_ANIM:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_GAMEOBJECT_DESPAWN_ANIM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0215))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_CORPSE_QUERY_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_CORPSE_QUERY_Client:
        return MSG_CORPSE_QUERY_Client()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0216))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_CORPSE_QUERY_Server:
    result: CorpseQueryResult
    map: typing.Optional[Map] = None
    position: typing.Optional[Vector3d] = None
    corpse_map: typing.Optional[Map] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_CORPSE_QUERY_Server:
        map = None
        position = None
        corpse_map = None
        # result: CorpseQueryResult
        result = CorpseQueryResult(await read_int(reader, 1))

        if result == CorpseQueryResult.FOUND:
            # map: Map
            map = Map(await read_int(reader, 4))

            # position: Vector3d
            position = await Vector3d.read(reader)

            # corpse_map: Map
            corpse_map = Map(await read_int(reader, 4))

        return MSG_CORPSE_QUERY_Server(
            result=result,
            map=map,
            position=position,
            corpse_map=corpse_map,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0216))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        if self.result == CorpseQueryResult.FOUND:
            _fmt += 'I'
            _data.append(self.map.value)
            # position: Vector3d
            _fmt, _data = self.position.write(_fmt, _data)

            # corpse_map: Map
            _fmt += 'I'
            _data.append(self.corpse_map.value)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.result == CorpseQueryResult.FOUND:
            _size += 20

        return _size


@dataclasses.dataclass
class CMSG_GMTICKET_DELETETICKET:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GMTICKET_DELETETICKET:
        return CMSG_GMTICKET_DELETETICKET()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0217))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GMTICKET_DELETETICKET:
    response: GmTicketResponse

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GMTICKET_DELETETICKET:
        # response: GmTicketResponse
        response = GmTicketResponse(await read_int(reader, 4))

        return SMSG_GMTICKET_DELETETICKET(
            response=response,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0218))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.response.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CHAT_WRONG_FACTION:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAT_WRONG_FACTION:
        return SMSG_CHAT_WRONG_FACTION()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0219))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GMTICKET_SYSTEMSTATUS:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GMTICKET_SYSTEMSTATUS:
        return CMSG_GMTICKET_SYSTEMSTATUS()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x021A))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GMTICKET_SYSTEMSTATUS:
    will_accept_tickets: GmTicketQueueStatus

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GMTICKET_SYSTEMSTATUS:
        # will_accept_tickets: GmTicketQueueStatus
        will_accept_tickets = GmTicketQueueStatus(await read_int(reader, 4))

        return SMSG_GMTICKET_SYSTEMSTATUS(
            will_accept_tickets=will_accept_tickets,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x021B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.will_accept_tickets.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SPIRIT_HEALER_ACTIVATE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SPIRIT_HEALER_ACTIVATE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_SPIRIT_HEALER_ACTIVATE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x021C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SET_REST_START:
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_REST_START:
        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return SMSG_SET_REST_START(
            unknown1=unknown1,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x021E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.unknown1)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPIRIT_HEALER_CONFIRM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPIRIT_HEALER_CONFIRM:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_SPIRIT_HEALER_CONFIRM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0222))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GOSSIP_POI:
    flags: int
    position: Vector2d
    icon: int
    data: int
    location_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GOSSIP_POI:
        # flags: u32
        flags = await read_int(reader, 4)

        # position: Vector2d
        position = await Vector2d.read(reader)

        # icon: u32
        icon = await read_int(reader, 4)

        # data: u32
        data = await read_int(reader, 4)

        # location_name: CString
        location_name = await read_cstring(reader)

        return SMSG_GOSSIP_POI(
            flags=flags,
            position=position,
            icon=icon,
            data=data,
            location_name=location_name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0224))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.flags)
        # position: Vector2d
        _fmt, _data = self.position.write(_fmt, _data)

        # icon: u32
        _fmt += 'I'
        _data.append(self.icon)

        # data: u32
        _fmt += 'I'
        _data.append(self.data)

        # location_name: CString
        _fmt += f'{len(self.location_name)}sB'
        _data.extend([self.location_name.encode('utf-8'), 0])

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 21 + len(self.location_name)


@dataclasses.dataclass
class CMSG_CHAT_IGNORED:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHAT_IGNORED:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_CHAT_IGNORED(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0225))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_RANK:
    rank_id: int
    rights: int
    rank_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_RANK:
        # rank_id: u32
        rank_id = await read_int(reader, 4)

        # rights: u32
        rights = await read_int(reader, 4)

        # rank_name: CString
        rank_name = await read_cstring(reader)

        return CMSG_GUILD_RANK(
            rank_id=rank_id,
            rights=rights,
            rank_name=rank_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0231))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'II{len(self.rank_name)}sB'
        _data.extend([self.rank_id, self.rights, self.rank_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.rank_name)


@dataclasses.dataclass
class CMSG_GUILD_ADD_RANK:
    rank_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_ADD_RANK:
        # rank_name: CString
        rank_name = await read_cstring(reader)

        return CMSG_GUILD_ADD_RANK(
            rank_name=rank_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0232))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.rank_name)}sB'
        _data.extend([self.rank_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.rank_name)


@dataclasses.dataclass
class CMSG_GUILD_DEL_RANK:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_DEL_RANK:
        return CMSG_GUILD_DEL_RANK()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0233))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GUILD_SET_PUBLIC_NOTE:
    player_name: str
    note: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_SET_PUBLIC_NOTE:
        # player_name: CString
        player_name = await read_cstring(reader)

        # note: CString
        note = await read_cstring(reader)

        return CMSG_GUILD_SET_PUBLIC_NOTE(
            player_name=player_name,
            note=note,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0234))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.player_name)}sB{len(self.note)}sB'
        _data.extend([self.player_name.encode('utf-8'), 0, self.note.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.player_name) + len(self.note)


@dataclasses.dataclass
class CMSG_GUILD_SET_OFFICER_NOTE:
    player_name: str
    note: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_SET_OFFICER_NOTE:
        # player_name: CString
        player_name = await read_cstring(reader)

        # note: CString
        note = await read_cstring(reader)

        return CMSG_GUILD_SET_OFFICER_NOTE(
            player_name=player_name,
            note=note,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0235))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.player_name)}sB{len(self.note)}sB'
        _data.extend([self.player_name.encode('utf-8'), 0, self.note.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.player_name) + len(self.note)


@dataclasses.dataclass
class SMSG_LOGIN_VERIFY_WORLD:
    map: Map
    position: Vector3d
    orientation: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOGIN_VERIFY_WORLD:
        # map: Map
        map = Map(await read_int(reader, 4))

        # position: Vector3d
        position = await Vector3d.read(reader)

        # orientation: f32
        orientation = await read_float(reader)

        return SMSG_LOGIN_VERIFY_WORLD(
            map=map,
            position=position,
            orientation=orientation,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x0236))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        # orientation: f32
        _fmt += 'f'
        _data.append(self.orientation)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SEND_MAIL:
    mailbox: int
    receiver: str
    subject: str
    body: str
    unknown1: int
    unknown2: int
    item: int
    money: int
    cash_on_delivery_amount: int
    unknown3: int
    unknown4: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SEND_MAIL:
        # mailbox: Guid
        mailbox = await read_int(reader, 8)

        # receiver: CString
        receiver = await read_cstring(reader)

        # subject: CString
        subject = await read_cstring(reader)

        # body: CString
        body = await read_cstring(reader)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        # unknown2: u32
        unknown2 = await read_int(reader, 4)

        # item: Guid
        item = await read_int(reader, 8)

        # money: Gold
        money = await read_int(reader, 4)

        # cash_on_delivery_amount: u32
        cash_on_delivery_amount = await read_int(reader, 4)

        # unknown3: u32
        unknown3 = await read_int(reader, 4)

        # unknown4: u32
        unknown4 = await read_int(reader, 4)

        return CMSG_SEND_MAIL(
            mailbox=mailbox,
            receiver=receiver,
            subject=subject,
            body=body,
            unknown1=unknown1,
            unknown2=unknown2,
            item=item,
            money=money,
            cash_on_delivery_amount=cash_on_delivery_amount,
            unknown3=unknown3,
            unknown4=unknown4,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0238))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.receiver)}sB{len(self.subject)}sB{len(self.body)}sBIIQIIII'
        _data.extend([self.mailbox, self.receiver.encode('utf-8'), 0, self.subject.encode('utf-8'), 0, self.body.encode('utf-8'), 0, self.unknown1, self.unknown2, self.item, self.money, self.cash_on_delivery_amount, self.unknown3, self.unknown4])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 43 + len(self.receiver) + len(self.subject) + len(self.body)


@dataclasses.dataclass
class SMSG_SEND_MAIL_RESULT:
    mail_id: int
    action: MailAction
    result: typing.Optional[MailResult] = None
    equip_error: typing.Optional[int] = None
    item: typing.Optional[int] = None
    item_count: typing.Optional[int] = None
    result2: typing.Optional[MailResultTwo] = None
    equip_error2: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SEND_MAIL_RESULT:
        result = None
        equip_error = None
        item = None
        item_count = None
        result2 = None
        equip_error2 = None
        # mail_id: u32
        mail_id = await read_int(reader, 4)

        # action: MailAction
        action = MailAction(await read_int(reader, 4))

        if action == MailAction.ITEM_TAKEN:
            # result: MailResult
            result = MailResult(await read_int(reader, 4))

            if result == MailResult.ERR_EQUIP_ERROR:
                # equip_error: u32
                equip_error = await read_int(reader, 4)

            elif result in {MailResult.OK, MailResult.ERR_CANNOT_SEND_TO_SELF, MailResult.ERR_NOT_ENOUGH_MONEY, MailResult.ERR_RECIPIENT_NOT_FOUND, MailResult.ERR_NOT_YOUR_TEAM, MailResult.ERR_INTERNAL_ERROR, MailResult.ERR_DISABLED_FOR_TRIAL_ACC, MailResult.ERR_RECIPIENT_CAP_REACHED, MailResult.ERR_CANT_SEND_WRAPPED_COD, MailResult.ERR_MAIL_AND_CHAT_SUSPENDED, MailResult.ERR_TOO_MANY_ATTACHMENTS, MailResult.ERR_MAIL_ATTACHMENT_INVALID}:
                # item: Item
                item = await read_int(reader, 4)

                # item_count: u32
                item_count = await read_int(reader, 4)

        elif action in {MailAction.SEND, MailAction.MONEY_TAKEN, MailAction.RETURNED_TO_SENDER, MailAction.DELETED, MailAction.MADE_PERMANENT}:
            # result2: MailResultTwo
            result2 = MailResultTwo(await read_int(reader, 4))

            if result2 == MailResultTwo.ERR_EQUIP_ERROR:
                # equip_error2: u32
                equip_error2 = await read_int(reader, 4)

        return SMSG_SEND_MAIL_RESULT(
            mail_id=mail_id,
            action=action,
            result=result,
            equip_error=equip_error,
            item=item,
            item_count=item_count,
            result2=result2,
            equip_error2=equip_error2,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0239))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.mail_id, self.action.value])
        if self.action == MailAction.ITEM_TAKEN:
            _fmt += 'I'
            _data.append(self.result.value)
            if self.result == MailResult.ERR_EQUIP_ERROR:
                _fmt += 'I'
                _data.append(self.equip_error)
            elif self.result in {MailResult.OK, MailResult.ERR_CANNOT_SEND_TO_SELF, MailResult.ERR_NOT_ENOUGH_MONEY, MailResult.ERR_RECIPIENT_NOT_FOUND, MailResult.ERR_NOT_YOUR_TEAM, MailResult.ERR_INTERNAL_ERROR, MailResult.ERR_DISABLED_FOR_TRIAL_ACC, MailResult.ERR_RECIPIENT_CAP_REACHED, MailResult.ERR_CANT_SEND_WRAPPED_COD, MailResult.ERR_MAIL_AND_CHAT_SUSPENDED, MailResult.ERR_TOO_MANY_ATTACHMENTS, MailResult.ERR_MAIL_ATTACHMENT_INVALID}:
                _fmt += 'II'
                _data.extend([self.item, self.item_count])
        elif self.action in {MailAction.SEND, MailAction.MONEY_TAKEN, MailAction.RETURNED_TO_SENDER, MailAction.DELETED, MailAction.MADE_PERMANENT}:
            _fmt += 'I'
            _data.append(self.result2.value)
            if self.result2 == MailResultTwo.ERR_EQUIP_ERROR:
                _fmt += 'I'
                _data.append(self.equip_error2)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 8

        if self.action == MailAction.ITEM_TAKEN:
            _size += 4

            if self.result == MailResult.ERR_EQUIP_ERROR:
                _size += 4
            elif self.result in {MailResult.OK, MailResult.ERR_CANNOT_SEND_TO_SELF, MailResult.ERR_NOT_ENOUGH_MONEY, MailResult.ERR_RECIPIENT_NOT_FOUND, MailResult.ERR_NOT_YOUR_TEAM, MailResult.ERR_INTERNAL_ERROR, MailResult.ERR_DISABLED_FOR_TRIAL_ACC, MailResult.ERR_RECIPIENT_CAP_REACHED, MailResult.ERR_CANT_SEND_WRAPPED_COD, MailResult.ERR_MAIL_AND_CHAT_SUSPENDED, MailResult.ERR_TOO_MANY_ATTACHMENTS, MailResult.ERR_MAIL_ATTACHMENT_INVALID}:
                _size += 8

        elif self.action in {MailAction.SEND, MailAction.MONEY_TAKEN, MailAction.RETURNED_TO_SENDER, MailAction.DELETED, MailAction.MADE_PERMANENT}:
            _size += 4

            if self.result2 == MailResultTwo.ERR_EQUIP_ERROR:
                _size += 4


        return _size


@dataclasses.dataclass
class CMSG_GET_MAIL_LIST:
    mailbox: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GET_MAIL_LIST:
        # mailbox: Guid
        mailbox = await read_int(reader, 8)

        return CMSG_GET_MAIL_LIST(
            mailbox=mailbox,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x023A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.mailbox)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MAIL_LIST_RESULT:
    mails: typing.List[Mail]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MAIL_LIST_RESULT:
        # amount_of_mails: u8
        amount_of_mails = await read_int(reader, 1)

        # mails: Mail[amount_of_mails]
        mails = []
        for _ in range(0, amount_of_mails):
            mails.append(await Mail.read(reader))

        return SMSG_MAIL_LIST_RESULT(
            mails=mails,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x023B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(len(self.mails))
        # mails: Mail[amount_of_mails]
        for i in self.mails:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + sum([i.size() for i in self.mails])


@dataclasses.dataclass
class CMSG_BATTLEFIELD_LIST:
    map: Map

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BATTLEFIELD_LIST:
        # map: Map
        map = Map(await read_int(reader, 4))

        return CMSG_BATTLEFIELD_LIST(
            map=map,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x023C))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BATTLEFIELD_LIST:
    battlemaster: int
    map: Map
    bracket: BattlegroundBracket
    battlegrounds: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BATTLEFIELD_LIST:
        # battlemaster: Guid
        battlemaster = await read_int(reader, 8)

        # map: Map
        map = Map(await read_int(reader, 4))

        # bracket: BattlegroundBracket
        bracket = BattlegroundBracket(await read_int(reader, 1))

        # number_of_battlegrounds: u32
        number_of_battlegrounds = await read_int(reader, 4)

        # battlegrounds: u32[number_of_battlegrounds]
        battlegrounds = []
        for _ in range(0, number_of_battlegrounds):
            battlegrounds.append(await read_int(reader, 4))

        return SMSG_BATTLEFIELD_LIST(
            battlemaster=battlemaster,
            map=map,
            bracket=bracket,
            battlegrounds=battlegrounds,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x023D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QIBI{len(self.battlegrounds)}I'
        _data.extend([self.battlemaster, self.map.value, self.bracket.value, len(self.battlegrounds), *self.battlegrounds])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 17 + 4 * len(self.battlegrounds)


@dataclasses.dataclass
class CMSG_BATTLEFIELD_JOIN:
    map: Map

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BATTLEFIELD_JOIN:
        # map: Map
        map = Map(await read_int(reader, 4))

        return CMSG_BATTLEFIELD_JOIN(
            map=map,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x023E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ITEM_TEXT_QUERY:
    item_text_id: int
    mail_id: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ITEM_TEXT_QUERY:
        # item_text_id: u32
        item_text_id = await read_int(reader, 4)

        # mail_id: u32
        mail_id = await read_int(reader, 4)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return CMSG_ITEM_TEXT_QUERY(
            item_text_id=item_text_id,
            mail_id=mail_id,
            unknown1=unknown1,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0243))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'III'
        _data.extend([self.item_text_id, self.mail_id, self.unknown1])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_TEXT_QUERY_RESPONSE:
    item_text_id: int
    text: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_TEXT_QUERY_RESPONSE:
        # item_text_id: u32
        item_text_id = await read_int(reader, 4)

        # text: CString
        text = await read_cstring(reader)

        return SMSG_ITEM_TEXT_QUERY_RESPONSE(
            item_text_id=item_text_id,
            text=text,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0244))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.text)}sB'
        _data.extend([self.item_text_id, self.text.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + len(self.text)


@dataclasses.dataclass
class CMSG_MAIL_TAKE_MONEY:
    mailbox: int
    mail_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MAIL_TAKE_MONEY:
        # mailbox: Guid
        mailbox = await read_int(reader, 8)

        # mail_id: u32
        mail_id = await read_int(reader, 4)

        return CMSG_MAIL_TAKE_MONEY(
            mailbox=mailbox,
            mail_id=mail_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0245))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.mailbox, self.mail_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MAIL_TAKE_ITEM:
    mailbox: int
    mail_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MAIL_TAKE_ITEM:
        # mailbox: Guid
        mailbox = await read_int(reader, 8)

        # mail_id: u32
        mail_id = await read_int(reader, 4)

        return CMSG_MAIL_TAKE_ITEM(
            mailbox=mailbox,
            mail_id=mail_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0246))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.mailbox, self.mail_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MAIL_MARK_AS_READ:
    mailbox: int
    mail_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MAIL_MARK_AS_READ:
        # mailbox: Guid
        mailbox = await read_int(reader, 8)

        # mail_id: u32
        mail_id = await read_int(reader, 4)

        return CMSG_MAIL_MARK_AS_READ(
            mailbox=mailbox,
            mail_id=mail_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0247))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.mailbox, self.mail_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MAIL_RETURN_TO_SENDER:
    mailbox_id: int
    mail_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MAIL_RETURN_TO_SENDER:
        # mailbox_id: Guid
        mailbox_id = await read_int(reader, 8)

        # mail_id: u32
        mail_id = await read_int(reader, 4)

        return CMSG_MAIL_RETURN_TO_SENDER(
            mailbox_id=mailbox_id,
            mail_id=mail_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0248))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.mailbox_id, self.mail_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MAIL_DELETE:
    mailbox_id: int
    mail_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MAIL_DELETE:
        # mailbox_id: Guid
        mailbox_id = await read_int(reader, 8)

        # mail_id: u32
        mail_id = await read_int(reader, 4)

        return CMSG_MAIL_DELETE(
            mailbox_id=mailbox_id,
            mail_id=mail_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0249))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.mailbox_id, self.mail_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MAIL_CREATE_TEXT_ITEM:
    mailbox: int
    mail_id: int
    mail_template_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MAIL_CREATE_TEXT_ITEM:
        # mailbox: Guid
        mailbox = await read_int(reader, 8)

        # mail_id: u32
        mail_id = await read_int(reader, 4)

        # mail_template_id: u32
        mail_template_id = await read_int(reader, 4)

        return CMSG_MAIL_CREATE_TEXT_ITEM(
            mailbox=mailbox,
            mail_id=mail_id,
            mail_template_id=mail_template_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x024A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.mailbox, self.mail_id, self.mail_template_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELLLOGMISS:
    id: int
    caster: int
    unknown1: int
    targets: typing.List[SpellLogMiss]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLLOGMISS:
        # id: Spell
        id = await read_int(reader, 4)

        # caster: Guid
        caster = await read_int(reader, 8)

        # unknown1: u8
        unknown1 = await read_int(reader, 1)

        # amount_of_targets: u32
        amount_of_targets = await read_int(reader, 4)

        # targets: SpellLogMiss[amount_of_targets]
        targets = []
        for _ in range(0, amount_of_targets):
            targets.append(await SpellLogMiss.read(reader))

        return SMSG_SPELLLOGMISS(
            id=id,
            caster=caster,
            unknown1=unknown1,
            targets=targets,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x024B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IQBI'
        _data.extend([self.id, self.caster, self.unknown1, len(self.targets)])
        # targets: SpellLogMiss[amount_of_targets]
        for i in self.targets:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 17 + 9 * len(self.targets)


@dataclasses.dataclass
class SMSG_SPELLLOGEXECUTE:
    caster: int
    spell: int
    logs: typing.List[SpellLog]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLLOGEXECUTE:
        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # spell: Spell
        spell = await read_int(reader, 4)

        # amount_of_effects: u32
        amount_of_effects = await read_int(reader, 4)

        # logs: SpellLog[amount_of_effects]
        logs = []
        for _ in range(0, amount_of_effects):
            logs.append(await SpellLog.read(reader))

        return SMSG_SPELLLOGEXECUTE(
            caster=caster,
            spell=spell,
            logs=logs,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x024C))
        _fmt = "<4s"
        _data = [_data]

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # amount_of_effects: u32
        _fmt += 'I'
        _data.append(len(self.logs))

        # logs: SpellLog[amount_of_effects]
        for i in self.logs:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.caster) + sum([i.size() for i in self.logs])


@dataclasses.dataclass
class SMSG_PERIODICAURALOG:
    target: int
    caster: int
    spell: int
    auras: typing.List[AuraLog]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PERIODICAURALOG:
        # target: PackedGuid
        target = await read_packed_guid(reader)

        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # spell: Spell
        spell = await read_int(reader, 4)

        # amount_of_auras: u32
        amount_of_auras = await read_int(reader, 4)

        # auras: AuraLog[amount_of_auras]
        auras = []
        for _ in range(0, amount_of_auras):
            auras.append(await AuraLog.read(reader))

        return SMSG_PERIODICAURALOG(
            target=target,
            caster=caster,
            spell=spell,
            auras=auras,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x024E))
        _fmt = "<4s"
        _data = [_data]

        # target: PackedGuid
        _fmt, _data = packed_guid_write(self.target, _fmt, _data)

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # amount_of_auras: u32
        _fmt += 'I'
        _data.append(len(self.auras))

        # auras: AuraLog[amount_of_auras]
        for i in self.auras:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.target) + packed_guid_size(self.caster) + sum([i.size() for i in self.auras])


@dataclasses.dataclass
class SMSG_SPELLDAMAGESHIELD:
    victim: int
    caster: int
    damage: int
    school: SpellSchool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLDAMAGESHIELD:
        # victim: Guid
        victim = await read_int(reader, 8)

        # caster: Guid
        caster = await read_int(reader, 8)

        # damage: u32
        damage = await read_int(reader, 4)

        # school: SpellSchool
        school = SpellSchool(await read_int(reader, 4))

        return SMSG_SPELLDAMAGESHIELD(
            victim=victim,
            caster=caster,
            damage=damage,
            school=school,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(24 + 2, 0x024F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQII'
        _data.extend([self.victim, self.caster, self.damage, self.school.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELLNONMELEEDAMAGELOG:
    target: int
    attacker: int
    spell: int
    damage: int
    school: SpellSchool
    absorbed_damage: int
    resisted: int
    periodic_log: bool
    unused: int
    blocked: int
    hit_info: HitInfo
    extend_flag: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLNONMELEEDAMAGELOG:
        # target: PackedGuid
        target = await read_packed_guid(reader)

        # attacker: PackedGuid
        attacker = await read_packed_guid(reader)

        # spell: Spell
        spell = await read_int(reader, 4)

        # damage: u32
        damage = await read_int(reader, 4)

        # school: SpellSchool
        school = SpellSchool(await read_int(reader, 1))

        # absorbed_damage: u32
        absorbed_damage = await read_int(reader, 4)

        # resisted: u32
        resisted = await read_int(reader, 4)

        # periodic_log: Bool8
        periodic_log = await read_bool(reader, 1)

        # unused: u8
        unused = await read_int(reader, 1)

        # blocked: u32
        blocked = await read_int(reader, 4)

        # hit_info: HitInfo
        hit_info = HitInfo(await read_int(reader, 4))

        # extend_flag: u8
        extend_flag = await read_int(reader, 1)

        return SMSG_SPELLNONMELEEDAMAGELOG(
            target=target,
            attacker=attacker,
            spell=spell,
            damage=damage,
            school=school,
            absorbed_damage=absorbed_damage,
            resisted=resisted,
            periodic_log=periodic_log,
            unused=unused,
            blocked=blocked,
            hit_info=hit_info,
            extend_flag=extend_flag,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0250))
        _fmt = "<4s"
        _data = [_data]

        # target: PackedGuid
        _fmt, _data = packed_guid_write(self.target, _fmt, _data)

        # attacker: PackedGuid
        _fmt, _data = packed_guid_write(self.attacker, _fmt, _data)

        # spell: Spell
        _fmt += 'I'
        _data.append(self.spell)

        # damage: u32
        _fmt += 'I'
        _data.append(self.damage)

        # school: SpellSchool
        _fmt += 'B'
        _data.append(self.school.value)

        # absorbed_damage: u32
        _fmt += 'I'
        _data.append(self.absorbed_damage)

        # resisted: u32
        _fmt += 'I'
        _data.append(self.resisted)

        # periodic_log: Bool8
        _fmt += 'B'
        _data.append(self.periodic_log)

        # unused: u8
        _fmt += 'B'
        _data.append(self.unused)

        # blocked: u32
        _fmt += 'I'
        _data.append(self.blocked)

        # hit_info: HitInfo
        _fmt += 'I'
        _data.append(self.hit_info.value)

        # extend_flag: u8
        _fmt += 'B'
        _data.append(self.extend_flag)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 28 + packed_guid_size(self.target) + packed_guid_size(self.attacker)


@dataclasses.dataclass
class CMSG_LEARN_TALENT:
    talent: Talent
    requested_rank: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LEARN_TALENT:
        # talent: Talent
        talent = Talent(await read_int(reader, 4))

        # requested_rank: u32
        requested_rank = await read_int(reader, 4)

        return CMSG_LEARN_TALENT(
            talent=talent,
            requested_rank=requested_rank,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0251))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.talent.value, self.requested_rank])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TOGGLE_PVP:
    enable_pvp: typing.Optional[bool] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TOGGLE_PVP:
        enable_pvp = None
        _size = 0

        # set: optional
        if _size < body_size:
            # enable_pvp: Bool8
            enable_pvp = await read_bool(reader, 1)
            _size += 1

        return CMSG_TOGGLE_PVP(
            enable_pvp=enable_pvp,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0253))
        _fmt = "<6s"
        _data = [_data]

        # set: optional
        if self.enable_pvp is not None:
            _fmt += 'B'
            _data.append(self.enable_pvp)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 0

        # set: optional
        if self.enable_pvp is not None:
            _size += 1

        return _size


@dataclasses.dataclass
class SMSG_ZONE_UNDER_ATTACK:
    zone_id: Area

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ZONE_UNDER_ATTACK:
        # zone_id: Area
        zone_id = Area(await read_int(reader, 4))

        return SMSG_ZONE_UNDER_ATTACK(
            zone_id=zone_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0254))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.zone_id.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_AUCTION_HELLO_Client:
    auctioneer: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_AUCTION_HELLO_Client:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        return MSG_AUCTION_HELLO_Client(
            auctioneer=auctioneer,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0255))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.auctioneer)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_AUCTION_HELLO_Server:
    auctioneer: int
    auction_house: AuctionHouse

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_AUCTION_HELLO_Server:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        # auction_house: AuctionHouse
        auction_house = AuctionHouse(await read_int(reader, 4))

        return MSG_AUCTION_HELLO_Server(
            auctioneer=auctioneer,
            auction_house=auction_house,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0255))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.auctioneer, self.auction_house.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUCTION_SELL_ITEM:
    auctioneer: int
    item: int
    starting_bid: int
    buyout: int
    auction_duration_in_minutes: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUCTION_SELL_ITEM:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        # item: Guid
        item = await read_int(reader, 8)

        # starting_bid: u32
        starting_bid = await read_int(reader, 4)

        # buyout: u32
        buyout = await read_int(reader, 4)

        # auction_duration_in_minutes: u32
        auction_duration_in_minutes = await read_int(reader, 4)

        return CMSG_AUCTION_SELL_ITEM(
            auctioneer=auctioneer,
            item=item,
            starting_bid=starting_bid,
            buyout=buyout,
            auction_duration_in_minutes=auction_duration_in_minutes,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(28 + 4, 0x0256))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QQIII'
        _data.extend([self.auctioneer, self.item, self.starting_bid, self.buyout, self.auction_duration_in_minutes])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUCTION_REMOVE_ITEM:
    auctioneer: int
    auction_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUCTION_REMOVE_ITEM:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        # auction_id: u32
        auction_id = await read_int(reader, 4)

        return CMSG_AUCTION_REMOVE_ITEM(
            auctioneer=auctioneer,
            auction_id=auction_id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0257))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.auctioneer, self.auction_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUCTION_LIST_ITEMS:
    auctioneer: int
    list_start_item: int
    searched_name: str
    minimum_level: int
    maximum_level: int
    auction_slot_id: int
    auction_main_category: int
    auction_sub_category: int
    auction_quality: ItemQuality
    usable: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUCTION_LIST_ITEMS:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        # list_start_item: u32
        list_start_item = await read_int(reader, 4)

        # searched_name: CString
        searched_name = await read_cstring(reader)

        # minimum_level: u8
        minimum_level = await read_int(reader, 1)

        # maximum_level: u8
        maximum_level = await read_int(reader, 1)

        # auction_slot_id: u32
        auction_slot_id = await read_int(reader, 4)

        # auction_main_category: u32
        auction_main_category = await read_int(reader, 4)

        # auction_sub_category: u32
        auction_sub_category = await read_int(reader, 4)

        # auction_quality: ItemQuality
        auction_quality = ItemQuality(await read_int(reader, 4))

        # usable: u8
        usable = await read_int(reader, 1)

        return CMSG_AUCTION_LIST_ITEMS(
            auctioneer=auctioneer,
            list_start_item=list_start_item,
            searched_name=searched_name,
            minimum_level=minimum_level,
            maximum_level=maximum_level,
            auction_slot_id=auction_slot_id,
            auction_main_category=auction_main_category,
            auction_sub_category=auction_sub_category,
            auction_quality=auction_quality,
            usable=usable,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0258))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'QI{len(self.searched_name)}sBBBIIIIB'
        _data.extend([self.auctioneer, self.list_start_item, self.searched_name.encode('utf-8'), 0, self.minimum_level, self.maximum_level, self.auction_slot_id, self.auction_main_category, self.auction_sub_category, self.auction_quality.value, self.usable])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 32 + len(self.searched_name)


@dataclasses.dataclass
class CMSG_AUCTION_LIST_OWNER_ITEMS:
    auctioneer: int
    list_from: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUCTION_LIST_OWNER_ITEMS:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        # list_from: u32
        list_from = await read_int(reader, 4)

        return CMSG_AUCTION_LIST_OWNER_ITEMS(
            auctioneer=auctioneer,
            list_from=list_from,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0259))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.auctioneer, self.list_from])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUCTION_PLACE_BID:
    auctioneer: int
    auction_id: int
    price: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUCTION_PLACE_BID:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        # auction_id: u32
        auction_id = await read_int(reader, 4)

        # price: Gold
        price = await read_int(reader, 4)

        return CMSG_AUCTION_PLACE_BID(
            auctioneer=auctioneer,
            auction_id=auction_id,
            price=price,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x025A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.auctioneer, self.auction_id, self.price])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AUCTION_COMMAND_RESULT:
    auction_id: int
    action: AuctionCommandAction
    result: typing.Optional[AuctionCommandResult] = None
    auction_outbid1: typing.Optional[int] = None
    inventory_result: typing.Optional[InventoryResult] = None
    higher_bidder: typing.Optional[int] = None
    new_bid: typing.Optional[int] = None
    auction_outbid2: typing.Optional[int] = None
    result2: typing.Optional[AuctionCommandResultTwo] = None
    inventory_result2: typing.Optional[InventoryResult] = None
    higher_bidder2: typing.Optional[int] = None
    new_bid2: typing.Optional[int] = None
    auction_outbid3: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_COMMAND_RESULT:
        result = None
        auction_outbid1 = None
        inventory_result = None
        higher_bidder = None
        new_bid = None
        auction_outbid2 = None
        result2 = None
        inventory_result2 = None
        higher_bidder2 = None
        new_bid2 = None
        auction_outbid3 = None
        # auction_id: u32
        auction_id = await read_int(reader, 4)

        # action: AuctionCommandAction
        action = AuctionCommandAction(await read_int(reader, 4))

        if action == AuctionCommandAction.BID_PLACED:
            # result: AuctionCommandResult
            result = AuctionCommandResult(await read_int(reader, 4))

            if result == AuctionCommandResult.OK:
                # auction_outbid1: u32
                auction_outbid1 = await read_int(reader, 4)

            elif result == AuctionCommandResult.ERR_INVENTORY:
                # inventory_result: InventoryResult
                inventory_result = InventoryResult(await read_int(reader, 1))

            elif result == AuctionCommandResult.ERR_HIGHER_BID:
                # higher_bidder: Guid
                higher_bidder = await read_int(reader, 8)

                # new_bid: u32
                new_bid = await read_int(reader, 4)

                # auction_outbid2: u32
                auction_outbid2 = await read_int(reader, 4)

        elif action in {AuctionCommandAction.STARTED, AuctionCommandAction.REMOVED}:
            # result2: AuctionCommandResultTwo
            result2 = AuctionCommandResultTwo(await read_int(reader, 4))

            if result2 == AuctionCommandResultTwo.ERR_INVENTORY:
                # inventory_result2: InventoryResult
                inventory_result2 = InventoryResult(await read_int(reader, 1))

            elif result2 == AuctionCommandResultTwo.ERR_HIGHER_BID:
                # higher_bidder2: Guid
                higher_bidder2 = await read_int(reader, 8)

                # new_bid2: u32
                new_bid2 = await read_int(reader, 4)

                # auction_outbid3: u32
                auction_outbid3 = await read_int(reader, 4)

        return SMSG_AUCTION_COMMAND_RESULT(
            auction_id=auction_id,
            action=action,
            result=result,
            auction_outbid1=auction_outbid1,
            inventory_result=inventory_result,
            higher_bidder=higher_bidder,
            new_bid=new_bid,
            auction_outbid2=auction_outbid2,
            result2=result2,
            inventory_result2=inventory_result2,
            higher_bidder2=higher_bidder2,
            new_bid2=new_bid2,
            auction_outbid3=auction_outbid3,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x025B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.auction_id, self.action.value])
        if self.action == AuctionCommandAction.BID_PLACED:
            _fmt += 'I'
            _data.append(self.result.value)
            if self.result == AuctionCommandResult.OK:
                _fmt += 'I'
                _data.append(self.auction_outbid1)
            elif self.result == AuctionCommandResult.ERR_INVENTORY:
                _fmt += 'B'
                _data.append(self.inventory_result.value)
            elif self.result == AuctionCommandResult.ERR_HIGHER_BID:
                _fmt += 'QII'
                _data.extend([self.higher_bidder, self.new_bid, self.auction_outbid2])
        elif self.action in {AuctionCommandAction.STARTED, AuctionCommandAction.REMOVED}:
            _fmt += 'I'
            _data.append(self.result2.value)
            if self.result2 == AuctionCommandResultTwo.ERR_INVENTORY:
                _fmt += 'B'
                _data.append(self.inventory_result2.value)
            elif self.result2 == AuctionCommandResultTwo.ERR_HIGHER_BID:
                _fmt += 'QII'
                _data.extend([self.higher_bidder2, self.new_bid2, self.auction_outbid3])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 8

        if self.action == AuctionCommandAction.BID_PLACED:
            _size += 4

            if self.result == AuctionCommandResult.OK:
                _size += 4
            elif self.result == AuctionCommandResult.ERR_INVENTORY:
                _size += 1
            elif self.result == AuctionCommandResult.ERR_HIGHER_BID:
                _size += 16

        elif self.action in {AuctionCommandAction.STARTED, AuctionCommandAction.REMOVED}:
            _size += 4

            if self.result2 == AuctionCommandResultTwo.ERR_INVENTORY:
                _size += 1
            elif self.result2 == AuctionCommandResultTwo.ERR_HIGHER_BID:
                _size += 16


        return _size


@dataclasses.dataclass
class SMSG_AUCTION_LIST_RESULT:
    auctions: typing.List[AuctionListItem]
    total_amount_of_auctions: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_LIST_RESULT:
        # count: u32
        count = await read_int(reader, 4)

        # auctions: AuctionListItem[count]
        auctions = []
        for _ in range(0, count):
            auctions.append(await AuctionListItem.read(reader))

        # total_amount_of_auctions: u32
        total_amount_of_auctions = await read_int(reader, 4)

        return SMSG_AUCTION_LIST_RESULT(
            auctions=auctions,
            total_amount_of_auctions=total_amount_of_auctions,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x025C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.auctions))
        # auctions: AuctionListItem[count]
        for i in self.auctions:
            _fmt, _data = i.write(_fmt, _data)

        # total_amount_of_auctions: u32
        _fmt += 'I'
        _data.append(self.total_amount_of_auctions)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + 64 * len(self.auctions)


@dataclasses.dataclass
class SMSG_AUCTION_OWNER_LIST_RESULT:
    auctions: typing.List[AuctionListItem]
    total_amount_of_auctions: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_OWNER_LIST_RESULT:
        # count: u32
        count = await read_int(reader, 4)

        # auctions: AuctionListItem[count]
        auctions = []
        for _ in range(0, count):
            auctions.append(await AuctionListItem.read(reader))

        # total_amount_of_auctions: u32
        total_amount_of_auctions = await read_int(reader, 4)

        return SMSG_AUCTION_OWNER_LIST_RESULT(
            auctions=auctions,
            total_amount_of_auctions=total_amount_of_auctions,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x025D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.auctions))
        # auctions: AuctionListItem[count]
        for i in self.auctions:
            _fmt, _data = i.write(_fmt, _data)

        # total_amount_of_auctions: u32
        _fmt += 'I'
        _data.append(self.total_amount_of_auctions)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + 64 * len(self.auctions)


@dataclasses.dataclass
class SMSG_AUCTION_BIDDER_NOTIFICATION:
    auction_house: AuctionHouse
    auction_id: int
    bidder: int
    won: int
    out_bid: int
    item_template: int
    item_random_property_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_BIDDER_NOTIFICATION:
        # auction_house: AuctionHouse
        auction_house = AuctionHouse(await read_int(reader, 4))

        # auction_id: u32
        auction_id = await read_int(reader, 4)

        # bidder: Guid
        bidder = await read_int(reader, 8)

        # won: u32
        won = await read_int(reader, 4)

        # out_bid: u32
        out_bid = await read_int(reader, 4)

        # item_template: u32
        item_template = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        return SMSG_AUCTION_BIDDER_NOTIFICATION(
            auction_house=auction_house,
            auction_id=auction_id,
            bidder=bidder,
            won=won,
            out_bid=out_bid,
            item_template=item_template,
            item_random_property_id=item_random_property_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(32 + 2, 0x025E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIQIIII'
        _data.extend([self.auction_house.value, self.auction_id, self.bidder, self.won, self.out_bid, self.item_template, self.item_random_property_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AUCTION_OWNER_NOTIFICATION:
    auction_id: int
    bid: int
    auction_out_bid: int
    bidder: int
    item: int
    item_random_property_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_OWNER_NOTIFICATION:
        # auction_id: u32
        auction_id = await read_int(reader, 4)

        # bid: u32
        bid = await read_int(reader, 4)

        # auction_out_bid: u32
        auction_out_bid = await read_int(reader, 4)

        # bidder: Guid
        bidder = await read_int(reader, 8)

        # item: Item
        item = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        return SMSG_AUCTION_OWNER_NOTIFICATION(
            auction_id=auction_id,
            bid=bid,
            auction_out_bid=auction_out_bid,
            bidder=bidder,
            item=item,
            item_random_property_id=item_random_property_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(28 + 2, 0x025F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIIQII'
        _data.extend([self.auction_id, self.bid, self.auction_out_bid, self.bidder, self.item, self.item_random_property_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PROCRESIST:
    caster: int
    target: int
    id: int
    log_format: LogFormat

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PROCRESIST:
        # caster: Guid
        caster = await read_int(reader, 8)

        # target: Guid
        target = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        # log_format: LogFormat
        log_format = LogFormat(await read_int(reader, 1))

        return SMSG_PROCRESIST(
            caster=caster,
            target=target,
            id=id,
            log_format=log_format,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(21 + 2, 0x0260))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQIB'
        _data.extend([self.caster, self.target, self.id, self.log_format.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DISPEL_FAILED:
    caster: int
    target: int
    spells: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DISPEL_FAILED:
        _size = 0

        # caster: Guid
        caster = await read_int(reader, 8)
        _size += 8

        # target: Guid
        target = await read_int(reader, 8)
        _size += 8

        # spells: Spell[-]
        spells = []
        while _size < body_size:
            spells.append(await read_int(reader, 4))
            _size += 4

        return SMSG_DISPEL_FAILED(
            caster=caster,
            target=target,
            spells=spells,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0262))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQ'
        _data.extend([self.caster, self.target])
        # spells: Spell[-]
        _fmt += f'len({self.spells})I'
        _data.extend(self.spells)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + 4 * len(self.spells)


@dataclasses.dataclass
class SMSG_SPELLORDAMAGE_IMMUNE:
    caster: int
    target: int
    id: int
    debug_log_format: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLORDAMAGE_IMMUNE:
        # caster: Guid
        caster = await read_int(reader, 8)

        # target: Guid
        target = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        # debug_log_format: Bool8
        debug_log_format = await read_bool(reader, 1)

        return SMSG_SPELLORDAMAGE_IMMUNE(
            caster=caster,
            target=target,
            id=id,
            debug_log_format=debug_log_format,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(21 + 2, 0x0263))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QQIB'
        _data.extend([self.caster, self.target, self.id, self.debug_log_format])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUCTION_LIST_BIDDER_ITEMS:
    auctioneer: int
    start_from_page: int
    outbid_item_ids: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUCTION_LIST_BIDDER_ITEMS:
        # auctioneer: Guid
        auctioneer = await read_int(reader, 8)

        # start_from_page: u32
        start_from_page = await read_int(reader, 4)

        # amount_of_outbid_items: u32
        amount_of_outbid_items = await read_int(reader, 4)

        # outbid_item_ids: u32[amount_of_outbid_items]
        outbid_item_ids = []
        for _ in range(0, amount_of_outbid_items):
            outbid_item_ids.append(await read_int(reader, 4))

        return CMSG_AUCTION_LIST_BIDDER_ITEMS(
            auctioneer=auctioneer,
            start_from_page=start_from_page,
            outbid_item_ids=outbid_item_ids,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0264))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'QII{len(self.outbid_item_ids)}I'
        _data.extend([self.auctioneer, self.start_from_page, len(self.outbid_item_ids), *self.outbid_item_ids])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + 4 * len(self.outbid_item_ids)


@dataclasses.dataclass
class SMSG_AUCTION_BIDDER_LIST_RESULT:
    auctions: typing.List[AuctionListItem]
    total_amount_of_auctions: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_BIDDER_LIST_RESULT:
        # count: u32
        count = await read_int(reader, 4)

        # auctions: AuctionListItem[count]
        auctions = []
        for _ in range(0, count):
            auctions.append(await AuctionListItem.read(reader))

        # total_amount_of_auctions: u32
        total_amount_of_auctions = await read_int(reader, 4)

        return SMSG_AUCTION_BIDDER_LIST_RESULT(
            auctions=auctions,
            total_amount_of_auctions=total_amount_of_auctions,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0265))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.auctions))
        # auctions: AuctionListItem[count]
        for i in self.auctions:
            _fmt, _data = i.write(_fmt, _data)

        # total_amount_of_auctions: u32
        _fmt += 'I'
        _data.append(self.total_amount_of_auctions)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + 64 * len(self.auctions)


@dataclasses.dataclass
class SMSG_SET_FLAT_SPELL_MODIFIER:
    eff: int
    op: int
    value: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_FLAT_SPELL_MODIFIER:
        # eff: u8
        eff = await read_int(reader, 1)

        # op: u8
        op = await read_int(reader, 1)

        # value: u32
        value = await read_int(reader, 4)

        return SMSG_SET_FLAT_SPELL_MODIFIER(
            eff=eff,
            op=op,
            value=value,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(6 + 2, 0x0266))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BBI'
        _data.extend([self.eff, self.op, self.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SET_PCT_SPELL_MODIFIER:
    eff: int
    op: int
    value: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_PCT_SPELL_MODIFIER:
        # eff: u8
        eff = await read_int(reader, 1)

        # op: u8
        op = await read_int(reader, 1)

        # value: u32
        value = await read_int(reader, 4)

        return SMSG_SET_PCT_SPELL_MODIFIER(
            eff=eff,
            op=op,
            value=value,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(6 + 2, 0x0267))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'BBI'
        _data.extend([self.eff, self.op, self.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_AMMO:
    item: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_AMMO:
        # item: Item
        item = await read_int(reader, 4)

        return CMSG_SET_AMMO(
            item=item,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0268))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.item)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CORPSE_RECLAIM_DELAY:
    delay: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CORPSE_RECLAIM_DELAY:
        # delay: Seconds
        delay = await read_int(reader, 4)

        return SMSG_CORPSE_RECLAIM_DELAY(
            delay=delay,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0269))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.delay)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_ACTIVE_MOVER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_ACTIVE_MOVER:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_SET_ACTIVE_MOVER(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x026A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_PET_CANCEL_AURA:
    guid: int
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_CANCEL_AURA:
        # guid: Guid
        guid = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        return CMSG_PET_CANCEL_AURA(
            guid=guid,
            id=id,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x026B))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CANCEL_AUTO_REPEAT_SPELL:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_AUTO_REPEAT_SPELL:
        return CMSG_CANCEL_AUTO_REPEAT_SPELL()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x026D))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_LIST_STABLED_PETS_Client:
    npc: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_LIST_STABLED_PETS_Client:
        # npc: Guid
        npc = await read_int(reader, 8)

        return MSG_LIST_STABLED_PETS_Client(
            npc=npc,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x026F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.npc)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_LIST_STABLED_PETS_Server:
    npc: int
    stable_slots: int
    pets: typing.List[StabledPet]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_LIST_STABLED_PETS_Server:
        # npc: Guid
        npc = await read_int(reader, 8)

        # amount_of_pets: u8
        amount_of_pets = await read_int(reader, 1)

        # stable_slots: u8
        stable_slots = await read_int(reader, 1)

        # pets: StabledPet[amount_of_pets]
        pets = []
        for _ in range(0, amount_of_pets):
            pets.append(await StabledPet.read(reader))

        return MSG_LIST_STABLED_PETS_Server(
            npc=npc,
            stable_slots=stable_slots,
            pets=pets,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x026F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QBB'
        _data.extend([self.npc, len(self.pets), self.stable_slots])
        # pets: StabledPet[amount_of_pets]
        for i in self.pets:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 10 + sum([i.size() for i in self.pets])


@dataclasses.dataclass
class CMSG_STABLE_PET:
    stable_master: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_STABLE_PET:
        # stable_master: Guid
        stable_master = await read_int(reader, 8)

        return CMSG_STABLE_PET(
            stable_master=stable_master,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0270))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.stable_master)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_UNSTABLE_PET:
    stable_master: int
    pet_number: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_UNSTABLE_PET:
        # stable_master: Guid
        stable_master = await read_int(reader, 8)

        # pet_number: u32
        pet_number = await read_int(reader, 4)

        return CMSG_UNSTABLE_PET(
            stable_master=stable_master,
            pet_number=pet_number,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0271))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.stable_master, self.pet_number])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BUY_STABLE_SLOT:
    npc: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BUY_STABLE_SLOT:
        # npc: Guid
        npc = await read_int(reader, 8)

        return CMSG_BUY_STABLE_SLOT(
            npc=npc,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0272))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.npc)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_STABLE_RESULT:
    result: StableResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_STABLE_RESULT:
        # result: StableResult
        result = StableResult(await read_int(reader, 1))

        return SMSG_STABLE_RESULT(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x0273))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_STABLE_SWAP_PET:
    npc: int
    pet_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_STABLE_SWAP_PET:
        # npc: Guid
        npc = await read_int(reader, 8)

        # pet_slot: u32
        pet_slot = await read_int(reader, 4)

        return CMSG_STABLE_SWAP_PET(
            npc=npc,
            pet_slot=pet_slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0275))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.npc, self.pet_slot])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_QUEST_PUSH_RESULT:
    guid: int
    message: QuestPartyMessage

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_QUEST_PUSH_RESULT:
        # guid: Guid
        guid = await read_int(reader, 8)

        # message: QuestPartyMessage
        message = QuestPartyMessage(await read_int(reader, 1))

        return MSG_QUEST_PUSH_RESULT(
            guid=guid,
            message=message,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x0276))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.message.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x0276))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.message.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PLAY_MUSIC:
    sound_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAY_MUSIC:
        # sound_id: u32
        sound_id = await read_int(reader, 4)

        return SMSG_PLAY_MUSIC(
            sound_id=sound_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0277))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.sound_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PLAY_OBJECT_SOUND:
    sound_id: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAY_OBJECT_SOUND:
        # sound_id: u32
        sound_id = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_PLAY_OBJECT_SOUND(
            sound_id=sound_id,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0278))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.sound_id, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_REQUEST_PET_INFO:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REQUEST_PET_INFO:
        return CMSG_REQUEST_PET_INFO()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0279))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_FAR_SIGHT:
    operation: FarSightOperation

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FAR_SIGHT:
        # operation: FarSightOperation
        operation = FarSightOperation(await read_int(reader, 1))

        return CMSG_FAR_SIGHT(
            operation=operation,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x027A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.operation.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELLDISPELLOG:
    victim: int
    caster: int
    spells: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLDISPELLOG:
        # victim: PackedGuid
        victim = await read_packed_guid(reader)

        # caster: PackedGuid
        caster = await read_packed_guid(reader)

        # amount_of_spells: u32
        amount_of_spells = await read_int(reader, 4)

        # spells: Spell[amount_of_spells]
        spells = []
        for _ in range(0, amount_of_spells):
            spells.append(await read_int(reader, 4))

        return SMSG_SPELLDISPELLOG(
            victim=victim,
            caster=caster,
            spells=spells,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x027B))
        _fmt = "<4s"
        _data = [_data]

        # victim: PackedGuid
        _fmt, _data = packed_guid_write(self.victim, _fmt, _data)

        # caster: PackedGuid
        _fmt, _data = packed_guid_write(self.caster, _fmt, _data)

        # amount_of_spells: u32
        _fmt += 'I'
        _data.append(len(self.spells))

        # spells: Spell[amount_of_spells]
        _fmt += f'len({self.spells})I'
        _data.extend(self.spells)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.victim) + packed_guid_size(self.caster) + 4 * len(self.spells)


@dataclasses.dataclass
class CMSG_GROUP_CHANGE_SUB_GROUP:
    name: str
    group_number: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_CHANGE_SUB_GROUP:
        # name: CString
        name = await read_cstring(reader)

        # group_number: u8
        group_number = await read_int(reader, 1)

        return CMSG_GROUP_CHANGE_SUB_GROUP(
            name=name,
            group_number=group_number,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x027E))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sBB'
        _data.extend([self.name.encode('utf-8'), 0, self.group_number])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.name)


@dataclasses.dataclass
class CMSG_REQUEST_PARTY_MEMBER_STATS:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REQUEST_PARTY_MEMBER_STATS:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_REQUEST_PARTY_MEMBER_STATS(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x027F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_SWAP_SUB_GROUP:
    name: str
    swap_with_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_SWAP_SUB_GROUP:
        # name: CString
        name = await read_cstring(reader)

        # swap_with_name: CString
        swap_with_name = await read_cstring(reader)

        return CMSG_GROUP_SWAP_SUB_GROUP(
            name=name,
            swap_with_name=swap_with_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0280))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB{len(self.swap_with_name)}sB'
        _data.extend([self.name.encode('utf-8'), 0, self.swap_with_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 2 + len(self.name) + len(self.swap_with_name)


@dataclasses.dataclass
class CMSG_AUTOSTORE_BANK_ITEM:
    bag_index: int
    slot_index: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUTOSTORE_BANK_ITEM:
        # bag_index: u8
        bag_index = await read_int(reader, 1)

        # slot_index: u8
        slot_index = await read_int(reader, 1)

        return CMSG_AUTOSTORE_BANK_ITEM(
            bag_index=bag_index,
            slot_index=slot_index,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x0282))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.bag_index, self.slot_index])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AUTOBANK_ITEM:
    bag_index: int
    slot_index: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AUTOBANK_ITEM:
        # bag_index: u8
        bag_index = await read_int(reader, 1)

        # slot_index: u8
        slot_index = await read_int(reader, 1)

        return CMSG_AUTOBANK_ITEM(
            bag_index=bag_index,
            slot_index=slot_index,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x0283))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'BB'
        _data.extend([self.bag_index, self.slot_index])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_QUERY_NEXT_MAIL_TIME_Server:
    unread_mails: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_QUERY_NEXT_MAIL_TIME_Server:
        # unread_mails: f32
        unread_mails = await read_float(reader)

        return MSG_QUERY_NEXT_MAIL_TIME_Server(
            unread_mails=unread_mails,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0284))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'f'
        _data.append(self.unread_mails)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_QUERY_NEXT_MAIL_TIME_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_QUERY_NEXT_MAIL_TIME_Client:
        return MSG_QUERY_NEXT_MAIL_TIME_Client()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0284))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_RECEIVED_MAIL:
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RECEIVED_MAIL:
        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return SMSG_RECEIVED_MAIL(
            unknown1=unknown1,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0285))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.unknown1)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_RAID_GROUP_ONLY:
    homebind_timer: int
    error: RaidGroupError

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RAID_GROUP_ONLY:
        # homebind_timer: u32
        homebind_timer = await read_int(reader, 4)

        # error: RaidGroupError
        error = RaidGroupError(await read_int(reader, 4))

        return SMSG_RAID_GROUP_ONLY(
            homebind_timer=homebind_timer,
            error=error,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0286))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.homebind_timer, self.error.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PVP_CREDIT:
    honor_points: int
    victim: int
    rank: PvpRank

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PVP_CREDIT:
        # honor_points: u32
        honor_points = await read_int(reader, 4)

        # victim: Guid
        victim = await read_int(reader, 8)

        # rank: PvpRank
        rank = PvpRank(await read_int(reader, 4))

        return SMSG_PVP_CREDIT(
            honor_points=honor_points,
            victim=victim,
            rank=rank,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x028C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IQI'
        _data.extend([self.honor_points, self.victim, self.rank.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AUCTION_REMOVED_NOTIFICATION:
    item: int
    item_template: int
    random_property_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AUCTION_REMOVED_NOTIFICATION:
        # item: Item
        item = await read_int(reader, 4)

        # item_template: u32
        item_template = await read_int(reader, 4)

        # random_property_id: u32
        random_property_id = await read_int(reader, 4)

        return SMSG_AUCTION_REMOVED_NOTIFICATION(
            item=item,
            item_template=item_template,
            random_property_id=random_property_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x028D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'III'
        _data.extend([self.item, self.item_template, self.random_property_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_RAID_CONVERT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_RAID_CONVERT:
        return CMSG_GROUP_RAID_CONVERT()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x028E))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GROUP_ASSISTANT_LEADER:
    guid: int
    set_assistant: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GROUP_ASSISTANT_LEADER:
        # guid: Guid
        guid = await read_int(reader, 8)

        # set_assistant: Bool8
        set_assistant = await read_bool(reader, 1)

        return CMSG_GROUP_ASSISTANT_LEADER(
            guid=guid,
            set_assistant=set_assistant,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x028F))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QB'
        _data.extend([self.guid, self.set_assistant])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BUYBACK_ITEM:
    guid: int
    slot: BuybackSlot

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BUYBACK_ITEM:
        # guid: Guid
        guid = await read_int(reader, 8)

        # slot: BuybackSlot
        slot = BuybackSlot(await read_int(reader, 4))

        return CMSG_BUYBACK_ITEM(
            guid=guid,
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0290))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.slot.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SERVER_MESSAGE:
    message_type: ServerMessageType
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SERVER_MESSAGE:
        # message_type: ServerMessageType
        message_type = ServerMessageType(await read_int(reader, 4))

        # message: CString
        message = await read_cstring(reader)

        return SMSG_SERVER_MESSAGE(
            message_type=message_type,
            message=message,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0291))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.message)}sB'
        _data.extend([self.message_type.value, self.message.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + len(self.message)


@dataclasses.dataclass
class CMSG_MEETINGSTONE_JOIN:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MEETINGSTONE_JOIN:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_MEETINGSTONE_JOIN(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0292))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MEETINGSTONE_LEAVE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MEETINGSTONE_LEAVE:
        return CMSG_MEETINGSTONE_LEAVE()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0293))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MEETINGSTONE_SETQUEUE:
    area: Area
    status: MeetingStoneStatus

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MEETINGSTONE_SETQUEUE:
        # area: Area
        area = Area(await read_int(reader, 4))

        # status: MeetingStoneStatus
        status = MeetingStoneStatus(await read_int(reader, 1))

        return SMSG_MEETINGSTONE_SETQUEUE(
            area=area,
            status=status,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x0295))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([self.area.value, self.status.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MEETINGSTONE_INFO:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MEETINGSTONE_INFO:
        return CMSG_MEETINGSTONE_INFO()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0296))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MEETINGSTONE_COMPLETE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MEETINGSTONE_COMPLETE:
        return SMSG_MEETINGSTONE_COMPLETE()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0297))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MEETINGSTONE_IN_PROGRESS:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MEETINGSTONE_IN_PROGRESS:
        return SMSG_MEETINGSTONE_IN_PROGRESS()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0298))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MEETINGSTONE_MEMBER_ADDED:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MEETINGSTONE_MEMBER_ADDED:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_MEETINGSTONE_MEMBER_ADDED(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0299))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CANCEL_GROWTH_AURA:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CANCEL_GROWTH_AURA:
        return CMSG_CANCEL_GROWTH_AURA()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x029B))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CANCEL_AUTO_REPEAT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CANCEL_AUTO_REPEAT:
        return SMSG_CANCEL_AUTO_REPEAT()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x029C))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_STANDSTATE_UPDATE:
    state: UnitStandState

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_STANDSTATE_UPDATE:
        # state: UnitStandState
        state = UnitStandState(await read_int(reader, 1))

        return SMSG_STANDSTATE_UPDATE(
            state=state,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x029D))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.state.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_ALL_PASSED:
    looted_target: int
    loot_slot: int
    item: int
    item_random_property_id: int
    item_random_suffix_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_ALL_PASSED:
        # looted_target: Guid
        looted_target = await read_int(reader, 8)

        # loot_slot: u32
        loot_slot = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # item_random_suffix_id: u32
        item_random_suffix_id = await read_int(reader, 4)

        return SMSG_LOOT_ALL_PASSED(
            looted_target=looted_target,
            loot_slot=loot_slot,
            item=item,
            item_random_property_id=item_random_property_id,
            item_random_suffix_id=item_random_suffix_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(24 + 2, 0x029E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIIII'
        _data.extend([self.looted_target, self.loot_slot, self.item, self.item_random_property_id, self.item_random_suffix_id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_ROLL_WON:
    looted_target: int
    loot_slot: int
    item: int
    item_random_suffix: int
    item_random_property_id: int
    winning_player: int
    winning_roll: int
    vote: RollVote

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_ROLL_WON:
        # looted_target: Guid
        looted_target = await read_int(reader, 8)

        # loot_slot: u32
        loot_slot = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        # item_random_suffix: u32
        item_random_suffix = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # winning_player: Guid
        winning_player = await read_int(reader, 8)

        # winning_roll: u8
        winning_roll = await read_int(reader, 1)

        # vote: RollVote
        vote = RollVote(await read_int(reader, 1))

        return SMSG_LOOT_ROLL_WON(
            looted_target=looted_target,
            loot_slot=loot_slot,
            item=item,
            item_random_suffix=item_random_suffix,
            item_random_property_id=item_random_property_id,
            winning_player=winning_player,
            winning_roll=winning_roll,
            vote=vote,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(34 + 2, 0x029F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIIIIQBB'
        _data.extend([self.looted_target, self.loot_slot, self.item, self.item_random_suffix, self.item_random_property_id, self.winning_player, self.winning_roll, self.vote.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LOOT_ROLL:
    item: int
    item_slot: int
    vote: RollVote

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOOT_ROLL:
        # item: Guid
        item = await read_int(reader, 8)

        # item_slot: u32
        item_slot = await read_int(reader, 4)

        # vote: RollVote
        vote = RollVote(await read_int(reader, 1))

        return CMSG_LOOT_ROLL(
            item=item,
            item_slot=item_slot,
            vote=vote,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(13 + 4, 0x02A0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIB'
        _data.extend([self.item, self.item_slot, self.vote.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_START_ROLL:
    creature: int
    loot_slot: int
    item: int
    item_random_suffix: int
    item_random_property_id: int
    countdown_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_START_ROLL:
        # creature: Guid
        creature = await read_int(reader, 8)

        # loot_slot: u32
        loot_slot = await read_int(reader, 4)

        # item: Item
        item = await read_int(reader, 4)

        # item_random_suffix: u32
        item_random_suffix = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # countdown_time: Milliseconds
        countdown_time = await read_int(reader, 4)

        return SMSG_LOOT_START_ROLL(
            creature=creature,
            loot_slot=loot_slot,
            item=item,
            item_random_suffix=item_random_suffix,
            item_random_property_id=item_random_property_id,
            countdown_time=countdown_time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(28 + 2, 0x02A1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIIIII'
        _data.extend([self.creature, self.loot_slot, self.item, self.item_random_suffix, self.item_random_property_id, self.countdown_time])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_ROLL:
    creature: int
    loot_slot: int
    player: int
    item: int
    item_random_suffix: int
    item_random_property_id: int
    roll_number: int
    vote: RollVote

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_ROLL:
        # creature: Guid
        creature = await read_int(reader, 8)

        # loot_slot: u32
        loot_slot = await read_int(reader, 4)

        # player: Guid
        player = await read_int(reader, 8)

        # item: Item
        item = await read_int(reader, 4)

        # item_random_suffix: u32
        item_random_suffix = await read_int(reader, 4)

        # item_random_property_id: u32
        item_random_property_id = await read_int(reader, 4)

        # roll_number: u8
        roll_number = await read_int(reader, 1)

        # vote: RollVote
        vote = RollVote(await read_int(reader, 1))

        return SMSG_LOOT_ROLL(
            creature=creature,
            loot_slot=loot_slot,
            player=player,
            item=item,
            item_random_suffix=item_random_suffix,
            item_random_property_id=item_random_property_id,
            roll_number=roll_number,
            vote=vote,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(34 + 2, 0x02A2))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QIQIIIBB'
        _data.extend([self.creature, self.loot_slot, self.player, self.item, self.item_random_suffix, self.item_random_property_id, self.roll_number, self.vote.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_LOOT_MASTER_GIVE:
    loot: int
    slot_id: int
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LOOT_MASTER_GIVE:
        # loot: Guid
        loot = await read_int(reader, 8)

        # slot_id: u8
        slot_id = await read_int(reader, 1)

        # player: Guid
        player = await read_int(reader, 8)

        return CMSG_LOOT_MASTER_GIVE(
            loot=loot,
            slot_id=slot_id,
            player=player,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(17 + 4, 0x02A3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QBQ'
        _data.extend([self.loot, self.slot_id, self.player])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_LOOT_MASTER_LIST:
    guids: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_LOOT_MASTER_LIST:
        # amount_of_players: u8
        amount_of_players = await read_int(reader, 1)

        # guids: Guid[amount_of_players]
        guids = []
        for _ in range(0, amount_of_players):
            guids.append(await read_int(reader, 8))

        return SMSG_LOOT_MASTER_LIST(
            guids=guids,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02A4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'B{len(self.guids)}Q'
        _data.extend([len(self.guids), *self.guids])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + 8 * len(self.guids)


@dataclasses.dataclass
class SMSG_SET_FORCED_REACTIONS:
    reactions: typing.List[ForcedReaction]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SET_FORCED_REACTIONS:
        # amount_of_reactions: u32
        amount_of_reactions = await read_int(reader, 4)

        # reactions: ForcedReaction[amount_of_reactions]
        reactions = []
        for _ in range(0, amount_of_reactions):
            reactions.append(await ForcedReaction.read(reader))

        return SMSG_SET_FORCED_REACTIONS(
            reactions=reactions,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02A5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.reactions))
        # reactions: ForcedReaction[amount_of_reactions]
        for i in self.reactions:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + 6 * len(self.reactions)


@dataclasses.dataclass
class SMSG_SPELL_FAILED_OTHER:
    caster: int
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELL_FAILED_OTHER:
        # caster: Guid
        caster = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        return SMSG_SPELL_FAILED_OTHER(
            caster=caster,
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x02A6))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.caster, self.id])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GAMEOBJECT_RESET_STATE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GAMEOBJECT_RESET_STATE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_GAMEOBJECT_RESET_STATE(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x02A7))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_REPAIR_ITEM:
    npc: int
    item: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REPAIR_ITEM:
        # npc: Guid
        npc = await read_int(reader, 8)

        # item: Guid
        item = await read_int(reader, 8)

        return CMSG_REPAIR_ITEM(
            npc=npc,
            item=item,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x02A8))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QQ'
        _data.extend([self.npc, self.item])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_CHAT_PLAYER_NOT_FOUND:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAT_PLAYER_NOT_FOUND:
        # name: CString
        name = await read_cstring(reader)

        return SMSG_CHAT_PLAYER_NOT_FOUND(
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02A9))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.name)}sB'
        _data.extend([self.name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.name)


@dataclasses.dataclass
class MSG_TALENT_WIPE_CONFIRM_Client:
    wiping_npc: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_TALENT_WIPE_CONFIRM_Client:
        # wiping_npc: Guid
        wiping_npc = await read_int(reader, 8)

        return MSG_TALENT_WIPE_CONFIRM_Client(
            wiping_npc=wiping_npc,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02AA))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.wiping_npc)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_TALENT_WIPE_CONFIRM_Server:
    wiping_npc: int
    cost_in_copper: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_TALENT_WIPE_CONFIRM_Server:
        # wiping_npc: Guid
        wiping_npc = await read_int(reader, 8)

        # cost_in_copper: u32
        cost_in_copper = await read_int(reader, 4)

        return MSG_TALENT_WIPE_CONFIRM_Server(
            wiping_npc=wiping_npc,
            cost_in_copper=cost_in_copper,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x02AA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.wiping_npc, self.cost_in_copper])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SUMMON_REQUEST:
    summoner: int
    area: Area
    auto_decline_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SUMMON_REQUEST:
        # summoner: Guid
        summoner = await read_int(reader, 8)

        # area: Area
        area = Area(await read_int(reader, 4))

        # auto_decline_time: Milliseconds
        auto_decline_time = await read_int(reader, 4)

        return SMSG_SUMMON_REQUEST(
            summoner=summoner,
            area=area,
            auto_decline_time=auto_decline_time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x02AB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QII'
        _data.extend([self.summoner, self.area.value, self.auto_decline_time])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SUMMON_RESPONSE:
    summoner: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SUMMON_RESPONSE:
        # summoner: Guid
        summoner = await read_int(reader, 8)

        return CMSG_SUMMON_RESPONSE(
            summoner=summoner,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02AC))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.summoner)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MONSTER_MOVE_TRANSPORT:
    guid: int
    transport: int
    spline_point: Vector3d
    spline_id: int
    move_type: MonsterMoveType
    spline_flags: SplineFlag
    duration: int
    splines: MonsterMoveSpline
    target: typing.Optional[int] = None
    angle: typing.Optional[float] = None
    position: typing.Optional[Vector3d] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MONSTER_MOVE_TRANSPORT:
        target = None
        angle = None
        position = None
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # transport: PackedGuid
        transport = await read_packed_guid(reader)

        # spline_point: Vector3d
        spline_point = await Vector3d.read(reader)

        # spline_id: u32
        spline_id = await read_int(reader, 4)

        # move_type: MonsterMoveType
        move_type = MonsterMoveType(await read_int(reader, 1))

        if move_type == MonsterMoveType.FACING_TARGET:
            # target: Guid
            target = await read_int(reader, 8)

        elif move_type == MonsterMoveType.FACING_ANGLE:
            # angle: f32
            angle = await read_float(reader)

        elif move_type == MonsterMoveType.FACING_SPOT:
            # position: Vector3d
            position = await Vector3d.read(reader)

        # spline_flags: SplineFlag
        spline_flags = SplineFlag(await read_int(reader, 4))

        # duration: u32
        duration = await read_int(reader, 4)

        # splines: MonsterMoveSpline
        splines = await MonsterMoveSpline.read(reader)

        return SMSG_MONSTER_MOVE_TRANSPORT(
            guid=guid,
            transport=transport,
            spline_point=spline_point,
            spline_id=spline_id,
            move_type=move_type,
            target=target,
            angle=angle,
            position=position,
            spline_flags=spline_flags,
            duration=duration,
            splines=splines,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02AE))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # transport: PackedGuid
        _fmt, _data = packed_guid_write(self.transport, _fmt, _data)

        # spline_point: Vector3d
        _fmt, _data = self.spline_point.write(_fmt, _data)

        # spline_id: u32
        _fmt += 'I'
        _data.append(self.spline_id)

        # move_type: MonsterMoveType
        _fmt += 'B'
        _data.append(self.move_type.value)

        if self.move_type == MonsterMoveType.FACING_TARGET:
            _fmt += 'Q'
            _data.append(self.target)
        elif self.move_type == MonsterMoveType.FACING_ANGLE:
            _fmt += 'f'
            _data.append(self.angle)
        elif self.move_type == MonsterMoveType.FACING_SPOT:
            # position: Vector3d
            _fmt, _data = self.position.write(_fmt, _data)

        # spline_flags: SplineFlag
        _fmt += 'I'
        _data.append(self.spline_flags.value)

        # duration: u32
        _fmt += 'I'
        _data.append(self.duration)

        # splines: MonsterMoveSpline
        _fmt, _data = self.splines.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 25 + packed_guid_size(self.guid) + packed_guid_size(self.transport) + self.splines.size()

        if self.move_type == MonsterMoveType.FACING_TARGET:
            _size += 8
        elif self.move_type == MonsterMoveType.FACING_ANGLE:
            _size += 4
        elif self.move_type == MonsterMoveType.FACING_SPOT:
            _size += 12

        return _size


@dataclasses.dataclass
class SMSG_PET_BROKEN:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_BROKEN:
        return SMSG_PET_BROKEN()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x02AF))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MOVE_FEATHER_FALL_Server:
    player: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_FEATHER_FALL_Server:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_FEATHER_FALL_Server(
            player=player,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02B0))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class MSG_MOVE_WATER_WALK:
    player: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_WATER_WALK:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return MSG_MOVE_WATER_WALK(
            player=player,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02B1))
        _fmt = "<6s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02B1))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.player) + self.info.size()


@dataclasses.dataclass
class CMSG_SELF_RES:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SELF_RES:
        return CMSG_SELF_RES()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02B3))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_FEIGN_DEATH_RESISTED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FEIGN_DEATH_RESISTED:
        return SMSG_FEIGN_DEATH_RESISTED()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x02B4))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DUEL_COUNTDOWN:
    time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DUEL_COUNTDOWN:
        # time: Seconds
        time = await read_int(reader, 4)

        return SMSG_DUEL_COUNTDOWN(
            time=time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x02B7))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.time)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AREA_TRIGGER_MESSAGE:
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AREA_TRIGGER_MESSAGE:
        # message: SizedCString
        message = await read_sized_cstring(reader)

        return SMSG_AREA_TRIGGER_MESSAGE(
            message=message,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02B8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.message)}sB'
        _data.extend([len(self.message) + 1, self.message.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + len(self.message)


@dataclasses.dataclass
class CMSG_TOGGLE_HELM:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TOGGLE_HELM:
        return CMSG_TOGGLE_HELM()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02B9))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_TOGGLE_CLOAK:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_TOGGLE_CLOAK:
        return CMSG_TOGGLE_CLOAK()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02BA))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_MEETINGSTONE_JOINFAILED:
    reason: MeetingStoneFailure

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_MEETINGSTONE_JOINFAILED:
        # reason: MeetingStoneFailure
        reason = MeetingStoneFailure(await read_int(reader, 1))

        return SMSG_MEETINGSTONE_JOINFAILED(
            reason=reason,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x02BB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.reason.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PLAYER_SKINNED:
    spirit_released: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAYER_SKINNED:
        # spirit_released: Bool8
        spirit_released = await read_bool(reader, 1)

        return SMSG_PLAYER_SKINNED(
            spirit_released=spirit_released,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x02BC))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.spirit_released)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_DURABILITY_DAMAGE_DEATH:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DURABILITY_DAMAGE_DEATH:
        return SMSG_DURABILITY_DAMAGE_DEATH()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x02BD))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_ACTIONBAR_TOGGLES:
    action_bar: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_ACTIONBAR_TOGGLES:
        # action_bar: u8
        action_bar = await read_int(reader, 1)

        return CMSG_SET_ACTIONBAR_TOGGLES(
            action_bar=action_bar,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x02BF))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.action_bar)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_PETITION_RENAME:
    petition: int
    new_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_PETITION_RENAME:
        # petition: Guid
        petition = await read_int(reader, 8)

        # new_name: CString
        new_name = await read_cstring(reader)

        return MSG_PETITION_RENAME(
            petition=petition,
            new_name=new_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02C1))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.new_name)}sB'
        _data.extend([self.petition, self.new_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02C1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'Q{len(self.new_name)}sB'
        _data.extend([self.petition, self.new_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.new_name)


@dataclasses.dataclass
class SMSG_INIT_WORLD_STATES:
    map: Map
    area: Area
    states: typing.List[WorldState]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INIT_WORLD_STATES:
        # map: Map
        map = Map(await read_int(reader, 4))

        # area: Area
        area = Area(await read_int(reader, 4))

        # amount_of_states: u16
        amount_of_states = await read_int(reader, 2)

        # states: WorldState[amount_of_states]
        states = []
        for _ in range(0, amount_of_states):
            states.append(await WorldState.read(reader))

        return SMSG_INIT_WORLD_STATES(
            map=map,
            area=area,
            states=states,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02C2))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IIH'
        _data.extend([self.map.value, self.area.value, len(self.states)])
        # states: WorldState[amount_of_states]
        for i in self.states:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 10 + 8 * len(self.states)


@dataclasses.dataclass
class SMSG_UPDATE_WORLD_STATE:
    state: WorldState

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_UPDATE_WORLD_STATE:
        # state: WorldState
        state = await WorldState.read(reader)

        return SMSG_UPDATE_WORLD_STATE(
            state=state,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x02C3))
        _fmt = "<4s"
        _data = [_data]

        # state: WorldState
        _fmt, _data = self.state.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_ITEM_NAME_QUERY:
    item: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ITEM_NAME_QUERY:
        # item: Item
        item = await read_int(reader, 4)

        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_ITEM_NAME_QUERY(
            item=item,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x02C4))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IQ'
        _data.extend([self.item, self.guid])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ITEM_NAME_QUERY_RESPONSE:
    item: int
    item_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ITEM_NAME_QUERY_RESPONSE:
        # item: Item
        item = await read_int(reader, 4)

        # item_name: CString
        item_name = await read_cstring(reader)

        return SMSG_ITEM_NAME_QUERY_RESPONSE(
            item=item,
            item_name=item_name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02C5))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'I{len(self.item_name)}sB'
        _data.extend([self.item, self.item_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + len(self.item_name)


@dataclasses.dataclass
class SMSG_PET_ACTION_FEEDBACK:
    feedback: PetFeedback

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_ACTION_FEEDBACK:
        # feedback: PetFeedback
        feedback = PetFeedback(await read_int(reader, 1))

        return SMSG_PET_ACTION_FEEDBACK(
            feedback=feedback,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x02C6))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.feedback.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_CHAR_RENAME:
    character: int
    new_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_CHAR_RENAME:
        # character: Guid
        character = await read_int(reader, 8)

        # new_name: CString
        new_name = await read_cstring(reader)

        return CMSG_CHAR_RENAME(
            character=character,
            new_name=new_name,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02C7))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'Q{len(self.new_name)}sB'
        _data.extend([self.character, self.new_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.new_name)


@dataclasses.dataclass
class SMSG_CHAR_RENAME:
    result: WorldResult
    character: typing.Optional[int] = None
    new_name: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAR_RENAME:
        character = None
        new_name = None
        # result: WorldResult
        result = WorldResult(await read_int(reader, 1))

        if result == WorldResult.RESPONSE_SUCCESS:
            # character: Guid
            character = await read_int(reader, 8)

            # new_name: CString
            new_name = await read_cstring(reader)

        return SMSG_CHAR_RENAME(
            result=result,
            character=character,
            new_name=new_name,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02C8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.result.value)
        if self.result == WorldResult.RESPONSE_SUCCESS:
            _fmt += f'Q{len(self.new_name)}sB'
            _data.extend([self.character, self.new_name.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.result == WorldResult.RESPONSE_SUCCESS:
            _size += 9 + len(self.new_name)

        return _size


@dataclasses.dataclass
class CMSG_MOVE_SPLINE_DONE:
    info: MovementInfo
    movement_counter: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_SPLINE_DONE:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # unknown1: u32
        unknown1 = await read_int(reader, 4)

        return CMSG_MOVE_SPLINE_DONE(
            info=info,
            movement_counter=movement_counter,
            unknown1=unknown1,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02C9))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # movement_counter: u32
        _fmt += 'I'
        _data.append(self.movement_counter)

        # unknown1: u32
        _fmt += 'I'
        _data.append(self.unknown1)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + self.info.size()


@dataclasses.dataclass
class CMSG_MOVE_FALL_RESET:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_FALL_RESET:
        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return CMSG_MOVE_FALL_RESET(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02CA))
        _fmt = "<6s"
        _data = [_data]

        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + self.info.size()


@dataclasses.dataclass
class SMSG_INSTANCE_SAVE_CREATED:
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INSTANCE_SAVE_CREATED:
        # unknown: u32
        unknown = await read_int(reader, 4)

        return SMSG_INSTANCE_SAVE_CREATED(
            unknown=unknown,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x02CB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.unknown)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_RAID_INSTANCE_INFO:
    raid_infos: typing.List[RaidInfo]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RAID_INSTANCE_INFO:
        # amount_of_raid_infos: u32
        amount_of_raid_infos = await read_int(reader, 4)

        # raid_infos: RaidInfo[amount_of_raid_infos]
        raid_infos = []
        for _ in range(0, amount_of_raid_infos):
            raid_infos.append(await RaidInfo.read(reader))

        return SMSG_RAID_INSTANCE_INFO(
            raid_infos=raid_infos,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02CC))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.raid_infos))
        # raid_infos: RaidInfo[amount_of_raid_infos]
        for i in self.raid_infos:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + 12 * len(self.raid_infos)


@dataclasses.dataclass
class CMSG_REQUEST_RAID_INFO:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_REQUEST_RAID_INFO:
        return CMSG_REQUEST_RAID_INFO()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02CD))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MOVE_TIME_SKIPPED:
    guid: int
    lag: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_TIME_SKIPPED:
        # guid: Guid
        guid = await read_int(reader, 8)

        # lag: u32
        lag = await read_int(reader, 4)

        return CMSG_MOVE_TIME_SKIPPED(
            guid=guid,
            lag=lag,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x02CE))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.lag])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_MOVE_FEATHER_FALL_ACK:
    guid: int
    movement_counter: int
    info: MovementInfo
    apply: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_FEATHER_FALL_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # apply: u32
        apply = await read_int(reader, 4)

        return CMSG_MOVE_FEATHER_FALL_ACK(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
            apply=apply,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02CF))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.movement_counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # apply: u32
        _fmt += 'I'
        _data.append(self.apply)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class CMSG_MOVE_WATER_WALK_ACK:
    guid: int
    movement_counter: int
    info: MovementInfo
    apply: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_WATER_WALK_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # movement_counter: u32
        movement_counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # apply: u32
        apply = await read_int(reader, 4)

        return CMSG_MOVE_WATER_WALK_ACK(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
            apply=apply,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02D0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.movement_counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # apply: u32
        _fmt += 'I'
        _data.append(self.apply)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class CMSG_MOVE_NOT_ACTIVE_MOVER:
    old_mover: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_MOVE_NOT_ACTIVE_MOVER:
        # old_mover: Guid
        old_mover = await read_int(reader, 8)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        return CMSG_MOVE_NOT_ACTIVE_MOVER(
            old_mover=old_mover,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02D1))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.old_mover)
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + self.info.size()


@dataclasses.dataclass
class SMSG_PLAY_SOUND:
    sound_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PLAY_SOUND:
        # sound_id: u32
        sound_id = await read_int(reader, 4)

        return SMSG_PLAY_SOUND(
            sound_id=sound_id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x02D2))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.sound_id)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BATTLEFIELD_STATUS:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BATTLEFIELD_STATUS:
        return CMSG_BATTLEFIELD_STATUS()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02D3))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BATTLEFIELD_STATUS:
    queue_slot: int
    map: Map
    bracket: typing.Optional[BattlegroundBracket] = None
    client_instance_id: typing.Optional[int] = None
    status_id: typing.Optional[StatusId] = None
    average_wait_time_in_ms: typing.Optional[int] = None
    time_in_queue_in_ms: typing.Optional[int] = None
    time_to_remove_in_queue_in_ms: typing.Optional[int] = None
    time_to_bg_autoleave_in_ms: typing.Optional[int] = None
    time_to_bg_start_in_ms: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BATTLEFIELD_STATUS:
        bracket = None
        client_instance_id = None
        status_id = None
        average_wait_time_in_ms = None
        time_in_queue_in_ms = None
        time_to_remove_in_queue_in_ms = None
        time_to_bg_autoleave_in_ms = None
        time_to_bg_start_in_ms = None
        # queue_slot: u32
        queue_slot = await read_int(reader, 4)

        # map: Map
        map = Map(await read_int(reader, 4))

        if map in {Map.KALIMDOR, Map.TESTING, Map.SCOTT_TEST, Map.CASH_TEST, Map.ALTERAC_VALLEY, Map.SHADOWFANG_KEEP, Map.STORMWIND_STOCKADE, Map.STORMWIND_PRISON, Map.DEADMINES, Map.AZSHARA_CRATER, Map.COLLINS_TEST, Map.WAILING_CAVERNS, Map.MONASTERY_UNUSED, Map.RAZORFEN_KRAUL, Map.BLACKFATHOM_DEEPS, Map.ULDAMAN, Map.GNOMEREGAN, Map.SUNKEN_TEMPLE, Map.RAZORFEN_DOWNS, Map.EMERALD_DREAM, Map.SCARLET_MONASTERY, Map.ZUL_FARRAK, Map.BLACKROCK_SPIRE, Map.BLACKROCK_DEPTHS, Map.ONYXIAS_LAIR, Map.OPENING_OF_THE_DARK_PORTAL, Map.SCHOLOMANCE, Map.ZUL_GURUB, Map.STRATHOLME, Map.MARAUDON, Map.DEEPRUN_TRAM, Map.RAGEFIRE_CHASM, Map.MOLTEN_CORE, Map.DIRE_MAUL, Map.ALLIANCE_PVP_BARRACKS, Map.HORDE_PVP_BARRACKS, Map.DEVELOPMENT_LAND, Map.BLACKWING_LAIR, Map.WARSONG_GULCH, Map.RUINS_OF_AHN_QIRAJ, Map.ARATHI_BASIN, Map.AHN_QIRAJ_TEMPLE, Map.NAXXRAMAS}:
            # bracket: BattlegroundBracket
            bracket = BattlegroundBracket(await read_int(reader, 1))

            # client_instance_id: u32
            client_instance_id = await read_int(reader, 4)

            # status_id: StatusId
            status_id = StatusId(await read_int(reader, 1))

            if status_id == StatusId.WAIT_QUEUE:
                # average_wait_time_in_ms: u32
                average_wait_time_in_ms = await read_int(reader, 4)

                # time_in_queue_in_ms: u32
                time_in_queue_in_ms = await read_int(reader, 4)

            elif status_id == StatusId.WAIT_JOIN:
                # time_to_remove_in_queue_in_ms: u32
                time_to_remove_in_queue_in_ms = await read_int(reader, 4)

            elif status_id == StatusId.IN_PROGRESS:
                # time_to_bg_autoleave_in_ms: u32
                time_to_bg_autoleave_in_ms = await read_int(reader, 4)

                # time_to_bg_start_in_ms: u32
                time_to_bg_start_in_ms = await read_int(reader, 4)

        return SMSG_BATTLEFIELD_STATUS(
            queue_slot=queue_slot,
            map=map,
            bracket=bracket,
            client_instance_id=client_instance_id,
            status_id=status_id,
            average_wait_time_in_ms=average_wait_time_in_ms,
            time_in_queue_in_ms=time_in_queue_in_ms,
            time_to_remove_in_queue_in_ms=time_to_remove_in_queue_in_ms,
            time_to_bg_autoleave_in_ms=time_to_bg_autoleave_in_ms,
            time_to_bg_start_in_ms=time_to_bg_start_in_ms,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02D4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.queue_slot, self.map.value])
        if self.map in {Map.KALIMDOR, Map.TESTING, Map.SCOTT_TEST, Map.CASH_TEST, Map.ALTERAC_VALLEY, Map.SHADOWFANG_KEEP, Map.STORMWIND_STOCKADE, Map.STORMWIND_PRISON, Map.DEADMINES, Map.AZSHARA_CRATER, Map.COLLINS_TEST, Map.WAILING_CAVERNS, Map.MONASTERY_UNUSED, Map.RAZORFEN_KRAUL, Map.BLACKFATHOM_DEEPS, Map.ULDAMAN, Map.GNOMEREGAN, Map.SUNKEN_TEMPLE, Map.RAZORFEN_DOWNS, Map.EMERALD_DREAM, Map.SCARLET_MONASTERY, Map.ZUL_FARRAK, Map.BLACKROCK_SPIRE, Map.BLACKROCK_DEPTHS, Map.ONYXIAS_LAIR, Map.OPENING_OF_THE_DARK_PORTAL, Map.SCHOLOMANCE, Map.ZUL_GURUB, Map.STRATHOLME, Map.MARAUDON, Map.DEEPRUN_TRAM, Map.RAGEFIRE_CHASM, Map.MOLTEN_CORE, Map.DIRE_MAUL, Map.ALLIANCE_PVP_BARRACKS, Map.HORDE_PVP_BARRACKS, Map.DEVELOPMENT_LAND, Map.BLACKWING_LAIR, Map.WARSONG_GULCH, Map.RUINS_OF_AHN_QIRAJ, Map.ARATHI_BASIN, Map.AHN_QIRAJ_TEMPLE, Map.NAXXRAMAS}:
            _fmt += 'BIB'
            _data.extend([self.bracket.value, self.client_instance_id, self.status_id.value])
            if self.status_id == StatusId.WAIT_QUEUE:
                _fmt += 'II'
                _data.extend([self.average_wait_time_in_ms, self.time_in_queue_in_ms])
            elif self.status_id == StatusId.WAIT_JOIN:
                _fmt += 'I'
                _data.append(self.time_to_remove_in_queue_in_ms)
            elif self.status_id == StatusId.IN_PROGRESS:
                _fmt += 'II'
                _data.extend([self.time_to_bg_autoleave_in_ms, self.time_to_bg_start_in_ms])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 8

        if self.map in {Map.KALIMDOR, Map.TESTING, Map.SCOTT_TEST, Map.CASH_TEST, Map.ALTERAC_VALLEY, Map.SHADOWFANG_KEEP, Map.STORMWIND_STOCKADE, Map.STORMWIND_PRISON, Map.DEADMINES, Map.AZSHARA_CRATER, Map.COLLINS_TEST, Map.WAILING_CAVERNS, Map.MONASTERY_UNUSED, Map.RAZORFEN_KRAUL, Map.BLACKFATHOM_DEEPS, Map.ULDAMAN, Map.GNOMEREGAN, Map.SUNKEN_TEMPLE, Map.RAZORFEN_DOWNS, Map.EMERALD_DREAM, Map.SCARLET_MONASTERY, Map.ZUL_FARRAK, Map.BLACKROCK_SPIRE, Map.BLACKROCK_DEPTHS, Map.ONYXIAS_LAIR, Map.OPENING_OF_THE_DARK_PORTAL, Map.SCHOLOMANCE, Map.ZUL_GURUB, Map.STRATHOLME, Map.MARAUDON, Map.DEEPRUN_TRAM, Map.RAGEFIRE_CHASM, Map.MOLTEN_CORE, Map.DIRE_MAUL, Map.ALLIANCE_PVP_BARRACKS, Map.HORDE_PVP_BARRACKS, Map.DEVELOPMENT_LAND, Map.BLACKWING_LAIR, Map.WARSONG_GULCH, Map.RUINS_OF_AHN_QIRAJ, Map.ARATHI_BASIN, Map.AHN_QIRAJ_TEMPLE, Map.NAXXRAMAS}:
            _size += 6

            if self.status_id == StatusId.WAIT_QUEUE:
                _size += 8
            elif self.status_id == StatusId.WAIT_JOIN:
                _size += 4
            elif self.status_id == StatusId.IN_PROGRESS:
                _size += 8


        return _size


@dataclasses.dataclass
class CMSG_BATTLEFIELD_PORT:
    map: Map
    action: BattlefieldPortAction

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BATTLEFIELD_PORT:
        # map: Map
        map = Map(await read_int(reader, 4))

        # action: BattlefieldPortAction
        action = BattlefieldPortAction(await read_int(reader, 1))

        return CMSG_BATTLEFIELD_PORT(
            map=map,
            action=action,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(5 + 4, 0x02D5))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'IB'
        _data.extend([self.map.value, self.action.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_INSPECT_HONOR_STATS_Client:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_INSPECT_HONOR_STATS_Client:
        # guid: Guid
        guid = await read_int(reader, 8)

        return MSG_INSPECT_HONOR_STATS_Client(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02D6))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_INSPECT_HONOR_STATS_Server:
    guid: int
    highest_rank: PvpRank
    today_honorable_and_dishonorable: int
    yesterday_honorable: int
    unknown1: int
    last_week_honorable: int
    unknown2: int
    this_week_honorable: int
    unknown3: int
    lifetime_honorable: int
    lifetime_dishonorable: int
    yesterday_honor: int
    last_week_honor: int
    this_week_honor: int
    last_week_standing: PvpRank
    rank_progress_bar: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_INSPECT_HONOR_STATS_Server:
        # guid: Guid
        guid = await read_int(reader, 8)

        # highest_rank: PvpRank
        highest_rank = PvpRank(await read_int(reader, 1))

        # today_honorable_and_dishonorable: u32
        today_honorable_and_dishonorable = await read_int(reader, 4)

        # yesterday_honorable: u16
        yesterday_honorable = await read_int(reader, 2)

        # unknown1: u16
        unknown1 = await read_int(reader, 2)

        # last_week_honorable: u16
        last_week_honorable = await read_int(reader, 2)

        # unknown2: u16
        unknown2 = await read_int(reader, 2)

        # this_week_honorable: u16
        this_week_honorable = await read_int(reader, 2)

        # unknown3: u16
        unknown3 = await read_int(reader, 2)

        # lifetime_honorable: u32
        lifetime_honorable = await read_int(reader, 4)

        # lifetime_dishonorable: u32
        lifetime_dishonorable = await read_int(reader, 4)

        # yesterday_honor: u32
        yesterday_honor = await read_int(reader, 4)

        # last_week_honor: u32
        last_week_honor = await read_int(reader, 4)

        # this_week_honor: u32
        this_week_honor = await read_int(reader, 4)

        # last_week_standing: PvpRank
        last_week_standing = PvpRank(await read_int(reader, 4))

        # rank_progress_bar: u8
        rank_progress_bar = await read_int(reader, 1)

        return MSG_INSPECT_HONOR_STATS_Server(
            guid=guid,
            highest_rank=highest_rank,
            today_honorable_and_dishonorable=today_honorable_and_dishonorable,
            yesterday_honorable=yesterday_honorable,
            unknown1=unknown1,
            last_week_honorable=last_week_honorable,
            unknown2=unknown2,
            this_week_honorable=this_week_honorable,
            unknown3=unknown3,
            lifetime_honorable=lifetime_honorable,
            lifetime_dishonorable=lifetime_dishonorable,
            yesterday_honor=yesterday_honor,
            last_week_honor=last_week_honor,
            this_week_honor=this_week_honor,
            last_week_standing=last_week_standing,
            rank_progress_bar=rank_progress_bar,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(50 + 2, 0x02D6))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QBIHHHHHHIIIIIIB'
        _data.extend([self.guid, self.highest_rank.value, self.today_honorable_and_dishonorable, self.yesterday_honorable, self.unknown1, self.last_week_honorable, self.unknown2, self.this_week_honorable, self.unknown3, self.lifetime_honorable, self.lifetime_dishonorable, self.yesterday_honor, self.last_week_honor, self.this_week_honor, self.last_week_standing.value, self.rank_progress_bar])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BATTLEMASTER_HELLO:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BATTLEMASTER_HELLO:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_BATTLEMASTER_HELLO(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02D7))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_FORCE_WALK_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_WALK_SPEED_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_WALK_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02DA))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_WALK_SPEED_CHANGE_ACK:
    guid: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_WALK_SPEED_CHANGE_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_WALK_SPEED_CHANGE_ACK(
            guid=guid,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02DB))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_SWIM_BACK_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_SWIM_BACK_SPEED_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_SWIM_BACK_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02DC))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK:
    guid: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK(
            guid=guid,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02DD))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class SMSG_FORCE_TURN_RATE_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_FORCE_TURN_RATE_CHANGE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # move_event: u32
        move_event = await read_int(reader, 4)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_FORCE_TURN_RATE_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02DE))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # move_event: u32
        _fmt += 'I'
        _data.append(self.move_event)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_TURN_RATE_CHANGE_ACK:
    guid: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_FORCE_TURN_RATE_CHANGE_ACK:
        # guid: Guid
        guid = await read_int(reader, 8)

        # counter: u32
        counter = await read_int(reader, 4)

        # info: MovementInfo
        info = await MovementInfo.read(reader)

        # new_speed: f32
        new_speed = await read_float(reader)

        return CMSG_FORCE_TURN_RATE_CHANGE_ACK(
            guid=guid,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02DF))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.counter])
        # info: MovementInfo
        _fmt, _data = self.info.write(_fmt, _data)

        # new_speed: f32
        _fmt += 'f'
        _data.append(self.new_speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + self.info.size()


@dataclasses.dataclass
class MSG_PVP_LOG_DATA_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_PVP_LOG_DATA_Client:
        return MSG_PVP_LOG_DATA_Client()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02E0))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_PVP_LOG_DATA_Server:
    status: BattlegroundEndStatus
    players: typing.List[BattlegroundPlayer]
    winner: typing.Optional[BattlegroundWinner] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_PVP_LOG_DATA_Server:
        winner = None
        # status: BattlegroundEndStatus
        status = BattlegroundEndStatus(await read_int(reader, 1))

        if status == BattlegroundEndStatus.ENDED:
            # winner: BattlegroundWinner
            winner = BattlegroundWinner(await read_int(reader, 1))

        # amount_of_players: u32
        amount_of_players = await read_int(reader, 4)

        # players: BattlegroundPlayer[amount_of_players]
        players = []
        for _ in range(0, amount_of_players):
            players.append(await BattlegroundPlayer.read(reader))

        return MSG_PVP_LOG_DATA_Server(
            status=status,
            winner=winner,
            players=players,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02E0))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.status.value)
        if self.status == BattlegroundEndStatus.ENDED:
            _fmt += 'B'
            _data.append(self.winner.value)
        # amount_of_players: u32
        _fmt += 'I'
        _data.append(len(self.players))

        # players: BattlegroundPlayer[amount_of_players]
        for i in self.players:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 5 + sum([i.size() for i in self.players])

        if self.status == BattlegroundEndStatus.ENDED:
            _size += 1

        return _size


@dataclasses.dataclass
class CMSG_LEAVE_BATTLEFIELD:
    map: Map

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_LEAVE_BATTLEFIELD:
        # map: Map
        map = Map(await read_int(reader, 4))

        return CMSG_LEAVE_BATTLEFIELD(
            map=map,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x02E1))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AREA_SPIRIT_HEALER_QUERY:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AREA_SPIRIT_HEALER_QUERY:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_AREA_SPIRIT_HEALER_QUERY(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02E2))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_AREA_SPIRIT_HEALER_QUEUE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_AREA_SPIRIT_HEALER_QUEUE:
        # guid: Guid
        guid = await read_int(reader, 8)

        return CMSG_AREA_SPIRIT_HEALER_QUEUE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02E3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_AREA_SPIRIT_HEALER_TIME:
    guid: int
    next_resurrect_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_AREA_SPIRIT_HEALER_TIME:
        # guid: Guid
        guid = await read_int(reader, 8)

        # next_resurrect_time: u32
        next_resurrect_time = await read_int(reader, 4)

        return SMSG_AREA_SPIRIT_HEALER_TIME(
            guid=guid,
            next_resurrect_time=next_resurrect_time,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x02E4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.next_resurrect_time])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_WARDEN_DATA:
    encrypted_data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_WARDEN_DATA:
        _size = 0

        # encrypted_data: u8[-]
        encrypted_data = []
        while _size < body_size:
            encrypted_data.append(await read_int(reader, 1))
            _size += 1

        return SMSG_WARDEN_DATA(
            encrypted_data=encrypted_data,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02E6))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'{len(self.encrypted_data)}B'
        _data.extend([*self.encrypted_data])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + 1 * len(self.encrypted_data)


@dataclasses.dataclass
class CMSG_WARDEN_DATA:
    encrypted_data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_WARDEN_DATA:
        _size = 0

        # encrypted_data: u8[-]
        encrypted_data = []
        while _size < body_size:
            encrypted_data.append(await read_int(reader, 1))
            _size += 1

        return CMSG_WARDEN_DATA(
            encrypted_data=encrypted_data,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02E7))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.encrypted_data)}B'
        _data.extend([*self.encrypted_data])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + 1 * len(self.encrypted_data)


@dataclasses.dataclass
class SMSG_GROUP_JOINED_BATTLEGROUND:
    id: BgTypeId

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GROUP_JOINED_BATTLEGROUND:
        # id: BgTypeId
        id = BgTypeId(await read_int(reader, 4))

        return SMSG_GROUP_JOINED_BATTLEGROUND(
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x02E8))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.id.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_BATTLEGROUND_PLAYER_POSITIONS_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_BATTLEGROUND_PLAYER_POSITIONS_Client:
        return MSG_BATTLEGROUND_PLAYER_POSITIONS_Client()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02E9))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_BATTLEGROUND_PLAYER_POSITIONS_Server:
    teammates: typing.List[BattlegroundPlayerPosition]
    carriers: typing.List[BattlegroundPlayerPosition]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_BATTLEGROUND_PLAYER_POSITIONS_Server:
        # amount_of_teammates: u32
        amount_of_teammates = await read_int(reader, 4)

        # teammates: BattlegroundPlayerPosition[amount_of_teammates]
        teammates = []
        for _ in range(0, amount_of_teammates):
            teammates.append(await BattlegroundPlayerPosition.read(reader))

        # amount_of_carriers: u8
        amount_of_carriers = await read_int(reader, 1)

        # carriers: BattlegroundPlayerPosition[amount_of_carriers]
        carriers = []
        for _ in range(0, amount_of_carriers):
            carriers.append(await BattlegroundPlayerPosition.read(reader))

        return MSG_BATTLEGROUND_PLAYER_POSITIONS_Server(
            teammates=teammates,
            carriers=carriers,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02E9))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.teammates))
        # teammates: BattlegroundPlayerPosition[amount_of_teammates]
        for i in self.teammates:
            _fmt, _data = i.write(_fmt, _data)

        # amount_of_carriers: u8
        _fmt += 'B'
        _data.append(len(self.carriers))

        # carriers: BattlegroundPlayerPosition[amount_of_carriers]
        for i in self.carriers:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + 16 * len(self.teammates) + 16 * len(self.carriers)


@dataclasses.dataclass
class CMSG_PET_STOP_ATTACK:
    pet: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_STOP_ATTACK:
        # pet: Guid
        pet = await read_int(reader, 8)

        return CMSG_PET_STOP_ATTACK(
            pet=pet,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02EA))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.pet)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BINDER_CONFIRM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BINDER_CONFIRM:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_BINDER_CONFIRM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x02EB))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BATTLEGROUND_PLAYER_JOINED:
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BATTLEGROUND_PLAYER_JOINED:
        # player: Guid
        player = await read_int(reader, 8)

        return SMSG_BATTLEGROUND_PLAYER_JOINED(
            player=player,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x02EC))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.player)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_BATTLEGROUND_PLAYER_LEFT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_BATTLEGROUND_PLAYER_LEFT:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_BATTLEGROUND_PLAYER_LEFT(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x02ED))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_BATTLEMASTER_JOIN:
    guid: int
    map: Map
    instance_id: int
    join_as_group: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_BATTLEMASTER_JOIN:
        # guid: Guid
        guid = await read_int(reader, 8)

        # map: Map
        map = Map(await read_int(reader, 4))

        # instance_id: u32
        instance_id = await read_int(reader, 4)

        # join_as_group: Bool8
        join_as_group = await read_bool(reader, 1)

        return CMSG_BATTLEMASTER_JOIN(
            guid=guid,
            map=map,
            instance_id=instance_id,
            join_as_group=join_as_group,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(17 + 4, 0x02EE))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIIB'
        _data.extend([self.guid, self.map.value, self.instance_id, self.join_as_group])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_ADDON_INFO:
    addons: typing.List[Addon]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_ADDON_INFO:
        _size = 0

        # addons: Addon[-]
        addons = []
        while _size < body_size:
            addons.append(await Addon.read(reader))
            _size += addons[-1].size()

        return SMSG_ADDON_INFO(
            addons=addons,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02EF))
        _fmt = "<4s"
        _data = [_data]

        # addons: Addon[-]
        for i in self.addons:
            _fmt, _data = i.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + sum([i.size() for i in self.addons])


@dataclasses.dataclass
class CMSG_PET_UNLEARN:
    pet: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_UNLEARN:
        # pet: Guid
        pet = await read_int(reader, 8)

        return CMSG_PET_UNLEARN(
            pet=pet,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02F0))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.pet)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PET_UNLEARN_CONFIRM:
    pet: int
    talent_reset_cost: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_UNLEARN_CONFIRM:
        # pet: Guid
        pet = await read_int(reader, 8)

        # talent_reset_cost: u32
        talent_reset_cost = await read_int(reader, 4)

        return SMSG_PET_UNLEARN_CONFIRM(
            pet=pet,
            talent_reset_cost=talent_reset_cost,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x02F1))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.pet, self.talent_reset_cost])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PARTY_MEMBER_STATS_FULL:
    player: int
    mask: GroupUpdateFlags
    status: typing.Optional[GroupMemberOnlineStatus] = None
    current_health: typing.Optional[int] = None
    max_health: typing.Optional[int] = None
    power: typing.Optional[Power] = None
    current_power: typing.Optional[int] = None
    max_power: typing.Optional[int] = None
    level: typing.Optional[int] = None
    area: typing.Optional[Area] = None
    position_x: typing.Optional[int] = None
    position_y: typing.Optional[int] = None
    auras: typing.Optional[AuraMask] = None
    pet: typing.Optional[int] = None
    pet_name: typing.Optional[str] = None
    pet_display_id: typing.Optional[int] = None
    pet_current_health: typing.Optional[int] = None
    pet_max_health: typing.Optional[int] = None
    pet_power_type: typing.Optional[Power] = None
    pet_current_power: typing.Optional[int] = None
    pet_max_power: typing.Optional[int] = None
    pet_auras: typing.Optional[AuraMask] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PARTY_MEMBER_STATS_FULL:
        status = None
        current_health = None
        max_health = None
        power = None
        current_power = None
        max_power = None
        level = None
        area = None
        position_x = None
        position_y = None
        auras = None
        pet = None
        pet_name = None
        pet_display_id = None
        pet_current_health = None
        pet_max_health = None
        pet_power_type = None
        pet_current_power = None
        pet_max_power = None
        pet_auras = None
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # mask: GroupUpdateFlags
        mask = GroupUpdateFlags(await read_int(reader, 4))

        if GroupUpdateFlags.STATUS in mask:
            # status: GroupMemberOnlineStatus
            status = GroupMemberOnlineStatus(await read_int(reader, 1))

        if GroupUpdateFlags.CUR_HP in mask:
            # current_health: u16
            current_health = await read_int(reader, 2)

        if GroupUpdateFlags.MAX_HP in mask:
            # max_health: u16
            max_health = await read_int(reader, 2)

        if GroupUpdateFlags.POWER_TYPE in mask:
            # power: Power
            power = Power(await read_int(reader, 1))

        if GroupUpdateFlags.CUR_POWER in mask:
            # current_power: u16
            current_power = await read_int(reader, 2)

        if GroupUpdateFlags.MAX_POWER in mask:
            # max_power: u16
            max_power = await read_int(reader, 2)

        if GroupUpdateFlags.LEVEL in mask:
            # level: Level16
            level = await read_int(reader, 2)

        if GroupUpdateFlags.ZONE in mask:
            # area: Area
            area = Area(await read_int(reader, 4))

        if GroupUpdateFlags.POSITION in mask:
            # position_x: u16
            position_x = await read_int(reader, 2)

            # position_y: u16
            position_y = await read_int(reader, 2)

        if GroupUpdateFlags.AURAS in mask:
            # auras: AuraMask
            auras = await AuraMask.read(reader)

        if GroupUpdateFlags.PET_GUID in mask:
            # pet: Guid
            pet = await read_int(reader, 8)

        if GroupUpdateFlags.PET_NAME in mask:
            # pet_name: CString
            pet_name = await read_cstring(reader)

        if GroupUpdateFlags.PET_MODEL_ID in mask:
            # pet_display_id: u16
            pet_display_id = await read_int(reader, 2)

        if GroupUpdateFlags.PET_CUR_HP in mask:
            # pet_current_health: u16
            pet_current_health = await read_int(reader, 2)

        if GroupUpdateFlags.PET_MAX_HP in mask:
            # pet_max_health: u16
            pet_max_health = await read_int(reader, 2)

        if GroupUpdateFlags.PET_POWER_TYPE in mask:
            # pet_power_type: Power
            pet_power_type = Power(await read_int(reader, 1))

        if GroupUpdateFlags.PET_CUR_POWER in mask:
            # pet_current_power: u16
            pet_current_power = await read_int(reader, 2)

        if GroupUpdateFlags.PET_MAX_POWER in mask:
            # pet_max_power: u16
            pet_max_power = await read_int(reader, 2)

        if GroupUpdateFlags.PET_AURAS in mask:
            # pet_auras: AuraMask
            pet_auras = await AuraMask.read(reader)

        return SMSG_PARTY_MEMBER_STATS_FULL(
            player=player,
            mask=mask,
            status=status,
            current_health=current_health,
            max_health=max_health,
            power=power,
            current_power=current_power,
            max_power=max_power,
            level=level,
            area=area,
            position_x=position_x,
            position_y=position_y,
            auras=auras,
            pet=pet,
            pet_name=pet_name,
            pet_display_id=pet_display_id,
            pet_current_health=pet_current_health,
            pet_max_health=pet_max_health,
            pet_power_type=pet_power_type,
            pet_current_power=pet_current_power,
            pet_max_power=pet_max_power,
            pet_auras=pet_auras,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02F2))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # mask: GroupUpdateFlags
        _fmt += 'I'
        _data.append(self.mask.value)

        if GroupUpdateFlags.STATUS in self.mask:
            _fmt += 'B'
            _data.append(self.status.value)
        if GroupUpdateFlags.CUR_HP in self.mask:
            _fmt += 'H'
            _data.append(self.current_health)
        if GroupUpdateFlags.MAX_HP in self.mask:
            _fmt += 'H'
            _data.append(self.max_health)
        if GroupUpdateFlags.POWER_TYPE in self.mask:
            _fmt += 'B'
            _data.append(self.power.value)
        if GroupUpdateFlags.CUR_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.current_power)
        if GroupUpdateFlags.MAX_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.max_power)
        if GroupUpdateFlags.LEVEL in self.mask:
            _fmt += 'H'
            _data.append(self.level)
        if GroupUpdateFlags.ZONE in self.mask:
            _fmt += 'I'
            _data.append(self.area.value)
        if GroupUpdateFlags.POSITION in self.mask:
            _fmt += 'HH'
            _data.extend([self.position_x, self.position_y])
        if GroupUpdateFlags.AURAS in self.mask:
            # auras: AuraMask
            _fmt, _data = self.auras.write(_fmt, _data)

        if GroupUpdateFlags.PET_GUID in self.mask:
            _fmt += 'Q'
            _data.append(self.pet)
        if GroupUpdateFlags.PET_NAME in self.mask:
            _fmt += f'{len(self.pet_name)}sB'
            _data.extend([self.pet_name.encode('utf-8'), 0])
        if GroupUpdateFlags.PET_MODEL_ID in self.mask:
            _fmt += 'H'
            _data.append(self.pet_display_id)
        if GroupUpdateFlags.PET_CUR_HP in self.mask:
            _fmt += 'H'
            _data.append(self.pet_current_health)
        if GroupUpdateFlags.PET_MAX_HP in self.mask:
            _fmt += 'H'
            _data.append(self.pet_max_health)
        if GroupUpdateFlags.PET_POWER_TYPE in self.mask:
            _fmt += 'B'
            _data.append(self.pet_power_type.value)
        if GroupUpdateFlags.PET_CUR_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.pet_current_power)
        if GroupUpdateFlags.PET_MAX_POWER in self.mask:
            _fmt += 'H'
            _data.append(self.pet_max_power)
        if GroupUpdateFlags.PET_AURAS in self.mask:
            # pet_auras: AuraMask
            _fmt, _data = self.pet_auras.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 4 + packed_guid_size(self.player)

        if GroupUpdateFlags.STATUS in self.mask:
            _size += 1

        if GroupUpdateFlags.CUR_HP in self.mask:
            _size += 2

        if GroupUpdateFlags.MAX_HP in self.mask:
            _size += 2

        if GroupUpdateFlags.POWER_TYPE in self.mask:
            _size += 1

        if GroupUpdateFlags.CUR_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.MAX_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.LEVEL in self.mask:
            _size += 2

        if GroupUpdateFlags.ZONE in self.mask:
            _size += 4

        if GroupUpdateFlags.POSITION in self.mask:
            _size += 4

        if GroupUpdateFlags.AURAS in self.mask:
            _size += 0 + self.auras.size()

        if GroupUpdateFlags.PET_GUID in self.mask:
            _size += 8

        if GroupUpdateFlags.PET_NAME in self.mask:
            _size += 1 + len(self.pet_name)

        if GroupUpdateFlags.PET_MODEL_ID in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_CUR_HP in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_MAX_HP in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_POWER_TYPE in self.mask:
            _size += 1

        if GroupUpdateFlags.PET_CUR_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_MAX_POWER in self.mask:
            _size += 2

        if GroupUpdateFlags.PET_AURAS in self.mask:
            _size += 0 + self.pet_auras.size()

        return _size


@dataclasses.dataclass
class CMSG_PET_SPELL_AUTOCAST:
    guid: int
    id: int
    autocast_enabled: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_PET_SPELL_AUTOCAST:
        # guid: Guid
        guid = await read_int(reader, 8)

        # id: Spell
        id = await read_int(reader, 4)

        # autocast_enabled: Bool8
        autocast_enabled = await read_bool(reader, 1)

        return CMSG_PET_SPELL_AUTOCAST(
            guid=guid,
            id=id,
            autocast_enabled=autocast_enabled,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(13 + 4, 0x02F3))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'QIB'
        _data.extend([self.guid, self.id, self.autocast_enabled])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_WEATHER:
    weather_type: WeatherType
    grade: float
    sound_id: int
    change: WeatherChangeType

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_WEATHER:
        # weather_type: WeatherType
        weather_type = WeatherType(await read_int(reader, 4))

        # grade: f32
        grade = await read_float(reader)

        # sound_id: u32
        sound_id = await read_int(reader, 4)

        # change: WeatherChangeType
        change = WeatherChangeType(await read_int(reader, 1))

        return SMSG_WEATHER(
            weather_type=weather_type,
            grade=grade,
            sound_id=sound_id,
            change=change,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(13 + 2, 0x02F4))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'IfIB'
        _data.extend([self.weather_type.value, self.grade, self.sound_id, self.change.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_RAID_INSTANCE_MESSAGE:
    message_type: RaidInstanceMessage
    map: Map
    time_left: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_RAID_INSTANCE_MESSAGE:
        # message_type: RaidInstanceMessage
        message_type = RaidInstanceMessage(await read_int(reader, 4))

        # map: Map
        map = Map(await read_int(reader, 4))

        # time_left: u32
        time_left = await read_int(reader, 4)

        return SMSG_RAID_INSTANCE_MESSAGE(
            message_type=message_type,
            map=map,
            time_left=time_left,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x02FA))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'III'
        _data.extend([self.message_type.value, self.map.value, self.time_left])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_COMPRESSED_MOVES:
    moves: typing.List[CompressedMove]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_COMPRESSED_MOVES:
        decompressed_size = await read_int(reader, 4)
        compressed_bytes = await reader.readexactly(body_size - 4)
        decompressed_bytes = zlib.decompress(compressed_bytes, bufsize=decompressed_size)
        reader = asyncio.StreamReader()
        reader.feed_data(decompressed_bytes)
        reader.feed_eof()


        _size = 0

        # moves: CompressedMove[-]
        moves = []
        while not reader.at_eof():
            moves.append(await CompressedMove.read(reader))
            _size += moves[-1].size()

        return SMSG_COMPRESSED_MOVES(
            moves=moves,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02FB))
        _fmt = "<4s"
        _data = [_data]

        _compressed_fmt = "<"
        _compressed_data = []

        # moves: CompressedMove[-]
        for i in self.moves:
            _compressed_fmt, _compressed_data = i.write(_compressed_fmt, _compressed_data)

        _uncompressed_data = struct.pack(_compressed_fmt, *_compressed_data)
        _compressed_data = zlib.compress(_uncompressed_data)

        _fmt += 'I'
        _data.append(len(_uncompressed_data))

        _fmt += f'{len(_compressed_data)}s'
        _data.append(_compressed_data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _fmt = ''
        _data = []

        # moves: CompressedMove[-]
        for i in self.moves:
            _fmt, _data = i.write(_fmt, _data)

        _uncompressed_data = struct.pack(_fmt, *_data)
        _compressed_data = zlib.compress(_uncompressed_data)
        return len(_compressed_data) + 4


@dataclasses.dataclass
class CMSG_GUILD_INFO_TEXT:
    guild_info: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GUILD_INFO_TEXT:
        # guild_info: CString
        guild_info = await read_cstring(reader)

        return CMSG_GUILD_INFO_TEXT(
            guild_info=guild_info,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x02FC))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'{len(self.guild_info)}sB'
        _data.extend([self.guild_info.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 1 + len(self.guild_info)


@dataclasses.dataclass
class SMSG_CHAT_RESTRICTED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_CHAT_RESTRICTED:
        return SMSG_CHAT_RESTRICTED()

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x02FD))
        _fmt = "<4s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPLINE_SET_RUN_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_RUN_SPEED:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_RUN_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02FE))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_RUN_BACK_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_RUN_BACK_SPEED:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_RUN_BACK_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x02FF))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_SWIM_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_SWIM_SPEED:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_SWIM_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0300))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_WALK_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_WALK_SPEED:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_WALK_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0301))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_SWIM_BACK_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_SWIM_BACK_SPEED:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_SWIM_BACK_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0302))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_TURN_RATE:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_SET_TURN_RATE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        # speed: f32
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_TURN_RATE(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0303))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        # speed: f32
        _fmt += 'f'
        _data.append(self.speed)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_UNROOT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_UNROOT:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_UNROOT(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0304))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_FEATHER_FALL:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_FEATHER_FALL:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_FEATHER_FALL(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0305))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_NORMAL_FALL:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_NORMAL_FALL:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_NORMAL_FALL(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0306))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_SET_HOVER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_SET_HOVER:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_SET_HOVER(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0307))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_UNSET_HOVER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_UNSET_HOVER:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_UNSET_HOVER(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0308))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_WATER_WALK:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_WATER_WALK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_WATER_WALK(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0309))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_LAND_WALK:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_LAND_WALK:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_LAND_WALK(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x030A))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_START_SWIM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_START_SWIM:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_START_SWIM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x030B))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_STOP_SWIM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_STOP_SWIM:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_STOP_SWIM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x030C))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_SET_RUN_MODE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_SET_RUN_MODE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_SET_RUN_MODE(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x030D))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_SET_WALK_MODE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_SET_WALK_MODE:
        # guid: PackedGuid
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_SET_WALK_MODE(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x030E))
        _fmt = "<4s"
        _data = [_data]

        # guid: PackedGuid
        _fmt, _data = packed_guid_write(self.guid, _fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_ACTIVATETAXIEXPRESS:
    guid: int
    total_cost: int
    nodes: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_ACTIVATETAXIEXPRESS:
        # guid: Guid
        guid = await read_int(reader, 8)

        # total_cost: u32
        total_cost = await read_int(reader, 4)

        # node_count: u32
        node_count = await read_int(reader, 4)

        # nodes: u32[node_count]
        nodes = []
        for _ in range(0, node_count):
            nodes.append(await read_int(reader, 4))

        return CMSG_ACTIVATETAXIEXPRESS(
            guid=guid,
            total_cost=total_cost,
            nodes=nodes,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0312))
        _fmt = "<6s"
        _data = [_data]

        _fmt += f'QII{len(self.nodes)}I'
        _data.extend([self.guid, self.total_cost, len(self.nodes), *self.nodes])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + 4 * len(self.nodes)


@dataclasses.dataclass
class CMSG_SET_FACTION_INACTIVE:
    faction: Faction
    inactive: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_FACTION_INACTIVE:
        # faction: Faction
        faction = Faction(await read_int(reader, 2))

        # inactive: Bool8
        inactive = await read_bool(reader, 1)

        return CMSG_SET_FACTION_INACTIVE(
            faction=faction,
            inactive=inactive,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(3 + 4, 0x0317))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'HB'
        _data.extend([self.faction.value, self.inactive])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_SET_WATCHED_FACTION:
    faction: Faction

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_SET_WATCHED_FACTION:
        # faction: Faction
        faction = Faction(await read_int(reader, 2))

        return CMSG_SET_WATCHED_FACTION(
            faction=faction,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x0318))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'H'
        _data.append(self.faction.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_MOVE_TIME_SKIPPED_Server:
    player: int
    time_skipped: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_MOVE_TIME_SKIPPED_Server:
        # player: PackedGuid
        player = await read_packed_guid(reader)

        # time_skipped: u32
        time_skipped = await read_int(reader, 4)

        return MSG_MOVE_TIME_SKIPPED_Server(
            player=player,
            time_skipped=time_skipped,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0319))
        _fmt = "<4s"
        _data = [_data]

        # player: PackedGuid
        _fmt, _data = packed_guid_write(self.player, _fmt, _data)

        # time_skipped: u32
        _fmt += 'I'
        _data.append(self.time_skipped)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + packed_guid_size(self.player)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_ROOT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPLINE_MOVE_ROOT:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_SPLINE_MOVE_ROOT(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x031A))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_INVALIDATE_PLAYER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INVALIDATE_PLAYER:
        # guid: Guid
        guid = await read_int(reader, 8)

        return SMSG_INVALIDATE_PLAYER(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x031C))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'Q'
        _data.append(self.guid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_RESET_INSTANCES:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_RESET_INSTANCES:
        return CMSG_RESET_INSTANCES()

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x031D))
        _fmt = "<6s"
        _data = [_data]

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_INSTANCE_RESET:
    map: Map

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INSTANCE_RESET:
        # map: Map
        map = Map(await read_int(reader, 4))

        return SMSG_INSTANCE_RESET(
            map=map,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x031E))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_INSTANCE_RESET_FAILED:
    reason: InstanceResetFailedReason
    map: Map

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_INSTANCE_RESET_FAILED:
        # reason: InstanceResetFailedReason
        reason = InstanceResetFailedReason(await read_int(reader, 4))

        # map: Map
        map = Map(await read_int(reader, 4))

        return SMSG_INSTANCE_RESET_FAILED(
            reason=reason,
            map=map,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x031F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'II'
        _data.extend([self.reason.value, self.map.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_UPDATE_LAST_INSTANCE:
    map: Map

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_UPDATE_LAST_INSTANCE:
        # map: Map
        map = Map(await read_int(reader, 4))

        return SMSG_UPDATE_LAST_INSTANCE(
            map=map,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0320))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.map.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class MSG_RAID_TARGET_UPDATE_Client:
    target_index: RaidTargetIndex
    target: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RAID_TARGET_UPDATE_Client:
        target = None
        # target_index: RaidTargetIndex
        target_index = RaidTargetIndex(await read_int(reader, 1))

        if target_index in {RaidTargetIndex.UNKNOWN0, RaidTargetIndex.UNKNOWN1, RaidTargetIndex.UNKNOWN2, RaidTargetIndex.UNKNOWN3, RaidTargetIndex.UNKNOWN4, RaidTargetIndex.UNKNOWN5, RaidTargetIndex.UNKNOWN6, RaidTargetIndex.UNKNOWN7, RaidTargetIndex.UNKNOWN8}:
            # target: Guid
            target = await read_int(reader, 8)

        return MSG_RAID_TARGET_UPDATE_Client(
            target_index=target_index,
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0321))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.target_index.value)
        if self.target_index in {RaidTargetIndex.UNKNOWN0, RaidTargetIndex.UNKNOWN1, RaidTargetIndex.UNKNOWN2, RaidTargetIndex.UNKNOWN3, RaidTargetIndex.UNKNOWN4, RaidTargetIndex.UNKNOWN5, RaidTargetIndex.UNKNOWN6, RaidTargetIndex.UNKNOWN7, RaidTargetIndex.UNKNOWN8}:
            _fmt += 'Q'
            _data.append(self.target)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.target_index in {RaidTargetIndex.UNKNOWN0, RaidTargetIndex.UNKNOWN1, RaidTargetIndex.UNKNOWN2, RaidTargetIndex.UNKNOWN3, RaidTargetIndex.UNKNOWN4, RaidTargetIndex.UNKNOWN5, RaidTargetIndex.UNKNOWN6, RaidTargetIndex.UNKNOWN7, RaidTargetIndex.UNKNOWN8}:
            _size += 8

        return _size


@dataclasses.dataclass
class MSG_RAID_TARGET_UPDATE_Server:
    update_type: RaidTargetUpdateType
    raid_targets: typing.Optional[typing.List[RaidTargetUpdate]] = None
    raid_target: typing.Optional[RaidTargetUpdate] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RAID_TARGET_UPDATE_Server:
        raid_targets = None
        raid_target = None
        # update_type: RaidTargetUpdateType
        update_type = RaidTargetUpdateType(await read_int(reader, 1))

        if update_type == RaidTargetUpdateType.FULL:
            # raid_targets: RaidTargetUpdate[8]
            raid_targets = []
            for _ in range(0, 8):
                raid_targets.append(await RaidTargetUpdate.read(reader))

        elif update_type == RaidTargetUpdateType.PARTIAL:
            # raid_target: RaidTargetUpdate
            raid_target = await RaidTargetUpdate.read(reader)

        return MSG_RAID_TARGET_UPDATE_Server(
            update_type=update_type,
            raid_targets=raid_targets,
            raid_target=raid_target,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0321))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'B'
        _data.append(self.update_type.value)
        if self.update_type == RaidTargetUpdateType.FULL:
            # raid_targets: RaidTargetUpdate[8]
            for i in self.raid_targets:
                _fmt, _data = i.write(_fmt, _data)

        elif self.update_type == RaidTargetUpdateType.PARTIAL:
            # raid_target: RaidTargetUpdate
            _fmt, _data = self.raid_target.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 1

        if self.update_type == RaidTargetUpdateType.FULL:
            _size += 72
        elif self.update_type == RaidTargetUpdateType.PARTIAL:
            _size += 9

        return _size


@dataclasses.dataclass
class MSG_RAID_READY_CHECK_Client:
    state: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RAID_READY_CHECK_Client:
        state = None
        _size = 0

        # answer: optional
        if _size < body_size:
            # state: u8
            state = await read_int(reader, 1)
            _size += 1

        return MSG_RAID_READY_CHECK_Client(
            state=state,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x0322))
        _fmt = "<6s"
        _data = [_data]

        # answer: optional
        if self.state is not None:
            _fmt += 'B'
            _data.append(self.state)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 0

        # answer: optional
        if self.state is not None:
            _size += 1

        return _size


@dataclasses.dataclass
class MSG_RAID_READY_CHECK_Server:
    guid: typing.Optional[int] = None
    state: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> MSG_RAID_READY_CHECK_Server:
        guid = None
        state = None
        _size = 0

        # state_check: optional
        if _size < body_size:
            # guid: Guid
            guid = await read_int(reader, 8)
            _size += 8

            # state: u8
            state = await read_int(reader, 1)
            _size += 1

        return MSG_RAID_READY_CHECK_Server(
            guid=guid,
            state=state,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0322))
        _fmt = "<4s"
        _data = [_data]

        # state_check: optional
        if self.guid is not None and self.state is not None:
            _fmt += 'QB'
            _data.extend([self.guid, self.state])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        _size = 0

        # state_check: optional
        if self.guid is not None and self.state is not None:
            _size += 9

        return _size


@dataclasses.dataclass
class SMSG_PET_ACTION_SOUND:
    guid: int
    reason: PetTalkReason

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_ACTION_SOUND:
        # guid: Guid
        guid = await read_int(reader, 8)

        # reason: PetTalkReason
        reason = PetTalkReason(await read_int(reader, 4))

        return SMSG_PET_ACTION_SOUND(
            guid=guid,
            reason=reason,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0324))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.guid, self.reason.value])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_PET_DISMISS_SOUND:
    sound_id: int
    position: Vector3d

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_PET_DISMISS_SOUND:
        # sound_id: u32
        sound_id = await read_int(reader, 4)

        # position: Vector3d
        position = await Vector3d.read(reader)

        return SMSG_PET_DISMISS_SOUND(
            sound_id=sound_id,
            position=position,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x0325))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.sound_id)
        # position: Vector3d
        _fmt, _data = self.position.write(_fmt, _data)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_GM_TICKET_STATUS_UPDATE:
    response: GmTicketStatusResponse

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_GM_TICKET_STATUS_UPDATE:
        # response: GmTicketStatusResponse
        response = GmTicketStatusResponse(await read_int(reader, 4))

        return SMSG_GM_TICKET_STATUS_UPDATE(
            response=response,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0328))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.response.value)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class CMSG_GMSURVEY_SUBMIT:
    survey_id: int
    questions: typing.List[GmSurveyQuestion]
    answer_comment: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> CMSG_GMSURVEY_SUBMIT:
        # survey_id: u32
        survey_id = await read_int(reader, 4)

        # questions: GmSurveyQuestion[10]
        questions = []
        for _ in range(0, 10):
            questions.append(await GmSurveyQuestion.read(reader))

        # answer_comment: CString
        answer_comment = await read_cstring(reader)

        return CMSG_GMSURVEY_SUBMIT(
            survey_id=survey_id,
            questions=questions,
            answer_comment=answer_comment,
        )

    def write_encrypted_client(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 4, 0x032A))
        _fmt = "<6s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.survey_id)
        # questions: GmSurveyQuestion[10]
        for i in self.questions:
            _fmt, _data = i.write(_fmt, _data)

        # answer_comment: CString
        _fmt += f'{len(self.answer_comment)}sB'
        _data.extend([self.answer_comment.encode('utf-8'), 0])

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 5 + sum([i.size() for i in self.questions]) + len(self.answer_comment)


@dataclasses.dataclass
class SMSG_UPDATE_INSTANCE_OWNERSHIP:
    player_is_saved_to_a_raid: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_UPDATE_INSTANCE_OWNERSHIP:
        # player_is_saved_to_a_raid: Bool32
        player_is_saved_to_a_raid = await read_bool(reader, 4)

        return SMSG_UPDATE_INSTANCE_OWNERSHIP(
            player_is_saved_to_a_raid=player_is_saved_to_a_raid,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x032B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(self.player_is_saved_to_a_raid)
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELLINSTAKILLLOG:
    target: int
    spell: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELLINSTAKILLLOG:
        # target: Guid
        target = await read_int(reader, 8)

        # spell: Spell
        spell = await read_int(reader, 4)

        return SMSG_SPELLINSTAKILLLOG(
            target=target,
            spell=spell,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x032F))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'QI'
        _data.extend([self.target, self.spell])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)


@dataclasses.dataclass
class SMSG_SPELL_UPDATE_CHAIN_TARGETS:
    caster: int
    spell: int
    targets: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_SPELL_UPDATE_CHAIN_TARGETS:
        # caster: Guid
        caster = await read_int(reader, 8)

        # spell: Spell
        spell = await read_int(reader, 4)

        # amount_of_targets: u32
        amount_of_targets = await read_int(reader, 4)

        # targets: Guid[amount_of_targets]
        targets = []
        for _ in range(0, amount_of_targets):
            targets.append(await read_int(reader, 8))

        return SMSG_SPELL_UPDATE_CHAIN_TARGETS(
            caster=caster,
            spell=spell,
            targets=targets,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0330))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'QII{len(self.targets)}Q'
        _data.extend([self.caster, self.spell, len(self.targets), *self.targets])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 16 + 8 * len(self.targets)


@dataclasses.dataclass
class SMSG_EXPECTED_SPAM_RECORDS:
    records: typing.List[str]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_EXPECTED_SPAM_RECORDS:
        # amount_of_records: u32
        amount_of_records = await read_int(reader, 4)

        # records: CString[amount_of_records]
        records = []
        for _ in range(0, amount_of_records):
            records.append(await read_cstring(reader))

        return SMSG_EXPECTED_SPAM_RECORDS(
            records=records,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x0332))
        _fmt = "<4s"
        _data = [_data]

        _fmt += 'I'
        _data.append(len(self.records))
        # records: CString[amount_of_records]
        for i in self.records:
            _fmt += f'{len(i)}sB'
            _data.append(i.encode('utf-8'))
            _data.append(0)

        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 4 + sum([len(i) + 1 for i in self.records])


@dataclasses.dataclass
class SMSG_DEFENSE_MESSAGE:
    area: Area
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int) -> SMSG_DEFENSE_MESSAGE:
        # area: Area
        area = Area(await read_int(reader, 4))

        # message: SizedCString
        message = await read_sized_cstring(reader)

        return SMSG_DEFENSE_MESSAGE(
            area=area,
            message=message,
        )

    def write_encrypted_server(
        self,
        writer: typing.Union[asyncio.StreamWriter, bytearray],
        header_crypto: wow_srp.VanillaHeaderCrypto,
    ):
        _data = bytes(header_crypto.encrypt_server_header(self.size() + 2, 0x033B))
        _fmt = "<4s"
        _data = [_data]

        _fmt += f'II{len(self.message)}sB'
        _data.extend([self.area.value, len(self.message) + 1, self.message.encode('utf-8'), 0])
        _data = struct.pack(_fmt, *_data)
        if isinstance(writer, bytearray):
            for i in range(0, len(_data)):
                writer[i] = _data[i]
            return
        writer.write(_data)

    def size(self) -> int:
        return 9 + len(self.message)


ClientOpcode = typing.Union[
    CMSG_BOOTME,
    CMSG_DBLOOKUP,
    CMSG_WORLD_TELEPORT,
    CMSG_TELEPORT_TO_UNIT,
    CMSG_CHAR_CREATE,
    CMSG_CHAR_ENUM,
    CMSG_CHAR_DELETE,
    CMSG_PLAYER_LOGIN,
    CMSG_PLAYER_LOGOUT,
    CMSG_LOGOUT_REQUEST,
    CMSG_LOGOUT_CANCEL,
    CMSG_NAME_QUERY,
    CMSG_PET_NAME_QUERY,
    CMSG_GUILD_QUERY,
    CMSG_ITEM_QUERY_SINGLE,
    CMSG_PAGE_TEXT_QUERY,
    CMSG_QUEST_QUERY,
    CMSG_GAMEOBJECT_QUERY,
    CMSG_CREATURE_QUERY,
    CMSG_WHO,
    CMSG_WHOIS,
    CMSG_FRIEND_LIST,
    CMSG_ADD_FRIEND,
    CMSG_DEL_FRIEND,
    CMSG_ADD_IGNORE,
    CMSG_DEL_IGNORE,
    CMSG_GROUP_INVITE,
    CMSG_GROUP_ACCEPT,
    CMSG_GROUP_DECLINE,
    CMSG_GROUP_UNINVITE,
    CMSG_GROUP_UNINVITE_GUID,
    CMSG_GROUP_SET_LEADER,
    CMSG_LOOT_METHOD,
    CMSG_GROUP_DISBAND,
    CMSG_GUILD_CREATE,
    CMSG_GUILD_INVITE,
    CMSG_GUILD_ACCEPT,
    CMSG_GUILD_DECLINE,
    CMSG_GUILD_INFO,
    CMSG_GUILD_ROSTER,
    CMSG_GUILD_PROMOTE,
    CMSG_GUILD_DEMOTE,
    CMSG_GUILD_LEAVE,
    CMSG_GUILD_REMOVE,
    CMSG_GUILD_DISBAND,
    CMSG_GUILD_LEADER,
    CMSG_GUILD_MOTD,
    CMSG_MESSAGECHAT,
    CMSG_JOIN_CHANNEL,
    CMSG_LEAVE_CHANNEL,
    CMSG_CHANNEL_LIST,
    CMSG_CHANNEL_PASSWORD,
    CMSG_CHANNEL_SET_OWNER,
    CMSG_CHANNEL_OWNER,
    CMSG_CHANNEL_MODERATOR,
    CMSG_CHANNEL_UNMODERATOR,
    CMSG_CHANNEL_MUTE,
    CMSG_CHANNEL_UNMUTE,
    CMSG_CHANNEL_INVITE,
    CMSG_CHANNEL_KICK,
    CMSG_CHANNEL_BAN,
    CMSG_CHANNEL_UNBAN,
    CMSG_CHANNEL_ANNOUNCEMENTS,
    CMSG_CHANNEL_MODERATE,
    CMSG_USE_ITEM,
    CMSG_OPEN_ITEM,
    CMSG_READ_ITEM,
    CMSG_GAMEOBJ_USE,
    CMSG_AREATRIGGER,
    MSG_MOVE_START_FORWARD_Client,
    MSG_MOVE_START_BACKWARD_Client,
    MSG_MOVE_STOP_Client,
    MSG_MOVE_START_STRAFE_LEFT_Client,
    MSG_MOVE_START_STRAFE_RIGHT_Client,
    MSG_MOVE_STOP_STRAFE_Client,
    MSG_MOVE_JUMP_Client,
    MSG_MOVE_START_TURN_LEFT_Client,
    MSG_MOVE_START_TURN_RIGHT_Client,
    MSG_MOVE_STOP_TURN_Client,
    MSG_MOVE_START_PITCH_UP_Client,
    MSG_MOVE_START_PITCH_DOWN_Client,
    MSG_MOVE_STOP_PITCH_Client,
    MSG_MOVE_SET_RUN_MODE_Client,
    MSG_MOVE_SET_WALK_MODE_Client,
    MSG_MOVE_TELEPORT_ACK_Client,
    MSG_MOVE_FALL_LAND_Client,
    MSG_MOVE_START_SWIM_Client,
    MSG_MOVE_STOP_SWIM_Client,
    MSG_MOVE_SET_FACING_Client,
    MSG_MOVE_SET_PITCH_Client,
    MSG_MOVE_WORLDPORT_ACK,
    CMSG_MOVE_SET_RAW_POSITION,
    CMSG_FORCE_RUN_SPEED_CHANGE_ACK,
    CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK,
    CMSG_FORCE_SWIM_SPEED_CHANGE_ACK,
    CMSG_FORCE_MOVE_ROOT_ACK,
    CMSG_FORCE_MOVE_UNROOT_ACK,
    MSG_MOVE_HEARTBEAT_Client,
    CMSG_MOVE_KNOCK_BACK_ACK,
    CMSG_MOVE_HOVER_ACK,
    CMSG_NEXT_CINEMATIC_CAMERA,
    CMSG_COMPLETE_CINEMATIC,
    CMSG_TUTORIAL_FLAG,
    CMSG_TUTORIAL_CLEAR,
    CMSG_TUTORIAL_RESET,
    CMSG_STANDSTATECHANGE,
    CMSG_EMOTE,
    CMSG_TEXT_EMOTE,
    CMSG_AUTOSTORE_LOOT_ITEM,
    CMSG_AUTOEQUIP_ITEM,
    CMSG_AUTOSTORE_BAG_ITEM,
    CMSG_SWAP_ITEM,
    CMSG_SWAP_INV_ITEM,
    CMSG_SPLIT_ITEM,
    CMSG_AUTOEQUIP_ITEM_SLOT,
    CMSG_DESTROYITEM,
    CMSG_INSPECT,
    CMSG_INITIATE_TRADE,
    CMSG_BEGIN_TRADE,
    CMSG_BUSY_TRADE,
    CMSG_IGNORE_TRADE,
    CMSG_ACCEPT_TRADE,
    CMSG_UNACCEPT_TRADE,
    CMSG_CANCEL_TRADE,
    CMSG_SET_TRADE_ITEM,
    CMSG_CLEAR_TRADE_ITEM,
    CMSG_SET_TRADE_GOLD,
    CMSG_SET_FACTION_ATWAR,
    CMSG_SET_ACTION_BUTTON,
    CMSG_CAST_SPELL,
    CMSG_CANCEL_CAST,
    CMSG_CANCEL_AURA,
    CMSG_CANCEL_CHANNELLING,
    CMSG_SET_SELECTION,
    CMSG_SET_TARGET_OBSOLETE,
    CMSG_ATTACKSWING,
    CMSG_ATTACKSTOP,
    CMSG_REPOP_REQUEST,
    CMSG_RESURRECT_RESPONSE,
    CMSG_LOOT,
    CMSG_LOOT_MONEY,
    CMSG_LOOT_RELEASE,
    CMSG_DUEL_ACCEPTED,
    CMSG_DUEL_CANCELLED,
    CMSG_MOUNTSPECIAL_ANIM,
    CMSG_PET_SET_ACTION,
    CMSG_PET_ACTION,
    CMSG_PET_ABANDON,
    CMSG_PET_RENAME,
    CMSG_GOSSIP_HELLO,
    CMSG_GOSSIP_SELECT_OPTION,
    CMSG_NPC_TEXT_QUERY,
    CMSG_QUESTGIVER_STATUS_QUERY,
    CMSG_QUESTGIVER_HELLO,
    CMSG_QUESTGIVER_QUERY_QUEST,
    CMSG_QUESTGIVER_QUEST_AUTOLAUNCH,
    CMSG_QUESTGIVER_ACCEPT_QUEST,
    CMSG_QUESTGIVER_COMPLETE_QUEST,
    CMSG_QUESTGIVER_REQUEST_REWARD,
    CMSG_QUESTGIVER_CHOOSE_REWARD,
    CMSG_QUESTGIVER_CANCEL,
    CMSG_QUESTLOG_SWAP_QUEST,
    CMSG_QUESTLOG_REMOVE_QUEST,
    CMSG_QUEST_CONFIRM_ACCEPT,
    CMSG_PUSHQUESTTOPARTY,
    CMSG_LIST_INVENTORY,
    CMSG_SELL_ITEM,
    CMSG_BUY_ITEM,
    CMSG_BUY_ITEM_IN_SLOT,
    CMSG_TAXINODE_STATUS_QUERY,
    CMSG_TAXIQUERYAVAILABLENODES,
    CMSG_ACTIVATETAXI,
    CMSG_TRAINER_LIST,
    CMSG_TRAINER_BUY_SPELL,
    CMSG_BINDER_ACTIVATE,
    CMSG_BANKER_ACTIVATE,
    CMSG_BUY_BANK_SLOT,
    CMSG_PETITION_SHOWLIST,
    CMSG_PETITION_BUY,
    CMSG_PETITION_SHOW_SIGNATURES,
    CMSG_PETITION_SIGN,
    MSG_PETITION_DECLINE,
    CMSG_OFFER_PETITION,
    CMSG_TURN_IN_PETITION,
    CMSG_PETITION_QUERY,
    CMSG_BUG,
    CMSG_PLAYED_TIME,
    CMSG_QUERY_TIME,
    CMSG_RECLAIM_CORPSE,
    CMSG_WRAP_ITEM,
    MSG_MINIMAP_PING_Client,
    CMSG_PING,
    CMSG_SETSHEATHED,
    CMSG_AUTH_SESSION,
    CMSG_PET_CAST_SPELL,
    MSG_SAVE_GUILD_EMBLEM_Client,
    MSG_TABARDVENDOR_ACTIVATE,
    CMSG_ZONEUPDATE,
    MSG_RANDOM_ROLL_Client,
    MSG_LOOKING_FOR_GROUP_Client,
    CMSG_UNLEARN_SKILL,
    CMSG_GMTICKET_CREATE,
    CMSG_GMTICKET_UPDATETEXT,
    CMSG_REQUEST_ACCOUNT_DATA,
    CMSG_UPDATE_ACCOUNT_DATA,
    CMSG_GMTICKET_GETTICKET,
    MSG_CORPSE_QUERY_Client,
    CMSG_GMTICKET_DELETETICKET,
    CMSG_GMTICKET_SYSTEMSTATUS,
    CMSG_SPIRIT_HEALER_ACTIVATE,
    CMSG_CHAT_IGNORED,
    CMSG_GUILD_RANK,
    CMSG_GUILD_ADD_RANK,
    CMSG_GUILD_DEL_RANK,
    CMSG_GUILD_SET_PUBLIC_NOTE,
    CMSG_GUILD_SET_OFFICER_NOTE,
    CMSG_SEND_MAIL,
    CMSG_GET_MAIL_LIST,
    CMSG_BATTLEFIELD_LIST,
    CMSG_BATTLEFIELD_JOIN,
    CMSG_ITEM_TEXT_QUERY,
    CMSG_MAIL_TAKE_MONEY,
    CMSG_MAIL_TAKE_ITEM,
    CMSG_MAIL_MARK_AS_READ,
    CMSG_MAIL_RETURN_TO_SENDER,
    CMSG_MAIL_DELETE,
    CMSG_MAIL_CREATE_TEXT_ITEM,
    CMSG_LEARN_TALENT,
    CMSG_TOGGLE_PVP,
    MSG_AUCTION_HELLO_Client,
    CMSG_AUCTION_SELL_ITEM,
    CMSG_AUCTION_REMOVE_ITEM,
    CMSG_AUCTION_LIST_ITEMS,
    CMSG_AUCTION_LIST_OWNER_ITEMS,
    CMSG_AUCTION_PLACE_BID,
    CMSG_AUCTION_LIST_BIDDER_ITEMS,
    CMSG_SET_AMMO,
    CMSG_SET_ACTIVE_MOVER,
    CMSG_PET_CANCEL_AURA,
    CMSG_CANCEL_AUTO_REPEAT_SPELL,
    MSG_LIST_STABLED_PETS_Client,
    CMSG_STABLE_PET,
    CMSG_UNSTABLE_PET,
    CMSG_BUY_STABLE_SLOT,
    CMSG_STABLE_SWAP_PET,
    MSG_QUEST_PUSH_RESULT,
    CMSG_REQUEST_PET_INFO,
    CMSG_FAR_SIGHT,
    CMSG_GROUP_CHANGE_SUB_GROUP,
    CMSG_REQUEST_PARTY_MEMBER_STATS,
    CMSG_GROUP_SWAP_SUB_GROUP,
    CMSG_AUTOSTORE_BANK_ITEM,
    CMSG_AUTOBANK_ITEM,
    MSG_QUERY_NEXT_MAIL_TIME_Client,
    CMSG_GROUP_RAID_CONVERT,
    CMSG_GROUP_ASSISTANT_LEADER,
    CMSG_BUYBACK_ITEM,
    CMSG_MEETINGSTONE_JOIN,
    CMSG_MEETINGSTONE_LEAVE,
    CMSG_MEETINGSTONE_INFO,
    CMSG_CANCEL_GROWTH_AURA,
    CMSG_LOOT_ROLL,
    CMSG_LOOT_MASTER_GIVE,
    CMSG_REPAIR_ITEM,
    MSG_TALENT_WIPE_CONFIRM_Client,
    CMSG_SUMMON_RESPONSE,
    MSG_MOVE_WATER_WALK,
    CMSG_SELF_RES,
    CMSG_TOGGLE_HELM,
    CMSG_TOGGLE_CLOAK,
    CMSG_SET_ACTIONBAR_TOGGLES,
    MSG_PETITION_RENAME,
    CMSG_ITEM_NAME_QUERY,
    CMSG_CHAR_RENAME,
    CMSG_MOVE_SPLINE_DONE,
    CMSG_MOVE_FALL_RESET,
    CMSG_REQUEST_RAID_INFO,
    CMSG_MOVE_TIME_SKIPPED,
    CMSG_MOVE_FEATHER_FALL_ACK,
    CMSG_MOVE_WATER_WALK_ACK,
    CMSG_MOVE_NOT_ACTIVE_MOVER,
    CMSG_BATTLEFIELD_STATUS,
    CMSG_BATTLEFIELD_PORT,
    MSG_INSPECT_HONOR_STATS_Client,
    CMSG_BATTLEMASTER_HELLO,
    CMSG_FORCE_WALK_SPEED_CHANGE_ACK,
    CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK,
    CMSG_FORCE_TURN_RATE_CHANGE_ACK,
    MSG_PVP_LOG_DATA_Client,
    CMSG_LEAVE_BATTLEFIELD,
    CMSG_AREA_SPIRIT_HEALER_QUERY,
    CMSG_AREA_SPIRIT_HEALER_QUEUE,
    CMSG_WARDEN_DATA,
    MSG_BATTLEGROUND_PLAYER_POSITIONS_Client,
    CMSG_PET_STOP_ATTACK,
    CMSG_BATTLEMASTER_JOIN,
    CMSG_PET_UNLEARN,
    CMSG_PET_SPELL_AUTOCAST,
    CMSG_GUILD_INFO_TEXT,
    CMSG_ACTIVATETAXIEXPRESS,
    CMSG_SET_FACTION_INACTIVE,
    CMSG_SET_WATCHED_FACTION,
    CMSG_RESET_INSTANCES,
    MSG_RAID_TARGET_UPDATE_Client,
    MSG_RAID_READY_CHECK_Client,
    CMSG_GMSURVEY_SUBMIT,
]

ServerOpcode = typing.Union[
    SMSG_CHAR_CREATE,
    SMSG_CHAR_ENUM,
    SMSG_CHAR_DELETE,
    SMSG_NEW_WORLD,
    SMSG_TRANSFER_PENDING,
    SMSG_TRANSFER_ABORTED,
    SMSG_CHARACTER_LOGIN_FAILED,
    SMSG_LOGIN_SETTIMESPEED,
    SMSG_LOGOUT_RESPONSE,
    SMSG_LOGOUT_COMPLETE,
    SMSG_LOGOUT_CANCEL_ACK,
    SMSG_NAME_QUERY_RESPONSE,
    SMSG_PET_NAME_QUERY_RESPONSE,
    SMSG_GUILD_QUERY_RESPONSE,
    SMSG_ITEM_QUERY_SINGLE_RESPONSE,
    SMSG_PAGE_TEXT_QUERY_RESPONSE,
    SMSG_QUEST_QUERY_RESPONSE,
    SMSG_GAMEOBJECT_QUERY_RESPONSE,
    SMSG_CREATURE_QUERY_RESPONSE,
    SMSG_WHO,
    SMSG_WHOIS,
    SMSG_FRIEND_LIST,
    SMSG_FRIEND_STATUS,
    SMSG_IGNORE_LIST,
    SMSG_GROUP_INVITE,
    SMSG_GROUP_DECLINE,
    SMSG_GROUP_UNINVITE,
    SMSG_GROUP_SET_LEADER,
    SMSG_GROUP_DESTROYED,
    SMSG_GROUP_LIST,
    SMSG_PARTY_MEMBER_STATS,
    SMSG_PARTY_COMMAND_RESULT,
    SMSG_GUILD_INVITE,
    SMSG_GUILD_INFO,
    SMSG_GUILD_ROSTER,
    SMSG_GUILD_EVENT,
    SMSG_GUILD_COMMAND_RESULT,
    SMSG_MESSAGECHAT,
    SMSG_CHANNEL_NOTIFY,
    SMSG_CHANNEL_LIST,
    SMSG_UPDATE_OBJECT,
    SMSG_DESTROY_OBJECT,
    SMSG_READ_ITEM_OK,
    SMSG_READ_ITEM_FAILED,
    SMSG_ITEM_COOLDOWN,
    SMSG_GAMEOBJECT_CUSTOM_ANIM,
    MSG_MOVE_START_FORWARD_Server,
    MSG_MOVE_START_BACKWARD_Server,
    MSG_MOVE_STOP_Server,
    MSG_MOVE_START_STRAFE_LEFT_Server,
    MSG_MOVE_START_STRAFE_RIGHT_Server,
    MSG_MOVE_STOP_STRAFE_Server,
    MSG_MOVE_JUMP_Server,
    MSG_MOVE_START_TURN_LEFT_Server,
    MSG_MOVE_START_TURN_RIGHT_Server,
    MSG_MOVE_STOP_TURN_Server,
    MSG_MOVE_START_PITCH_UP_Server,
    MSG_MOVE_START_PITCH_DOWN_Server,
    MSG_MOVE_STOP_PITCH_Server,
    MSG_MOVE_SET_RUN_MODE_Server,
    MSG_MOVE_SET_WALK_MODE_Server,
    MSG_MOVE_TELEPORT_ACK_Server,
    MSG_MOVE_FALL_LAND_Server,
    MSG_MOVE_START_SWIM_Server,
    MSG_MOVE_STOP_SWIM_Server,
    MSG_MOVE_SET_FACING_Server,
    MSG_MOVE_SET_PITCH_Server,
    MSG_MOVE_WORLDPORT_ACK,
    SMSG_MONSTER_MOVE,
    SMSG_MOVE_WATER_WALK,
    SMSG_MOVE_LAND_WALK,
    SMSG_FORCE_RUN_SPEED_CHANGE,
    SMSG_FORCE_RUN_BACK_SPEED_CHANGE,
    SMSG_FORCE_SWIM_SPEED_CHANGE,
    SMSG_FORCE_MOVE_ROOT,
    SMSG_FORCE_MOVE_UNROOT,
    MSG_MOVE_HEARTBEAT_Server,
    SMSG_MOVE_KNOCK_BACK,
    SMSG_MOVE_FEATHER_FALL,
    SMSG_MOVE_NORMAL_FALL,
    SMSG_MOVE_SET_HOVER,
    SMSG_MOVE_UNSET_HOVER,
    SMSG_TRIGGER_CINEMATIC,
    SMSG_TUTORIAL_FLAGS,
    SMSG_EMOTE,
    SMSG_TEXT_EMOTE,
    SMSG_INVENTORY_CHANGE_FAILURE,
    SMSG_OPEN_CONTAINER,
    SMSG_INSPECT,
    SMSG_TRADE_STATUS,
    SMSG_TRADE_STATUS_EXTENDED,
    SMSG_INITIALIZE_FACTIONS,
    SMSG_SET_FACTION_VISIBLE,
    SMSG_SET_FACTION_STANDING,
    SMSG_SET_PROFICIENCY,
    SMSG_ACTION_BUTTONS,
    SMSG_INITIAL_SPELLS,
    SMSG_LEARNED_SPELL,
    SMSG_SUPERCEDED_SPELL,
    SMSG_CAST_RESULT,
    SMSG_SPELL_START,
    SMSG_SPELL_GO,
    SMSG_SPELL_FAILURE,
    SMSG_SPELL_COOLDOWN,
    SMSG_COOLDOWN_EVENT,
    SMSG_UPDATE_AURA_DURATION,
    SMSG_PET_CAST_FAILED,
    MSG_CHANNEL_START_Server,
    MSG_CHANNEL_UPDATE_Server,
    SMSG_AI_REACTION,
    SMSG_ATTACKSTART,
    SMSG_ATTACKSTOP,
    SMSG_ATTACKSWING_NOTINRANGE,
    SMSG_ATTACKSWING_BADFACING,
    SMSG_ATTACKSWING_NOTSTANDING,
    SMSG_ATTACKSWING_DEADTARGET,
    SMSG_ATTACKSWING_CANT_ATTACK,
    SMSG_ATTACKERSTATEUPDATE,
    SMSG_CANCEL_COMBAT,
    SMSG_SPELLHEALLOG,
    SMSG_SPELLENERGIZELOG,
    SMSG_BINDPOINTUPDATE,
    SMSG_PLAYERBOUND,
    SMSG_CLIENT_CONTROL_UPDATE,
    SMSG_RESURRECT_REQUEST,
    SMSG_LOOT_RESPONSE,
    SMSG_LOOT_RELEASE_RESPONSE,
    SMSG_LOOT_REMOVED,
    SMSG_LOOT_MONEY_NOTIFY,
    SMSG_LOOT_CLEAR_MONEY,
    SMSG_ITEM_PUSH_RESULT,
    SMSG_DUEL_REQUESTED,
    SMSG_DUEL_OUTOFBOUNDS,
    SMSG_DUEL_INBOUNDS,
    SMSG_DUEL_COMPLETE,
    SMSG_DUEL_WINNER,
    SMSG_MOUNTRESULT,
    SMSG_DISMOUNTRESULT,
    SMSG_MOUNTSPECIAL_ANIM,
    SMSG_PET_TAME_FAILURE,
    SMSG_PET_NAME_INVALID,
    SMSG_PET_SPELLS,
    SMSG_PET_MODE,
    SMSG_GOSSIP_MESSAGE,
    SMSG_GOSSIP_COMPLETE,
    SMSG_NPC_TEXT_UPDATE,
    SMSG_QUESTGIVER_STATUS,
    SMSG_QUESTGIVER_QUEST_LIST,
    SMSG_QUESTGIVER_QUEST_DETAILS,
    SMSG_QUESTGIVER_REQUEST_ITEMS,
    SMSG_QUESTGIVER_OFFER_REWARD,
    SMSG_QUESTGIVER_QUEST_INVALID,
    SMSG_QUESTGIVER_QUEST_COMPLETE,
    SMSG_QUESTGIVER_QUEST_FAILED,
    SMSG_QUESTLOG_FULL,
    SMSG_QUESTUPDATE_FAILED,
    SMSG_QUESTUPDATE_FAILEDTIMER,
    SMSG_QUESTUPDATE_COMPLETE,
    SMSG_QUESTUPDATE_ADD_KILL,
    SMSG_QUESTUPDATE_ADD_ITEM,
    SMSG_QUEST_CONFIRM_ACCEPT,
    SMSG_LIST_INVENTORY,
    SMSG_SELL_ITEM,
    SMSG_BUY_ITEM,
    SMSG_BUY_FAILED,
    SMSG_SHOWTAXINODES,
    SMSG_TAXINODE_STATUS,
    SMSG_ACTIVATETAXIREPLY,
    SMSG_NEW_TAXI_PATH,
    SMSG_TRAINER_LIST,
    SMSG_TRAINER_BUY_SUCCEEDED,
    SMSG_TRAINER_BUY_FAILED,
    SMSG_SHOW_BANK,
    SMSG_BUY_BANK_SLOT_RESULT,
    SMSG_PETITION_SHOWLIST,
    SMSG_PETITION_SHOW_SIGNATURES,
    SMSG_PETITION_SIGN_RESULTS,
    MSG_PETITION_DECLINE,
    SMSG_TURN_IN_PETITION_RESULTS,
    SMSG_PETITION_QUERY_RESPONSE,
    SMSG_FISH_NOT_HOOKED,
    SMSG_FISH_ESCAPED,
    SMSG_NOTIFICATION,
    SMSG_PLAYED_TIME,
    SMSG_QUERY_TIME_RESPONSE,
    SMSG_LOG_XPGAIN,
    SMSG_LEVELUP_INFO,
    MSG_MINIMAP_PING_Server,
    SMSG_RESISTLOG,
    SMSG_ENCHANTMENTLOG,
    SMSG_START_MIRROR_TIMER,
    SMSG_PAUSE_MIRROR_TIMER,
    SMSG_STOP_MIRROR_TIMER,
    SMSG_PONG,
    SMSG_CLEAR_COOLDOWN,
    SMSG_GAMEOBJECT_PAGETEXT,
    SMSG_SPELL_DELAYED,
    SMSG_ITEM_TIME_UPDATE,
    SMSG_ITEM_ENCHANT_TIME_UPDATE,
    SMSG_AUTH_CHALLENGE,
    SMSG_AUTH_RESPONSE,
    MSG_SAVE_GUILD_EMBLEM_Server,
    MSG_TABARDVENDOR_ACTIVATE,
    SMSG_PLAY_SPELL_VISUAL,
    SMSG_PARTYKILLLOG,
    SMSG_COMPRESSED_UPDATE_OBJECT,
    SMSG_PLAY_SPELL_IMPACT,
    SMSG_EXPLORATION_EXPERIENCE,
    MSG_RANDOM_ROLL_Server,
    SMSG_ENVIRONMENTAL_DAMAGE_LOG,
    MSG_LOOKING_FOR_GROUP_Server,
    SMSG_REMOVED_SPELL,
    SMSG_GMTICKET_CREATE,
    SMSG_GMTICKET_UPDATETEXT,
    SMSG_ACCOUNT_DATA_TIMES,
    SMSG_GMTICKET_GETTICKET,
    SMSG_GAMEOBJECT_SPAWN_ANIM,
    SMSG_GAMEOBJECT_DESPAWN_ANIM,
    MSG_CORPSE_QUERY_Server,
    SMSG_GMTICKET_DELETETICKET,
    SMSG_CHAT_WRONG_FACTION,
    SMSG_GMTICKET_SYSTEMSTATUS,
    SMSG_SET_REST_START,
    SMSG_SPIRIT_HEALER_CONFIRM,
    SMSG_GOSSIP_POI,
    SMSG_LOGIN_VERIFY_WORLD,
    SMSG_SEND_MAIL_RESULT,
    SMSG_MAIL_LIST_RESULT,
    SMSG_BATTLEFIELD_LIST,
    SMSG_ITEM_TEXT_QUERY_RESPONSE,
    SMSG_SPELLLOGMISS,
    SMSG_SPELLLOGEXECUTE,
    SMSG_PERIODICAURALOG,
    SMSG_SPELLDAMAGESHIELD,
    SMSG_SPELLNONMELEEDAMAGELOG,
    SMSG_ZONE_UNDER_ATTACK,
    MSG_AUCTION_HELLO_Server,
    SMSG_AUCTION_COMMAND_RESULT,
    SMSG_AUCTION_LIST_RESULT,
    SMSG_AUCTION_OWNER_LIST_RESULT,
    SMSG_AUCTION_BIDDER_NOTIFICATION,
    SMSG_AUCTION_OWNER_NOTIFICATION,
    SMSG_PROCRESIST,
    SMSG_DISPEL_FAILED,
    SMSG_SPELLORDAMAGE_IMMUNE,
    SMSG_AUCTION_BIDDER_LIST_RESULT,
    SMSG_SET_FLAT_SPELL_MODIFIER,
    SMSG_SET_PCT_SPELL_MODIFIER,
    SMSG_CORPSE_RECLAIM_DELAY,
    MSG_LIST_STABLED_PETS_Server,
    SMSG_STABLE_RESULT,
    MSG_QUEST_PUSH_RESULT,
    SMSG_PLAY_MUSIC,
    SMSG_PLAY_OBJECT_SOUND,
    SMSG_SPELLDISPELLOG,
    MSG_QUERY_NEXT_MAIL_TIME_Server,
    SMSG_RECEIVED_MAIL,
    SMSG_RAID_GROUP_ONLY,
    SMSG_PVP_CREDIT,
    SMSG_AUCTION_REMOVED_NOTIFICATION,
    SMSG_SERVER_MESSAGE,
    SMSG_MEETINGSTONE_SETQUEUE,
    SMSG_MEETINGSTONE_COMPLETE,
    SMSG_MEETINGSTONE_IN_PROGRESS,
    SMSG_MEETINGSTONE_MEMBER_ADDED,
    SMSG_CANCEL_AUTO_REPEAT,
    SMSG_STANDSTATE_UPDATE,
    SMSG_LOOT_ALL_PASSED,
    SMSG_LOOT_ROLL_WON,
    SMSG_LOOT_START_ROLL,
    SMSG_LOOT_ROLL,
    SMSG_LOOT_MASTER_LIST,
    SMSG_SET_FORCED_REACTIONS,
    SMSG_SPELL_FAILED_OTHER,
    SMSG_GAMEOBJECT_RESET_STATE,
    SMSG_CHAT_PLAYER_NOT_FOUND,
    MSG_TALENT_WIPE_CONFIRM_Server,
    SMSG_SUMMON_REQUEST,
    SMSG_MONSTER_MOVE_TRANSPORT,
    SMSG_PET_BROKEN,
    MSG_MOVE_FEATHER_FALL_Server,
    MSG_MOVE_WATER_WALK,
    SMSG_FEIGN_DEATH_RESISTED,
    SMSG_DUEL_COUNTDOWN,
    SMSG_AREA_TRIGGER_MESSAGE,
    SMSG_MEETINGSTONE_JOINFAILED,
    SMSG_PLAYER_SKINNED,
    SMSG_DURABILITY_DAMAGE_DEATH,
    MSG_PETITION_RENAME,
    SMSG_INIT_WORLD_STATES,
    SMSG_UPDATE_WORLD_STATE,
    SMSG_ITEM_NAME_QUERY_RESPONSE,
    SMSG_PET_ACTION_FEEDBACK,
    SMSG_CHAR_RENAME,
    SMSG_INSTANCE_SAVE_CREATED,
    SMSG_RAID_INSTANCE_INFO,
    SMSG_PLAY_SOUND,
    SMSG_BATTLEFIELD_STATUS,
    MSG_INSPECT_HONOR_STATS_Server,
    SMSG_FORCE_WALK_SPEED_CHANGE,
    SMSG_FORCE_SWIM_BACK_SPEED_CHANGE,
    SMSG_FORCE_TURN_RATE_CHANGE,
    MSG_PVP_LOG_DATA_Server,
    SMSG_AREA_SPIRIT_HEALER_TIME,
    SMSG_WARDEN_DATA,
    SMSG_GROUP_JOINED_BATTLEGROUND,
    MSG_BATTLEGROUND_PLAYER_POSITIONS_Server,
    SMSG_BINDER_CONFIRM,
    SMSG_BATTLEGROUND_PLAYER_JOINED,
    SMSG_BATTLEGROUND_PLAYER_LEFT,
    SMSG_ADDON_INFO,
    SMSG_PET_UNLEARN_CONFIRM,
    SMSG_PARTY_MEMBER_STATS_FULL,
    SMSG_WEATHER,
    SMSG_RAID_INSTANCE_MESSAGE,
    SMSG_COMPRESSED_MOVES,
    SMSG_CHAT_RESTRICTED,
    SMSG_SPLINE_SET_RUN_SPEED,
    SMSG_SPLINE_SET_RUN_BACK_SPEED,
    SMSG_SPLINE_SET_SWIM_SPEED,
    SMSG_SPLINE_SET_WALK_SPEED,
    SMSG_SPLINE_SET_SWIM_BACK_SPEED,
    SMSG_SPLINE_SET_TURN_RATE,
    SMSG_SPLINE_MOVE_UNROOT,
    SMSG_SPLINE_MOVE_FEATHER_FALL,
    SMSG_SPLINE_MOVE_NORMAL_FALL,
    SMSG_SPLINE_MOVE_SET_HOVER,
    SMSG_SPLINE_MOVE_UNSET_HOVER,
    SMSG_SPLINE_MOVE_WATER_WALK,
    SMSG_SPLINE_MOVE_LAND_WALK,
    SMSG_SPLINE_MOVE_START_SWIM,
    SMSG_SPLINE_MOVE_STOP_SWIM,
    SMSG_SPLINE_MOVE_SET_RUN_MODE,
    SMSG_SPLINE_MOVE_SET_WALK_MODE,
    MSG_MOVE_TIME_SKIPPED_Server,
    SMSG_SPLINE_MOVE_ROOT,
    SMSG_INVALIDATE_PLAYER,
    SMSG_INSTANCE_RESET,
    SMSG_INSTANCE_RESET_FAILED,
    SMSG_UPDATE_LAST_INSTANCE,
    MSG_RAID_TARGET_UPDATE_Server,
    MSG_RAID_READY_CHECK_Server,
    SMSG_PET_ACTION_SOUND,
    SMSG_PET_DISMISS_SOUND,
    SMSG_GM_TICKET_STATUS_UPDATE,
    SMSG_UPDATE_INSTANCE_OWNERSHIP,
    SMSG_SPELLINSTAKILLLOG,
    SMSG_SPELL_UPDATE_CHAIN_TARGETS,
    SMSG_EXPECTED_SPAM_RECORDS,
    SMSG_DEFENSE_MESSAGE,
]


client_opcodes: dict[int, ClientOpcode] = {
    0x0001: CMSG_BOOTME,
    0x0002: CMSG_DBLOOKUP,
    0x0008: CMSG_WORLD_TELEPORT,
    0x0009: CMSG_TELEPORT_TO_UNIT,
    0x0036: CMSG_CHAR_CREATE,
    0x0037: CMSG_CHAR_ENUM,
    0x0038: CMSG_CHAR_DELETE,
    0x003D: CMSG_PLAYER_LOGIN,
    0x004A: CMSG_PLAYER_LOGOUT,
    0x004B: CMSG_LOGOUT_REQUEST,
    0x004E: CMSG_LOGOUT_CANCEL,
    0x0050: CMSG_NAME_QUERY,
    0x0052: CMSG_PET_NAME_QUERY,
    0x0054: CMSG_GUILD_QUERY,
    0x0056: CMSG_ITEM_QUERY_SINGLE,
    0x005A: CMSG_PAGE_TEXT_QUERY,
    0x005C: CMSG_QUEST_QUERY,
    0x005E: CMSG_GAMEOBJECT_QUERY,
    0x0060: CMSG_CREATURE_QUERY,
    0x0062: CMSG_WHO,
    0x0064: CMSG_WHOIS,
    0x0066: CMSG_FRIEND_LIST,
    0x0069: CMSG_ADD_FRIEND,
    0x006A: CMSG_DEL_FRIEND,
    0x006C: CMSG_ADD_IGNORE,
    0x006D: CMSG_DEL_IGNORE,
    0x006E: CMSG_GROUP_INVITE,
    0x0072: CMSG_GROUP_ACCEPT,
    0x0073: CMSG_GROUP_DECLINE,
    0x0075: CMSG_GROUP_UNINVITE,
    0x0076: CMSG_GROUP_UNINVITE_GUID,
    0x0078: CMSG_GROUP_SET_LEADER,
    0x007A: CMSG_LOOT_METHOD,
    0x007B: CMSG_GROUP_DISBAND,
    0x0081: CMSG_GUILD_CREATE,
    0x0082: CMSG_GUILD_INVITE,
    0x0084: CMSG_GUILD_ACCEPT,
    0x0085: CMSG_GUILD_DECLINE,
    0x0087: CMSG_GUILD_INFO,
    0x0089: CMSG_GUILD_ROSTER,
    0x008B: CMSG_GUILD_PROMOTE,
    0x008C: CMSG_GUILD_DEMOTE,
    0x008D: CMSG_GUILD_LEAVE,
    0x008E: CMSG_GUILD_REMOVE,
    0x008F: CMSG_GUILD_DISBAND,
    0x0090: CMSG_GUILD_LEADER,
    0x0091: CMSG_GUILD_MOTD,
    0x0095: CMSG_MESSAGECHAT,
    0x0097: CMSG_JOIN_CHANNEL,
    0x0098: CMSG_LEAVE_CHANNEL,
    0x009A: CMSG_CHANNEL_LIST,
    0x009C: CMSG_CHANNEL_PASSWORD,
    0x009D: CMSG_CHANNEL_SET_OWNER,
    0x009E: CMSG_CHANNEL_OWNER,
    0x009F: CMSG_CHANNEL_MODERATOR,
    0x00A0: CMSG_CHANNEL_UNMODERATOR,
    0x00A1: CMSG_CHANNEL_MUTE,
    0x00A2: CMSG_CHANNEL_UNMUTE,
    0x00A3: CMSG_CHANNEL_INVITE,
    0x00A4: CMSG_CHANNEL_KICK,
    0x00A5: CMSG_CHANNEL_BAN,
    0x00A6: CMSG_CHANNEL_UNBAN,
    0x00A7: CMSG_CHANNEL_ANNOUNCEMENTS,
    0x00A8: CMSG_CHANNEL_MODERATE,
    0x00AB: CMSG_USE_ITEM,
    0x00AC: CMSG_OPEN_ITEM,
    0x00AD: CMSG_READ_ITEM,
    0x00B1: CMSG_GAMEOBJ_USE,
    0x00B4: CMSG_AREATRIGGER,
    0x00B5: MSG_MOVE_START_FORWARD_Client,
    0x00B6: MSG_MOVE_START_BACKWARD_Client,
    0x00B7: MSG_MOVE_STOP_Client,
    0x00B8: MSG_MOVE_START_STRAFE_LEFT_Client,
    0x00B9: MSG_MOVE_START_STRAFE_RIGHT_Client,
    0x00BA: MSG_MOVE_STOP_STRAFE_Client,
    0x00BB: MSG_MOVE_JUMP_Client,
    0x00BC: MSG_MOVE_START_TURN_LEFT_Client,
    0x00BD: MSG_MOVE_START_TURN_RIGHT_Client,
    0x00BE: MSG_MOVE_STOP_TURN_Client,
    0x00BF: MSG_MOVE_START_PITCH_UP_Client,
    0x00C0: MSG_MOVE_START_PITCH_DOWN_Client,
    0x00C1: MSG_MOVE_STOP_PITCH_Client,
    0x00C2: MSG_MOVE_SET_RUN_MODE_Client,
    0x00C3: MSG_MOVE_SET_WALK_MODE_Client,
    0x00C7: MSG_MOVE_TELEPORT_ACK_Client,
    0x00C9: MSG_MOVE_FALL_LAND_Client,
    0x00CA: MSG_MOVE_START_SWIM_Client,
    0x00CB: MSG_MOVE_STOP_SWIM_Client,
    0x00DA: MSG_MOVE_SET_FACING_Client,
    0x00DB: MSG_MOVE_SET_PITCH_Client,
    0x00DC: MSG_MOVE_WORLDPORT_ACK,
    0x00E1: CMSG_MOVE_SET_RAW_POSITION,
    0x00E3: CMSG_FORCE_RUN_SPEED_CHANGE_ACK,
    0x00E5: CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK,
    0x00E7: CMSG_FORCE_SWIM_SPEED_CHANGE_ACK,
    0x00E9: CMSG_FORCE_MOVE_ROOT_ACK,
    0x00EB: CMSG_FORCE_MOVE_UNROOT_ACK,
    0x00EE: MSG_MOVE_HEARTBEAT_Client,
    0x00F0: CMSG_MOVE_KNOCK_BACK_ACK,
    0x00F6: CMSG_MOVE_HOVER_ACK,
    0x00FB: CMSG_NEXT_CINEMATIC_CAMERA,
    0x00FC: CMSG_COMPLETE_CINEMATIC,
    0x00FE: CMSG_TUTORIAL_FLAG,
    0x00FF: CMSG_TUTORIAL_CLEAR,
    0x0100: CMSG_TUTORIAL_RESET,
    0x0101: CMSG_STANDSTATECHANGE,
    0x0102: CMSG_EMOTE,
    0x0104: CMSG_TEXT_EMOTE,
    0x0108: CMSG_AUTOSTORE_LOOT_ITEM,
    0x010A: CMSG_AUTOEQUIP_ITEM,
    0x010B: CMSG_AUTOSTORE_BAG_ITEM,
    0x010C: CMSG_SWAP_ITEM,
    0x010D: CMSG_SWAP_INV_ITEM,
    0x010E: CMSG_SPLIT_ITEM,
    0x010F: CMSG_AUTOEQUIP_ITEM_SLOT,
    0x0111: CMSG_DESTROYITEM,
    0x0114: CMSG_INSPECT,
    0x0116: CMSG_INITIATE_TRADE,
    0x0117: CMSG_BEGIN_TRADE,
    0x0118: CMSG_BUSY_TRADE,
    0x0119: CMSG_IGNORE_TRADE,
    0x011A: CMSG_ACCEPT_TRADE,
    0x011B: CMSG_UNACCEPT_TRADE,
    0x011C: CMSG_CANCEL_TRADE,
    0x011D: CMSG_SET_TRADE_ITEM,
    0x011E: CMSG_CLEAR_TRADE_ITEM,
    0x011F: CMSG_SET_TRADE_GOLD,
    0x0125: CMSG_SET_FACTION_ATWAR,
    0x0128: CMSG_SET_ACTION_BUTTON,
    0x012E: CMSG_CAST_SPELL,
    0x012F: CMSG_CANCEL_CAST,
    0x0136: CMSG_CANCEL_AURA,
    0x013B: CMSG_CANCEL_CHANNELLING,
    0x013D: CMSG_SET_SELECTION,
    0x013E: CMSG_SET_TARGET_OBSOLETE,
    0x0141: CMSG_ATTACKSWING,
    0x0142: CMSG_ATTACKSTOP,
    0x015A: CMSG_REPOP_REQUEST,
    0x015C: CMSG_RESURRECT_RESPONSE,
    0x015D: CMSG_LOOT,
    0x015E: CMSG_LOOT_MONEY,
    0x015F: CMSG_LOOT_RELEASE,
    0x016C: CMSG_DUEL_ACCEPTED,
    0x016D: CMSG_DUEL_CANCELLED,
    0x0171: CMSG_MOUNTSPECIAL_ANIM,
    0x0174: CMSG_PET_SET_ACTION,
    0x0175: CMSG_PET_ACTION,
    0x0176: CMSG_PET_ABANDON,
    0x0177: CMSG_PET_RENAME,
    0x017B: CMSG_GOSSIP_HELLO,
    0x017C: CMSG_GOSSIP_SELECT_OPTION,
    0x017F: CMSG_NPC_TEXT_QUERY,
    0x0182: CMSG_QUESTGIVER_STATUS_QUERY,
    0x0184: CMSG_QUESTGIVER_HELLO,
    0x0186: CMSG_QUESTGIVER_QUERY_QUEST,
    0x0187: CMSG_QUESTGIVER_QUEST_AUTOLAUNCH,
    0x0189: CMSG_QUESTGIVER_ACCEPT_QUEST,
    0x018A: CMSG_QUESTGIVER_COMPLETE_QUEST,
    0x018C: CMSG_QUESTGIVER_REQUEST_REWARD,
    0x018E: CMSG_QUESTGIVER_CHOOSE_REWARD,
    0x0190: CMSG_QUESTGIVER_CANCEL,
    0x0193: CMSG_QUESTLOG_SWAP_QUEST,
    0x0194: CMSG_QUESTLOG_REMOVE_QUEST,
    0x019B: CMSG_QUEST_CONFIRM_ACCEPT,
    0x019D: CMSG_PUSHQUESTTOPARTY,
    0x019E: CMSG_LIST_INVENTORY,
    0x01A0: CMSG_SELL_ITEM,
    0x01A2: CMSG_BUY_ITEM,
    0x01A3: CMSG_BUY_ITEM_IN_SLOT,
    0x01AA: CMSG_TAXINODE_STATUS_QUERY,
    0x01AC: CMSG_TAXIQUERYAVAILABLENODES,
    0x01AD: CMSG_ACTIVATETAXI,
    0x01B0: CMSG_TRAINER_LIST,
    0x01B2: CMSG_TRAINER_BUY_SPELL,
    0x01B5: CMSG_BINDER_ACTIVATE,
    0x01B7: CMSG_BANKER_ACTIVATE,
    0x01B9: CMSG_BUY_BANK_SLOT,
    0x01BB: CMSG_PETITION_SHOWLIST,
    0x01BD: CMSG_PETITION_BUY,
    0x01BE: CMSG_PETITION_SHOW_SIGNATURES,
    0x01C0: CMSG_PETITION_SIGN,
    0x01C2: MSG_PETITION_DECLINE,
    0x01C3: CMSG_OFFER_PETITION,
    0x01C4: CMSG_TURN_IN_PETITION,
    0x01C6: CMSG_PETITION_QUERY,
    0x01CA: CMSG_BUG,
    0x01CC: CMSG_PLAYED_TIME,
    0x01CE: CMSG_QUERY_TIME,
    0x01D2: CMSG_RECLAIM_CORPSE,
    0x01D3: CMSG_WRAP_ITEM,
    0x01D5: MSG_MINIMAP_PING_Client,
    0x01DC: CMSG_PING,
    0x01E0: CMSG_SETSHEATHED,
    0x01ED: CMSG_AUTH_SESSION,
    0x01F0: CMSG_PET_CAST_SPELL,
    0x01F1: MSG_SAVE_GUILD_EMBLEM_Client,
    0x01F2: MSG_TABARDVENDOR_ACTIVATE,
    0x01F4: CMSG_ZONEUPDATE,
    0x01FB: MSG_RANDOM_ROLL_Client,
    0x01FF: MSG_LOOKING_FOR_GROUP_Client,
    0x0202: CMSG_UNLEARN_SKILL,
    0x0205: CMSG_GMTICKET_CREATE,
    0x0207: CMSG_GMTICKET_UPDATETEXT,
    0x020A: CMSG_REQUEST_ACCOUNT_DATA,
    0x020B: CMSG_UPDATE_ACCOUNT_DATA,
    0x0211: CMSG_GMTICKET_GETTICKET,
    0x0216: MSG_CORPSE_QUERY_Client,
    0x0217: CMSG_GMTICKET_DELETETICKET,
    0x021A: CMSG_GMTICKET_SYSTEMSTATUS,
    0x021C: CMSG_SPIRIT_HEALER_ACTIVATE,
    0x0225: CMSG_CHAT_IGNORED,
    0x0231: CMSG_GUILD_RANK,
    0x0232: CMSG_GUILD_ADD_RANK,
    0x0233: CMSG_GUILD_DEL_RANK,
    0x0234: CMSG_GUILD_SET_PUBLIC_NOTE,
    0x0235: CMSG_GUILD_SET_OFFICER_NOTE,
    0x0238: CMSG_SEND_MAIL,
    0x023A: CMSG_GET_MAIL_LIST,
    0x023C: CMSG_BATTLEFIELD_LIST,
    0x023E: CMSG_BATTLEFIELD_JOIN,
    0x0243: CMSG_ITEM_TEXT_QUERY,
    0x0245: CMSG_MAIL_TAKE_MONEY,
    0x0246: CMSG_MAIL_TAKE_ITEM,
    0x0247: CMSG_MAIL_MARK_AS_READ,
    0x0248: CMSG_MAIL_RETURN_TO_SENDER,
    0x0249: CMSG_MAIL_DELETE,
    0x024A: CMSG_MAIL_CREATE_TEXT_ITEM,
    0x0251: CMSG_LEARN_TALENT,
    0x0253: CMSG_TOGGLE_PVP,
    0x0255: MSG_AUCTION_HELLO_Client,
    0x0256: CMSG_AUCTION_SELL_ITEM,
    0x0257: CMSG_AUCTION_REMOVE_ITEM,
    0x0258: CMSG_AUCTION_LIST_ITEMS,
    0x0259: CMSG_AUCTION_LIST_OWNER_ITEMS,
    0x025A: CMSG_AUCTION_PLACE_BID,
    0x0264: CMSG_AUCTION_LIST_BIDDER_ITEMS,
    0x0268: CMSG_SET_AMMO,
    0x026A: CMSG_SET_ACTIVE_MOVER,
    0x026B: CMSG_PET_CANCEL_AURA,
    0x026D: CMSG_CANCEL_AUTO_REPEAT_SPELL,
    0x026F: MSG_LIST_STABLED_PETS_Client,
    0x0270: CMSG_STABLE_PET,
    0x0271: CMSG_UNSTABLE_PET,
    0x0272: CMSG_BUY_STABLE_SLOT,
    0x0275: CMSG_STABLE_SWAP_PET,
    0x0276: MSG_QUEST_PUSH_RESULT,
    0x0279: CMSG_REQUEST_PET_INFO,
    0x027A: CMSG_FAR_SIGHT,
    0x027E: CMSG_GROUP_CHANGE_SUB_GROUP,
    0x027F: CMSG_REQUEST_PARTY_MEMBER_STATS,
    0x0280: CMSG_GROUP_SWAP_SUB_GROUP,
    0x0282: CMSG_AUTOSTORE_BANK_ITEM,
    0x0283: CMSG_AUTOBANK_ITEM,
    0x0284: MSG_QUERY_NEXT_MAIL_TIME_Client,
    0x028E: CMSG_GROUP_RAID_CONVERT,
    0x028F: CMSG_GROUP_ASSISTANT_LEADER,
    0x0290: CMSG_BUYBACK_ITEM,
    0x0292: CMSG_MEETINGSTONE_JOIN,
    0x0293: CMSG_MEETINGSTONE_LEAVE,
    0x0296: CMSG_MEETINGSTONE_INFO,
    0x029B: CMSG_CANCEL_GROWTH_AURA,
    0x02A0: CMSG_LOOT_ROLL,
    0x02A3: CMSG_LOOT_MASTER_GIVE,
    0x02A8: CMSG_REPAIR_ITEM,
    0x02AA: MSG_TALENT_WIPE_CONFIRM_Client,
    0x02AC: CMSG_SUMMON_RESPONSE,
    0x02B1: MSG_MOVE_WATER_WALK,
    0x02B3: CMSG_SELF_RES,
    0x02B9: CMSG_TOGGLE_HELM,
    0x02BA: CMSG_TOGGLE_CLOAK,
    0x02BF: CMSG_SET_ACTIONBAR_TOGGLES,
    0x02C1: MSG_PETITION_RENAME,
    0x02C4: CMSG_ITEM_NAME_QUERY,
    0x02C7: CMSG_CHAR_RENAME,
    0x02C9: CMSG_MOVE_SPLINE_DONE,
    0x02CA: CMSG_MOVE_FALL_RESET,
    0x02CD: CMSG_REQUEST_RAID_INFO,
    0x02CE: CMSG_MOVE_TIME_SKIPPED,
    0x02CF: CMSG_MOVE_FEATHER_FALL_ACK,
    0x02D0: CMSG_MOVE_WATER_WALK_ACK,
    0x02D1: CMSG_MOVE_NOT_ACTIVE_MOVER,
    0x02D3: CMSG_BATTLEFIELD_STATUS,
    0x02D5: CMSG_BATTLEFIELD_PORT,
    0x02D6: MSG_INSPECT_HONOR_STATS_Client,
    0x02D7: CMSG_BATTLEMASTER_HELLO,
    0x02DB: CMSG_FORCE_WALK_SPEED_CHANGE_ACK,
    0x02DD: CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK,
    0x02DF: CMSG_FORCE_TURN_RATE_CHANGE_ACK,
    0x02E0: MSG_PVP_LOG_DATA_Client,
    0x02E1: CMSG_LEAVE_BATTLEFIELD,
    0x02E2: CMSG_AREA_SPIRIT_HEALER_QUERY,
    0x02E3: CMSG_AREA_SPIRIT_HEALER_QUEUE,
    0x02E7: CMSG_WARDEN_DATA,
    0x02E9: MSG_BATTLEGROUND_PLAYER_POSITIONS_Client,
    0x02EA: CMSG_PET_STOP_ATTACK,
    0x02EE: CMSG_BATTLEMASTER_JOIN,
    0x02F0: CMSG_PET_UNLEARN,
    0x02F3: CMSG_PET_SPELL_AUTOCAST,
    0x02FC: CMSG_GUILD_INFO_TEXT,
    0x0312: CMSG_ACTIVATETAXIEXPRESS,
    0x0317: CMSG_SET_FACTION_INACTIVE,
    0x0318: CMSG_SET_WATCHED_FACTION,
    0x031D: CMSG_RESET_INSTANCES,
    0x0321: MSG_RAID_TARGET_UPDATE_Client,
    0x0322: MSG_RAID_READY_CHECK_Client,
    0x032A: CMSG_GMSURVEY_SUBMIT,
}


async def read_client_opcode_body(
    reader: asyncio.StreamReader,
    opcode: int,
    body_size: int,
) -> ClientOpcode:
    return await client_opcodes[opcode].read(reader, body_size)


server_opcodes: dict[int, ServerOpcode] = {
    0x003A: SMSG_CHAR_CREATE,
    0x003B: SMSG_CHAR_ENUM,
    0x003C: SMSG_CHAR_DELETE,
    0x003E: SMSG_NEW_WORLD,
    0x003F: SMSG_TRANSFER_PENDING,
    0x0040: SMSG_TRANSFER_ABORTED,
    0x0041: SMSG_CHARACTER_LOGIN_FAILED,
    0x0042: SMSG_LOGIN_SETTIMESPEED,
    0x004C: SMSG_LOGOUT_RESPONSE,
    0x004D: SMSG_LOGOUT_COMPLETE,
    0x004F: SMSG_LOGOUT_CANCEL_ACK,
    0x0051: SMSG_NAME_QUERY_RESPONSE,
    0x0053: SMSG_PET_NAME_QUERY_RESPONSE,
    0x0055: SMSG_GUILD_QUERY_RESPONSE,
    0x0058: SMSG_ITEM_QUERY_SINGLE_RESPONSE,
    0x005B: SMSG_PAGE_TEXT_QUERY_RESPONSE,
    0x005D: SMSG_QUEST_QUERY_RESPONSE,
    0x005F: SMSG_GAMEOBJECT_QUERY_RESPONSE,
    0x0061: SMSG_CREATURE_QUERY_RESPONSE,
    0x0063: SMSG_WHO,
    0x0065: SMSG_WHOIS,
    0x0067: SMSG_FRIEND_LIST,
    0x0068: SMSG_FRIEND_STATUS,
    0x006B: SMSG_IGNORE_LIST,
    0x006F: SMSG_GROUP_INVITE,
    0x0074: SMSG_GROUP_DECLINE,
    0x0077: SMSG_GROUP_UNINVITE,
    0x0079: SMSG_GROUP_SET_LEADER,
    0x007C: SMSG_GROUP_DESTROYED,
    0x007D: SMSG_GROUP_LIST,
    0x007E: SMSG_PARTY_MEMBER_STATS,
    0x007F: SMSG_PARTY_COMMAND_RESULT,
    0x0083: SMSG_GUILD_INVITE,
    0x0088: SMSG_GUILD_INFO,
    0x008A: SMSG_GUILD_ROSTER,
    0x0092: SMSG_GUILD_EVENT,
    0x0093: SMSG_GUILD_COMMAND_RESULT,
    0x0096: SMSG_MESSAGECHAT,
    0x0099: SMSG_CHANNEL_NOTIFY,
    0x009B: SMSG_CHANNEL_LIST,
    0x00A9: SMSG_UPDATE_OBJECT,
    0x00AA: SMSG_DESTROY_OBJECT,
    0x00AE: SMSG_READ_ITEM_OK,
    0x00AF: SMSG_READ_ITEM_FAILED,
    0x00B0: SMSG_ITEM_COOLDOWN,
    0x00B3: SMSG_GAMEOBJECT_CUSTOM_ANIM,
    0x00B5: MSG_MOVE_START_FORWARD_Server,
    0x00B6: MSG_MOVE_START_BACKWARD_Server,
    0x00B7: MSG_MOVE_STOP_Server,
    0x00B8: MSG_MOVE_START_STRAFE_LEFT_Server,
    0x00B9: MSG_MOVE_START_STRAFE_RIGHT_Server,
    0x00BA: MSG_MOVE_STOP_STRAFE_Server,
    0x00BB: MSG_MOVE_JUMP_Server,
    0x00BC: MSG_MOVE_START_TURN_LEFT_Server,
    0x00BD: MSG_MOVE_START_TURN_RIGHT_Server,
    0x00BE: MSG_MOVE_STOP_TURN_Server,
    0x00BF: MSG_MOVE_START_PITCH_UP_Server,
    0x00C0: MSG_MOVE_START_PITCH_DOWN_Server,
    0x00C1: MSG_MOVE_STOP_PITCH_Server,
    0x00C2: MSG_MOVE_SET_RUN_MODE_Server,
    0x00C3: MSG_MOVE_SET_WALK_MODE_Server,
    0x00C7: MSG_MOVE_TELEPORT_ACK_Server,
    0x00C9: MSG_MOVE_FALL_LAND_Server,
    0x00CA: MSG_MOVE_START_SWIM_Server,
    0x00CB: MSG_MOVE_STOP_SWIM_Server,
    0x00DA: MSG_MOVE_SET_FACING_Server,
    0x00DB: MSG_MOVE_SET_PITCH_Server,
    0x00DC: MSG_MOVE_WORLDPORT_ACK,
    0x00DD: SMSG_MONSTER_MOVE,
    0x00DE: SMSG_MOVE_WATER_WALK,
    0x00DF: SMSG_MOVE_LAND_WALK,
    0x00E2: SMSG_FORCE_RUN_SPEED_CHANGE,
    0x00E4: SMSG_FORCE_RUN_BACK_SPEED_CHANGE,
    0x00E6: SMSG_FORCE_SWIM_SPEED_CHANGE,
    0x00E8: SMSG_FORCE_MOVE_ROOT,
    0x00EA: SMSG_FORCE_MOVE_UNROOT,
    0x00EE: MSG_MOVE_HEARTBEAT_Server,
    0x00EF: SMSG_MOVE_KNOCK_BACK,
    0x00F2: SMSG_MOVE_FEATHER_FALL,
    0x00F3: SMSG_MOVE_NORMAL_FALL,
    0x00F4: SMSG_MOVE_SET_HOVER,
    0x00F5: SMSG_MOVE_UNSET_HOVER,
    0x00FA: SMSG_TRIGGER_CINEMATIC,
    0x00FD: SMSG_TUTORIAL_FLAGS,
    0x0103: SMSG_EMOTE,
    0x0105: SMSG_TEXT_EMOTE,
    0x0112: SMSG_INVENTORY_CHANGE_FAILURE,
    0x0113: SMSG_OPEN_CONTAINER,
    0x0115: SMSG_INSPECT,
    0x0120: SMSG_TRADE_STATUS,
    0x0121: SMSG_TRADE_STATUS_EXTENDED,
    0x0122: SMSG_INITIALIZE_FACTIONS,
    0x0123: SMSG_SET_FACTION_VISIBLE,
    0x0124: SMSG_SET_FACTION_STANDING,
    0x0127: SMSG_SET_PROFICIENCY,
    0x0129: SMSG_ACTION_BUTTONS,
    0x012A: SMSG_INITIAL_SPELLS,
    0x012B: SMSG_LEARNED_SPELL,
    0x012C: SMSG_SUPERCEDED_SPELL,
    0x0130: SMSG_CAST_RESULT,
    0x0131: SMSG_SPELL_START,
    0x0132: SMSG_SPELL_GO,
    0x0133: SMSG_SPELL_FAILURE,
    0x0134: SMSG_SPELL_COOLDOWN,
    0x0135: SMSG_COOLDOWN_EVENT,
    0x0137: SMSG_UPDATE_AURA_DURATION,
    0x0138: SMSG_PET_CAST_FAILED,
    0x0139: MSG_CHANNEL_START_Server,
    0x013A: MSG_CHANNEL_UPDATE_Server,
    0x013C: SMSG_AI_REACTION,
    0x0143: SMSG_ATTACKSTART,
    0x0144: SMSG_ATTACKSTOP,
    0x0145: SMSG_ATTACKSWING_NOTINRANGE,
    0x0146: SMSG_ATTACKSWING_BADFACING,
    0x0147: SMSG_ATTACKSWING_NOTSTANDING,
    0x0148: SMSG_ATTACKSWING_DEADTARGET,
    0x0149: SMSG_ATTACKSWING_CANT_ATTACK,
    0x014A: SMSG_ATTACKERSTATEUPDATE,
    0x014E: SMSG_CANCEL_COMBAT,
    0x0150: SMSG_SPELLHEALLOG,
    0x0151: SMSG_SPELLENERGIZELOG,
    0x0155: SMSG_BINDPOINTUPDATE,
    0x0158: SMSG_PLAYERBOUND,
    0x0159: SMSG_CLIENT_CONTROL_UPDATE,
    0x015B: SMSG_RESURRECT_REQUEST,
    0x0160: SMSG_LOOT_RESPONSE,
    0x0161: SMSG_LOOT_RELEASE_RESPONSE,
    0x0162: SMSG_LOOT_REMOVED,
    0x0163: SMSG_LOOT_MONEY_NOTIFY,
    0x0165: SMSG_LOOT_CLEAR_MONEY,
    0x0166: SMSG_ITEM_PUSH_RESULT,
    0x0167: SMSG_DUEL_REQUESTED,
    0x0168: SMSG_DUEL_OUTOFBOUNDS,
    0x0169: SMSG_DUEL_INBOUNDS,
    0x016A: SMSG_DUEL_COMPLETE,
    0x016B: SMSG_DUEL_WINNER,
    0x016E: SMSG_MOUNTRESULT,
    0x016F: SMSG_DISMOUNTRESULT,
    0x0172: SMSG_MOUNTSPECIAL_ANIM,
    0x0173: SMSG_PET_TAME_FAILURE,
    0x0178: SMSG_PET_NAME_INVALID,
    0x0179: SMSG_PET_SPELLS,
    0x017A: SMSG_PET_MODE,
    0x017D: SMSG_GOSSIP_MESSAGE,
    0x017E: SMSG_GOSSIP_COMPLETE,
    0x0180: SMSG_NPC_TEXT_UPDATE,
    0x0183: SMSG_QUESTGIVER_STATUS,
    0x0185: SMSG_QUESTGIVER_QUEST_LIST,
    0x0188: SMSG_QUESTGIVER_QUEST_DETAILS,
    0x018B: SMSG_QUESTGIVER_REQUEST_ITEMS,
    0x018D: SMSG_QUESTGIVER_OFFER_REWARD,
    0x018F: SMSG_QUESTGIVER_QUEST_INVALID,
    0x0191: SMSG_QUESTGIVER_QUEST_COMPLETE,
    0x0192: SMSG_QUESTGIVER_QUEST_FAILED,
    0x0195: SMSG_QUESTLOG_FULL,
    0x0196: SMSG_QUESTUPDATE_FAILED,
    0x0197: SMSG_QUESTUPDATE_FAILEDTIMER,
    0x0198: SMSG_QUESTUPDATE_COMPLETE,
    0x0199: SMSG_QUESTUPDATE_ADD_KILL,
    0x019A: SMSG_QUESTUPDATE_ADD_ITEM,
    0x019C: SMSG_QUEST_CONFIRM_ACCEPT,
    0x019F: SMSG_LIST_INVENTORY,
    0x01A1: SMSG_SELL_ITEM,
    0x01A4: SMSG_BUY_ITEM,
    0x01A5: SMSG_BUY_FAILED,
    0x01A9: SMSG_SHOWTAXINODES,
    0x01AB: SMSG_TAXINODE_STATUS,
    0x01AE: SMSG_ACTIVATETAXIREPLY,
    0x01AF: SMSG_NEW_TAXI_PATH,
    0x01B1: SMSG_TRAINER_LIST,
    0x01B3: SMSG_TRAINER_BUY_SUCCEEDED,
    0x01B4: SMSG_TRAINER_BUY_FAILED,
    0x01B8: SMSG_SHOW_BANK,
    0x01BA: SMSG_BUY_BANK_SLOT_RESULT,
    0x01BC: SMSG_PETITION_SHOWLIST,
    0x01BF: SMSG_PETITION_SHOW_SIGNATURES,
    0x01C1: SMSG_PETITION_SIGN_RESULTS,
    0x01C2: MSG_PETITION_DECLINE,
    0x01C5: SMSG_TURN_IN_PETITION_RESULTS,
    0x01C7: SMSG_PETITION_QUERY_RESPONSE,
    0x01C8: SMSG_FISH_NOT_HOOKED,
    0x01C9: SMSG_FISH_ESCAPED,
    0x01CB: SMSG_NOTIFICATION,
    0x01CD: SMSG_PLAYED_TIME,
    0x01CF: SMSG_QUERY_TIME_RESPONSE,
    0x01D0: SMSG_LOG_XPGAIN,
    0x01D4: SMSG_LEVELUP_INFO,
    0x01D5: MSG_MINIMAP_PING_Server,
    0x01D6: SMSG_RESISTLOG,
    0x01D7: SMSG_ENCHANTMENTLOG,
    0x01D9: SMSG_START_MIRROR_TIMER,
    0x01DA: SMSG_PAUSE_MIRROR_TIMER,
    0x01DB: SMSG_STOP_MIRROR_TIMER,
    0x01DD: SMSG_PONG,
    0x01DE: SMSG_CLEAR_COOLDOWN,
    0x01DF: SMSG_GAMEOBJECT_PAGETEXT,
    0x01E2: SMSG_SPELL_DELAYED,
    0x01EA: SMSG_ITEM_TIME_UPDATE,
    0x01EB: SMSG_ITEM_ENCHANT_TIME_UPDATE,
    0x01EC: SMSG_AUTH_CHALLENGE,
    0x01EE: SMSG_AUTH_RESPONSE,
    0x01F1: MSG_SAVE_GUILD_EMBLEM_Server,
    0x01F2: MSG_TABARDVENDOR_ACTIVATE,
    0x01F3: SMSG_PLAY_SPELL_VISUAL,
    0x01F5: SMSG_PARTYKILLLOG,
    0x01F6: SMSG_COMPRESSED_UPDATE_OBJECT,
    0x01F7: SMSG_PLAY_SPELL_IMPACT,
    0x01F8: SMSG_EXPLORATION_EXPERIENCE,
    0x01FB: MSG_RANDOM_ROLL_Server,
    0x01FC: SMSG_ENVIRONMENTAL_DAMAGE_LOG,
    0x01FF: MSG_LOOKING_FOR_GROUP_Server,
    0x0203: SMSG_REMOVED_SPELL,
    0x0206: SMSG_GMTICKET_CREATE,
    0x0208: SMSG_GMTICKET_UPDATETEXT,
    0x0209: SMSG_ACCOUNT_DATA_TIMES,
    0x0212: SMSG_GMTICKET_GETTICKET,
    0x0214: SMSG_GAMEOBJECT_SPAWN_ANIM,
    0x0215: SMSG_GAMEOBJECT_DESPAWN_ANIM,
    0x0216: MSG_CORPSE_QUERY_Server,
    0x0218: SMSG_GMTICKET_DELETETICKET,
    0x0219: SMSG_CHAT_WRONG_FACTION,
    0x021B: SMSG_GMTICKET_SYSTEMSTATUS,
    0x021E: SMSG_SET_REST_START,
    0x0222: SMSG_SPIRIT_HEALER_CONFIRM,
    0x0224: SMSG_GOSSIP_POI,
    0x0236: SMSG_LOGIN_VERIFY_WORLD,
    0x0239: SMSG_SEND_MAIL_RESULT,
    0x023B: SMSG_MAIL_LIST_RESULT,
    0x023D: SMSG_BATTLEFIELD_LIST,
    0x0244: SMSG_ITEM_TEXT_QUERY_RESPONSE,
    0x024B: SMSG_SPELLLOGMISS,
    0x024C: SMSG_SPELLLOGEXECUTE,
    0x024E: SMSG_PERIODICAURALOG,
    0x024F: SMSG_SPELLDAMAGESHIELD,
    0x0250: SMSG_SPELLNONMELEEDAMAGELOG,
    0x0254: SMSG_ZONE_UNDER_ATTACK,
    0x0255: MSG_AUCTION_HELLO_Server,
    0x025B: SMSG_AUCTION_COMMAND_RESULT,
    0x025C: SMSG_AUCTION_LIST_RESULT,
    0x025D: SMSG_AUCTION_OWNER_LIST_RESULT,
    0x025E: SMSG_AUCTION_BIDDER_NOTIFICATION,
    0x025F: SMSG_AUCTION_OWNER_NOTIFICATION,
    0x0260: SMSG_PROCRESIST,
    0x0262: SMSG_DISPEL_FAILED,
    0x0263: SMSG_SPELLORDAMAGE_IMMUNE,
    0x0265: SMSG_AUCTION_BIDDER_LIST_RESULT,
    0x0266: SMSG_SET_FLAT_SPELL_MODIFIER,
    0x0267: SMSG_SET_PCT_SPELL_MODIFIER,
    0x0269: SMSG_CORPSE_RECLAIM_DELAY,
    0x026F: MSG_LIST_STABLED_PETS_Server,
    0x0273: SMSG_STABLE_RESULT,
    0x0276: MSG_QUEST_PUSH_RESULT,
    0x0277: SMSG_PLAY_MUSIC,
    0x0278: SMSG_PLAY_OBJECT_SOUND,
    0x027B: SMSG_SPELLDISPELLOG,
    0x0284: MSG_QUERY_NEXT_MAIL_TIME_Server,
    0x0285: SMSG_RECEIVED_MAIL,
    0x0286: SMSG_RAID_GROUP_ONLY,
    0x028C: SMSG_PVP_CREDIT,
    0x028D: SMSG_AUCTION_REMOVED_NOTIFICATION,
    0x0291: SMSG_SERVER_MESSAGE,
    0x0295: SMSG_MEETINGSTONE_SETQUEUE,
    0x0297: SMSG_MEETINGSTONE_COMPLETE,
    0x0298: SMSG_MEETINGSTONE_IN_PROGRESS,
    0x0299: SMSG_MEETINGSTONE_MEMBER_ADDED,
    0x029C: SMSG_CANCEL_AUTO_REPEAT,
    0x029D: SMSG_STANDSTATE_UPDATE,
    0x029E: SMSG_LOOT_ALL_PASSED,
    0x029F: SMSG_LOOT_ROLL_WON,
    0x02A1: SMSG_LOOT_START_ROLL,
    0x02A2: SMSG_LOOT_ROLL,
    0x02A4: SMSG_LOOT_MASTER_LIST,
    0x02A5: SMSG_SET_FORCED_REACTIONS,
    0x02A6: SMSG_SPELL_FAILED_OTHER,
    0x02A7: SMSG_GAMEOBJECT_RESET_STATE,
    0x02A9: SMSG_CHAT_PLAYER_NOT_FOUND,
    0x02AA: MSG_TALENT_WIPE_CONFIRM_Server,
    0x02AB: SMSG_SUMMON_REQUEST,
    0x02AE: SMSG_MONSTER_MOVE_TRANSPORT,
    0x02AF: SMSG_PET_BROKEN,
    0x02B0: MSG_MOVE_FEATHER_FALL_Server,
    0x02B1: MSG_MOVE_WATER_WALK,
    0x02B4: SMSG_FEIGN_DEATH_RESISTED,
    0x02B7: SMSG_DUEL_COUNTDOWN,
    0x02B8: SMSG_AREA_TRIGGER_MESSAGE,
    0x02BB: SMSG_MEETINGSTONE_JOINFAILED,
    0x02BC: SMSG_PLAYER_SKINNED,
    0x02BD: SMSG_DURABILITY_DAMAGE_DEATH,
    0x02C1: MSG_PETITION_RENAME,
    0x02C2: SMSG_INIT_WORLD_STATES,
    0x02C3: SMSG_UPDATE_WORLD_STATE,
    0x02C5: SMSG_ITEM_NAME_QUERY_RESPONSE,
    0x02C6: SMSG_PET_ACTION_FEEDBACK,
    0x02C8: SMSG_CHAR_RENAME,
    0x02CB: SMSG_INSTANCE_SAVE_CREATED,
    0x02CC: SMSG_RAID_INSTANCE_INFO,
    0x02D2: SMSG_PLAY_SOUND,
    0x02D4: SMSG_BATTLEFIELD_STATUS,
    0x02D6: MSG_INSPECT_HONOR_STATS_Server,
    0x02DA: SMSG_FORCE_WALK_SPEED_CHANGE,
    0x02DC: SMSG_FORCE_SWIM_BACK_SPEED_CHANGE,
    0x02DE: SMSG_FORCE_TURN_RATE_CHANGE,
    0x02E0: MSG_PVP_LOG_DATA_Server,
    0x02E4: SMSG_AREA_SPIRIT_HEALER_TIME,
    0x02E6: SMSG_WARDEN_DATA,
    0x02E8: SMSG_GROUP_JOINED_BATTLEGROUND,
    0x02E9: MSG_BATTLEGROUND_PLAYER_POSITIONS_Server,
    0x02EB: SMSG_BINDER_CONFIRM,
    0x02EC: SMSG_BATTLEGROUND_PLAYER_JOINED,
    0x02ED: SMSG_BATTLEGROUND_PLAYER_LEFT,
    0x02EF: SMSG_ADDON_INFO,
    0x02F1: SMSG_PET_UNLEARN_CONFIRM,
    0x02F2: SMSG_PARTY_MEMBER_STATS_FULL,
    0x02F4: SMSG_WEATHER,
    0x02FA: SMSG_RAID_INSTANCE_MESSAGE,
    0x02FB: SMSG_COMPRESSED_MOVES,
    0x02FD: SMSG_CHAT_RESTRICTED,
    0x02FE: SMSG_SPLINE_SET_RUN_SPEED,
    0x02FF: SMSG_SPLINE_SET_RUN_BACK_SPEED,
    0x0300: SMSG_SPLINE_SET_SWIM_SPEED,
    0x0301: SMSG_SPLINE_SET_WALK_SPEED,
    0x0302: SMSG_SPLINE_SET_SWIM_BACK_SPEED,
    0x0303: SMSG_SPLINE_SET_TURN_RATE,
    0x0304: SMSG_SPLINE_MOVE_UNROOT,
    0x0305: SMSG_SPLINE_MOVE_FEATHER_FALL,
    0x0306: SMSG_SPLINE_MOVE_NORMAL_FALL,
    0x0307: SMSG_SPLINE_MOVE_SET_HOVER,
    0x0308: SMSG_SPLINE_MOVE_UNSET_HOVER,
    0x0309: SMSG_SPLINE_MOVE_WATER_WALK,
    0x030A: SMSG_SPLINE_MOVE_LAND_WALK,
    0x030B: SMSG_SPLINE_MOVE_START_SWIM,
    0x030C: SMSG_SPLINE_MOVE_STOP_SWIM,
    0x030D: SMSG_SPLINE_MOVE_SET_RUN_MODE,
    0x030E: SMSG_SPLINE_MOVE_SET_WALK_MODE,
    0x0319: MSG_MOVE_TIME_SKIPPED_Server,
    0x031A: SMSG_SPLINE_MOVE_ROOT,
    0x031C: SMSG_INVALIDATE_PLAYER,
    0x031E: SMSG_INSTANCE_RESET,
    0x031F: SMSG_INSTANCE_RESET_FAILED,
    0x0320: SMSG_UPDATE_LAST_INSTANCE,
    0x0321: MSG_RAID_TARGET_UPDATE_Server,
    0x0322: MSG_RAID_READY_CHECK_Server,
    0x0324: SMSG_PET_ACTION_SOUND,
    0x0325: SMSG_PET_DISMISS_SOUND,
    0x0328: SMSG_GM_TICKET_STATUS_UPDATE,
    0x032B: SMSG_UPDATE_INSTANCE_OWNERSHIP,
    0x032F: SMSG_SPELLINSTAKILLLOG,
    0x0330: SMSG_SPELL_UPDATE_CHAIN_TARGETS,
    0x0332: SMSG_EXPECTED_SPAM_RECORDS,
    0x033B: SMSG_DEFENSE_MESSAGE,
}


async def read_server_opcode_body(
    reader: asyncio.StreamReader,
    opcode: int,
    body_size: int,
) -> ServerOpcode:
    return await server_opcodes[opcode].read(reader, body_size)


async def read_client_opcodes_unencrypted(reader: asyncio.StreamReader) -> ClientOpcode:
    opcode_size = 2
    size_field_size = 4

    size = int.from_bytes(await reader.readexactly(opcode_size), "big")
    opcode = int.from_bytes(await reader.readexactly(size_field_size), "little")

    body_size = size - size_field_size
    body = await reader.readexactly(body_size)
    body_reader = asyncio.StreamReader()
    body_reader.feed_data(body)
    body_reader.feed_eof()

    return await read_client_opcode_body(body_reader, opcode, body_size)


async def read_client_opcodes_encrypted(
    reader: asyncio.StreamReader,
    header_crypto: wow_srp.VanillaHeaderCrypto,
) -> ClientOpcode:
    size_field_size = 4
    header_size = 6

    data = await reader.readexactly(header_size)

    size, opcode = header_crypto.decrypt_client_header(data)

    body_size = size - size_field_size
    body = await reader.readexactly(body_size)
    body_reader = asyncio.StreamReader()
    body_reader.feed_data(body)
    body_reader.feed_eof()

    return await read_client_opcode_body(body_reader, opcode, body_size)


async def read_server_opcodes_unencrypted(reader: asyncio.StreamReader) -> ServerOpcode:
    opcode_size = 2
    size_field_size = 2

    size = int.from_bytes(await reader.readexactly(opcode_size), "big")
    opcode = int.from_bytes(await reader.readexactly(size_field_size), "little")

    body_size = size - size_field_size
    body = await reader.readexactly(body_size)
    body_reader = asyncio.StreamReader()
    body_reader.feed_data(body)
    body_reader.feed_eof()

    return await read_server_opcode_body(body_reader, opcode, body_size)


async def read_server_opcodes_encrypted(
    reader: asyncio.StreamReader,
    header_crypto: wow_srp.VanillaHeaderCrypto,
) -> ServerOpcode:
    size_field_size = 2
    header_size = 4

    data = await reader.readexactly(header_size)

    size, opcode = header_crypto.decrypt_client_header(data)

    body_size = size - size_field_size
    body = await reader.readexactly(body_size)
    body_reader = asyncio.StreamReader()
    body_reader.feed_data(body)
    body_reader.feed_eof()

    return await read_server_opcode_body(body_reader, opcode, body_size)


async def expect_client_opcode_unencrypted(
    reader: asyncio.StreamReader,
    opcode: typing.Type[ClientOpcode],
) -> typing.Optional[ClientOpcode]:
    o = await read_client_opcodes_unencrypted(reader)
    if isinstance(o, opcode):
        return o
    else:
        return None


async def expect_client_opcode_encrypted(
    reader: asyncio.StreamReader,
    opcode: typing.Type[ClientOpcode],
    header_crypto: wow_srp.VanillaHeaderCrypto,
) -> typing.Optional[ClientOpcode]:
    o = await read_client_opcodes_encrypted(reader, header_crypto)
    if isinstance(o, opcode):
        return o
    else:
        return None


async def expect_server_opcode_unencrypted(
    reader: asyncio.StreamReader,
    opcode: typing.Type[ServerOpcode],
) -> typing.Optional[ServerOpcode]:
    o = await read_server_opcodes_unencrypted(reader)
    if isinstance(o, opcode):
        return o
    else:
        return None


async def expect_server_opcode_encrypted(
    reader: asyncio.StreamReader,
    opcode: typing.Type[ServerOpcode],
    header_crypto: wow_srp.VanillaHeaderCrypto,
) -> typing.Optional[ServerOpcode]:
    o = await read_server_opcodes_encrypted(reader, header_crypto)
    if isinstance(o, opcode):
        return o
    else:
        return None


