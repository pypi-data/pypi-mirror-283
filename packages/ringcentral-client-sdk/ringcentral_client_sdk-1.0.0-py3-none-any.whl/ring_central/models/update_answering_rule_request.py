# This file was generated by liblab | https://liblab.com/

from __future__ import annotations
from enum import Enum
from typing import List
from .utils.json_map import JsonMap
from .base import BaseModel
from .forwarding_info_create_rule_request import ForwardingInfoCreateRuleRequest
from .callers_info_request import CallersInfoRequest
from .called_number_info import CalledNumberInfo
from .schedule_info import ScheduleInfo
from .unconditional_forwarding_info import UnconditionalForwardingInfo
from .queue_info import QueueInfo
from .voicemail_info import VoicemailInfo
from .missed_call_info import MissedCallInfo
from .greeting_info import GreetingInfo
from .transferred_extension_info import TransferredExtensionInfo


class UpdateAnsweringRuleRequestCallHandlingAction(Enum):
    """An enumeration representing different categories.

    :cvar FORWARDCALLS: "ForwardCalls"
    :vartype FORWARDCALLS: str
    :cvar UNCONDITIONALFORWARDING: "UnconditionalForwarding"
    :vartype UNCONDITIONALFORWARDING: str
    :cvar AGENTQUEUE: "AgentQueue"
    :vartype AGENTQUEUE: str
    :cvar TRANSFERTOEXTENSION: "TransferToExtension"
    :vartype TRANSFERTOEXTENSION: str
    :cvar TAKEMESSAGESONLY: "TakeMessagesOnly"
    :vartype TAKEMESSAGESONLY: str
    :cvar PLAYANNOUNCEMENTONLY: "PlayAnnouncementOnly"
    :vartype PLAYANNOUNCEMENTONLY: str
    :cvar SHAREDLINES: "SharedLines"
    :vartype SHAREDLINES: str
    """

    FORWARDCALLS = "ForwardCalls"
    UNCONDITIONALFORWARDING = "UnconditionalForwarding"
    AGENTQUEUE = "AgentQueue"
    TRANSFERTOEXTENSION = "TransferToExtension"
    TAKEMESSAGESONLY = "TakeMessagesOnly"
    PLAYANNOUNCEMENTONLY = "PlayAnnouncementOnly"
    SHAREDLINES = "SharedLines"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(
            map(
                lambda x: x.value,
                UpdateAnsweringRuleRequestCallHandlingAction._member_map_.values(),
            )
        )


class UpdateAnsweringRuleRequestType(Enum):
    """An enumeration representing different categories.

    :cvar BUSINESSHOURS: "BusinessHours"
    :vartype BUSINESSHOURS: str
    :cvar AFTERHOURS: "AfterHours"
    :vartype AFTERHOURS: str
    :cvar CUSTOM: "Custom"
    :vartype CUSTOM: str
    """

    BUSINESSHOURS = "BusinessHours"
    AFTERHOURS = "AfterHours"
    CUSTOM = "Custom"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(
            map(lambda x: x.value, UpdateAnsweringRuleRequestType._member_map_.values())
        )


class UpdateAnsweringRuleRequestScreening(Enum):
    """An enumeration representing different categories.

    :cvar OFF: "Off"
    :vartype OFF: str
    :cvar NOCALLERID: "NoCallerId"
    :vartype NOCALLERID: str
    :cvar UNKNOWNCALLERID: "UnknownCallerId"
    :vartype UNKNOWNCALLERID: str
    :cvar ALWAYS: "Always"
    :vartype ALWAYS: str
    """

    OFF = "Off"
    NOCALLERID = "NoCallerId"
    UNKNOWNCALLERID = "UnknownCallerId"
    ALWAYS = "Always"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(
            map(
                lambda x: x.value,
                UpdateAnsweringRuleRequestScreening._member_map_.values(),
            )
        )


@JsonMap(
    {
        "id_": "id",
        "called_numbers": "calledNumbers",
        "call_handling_action": "callHandlingAction",
        "type_": "type",
        "unconditional_forwarding": "unconditionalForwarding",
        "missed_call": "missedCall",
        "show_inactive_numbers": "showInactiveNumbers",
    }
)
class UpdateAnsweringRuleRequest(BaseModel):
    """UpdateAnsweringRuleRequest

    :param id_: Identifier of an answering rule, defaults to None
    :type id_: str, optional
    :param forwarding: Forwarding parameters. Returned if 'ForwardCalls' is specified in 'callHandlingAction'. These settings determine the forwarding numbers to which the call will be forwarded, defaults to None
    :type forwarding: ForwardingInfoCreateRuleRequest, optional
    :param enabled: Specifies if the rule is active or inactive. The default value is `true`, defaults to None
    :type enabled: bool, optional
    :param name: Name of an answering rule specified by user, defaults to None
    :type name: str, optional
    :param callers: Answering rule will be applied when calls are received from the specified caller(s), defaults to None
    :type callers: List[CallersInfoRequest], optional
    :param called_numbers: Answering rules are applied when calling to selected number(s), defaults to None
    :type called_numbers: List[CalledNumberInfo], optional
    :param schedule: Schedule when an answering rule should be applied, defaults to None
    :type schedule: ScheduleInfo, optional
    :param call_handling_action: Specifies how incoming calls are forwarded, defaults to None
    :type call_handling_action: UpdateAnsweringRuleRequestCallHandlingAction, optional
    :param type_: Type of an answering rule, defaults to None
    :type type_: UpdateAnsweringRuleRequestType, optional
    :param unconditional_forwarding: Unconditional forwarding parameters.<br>Returned if 'UnconditionalForwarding' value is specified for the `callHandlingAction` parameter<br>, defaults to None
    :type unconditional_forwarding: UnconditionalForwardingInfo, optional
    :param queue: Queue settings applied for department (call queue) extension type,<br>with the 'AgentQueue' value specified as a call handling action<br>, defaults to None
    :type queue: QueueInfo, optional
    :param voicemail: Specifies whether to take a voicemail and who should do it, defaults to None
    :type voicemail: VoicemailInfo, optional
    :param missed_call: Specifies behavior for the missed call scenario. Returned only if `enabled` parameter of a voicemail is set to 'false', defaults to None
    :type missed_call: MissedCallInfo, optional
    :param greetings: Greetings applied for an answering rule; only predefined greetings<br>can be applied, see Dictionary Greeting List<br>, defaults to None
    :type greetings: List[GreetingInfo], optional
    :param screening: Call screening status. 'Off' - no call screening; 'NoCallerId'<br>- if caller ID is missing, then callers are asked to say their name before<br>connecting; 'UnknownCallerId' - if caller ID is not in contact list, then<br>callers are asked to say their name before connecting; 'Always' - the<br>callers are always asked to say their name before connecting. The default<br>value is 'Off'<br>, defaults to None
    :type screening: UpdateAnsweringRuleRequestScreening, optional
    :param show_inactive_numbers: Indicates whether inactive numbers should be returned or not, defaults to None
    :type show_inactive_numbers: bool, optional
    :param transfer: transfer, defaults to None
    :type transfer: TransferredExtensionInfo, optional
    """

    def __init__(
        self,
        id_: str = None,
        forwarding: ForwardingInfoCreateRuleRequest = None,
        enabled: bool = None,
        name: str = None,
        callers: List[CallersInfoRequest] = None,
        called_numbers: List[CalledNumberInfo] = None,
        schedule: ScheduleInfo = None,
        call_handling_action: UpdateAnsweringRuleRequestCallHandlingAction = None,
        type_: UpdateAnsweringRuleRequestType = None,
        unconditional_forwarding: UnconditionalForwardingInfo = None,
        queue: QueueInfo = None,
        voicemail: VoicemailInfo = None,
        missed_call: MissedCallInfo = None,
        greetings: List[GreetingInfo] = None,
        screening: UpdateAnsweringRuleRequestScreening = None,
        show_inactive_numbers: bool = None,
        transfer: TransferredExtensionInfo = None,
    ):
        if id_ is not None:
            self.id_ = id_
        if forwarding is not None:
            self.forwarding = self._define_object(
                forwarding, ForwardingInfoCreateRuleRequest
            )
        if enabled is not None:
            self.enabled = enabled
        if name is not None:
            self.name = name
        if callers is not None:
            self.callers = self._define_list(callers, CallersInfoRequest)
        if called_numbers is not None:
            self.called_numbers = self._define_list(called_numbers, CalledNumberInfo)
        if schedule is not None:
            self.schedule = self._define_object(schedule, ScheduleInfo)
        if call_handling_action is not None:
            self.call_handling_action = self._enum_matching(
                call_handling_action,
                UpdateAnsweringRuleRequestCallHandlingAction.list(),
                "call_handling_action",
            )
        if type_ is not None:
            self.type_ = self._enum_matching(
                type_, UpdateAnsweringRuleRequestType.list(), "type_"
            )
        if unconditional_forwarding is not None:
            self.unconditional_forwarding = self._define_object(
                unconditional_forwarding, UnconditionalForwardingInfo
            )
        if queue is not None:
            self.queue = self._define_object(queue, QueueInfo)
        if voicemail is not None:
            self.voicemail = self._define_object(voicemail, VoicemailInfo)
        if missed_call is not None:
            self.missed_call = self._define_object(missed_call, MissedCallInfo)
        if greetings is not None:
            self.greetings = self._define_list(greetings, GreetingInfo)
        if screening is not None:
            self.screening = self._enum_matching(
                screening, UpdateAnsweringRuleRequestScreening.list(), "screening"
            )
        if show_inactive_numbers is not None:
            self.show_inactive_numbers = show_inactive_numbers
        if transfer is not None:
            self.transfer = self._define_object(transfer, TransferredExtensionInfo)
