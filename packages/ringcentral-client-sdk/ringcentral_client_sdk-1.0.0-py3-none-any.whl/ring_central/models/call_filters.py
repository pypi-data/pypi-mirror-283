# This file was generated by liblab | https://liblab.com/

from __future__ import annotations
from typing import List
from .utils.json_map import JsonMap
from .base import BaseModel
from .extension_filters import ExtensionFilters
from .direction import Direction
from .origin import Origin
from .call_response import CallResponse
from .call_result import CallResult
from .call_segment_filter import CallSegmentFilter
from .call_action import CallAction
from .company_hours_options import CompanyHoursOptions
from .call_duration_filter import CallDurationFilter
from .time_spent_filter import TimeSpentFilter
from .queue_sla_options import QueueSlaOptions
from .call_type import CallType


@JsonMap(
    {
        "extension_filters": "extensionFilters",
        "called_numbers": "calledNumbers",
        "call_responses": "callResponses",
        "call_results": "callResults",
        "call_segments": "callSegments",
        "call_actions": "callActions",
        "company_hours": "companyHours",
        "call_duration": "callDuration",
        "time_spent": "timeSpent",
        "queue_sla": "queueSla",
        "call_types": "callTypes",
    }
)
class CallFilters(BaseModel):
    """Optional filters that limit the scope of calls (joined via AND)

    :param extension_filters: Specifies filtering based on extension ids, defaults to None
    :type extension_filters: ExtensionFilters, optional
    :param queues: List of queues extension ids which allows to get data only for calls that were routed through any of these queues, defaults to None
    :type queues: List[str], optional
    :param called_numbers: The direct company numbers the caller called (joined via OR), defaults to None
    :type called_numbers: List[str], optional
    :param directions: Specifies the call directions relative to the scope specified in grouping object (joined via OR). Not applicable to internal origin calls with company scope, defaults to None
    :type directions: List[Direction], optional
    :param origins: Specifies whether an external party was present in the initial segment of the call (joined via OR), defaults to None
    :type origins: List[Origin], optional
    :param call_responses: Filtering of calls by first response (joined via OR), defaults to None
    :type call_responses: List[CallResponse], optional
    :param call_results: Filtering of calls by the nature of call result (joined via OR), defaults to None
    :type call_results: List[CallResult], optional
    :param call_segments: Filtering of calls by presence of specific segment (joined via OR), defaults to None
    :type call_segments: List[CallSegmentFilter], optional
    :param call_actions: Filtering of calls by presence of specific action (joined via OR), defaults to None
    :type call_actions: List[CallAction], optional
    :param company_hours: Filtering of calls by company's business hours or after hours (joined via OR), defaults to None
    :type company_hours: List[CompanyHoursOptions], optional
    :param call_duration: Filtering of calls based on the overall call length, defaults to None
    :type call_duration: CallDurationFilter, optional
    :param time_spent: Filtering of calls based on the time spent by specified mailbox(es) on call, defaults to None
    :type time_spent: TimeSpentFilter, optional
    :param queue_sla: Filtering calls that were within or out of queue SLA (joined via OR). Only applicable to Queues grouping, defaults to None
    :type queue_sla: List[QueueSlaOptions], optional
    :param call_types: Filtering of calls based on how the call started from the callee perspective (joined via OR). If the call is outbound relative to the grouping scope, CallType is Outbound, defaults to None
    :type call_types: List[CallType], optional
    """

    def __init__(
        self,
        extension_filters: ExtensionFilters = None,
        queues: List[str] = None,
        called_numbers: List[str] = None,
        directions: List[Direction] = None,
        origins: List[Origin] = None,
        call_responses: List[CallResponse] = None,
        call_results: List[CallResult] = None,
        call_segments: List[CallSegmentFilter] = None,
        call_actions: List[CallAction] = None,
        company_hours: List[CompanyHoursOptions] = None,
        call_duration: CallDurationFilter = None,
        time_spent: TimeSpentFilter = None,
        queue_sla: List[QueueSlaOptions] = None,
        call_types: List[CallType] = None,
    ):
        if extension_filters is not None:
            self.extension_filters = self._define_object(
                extension_filters, ExtensionFilters
            )
        if queues is not None:
            self.queues = queues
        if called_numbers is not None:
            self.called_numbers = called_numbers
        if directions is not None:
            self.directions = self._define_list(directions, Direction)
        if origins is not None:
            self.origins = self._define_list(origins, Origin)
        if call_responses is not None:
            self.call_responses = self._define_list(call_responses, CallResponse)
        if call_results is not None:
            self.call_results = self._define_list(call_results, CallResult)
        if call_segments is not None:
            self.call_segments = self._define_list(call_segments, CallSegmentFilter)
        if call_actions is not None:
            self.call_actions = self._define_list(call_actions, CallAction)
        if company_hours is not None:
            self.company_hours = self._define_list(company_hours, CompanyHoursOptions)
        if call_duration is not None:
            self.call_duration = self._define_object(call_duration, CallDurationFilter)
        if time_spent is not None:
            self.time_spent = self._define_object(time_spent, TimeSpentFilter)
        if queue_sla is not None:
            self.queue_sla = self._define_list(queue_sla, QueueSlaOptions)
        if call_types is not None:
            self.call_types = self._define_list(call_types, CallType)
