# This file was generated by liblab | https://liblab.com/

from __future__ import annotations
from enum import Enum
from .utils.json_map import JsonMap
from .base import BaseModel
from .greeting_type_enum import GreetingTypeEnum
from .page_navigation_model import PageNavigationModel
from .enumerated_paging_model import EnumeratedPagingModel


class DictionaryGreetingInfoUsageType(Enum):
    """An enumeration representing different categories.

    :cvar USEREXTENSIONANSWERINGRULE: "UserExtensionAnsweringRule"
    :vartype USEREXTENSIONANSWERINGRULE: str
    :cvar EXTENSIONANSWERINGRULE: "ExtensionAnsweringRule"
    :vartype EXTENSIONANSWERINGRULE: str
    :cvar DEPARTMENTEXTENSIONANSWERINGRULE: "DepartmentExtensionAnsweringRule"
    :vartype DEPARTMENTEXTENSIONANSWERINGRULE: str
    :cvar BLOCKEDCALLS: "BlockedCalls"
    :vartype BLOCKEDCALLS: str
    :cvar CALLRECORDING: "CallRecording"
    :vartype CALLRECORDING: str
    :cvar COMPANYANSWERINGRULE: "CompanyAnsweringRule"
    :vartype COMPANYANSWERINGRULE: str
    :cvar COMPANYAFTERHOURSANSWERINGRULE: "CompanyAfterHoursAnsweringRule"
    :vartype COMPANYAFTERHOURSANSWERINGRULE: str
    :cvar LIMITEDEXTENSIONANSWERINGRULE: "LimitedExtensionAnsweringRule"
    :vartype LIMITEDEXTENSIONANSWERINGRULE: str
    :cvar VOICEMAILEXTENSIONANSWERINGRULE: "VoicemailExtensionAnsweringRule"
    :vartype VOICEMAILEXTENSIONANSWERINGRULE: str
    :cvar ANNOUNCEMENTEXTENSIONANSWERINGRULE: "AnnouncementExtensionAnsweringRule"
    :vartype ANNOUNCEMENTEXTENSIONANSWERINGRULE: str
    :cvar SHAREDLINESGROUPANSWERINGRULE: "SharedLinesGroupAnsweringRule"
    :vartype SHAREDLINESGROUPANSWERINGRULE: str
    """

    USEREXTENSIONANSWERINGRULE = "UserExtensionAnsweringRule"
    EXTENSIONANSWERINGRULE = "ExtensionAnsweringRule"
    DEPARTMENTEXTENSIONANSWERINGRULE = "DepartmentExtensionAnsweringRule"
    BLOCKEDCALLS = "BlockedCalls"
    CALLRECORDING = "CallRecording"
    COMPANYANSWERINGRULE = "CompanyAnsweringRule"
    COMPANYAFTERHOURSANSWERINGRULE = "CompanyAfterHoursAnsweringRule"
    LIMITEDEXTENSIONANSWERINGRULE = "LimitedExtensionAnsweringRule"
    VOICEMAILEXTENSIONANSWERINGRULE = "VoicemailExtensionAnsweringRule"
    ANNOUNCEMENTEXTENSIONANSWERINGRULE = "AnnouncementExtensionAnsweringRule"
    SHAREDLINESGROUPANSWERINGRULE = "SharedLinesGroupAnsweringRule"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(
            map(
                lambda x: x.value, DictionaryGreetingInfoUsageType._member_map_.values()
            )
        )


class DictionaryGreetingInfoCategory(Enum):
    """An enumeration representing different categories.

    :cvar MUSIC: "Music"
    :vartype MUSIC: str
    :cvar MESSAGE: "Message"
    :vartype MESSAGE: str
    :cvar RINGTONES: "RingTones"
    :vartype RINGTONES: str
    :cvar NONE: "None"
    :vartype NONE: str
    """

    MUSIC = "Music"
    MESSAGE = "Message"
    RINGTONES = "RingTones"
    NONE = "None"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(
            map(lambda x: x.value, DictionaryGreetingInfoCategory._member_map_.values())
        )


@JsonMap(
    {
        "id_": "id",
        "usage_type": "usageType",
        "content_uri": "contentUri",
        "type_": "type",
    }
)
class DictionaryGreetingInfo(BaseModel):
    """DictionaryGreetingInfo

    :param id_: Internal identifier of a greeting, defaults to None
    :type id_: str, optional
    :param uri: Link to a greeting, defaults to None
    :type uri: str, optional
    :param name: Name of a greeting, defaults to None
    :type name: str, optional
    :param usage_type: Usage type of greeting, specifying if the greeting is applied for user extension or department (call queue) extension., defaults to None
    :type usage_type: DictionaryGreetingInfoUsageType, optional
    :param text: Text of a greeting, if any, defaults to None
    :type text: str, optional
    :param content_uri: Link to a greeting content (audio file), if any, defaults to None
    :type content_uri: str, optional
    :param type_: Type of greeting, specifying the case when the greeting is played., defaults to None
    :type type_: GreetingTypeEnum, optional
    :param category: Category of a greeting, specifying data form. The category value 'None' specifies that greetings of a certain type ('Introductory', 'ConnectingAudio', etc.) are switched off for an extension = ['Music', 'Message', 'RingTones', 'None'], defaults to None
    :type category: DictionaryGreetingInfoCategory, optional
    :param navigation: Links to other pages of the current result set, defaults to None
    :type navigation: PageNavigationModel, optional
    :param paging: paging, defaults to None
    :type paging: EnumeratedPagingModel, optional
    """

    def __init__(
        self,
        id_: str = None,
        uri: str = None,
        name: str = None,
        usage_type: DictionaryGreetingInfoUsageType = None,
        text: str = None,
        content_uri: str = None,
        type_: GreetingTypeEnum = None,
        category: DictionaryGreetingInfoCategory = None,
        navigation: PageNavigationModel = None,
        paging: EnumeratedPagingModel = None,
    ):
        if id_ is not None:
            self.id_ = id_
        if uri is not None:
            self.uri = uri
        if name is not None:
            self.name = name
        if usage_type is not None:
            self.usage_type = self._enum_matching(
                usage_type, DictionaryGreetingInfoUsageType.list(), "usage_type"
            )
        if text is not None:
            self.text = text
        if content_uri is not None:
            self.content_uri = content_uri
        if type_ is not None:
            self.type_ = self._enum_matching(type_, GreetingTypeEnum.list(), "type_")
        if category is not None:
            self.category = self._enum_matching(
                category, DictionaryGreetingInfoCategory.list(), "category"
            )
        if navigation is not None:
            self.navigation = self._define_object(navigation, PageNavigationModel)
        if paging is not None:
            self.paging = self._define_object(paging, EnumeratedPagingModel)
