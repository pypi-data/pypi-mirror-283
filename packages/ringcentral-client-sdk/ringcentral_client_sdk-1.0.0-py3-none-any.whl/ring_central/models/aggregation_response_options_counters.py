# This file was generated by liblab | https://liblab.com/

from __future__ import annotations
from .utils.json_map import JsonMap
from .base import BaseModel
from .aggregation_type import AggregationType
from .aggregation_interval import AggregationInterval
from .queue_opportunities_aggregation_type import QueueOpportunitiesAggregationType


@JsonMap(
    {
        "aggregation_type": "aggregationType",
        "aggregation_interval": "aggregationInterval",
    }
)
class AggregationResponseOptionsCountersAllCalls(BaseModel):
    """Aggregation of all calls count

    :param aggregation_type: Counter aggregation type. Can be `Sum`, `Average`, `Min`, `Max` or `Percent`
    :type aggregation_type: AggregationType
    :param aggregation_interval: Time interval which will be used for aggregation. Can be `Hour`, `Day`, `Week` or `Month`, defaults to None
    :type aggregation_interval: AggregationInterval, optional
    """

    def __init__(
        self,
        aggregation_type: AggregationType,
        aggregation_interval: AggregationInterval = None,
    ):
        self.aggregation_type = self._enum_matching(
            aggregation_type, AggregationType.list(), "aggregation_type"
        )
        if aggregation_interval is not None:
            self.aggregation_interval = self._enum_matching(
                aggregation_interval, AggregationInterval.list(), "aggregation_interval"
            )


@JsonMap(
    {
        "aggregation_type": "aggregationType",
        "aggregation_interval": "aggregationInterval",
    }
)
class AggregationResponseOptionsCountersCallsByDirection(BaseModel):
    """Aggregation of calls count by direction (Inbound, Outbound)

    :param aggregation_type: Counter aggregation type. Can be `Sum`, `Average`, `Min`, `Max` or `Percent`
    :type aggregation_type: AggregationType
    :param aggregation_interval: Time interval which will be used for aggregation. Can be `Hour`, `Day`, `Week` or `Month`, defaults to None
    :type aggregation_interval: AggregationInterval, optional
    """

    def __init__(
        self,
        aggregation_type: AggregationType,
        aggregation_interval: AggregationInterval = None,
    ):
        self.aggregation_type = self._enum_matching(
            aggregation_type, AggregationType.list(), "aggregation_type"
        )
        if aggregation_interval is not None:
            self.aggregation_interval = self._enum_matching(
                aggregation_interval, AggregationInterval.list(), "aggregation_interval"
            )


@JsonMap(
    {
        "aggregation_type": "aggregationType",
        "aggregation_interval": "aggregationInterval",
    }
)
class AggregationResponseOptionsCountersCallsByOrigin(BaseModel):
    """Aggregation of calls count by origin (Internal, External)

    :param aggregation_type: Counter aggregation type. Can be `Sum`, `Average`, `Min`, `Max` or `Percent`
    :type aggregation_type: AggregationType
    :param aggregation_interval: Time interval which will be used for aggregation. Can be `Hour`, `Day`, `Week` or `Month`, defaults to None
    :type aggregation_interval: AggregationInterval, optional
    """

    def __init__(
        self,
        aggregation_type: AggregationType,
        aggregation_interval: AggregationInterval = None,
    ):
        self.aggregation_type = self._enum_matching(
            aggregation_type, AggregationType.list(), "aggregation_type"
        )
        if aggregation_interval is not None:
            self.aggregation_interval = self._enum_matching(
                aggregation_interval, AggregationInterval.list(), "aggregation_interval"
            )


@JsonMap(
    {
        "aggregation_type": "aggregationType",
        "aggregation_interval": "aggregationInterval",
    }
)
class AggregationResponseOptionsCountersCallsByResponse(BaseModel):
    """Aggregation of calls count by response (Answered, NotAnswered, Connected, NotConnected)

    :param aggregation_type: Counter aggregation type. Can be `Sum`, `Average`, `Min`, `Max` or `Percent`
    :type aggregation_type: AggregationType
    :param aggregation_interval: Time interval which will be used for aggregation. Can be `Hour`, `Day`, `Week` or `Month`, defaults to None
    :type aggregation_interval: AggregationInterval, optional
    """

    def __init__(
        self,
        aggregation_type: AggregationType,
        aggregation_interval: AggregationInterval = None,
    ):
        self.aggregation_type = self._enum_matching(
            aggregation_type, AggregationType.list(), "aggregation_type"
        )
        if aggregation_interval is not None:
            self.aggregation_interval = self._enum_matching(
                aggregation_interval, AggregationInterval.list(), "aggregation_interval"
            )


@JsonMap(
    {
        "aggregation_type": "aggregationType",
        "aggregation_interval": "aggregationInterval",
    }
)
class CallsSegments(BaseModel):
    """Aggregation of calls count by segments (Ringing, LiveTalk, Hold, Park, Transfer, IvrPrompt, Voicemail, VmGreeting, Setup)

    :param aggregation_type: Counter aggregation type. Can be `Sum`, `Average`, `Min`, `Max` or `Percent`
    :type aggregation_type: AggregationType
    :param aggregation_interval: Time interval which will be used for aggregation. Can be `Hour`, `Day`, `Week` or `Month`, defaults to None
    :type aggregation_interval: AggregationInterval, optional
    """

    def __init__(
        self,
        aggregation_type: AggregationType,
        aggregation_interval: AggregationInterval = None,
    ):
        self.aggregation_type = self._enum_matching(
            aggregation_type, AggregationType.list(), "aggregation_type"
        )
        if aggregation_interval is not None:
            self.aggregation_interval = self._enum_matching(
                aggregation_interval, AggregationInterval.list(), "aggregation_interval"
            )


@JsonMap(
    {
        "aggregation_type": "aggregationType",
        "aggregation_interval": "aggregationInterval",
    }
)
class AggregationResponseOptionsCountersCallsByResult(BaseModel):
    """Aggregation of calls count by result (Completed, Abandoned, Voicemail, Unknown, Missed, Accepted)

    :param aggregation_type: Counter aggregation type. Can be `Sum`, `Average`, `Min`, `Max` or `Percent`
    :type aggregation_type: AggregationType
    :param aggregation_interval: Time interval which will be used for aggregation. Can be `Hour`, `Day`, `Week` or `Month`, defaults to None
    :type aggregation_interval: AggregationInterval, optional
    """

    def __init__(
        self,
        aggregation_type: AggregationType,
        aggregation_interval: AggregationInterval = None,
    ):
        self.aggregation_type = self._enum_matching(
            aggregation_type, AggregationType.list(), "aggregation_type"
        )
        if aggregation_interval is not None:
            self.aggregation_interval = self._enum_matching(
                aggregation_interval, AggregationInterval.list(), "aggregation_interval"
            )


@JsonMap(
    {
        "aggregation_type": "aggregationType",
        "aggregation_interval": "aggregationInterval",
    }
)
class AggregationResponseOptionsCountersCallsByCompanyHours(BaseModel):
    """Aggregation of calls count by company hours (BusinessHours, AfterHours)

    :param aggregation_type: Counter aggregation type. Can be `Sum`, `Average`, `Min`, `Max` or `Percent`
    :type aggregation_type: AggregationType
    :param aggregation_interval: Time interval which will be used for aggregation. Can be `Hour`, `Day`, `Week` or `Month`, defaults to None
    :type aggregation_interval: AggregationInterval, optional
    """

    def __init__(
        self,
        aggregation_type: AggregationType,
        aggregation_interval: AggregationInterval = None,
    ):
        self.aggregation_type = self._enum_matching(
            aggregation_type, AggregationType.list(), "aggregation_type"
        )
        if aggregation_interval is not None:
            self.aggregation_interval = self._enum_matching(
                aggregation_interval, AggregationInterval.list(), "aggregation_interval"
            )


@JsonMap(
    {
        "aggregation_type": "aggregationType",
        "aggregation_interval": "aggregationInterval",
    }
)
class AggregationResponseOptionsCountersCallsByQueueSla(BaseModel):
    """Aggregation of calls count by queue SLA (InSLA, OutSLA). This counter is only applicable to Queues grouping

    :param aggregation_type: Counter aggregation type. Can be `Sum`, `Average`, `Min`, `Max` or `Percent`
    :type aggregation_type: AggregationType
    :param aggregation_interval: Time interval which will be used for aggregation. Can be `Hour`, `Day`, `Week` or `Month`, defaults to None
    :type aggregation_interval: AggregationInterval, optional
    """

    def __init__(
        self,
        aggregation_type: AggregationType,
        aggregation_interval: AggregationInterval = None,
    ):
        self.aggregation_type = self._enum_matching(
            aggregation_type, AggregationType.list(), "aggregation_type"
        )
        if aggregation_interval is not None:
            self.aggregation_interval = self._enum_matching(
                aggregation_interval, AggregationInterval.list(), "aggregation_interval"
            )


@JsonMap(
    {
        "aggregation_type": "aggregationType",
        "aggregation_interval": "aggregationInterval",
    }
)
class AggregationResponseOptionsCountersCallsByActions(BaseModel):
    """Aggregation of calls count by action (HoldOff, HoldOn, ParkOn, ParkOff, BlindTransfer, WarmTransfer, DTMFTransfer)

    :param aggregation_type: Counter aggregation type. Can be `Sum`, `Average`, `Min`, `Max` or `Percent`
    :type aggregation_type: AggregationType
    :param aggregation_interval: Time interval which will be used for aggregation. Can be `Hour`, `Day`, `Week` or `Month`, defaults to None
    :type aggregation_interval: AggregationInterval, optional
    """

    def __init__(
        self,
        aggregation_type: AggregationType,
        aggregation_interval: AggregationInterval = None,
    ):
        self.aggregation_type = self._enum_matching(
            aggregation_type, AggregationType.list(), "aggregation_type"
        )
        if aggregation_interval is not None:
            self.aggregation_interval = self._enum_matching(
                aggregation_interval, AggregationInterval.list(), "aggregation_interval"
            )


@JsonMap(
    {
        "aggregation_type": "aggregationType",
        "aggregation_interval": "aggregationInterval",
    }
)
class AggregationResponseOptionsCountersCallsByType(BaseModel):
    """Aggregation of calls count by type (Direct, FromQueue, ParkRetrieval, Transferred, Outbound)

    :param aggregation_type: Counter aggregation type. Can be `Sum`, `Average`, `Min`, `Max` or `Percent`
    :type aggregation_type: AggregationType
    :param aggregation_interval: Time interval which will be used for aggregation. Can be `Hour`, `Day`, `Week` or `Month`, defaults to None
    :type aggregation_interval: AggregationInterval, optional
    """

    def __init__(
        self,
        aggregation_type: AggregationType,
        aggregation_interval: AggregationInterval = None,
    ):
        self.aggregation_type = self._enum_matching(
            aggregation_type, AggregationType.list(), "aggregation_type"
        )
        if aggregation_interval is not None:
            self.aggregation_interval = self._enum_matching(
                aggregation_interval, AggregationInterval.list(), "aggregation_interval"
            )


@JsonMap({"aggregation_type": "aggregationType"})
class AggregationResponseOptionsCountersQueueOpportunities(BaseModel):
    """Aggregation of calls count by the total number of times a Queue call was presented to the user. It is limited to `groupBy` Users and `groupByMembers` (Department, Queue, Site, UserGroup) grouping. Only the listed below options for call filters are applicable to `queueOpportunities` and provide meaningful results: `queues` (selected queue extension ids), `callResults` (Missed, Abandoned), `callResponses` (Answered, NotAnswered), `origins` (Internal, External)

    :param aggregation_type: Counter aggregation type for queue opportunities, limited to `Sum` only.
    :type aggregation_type: QueueOpportunitiesAggregationType
    """

    def __init__(self, aggregation_type: QueueOpportunitiesAggregationType):
        self.aggregation_type = self._enum_matching(
            aggregation_type,
            QueueOpportunitiesAggregationType.list(),
            "aggregation_type",
        )


@JsonMap(
    {
        "all_calls": "allCalls",
        "calls_by_direction": "callsByDirection",
        "calls_by_origin": "callsByOrigin",
        "calls_by_response": "callsByResponse",
        "calls_segments": "callsSegments",
        "calls_by_result": "callsByResult",
        "calls_by_company_hours": "callsByCompanyHours",
        "calls_by_queue_sla": "callsByQueueSla",
        "calls_by_actions": "callsByActions",
        "calls_by_type": "callsByType",
        "queue_opportunities": "queueOpportunities",
    }
)
class AggregationResponseOptionsCounters(BaseModel):
    """The formula is defined by `aggregationType` and `aggregationInterval` for every counter individually.
    If `aggregationType` is `Sum` or `Percent`, `aggregationInterval` is not supported.
    If `aggregationType` is `Min`, `Max` or `Average`, `aggregationInterval` is required

    :param all_calls: Aggregation of all calls count, defaults to None
    :type all_calls: AggregationResponseOptionsCountersAllCalls, optional
    :param calls_by_direction: Aggregation of calls count by direction (Inbound, Outbound), defaults to None
    :type calls_by_direction: AggregationResponseOptionsCountersCallsByDirection, optional
    :param calls_by_origin: Aggregation of calls count by origin (Internal, External), defaults to None
    :type calls_by_origin: AggregationResponseOptionsCountersCallsByOrigin, optional
    :param calls_by_response: Aggregation of calls count by response (Answered, NotAnswered, Connected, NotConnected), defaults to None
    :type calls_by_response: AggregationResponseOptionsCountersCallsByResponse, optional
    :param calls_segments: Aggregation of calls count by segments (Ringing, LiveTalk, Hold, Park, Transfer, IvrPrompt, Voicemail, VmGreeting, Setup), defaults to None
    :type calls_segments: CallsSegments, optional
    :param calls_by_result: Aggregation of calls count by result (Completed, Abandoned, Voicemail, Unknown, Missed, Accepted), defaults to None
    :type calls_by_result: AggregationResponseOptionsCountersCallsByResult, optional
    :param calls_by_company_hours: Aggregation of calls count by company hours (BusinessHours, AfterHours), defaults to None
    :type calls_by_company_hours: AggregationResponseOptionsCountersCallsByCompanyHours, optional
    :param calls_by_queue_sla: Aggregation of calls count by queue SLA (InSLA, OutSLA). This counter is only applicable to Queues grouping, defaults to None
    :type calls_by_queue_sla: AggregationResponseOptionsCountersCallsByQueueSla, optional
    :param calls_by_actions: Aggregation of calls count by action (HoldOff, HoldOn, ParkOn, ParkOff, BlindTransfer, WarmTransfer, DTMFTransfer), defaults to None
    :type calls_by_actions: AggregationResponseOptionsCountersCallsByActions, optional
    :param calls_by_type: Aggregation of calls count by type (Direct, FromQueue, ParkRetrieval, Transferred, Outbound), defaults to None
    :type calls_by_type: AggregationResponseOptionsCountersCallsByType, optional
    :param queue_opportunities: Aggregation of calls count by the total number of times a Queue call was presented to the user. It is limited to `groupBy` Users and `groupByMembers` (Department, Queue, Site, UserGroup) grouping. Only the listed below options for call filters are applicable to `queueOpportunities` and provide meaningful results: `queues` (selected queue extension ids), `callResults` (Missed, Abandoned), `callResponses` (Answered, NotAnswered), `origins` (Internal, External), defaults to None
    :type queue_opportunities: AggregationResponseOptionsCountersQueueOpportunities, optional
    """

    def __init__(
        self,
        all_calls: AggregationResponseOptionsCountersAllCalls = None,
        calls_by_direction: AggregationResponseOptionsCountersCallsByDirection = None,
        calls_by_origin: AggregationResponseOptionsCountersCallsByOrigin = None,
        calls_by_response: AggregationResponseOptionsCountersCallsByResponse = None,
        calls_segments: CallsSegments = None,
        calls_by_result: AggregationResponseOptionsCountersCallsByResult = None,
        calls_by_company_hours: AggregationResponseOptionsCountersCallsByCompanyHours = None,
        calls_by_queue_sla: AggregationResponseOptionsCountersCallsByQueueSla = None,
        calls_by_actions: AggregationResponseOptionsCountersCallsByActions = None,
        calls_by_type: AggregationResponseOptionsCountersCallsByType = None,
        queue_opportunities: AggregationResponseOptionsCountersQueueOpportunities = None,
    ):
        if all_calls is not None:
            self.all_calls = self._define_object(
                all_calls, AggregationResponseOptionsCountersAllCalls
            )
        if calls_by_direction is not None:
            self.calls_by_direction = self._define_object(
                calls_by_direction, AggregationResponseOptionsCountersCallsByDirection
            )
        if calls_by_origin is not None:
            self.calls_by_origin = self._define_object(
                calls_by_origin, AggregationResponseOptionsCountersCallsByOrigin
            )
        if calls_by_response is not None:
            self.calls_by_response = self._define_object(
                calls_by_response, AggregationResponseOptionsCountersCallsByResponse
            )
        if calls_segments is not None:
            self.calls_segments = self._define_object(calls_segments, CallsSegments)
        if calls_by_result is not None:
            self.calls_by_result = self._define_object(
                calls_by_result, AggregationResponseOptionsCountersCallsByResult
            )
        if calls_by_company_hours is not None:
            self.calls_by_company_hours = self._define_object(
                calls_by_company_hours,
                AggregationResponseOptionsCountersCallsByCompanyHours,
            )
        if calls_by_queue_sla is not None:
            self.calls_by_queue_sla = self._define_object(
                calls_by_queue_sla, AggregationResponseOptionsCountersCallsByQueueSla
            )
        if calls_by_actions is not None:
            self.calls_by_actions = self._define_object(
                calls_by_actions, AggregationResponseOptionsCountersCallsByActions
            )
        if calls_by_type is not None:
            self.calls_by_type = self._define_object(
                calls_by_type, AggregationResponseOptionsCountersCallsByType
            )
        if queue_opportunities is not None:
            self.queue_opportunities = self._define_object(
                queue_opportunities,
                AggregationResponseOptionsCountersQueueOpportunities,
            )
