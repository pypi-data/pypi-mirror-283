# This file was generated by liblab | https://liblab.com/

from __future__ import annotations
from enum import Enum
from .utils.json_map import JsonMap
from .base import BaseModel
from .bridge_join_preferences import BridgeJoinPreferences
from .recordings_preferences import RecordingsPreferences


class PlayTones(Enum):
    """An enumeration representing different categories.

    :cvar ON: "On"
    :vartype ON: str
    :cvar OFF: "Off"
    :vartype OFF: str
    :cvar EXITONLY: "ExitOnly"
    :vartype EXITONLY: str
    :cvar ENTERONLY: "EnterOnly"
    :vartype ENTERONLY: str
    """

    ON = "On"
    OFF = "Off"
    EXITONLY = "ExitOnly"
    ENTERONLY = "EnterOnly"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, PlayTones._member_map_.values()))


class RecordingsMode(Enum):
    """An enumeration representing different categories.

    :cvar AUTO: "Auto"
    :vartype AUTO: str
    :cvar FORCEAUTO: "ForceAuto"
    :vartype FORCEAUTO: str
    :cvar USER: "User"
    :vartype USER: str
    """

    AUTO = "Auto"
    FORCEAUTO = "ForceAuto"
    USER = "User"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, RecordingsMode._member_map_.values()))


class TranscriptionsMode(Enum):
    """An enumeration representing different categories.

    :cvar AUTO: "Auto"
    :vartype AUTO: str
    :cvar FORCEAUTO: "ForceAuto"
    :vartype FORCEAUTO: str
    :cvar USER: "User"
    :vartype USER: str
    """

    AUTO = "Auto"
    FORCEAUTO = "ForceAuto"
    USER = "User"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, TranscriptionsMode._member_map_.values()))


@JsonMap(
    {
        "play_tones": "playTones",
        "music_on_hold": "musicOnHold",
        "join_before_host": "joinBeforeHost",
        "screen_sharing": "screenSharing",
        "recordings_mode": "recordingsMode",
        "transcriptions_mode": "transcriptionsMode",
        "allow_everyone_transcribe_meetings": "allowEveryoneTranscribeMeetings",
    }
)
class BridgePreferences(BaseModel):
    """BridgePreferences

    :param join: join, defaults to None
    :type join: BridgeJoinPreferences, optional
    :param play_tones: Specifies enter and exit tones mode.<br>1) On - Enter and exit tones switched on.<br>2) Off - Enter and exit tones switched off.<br>3) ExitOnly - Only exit tones switched on.<br>4) EnterOnly - Only enter tones switched on.<br>, defaults to None
    :type play_tones: PlayTones, optional
    :param music_on_hold: Specifies whether to play music on hold when alone, defaults to None
    :type music_on_hold: bool, optional
    :param join_before_host: Specifies if participants can join to a meeting before host.<br>Default value depends on the bridge type:<br>- default bridge (PMI) -> false<br>- other types -> true<br>, defaults to None
    :type join_before_host: bool, optional
    :param screen_sharing: Specifies if screen sharing is allowed, defaults to None
    :type screen_sharing: bool, optional
    :param recordings_mode: Controls whether recordings are enabled automatically or by user decision, defaults to None
    :type recordings_mode: RecordingsMode, optional
    :param transcriptions_mode: Controls whether transcriptions are enabled automatically or by user decision, defaults to None
    :type transcriptions_mode: TranscriptionsMode, optional
    :param recordings: Recordings preferences, defaults to None
    :type recordings: RecordingsPreferences, optional
    :param allow_everyone_transcribe_meetings: Controls whether participants can start and pause transcription, defaults to None
    :type allow_everyone_transcribe_meetings: bool, optional
    """

    def __init__(
        self,
        join: BridgeJoinPreferences = None,
        play_tones: PlayTones = None,
        music_on_hold: bool = None,
        join_before_host: bool = None,
        screen_sharing: bool = None,
        recordings_mode: RecordingsMode = None,
        transcriptions_mode: TranscriptionsMode = None,
        recordings: RecordingsPreferences = None,
        allow_everyone_transcribe_meetings: bool = None,
    ):
        if join is not None:
            self.join = self._define_object(join, BridgeJoinPreferences)
        if play_tones is not None:
            self.play_tones = self._enum_matching(
                play_tones, PlayTones.list(), "play_tones"
            )
        if music_on_hold is not None:
            self.music_on_hold = music_on_hold
        if join_before_host is not None:
            self.join_before_host = join_before_host
        if screen_sharing is not None:
            self.screen_sharing = screen_sharing
        if recordings_mode is not None:
            self.recordings_mode = self._enum_matching(
                recordings_mode, RecordingsMode.list(), "recordings_mode"
            )
        if transcriptions_mode is not None:
            self.transcriptions_mode = self._enum_matching(
                transcriptions_mode, TranscriptionsMode.list(), "transcriptions_mode"
            )
        if recordings is not None:
            self.recordings = self._define_object(recordings, RecordingsPreferences)
        if allow_everyone_transcribe_meetings is not None:
            self.allow_everyone_transcribe_meetings = allow_everyone_transcribe_meetings
