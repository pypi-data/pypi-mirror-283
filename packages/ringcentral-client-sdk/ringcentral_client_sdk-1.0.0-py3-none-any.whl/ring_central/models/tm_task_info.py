# This file was generated by liblab | https://liblab.com/

from __future__ import annotations
from enum import Enum
from typing import List
from .utils.json_map import JsonMap
from .base import BaseModel
from .task_recurrence_info import TaskRecurrenceInfo
from .task_attachment import TaskAttachment


class TmTaskInfoType(Enum):
    """An enumeration representing different categories.

    :cvar TASK: "Task"
    :vartype TASK: str
    """

    TASK = "Task"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, TmTaskInfoType._member_map_.values()))


@JsonMap({"id_": "id"})
class Creator(BaseModel):
    """Creator

    :param id_: Internal identifier of a task creator, defaults to None
    :type id_: str, optional
    """

    def __init__(self, id_: str = None):
        if id_ is not None:
            self.id_ = id_


class TmTaskInfoStatus(Enum):
    """An enumeration representing different categories.

    :cvar PENDING: "Pending"
    :vartype PENDING: str
    :cvar INPROGRESS: "InProgress"
    :vartype INPROGRESS: str
    :cvar COMPLETED: "Completed"
    :vartype COMPLETED: str
    """

    PENDING = "Pending"
    INPROGRESS = "InProgress"
    COMPLETED = "Completed"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, TmTaskInfoStatus._member_map_.values()))


class AssigneesStatus(Enum):
    """An enumeration representing different categories.

    :cvar PENDING: "Pending"
    :vartype PENDING: str
    :cvar COMPLETED: "Completed"
    :vartype COMPLETED: str
    """

    PENDING = "Pending"
    COMPLETED = "Completed"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, AssigneesStatus._member_map_.values()))


@JsonMap({"id_": "id"})
class TmTaskInfoAssignees(BaseModel):
    """TmTaskInfoAssignees

    :param id_: Internal identifier of an assignee, defaults to None
    :type id_: str, optional
    :param status: Task execution status by assignee, defaults to None
    :type status: AssigneesStatus, optional
    """

    def __init__(self, id_: str = None, status: AssigneesStatus = None):
        if id_ is not None:
            self.id_ = id_
        if status is not None:
            self.status = self._enum_matching(status, AssigneesStatus.list(), "status")


class TmTaskInfoCompletenessCondition(Enum):
    """An enumeration representing different categories.

    :cvar SIMPLE: "Simple"
    :vartype SIMPLE: str
    :cvar ALLASSIGNEES: "AllAssignees"
    :vartype ALLASSIGNEES: str
    :cvar PERCENTAGE: "Percentage"
    :vartype PERCENTAGE: str
    """

    SIMPLE = "Simple"
    ALLASSIGNEES = "AllAssignees"
    PERCENTAGE = "Percentage"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(
            map(
                lambda x: x.value, TmTaskInfoCompletenessCondition._member_map_.values()
            )
        )


class TmTaskInfoColor(Enum):
    """An enumeration representing different categories.

    :cvar BLACK: "Black"
    :vartype BLACK: str
    :cvar RED: "Red"
    :vartype RED: str
    :cvar ORANGE: "Orange"
    :vartype ORANGE: str
    :cvar YELLOW: "Yellow"
    :vartype YELLOW: str
    :cvar GREEN: "Green"
    :vartype GREEN: str
    :cvar BLUE: "Blue"
    :vartype BLUE: str
    :cvar PURPLE: "Purple"
    :vartype PURPLE: str
    :cvar MAGENTA: "Magenta"
    :vartype MAGENTA: str
    """

    BLACK = "Black"
    RED = "Red"
    ORANGE = "Orange"
    YELLOW = "Yellow"
    GREEN = "Green"
    BLUE = "Blue"
    PURPLE = "Purple"
    MAGENTA = "Magenta"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, TmTaskInfoColor._member_map_.values()))


@JsonMap(
    {
        "id_": "id",
        "creation_time": "creationTime",
        "last_modified_time": "lastModifiedTime",
        "type_": "type",
        "chat_ids": "chatIds",
        "completeness_condition": "completenessCondition",
        "completeness_percentage": "completenessPercentage",
        "start_date": "startDate",
        "due_date": "dueDate",
    }
)
class TmTaskInfo(BaseModel):
    """TmTaskInfo

    :param id_: Internal identifier of a task, defaults to None
    :type id_: str, optional
    :param creation_time: Task creation date/time in UTC time zone, defaults to None
    :type creation_time: str, optional
    :param last_modified_time: Task the last modified time in UTC time zone, defaults to None
    :type last_modified_time: str, optional
    :param type_: Task type, defaults to None
    :type type_: TmTaskInfoType, optional
    :param creator: creator, defaults to None
    :type creator: Creator, optional
    :param chat_ids: Internal identifiers of the chats where the task is posted or shared, defaults to None
    :type chat_ids: List[str], optional
    :param status: Task execution status, defaults to None
    :type status: TmTaskInfoStatus, optional
    :param subject: Task name/subject, defaults to None
    :type subject: str, optional
    :param assignees: Task name/subject, defaults to None
    :type assignees: List[TmTaskInfoAssignees], optional
    :param completeness_condition: How the task completeness should be determined, defaults to None
    :type completeness_condition: TmTaskInfoCompletenessCondition, optional
    :param completeness_percentage: Current completeness percentage of the task with the specified percentage completeness condition, defaults to None
    :type completeness_percentage: int, optional
    :param start_date: Task start date, defaults to None
    :type start_date: str, optional
    :param due_date: Task due date/time, defaults to None
    :type due_date: str, optional
    :param color: Font color of a post with the current task, defaults to None
    :type color: TmTaskInfoColor, optional
    :param section: Task section to group / search by, defaults to None
    :type section: str, optional
    :param description: Task details, defaults to None
    :type description: str, optional
    :param recurrence: Task information, defaults to None
    :type recurrence: TaskRecurrenceInfo, optional
    :param attachments: attachments, defaults to None
    :type attachments: List[TaskAttachment], optional
    """

    def __init__(
        self,
        id_: str = None,
        creation_time: str = None,
        last_modified_time: str = None,
        type_: TmTaskInfoType = None,
        creator: Creator = None,
        chat_ids: List[str] = None,
        status: TmTaskInfoStatus = None,
        subject: str = None,
        assignees: List[TmTaskInfoAssignees] = None,
        completeness_condition: TmTaskInfoCompletenessCondition = None,
        completeness_percentage: int = None,
        start_date: str = None,
        due_date: str = None,
        color: TmTaskInfoColor = None,
        section: str = None,
        description: str = None,
        recurrence: TaskRecurrenceInfo = None,
        attachments: List[TaskAttachment] = None,
    ):
        if id_ is not None:
            self.id_ = id_
        if creation_time is not None:
            self.creation_time = creation_time
        if last_modified_time is not None:
            self.last_modified_time = last_modified_time
        if type_ is not None:
            self.type_ = self._enum_matching(type_, TmTaskInfoType.list(), "type_")
        if creator is not None:
            self.creator = self._define_object(creator, Creator)
        if chat_ids is not None:
            self.chat_ids = chat_ids
        if status is not None:
            self.status = self._enum_matching(status, TmTaskInfoStatus.list(), "status")
        if subject is not None:
            self.subject = subject
        if assignees is not None:
            self.assignees = self._define_list(assignees, TmTaskInfoAssignees)
        if completeness_condition is not None:
            self.completeness_condition = self._enum_matching(
                completeness_condition,
                TmTaskInfoCompletenessCondition.list(),
                "completeness_condition",
            )
        if completeness_percentage is not None:
            self.completeness_percentage = completeness_percentage
        if start_date is not None:
            self.start_date = start_date
        if due_date is not None:
            self.due_date = due_date
        if color is not None:
            self.color = self._enum_matching(color, TmTaskInfoColor.list(), "color")
        if section is not None:
            self.section = section
        if description is not None:
            self.description = description
        if recurrence is not None:
            self.recurrence = self._define_object(recurrence, TaskRecurrenceInfo)
        if attachments is not None:
            self.attachments = self._define_list(attachments, TaskAttachment)
