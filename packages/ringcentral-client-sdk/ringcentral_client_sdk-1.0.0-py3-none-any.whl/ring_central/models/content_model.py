# This file was generated by liblab | https://liblab.com/

from __future__ import annotations
from typing import List
from .utils.json_map import JsonMap
from .base import BaseModel
from .content_attachment import ContentAttachment
from .content_body_formatted import ContentBodyFormatted
from .content_body_input_format import ContentBodyInputFormat
from .content_created_from import ContentCreatedFrom
from .content_source_type import ContentSourceType
from .content_status import ContentStatus
from .content_type import ContentType


@JsonMap(
    {
        "author_identity_id": "authorIdentityId",
        "auto_submitted": "autoSubmitted",
        "body_formatted": "bodyFormatted",
        "body_input_format": "bodyInputFormat",
        "category_ids": "categoryIds",
        "context_data": "contextData",
        "creation_time": "creationTime",
        "created_from": "createdFrom",
        "creator_id": "creatorId",
        "foreign_categories": "foreignCategories",
        "id_": "id",
        "in_reply_to_author_identity_id": "inReplyToAuthorIdentityId",
        "in_reply_to_content_id": "inReplyToContentId",
        "intervention_id": "interventionId",
        "remotely_deleted": "remotelyDeleted",
        "source_id": "sourceId",
        "source_type": "sourceType",
        "source_uri": "sourceUri",
        "synchronization_status": "synchronizationStatus",
        "synchronization_error": "synchronizationError",
        "thread_id": "threadId",
        "type_": "type",
        "last_modified_time": "lastModifiedTime",
        "capabilities_supported": "capabilitiesSupported",
    }
)
class ContentModel(BaseModel):
    """ContentModel

    :param attachments: An array containing the attachments that are attached to the content.<br>
    :type attachments: List[ContentAttachment]
    :param author_identity_id: Identity identifier of the author of content.<br><br>Not mandatory on creation, by default it uses the token's user first identity on channel.<br>
    :type author_identity_id: str
    :param auto_submitted: Auto submitted content:<br>  - won't reopen tasks or interventions<br>  - can be used to send automatic messages like asking an user to follow on twitter, sending a survey, etc,<br>  - doesn't get included in statistics<br>
    :type auto_submitted: bool
    :param body: The content's body.<br><br>On creation this field is mandatory except for WhatsApp content using templates.<br><br>The following are the max length restrictions for the different channels supported.<br>Channel and max length<br>  * Apple Messages For Business (max length 10000)<br>  * Email (max length 262144)<br>  * RingCX Digital Messaging (max length 1024)<br>  * Facebook (max length 8000)<br>  * GoogleBusinessMessages (max length 3000)<br>  * Google My Business (max length 4000)<br>  * Instagram (max length 950)<br>  * Instagram Messaging (max length 1000)<br>  * LinkedIn (max length 3000)<br>  * Messenger (max length 2000)<br>  * Twitter (max length 280)<br>  * Viber (max length 7000)<br>  * WhatsApp (max length 3800)<br>  * Youtube (max length 8000)<br>
    :type body: str
    :param body_formatted: Text and HTML formatted versions of the content body.
    :type body_formatted: ContentBodyFormatted
    :param body_input_format: Values can be Text or Html.
    :type body_input_format: ContentBodyInputFormat
    :param category_ids: List of the category identifiers of the content.<br>
    :type category_ids: List[str]
    :param context_data: Additional data of the content.<br><br>The contextData hash keys are the custom fields keys.<br>, defaults to None
    :type context_data: dict, optional
    :param creation_time: Creation time of the resource.
    :type creation_time: str
    :param created_from: Created from of the content.
    :type created_from: ContentCreatedFrom
    :param creator_id: RC user id of the creator
    :type creator_id: str
    :param foreign_categories: External categories of the content.<br><br>Present only if the content has foreignCategories.<br>, defaults to None
    :type foreign_categories: List[str], optional
    :param id_: Identifier of the content.
    :type id_: str
    :param in_reply_to_author_identity_id: The identity identifier of the content to which this content is a reply to.
    :type in_reply_to_author_identity_id: str
    :param in_reply_to_content_id: The content identifier to which this content is a reply to.<br><br>On creation, if omitted, a new discussion will be created. If the channel does not support to initiate discussion this parameter is mandatory.<br>
    :type in_reply_to_content_id: str
    :param intervention_id: The intervention identifier of the content.
    :type intervention_id: str
    :param language: Language of the content.
    :type language: str
    :param public: True if the content is publicly visible on the remote channel (default).<br><br>Private content is NOT supported on every channel.<br>
    :type public: bool
    :param published: True if the content is published on the remote channel.
    :type published: bool
    :param rating: Rating of the content.<br><br>Present only if the content supports rating and rating is filled.<br>
    :type rating: int
    :param remotely_deleted: True if the content has been deleted on the remote channel.
    :type remotely_deleted: bool
    :param source_id: Identifier of the channel.<br><br>On creation if `inReplyToContentId` is specified, the channel will be determined from it. Otherwise, this parameter is mandatory.<br>
    :type source_id: str
    :param source_type: Type of the channel.
    :type source_type: ContentSourceType
    :param source_uri: External Uri of the content channel.
    :type source_uri: str
    :param status: Content status.
    :type status: ContentStatus
    :param synchronization_status: Synchronization status.
    :type synchronization_status: str
    :param synchronization_error: Synchronization error details.
    :type synchronization_error: str
    :param thread_id: Content thread identifier of the content.
    :type thread_id: str
    :param title: Applicable to Email channels only.<br><br>The subject of the email.<br><br>This field is mandatory when initiating a discussion.<br>
    :type title: str
    :param type_: Type of the content.
    :type type_: ContentType
    :param last_modified_time: The time when the last modification was completed.
    :type last_modified_time: str
    :param capabilities_supported: Types of structured messages that can be used to reply to this type of message.
    :type capabilities_supported: List[str]
    """

    def __init__(
        self,
        attachments: List[ContentAttachment],
        author_identity_id: str,
        auto_submitted: bool,
        body: str,
        body_formatted: ContentBodyFormatted,
        body_input_format: ContentBodyInputFormat,
        category_ids: List[str],
        creation_time: str,
        created_from: ContentCreatedFrom,
        creator_id: str,
        id_: str,
        in_reply_to_author_identity_id: str,
        in_reply_to_content_id: str,
        intervention_id: str,
        language: str,
        public: bool,
        published: bool,
        rating: int,
        remotely_deleted: bool,
        source_id: str,
        source_type: ContentSourceType,
        source_uri: str,
        status: ContentStatus,
        synchronization_status: str,
        synchronization_error: str,
        thread_id: str,
        title: str,
        type_: ContentType,
        last_modified_time: str,
        capabilities_supported: List[str],
        context_data: dict = None,
        foreign_categories: List[str] = None,
    ):
        self.attachments = self._define_list(attachments, ContentAttachment)
        self.author_identity_id = author_identity_id
        self.auto_submitted = auto_submitted
        self.body = body
        self.body_formatted = self._define_object(body_formatted, ContentBodyFormatted)
        self.body_input_format = self._enum_matching(
            body_input_format, ContentBodyInputFormat.list(), "body_input_format"
        )
        self.category_ids = category_ids
        if context_data is not None:
            self.context_data = context_data
        self.creation_time = creation_time
        self.created_from = self._enum_matching(
            created_from, ContentCreatedFrom.list(), "created_from"
        )
        self.creator_id = creator_id
        if foreign_categories is not None:
            self.foreign_categories = foreign_categories
        self.id_ = id_
        self.in_reply_to_author_identity_id = in_reply_to_author_identity_id
        self.in_reply_to_content_id = in_reply_to_content_id
        self.intervention_id = intervention_id
        self.language = language
        self.public = public
        self.published = published
        self.rating = rating
        self.remotely_deleted = remotely_deleted
        self.source_id = source_id
        self.source_type = self._enum_matching(
            source_type, ContentSourceType.list(), "source_type"
        )
        self.source_uri = source_uri
        self.status = self._enum_matching(status, ContentStatus.list(), "status")
        self.synchronization_status = synchronization_status
        self.synchronization_error = synchronization_error
        self.thread_id = thread_id
        self.title = title
        self.type_ = self._enum_matching(type_, ContentType.list(), "type_")
        self.last_modified_time = last_modified_time
        self.capabilities_supported = capabilities_supported
