# This file was generated by liblab | https://liblab.com/

from __future__ import annotations
from enum import Enum
from typing import List
from .utils.json_map import JsonMap
from .base import BaseModel
from .transfer_info import TransferInfo
from .fixed_order_agents import FixedOrderAgents
from .unconditional_forwarding_info import UnconditionalForwardingInfo


class TransferMode(Enum):
    """An enumeration representing different categories.

    :cvar ROTATING: "Rotating"
    :vartype ROTATING: str
    :cvar SIMULTANEOUS: "Simultaneous"
    :vartype SIMULTANEOUS: str
    :cvar FIXEDORDER: "FixedOrder"
    :vartype FIXEDORDER: str
    """

    ROTATING = "Rotating"
    SIMULTANEOUS = "Simultaneous"
    FIXEDORDER = "FixedOrder"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, TransferMode._member_map_.values()))


class NoAnswerAction(Enum):
    """An enumeration representing different categories.

    :cvar WAITPRIMARYMEMBERS: "WaitPrimaryMembers"
    :vartype WAITPRIMARYMEMBERS: str
    :cvar WAITPRIMARYANDOVERFLOWMEMBERS: "WaitPrimaryAndOverflowMembers"
    :vartype WAITPRIMARYANDOVERFLOWMEMBERS: str
    :cvar VOICEMAIL: "Voicemail"
    :vartype VOICEMAIL: str
    :cvar TRANSFERTOEXTENSION: "TransferToExtension"
    :vartype TRANSFERTOEXTENSION: str
    :cvar UNCONDITIONALFORWARDING: "UnconditionalForwarding"
    :vartype UNCONDITIONALFORWARDING: str
    """

    WAITPRIMARYMEMBERS = "WaitPrimaryMembers"
    WAITPRIMARYANDOVERFLOWMEMBERS = "WaitPrimaryAndOverflowMembers"
    VOICEMAIL = "Voicemail"
    TRANSFERTOEXTENSION = "TransferToExtension"
    UNCONDITIONALFORWARDING = "UnconditionalForwarding"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, NoAnswerAction._member_map_.values()))


class HoldAudioInterruptionMode(Enum):
    """An enumeration representing different categories.

    :cvar NEVER: "Never"
    :vartype NEVER: str
    :cvar WHENMUSICENDS: "WhenMusicEnds"
    :vartype WHENMUSICENDS: str
    :cvar PERIODICALLY: "Periodically"
    :vartype PERIODICALLY: str
    """

    NEVER = "Never"
    WHENMUSICENDS = "WhenMusicEnds"
    PERIODICALLY = "Periodically"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(
            map(lambda x: x.value, HoldAudioInterruptionMode._member_map_.values())
        )


class HoldTimeExpirationAction(Enum):
    """An enumeration representing different categories.

    :cvar TRANSFERTOEXTENSION: "TransferToExtension"
    :vartype TRANSFERTOEXTENSION: str
    :cvar UNCONDITIONALFORWARDING: "UnconditionalForwarding"
    :vartype UNCONDITIONALFORWARDING: str
    :cvar VOICEMAIL: "Voicemail"
    :vartype VOICEMAIL: str
    """

    TRANSFERTOEXTENSION = "TransferToExtension"
    UNCONDITIONALFORWARDING = "UnconditionalForwarding"
    VOICEMAIL = "Voicemail"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(
            map(lambda x: x.value, HoldTimeExpirationAction._member_map_.values())
        )


class MaxCallersAction(Enum):
    """An enumeration representing different categories.

    :cvar VOICEMAIL: "Voicemail"
    :vartype VOICEMAIL: str
    :cvar ANNOUNCEMENT: "Announcement"
    :vartype ANNOUNCEMENT: str
    :cvar TRANSFERTOEXTENSION: "TransferToExtension"
    :vartype TRANSFERTOEXTENSION: str
    :cvar UNCONDITIONALFORWARDING: "UnconditionalForwarding"
    :vartype UNCONDITIONALFORWARDING: str
    """

    VOICEMAIL = "Voicemail"
    ANNOUNCEMENT = "Announcement"
    TRANSFERTOEXTENSION = "TransferToExtension"
    UNCONDITIONALFORWARDING = "UnconditionalForwarding"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, MaxCallersAction._member_map_.values()))


@JsonMap(
    {
        "transfer_mode": "transferMode",
        "no_answer_action": "noAnswerAction",
        "fixed_order_agents": "fixedOrderAgents",
        "hold_audio_interruption_mode": "holdAudioInterruptionMode",
        "hold_audio_interruption_period": "holdAudioInterruptionPeriod",
        "hold_time_expiration_action": "holdTimeExpirationAction",
        "agent_timeout": "agentTimeout",
        "wrap_up_time": "wrapUpTime",
        "hold_time": "holdTime",
        "max_callers": "maxCallers",
        "max_callers_action": "maxCallersAction",
        "unconditional_forwarding": "unconditionalForwarding",
    }
)
class QueueInfo(BaseModel):
    """Queue settings applied for department (call queue) extension type,
    with the 'AgentQueue' value specified as a call handling action


    :param transfer_mode: Specifies how calls are transferred to group members, defaults to None
    :type transfer_mode: TransferMode, optional
    :param transfer: Call transfer information, defaults to None
    :type transfer: List[TransferInfo], optional
    :param no_answer_action: Specifies the type of action to be taken if: members are available<br>but no one answers, or all members are busy/unavailable. This option is<br>available for Business hours only. For simultaneous transfer mode only<br>'WaitPrimaryMembers' and 'WaitPrimaryAndOverflowMembers' are supported<br>, defaults to None
    :type no_answer_action: NoAnswerAction, optional
    :param fixed_order_agents: Information on a call forwarding rule, defaults to None
    :type fixed_order_agents: List[FixedOrderAgents], optional
    :param hold_audio_interruption_mode: Connecting audio interruption mode, defaults to None
    :type hold_audio_interruption_mode: HoldAudioInterruptionMode, optional
    :param hold_audio_interruption_period: Connecting audio interruption message period in seconds, defaults to None
    :type hold_audio_interruption_period: int, optional
    :param hold_time_expiration_action: Specifies the type of action to be taken after the hold time<br>(waiting for an available call queue member) expires. If 'TransferToExtension'<br>option is selected, the extension specified in `transfer` field is used.<br>The default value is `Voicemail`<br>, defaults to None
    :type hold_time_expiration_action: HoldTimeExpirationAction, optional
    :param agent_timeout: Maximum time in seconds to wait for a call queue member before trying the next member, defaults to None
    :type agent_timeout: int, optional
    :param wrap_up_time: Minimum post-call wrap up time in seconds before agent status<br>is automatically set; the value range is from 0 to 300 sec.<br>, defaults to None
    :type wrap_up_time: int, optional
    :param hold_time: Maximum hold time in seconds to wait for an available call queue member, defaults to None
    :type hold_time: int, optional
    :param max_callers: Maximum count of callers on hold; the limitation is 25 callers, defaults to None
    :type max_callers: int, optional
    :param max_callers_action: Specifies the type of action to be taken if count of callers on hold exceeds the supported maximum, defaults to None
    :type max_callers_action: MaxCallersAction, optional
    :param unconditional_forwarding: unconditional_forwarding, defaults to None
    :type unconditional_forwarding: List[UnconditionalForwardingInfo], optional
    """

    def __init__(
        self,
        transfer_mode: TransferMode = None,
        transfer: List[TransferInfo] = None,
        no_answer_action: NoAnswerAction = None,
        fixed_order_agents: List[FixedOrderAgents] = None,
        hold_audio_interruption_mode: HoldAudioInterruptionMode = None,
        hold_audio_interruption_period: int = None,
        hold_time_expiration_action: HoldTimeExpirationAction = None,
        agent_timeout: int = None,
        wrap_up_time: int = None,
        hold_time: int = None,
        max_callers: int = None,
        max_callers_action: MaxCallersAction = None,
        unconditional_forwarding: List[UnconditionalForwardingInfo] = None,
    ):
        if transfer_mode is not None:
            self.transfer_mode = self._enum_matching(
                transfer_mode, TransferMode.list(), "transfer_mode"
            )
        if transfer is not None:
            self.transfer = self._define_list(transfer, TransferInfo)
        if no_answer_action is not None:
            self.no_answer_action = self._enum_matching(
                no_answer_action, NoAnswerAction.list(), "no_answer_action"
            )
        if fixed_order_agents is not None:
            self.fixed_order_agents = self._define_list(
                fixed_order_agents, FixedOrderAgents
            )
        if hold_audio_interruption_mode is not None:
            self.hold_audio_interruption_mode = self._enum_matching(
                hold_audio_interruption_mode,
                HoldAudioInterruptionMode.list(),
                "hold_audio_interruption_mode",
            )
        if hold_audio_interruption_period is not None:
            self.hold_audio_interruption_period = hold_audio_interruption_period
        if hold_time_expiration_action is not None:
            self.hold_time_expiration_action = self._enum_matching(
                hold_time_expiration_action,
                HoldTimeExpirationAction.list(),
                "hold_time_expiration_action",
            )
        if agent_timeout is not None:
            self.agent_timeout = agent_timeout
        if wrap_up_time is not None:
            self.wrap_up_time = wrap_up_time
        if hold_time is not None:
            self.hold_time = hold_time
        if max_callers is not None:
            self.max_callers = max_callers
        if max_callers_action is not None:
            self.max_callers_action = self._enum_matching(
                max_callers_action, MaxCallersAction.list(), "max_callers_action"
            )
        if unconditional_forwarding is not None:
            self.unconditional_forwarding = self._define_list(
                unconditional_forwarding, UnconditionalForwardingInfo
            )
