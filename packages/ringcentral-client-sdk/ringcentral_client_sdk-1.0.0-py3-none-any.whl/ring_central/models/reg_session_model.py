# This file was generated by liblab | https://liblab.com/

from enum import Enum
from .utils.json_map import JsonMap
from .base import BaseModel


class RegistrationStatus(Enum):
    """An enumeration representing different categories.

    :cvar OPEN: "Open"
    :vartype OPEN: str
    :cvar CLOSED: "Closed"
    :vartype CLOSED: str
    """

    OPEN = "Open"
    CLOSED = "Closed"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, RegistrationStatus._member_map_.values()))


class OnDemandDuration(Enum):
    """An enumeration representing different categories.

    :cvar ONEMONTH: "OneMonth"
    :vartype ONEMONTH: str
    :cvar TWOMONTHS: "TwoMonths"
    :vartype TWOMONTHS: str
    :cvar THREEMONTHS: "ThreeMonths"
    :vartype THREEMONTHS: str
    :cvar SIXMONTHS: "SixMonths"
    :vartype SIXMONTHS: str
    :cvar ONEYEAR: "OneYear"
    :vartype ONEYEAR: str
    """

    ONEMONTH = "OneMonth"
    TWOMONTHS = "TwoMonths"
    THREEMONTHS = "ThreeMonths"
    SIXMONTHS = "SixMonths"
    ONEYEAR = "OneYear"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, OnDemandDuration._member_map_.values()))


@JsonMap(
    {
        "auto_close_limit": "autoCloseLimit",
        "suppress_emails": "suppressEmails",
        "registration_digest_enabled": "registrationDigestEnabled",
        "prevent_multiple_device_joins": "preventMultipleDeviceJoins",
        "work_email_required": "workEmailRequired",
        "view_recording": "viewRecording",
        "on_demand_duration": "onDemandDuration",
        "recording_exist": "recordingExist",
    }
)
class Settings(BaseModel):
    """Settings

    :param auto_close_limit: The maximum number of registrants which forces closing the registration (0 means "off")., defaults to None
    :type auto_close_limit: int, optional
    :param suppress_emails: Indicates that emails to registrants should be suppressed (should be supported by external party), defaults to None
    :type suppress_emails: bool, optional
    :param registration_digest_enabled: Indicates that registration digest should be sent to host., defaults to None
    :type registration_digest_enabled: bool, optional
    :param prevent_multiple_device_joins: Indicates that registrants are allowed to join from multiple devices., defaults to None
    :type prevent_multiple_device_joins: bool, optional
    :param work_email_required: Indicates that work email address is required for registration., defaults to None
    :type work_email_required: bool, optional
    :param view_recording: Indicates that recording will be shown after the webinar and in emails., defaults to None
    :type view_recording: bool, optional
    :param on_demand_duration: Duration of on-demand webinar. The default value can only be used if the session is on demand., defaults to None
    :type on_demand_duration: OnDemandDuration, optional
    :param recording_exist: Indicates that recording exists for the session., defaults to None
    :type recording_exist: bool, optional
    """

    def __init__(
        self,
        auto_close_limit: int = None,
        suppress_emails: bool = None,
        registration_digest_enabled: bool = None,
        prevent_multiple_device_joins: bool = None,
        work_email_required: bool = None,
        view_recording: bool = None,
        on_demand_duration: OnDemandDuration = None,
        recording_exist: bool = None,
    ):
        if auto_close_limit is not None:
            self.auto_close_limit = auto_close_limit
        if suppress_emails is not None:
            self.suppress_emails = suppress_emails
        if registration_digest_enabled is not None:
            self.registration_digest_enabled = registration_digest_enabled
        if prevent_multiple_device_joins is not None:
            self.prevent_multiple_device_joins = prevent_multiple_device_joins
        if work_email_required is not None:
            self.work_email_required = work_email_required
        if view_recording is not None:
            self.view_recording = view_recording
        if on_demand_duration is not None:
            self.on_demand_duration = self._enum_matching(
                on_demand_duration, OnDemandDuration.list(), "on_demand_duration"
            )
        if recording_exist is not None:
            self.recording_exist = recording_exist


@JsonMap(
    {
        "id_": "id",
        "registration_status": "registrationStatus",
        "registration_page_uri": "registrationPageUri",
        "branding_descriptor_uri": "brandingDescriptorUri",
        "registrant_count": "registrantCount",
        "has_real_registrants": "hasRealRegistrants",
        "icalendar_sequence": "icalendarSequence",
    }
)
class RegSessionModel(BaseModel):
    """RegSessionModel

    :param id_: ID of the session
    :type id_: str
    :param registration_status: Status of the registration
    :type registration_status: RegistrationStatus
    :param registration_page_uri: The URI of the registration landing page, defaults to None
    :type registration_page_uri: str, optional
    :param branding_descriptor_uri: The URI of the branding descriptor, defaults to None
    :type branding_descriptor_uri: str, optional
    :param registrant_count: The current number of registrants
    :type registrant_count: int
    :param has_real_registrants: Indicates that there are non-test registrants
    :type has_real_registrants: bool
    :param icalendar_sequence: Sequence number for iCalendar email attachments, defaults to None
    :type icalendar_sequence: int, optional
    :param settings: settings, defaults to None
    :type settings: Settings, optional
    """

    def __init__(
        self,
        id_: str,
        registration_status: RegistrationStatus,
        registrant_count: int,
        has_real_registrants: bool,
        registration_page_uri: str = None,
        branding_descriptor_uri: str = None,
        icalendar_sequence: int = None,
        settings: Settings = None,
    ):
        self.id_ = id_
        self.registration_status = self._enum_matching(
            registration_status, RegistrationStatus.list(), "registration_status"
        )
        if registration_page_uri is not None:
            self.registration_page_uri = registration_page_uri
        if branding_descriptor_uri is not None:
            self.branding_descriptor_uri = branding_descriptor_uri
        self.registrant_count = registrant_count
        self.has_real_registrants = has_real_registrants
        if icalendar_sequence is not None:
            self.icalendar_sequence = icalendar_sequence
        if settings is not None:
            self.settings = self._define_object(settings, Settings)
