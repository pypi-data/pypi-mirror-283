# This file was generated by liblab | https://liblab.com/

from __future__ import annotations
from enum import Enum
from typing import List
from .utils.json_map import JsonMap
from .base import BaseModel
from .disabled_filter_info import DisabledFilterInfo
from .notification_delivery_mode import (
    NotificationDeliveryMode,
    NotificationDeliveryModeGuard,
)
from .webhook_delivery_mode import WebhookDeliveryMode
from .mobile_delivery_mode import MobileDeliveryMode
from .pub_nub_delivery_mode import PubNubDeliveryMode
from .web_socket_delivery_mode import WebSocketDeliveryMode


class SubscriptionInfoStatus(Enum):
    """An enumeration representing different categories.

    :cvar ACTIVE: "Active"
    :vartype ACTIVE: str
    :cvar BLACKLISTED: "Blacklisted"
    :vartype BLACKLISTED: str
    """

    ACTIVE = "Active"
    BLACKLISTED = "Blacklisted"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(
            map(lambda x: x.value, SubscriptionInfoStatus._member_map_.values())
        )


@JsonMap({"blacklisted_at": "blacklistedAt"})
class BlacklistedData(BaseModel):
    """Returned if a WebHook subscription is blacklisted

    :param blacklisted_at: Time of adding subscription to a black list in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)<br>format including timezone, for example *2016-03-10T18:07:52.534Z*<br>, defaults to None
    :type blacklisted_at: str, optional
    :param reason: Reason of adding subscription to a black list, defaults to None
    :type reason: str, optional
    """

    def __init__(self, blacklisted_at: str = None, reason: str = None):
        if blacklisted_at is not None:
            self.blacklisted_at = blacklisted_at
        if reason is not None:
            self.reason = reason


@JsonMap(
    {
        "id_": "id",
        "event_filters": "eventFilters",
        "disabled_filters": "disabledFilters",
        "expiration_time": "expirationTime",
        "expires_in": "expiresIn",
        "creation_time": "creationTime",
        "delivery_mode": "deliveryMode",
        "blacklisted_data": "blacklistedData",
    }
)
class SubscriptionInfo(BaseModel):
    """SubscriptionInfo

    :param uri: Canonical URI of a subscription resource
    :type uri: str
    :param id_: Internal identifier of a subscription
    :type id_: str
    :param event_filters: The list of event filter names corresponding to events the user is subscribed to
    :type event_filters: List[str]
    :param disabled_filters: The list of event filter names corresponding to events the user is not subscribed to due to<br>certain limitations<br>, defaults to None
    :type disabled_filters: List[DisabledFilterInfo], optional
    :param expiration_time: Subscription expiration time in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)<br>format including timezone, for example *2016-03-10T18:07:52.534Z*<br>
    :type expiration_time: str
    :param expires_in: Subscription lifetime in seconds, defaults to None
    :type expires_in: int, optional
    :param status: Subscription status
    :type status: SubscriptionInfoStatus
    :param creation_time: Subscription creation time in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)<br>format including timezone, for example *2016-03-10T18:07:52.534*<br>
    :type creation_time: str
    :param delivery_mode: Notification delivery transport information
    :type delivery_mode: NotificationDeliveryMode
    :param blacklisted_data: Returned if a WebHook subscription is blacklisted, defaults to None
    :type blacklisted_data: BlacklistedData, optional
    """

    def __init__(
        self,
        uri: str,
        id_: str,
        event_filters: List[str],
        expiration_time: str,
        status: SubscriptionInfoStatus,
        creation_time: str,
        delivery_mode: NotificationDeliveryMode,
        disabled_filters: List[DisabledFilterInfo] = None,
        expires_in: int = None,
        blacklisted_data: BlacklistedData = None,
    ):
        self.uri = uri
        self.id_ = id_
        self.event_filters = event_filters
        if disabled_filters is not None:
            self.disabled_filters = self._define_list(
                disabled_filters, DisabledFilterInfo
            )
        self.expiration_time = expiration_time
        if expires_in is not None:
            self.expires_in = expires_in
        self.status = self._enum_matching(
            status, SubscriptionInfoStatus.list(), "status"
        )
        self.creation_time = creation_time
        self.delivery_mode = NotificationDeliveryModeGuard.return_one_of(delivery_mode)
        if blacklisted_data is not None:
            self.blacklisted_data = self._define_object(
                blacklisted_data, BlacklistedData
            )
