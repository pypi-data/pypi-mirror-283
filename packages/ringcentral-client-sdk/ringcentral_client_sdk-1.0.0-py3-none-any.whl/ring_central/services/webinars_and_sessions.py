# This file was generated by liblab | https://liblab.com/

from typing import List
from .utils.validator import Validator
from .utils.base_service import BaseService
from ..net.transport.serializer import Serializer
from ..models.webinar_list_resource import WebinarListResource
from ..models.webinar_creation_request import WebinarCreationRequest
from ..models.webinar_base_model import WebinarBaseModel
from ..models.wcs_webinar_resource import WcsWebinarResource
from ..models.wcs_session_with_locale_code_model import WcsSessionWithLocaleCodeModel
from ..models.wcs_session_status_model import WcsSessionStatusModel
from ..models.wcs_session_resource import WcsSessionResource
from ..models.wcs_session_global_list_resource import WcsSessionGlobalListResource
from ..models.utils.cast_models import cast_models


class WebinarsAndSessionsService(BaseService):

    @cast_models
    def rcw_config_list_webinars(
        self, creation_time_from: str, per_page: int = None, page_token: str = None
    ) -> WebinarListResource:
        """Returns the list of Webinars hosted by a current authorized user sorted by 'scheduledStartTime' or 'creationTime' in the ascending order.

        :param creation_time_from: The beginning of the time window by 'creationTime' .
        :type creation_time_from: str
        :param per_page: The number of items per page. If provided value in the request
        is greater than a maximum, the maximum value is applied, defaults to None
        :type per_page: int, optional
        :param page_token: The token indicating the particular page of the result set to be retrieved.
        If omitted the first page will be returned., defaults to None
        :type page_token: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response
        :rtype: WebinarListResource
        """

        Validator(str).validate(creation_time_from)
        Validator(int).is_optional().min(1).max(1000).validate(per_page)
        Validator(str).is_optional().validate(page_token)

        serialized_request = (
            Serializer(
                f"{self.base_url}/webinar/configuration/v1/webinars",
                self.get_default_headers(),
            )
            .add_query("creationTimeFrom", creation_time_from, explode=False)
            .add_query("perPage", per_page, explode=False)
            .add_query("pageToken", page_token, explode=False)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return WebinarListResource._unmap(response)

    @cast_models
    def rcw_config_create_webinar(
        self, request_body: WebinarCreationRequest
    ) -> WcsWebinarResource:
        """Creates a new webinar.

        If "host" parameter is NOT passed then the current authorized user will become a Host.
        If "host" parameter is passed then the caller must be a company administrator and have "WebinarSettings" permission.
        "host.linkedUser.accountId" must be the same as authorized user's account ID.

        The webinar settings which are not mandated at account level or are unlocked can be
        specified. All other settings are defaulted according to account policy.

        :param request_body: The request body.
        :type request_body: WebinarCreationRequest
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response, new Webinar is created
        :rtype: WcsWebinarResource
        """

        Validator(WebinarCreationRequest).validate(request_body)

        serialized_request = (
            Serializer(
                f"{self.base_url}/webinar/configuration/v1/webinars",
                self.get_default_headers(),
            )
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return WcsWebinarResource._unmap(response)

    @cast_models
    def rcw_config_get_webinar(self, webinar_id: str) -> WcsWebinarResource:
        """Returns a Webinar information by ID.
        Some webinar settings are returned basing on webinar-level overrides, other - from default settings defined at account level.

        :param webinar_id: Identifier of the Webinar.
        :type webinar_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response
        :rtype: WcsWebinarResource
        """

        Validator(str).min_length(1).max_length(20).validate(webinar_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/webinar/configuration/v1/webinars/{{webinarId}}",
                self.get_default_headers(),
            )
            .add_path("webinarId", webinar_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return WcsWebinarResource._unmap(response)

    @cast_models
    def rcw_config_update_webinar(
        self, request_body: WebinarBaseModel, webinar_id: str
    ) -> WcsWebinarResource:
        """Updates a Webinar. The payload may contain just changed fields of a Webinar resource (it is a partial update):
        - host cannot be changed, and host user information cannot be updated;
        - only the settings which are not mandated at account level or are unlocked can be
        changed;
        - in order to reset a webinar password it should be passed as an empty string;
        - "registrationStatus" cannot be changed.

        :param request_body: The request body.
        :type request_body: WebinarBaseModel
        :param webinar_id: Identifier of the Webinar.
        :type webinar_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response
        :rtype: WcsWebinarResource
        """

        Validator(WebinarBaseModel).validate(request_body)
        Validator(str).min_length(1).max_length(20).validate(webinar_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/webinar/configuration/v1/webinars/{{webinarId}}",
                self.get_default_headers(),
            )
            .add_path("webinarId", webinar_id)
            .serialize()
            .set_method("PATCH")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return WcsWebinarResource._unmap(response)

    @cast_models
    def rcw_config_delete_webinar(self, webinar_id: str):
        """Deletes a Webinar by ID. All child objects (Sessions, Invitees) will be also deleted.
        It is disallowed to delete a Webinar which has at least one Session in 'Active' or 'Finished' state.

        :param webinar_id: Identifier of the Webinar.
        :type webinar_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(str).min_length(1).max_length(20).validate(webinar_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/webinar/configuration/v1/webinars/{{webinarId}}",
                self.get_default_headers(),
            )
            .add_path("webinarId", webinar_id)
            .serialize()
            .set_method("DELETE")
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def rcw_config_create_session(
        self, request_body: WcsSessionWithLocaleCodeModel, webinar_id: str
    ) -> WcsSessionResource:
        """Creates a new Session for a given Webinar

        :param request_body: The request body.
        :type request_body: WcsSessionWithLocaleCodeModel
        :param webinar_id: Identifier of the Webinar.
        :type webinar_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response, new Session is created
        :rtype: WcsSessionResource
        """

        Validator(WcsSessionWithLocaleCodeModel).validate(request_body)
        Validator(str).min_length(1).max_length(20).validate(webinar_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/webinar/configuration/v1/webinars/{{webinarId}}/sessions",
                self.get_default_headers(),
            )
            .add_path("webinarId", webinar_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return WcsSessionResource._unmap(response)

    @cast_models
    def rcw_config_get_session(
        self, webinar_id: str, session_id: str
    ) -> WcsSessionResource:
        """Returns a Webinar Session by ID.

        :param webinar_id: Identifier of the Webinar.
        :type webinar_id: str
        :param session_id: Identifier of the Session.
        :type session_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response
        :rtype: WcsSessionResource
        """

        Validator(str).min_length(1).max_length(20).validate(webinar_id)
        Validator(str).min_length(1).max_length(20).validate(session_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/webinar/configuration/v1/webinars/{{webinarId}}/sessions/{{sessionId}}",
                self.get_default_headers(),
            )
            .add_path("webinarId", webinar_id)
            .add_path("sessionId", session_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return WcsSessionResource._unmap(response)

    @cast_models
    def rcw_config_update_session(
        self,
        request_body: WcsSessionWithLocaleCodeModel,
        webinar_id: str,
        session_id: str,
    ) -> WcsSessionResource:
        """Updates a Webinar Session. The payload may contain certain attributes from the Session resource
        (it is a partial update). Changing the 'status' field usually invokes certain workflow actions.
        Updating a Session in 'Active' or 'Finished' status is prohibited.
        Some status transitions (for example, to 'Active" or 'Finished') may be prohibited.

        :param request_body: The request body.
        :type request_body: WcsSessionWithLocaleCodeModel
        :param webinar_id: Identifier of the Webinar.
        :type webinar_id: str
        :param session_id: Identifier of the Session.
        :type session_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response
        :rtype: WcsSessionResource
        """

        Validator(WcsSessionWithLocaleCodeModel).validate(request_body)
        Validator(str).min_length(1).max_length(20).validate(webinar_id)
        Validator(str).min_length(1).max_length(20).validate(session_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/webinar/configuration/v1/webinars/{{webinarId}}/sessions/{{sessionId}}",
                self.get_default_headers(),
            )
            .add_path("webinarId", webinar_id)
            .add_path("sessionId", session_id)
            .serialize()
            .set_method("PATCH")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return WcsSessionResource._unmap(response)

    @cast_models
    def rcw_config_delete_session(self, webinar_id: str, session_id: str):
        """Deletes a Webinar Session. All child objects (Invitees) will be also deleted.
        It is disallowed to delete a Session which is in 'Active' or 'Finished' state

        :param webinar_id: Identifier of the Webinar.
        :type webinar_id: str
        :param session_id: Identifier of the Session.
        :type session_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(str).min_length(1).max_length(20).validate(webinar_id)
        Validator(str).min_length(1).max_length(20).validate(session_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/webinar/configuration/v1/webinars/{{webinarId}}/sessions/{{sessionId}}",
                self.get_default_headers(),
            )
            .add_path("webinarId", webinar_id)
            .add_path("sessionId", session_id)
            .serialize()
            .set_method("DELETE")
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def rcw_config_list_all_company_sessions(
        self,
        end_time_from: str,
        status: WcsSessionStatusModel = None,
        host_user_id: List[str] = None,
        per_page: int = None,
        page_token: str = None,
    ) -> WcsSessionGlobalListResource:
        """Returns the list of Webinar Sessions hosted by all company users or particular user(s) sorted by
        'scheduledStartTime' or 'creationTime' (if 'scheduledStartTime' is not set) in the ascending ordered.
        The user must have "WebinarSettings" permission granted otherwise the API returns HTTP 403.

        :param end_time_from: The beginning of the time window by 'endTime' (it is calculated as scheduledStartTime+scheduledDuration)
        :type end_time_from: str
        :param status: Filter to return only webinar sessions in certain status. Multiple values are supported., defaults to None
        :type status: WcsSessionStatusModel, optional
        :param host_user_id: Identifier of the user who hosts a webinar (if omitted, webinars hosted by all company users will be returned), defaults to None
        :type host_user_id: List[str], optional
        :param per_page: The number of items per page. If provided value in the request
        is greater than a maximum, the maximum value is applied, defaults to None
        :type per_page: int, optional
        :param page_token: The token indicating the particular page of the result set to be retrieved.
        If omitted the first page will be returned., defaults to None
        :type page_token: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response
        :rtype: WcsSessionGlobalListResource
        """

        Validator(str).validate(end_time_from)
        Validator(WcsSessionStatusModel).is_optional().validate(status)
        Validator(str).is_array().is_optional().validate(host_user_id)
        Validator(int).is_optional().min(1).max(1000).validate(per_page)
        Validator(str).is_optional().validate(page_token)

        serialized_request = (
            Serializer(
                f"{self.base_url}/webinar/configuration/v1/company/sessions",
                self.get_default_headers(),
            )
            .add_query("status", status)
            .add_query("endTimeFrom", end_time_from, explode=False)
            .add_query("hostUserId", host_user_id, explode=False)
            .add_query("perPage", per_page, explode=False)
            .add_query("pageToken", page_token, explode=False)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return WcsSessionGlobalListResource._unmap(response)

    @cast_models
    def rcw_config_list_all_sessions(
        self,
        end_time_from: str,
        name_fragment: str = None,
        status: WcsSessionStatusModel = None,
        per_page: int = None,
        page_token: str = None,
    ) -> WcsSessionGlobalListResource:
        """Returns the list of Webinar Sessions hosted by a current authorized user sorted by
        'scheduledStartTime' or 'creationTime' (if 'scheduledStartTime' is not set) in the ascending order

        :param end_time_from: The beginning of the time window by 'endTime' (it is calculated as scheduledStartTime+scheduledDuration)
        :type end_time_from: str
        :param name_fragment: Filter to return only webinar sessions containing particular substring within their names, defaults to None
        :type name_fragment: str, optional
        :param status: Filter to return only webinar sessions in certain status. Multiple values are supported., defaults to None
        :type status: WcsSessionStatusModel, optional
        :param per_page: The number of items per page. If provided value in the request
        is greater than a maximum, the maximum value is applied, defaults to None
        :type per_page: int, optional
        :param page_token: The token indicating the particular page of the result set to be retrieved.
        If omitted the first page will be returned., defaults to None
        :type page_token: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response
        :rtype: WcsSessionGlobalListResource
        """

        Validator(str).validate(end_time_from)
        Validator(str).is_optional().validate(name_fragment)
        Validator(WcsSessionStatusModel).is_optional().validate(status)
        Validator(int).is_optional().min(1).max(1000).validate(per_page)
        Validator(str).is_optional().validate(page_token)

        serialized_request = (
            Serializer(
                f"{self.base_url}/webinar/configuration/v1/sessions",
                self.get_default_headers(),
            )
            .add_query("nameFragment", name_fragment)
            .add_query("status", status)
            .add_query("endTimeFrom", end_time_from, explode=False)
            .add_query("perPage", per_page, explode=False)
            .add_query("pageToken", page_token, explode=False)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return WcsSessionGlobalListResource._unmap(response)
