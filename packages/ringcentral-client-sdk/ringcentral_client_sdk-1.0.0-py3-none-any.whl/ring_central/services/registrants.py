# This file was generated by liblab | https://liblab.com/

from .utils.validator import Validator
from .utils.base_service import BaseService
from ..net.transport.serializer import Serializer
from ..models.utils.cast_models import cast_models
from ..models.registrant_model_with_questionnaire import (
    RegistrantModelWithQuestionnaire,
)
from ..models.registrant_model_response_post_with_questionnaire import (
    RegistrantModelResponsePostWithQuestionnaire,
)
from ..models.registrant_list_resource import RegistrantListResource
from ..models.registrant_base_model_with_questionnaire import (
    RegistrantBaseModelWithQuestionnaire,
)


class RegistrantsService(BaseService):

    @cast_models
    def rcw_reg_list_registrants(
        self,
        session_id: str,
        per_page: int = None,
        page_token: str = None,
        include_questionnaire: bool = None,
    ) -> RegistrantListResource:
        """Returns the list of Registrants ordered by "id" ascending.

        A caller must be an authorized user: either a host of the webinar or an IT Admin:
        a user from host's account with "WebinarSettings" permission.

        :param session_id: Identifier of the Session.
        :type session_id: str
        :param per_page: The number of items per page. If provided value in the request
        is greater than a maximum, the maximum value is applied, defaults to None
        :type per_page: int, optional
        :param page_token: The token indicating the particular page of the result set to be retrieved.
        If omitted the first page will be returned., defaults to None
        :type page_token: str, optional
        :param include_questionnaire: Indicates if registrant's "questionnaire" should be returned, defaults to None
        :type include_questionnaire: bool, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response
        :rtype: RegistrantListResource
        """

        Validator(str).min_length(1).max_length(20).validate(session_id)
        Validator(int).is_optional().min(1).max(1000).validate(per_page)
        Validator(str).is_optional().validate(page_token)
        Validator(bool).is_optional().validate(include_questionnaire)

        serialized_request = (
            Serializer(
                f"{self.base_url}/webinar/registration/v1/sessions/{{sessionId}}/registrants",
                self.get_default_headers(),
            )
            .add_path("sessionId", session_id)
            .add_query("perPage", per_page, explode=False)
            .add_query("pageToken", page_token, explode=False)
            .add_query("includeQuestionnaire", include_questionnaire, explode=False)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return RegistrantListResource._unmap(response)

    @cast_models
    def rcw_reg_create_registrant(
        self, request_body: RegistrantBaseModelWithQuestionnaire, session_id: str
    ) -> RegistrantModelResponsePostWithQuestionnaire:
        """Creates a new Registrant for a given session.

        Registration MUST be open for the session for this call to succeed (otherwise it should return HTTP 403).

        A caller must be an authorized user: either a host of the webinar or an IT Admin:
        a user from host's account with "WebinarSettings" permission.

        :param request_body: The request body.
        :type request_body: RegistrantBaseModelWithQuestionnaire
        :param session_id: Identifier of the Session.
        :type session_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response, new Registrant is created
        :rtype: RegistrantModelResponsePostWithQuestionnaire
        """

        Validator(RegistrantBaseModelWithQuestionnaire).validate(request_body)
        Validator(str).min_length(1).max_length(20).validate(session_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/webinar/registration/v1/sessions/{{sessionId}}/registrants",
                self.get_default_headers(),
            )
            .add_path("sessionId", session_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return RegistrantModelResponsePostWithQuestionnaire._unmap(response)

    @cast_models
    def rcw_reg_get_registrant(
        self, session_id: str, registrant_id: str, include_questionnaire: bool = None
    ) -> RegistrantModelWithQuestionnaire:
        """Returns a Registrant by ID.

        A caller must be an authorized user: either a host of the webinar or an IT Admin:
        a user from host's account with "WebinarSettings" permission.

        :param session_id: Identifier of the Session.
        :type session_id: str
        :param registrant_id: Identifier of the Session Registrant
        :type registrant_id: str
        :param include_questionnaire: Indicates if registrant's "questionnaire" should be returned, defaults to None
        :type include_questionnaire: bool, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response
        :rtype: RegistrantModelWithQuestionnaire
        """

        Validator(str).min_length(1).max_length(20).validate(session_id)
        Validator(str).min_length(1).max_length(20).validate(registrant_id)
        Validator(bool).is_optional().validate(include_questionnaire)

        serialized_request = (
            Serializer(
                f"{self.base_url}/webinar/registration/v1/sessions/{{sessionId}}/registrants/{{registrantId}}",
                self.get_default_headers(),
            )
            .add_path("sessionId", session_id)
            .add_path("registrantId", registrant_id)
            .add_query("includeQuestionnaire", include_questionnaire, explode=False)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return RegistrantModelWithQuestionnaire._unmap(response)

    @cast_models
    def rcw_reg_delete_registrant(self, session_id: str, registrant_id: str):
        """Deletes a Registrant by ID.

        Session must not be in finished state (otherwise it should return HTTP 403).

        A caller must be an authorized user: either a host of the webinar or an IT Admin:
        a user from host's account with "WebinarSettings" permission.

        :param session_id: Identifier of the Session.
        :type session_id: str
        :param registrant_id: Identifier of the Session Registrant
        :type registrant_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(str).min_length(1).max_length(20).validate(session_id)
        Validator(str).min_length(1).max_length(20).validate(registrant_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/webinar/registration/v1/sessions/{{sessionId}}/registrants/{{registrantId}}",
                self.get_default_headers(),
            )
            .add_path("sessionId", session_id)
            .add_path("registrantId", registrant_id)
            .serialize()
            .set_method("DELETE")
        )

        response = self.send_request(serialized_request)

        return response
