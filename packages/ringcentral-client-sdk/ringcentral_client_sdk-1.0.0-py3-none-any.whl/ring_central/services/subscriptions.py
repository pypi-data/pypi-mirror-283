# This file was generated by liblab | https://liblab.com/

from .utils.validator import Validator
from .utils.base_service import BaseService
from ..net.transport.serializer import Serializer
from ..models.utils.cast_models import cast_models
from ..models.update_subscription_request import UpdateSubscriptionRequest
from ..models.subscription_list_resource import SubscriptionListResource
from ..models.subscription_info import SubscriptionInfo
from ..models.create_subscription_request import CreateSubscriptionRequest


class SubscriptionsService(BaseService):

    @cast_models
    def list_subscriptions(self) -> SubscriptionListResource:
        """Returns a list of subscriptions created by the user for the current authorized client application.

        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response
        :rtype: SubscriptionListResource
        """

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/subscription", self.get_default_headers()
            )
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return SubscriptionListResource._unmap(response)

    @cast_models
    def create_subscription(
        self, request_body: CreateSubscriptionRequest
    ) -> SubscriptionInfo:
        """This API allows client applications to register a new subscription so that it
        can be notified of events when they occur on the platform.

        A subscription relates to a set of events that a client application would like
        to be informed of and the delivery channel by which they will be notified of
        those events. How subscriptions are established depends upon the notification
        channel the client application would like to use to receive the event
        notification. For example, to create a webhook a developer would create a
        subscription via a REST API call, while specifying a list of events or "event
        filters" to be notified of, a transport type of `WebHook`, and the address or
        URL to which they would like the webhook delivered.

        However, developers wishing to subscribe to a set of events via a WebSocket
        channel, would first connect to the WebSocket gateway, and then issue their
        subscription request over the WebSocket itself, as opposed to making a REST
        API call to this endpoint.

        While the protocol for establishing a subscription may vary depending upon
        the delivery channel for that subscription, the schemas used for representing
        a subscription are the same across all delivery modes.

        Subscriptions are currently limited to 20 subscriptions per user/extension (for particular application).

        RingCentral currently supports the following delivery modes for event subscriptions:

        * [WebHook](https://developers.ringcentral.com/guide/notifications/webhooks/quick-start) - to receive event notifications as an HTTP POST to a given URL
        * [WebSocket](https://developers.ringcentral.com/guide/notifications/websockets/quick-start) - to receive real-time events over a persistent WebSocket connection
        * [PubNub](https://developers.ringcentral.com/guide/notifications/push-notifications/quick-start) (deprecated) - to receive a push notification sent directly to a client application

        Developers should be aware that the PubNub delivery mode is currently
        deprecated and will be removed in 2024. Developers are encouraged to
        [migrate their client applications to use WebSockets](https://developers.ringcentral.com/guide/notifications/websockets/migration/)
        instead.

        :param request_body: The request body.
        :type request_body: CreateSubscriptionRequest
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response
        :rtype: SubscriptionInfo
        """

        Validator(CreateSubscriptionRequest).validate(request_body)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/subscription", self.get_default_headers()
            )
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return SubscriptionInfo._unmap(response)

    @cast_models
    def read_subscription(self, subscription_id: str) -> SubscriptionInfo:
        """Returns the existing subscription by ID.

        :param subscription_id: Internal identifier of a subscription
        :type subscription_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response
        :rtype: SubscriptionInfo
        """

        Validator(str).min_length(1).max_length(20).validate(subscription_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/subscription/{{subscriptionId}}",
                self.get_default_headers(),
            )
            .add_path("subscriptionId", subscription_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return SubscriptionInfo._unmap(response)

    @cast_models
    def update_subscription(
        self, subscription_id: str, request_body: UpdateSubscriptionRequest = None
    ) -> SubscriptionInfo:
        """Updates the existing subscription. The client application can extend or narrow
        the list of events for which it receives notifications within the current subscription.
        If event filters are specified, calling this method modifies them for the
        existing subscription. The method also allows one to set an expiration time for the
        subscription itself.

        If parameters other than `events` and `expiresIn` are specified in the request they will be ignored.
        If the request body is empty then the specified subscription will be renewed without any
        event filter modifications and using the default expiration time.

        If the request is sent with empty body, it just renews a subscription
        (so it is an equivalent of the `POST /restapi/v1.0/subscription/{subscriptionId}/renew`).

        Please note that `WebSocket` subscriptions cannot be updated via HTTP interface.

        :param request_body: The request body., defaults to None
        :type request_body: UpdateSubscriptionRequest, optional
        :param subscription_id: Internal identifier of a subscription
        :type subscription_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response
        :rtype: SubscriptionInfo
        """

        Validator(UpdateSubscriptionRequest).is_optional().validate(request_body)
        Validator(str).min_length(1).max_length(20).validate(subscription_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/subscription/{{subscriptionId}}",
                self.get_default_headers(),
            )
            .add_path("subscriptionId", subscription_id)
            .serialize()
            .set_method("PUT")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return SubscriptionInfo._unmap(response)

    @cast_models
    def delete_subscription(self, subscription_id: str):
        """Cancels the existing subscription.

        :param subscription_id: Internal identifier of a subscription
        :type subscription_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(str).min_length(1).max_length(20).validate(subscription_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/subscription/{{subscriptionId}}",
                self.get_default_headers(),
            )
            .add_path("subscriptionId", subscription_id)
            .serialize()
            .set_method("DELETE")
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def renew_subscription(self, subscription_id: str) -> SubscriptionInfo:
        """Renews the existing subscription (this request comes with empty body).

        Please note that `WebSocket` subscriptions are renewed automatically while websocket session is alive.

        :param subscription_id: Internal identifier of a subscription
        :type subscription_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Subscription renewed successfully
        :rtype: SubscriptionInfo
        """

        Validator(str).min_length(1).max_length(20).validate(subscription_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/subscription/{{subscriptionId}}/renew",
                self.get_default_headers(),
            )
            .add_path("subscriptionId", subscription_id)
            .serialize()
            .set_method("POST")
        )

        response = self.send_request(serialized_request)

        return SubscriptionInfo._unmap(response)
