# This file was generated by liblab | https://liblab.com/

from .utils.validator import Validator
from .utils.base_service import BaseService
from ..net.transport.serializer import Serializer
from ..models.utils.cast_models import cast_models
from ..models.timeline_response import TimelineResponse
from ..models.timeline_request import TimelineRequest
from ..models.interval import Interval
from ..models.aggregation_response import AggregationResponse
from ..models.aggregation_request import AggregationRequest


class BusinessAnalyticsService(BaseService):

    @cast_models
    def analytics_calls_aggregation_fetch(
        self,
        request_body: AggregationRequest,
        account_id: str,
        page: int = None,
        per_page: int = None,
    ) -> AggregationResponse:
        """Returns call aggregations filtered by parameters specified

        :param request_body: The request body.
        :type request_body: AggregationRequest
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param page: The current page number (positive numbers only), defaults to None
        :type page: int, optional
        :param per_page: Number of records displayed on a page (positive numbers only, max value of 200), defaults to None
        :type per_page: int, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Calls Aggregation
        :rtype: AggregationResponse
        """

        Validator(AggregationRequest).validate(request_body)
        Validator(str).validate(account_id)
        Validator(int).is_optional().min(1).validate(page)
        Validator(int).is_optional().min(1).max(200).validate(per_page)

        serialized_request = (
            Serializer(
                f"{self.base_url}/analytics/calls/v1/accounts/{{accountId}}/aggregation/fetch",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_query("page", page)
            .add_query("perPage", per_page)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return AggregationResponse._unmap(response)

    @cast_models
    def analytics_calls_timeline_fetch(
        self,
        request_body: TimelineRequest,
        account_id: str,
        interval: Interval,
        page: int = None,
        per_page: int = None,
    ) -> TimelineResponse:
        """Returns time-value data aggregations filtered by parameters specified

        :param request_body: The request body.
        :type request_body: TimelineRequest
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param interval: Aggregation interval
        :type interval: Interval
        :param page: The current page number (positive numbers only), defaults to None
        :type page: int, optional
        :param per_page: Number of records displayed on a page (positive numbers only, max value of 20), defaults to None
        :type per_page: int, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Calls Timeline
        :rtype: TimelineResponse
        """

        Validator(TimelineRequest).validate(request_body)
        Validator(str).validate(account_id)
        Validator(Interval).validate(interval)
        Validator(int).is_optional().min(1).validate(page)
        Validator(int).is_optional().min(1).max(20).validate(per_page)

        serialized_request = (
            Serializer(
                f"{self.base_url}/analytics/calls/v1/accounts/{{accountId}}/timeline/fetch",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_query("interval", interval)
            .add_query("page", page)
            .add_query("perPage", per_page)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return TimelineResponse._unmap(response)
