# This file was generated by liblab | https://liblab.com/

from typing import List
from .utils.validator import Validator
from .utils.base_service import BaseService
from ..net.transport.serializer import Serializer
from ..models.wireless_points_list import WirelessPointsList
from ..models.wireless_point_info import WirelessPointInfo
from ..models.validate_multiple_wireless_points_response import (
    ValidateMultipleWirelessPointsResponse,
)
from ..models.validate_multiple_wireless_points_request import (
    ValidateMultipleWirelessPointsRequest,
)
from ..models.validate_multiple_switches_response import (
    ValidateMultipleSwitchesResponse,
)
from ..models.validate_multiple_switches_request import ValidateMultipleSwitchesRequest
from ..models.utils.cast_models import cast_models
from ..models.update_wireless_point import UpdateWirelessPoint
from ..models.update_switch_info import UpdateSwitchInfo
from ..models.update_network_request import UpdateNetworkRequest
from ..models.update_multiple_wireless_points_response import (
    UpdateMultipleWirelessPointsResponse,
)
from ..models.update_multiple_wireless_points_request import (
    UpdateMultipleWirelessPointsRequest,
)
from ..models.update_multiple_switches_response import UpdateMultipleSwitchesResponse
from ..models.update_multiple_switches_request import UpdateMultipleSwitchesRequest
from ..models.switches_list import SwitchesList
from ..models.switch_info import SwitchInfo
from ..models.networks_list import NetworksList
from ..models.network_info import NetworkInfo
from ..models.list_emergency_locations_order_by import ListEmergencyLocationsOrderBy
from ..models.list_devices_automatic_location_updates import (
    ListDevicesAutomaticLocationUpdates,
)
from ..models.list_automatic_location_updates_users_type import (
    ListAutomaticLocationUpdatesUsersType,
)
from ..models.get_location_deletion_multi_response import (
    GetLocationDeletionMultiResponse,
)
from ..models.get_extension_emergency_locations_order_by import (
    GetExtensionEmergencyLocationsOrderBy,
)
from ..models.emergency_locations_resource import EmergencyLocationsResource
from ..models.emergency_location_usage_status import EmergencyLocationUsageStatus
from ..models.emergency_location_response_resource import (
    EmergencyLocationResponseResource,
)
from ..models.emergency_location_request_resource import (
    EmergencyLocationRequestResource,
)
from ..models.emergency_address_status import EmergencyAddressStatus
from ..models.emergency_address_auto_update_users_bulk_assign_resource import (
    EmergencyAddressAutoUpdateUsersBulkAssignResource,
)
from ..models.create_wireless_point import CreateWirelessPoint
from ..models.create_user_emergency_location_request import (
    CreateUserEmergencyLocationRequest,
)
from ..models.create_switch_info import CreateSwitchInfo
from ..models.create_network_request import CreateNetworkRequest
from ..models.create_multiple_wireless_points_response import (
    CreateMultipleWirelessPointsResponse,
)
from ..models.create_multiple_wireless_points_request import (
    CreateMultipleWirelessPointsRequest,
)
from ..models.create_multiple_switches_response import CreateMultipleSwitchesResponse
from ..models.create_multiple_switches_request import CreateMultipleSwitchesRequest
from ..models.common_emergency_location_resource import CommonEmergencyLocationResource
from ..models.automatic_location_updates_user_list import (
    AutomaticLocationUpdatesUserList,
)
from ..models.automatic_location_updates_task_info import (
    AutomaticLocationUpdatesTaskInfo,
)
from ..models.assign_multiple_devices_automatic_location_updates import (
    AssignMultipleDevicesAutomaticLocationUpdates,
)


class AutomaticLocationUpdatesService(BaseService):

    @cast_models
    def list_emergency_locations(
        self,
        account_id: str,
        site_id: List[str] = None,
        search_string: str = None,
        address_status: EmergencyAddressStatus = None,
        usage_status: EmergencyLocationUsageStatus = None,
        domestic_country_id: str = None,
        order_by: ListEmergencyLocationsOrderBy = None,
        per_page: int = None,
        page: int = None,
    ) -> EmergencyLocationsResource:
        """Returns emergency response locations for the current account.

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param site_id: Internal identifier of a site for filtering. To indicate company main
        site `main-site` value should be specified. Supported only if multi-site feature
        is enabled for the account. Multiple values are supported., defaults to None
        :type site_id: List[str], optional
        :param search_string: Filters entries containing the specified substring in 'address'
        and 'name' fields. The character range is 0-64; not case-sensitive.
        If empty then the filter is ignored, defaults to None
        :type search_string: str, optional
        :param address_status: address_status, defaults to None
        :type address_status: EmergencyAddressStatus, optional
        :param usage_status: usage_status, defaults to None
        :type usage_status: EmergencyLocationUsageStatus, optional
        :param domestic_country_id: domestic_country_id, defaults to None
        :type domestic_country_id: str, optional
        :param order_by: Comma-separated list of fields to order results, prefixed by
        plus sign '+' (ascending order) or minus sign '-' (descending order), defaults to None
        :type order_by: ListEmergencyLocationsOrderBy, optional
        :param per_page: Indicates a page size (number of items). The values
        supported: `Max` or numeric value. If not specified,
        100 records are returned per one page, defaults to None
        :type per_page: int, optional
        :param page: Indicates the page number to retrieve. Only positive number values
        are supported, defaults to None
        :type page: int, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Emergency locations list
        :rtype: EmergencyLocationsResource
        """

        Validator(str).validate(account_id)
        Validator(str).is_array().is_optional().validate(site_id)
        Validator(str).is_optional().max_length(64).validate(search_string)
        Validator(EmergencyAddressStatus).is_optional().validate(address_status)
        Validator(EmergencyLocationUsageStatus).is_optional().validate(usage_status)
        Validator(str).is_optional().validate(domestic_country_id)
        Validator(ListEmergencyLocationsOrderBy).is_optional().validate(order_by)
        Validator(int).is_optional().validate(per_page)
        Validator(int).is_optional().validate(page)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-locations",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_query("siteId", site_id)
            .add_query("searchString", search_string)
            .add_query("addressStatus", address_status)
            .add_query("usageStatus", usage_status)
            .add_query("domesticCountryId", domestic_country_id)
            .add_query("orderBy", order_by)
            .add_query("perPage", per_page)
            .add_query("page", page)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return EmergencyLocationsResource._unmap(response)

    @cast_models
    def create_emergency_location(
        self, request_body: EmergencyLocationRequestResource, account_id: str
    ) -> EmergencyLocationResponseResource:
        """Creates a new emergency response location for a company.

        :param request_body: The request body.
        :type request_body: EmergencyLocationRequestResource
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Success
        :rtype: EmergencyLocationResponseResource
        """

        Validator(EmergencyLocationRequestResource).validate(request_body)
        Validator(str).validate(account_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-locations",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return EmergencyLocationResponseResource._unmap(response)

    @cast_models
    def read_emergency_location(
        self, account_id: str, location_id: str, sync_emergency_address: bool = None
    ) -> CommonEmergencyLocationResource:
        """Returns emergency response location by ID. Available for Admin users only.

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param location_id: Internal identifier of an emergency response location
        :type location_id: str
        :param sync_emergency_address: sync_emergency_address, defaults to None
        :type sync_emergency_address: bool, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Emergency location information
        :rtype: CommonEmergencyLocationResource
        """

        Validator(str).validate(account_id)
        Validator(str).validate(location_id)
        Validator(bool).is_optional().validate(sync_emergency_address)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-locations/{{locationId}}",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("locationId", location_id)
            .add_query("syncEmergencyAddress", sync_emergency_address)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return CommonEmergencyLocationResource._unmap(response)

    @cast_models
    def update_emergency_location(
        self,
        request_body: EmergencyLocationRequestResource,
        account_id: str,
        location_id: str,
    ) -> EmergencyLocationResponseResource:
        """Updates the specified emergency response location.

        :param request_body: The request body.
        :type request_body: EmergencyLocationRequestResource
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param location_id: Internal identifier of an emergency response location
        :type location_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Updated emergency location information
        :rtype: EmergencyLocationResponseResource
        """

        Validator(EmergencyLocationRequestResource).validate(request_body)
        Validator(str).validate(account_id)
        Validator(str).validate(location_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-locations/{{locationId}}",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("locationId", location_id)
            .serialize()
            .set_method("PUT")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return EmergencyLocationResponseResource._unmap(response)

    @cast_models
    def delete_emergency_location(
        self,
        account_id: str,
        location_id: str,
        validate_only: bool = None,
        new_location_id: str = None,
    ) -> GetLocationDeletionMultiResponse:
        """Deletes the specified emergency response location.

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param location_id: Internal identifier of an emergency response location
        :type location_id: str
        :param validate_only: Flag indicating that validation of emergency location(s) is required
        before deletion, defaults to None
        :type validate_only: bool, optional
        :param new_location_id: Internal identifier of an emergency response location
        that should be used instead of a deleted one., defaults to None
        :type new_location_id: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful validation
        :rtype: GetLocationDeletionMultiResponse
        """

        Validator(str).validate(account_id)
        Validator(str).validate(location_id)
        Validator(bool).is_optional().validate(validate_only)
        Validator(str).is_optional().validate(new_location_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-locations/{{locationId}}",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("locationId", location_id)
            .add_query("validateOnly", validate_only)
            .add_query("newLocationId", new_location_id)
            .serialize()
            .set_method("DELETE")
        )

        response = self.send_request(serialized_request)

        return GetLocationDeletionMultiResponse._unmap(response)

    @cast_models
    def get_extension_emergency_locations(
        self,
        account_id: str,
        extension_id: str,
        site_id: List[str] = None,
        search_string: str = None,
        domestic_country_id: str = None,
        order_by: GetExtensionEmergencyLocationsOrderBy = None,
        per_page: int = None,
        page: int = None,
        visibility: str = None,
    ) -> EmergencyLocationsResource:
        """Returns a list of emergency response locations available for the particular extension.

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param extension_id: Internal identifier of the RingCentral extension/user
        (can be set to "~" to indicate that the extension associated with current authorization session should be used)
        :type extension_id: str
        :param site_id: Internal identifier of a site for filtering. To indicate company main
        site `main-site` value should be specified. Supported only if multi-site feature
        is enabled for the account. Multiple values are supported., defaults to None
        :type site_id: List[str], optional
        :param search_string: Filters entries by the specified substring (search by chassis
        ID, switch name or address) The characters range is 0-64 (if
        empty the filter is ignored), defaults to None
        :type search_string: str, optional
        :param domestic_country_id: domestic_country_id, defaults to None
        :type domestic_country_id: str, optional
        :param order_by: Comma-separated list of fields to order results prefixed by '+'
        sign (ascending order) or '-' sign (descending order). The default
        sorting is by `name`, defaults to None
        :type order_by: GetExtensionEmergencyLocationsOrderBy, optional
        :param per_page: Indicates a page size (number of items). The values supported:
        `Max` or numeric value. If not specified, 100 records are returned
        per one page, defaults to None
        :type per_page: int, optional
        :param page: Indicates a page number to retrieve. Only positive
        number values are supported, defaults to None
        :type page: int, optional
        :param visibility: visibility, defaults to None
        :type visibility: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: User emergency location list
        :rtype: EmergencyLocationsResource
        """

        Validator(str).validate(account_id)
        Validator(str).validate(extension_id)
        Validator(str).is_array().is_optional().validate(site_id)
        Validator(str).is_optional().validate(search_string)
        Validator(str).is_optional().validate(domestic_country_id)
        Validator(GetExtensionEmergencyLocationsOrderBy).is_optional().validate(
            order_by
        )
        Validator(int).is_optional().validate(per_page)
        Validator(int).is_optional().validate(page)
        Validator(str).is_optional().validate(visibility)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/extension/{{extensionId}}/emergency-locations",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("extensionId", extension_id)
            .add_query("siteId", site_id)
            .add_query("searchString", search_string)
            .add_query("domesticCountryId", domestic_country_id)
            .add_query("orderBy", order_by)
            .add_query("perPage", per_page)
            .add_query("page", page)
            .add_query("visibility", visibility)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return EmergencyLocationsResource._unmap(response)

    @cast_models
    def create_extension_emergency_location(
        self,
        request_body: CreateUserEmergencyLocationRequest,
        account_id: str,
        extension_id: str,
    ) -> EmergencyLocationResponseResource:
        """Creates a personal emergency response location for the current user.

        :param request_body: The request body.
        :type request_body: CreateUserEmergencyLocationRequest
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param extension_id: Internal identifier of the RingCentral extension/user
        (can be set to "~" to indicate that the extension associated with current authorization session should be used)
        :type extension_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Emergency location information
        :rtype: EmergencyLocationResponseResource
        """

        Validator(CreateUserEmergencyLocationRequest).validate(request_body)
        Validator(str).validate(account_id)
        Validator(str).validate(extension_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/extension/{{extensionId}}/emergency-locations",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("extensionId", extension_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return EmergencyLocationResponseResource._unmap(response)

    @cast_models
    def get_extension_emergency_location(
        self, account_id: str, extension_id: str, location_id: str
    ) -> CommonEmergencyLocationResource:
        """Returns a personal emergency response location for the current user.

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param extension_id: Internal identifier of the RingCentral extension/user
        (can be set to "~" to indicate that the extension associated with current authorization session should be used)
        :type extension_id: str
        :param location_id: Internal identifier of an emergency response location
        :type location_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Success
        :rtype: CommonEmergencyLocationResource
        """

        Validator(str).validate(account_id)
        Validator(str).validate(extension_id)
        Validator(str).validate(location_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/extension/{{extensionId}}/emergency-locations/{{locationId}}",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("extensionId", extension_id)
            .add_path("locationId", location_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return CommonEmergencyLocationResource._unmap(response)

    @cast_models
    def update_extension_emergency_location(
        self,
        request_body: EmergencyLocationRequestResource,
        account_id: str,
        extension_id: str,
        location_id: str,
    ) -> EmergencyLocationResponseResource:
        """Updates a personal emergency response location by the current user or admin.

        :param request_body: The request body.
        :type request_body: EmergencyLocationRequestResource
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param extension_id: Internal identifier of the RingCentral extension/user
        (can be set to "~" to indicate that the extension associated with current authorization session should be used)
        :type extension_id: str
        :param location_id: Internal identifier of an emergency response location
        :type location_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: OK
        :rtype: EmergencyLocationResponseResource
        """

        Validator(EmergencyLocationRequestResource).validate(request_body)
        Validator(str).validate(account_id)
        Validator(str).validate(extension_id)
        Validator(str).validate(location_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/extension/{{extensionId}}/emergency-locations/{{locationId}}",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("extensionId", extension_id)
            .add_path("locationId", location_id)
            .serialize()
            .set_method("PUT")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return EmergencyLocationResponseResource._unmap(response)

    @cast_models
    def delete_extension_emergency_location(
        self,
        account_id: str,
        extension_id: str,
        location_id: str,
        validate_only: bool = None,
    ):
        """Deletes a personal emergency response location by ID by
        the current user or admin. Multiple personal emergency response
        locations can be deleted by single API call.

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param extension_id: Internal identifier of the RingCentral extension/user
        (can be set to "~" to indicate that the extension associated with current authorization session should be used)
        :type extension_id: str
        :param location_id: Internal identifier of an emergency response location
        :type location_id: str
        :param validate_only: Flag indicating that only validation of Emergency Response Locations
        to be deleted is required, defaults to None
        :type validate_only: bool, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(str).validate(account_id)
        Validator(str).validate(extension_id)
        Validator(str).validate(location_id)
        Validator(bool).is_optional().validate(validate_only)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/extension/{{extensionId}}/emergency-locations/{{locationId}}",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("extensionId", extension_id)
            .add_path("locationId", location_id)
            .add_query("validateOnly", validate_only)
            .serialize()
            .set_method("DELETE")
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def read_automatic_location_updates_task(
        self, account_id: str, task_id: str
    ) -> AutomaticLocationUpdatesTaskInfo:
        """Returns results of the task created within the frame of Automatic
        Location Updates feature. Currently four task types are supported: 'Wireless
        Points Bulk Create', 'Wireless Points Bulk Update', 'Switches Bulk Create',
        'Switches Bulk Update'.

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param task_id: task_id
        :type task_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Task information
        :rtype: AutomaticLocationUpdatesTaskInfo
        """

        Validator(str).validate(account_id)
        Validator(str).validate(task_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/tasks/{{taskId}}",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("taskId", task_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return AutomaticLocationUpdatesTaskInfo._unmap(response)

    @cast_models
    def list_automatic_location_updates_users(
        self,
        account_id: str,
        type_: List[ListAutomaticLocationUpdatesUsersType] = None,
        search_string: str = None,
        department: List[str] = None,
        site_id: List[str] = None,
        feature_enabled: bool = None,
        order_by: str = None,
        per_page: int = None,
        page: int = None,
    ) -> AutomaticLocationUpdatesUserList:
        """Returns a list of users with their status of Automatic Location
        Updates feature.

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param type_: Extension type. Multiple values are supported, defaults to None
        :type type_: List[ListAutomaticLocationUpdatesUsersType], optional
        :param search_string: Filters entries containing the specified substring in user name,
        extension or department. The characters range is 0-64; not case-sensitive.
        If empty then the filter is ignored, defaults to None
        :type search_string: str, optional
        :param department: Department name to filter the users. The value range is 0-64;
        not case-sensitive. If not specified then the parameter is ignored. Multiple
        values are supported, defaults to None
        :type department: List[str], optional
        :param site_id: Internal identifier of a site for filtering. To indicate company main
        site `main-site` value should be specified. Supported only if multi-site feature
        is enabled for the account. Multiple values are supported., defaults to None
        :type site_id: List[str], optional
        :param feature_enabled: Filters entries by their status of Automatic Location Updates
        feature, defaults to None
        :type feature_enabled: bool, optional
        :param order_by: Comma-separated list of fields to order results prefixed by
        plus sign '+' (ascending order) or minus sign '-' (descending order).
        Supported values: 'name', 'modelName', 'siteName', 'featureEnabled'.
        The default sorting is by `name`, defaults to None
        :type order_by: str, optional
        :param per_page: Indicates a page size (number of items). The values supported:
        `Max` or numeric value. If not specified, 100 records are returned per one
        page, defaults to None
        :type per_page: int, optional
        :param page: Indicates a page number to retrieve. Only positive number values
        are supported, defaults to None
        :type page: int, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: User list
        :rtype: AutomaticLocationUpdatesUserList
        """

        Validator(str).validate(account_id)
        Validator(
            ListAutomaticLocationUpdatesUsersType
        ).is_array().is_optional().validate(type_)
        Validator(str).is_optional().validate(search_string)
        Validator(str).is_array().is_optional().validate(department)
        Validator(str).is_array().is_optional().validate(site_id)
        Validator(bool).is_optional().validate(feature_enabled)
        Validator(str).is_optional().validate(order_by)
        Validator(int).is_optional().validate(per_page)
        Validator(int).is_optional().validate(page)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/users",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_query("type", type_)
            .add_query("searchString", search_string)
            .add_query("department", department)
            .add_query("siteId", site_id)
            .add_query("featureEnabled", feature_enabled)
            .add_query("orderBy", order_by)
            .add_query("perPage", per_page)
            .add_query("page", page)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return AutomaticLocationUpdatesUserList._unmap(response)

    @cast_models
    def assign_multiple_automatic_location_updates_users(
        self,
        account_id: str,
        request_body: EmergencyAddressAutoUpdateUsersBulkAssignResource = None,
    ):
        """Enables or disables Automatic Location Updates feature for multiple
        account users.

        :param request_body: The request body., defaults to None
        :type request_body: EmergencyAddressAutoUpdateUsersBulkAssignResource, optional
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(
            EmergencyAddressAutoUpdateUsersBulkAssignResource
        ).is_optional().validate(request_body)
        Validator(str).validate(account_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/users/bulk-assign",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def create_multiple_wireless_points(
        self, request_body: CreateMultipleWirelessPointsRequest, account_id: str
    ) -> CreateMultipleWirelessPointsResponse:
        """Creates multiple wireless points in a corporate map. The maximum
        number of wireless points per request is 10 000; limitation for account is
        70 000.

        :param request_body: The request body.
        :type request_body: CreateMultipleWirelessPointsRequest
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Multiple Wireless Points Creation Task
        :rtype: CreateMultipleWirelessPointsResponse
        """

        Validator(CreateMultipleWirelessPointsRequest).validate(request_body)
        Validator(str).validate(account_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/wireless-points-bulk-create",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return CreateMultipleWirelessPointsResponse._unmap(response)

    @cast_models
    def list_networks(
        self,
        account_id: str,
        site_id: List[str] = None,
        search_string: str = None,
        order_by: str = None,
        per_page: int = None,
        page: int = None,
    ) -> NetworksList:
        """Returns a corporate network map with emergency addresses assigned
        to the current account.

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param site_id: Internal identifier of a site for filtering. To indicate company main
        site `main-site` value should be specified. Supported only if multi-site feature
        is enabled for the account. Multiple values are supported., defaults to None
        :type site_id: List[str], optional
        :param search_string: Filters entries by the specified substring (search by chassis
        ID, switch name or address) The characters range is 0-64 (if empty the filter
        is ignored), defaults to None
        :type search_string: str, optional
        :param order_by: Comma-separated list of fields to order results prefixed by '+'
        sign (ascending order) or '-' sign (descending order). The default
        sorting is by `name`, defaults to None
        :type order_by: str, optional
        :param per_page: Indicates a page size (number of items). The values supported:
        `Max` or numeric value. If not specified, 100 records are returned per one
        page', defaults to None
        :type per_page: int, optional
        :param page: Indicates a page number to retrieve. Only positive number values
        are supported, defaults to None
        :type page: int, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Network map
        :rtype: NetworksList
        """

        Validator(str).validate(account_id)
        Validator(str).is_array().is_optional().validate(site_id)
        Validator(str).is_optional().validate(search_string)
        Validator(str).is_optional().validate(order_by)
        Validator(int).is_optional().validate(per_page)
        Validator(int).is_optional().validate(page)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/networks",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_query("siteId", site_id)
            .add_query("searchString", search_string)
            .add_query("orderBy", order_by)
            .add_query("perPage", per_page)
            .add_query("page", page)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return NetworksList._unmap(response)

    @cast_models
    def create_network(
        self, request_body: CreateNetworkRequest, account_id: str
    ) -> NetworkInfo:
        """Creates a new network in a corporate ethernet map for assignment
        of emergency addresses to network access points.

        :param request_body: The request body.
        :type request_body: CreateNetworkRequest
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Created network
        :rtype: NetworkInfo
        """

        Validator(CreateNetworkRequest).validate(request_body)
        Validator(str).validate(account_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/networks",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return NetworkInfo._unmap(response)

    @cast_models
    def read_network(self, account_id: str, network_id: str) -> NetworkInfo:
        """Returns the specified network with emergency addresses assigned
        to the current account.

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param network_id: Internal identifier of a network
        :type network_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Network information
        :rtype: NetworkInfo
        """

        Validator(str).validate(account_id)
        Validator(str).validate(network_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/networks/{{networkId}}",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("networkId", network_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return NetworkInfo._unmap(response)

    @cast_models
    def update_network(
        self, request_body: UpdateNetworkRequest, account_id: str, network_id: str
    ) -> NetworkInfo:
        """Updates a network in a corporate ethernet map for assignment of emergency
        addresses to network access points.

        :param request_body: The request body.
        :type request_body: UpdateNetworkRequest
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param network_id: Internal identifier of a network
        :type network_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Updated network information
        :rtype: NetworkInfo
        """

        Validator(UpdateNetworkRequest).validate(request_body)
        Validator(str).validate(account_id)
        Validator(str).validate(network_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/networks/{{networkId}}",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("networkId", network_id)
            .serialize()
            .set_method("PUT")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return NetworkInfo._unmap(response)

    @cast_models
    def delete_network(self, account_id: str, network_id: List[str]):
        """Deletes network(s) in a corporate ethernet map for Automatic Location
        Updates feature.

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param network_id: Internal identifier of a network
        :type network_id: List[str]
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(str).validate(account_id)
        Validator(str).is_array().validate(network_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/networks/{{networkId}}",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("networkId", network_id)
            .serialize()
            .set_method("DELETE")
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def validate_multiple_switches(
        self, request_body: ValidateMultipleSwitchesRequest, account_id: str
    ) -> ValidateMultipleSwitchesResponse:
        """Validates switches before creation or update. The maximum number
        of switches per request is 10 000.

        :param request_body: The request body.
        :type request_body: ValidateMultipleSwitchesRequest
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Success
        :rtype: ValidateMultipleSwitchesResponse
        """

        Validator(ValidateMultipleSwitchesRequest).validate(request_body)
        Validator(str).validate(account_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/switches-bulk-validate",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return ValidateMultipleSwitchesResponse._unmap(response)

    @cast_models
    def list_account_switches(
        self,
        account_id: str,
        site_id: List[str] = None,
        search_string: str = None,
        order_by: str = None,
        per_page: int = None,
        page: int = None,
    ) -> SwitchesList:
        """Returns a corporate map of configured network switches with the assigned
        emergency addresses for the logged-in account.

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param site_id: Internal identifier of a site for filtering. To indicate company main
        site `main-site` value should be specified. Supported only if multi-site feature
        is enabled for the account. Multiple values are supported., defaults to None
        :type site_id: List[str], optional
        :param search_string: Filters entries by the specified substring (search by chassis
        ID, switch name or address) The characters range is 0-64 (if empty the filter
        is ignored), defaults to None
        :type search_string: str, optional
        :param order_by: Comma-separated list of fields to order results prefixed by '+'
        sign (ascending order) or '-' sign (descending order). The default
        sorting is by `name`, defaults to None
        :type order_by: str, optional
        :param per_page: Indicates a page size (number of items). The values supported:
        `Max` or numeric value. If not specified, 100 records are returned per one
        page', defaults to None
        :type per_page: int, optional
        :param page: Indicates a page number to retrieve. Only positive number values
        are supported, defaults to None
        :type page: int, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Switches Map
        :rtype: SwitchesList
        """

        Validator(str).validate(account_id)
        Validator(str).is_array().is_optional().validate(site_id)
        Validator(str).is_optional().validate(search_string)
        Validator(str).is_optional().validate(order_by)
        Validator(int).is_optional().validate(per_page)
        Validator(int).is_optional().validate(page)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/switches",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_query("siteId", site_id)
            .add_query("searchString", search_string)
            .add_query("orderBy", order_by)
            .add_query("perPage", per_page)
            .add_query("page", page)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return SwitchesList._unmap(response)

    @cast_models
    def create_switch(
        self, request_body: CreateSwitchInfo, account_id: str
    ) -> SwitchInfo:
        """Creates a new switch in corporate map based on chassis ID and used
        for Automatic Locations Update feature.

        :param request_body: The request body.
        :type request_body: CreateSwitchInfo
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Switch information
        :rtype: SwitchInfo
        """

        Validator(CreateSwitchInfo).validate(request_body)
        Validator(str).validate(account_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/switches",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return SwitchInfo._unmap(response)

    @cast_models
    def read_switch(self, account_id: str, switch_id: str) -> SwitchInfo:
        """Returns the specified switch with the assigned emergency address.

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param switch_id: switch_id
        :type switch_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Switch information
        :rtype: SwitchInfo
        """

        Validator(str).validate(account_id)
        Validator(str).validate(switch_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/switches/{{switchId}}",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("switchId", switch_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return SwitchInfo._unmap(response)

    @cast_models
    def update_switch(
        self, request_body: UpdateSwitchInfo, account_id: str, switch_id: str
    ) -> SwitchInfo:
        """Updates switch. Partial update is not supported, all switch parameters
        should be specified. If null value is received or parameter is missing, its
        value is removed.

        :param request_body: The request body.
        :type request_body: UpdateSwitchInfo
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param switch_id: switch_id
        :type switch_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Updated switch information
        :rtype: SwitchInfo
        """

        Validator(UpdateSwitchInfo).validate(request_body)
        Validator(str).validate(account_id)
        Validator(str).validate(switch_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/switches/{{switchId}}",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("switchId", switch_id)
            .serialize()
            .set_method("PUT")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return SwitchInfo._unmap(response)

    @cast_models
    def delete_switch(self, account_id: str, switch_id: List[str]):
        """Deletes wireless switch(es) in a network configuration for Automatic
        Location Updates feature.

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param switch_id: switch_id
        :type switch_id: List[str]
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(str).validate(account_id)
        Validator(str).is_array().validate(switch_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/switches/{{switchId}}",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("switchId", switch_id)
            .serialize()
            .set_method("DELETE")
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def validate_multiple_wireless_points(
        self, request_body: ValidateMultipleWirelessPointsRequest, account_id: str
    ) -> ValidateMultipleWirelessPointsResponse:
        """Validates wireless points before creation or update. The maximum
        number of wireless points per request is 10 000.

        :param request_body: The request body.
        :type request_body: ValidateMultipleWirelessPointsRequest
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Validated wireless points information
        :rtype: ValidateMultipleWirelessPointsResponse
        """

        Validator(ValidateMultipleWirelessPointsRequest).validate(request_body)
        Validator(str).validate(account_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/wireless-points-bulk-validate",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return ValidateMultipleWirelessPointsResponse._unmap(response)

    @cast_models
    def list_wireless_points(
        self,
        account_id: str,
        site_id: List[str] = None,
        search_string: str = None,
        order_by: str = None,
        per_page: int = None,
        page: int = None,
    ) -> WirelessPointsList:
        """Returns account wireless points configured and used for Automatic
        Location Updates feature.

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param site_id: Internal identifier of a site for filtering. To indicate company main
        site `main-site` value should be specified. Supported only if multi-site feature
        is enabled for the account. Multiple values are supported., defaults to None
        :type site_id: List[str], optional
        :param search_string: Filters entries by the specified substring (search by chassis
        ID, switch name or address) The characters range is 0-64 (if empty the filter
        is ignored), defaults to None
        :type search_string: str, optional
        :param order_by: Comma-separated list of fields to order results prefixed by '+'
        sign (ascending order) or '-' sign (descending order).The default sorting
        is by `name`, defaults to None
        :type order_by: str, optional
        :param per_page: Indicates a page size (number of items). The values supported:
        `Max` or numeric value. If not specified, 100 records are returned per one
        page, defaults to None
        :type per_page: int, optional
        :param page: Indicates the page number to retrieve. Only positive number values
        are supported, defaults to None
        :type page: int, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: List of wireless points
        :rtype: WirelessPointsList
        """

        Validator(str).validate(account_id)
        Validator(str).is_array().is_optional().validate(site_id)
        Validator(str).is_optional().validate(search_string)
        Validator(str).is_optional().validate(order_by)
        Validator(int).is_optional().validate(per_page)
        Validator(int).is_optional().validate(page)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/wireless-points",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_query("siteId", site_id)
            .add_query("searchString", search_string)
            .add_query("orderBy", order_by)
            .add_query("perPage", per_page)
            .add_query("page", page)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return WirelessPointsList._unmap(response)

    @cast_models
    def create_wireless_point(
        self, request_body: CreateWirelessPoint, account_id: str
    ) -> WirelessPointInfo:
        """Creates a new wireless point in network configuration with the
        emergency address assigned.

        :param request_body: The request body.
        :type request_body: CreateWirelessPoint
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Created wireless point
        :rtype: WirelessPointInfo
        """

        Validator(CreateWirelessPoint).validate(request_body)
        Validator(str).validate(account_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/wireless-points",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return WirelessPointInfo._unmap(response)

    @cast_models
    def read_wireless_point(self, account_id: str, point_id: str) -> WirelessPointInfo:
        """Returns the specified wireless access point of a corporate map
        with the emergency address assigned.

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param point_id: Internal identifier of a point
        :type point_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Wireless point information
        :rtype: WirelessPointInfo
        """

        Validator(str).validate(account_id)
        Validator(str).validate(point_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/wireless-points/{{pointId}}",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("pointId", point_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return WirelessPointInfo._unmap(response)

    @cast_models
    def update_wireless_point(
        self, request_body: UpdateWirelessPoint, account_id: str, point_id: str
    ) -> WirelessPointInfo:
        """Updates the specified wireless access point of a corporate map
        by ID.

        :param request_body: The request body.
        :type request_body: UpdateWirelessPoint
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param point_id: Internal identifier of a wireless point
        :type point_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Updated wireless point
        :rtype: WirelessPointInfo
        """

        Validator(UpdateWirelessPoint).validate(request_body)
        Validator(str).validate(account_id)
        Validator(str).validate(point_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/wireless-points/{{pointId}}",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("pointId", point_id)
            .serialize()
            .set_method("PUT")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return WirelessPointInfo._unmap(response)

    @cast_models
    def delete_wireless_point(self, account_id: str, point_id: List[str]):
        """Deletes wireless point(s) of a corporate map by ID(s).

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param point_id: Internal identifier of a wireless point
        :type point_id: List[str]
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(str).validate(account_id)
        Validator(str).is_array().validate(point_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/wireless-points/{{pointId}}",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("pointId", point_id)
            .serialize()
            .set_method("DELETE")
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def list_devices_automatic_location_updates(
        self,
        account_id: str,
        site_id: List[str] = None,
        feature_enabled: bool = None,
        model_id: str = None,
        compatible_only: bool = None,
        search_string: str = None,
        order_by: str = None,
        per_page: int = None,
        page: int = None,
    ) -> ListDevicesAutomaticLocationUpdates:
        """Returns a list of common devices with their status of Automatic
        Location Updates feature.

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param site_id: Internal identifier of a site for filtering. To indicate company main
        site `main-site` value should be specified. Supported only if multi-site feature
        is enabled for the account. Multiple values are supported., defaults to None
        :type site_id: List[str], optional
        :param feature_enabled: Filters entries by their status of Automatic Location Updates
        feature, defaults to None
        :type feature_enabled: bool, optional
        :param model_id: Internal identifier of a device model for filtering. Multiple
        values are supported, defaults to None
        :type model_id: str, optional
        :param compatible_only: Filters devices which support HELD protocol, defaults to None
        :type compatible_only: bool, optional
        :param search_string: Filters entries which have device name or model name containing
        the mentioned substring. The value should be split by spaces; the range
        is 0 - 64 characters, not case-sensitive. If empty the filter is ignored, defaults to None
        :type search_string: str, optional
        :param order_by: Comma-separated list of fields to order results prefixed by
        plus sign '+' (ascending order) or minus sign '-' (descending order).
        Supported values: 'name', 'modelName', 'siteName', 'featureEnabled'.
        The default sorting is by `name`, defaults to None
        :type order_by: str, optional
        :param per_page: Indicates a page size (number of items). The values supported:
        `Max` or numeric value. If not specified, 100 records are returned per one
        page, defaults to None
        :type per_page: int, optional
        :param page: Indicates a page number to retrieve. Only positive number values
        are supported, defaults to None
        :type page: int, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Device list with their status of Automatic Location Updates feature
        :rtype: ListDevicesAutomaticLocationUpdates
        """

        Validator(str).validate(account_id)
        Validator(str).is_array().is_optional().validate(site_id)
        Validator(bool).is_optional().validate(feature_enabled)
        Validator(str).is_optional().validate(model_id)
        Validator(bool).is_optional().validate(compatible_only)
        Validator(str).is_optional().validate(search_string)
        Validator(str).is_optional().validate(order_by)
        Validator(int).is_optional().validate(per_page)
        Validator(int).is_optional().validate(page)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/devices",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_query("siteId", site_id)
            .add_query("featureEnabled", feature_enabled)
            .add_query("modelId", model_id)
            .add_query("compatibleOnly", compatible_only)
            .add_query("searchString", search_string)
            .add_query("orderBy", order_by)
            .add_query("perPage", per_page)
            .add_query("page", page)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return ListDevicesAutomaticLocationUpdates._unmap(response)

    @cast_models
    def assign_multiple_devices_automatic_location_updates(
        self,
        account_id: str,
        request_body: AssignMultipleDevicesAutomaticLocationUpdates = None,
    ):
        """Enables or disables Automatic Location Updates feature for the
        specified common phones.

        :param request_body: The request body., defaults to None
        :type request_body: AssignMultipleDevicesAutomaticLocationUpdates, optional
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(AssignMultipleDevicesAutomaticLocationUpdates).is_optional().validate(
            request_body
        )
        Validator(str).validate(account_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/devices/bulk-assign",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def create_multiple_switches(
        self, request_body: CreateMultipleSwitchesRequest, account_id: str
    ) -> CreateMultipleSwitchesResponse:
        """Creates multiple switches in corporate map. The maximum number
        of switches per request is 10 000; limitation for account is 10 000.

        :param request_body: The request body.
        :type request_body: CreateMultipleSwitchesRequest
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Multiple Switches Creation Task
        :rtype: CreateMultipleSwitchesResponse
        """

        Validator(CreateMultipleSwitchesRequest).validate(request_body)
        Validator(str).validate(account_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/switches-bulk-create",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return CreateMultipleSwitchesResponse._unmap(response)

    @cast_models
    def update_multiple_wireless_points(
        self, request_body: UpdateMultipleWirelessPointsRequest, account_id: str
    ) -> UpdateMultipleWirelessPointsResponse:
        """Updates wireless points in corporate map. The maximum number of
        wireless points per request is 10 000; limitation for account is 70 000.

        :param request_body: The request body.
        :type request_body: UpdateMultipleWirelessPointsRequest
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Multiple Wireless Points Update Task
        :rtype: UpdateMultipleWirelessPointsResponse
        """

        Validator(UpdateMultipleWirelessPointsRequest).validate(request_body)
        Validator(str).validate(account_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/wireless-points-bulk-update",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return UpdateMultipleWirelessPointsResponse._unmap(response)

    @cast_models
    def update_multiple_switches(
        self, request_body: UpdateMultipleSwitchesRequest, account_id: str
    ) -> UpdateMultipleSwitchesResponse:
        """Updates multiple switches in corporate map. The maximum number
        of switches per request is 10 000; limitation for account is 10 000.

        :param request_body: The request body.
        :type request_body: UpdateMultipleSwitchesRequest
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Multiple Switches Update Task
        :rtype: UpdateMultipleSwitchesResponse
        """

        Validator(UpdateMultipleSwitchesRequest).validate(request_body)
        Validator(str).validate(account_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/emergency-address-auto-update/switches-bulk-update",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return UpdateMultipleSwitchesResponse._unmap(response)
