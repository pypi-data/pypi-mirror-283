# This file was generated by liblab | https://liblab.com/

from typing import List
from .utils.validator import Validator
from .utils.base_service import BaseService
from ..net.transport.serializer import Serializer
from ..models.utils.cast_models import cast_models
from ..models.recording_status_model import RecordingStatusModel
from ..models.recording_media_type import RecordingMediaType
from ..models.recording_list_resource import RecordingListResource
from ..models.recording_item_extended_model import RecordingItemExtendedModel
from ..models.recording_download_model import RecordingDownloadModel
from ..models.recording_admin_list_resource import RecordingAdminListResource
from ..models.recording_admin_extended_item_model import RecordingAdminExtendedItemModel


class HistoricalRecordingsService(BaseService):

    @cast_models
    def rcw_history_admin_list_recordings(
        self,
        creation_time_from: str,
        creation_time_to: str,
        name_fragment: str = None,
        status: List[RecordingStatusModel] = None,
        host_user_id: List[str] = None,
        per_page: int = None,
        page_token: str = None,
    ) -> RecordingAdminListResource:
        """Returns the list of webinar recordings (Administrator's interface).
        The user must have "WebinarSettings" permission granted otherwise the API returns HTTP 403.

        :param creation_time_from: The beginning of the time window by 'creationTime' .
        :type creation_time_from: str
        :param creation_time_to: The end of the time window by 'creationTime' .
        :type creation_time_to: str
        :param name_fragment: Filter to return only webinar recordings containing particular substring within their names, defaults to None
        :type name_fragment: str, optional
        :param status: The status of the recording., defaults to None
        :type status: List[RecordingStatusModel], optional
        :param host_user_id: Identifier of the user who hosts a webinar (if omitted, webinars hosted by all company users will be returned), defaults to None
        :type host_user_id: List[str], optional
        :param per_page: The number of items per page. If provided value in the request
        is greater than a maximum, the maximum value is applied, defaults to None
        :type per_page: int, optional
        :param page_token: The token indicating the particular page of the result set to be retrieved.
        If omitted the first page will be returned., defaults to None
        :type page_token: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response
        :rtype: RecordingAdminListResource
        """

        Validator(str).validate(creation_time_from)
        Validator(str).validate(creation_time_to)
        Validator(str).is_optional().validate(name_fragment)
        Validator(RecordingStatusModel).is_array().is_optional().validate(status)
        Validator(str).is_array().is_optional().validate(host_user_id)
        Validator(int).is_optional().min(1).max(1000).validate(per_page)
        Validator(str).is_optional().validate(page_token)

        serialized_request = (
            Serializer(
                f"{self.base_url}/webinar/history/v1/company/recordings",
                self.get_default_headers(),
            )
            .add_query("nameFragment", name_fragment)
            .add_query("creationTimeFrom", creation_time_from, explode=False)
            .add_query("creationTimeTo", creation_time_to, explode=False)
            .add_query("status", status)
            .add_query("hostUserId", host_user_id, explode=False)
            .add_query("perPage", per_page, explode=False)
            .add_query("pageToken", page_token, explode=False)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return RecordingAdminListResource._unmap(response)

    @cast_models
    def rcw_history_admin_get_recording(
        self, recording_id: str
    ) -> RecordingAdminExtendedItemModel:
        """Returns the webinar recording by ID (Administrator's interface).

        The user must have "WebinarSettings" permission granted otherwise the API returns HTTP 403.

        :param recording_id: Identifier of the Webinar recording.
        :type recording_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response
        :rtype: RecordingAdminExtendedItemModel
        """

        Validator(str).validate(recording_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/webinar/history/v1/company/recordings/{{recordingId}}",
                self.get_default_headers(),
            )
            .add_path("recordingId", recording_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return RecordingAdminExtendedItemModel._unmap(response)

    @cast_models
    def rcw_history_list_recordings(
        self,
        creation_time_from: str,
        creation_time_to: str,
        status: List[RecordingStatusModel] = None,
        per_page: int = None,
        page_token: str = None,
    ) -> RecordingListResource:
        """Returns the list of webinar recordings for a given webinar host user

        :param creation_time_from: The beginning of the time window by 'creationTime' .
        :type creation_time_from: str
        :param creation_time_to: The end of the time window by 'creationTime' .
        :type creation_time_to: str
        :param status: The status of the recording., defaults to None
        :type status: List[RecordingStatusModel], optional
        :param per_page: The number of items per page. If provided value in the request
        is greater than a maximum, the maximum value is applied, defaults to None
        :type per_page: int, optional
        :param page_token: The token indicating the particular page of the result set to be retrieved.
        If omitted the first page will be returned., defaults to None
        :type page_token: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response
        :rtype: RecordingListResource
        """

        Validator(str).validate(creation_time_from)
        Validator(str).validate(creation_time_to)
        Validator(RecordingStatusModel).is_array().is_optional().validate(status)
        Validator(int).is_optional().min(1).max(1000).validate(per_page)
        Validator(str).is_optional().validate(page_token)

        serialized_request = (
            Serializer(
                f"{self.base_url}/webinar/history/v1/recordings",
                self.get_default_headers(),
            )
            .add_query("creationTimeFrom", creation_time_from, explode=False)
            .add_query("creationTimeTo", creation_time_to, explode=False)
            .add_query("status", status)
            .add_query("perPage", per_page, explode=False)
            .add_query("pageToken", page_token, explode=False)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return RecordingListResource._unmap(response)

    @cast_models
    def rcw_history_get_recording(
        self, recording_id: str
    ) -> RecordingItemExtendedModel:
        """Returns the webinar recording by ID (Webinar host's interface).
        This API also returns sharing link if sharing is enabled.

        :param recording_id: Identifier of the Webinar recording.
        :type recording_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response
        :rtype: RecordingItemExtendedModel
        """

        Validator(str).validate(recording_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/webinar/history/v1/recordings/{{recordingId}}",
                self.get_default_headers(),
            )
            .add_path("recordingId", recording_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return RecordingItemExtendedModel._unmap(response)

    @cast_models
    def rcw_history_get_recording_download(
        self, recording_id: str, recording_media_type: RecordingMediaType = None
    ) -> RecordingDownloadModel:
        """Returns the webinar recording download link (both Webinar host's and admin interface).

        If called by a webinar host, the API returns error (403) if recording downloading is prohibited by company settings.
        The admin user who has "WebinarSettings" permission should be able to download recording regardless of current company settings.

        :param recording_id: Identifier of the Webinar recording.
        :type recording_id: str
        :param recording_media_type: Download file media type.
        - Type 'Video' refers to a multiplexed audio and video file.
        - Type 'Audio' refers to an audio only file.
        - Unless specified by this query parameter, a video file is returned by default when a recording is downloaded., defaults to None
        :type recording_media_type: RecordingMediaType, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response
        :rtype: RecordingDownloadModel
        """

        Validator(str).validate(recording_id)
        Validator(RecordingMediaType).is_optional().validate(recording_media_type)

        serialized_request = (
            Serializer(
                f"{self.base_url}/webinar/history/v1/recordings/{{recordingId}}/download",
                self.get_default_headers(),
            )
            .add_path("recordingId", recording_id)
            .add_query("recordingMediaType", recording_media_type)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return RecordingDownloadModel._unmap(response)
