# This file was generated by liblab | https://liblab.com/

from typing import List
from .utils.validator import Validator
from .utils.base_service import BaseService
from ..net.transport.serializer import Serializer
from ..models.utils.cast_models import cast_models
from ..models.soc_msg_creation_time_order import SocMsgCreationTimeOrder
from ..models.create_content_request import CreateContentRequest
from ..models.content_status import ContentStatus
from ..models.content_model import ContentModel
from ..models.content_list import ContentList


class ContentsService(BaseService):

    @cast_models
    def soc_msg_list_contents(
        self,
        intervention: List[str] = None,
        identity: List[str] = None,
        identity_group: List[str] = None,
        source: List[str] = None,
        thread: List[str] = None,
        text: List[str] = None,
        status: List[ContentStatus] = None,
        order_by: SocMsgCreationTimeOrder = None,
        page_token: str = None,
        per_page: int = None,
    ) -> ContentList:
        """List contents by creation date. The default creation order is descending.

        The account context of this request is determined by the RC Account Id associated with the access token provided
        in the Authorization header.

        The query parameters provided shall be considered an AND operation to filter the list.

        A query parameter not specified or a query parameter provided with no value is treated as not required for
        filtering the list.

        :param intervention: Filter based on the specified intervention identifiers., defaults to None
        :type intervention: List[str], optional
        :param identity: Filter based on the specified identity identifiers., defaults to None
        :type identity: List[str], optional
        :param identity_group: Filter based on the specified identity group identifiers., defaults to None
        :type identity_group: List[str], optional
        :param source: Filter based on the specified channel identifiers., defaults to None
        :type source: List[str], optional
        :param thread: Filter based on the specified thread identifiers., defaults to None
        :type thread: List[str], optional
        :param text: Filter based on the specified text(s). Provided multiple times, the values are ANDed., defaults to None
        :type text: List[str], optional
        :param status: Filter for specified status., defaults to None
        :type status: List[ContentStatus], optional
        :param order_by: Order results by specified field., defaults to None
        :type order_by: SocMsgCreationTimeOrder, optional
        :param page_token: The token indicating the particular page of the result set to be retrieved.
        If omitted the first page will be returned., defaults to None
        :type page_token: str, optional
        :param per_page: The number of items per page. If provided value in the request
        is greater than a maximum, the maximum value is applied, defaults to None
        :type per_page: int, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response.
        :rtype: ContentList
        """

        Validator(str).is_array().is_optional().validate(intervention)
        Validator(str).is_array().is_optional().validate(identity)
        Validator(str).is_array().is_optional().validate(identity_group)
        Validator(str).is_array().is_optional().validate(source)
        Validator(str).is_array().is_optional().validate(thread)
        Validator(str).is_array().is_optional().validate(text)
        Validator(ContentStatus).is_array().is_optional().validate(status)
        Validator(SocMsgCreationTimeOrder).is_optional().validate(order_by)
        Validator(str).is_optional().validate(page_token)
        Validator(int).is_optional().min(1).max(1000).validate(per_page)

        serialized_request = (
            Serializer(
                f"{self.base_url}/cx/social-messaging/v1/contents",
                self.get_default_headers(),
            )
            .add_query("intervention", intervention)
            .add_query("identity", identity)
            .add_query("identityGroup", identity_group)
            .add_query("source", source)
            .add_query("thread", thread)
            .add_query("text", text)
            .add_query("status", status)
            .add_query("orderBy", order_by)
            .add_query("pageToken", page_token, explode=False)
            .add_query("perPage", per_page, explode=False)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return ContentList._unmap(response)

    @cast_models
    def soc_msg_create_content(
        self, request_body: CreateContentRequest
    ) -> ContentModel:
        """Creates new content for use in discussions.

        This request is used to reply to already-posted content or to initiate a discussion. If authorized, the
        authenticated user will be used as the content author.

        Content will be created and pushed asynchronously to the channel. When the content is successfully pushed to
        the channel, the Content.Exported event will be reported.

        The account context of this request is determined by the RC Account Id associated with the access token provided
        in the Authorization header.

        Replying to customer content is usually possible unless the channel or conversation is read only. Composing
        content, on the contrary, depends on the channel itself.

        * The channel may not support it (and be purely reactive like Instagram, Messenger, etc.).

        * Some channels (usually public accounts like Twitter or Facebook pages) allow for the publishing of content
        without targeting specific individuals.

        * Some channels (usually non-public media) require specific targeting (phone number for SMS, email address
        for email, customer_id, etc.) to be able to create content. This is channel-specific and detailed under the
        generic parameters.

        :param request_body: The request body.
        :type request_body: CreateContentRequest
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response.
        :rtype: ContentModel
        """

        Validator(CreateContentRequest).validate(request_body)

        serialized_request = (
            Serializer(
                f"{self.base_url}/cx/social-messaging/v1/contents",
                self.get_default_headers(),
            )
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return ContentModel._unmap(response)

    @cast_models
    def soc_msg_get_content(self, content_id: str) -> ContentModel:
        """Retrieves the content from the given id.

        :param content_id: content_id
        :type content_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response.
        :rtype: ContentModel
        """

        Validator(str).validate(content_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/cx/social-messaging/v1/contents/{{contentId}}",
                self.get_default_headers(),
            )
            .add_path("contentId", content_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return ContentModel._unmap(response)
