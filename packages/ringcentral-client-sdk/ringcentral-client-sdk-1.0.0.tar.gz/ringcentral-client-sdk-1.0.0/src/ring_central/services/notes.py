# This file was generated by liblab | https://liblab.com/

from .utils.validator import Validator
from .utils.base_service import BaseService
from ..net.transport.serializer import Serializer
from ..models.utils.cast_models import cast_models
from ..models.tm_note_with_body_info import TmNoteWithBodyInfo
from ..models.tm_note_list import TmNoteList
from ..models.tm_note_info import TmNoteInfo
from ..models.tm_create_note_request import TmCreateNoteRequest
from ..models.list_chat_notes_new_status import ListChatNotesNewStatus


class NotesService(BaseService):

    @cast_models
    def list_chat_notes_new(
        self,
        chat_id: str,
        creation_time_to: str = None,
        creation_time_from: str = None,
        creator_id: str = None,
        status: ListChatNotesNewStatus = None,
        page_token: str = None,
        record_count: int = None,
    ) -> TmNoteList:
        """Returns the list of chat notes.

        :param chat_id: Internal identifier of a chat to fetch notes from.
        :type chat_id: str
        :param creation_time_to: The end datetime for resulting records in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
        format including timezone, e.g. 2019-03-10T18:23:45. The default value is
        Now., defaults to None
        :type creation_time_to: str, optional
        :param creation_time_from: The start datetime for resulting records in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
        format including timezone, defaults to None
        :type creation_time_from: str, optional
        :param creator_id: Internal identifier of the user that created the note. Multiple
        values are supported, defaults to None
        :type creator_id: str, optional
        :param status: Status of notes to be fetched; if not specified all notes are
        fetched by default., defaults to None
        :type status: ListChatNotesNewStatus, optional
        :param page_token: Pagination token, defaults to None
        :type page_token: str, optional
        :param record_count: Max number of notes to be fetched by one request; the value range is 1-250., defaults to None
        :type record_count: int, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: OK
        :rtype: TmNoteList
        """

        Validator(str).validate(chat_id)
        Validator(str).is_optional().validate(creation_time_to)
        Validator(str).is_optional().validate(creation_time_from)
        Validator(str).is_optional().validate(creator_id)
        Validator(ListChatNotesNewStatus).is_optional().validate(status)
        Validator(str).is_optional().validate(page_token)
        Validator(int).is_optional().max(250).validate(record_count)

        serialized_request = (
            Serializer(
                f"{self.base_url}/team-messaging/v1/chats/{{chatId}}/notes",
                self.get_default_headers(),
            )
            .add_path("chatId", chat_id)
            .add_query("creationTimeTo", creation_time_to)
            .add_query("creationTimeFrom", creation_time_from)
            .add_query("creatorId", creator_id)
            .add_query("status", status)
            .add_query("pageToken", page_token)
            .add_query("recordCount", record_count)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return TmNoteList._unmap(response)

    @cast_models
    def create_chat_note_new(
        self, request_body: TmCreateNoteRequest, chat_id: str
    ) -> TmNoteInfo:
        """Creates a new note in the specified chat.

        :param request_body: The request body.
        :type request_body: TmCreateNoteRequest
        :param chat_id: Internal identifier of a chat to create a note in
        :type chat_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: OK
        :rtype: TmNoteInfo
        """

        Validator(TmCreateNoteRequest).validate(request_body)
        Validator(str).validate(chat_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/team-messaging/v1/chats/{{chatId}}/notes",
                self.get_default_headers(),
            )
            .add_path("chatId", chat_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return TmNoteInfo._unmap(response)

    @cast_models
    def read_user_note_new(self, note_id: str) -> TmNoteWithBodyInfo:
        """Returns the specified note(s). It is possible to fetch up to 50 notes per request.

        :param note_id: Internal identifier of a note to be fetched
        :type note_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: OK
        :rtype: TmNoteWithBodyInfo
        """

        Validator(str).validate(note_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/team-messaging/v1/notes/{{noteId}}",
                self.get_default_headers(),
            )
            .add_path("noteId", note_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return TmNoteWithBodyInfo._unmap(response)

    @cast_models
    def patch_note_new(
        self, request_body: TmCreateNoteRequest, note_id: str, release_lock: bool = None
    ) -> TmNoteInfo:
        """Edits a note. Notes can be edited by any user if posted to a chat. the user belongs to.

        :param request_body: The request body.
        :type request_body: TmCreateNoteRequest
        :param note_id: Internal identifier of a note to be updated
        :type note_id: str
        :param release_lock: If true then note lock (if any) will be released upon request, defaults to None
        :type release_lock: bool, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: OK
        :rtype: TmNoteInfo
        """

        Validator(TmCreateNoteRequest).validate(request_body)
        Validator(str).validate(note_id)
        Validator(bool).is_optional().validate(release_lock)

        serialized_request = (
            Serializer(
                f"{self.base_url}/team-messaging/v1/notes/{{noteId}}",
                self.get_default_headers(),
            )
            .add_path("noteId", note_id)
            .add_query("releaseLock", release_lock)
            .serialize()
            .set_method("PATCH")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return TmNoteInfo._unmap(response)

    @cast_models
    def delete_note_new(self, note_id: str):
        """Deletes the specified note.

        :param note_id: Internal identifier of a note to be deleted
        :type note_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(str).validate(note_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/team-messaging/v1/notes/{{noteId}}",
                self.get_default_headers(),
            )
            .add_path("noteId", note_id)
            .serialize()
            .set_method("DELETE")
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def lock_note_new(self, note_id: str):
        """Locks a note providing the user with the unique write access for 5 hours.

        :param note_id: Internal identifier of a note to be locked
        :type note_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(str).validate(note_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/team-messaging/v1/notes/{{noteId}}/lock",
                self.get_default_headers(),
            )
            .add_path("noteId", note_id)
            .serialize()
            .set_method("POST")
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def publish_note_new(self, note_id: str) -> TmNoteInfo:
        """Publishes a note making it visible to other users.

        :param note_id: Internal identifier of a note to be published
        :type note_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: OK
        :rtype: TmNoteInfo
        """

        Validator(str).validate(note_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/team-messaging/v1/notes/{{noteId}}/publish",
                self.get_default_headers(),
            )
            .add_path("noteId", note_id)
            .serialize()
            .set_method("POST")
        )

        response = self.send_request(serialized_request)

        return TmNoteInfo._unmap(response)

    @cast_models
    def unlock_note_new(self, note_id: str):
        """Unlocks a note letting other users edit this note. Once the note is locked (by another user) it cannot be unlocked during 5 hours since the lock datetime.

        :param note_id: Internal identifier of a note to be unlocked
        :type note_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(str).validate(note_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/team-messaging/v1/notes/{{noteId}}/unlock",
                self.get_default_headers(),
            )
            .add_path("noteId", note_id)
            .serialize()
            .set_method("POST")
        )

        response = self.send_request(serialized_request)

        return response
