# This file was generated by liblab | https://liblab.com/

from typing import List
from .utils.validator import Validator
from .utils.base_service import BaseService
from ..net.transport.serializer import Serializer
from ..models.utils.cast_models import cast_models
from ..models.update_message_request import UpdateMessageRequest
from ..models.sync_type_enum import SyncTypeEnum
from ..models.patch_message_request import PatchMessageRequest
from ..models.message_type_enum import MessageTypeEnum
from ..models.message_store_configuration import MessageStoreConfiguration
from ..models.message_read_status_enum import MessageReadStatusEnum
from ..models.message_direction_enum import MessageDirectionEnum
from ..models.message_availability_enum import MessageAvailabilityEnum
from ..models.get_message_sync_response import GetMessageSyncResponse
from ..models.get_message_list import GetMessageList
from ..models.get_message_info_response import GetMessageInfoResponse
from ..models.delete_message_by_filter_type import DeleteMessageByFilterType
from ..models.content_disposition import ContentDisposition


class MessageStoreService(BaseService):

    @cast_models
    def read_message_content(
        self,
        account_id: str,
        extension_id: str,
        message_id: str,
        attachment_id: str,
        content_disposition: ContentDisposition = None,
        content_disposition_filename: str = None,
    ) -> any:
        """Returns media content of a message attachment.
        The content is typically an audio file (`audio/mpeg` or `audio/wav`) for voicemails,
        TIFF or PDF for faxes and image/audio/video for MMS.

        **This API must be called via media API entry point, e.g. https://media.ringcentral.com**

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param extension_id: Internal identifier of the RingCentral extension/user
        (can be set to "~" to indicate that the extension associated with current authorization session should be used)
        :type extension_id: str
        :param message_id: message_id
        :type message_id: str
        :param attachment_id: attachment_id
        :type attachment_id: str
        :param content_disposition: Whether the content is expected to be displayed in the browser, or downloaded and saved locally, defaults to None
        :type content_disposition: ContentDisposition, optional
        :param content_disposition_filename: The default filename of the file to be downloaded, defaults to None
        :type content_disposition_filename: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response
        :rtype: any
        """

        Validator(str).validate(account_id)
        Validator(str).validate(extension_id)
        Validator(str).validate(message_id)
        Validator(str).validate(attachment_id)
        Validator(ContentDisposition).is_optional().validate(content_disposition)
        Validator(str).is_optional().validate(content_disposition_filename)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/extension/{{extensionId}}/message-store/{{messageId}}/content/{{attachmentId}}",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("extensionId", extension_id)
            .add_path("messageId", message_id)
            .add_path("attachmentId", attachment_id)
            .add_query("contentDisposition", content_disposition)
            .add_query("contentDispositionFilename", content_disposition_filename)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def read_message_store_configuration(
        self, account_id: str
    ) -> MessageStoreConfiguration:
        """Returns message store settings.

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Message store configuration
        :rtype: MessageStoreConfiguration
        """

        Validator(str).validate(account_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/message-store-configuration",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return MessageStoreConfiguration._unmap(response)

    @cast_models
    def update_message_store_configuration(
        self, request_body: MessageStoreConfiguration, account_id: str
    ) -> MessageStoreConfiguration:
        """Updates message store settings.

        :param request_body: The request body.
        :type request_body: MessageStoreConfiguration
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Updated message store configuration
        :rtype: MessageStoreConfiguration
        """

        Validator(MessageStoreConfiguration).validate(request_body)
        Validator(str).validate(account_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/message-store-configuration",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .serialize()
            .set_method("PUT")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return MessageStoreConfiguration._unmap(response)

    @cast_models
    def sync_messages(
        self,
        account_id: str,
        extension_id: str,
        conversation_id: int = None,
        date_from: str = None,
        date_to: str = None,
        direction: List[MessageDirectionEnum] = None,
        distinct_conversations: bool = None,
        message_type: List[MessageTypeEnum] = None,
        record_count: int = None,
        sync_token: str = None,
        sync_type: SyncTypeEnum = None,
        voicemail_owner: List[str] = None,
    ) -> GetMessageSyncResponse:
        """Synchronizes messages.

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param extension_id: Internal identifier of the RingCentral extension/user
        (can be set to "~" to indicate that the extension associated with current authorization session should be used)
        :type extension_id: str
        :param conversation_id: Conversation identifier for the resulting messages. Meaningful
        for SMS and Pager messages only., defaults to None
        :type conversation_id: int, optional
        :param date_from: The start date/time for resulting messages in ISO 8601 format
        including timezone, for example 2016-03-10T18:07:52.534Z. The default value
        is dateTo minus 24 hours, defaults to None
        :type date_from: str, optional
        :param date_to: The end date/time for resulting messages in ISO 8601 format including
        timezone, for example 2016-03-10T18:07:52.534Z. The default value is current
        time, defaults to None
        :type date_to: str, optional
        :param direction: Direction for the resulting messages. If not specified, both
        inbound and outbound messages are returned. Multiple values are accepted, defaults to None
        :type direction: List[MessageDirectionEnum], optional
        :param distinct_conversations: If `true`, then the latest messages per every conversation ID
        are returned, defaults to None
        :type distinct_conversations: bool, optional
        :param message_type: Type for the resulting messages. If not specified, all types
        of messages are returned. Multiple values are accepted, defaults to None
        :type message_type: List[MessageTypeEnum], optional
        :param record_count: Limits the number of records to be returned (works in combination
        with dateFrom and dateTo if specified), defaults to None
        :type record_count: int, optional
        :param sync_token: A `syncToken` value from the previous sync response (for `ISync` mode only, mandatory), defaults to None
        :type sync_token: str, optional
        :param sync_type: Type of message synchronization, defaults to None
        :type sync_type: SyncTypeEnum, optional
        :param voicemail_owner: This query parameter will filter voicemail messages based on its owner.
        This parameter should be controlled by the 'SharedVoicemail' feature.
        If the feature is disabled this filter shouldn't be applied., defaults to None
        :type voicemail_owner: List[str], optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Success
        :rtype: GetMessageSyncResponse
        """

        Validator(str).validate(account_id)
        Validator(str).validate(extension_id)
        Validator(int).is_optional().validate(conversation_id)
        Validator(str).is_optional().validate(date_from)
        Validator(str).is_optional().validate(date_to)
        Validator(MessageDirectionEnum).is_array().is_optional().validate(direction)
        Validator(bool).is_optional().validate(distinct_conversations)
        Validator(MessageTypeEnum).is_array().is_optional().validate(message_type)
        Validator(int).is_optional().validate(record_count)
        Validator(str).is_optional().validate(sync_token)
        Validator(SyncTypeEnum).is_optional().validate(sync_type)
        Validator(str).is_array().is_optional().validate(voicemail_owner)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/extension/{{extensionId}}/message-sync",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("extensionId", extension_id)
            .add_query("conversationId", conversation_id)
            .add_query("dateFrom", date_from)
            .add_query("dateTo", date_to)
            .add_query("direction", direction)
            .add_query("distinctConversations", distinct_conversations)
            .add_query("messageType", message_type)
            .add_query("recordCount", record_count)
            .add_query("syncToken", sync_token)
            .add_query("syncType", sync_type)
            .add_query("voicemailOwner", voicemail_owner)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return GetMessageSyncResponse._unmap(response)

    @cast_models
    def list_messages(
        self,
        account_id: str,
        extension_id: str,
        availability: List[MessageAvailabilityEnum] = None,
        conversation_id: str = None,
        date_from: str = None,
        date_to: str = None,
        direction: List[MessageDirectionEnum] = None,
        distinct_conversations: bool = None,
        message_type: List[MessageTypeEnum] = None,
        read_status: List[MessageReadStatusEnum] = None,
        page: int = None,
        per_page: int = None,
        phone_number: str = None,
    ) -> GetMessageList:
        """Returns a list of messages from an extension mailbox.

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param extension_id: Internal identifier of the RingCentral extension/user
        (can be set to "~" to indicate that the extension associated with current authorization session should be used)
        :type extension_id: str
        :param availability: Specifies the availability status for resulting messages.
        Multiple values are accepted, defaults to None
        :type availability: List[MessageAvailabilityEnum], optional
        :param conversation_id: Specifies a conversation identifier for the resulting messages, defaults to None
        :type conversation_id: str, optional
        :param date_from: Start date/time for resulting messages in ISO 8601 format
        including timezone, for example 2016-03-10T18:07:52.534Z. The default value
        is dateTo minus 24 hours, defaults to None
        :type date_from: str, optional
        :param date_to: End date/time for resulting messages in ISO 8601 format including
        timezone, for example 2016-03-10T18:07:52.534Z. The default value is current
        time, defaults to None
        :type date_to: str, optional
        :param direction: Direction for resulting messages. If not specified, both
        inbound and outbound messages are returned. Multiple values are accepted, defaults to None
        :type direction: List[MessageDirectionEnum], optional
        :param distinct_conversations: If `true`, then the latest messages per every conversation ID
        are returned, defaults to None
        :type distinct_conversations: bool, optional
        :param message_type: Type of resulting messages. If not specified, all messages
        without message type filtering are returned. Multiple values are accepted, defaults to None
        :type message_type: List[MessageTypeEnum], optional
        :param read_status: Read status for resulting messages. Multiple values are
        accepted, defaults to None
        :type read_status: List[MessageReadStatusEnum], optional
        :param page: Indicates a page number to retrieve. Only positive number values
        are accepted, defaults to None
        :type page: int, optional
        :param per_page: Indicates a page size (number of items), defaults to None
        :type per_page: int, optional
        :param phone_number: Phone number. If specified, messages are returned for this
        particular phone number only, defaults to None
        :type phone_number: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Message list
        :rtype: GetMessageList
        """

        Validator(str).validate(account_id)
        Validator(str).validate(extension_id)
        Validator(MessageAvailabilityEnum).is_array().is_optional().validate(
            availability
        )
        Validator(str).is_optional().validate(conversation_id)
        Validator(str).is_optional().validate(date_from)
        Validator(str).is_optional().validate(date_to)
        Validator(MessageDirectionEnum).is_array().is_optional().validate(direction)
        Validator(bool).is_optional().validate(distinct_conversations)
        Validator(MessageTypeEnum).is_array().is_optional().validate(message_type)
        Validator(MessageReadStatusEnum).is_array().is_optional().validate(read_status)
        Validator(int).is_optional().validate(page)
        Validator(int).is_optional().validate(per_page)
        Validator(str).is_optional().validate(phone_number)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/extension/{{extensionId}}/message-store",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("extensionId", extension_id)
            .add_query("availability", availability)
            .add_query("conversationId", conversation_id)
            .add_query("dateFrom", date_from)
            .add_query("dateTo", date_to)
            .add_query("direction", direction)
            .add_query("distinctConversations", distinct_conversations)
            .add_query("messageType", message_type)
            .add_query("readStatus", read_status)
            .add_query("page", page)
            .add_query("perPage", per_page)
            .add_query("phoneNumber", phone_number)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return GetMessageList._unmap(response)

    @cast_models
    def delete_message_by_filter(
        self,
        account_id: str,
        extension_id: str,
        conversation_id: List[str] = None,
        date_to: str = None,
        type_: DeleteMessageByFilterType = None,
    ):
        """Deletes conversation(s) by conversation ID(s). Batch request is
        supported, max number of IDs passed as query/path parameters is 50. Alternative
        syntax is supported - user conversations can be deleted by passing multiple
        IDs in request body as an array of string, max number of conversation IDs
        passed in request body is 100. In this case asterisk is used in the path instead
        of IDs

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param extension_id: Internal identifier of the RingCentral extension/user
        (can be set to "~" to indicate that the extension associated with current authorization session should be used)
        :type extension_id: str
        :param conversation_id: conversation_id, defaults to None
        :type conversation_id: List[str], optional
        :param date_to: Messages received earlier then the date specified will be deleted.
        The default value is current date/time, defaults to None
        :type date_to: str, optional
        :param type_: Type of messages to be deleted, defaults to None
        :type type_: DeleteMessageByFilterType, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(str).validate(account_id)
        Validator(str).validate(extension_id)
        Validator(str).is_array().is_optional().validate(conversation_id)
        Validator(str).is_optional().validate(date_to)
        Validator(DeleteMessageByFilterType).is_optional().validate(type_)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/extension/{{extensionId}}/message-store",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("extensionId", extension_id)
            .add_query("conversationId", conversation_id)
            .add_query("dateTo", date_to)
            .add_query("type", type_)
            .serialize()
            .set_method("DELETE")
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def read_message(
        self, account_id: str, extension_id: str, message_id: List[str]
    ) -> GetMessageInfoResponse:
        """Returns an individual message record or multiple records by the given message ID(s).
        The length of inbound messages is unlimited. Bulk syntax is supported.

        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param extension_id: Internal identifier of the RingCentral extension/user
        (can be set to "~" to indicate that the extension associated with current authorization session should be used)
        :type extension_id: str
        :param message_id: Internal identifier of a message (or multiple messages in case of bulk operation)
        :type message_id: List[str]
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response (single message)
        :rtype: GetMessageInfoResponse
        """

        Validator(str).validate(account_id)
        Validator(str).validate(extension_id)
        Validator(str).is_array().validate(message_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/extension/{{extensionId}}/message-store/{{messageId}}",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("extensionId", extension_id)
            .add_path("messageId", message_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return GetMessageInfoResponse._unmap(response)

    @cast_models
    def update_message(
        self,
        request_body: UpdateMessageRequest,
        account_id: str,
        extension_id: str,
        message_id: List[str],
    ) -> GetMessageInfoResponse:
        """Updates message(s) by their ID(s). Currently, only the `readStatus`
        can be updated using this method.

        Bulk syntax is supported, max number of IDs passed as query/path
        parameters is 50. Alternative bulk syntax is also supported - user messages can be updated
        by passing multiple IDs in request body as an array of string, max number
        of IDs passed in the body is 1000. In this case asterisk is used in the
        path instead of IDs.

        :param request_body: The request body.
        :type request_body: UpdateMessageRequest
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param extension_id: Internal identifier of the RingCentral extension/user
        (can be set to "~" to indicate that the extension associated with current authorization session should be used)
        :type extension_id: str
        :param message_id: Internal identifier of a message (or multiple messages in case of bulk operation)
        :type message_id: List[str]
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response (single message)
        :rtype: GetMessageInfoResponse
        """

        Validator(UpdateMessageRequest).validate(request_body)
        Validator(str).validate(account_id)
        Validator(str).validate(extension_id)
        Validator(str).is_array().validate(message_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/extension/{{extensionId}}/message-store/{{messageId}}",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("extensionId", extension_id)
            .add_path("messageId", message_id)
            .serialize()
            .set_method("PUT")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return GetMessageInfoResponse._unmap(response)

    @cast_models
    def patch_message(
        self,
        request_body: PatchMessageRequest,
        account_id: str,
        extension_id: str,
        message_id: List[str],
    ) -> GetMessageInfoResponse:
        """Patches message(s) by ID(s). Currently, only updating the `readStatus` and
        restoring deleted messages are supported through this method.

        For changing status of a message send `readStatus` set to either 'Read' or 'Unread' in request.
        It is possible to restore a message and its attachments (if message status is 'Deleted') by sending
        `availability` attribute set to 'Alive' in request body. If a message is already in 'Purged' state
        then its attachments cannot be restored and the message itself is about to be physically deleted.

        Bulk syntax (both traditional and alternative one) is supported.

        :param request_body: The request body.
        :type request_body: PatchMessageRequest
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param extension_id: Internal identifier of the RingCentral extension/user
        (can be set to "~" to indicate that the extension associated with current authorization session should be used)
        :type extension_id: str
        :param message_id: Internal identifier of a message (or multiple messages in case of bulk operation)
        :type message_id: List[str]
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Successful response (single message)
        :rtype: GetMessageInfoResponse
        """

        Validator(PatchMessageRequest).validate(request_body)
        Validator(str).validate(account_id)
        Validator(str).validate(extension_id)
        Validator(str).is_array().validate(message_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/extension/{{extensionId}}/message-store/{{messageId}}",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("extensionId", extension_id)
            .add_path("messageId", message_id)
            .serialize()
            .set_method("PATCH")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return GetMessageInfoResponse._unmap(response)

    @cast_models
    def delete_message(
        self,
        account_id: str,
        extension_id: str,
        message_id: List[str],
        request_body: List[str] = None,
        purge: bool = None,
    ):
        """Deletes message(s) by the given message ID(s). The first call of
        this method transfers the message to the 'Delete' status. The second call
        transfers the deleted message to the 'Purged' status. If it is required to
        make the message 'Purged' immediately (from the first call), then set the
        query parameter purge to `true`.

        :param request_body: The request body., defaults to None
        :type request_body: List[str], optional
        :param account_id: Internal identifier of the RingCentral account
        (can be set to "~" to indicate that the account associated with current authorization session should be used)
        :type account_id: str
        :param extension_id: Internal identifier of the RingCentral extension/user
        (can be set to "~" to indicate that the extension associated with current authorization session should be used)
        :type extension_id: str
        :param message_id: Internal identifier of a message (or multiple messages in case of bulk operation)
        :type message_id: List[str]
        :param purge: If the value is `true`, then the message is purged immediately
        with all the attachments, defaults to None
        :type purge: bool, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(str).is_array().is_optional().validate(request_body)
        Validator(str).validate(account_id)
        Validator(str).validate(extension_id)
        Validator(str).is_array().validate(message_id)
        Validator(bool).is_optional().validate(purge)

        serialized_request = (
            Serializer(
                f"{self.base_url}/restapi/v1.0/account/{{accountId}}/extension/{{extensionId}}/message-store/{{messageId}}",
                self.get_default_headers(),
            )
            .add_path("accountId", account_id)
            .add_path("extensionId", extension_id)
            .add_path("messageId", message_id)
            .add_query("purge", purge)
            .serialize()
            .set_method("DELETE")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)

        return response
