# This file was generated by liblab | https://liblab.com/

from typing import List
from .utils.validator import Validator
from .utils.base_service import BaseService
from ..net.transport.serializer import Serializer
from ..models.utils.cast_models import cast_models
from ..models.tm_chat_list_without_navigation import TmChatListWithoutNavigation
from ..models.tm_chat_list import TmChatList
from ..models.tm_chat_info import TmChatInfo
from ..models.list_recent_chats_new_type import ListRecentChatsNewType
from ..models.list_glip_chats_new_type import ListGlipChatsNewType


class ChatsService(BaseService):

    @cast_models
    def list_recent_chats_new(
        self, type_: List[ListRecentChatsNewType] = None, record_count: int = None
    ) -> TmChatListWithoutNavigation:
        """Returns recent chats where the user is a member. All records in response are sorted by the `lastModifiedTime` in descending order (the latest changed chat is displayed first on page)

        :param type_: Type of chats to be fetched. By default, all chat types are returned, defaults to None
        :type type_: List[ListRecentChatsNewType], optional
        :param record_count: Max number of chats to be fetched by one request (Not more than 250)., defaults to None
        :type record_count: int, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Success
        :rtype: TmChatListWithoutNavigation
        """

        Validator(ListRecentChatsNewType).is_array().is_optional().validate(type_)
        Validator(int).is_optional().max(250).validate(record_count)

        serialized_request = (
            Serializer(
                f"{self.base_url}/team-messaging/v1/recent/chats",
                self.get_default_headers(),
            )
            .add_query("type", type_)
            .add_query("recordCount", record_count)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return TmChatListWithoutNavigation._unmap(response)

    @cast_models
    def list_glip_chats_new(
        self,
        type_: List[ListGlipChatsNewType] = None,
        record_count: int = None,
        page_token: str = None,
    ) -> TmChatList:
        """Returns the list of chats where the user is a member and also public teams that can be joined.

        All records in response are sorted by creation time of a chat in ascending order.

        **Chat types**

        There are multiple types of chats, including:

        * **Personal** - each user is given a dedicated "personal chat" in which they are the only member.
        * **Direct** - a chat between two individuals.
        * **Group** - a chat between three or more named individuals. A "group" chat has no name.
        * **Team** - a chat related to a specific topic. Members can come and go freely from this chat type.
        * **Everyone** - a special chat containing every individual in a company.

        :param type_: Type of chats to be fetched. By default, all type of chats will be fetched, defaults to None
        :type type_: List[ListGlipChatsNewType], optional
        :param record_count: Number of chats to be fetched by one request. The maximum value is 250, by default - 30., defaults to None
        :type record_count: int, optional
        :param page_token: Pagination token., defaults to None
        :type page_token: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: OK
        :rtype: TmChatList
        """

        Validator(ListGlipChatsNewType).is_array().is_optional().validate(type_)
        Validator(int).is_optional().max(250).validate(record_count)
        Validator(str).is_optional().validate(page_token)

        serialized_request = (
            Serializer(
                f"{self.base_url}/team-messaging/v1/chats", self.get_default_headers()
            )
            .add_query("type", type_)
            .add_query("recordCount", record_count)
            .add_query("pageToken", page_token)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return TmChatList._unmap(response)

    @cast_models
    def read_glip_chat_new(self, chat_id: str) -> TmChatInfo:
        """Returns information about a chat by ID.

        **Note** 'Chat' is a general name for all types of threads including *Personal* (user's own me-chat), *Direct* (one on one chat), *Group* (chat of 3-15 participants without specific name), *Team* (chat of 2 and more participants, with a specific name), *Everyone* (company chat including all employees, with a specific name)."

        :param chat_id: Internal identifier of a chat. If tilde (~) is specified, then `/me` (Personal) chat will be returned
        :type chat_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: OK
        :rtype: TmChatInfo
        """

        Validator(str).validate(chat_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/team-messaging/v1/chats/{{chatId}}",
                self.get_default_headers(),
            )
            .add_path("chatId", chat_id)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return TmChatInfo._unmap(response)

    @cast_models
    def unfavorite_glip_chat_new(self, chat_id: str):
        """Removes the specified chat from the users's list of favorite chats.

        :param chat_id: Internal identifier of a chat to remove from favorite list.
        :type chat_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(str).validate(chat_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/team-messaging/v1/chats/{{chatId}}/unfavorite",
                self.get_default_headers(),
            )
            .add_path("chatId", chat_id)
            .serialize()
            .set_method("POST")
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def favorite_glip_chat_new(self, chat_id: str):
        """Adds the specified chat to the users's list of favorite chats.

        :param chat_id: Internal identifier of a chat to add to favorite list.
        :type chat_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(str).validate(chat_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/team-messaging/v1/chats/{{chatId}}/favorite",
                self.get_default_headers(),
            )
            .add_path("chatId", chat_id)
            .serialize()
            .set_method("POST")
        )

        response = self.send_request(serialized_request)

        return response

    @cast_models
    def list_favorite_chats_new(
        self, record_count: int = None
    ) -> TmChatListWithoutNavigation:
        """Returns a list of the current user's favorite chats.

        :param record_count: Max number of chats to be fetched by one request (Not more than 250)., defaults to None
        :type record_count: int, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: Success
        :rtype: TmChatListWithoutNavigation
        """

        Validator(int).is_optional().max(250).validate(record_count)

        serialized_request = (
            Serializer(
                f"{self.base_url}/team-messaging/v1/favorites",
                self.get_default_headers(),
            )
            .add_query("recordCount", record_count)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)

        return TmChatListWithoutNavigation._unmap(response)
