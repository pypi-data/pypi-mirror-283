# This file was generated by liblab | https://liblab.com/

from __future__ import annotations
from enum import Enum
from .utils.json_map import JsonMap
from .base import BaseModel
from .detailed_call_info import DetailedCallInfo
from .call_info_cq import CallInfoCq


class ActiveCallInfoDirection(Enum):
    """An enumeration representing different categories.

    :cvar INBOUND: "Inbound"
    :vartype INBOUND: str
    :cvar OUTBOUND: "Outbound"
    :vartype OUTBOUND: str
    """

    INBOUND = "Inbound"
    OUTBOUND = "Outbound"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(
            map(lambda x: x.value, ActiveCallInfoDirection._member_map_.values())
        )


class ActiveCallInfoTelephonyStatus(Enum):
    """An enumeration representing different categories.

    :cvar NOCALL: "NoCall"
    :vartype NOCALL: str
    :cvar CALLCONNECTED: "CallConnected"
    :vartype CALLCONNECTED: str
    :cvar RINGING: "Ringing"
    :vartype RINGING: str
    :cvar ONHOLD: "OnHold"
    :vartype ONHOLD: str
    :cvar PARKEDCALL: "ParkedCall"
    :vartype PARKEDCALL: str
    """

    NOCALL = "NoCall"
    CALLCONNECTED = "CallConnected"
    RINGING = "Ringing"
    ONHOLD = "OnHold"
    PARKEDCALL = "ParkedCall"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(
            map(lambda x: x.value, ActiveCallInfoTelephonyStatus._member_map_.values())
        )


@JsonMap(
    {
        "id_": "id",
        "queue_call": "queueCall",
        "from_": "from",
        "from_name": "fromName",
        "to_name": "toName",
        "start_time": "startTime",
        "telephony_status": "telephonyStatus",
        "sip_data": "sipData",
        "session_id": "sessionId",
        "telephony_session_id": "telephonySessionId",
        "on_behalf_of": "onBehalfOf",
        "party_id": "partyId",
        "termination_type": "terminationType",
        "call_info": "callInfo",
    }
)
class ActiveCallInfo(BaseModel):
    """ActiveCallInfo

    :param id_: id_, defaults to None
    :type id_: str, optional
    :param direction: direction, defaults to None
    :type direction: ActiveCallInfoDirection, optional
    :param queue_call: Identifies if a call belongs to the call queue, defaults to None
    :type queue_call: bool, optional
    :param from_: Phone number or extension number of a caller. For GCM transport type '_from' property should be used, defaults to None
    :type from_: str, optional
    :param from_name: Name of a caller, defaults to None
    :type from_name: str, optional
    :param to: Phone number or extension number of a callee, defaults to None
    :type to: str, optional
    :param to_name: Name of a callee, defaults to None
    :type to_name: str, optional
    :param start_time: Time when the call is actually started, defaults to None
    :type start_time: str, optional
    :param telephony_status: Telephony presence status, defaults to None
    :type telephony_status: ActiveCallInfoTelephonyStatus, optional
    :param sip_data: sip_data, defaults to None
    :type sip_data: DetailedCallInfo, optional
    :param session_id: session_id, defaults to None
    :type session_id: str, optional
    :param telephony_session_id: Telephony identifier of a call session, defaults to None
    :type telephony_session_id: str, optional
    :param on_behalf_of: Extension ID of the call owner on whose behalf a call is performed, defaults to None
    :type on_behalf_of: str, optional
    :param party_id: Internal identifier of a call party, defaults to None
    :type party_id: str, optional
    :param termination_type: termination_type, defaults to None
    :type termination_type: str, optional
    :param call_info: Primary/additional CQ information, defaults to None
    :type call_info: CallInfoCq, optional
    """

    def __init__(
        self,
        id_: str = None,
        direction: ActiveCallInfoDirection = None,
        queue_call: bool = None,
        from_: str = None,
        from_name: str = None,
        to: str = None,
        to_name: str = None,
        start_time: str = None,
        telephony_status: ActiveCallInfoTelephonyStatus = None,
        sip_data: DetailedCallInfo = None,
        session_id: str = None,
        telephony_session_id: str = None,
        on_behalf_of: str = None,
        party_id: str = None,
        termination_type: str = None,
        call_info: CallInfoCq = None,
    ):
        if id_ is not None:
            self.id_ = id_
        if direction is not None:
            self.direction = self._enum_matching(
                direction, ActiveCallInfoDirection.list(), "direction"
            )
        if queue_call is not None:
            self.queue_call = queue_call
        if from_ is not None:
            self.from_ = from_
        if from_name is not None:
            self.from_name = from_name
        if to is not None:
            self.to = to
        if to_name is not None:
            self.to_name = to_name
        if start_time is not None:
            self.start_time = start_time
        if telephony_status is not None:
            self.telephony_status = self._enum_matching(
                telephony_status,
                ActiveCallInfoTelephonyStatus.list(),
                "telephony_status",
            )
        if sip_data is not None:
            self.sip_data = self._define_object(sip_data, DetailedCallInfo)
        if session_id is not None:
            self.session_id = session_id
        if telephony_session_id is not None:
            self.telephony_session_id = telephony_session_id
        if on_behalf_of is not None:
            self.on_behalf_of = on_behalf_of
        if party_id is not None:
            self.party_id = party_id
        if termination_type is not None:
            self.termination_type = termination_type
        if call_info is not None:
            self.call_info = self._define_object(call_info, CallInfoCq)
