# This file was generated by liblab | https://liblab.com/

from __future__ import annotations
from enum import Enum
from typing import List
from .utils.json_map import JsonMap
from .base import BaseModel
from .callers_info_request import CallersInfoRequest
from .called_number_info import CalledNumberInfo
from .schedule_info import ScheduleInfo
from .forwarding_info import ForwardingInfo
from .unconditional_forwarding_info import UnconditionalForwardingInfo
from .queue_info import QueueInfo
from .transferred_extension_info import TransferredExtensionInfo
from .voicemail_info import VoicemailInfo
from .missed_call_info import MissedCallInfo
from .greeting_info import GreetingInfo


class CreateAnsweringRuleRequestCallHandlingAction(Enum):
    """An enumeration representing different categories.

    :cvar FORWARDCALLS: "ForwardCalls"
    :vartype FORWARDCALLS: str
    :cvar UNCONDITIONALFORWARDING: "UnconditionalForwarding"
    :vartype UNCONDITIONALFORWARDING: str
    :cvar AGENTQUEUE: "AgentQueue"
    :vartype AGENTQUEUE: str
    :cvar TRANSFERTOEXTENSION: "TransferToExtension"
    :vartype TRANSFERTOEXTENSION: str
    :cvar TAKEMESSAGESONLY: "TakeMessagesOnly"
    :vartype TAKEMESSAGESONLY: str
    :cvar PLAYANNOUNCEMENTONLY: "PlayAnnouncementOnly"
    :vartype PLAYANNOUNCEMENTONLY: str
    :cvar SHAREDLINES: "SharedLines"
    :vartype SHAREDLINES: str
    """

    FORWARDCALLS = "ForwardCalls"
    UNCONDITIONALFORWARDING = "UnconditionalForwarding"
    AGENTQUEUE = "AgentQueue"
    TRANSFERTOEXTENSION = "TransferToExtension"
    TAKEMESSAGESONLY = "TakeMessagesOnly"
    PLAYANNOUNCEMENTONLY = "PlayAnnouncementOnly"
    SHAREDLINES = "SharedLines"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(
            map(
                lambda x: x.value,
                CreateAnsweringRuleRequestCallHandlingAction._member_map_.values(),
            )
        )


class CreateAnsweringRuleRequestScreening(Enum):
    """An enumeration representing different categories.

    :cvar OFF: "Off"
    :vartype OFF: str
    :cvar NOCALLERID: "NoCallerId"
    :vartype NOCALLERID: str
    :cvar UNKNOWNCALLERID: "UnknownCallerId"
    :vartype UNKNOWNCALLERID: str
    :cvar ALWAYS: "Always"
    :vartype ALWAYS: str
    """

    OFF = "Off"
    NOCALLERID = "NoCallerId"
    UNKNOWNCALLERID = "UnknownCallerId"
    ALWAYS = "Always"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(
            map(
                lambda x: x.value,
                CreateAnsweringRuleRequestScreening._member_map_.values(),
            )
        )


@JsonMap(
    {
        "type_": "type",
        "called_numbers": "calledNumbers",
        "call_handling_action": "callHandlingAction",
        "unconditional_forwarding": "unconditionalForwarding",
        "missed_call": "missedCall",
    }
)
class CreateAnsweringRuleRequest(BaseModel):
    """CreateAnsweringRuleRequest

    :param enabled: Specifies if the rule is active or inactive. The default value<br>is `true`<br>, defaults to None
    :type enabled: bool, optional
    :param type_: Type of an answering rule. The 'Custom' value should be specified
    :type type_: str
    :param name: Name of an answering rule specified by user
    :type name: str
    :param callers: Answering rule will be applied when calls are received from the specified caller(s), defaults to None
    :type callers: List[CallersInfoRequest], optional
    :param called_numbers: Answering rules are applied when calling to selected number(s), defaults to None
    :type called_numbers: List[CalledNumberInfo], optional
    :param schedule: Schedule when an answering rule should be applied, defaults to None
    :type schedule: ScheduleInfo, optional
    :param call_handling_action: Specifies how incoming calls are forwarded, defaults to None
    :type call_handling_action: CreateAnsweringRuleRequestCallHandlingAction, optional
    :param forwarding: Forwarding parameters. Returned if 'ForwardCalls' is specified in 'callHandlingAction'. These settings determine the forwarding numbers to which the call will be forwarded, defaults to None
    :type forwarding: ForwardingInfo, optional
    :param unconditional_forwarding: Unconditional forwarding parameters.<br>Returned if 'UnconditionalForwarding' value is specified for the `callHandlingAction` parameter<br>, defaults to None
    :type unconditional_forwarding: UnconditionalForwardingInfo, optional
    :param queue: Queue settings applied for department (call queue) extension type,<br>with the 'AgentQueue' value specified as a call handling action<br>, defaults to None
    :type queue: QueueInfo, optional
    :param transfer: transfer, defaults to None
    :type transfer: TransferredExtensionInfo, optional
    :param voicemail: Specifies whether to take a voicemail and who should do it, defaults to None
    :type voicemail: VoicemailInfo, optional
    :param missed_call: Specifies behavior for the missed call scenario. Returned only if `enabled` parameter of a voicemail is set to 'false', defaults to None
    :type missed_call: MissedCallInfo, optional
    :param greetings: Greetings applied for an answering rule; only predefined greetings<br>can be applied, see Dictionary Greeting List<br>, defaults to None
    :type greetings: List[GreetingInfo], optional
    :param screening: Call screening status. 'Off' - no call screening; 'NoCallerId'<br>- if caller ID is missing, then callers are asked to say their name before<br>connecting; 'UnknownCallerId' - if caller ID is not in contact list, then<br>callers are asked to say their name before connecting; 'Always' - the<br>callers are always asked to say their name before connecting. The default<br>value is 'Off'<br>, defaults to None
    :type screening: CreateAnsweringRuleRequestScreening, optional
    """

    def __init__(
        self,
        type_: str,
        name: str,
        enabled: bool = None,
        callers: List[CallersInfoRequest] = None,
        called_numbers: List[CalledNumberInfo] = None,
        schedule: ScheduleInfo = None,
        call_handling_action: CreateAnsweringRuleRequestCallHandlingAction = None,
        forwarding: ForwardingInfo = None,
        unconditional_forwarding: UnconditionalForwardingInfo = None,
        queue: QueueInfo = None,
        transfer: TransferredExtensionInfo = None,
        voicemail: VoicemailInfo = None,
        missed_call: MissedCallInfo = None,
        greetings: List[GreetingInfo] = None,
        screening: CreateAnsweringRuleRequestScreening = None,
    ):
        if enabled is not None:
            self.enabled = enabled
        self.type_ = type_
        self.name = name
        if callers is not None:
            self.callers = self._define_list(callers, CallersInfoRequest)
        if called_numbers is not None:
            self.called_numbers = self._define_list(called_numbers, CalledNumberInfo)
        if schedule is not None:
            self.schedule = self._define_object(schedule, ScheduleInfo)
        if call_handling_action is not None:
            self.call_handling_action = self._enum_matching(
                call_handling_action,
                CreateAnsweringRuleRequestCallHandlingAction.list(),
                "call_handling_action",
            )
        if forwarding is not None:
            self.forwarding = self._define_object(forwarding, ForwardingInfo)
        if unconditional_forwarding is not None:
            self.unconditional_forwarding = self._define_object(
                unconditional_forwarding, UnconditionalForwardingInfo
            )
        if queue is not None:
            self.queue = self._define_object(queue, QueueInfo)
        if transfer is not None:
            self.transfer = self._define_object(transfer, TransferredExtensionInfo)
        if voicemail is not None:
            self.voicemail = self._define_object(voicemail, VoicemailInfo)
        if missed_call is not None:
            self.missed_call = self._define_object(missed_call, MissedCallInfo)
        if greetings is not None:
            self.greetings = self._define_list(greetings, GreetingInfo)
        if screening is not None:
            self.screening = self._enum_matching(
                screening, CreateAnsweringRuleRequestScreening.list(), "screening"
            )
