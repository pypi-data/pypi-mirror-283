# This file was generated by liblab | https://liblab.com/

from enum import Enum
from typing import List
from .utils.json_map import JsonMap
from .base import BaseModel


class RecordingStatus(Enum):
    """An enumeration representing different categories.

    :cvar PROCESSING: "Processing"
    :vartype PROCESSING: str
    :cvar PROCESSED: "Processed"
    :vartype PROCESSED: str
    :cvar ERROR: "Error"
    :vartype ERROR: str
    :cvar CORRUPTED: "Corrupted"
    :vartype CORRUPTED: str
    :cvar INPROGRESS: "InProgress"
    :vartype INPROGRESS: str
    :cvar PURGED: "Purged"
    :vartype PURGED: str
    :cvar FAILED: "Failed"
    :vartype FAILED: str
    """

    PROCESSING = "Processing"
    PROCESSED = "Processed"
    ERROR = "Error"
    CORRUPTED = "Corrupted"
    INPROGRESS = "InProgress"
    PURGED = "Purged"
    FAILED = "Failed"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, RecordingStatus._member_map_.values()))


class AvailabilityStatus(Enum):
    """An enumeration representing different categories.

    :cvar ALIVE: "Alive"
    :vartype ALIVE: str
    :cvar DELETED: "Deleted"
    :vartype DELETED: str
    :cvar PURGED: "Purged"
    :vartype PURGED: str
    :cvar NOTAVAILABLE: "NotAvailable"
    :vartype NOTAVAILABLE: str
    """

    ALIVE = "Alive"
    DELETED = "Deleted"
    PURGED = "Purged"
    NOTAVAILABLE = "NotAvailable"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, AvailabilityStatus._member_map_.values()))


@JsonMap(
    {
        "id_": "id",
        "start_time": "startTime",
        "availability_status": "availabilityStatus",
        "long_summary": "longSummary",
        "short_summary": "shortSummary",
    }
)
class Recording(BaseModel):
    """Recording information

    :param id_: Recording id
    :type id_: str
    :param start_time: Recording start time, defaults to None
    :type start_time: int, optional
    :param url: Secure Link to the recording file, defaults to None
    :type url: str, optional
    :param metadata: metadata, defaults to None
    :type metadata: dict, optional
    :param status: Recording processing status, defaults to None
    :type status: RecordingStatus, optional
    :param availability_status: Availability status
    :type availability_status: AvailabilityStatus
    :param long_summary: During meeting AI team analyze code and after meeting finished generates text summary about this meeting, defaults to None
    :type long_summary: str, optional
    :param short_summary: During meeting AI team analyze code and after meeting finished generates text summary about this meeting, defaults to None
    :type short_summary: str, optional
    :param keywords: During meeting AI team analyze code and after meeting finished generates key words used in meeting, defaults to None
    :type keywords: List[str], optional
    """

    def __init__(
        self,
        id_: str,
        availability_status: AvailabilityStatus,
        start_time: int = None,
        url: str = None,
        metadata: dict = None,
        status: RecordingStatus = None,
        long_summary: str = None,
        short_summary: str = None,
        keywords: List[str] = None,
    ):
        self.id_ = id_
        if start_time is not None:
            self.start_time = start_time
        if url is not None:
            self.url = url
        if metadata is not None:
            self.metadata = metadata
        if status is not None:
            self.status = self._enum_matching(status, RecordingStatus.list(), "status")
        self.availability_status = self._enum_matching(
            availability_status, AvailabilityStatus.list(), "availability_status"
        )
        if long_summary is not None:
            self.long_summary = long_summary
        if short_summary is not None:
            self.short_summary = short_summary
        if keywords is not None:
            self.keywords = keywords
