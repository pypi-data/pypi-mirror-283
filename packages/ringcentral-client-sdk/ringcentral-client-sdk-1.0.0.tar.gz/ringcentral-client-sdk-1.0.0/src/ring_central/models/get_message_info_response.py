# This file was generated by liblab | https://liblab.com/

from __future__ import annotations
from enum import Enum
from typing import List
from .utils.json_map import JsonMap
from .base import BaseModel
from .message_attachment_info import MessageAttachmentInfo
from .message_availability_enum import MessageAvailabilityEnum
from .conversation_info import ConversationInfo
from .message_direction_enum import MessageDirectionEnum
from .fax_resolution_enum import FaxResolutionEnum
from .message_store_caller_info_response_from import MessageStoreCallerInfoResponseFrom
from .message_status_enum import MessageStatusEnum
from .message_priority_enum import MessagePriorityEnum
from .message_read_status_enum import MessageReadStatusEnum
from .message_store_caller_info_response_to import MessageStoreCallerInfoResponseTo


class GetMessageInfoResponseType(Enum):
    """An enumeration representing different categories.

    :cvar FAX: "Fax"
    :vartype FAX: str
    :cvar SMS: "SMS"
    :vartype SMS: str
    :cvar VOICEMAIL: "VoiceMail"
    :vartype VOICEMAIL: str
    :cvar PAGER: "Pager"
    :vartype PAGER: str
    :cvar TEXT: "Text"
    :vartype TEXT: str
    """

    FAX = "Fax"
    SMS = "SMS"
    VOICEMAIL = "VoiceMail"
    PAGER = "Pager"
    TEXT = "Text"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(
            map(lambda x: x.value, GetMessageInfoResponseType._member_map_.values())
        )


class VmTranscriptionStatus(Enum):
    """An enumeration representing different categories.

    :cvar NOTAVAILABLE: "NotAvailable"
    :vartype NOTAVAILABLE: str
    :cvar INPROGRESS: "InProgress"
    :vartype INPROGRESS: str
    :cvar TIMEDOUT: "TimedOut"
    :vartype TIMEDOUT: str
    :cvar COMPLETED: "Completed"
    :vartype COMPLETED: str
    :cvar COMPLETEDPARTIALLY: "CompletedPartially"
    :vartype COMPLETEDPARTIALLY: str
    :cvar FAILED: "Failed"
    :vartype FAILED: str
    :cvar UNKNOWN: "Unknown"
    :vartype UNKNOWN: str
    """

    NOTAVAILABLE = "NotAvailable"
    INPROGRESS = "InProgress"
    TIMEDOUT = "TimedOut"
    COMPLETED = "Completed"
    COMPLETEDPARTIALLY = "CompletedPartially"
    FAILED = "Failed"
    UNKNOWN = "Unknown"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, VmTranscriptionStatus._member_map_.values()))


@JsonMap(
    {
        "id_": "id",
        "extension_id": "extensionId",
        "conversation_id": "conversationId",
        "creation_time": "creationTime",
        "delivery_error_code": "deliveryErrorCode",
        "fax_page_count": "faxPageCount",
        "fax_resolution": "faxResolution",
        "from_": "from",
        "last_modified_time": "lastModifiedTime",
        "message_status": "messageStatus",
        "pg_to_department": "pgToDepartment",
        "read_status": "readStatus",
        "sms_delivery_time": "smsDeliveryTime",
        "sms_sending_attempts_count": "smsSendingAttemptsCount",
        "type_": "type",
        "vm_transcription_status": "vmTranscriptionStatus",
        "cover_index": "coverIndex",
        "cover_page_text": "coverPageText",
    }
)
class GetMessageInfoResponse(BaseModel):
    """GetMessageInfoResponse

    :param id_: Internal identifier of a message, defaults to None
    :type id_: int, optional
    :param uri: Canonical URI of a message, defaults to None
    :type uri: str, optional
    :param extension_id: Internal identifier of an extension, defaults to None
    :type extension_id: str, optional
    :param attachments: List of message attachments, defaults to None
    :type attachments: List[MessageAttachmentInfo], optional
    :param availability: Message availability status. Message in 'Deleted' state is still<br>preserved with all its attachments and can be restored. 'Purged' means<br>that all attachments are already deleted and the message itself is about<br>to be physically deleted shortly<br>, defaults to None
    :type availability: MessageAvailabilityEnum, optional
    :param conversation_id: SMS and Pager only. Identifier of a conversation the message<br>belongs to<br>, defaults to None
    :type conversation_id: int, optional
    :param conversation: SMS and Pager only. Information about a conversation the message belongs to, defaults to None
    :type conversation: ConversationInfo, optional
    :param creation_time: Message creation date/time in ISO 8601 format including timezone,<br>for example 2016-03-10T18:07:52.534Z<br>, defaults to None
    :type creation_time: str, optional
    :param delivery_error_code: SMS only. Delivery error code returned by gateway, defaults to None
    :type delivery_error_code: str, optional
    :param direction: Text message direction. Note that for some message types not all<br>directions are allowed. For example voicemail messages can<br>be only inbound<br>, defaults to None
    :type direction: MessageDirectionEnum, optional
    :param fax_page_count: Fax only. Page count in a fax message, defaults to None
    :type fax_page_count: int, optional
    :param fax_resolution: Fax only. Resolution of a fax message. 'High' for black and<br>white image scanned at 200 dpi, 'Low' for black and white image scanned<br>at 100 dpi<br>, defaults to None
    :type fax_resolution: FaxResolutionEnum, optional
    :param from_: Sender information, defaults to None
    :type from_: MessageStoreCallerInfoResponseFrom, optional
    :param last_modified_time: The date/time when the message was modified on server in ISO<br>8601 format including timezone, for example 2016-03-10T18:07:52.534Z<br>, defaults to None
    :type last_modified_time: str, optional
    :param message_status: Message status. Different message types may have different<br>allowed status values. For outbound faxes the aggregated message status<br>is returned. If, for outbound message, a status for at least one recipient is 'Queued', then<br>the 'Queued' value is returned. If a status for at least one recipient is<br>'SendingFailed', then the 'SendingFailed' value is returned. In other cases<br>the 'Sent' status is returned<br>, defaults to None
    :type message_status: MessageStatusEnum, optional
    :param pg_to_department: Pager only. `true` if at least one of the message recipients is<br>'Department' extension<br>, defaults to None
    :type pg_to_department: bool, optional
    :param priority: Message priority, defaults to None
    :type priority: MessagePriorityEnum, optional
    :param read_status: Message read status, defaults to None
    :type read_status: MessageReadStatusEnum, optional
    :param sms_delivery_time: SMS only. Date/time when outbound SMS was delivered to recipient's<br>handset in ISO 8601 format including timezone, for example<br>2016-03-10T18:07:52.534Z. It is filled only if a carrier sends a delivery<br>receipt to RingCentral<br>, defaults to None
    :type sms_delivery_time: str, optional
    :param sms_sending_attempts_count: SMS only. Number of attempts made to send an outbound SMS to<br>the Gateway (if Gateway is temporary unavailable)<br>, defaults to None
    :type sms_sending_attempts_count: int, optional
    :param subject: Message subject. For SMS and Pager messages it replicates message<br>text which is also returned as an attachment<br>, defaults to None
    :type subject: str, optional
    :param to: Recipient information, defaults to None
    :type to: List[MessageStoreCallerInfoResponseTo], optional
    :param type_: Message type, defaults to None
    :type type_: GetMessageInfoResponseType, optional
    :param vm_transcription_status: Voicemail only. Status of a voicemail to text transcription.<br>If 'VoicemailToText' feature is not activated for account,<br>the 'NotAvailable' value is returned<br>, defaults to None
    :type vm_transcription_status: VmTranscriptionStatus, optional
    :param cover_index: Cover page identifier. If coverIndex is set to '0' (zero) cover<br>page is not attached. For the list of available cover page identifiers<br>(1-13) please call the Fax Cover Pages method. If not specified,<br>the default cover page is attached (which is configured in 'Outbound<br>Fax Settings')<br>, defaults to None
    :type cover_index: int, optional
    :param cover_page_text: Cover page text, entered by the fax sender and printed on the<br>cover page. Maximum length is limited to 1024 symbols<br>, defaults to None
    :type cover_page_text: str, optional
    """

    def __init__(
        self,
        id_: int = None,
        uri: str = None,
        extension_id: str = None,
        attachments: List[MessageAttachmentInfo] = None,
        availability: MessageAvailabilityEnum = None,
        conversation_id: int = None,
        conversation: ConversationInfo = None,
        creation_time: str = None,
        delivery_error_code: str = None,
        direction: MessageDirectionEnum = None,
        fax_page_count: int = None,
        fax_resolution: FaxResolutionEnum = None,
        from_: MessageStoreCallerInfoResponseFrom = None,
        last_modified_time: str = None,
        message_status: MessageStatusEnum = None,
        pg_to_department: bool = None,
        priority: MessagePriorityEnum = None,
        read_status: MessageReadStatusEnum = None,
        sms_delivery_time: str = None,
        sms_sending_attempts_count: int = None,
        subject: str = None,
        to: List[MessageStoreCallerInfoResponseTo] = None,
        type_: GetMessageInfoResponseType = None,
        vm_transcription_status: VmTranscriptionStatus = None,
        cover_index: int = None,
        cover_page_text: str = None,
    ):
        if id_ is not None:
            self.id_ = id_
        if uri is not None:
            self.uri = uri
        if extension_id is not None:
            self.extension_id = extension_id
        if attachments is not None:
            self.attachments = self._define_list(attachments, MessageAttachmentInfo)
        if availability is not None:
            self.availability = self._enum_matching(
                availability, MessageAvailabilityEnum.list(), "availability"
            )
        if conversation_id is not None:
            self.conversation_id = conversation_id
        if conversation is not None:
            self.conversation = self._define_object(conversation, ConversationInfo)
        if creation_time is not None:
            self.creation_time = creation_time
        if delivery_error_code is not None:
            self.delivery_error_code = delivery_error_code
        if direction is not None:
            self.direction = self._enum_matching(
                direction, MessageDirectionEnum.list(), "direction"
            )
        if fax_page_count is not None:
            self.fax_page_count = fax_page_count
        if fax_resolution is not None:
            self.fax_resolution = self._enum_matching(
                fax_resolution, FaxResolutionEnum.list(), "fax_resolution"
            )
        if from_ is not None:
            self.from_ = self._define_object(from_, MessageStoreCallerInfoResponseFrom)
        if last_modified_time is not None:
            self.last_modified_time = last_modified_time
        if message_status is not None:
            self.message_status = self._enum_matching(
                message_status, MessageStatusEnum.list(), "message_status"
            )
        if pg_to_department is not None:
            self.pg_to_department = pg_to_department
        if priority is not None:
            self.priority = self._enum_matching(
                priority, MessagePriorityEnum.list(), "priority"
            )
        if read_status is not None:
            self.read_status = self._enum_matching(
                read_status, MessageReadStatusEnum.list(), "read_status"
            )
        if sms_delivery_time is not None:
            self.sms_delivery_time = sms_delivery_time
        if sms_sending_attempts_count is not None:
            self.sms_sending_attempts_count = sms_sending_attempts_count
        if subject is not None:
            self.subject = subject
        if to is not None:
            self.to = self._define_list(to, MessageStoreCallerInfoResponseTo)
        if type_ is not None:
            self.type_ = self._enum_matching(
                type_, GetMessageInfoResponseType.list(), "type_"
            )
        if vm_transcription_status is not None:
            self.vm_transcription_status = self._enum_matching(
                vm_transcription_status,
                VmTranscriptionStatus.list(),
                "vm_transcription_status",
            )
        if cover_index is not None:
            self.cover_index = cover_index
        if cover_page_text is not None:
            self.cover_page_text = cover_page_text
