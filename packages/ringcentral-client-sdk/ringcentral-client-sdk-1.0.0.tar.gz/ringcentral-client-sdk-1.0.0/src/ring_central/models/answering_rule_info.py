# This file was generated by liblab | https://liblab.com/

from __future__ import annotations
from enum import Enum
from typing import List
from .utils.json_map import JsonMap
from .base import BaseModel
from .schedule_info import ScheduleInfo
from .called_number_info import CalledNumberInfo
from .callers_info import CallersInfo
from .forwarding_info import ForwardingInfo
from .unconditional_forwarding_info import UnconditionalForwardingInfo
from .queue_info import QueueInfo
from .transferred_extension_info import TransferredExtensionInfo
from .voicemail_info import VoicemailInfo
from .greeting_info import GreetingInfo
from .shared_lines_info import SharedLinesInfo
from .missed_call_info import MissedCallInfo


class AnsweringRuleInfoType(Enum):
    """An enumeration representing different categories.

    :cvar BUSINESSHOURS: "BusinessHours"
    :vartype BUSINESSHOURS: str
    :cvar AFTERHOURS: "AfterHours"
    :vartype AFTERHOURS: str
    :cvar CUSTOM: "Custom"
    :vartype CUSTOM: str
    """

    BUSINESSHOURS = "BusinessHours"
    AFTERHOURS = "AfterHours"
    CUSTOM = "Custom"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, AnsweringRuleInfoType._member_map_.values()))


class AnsweringRuleInfoCallHandlingAction(Enum):
    """An enumeration representing different categories.

    :cvar FORWARDCALLS: "ForwardCalls"
    :vartype FORWARDCALLS: str
    :cvar UNCONDITIONALFORWARDING: "UnconditionalForwarding"
    :vartype UNCONDITIONALFORWARDING: str
    :cvar AGENTQUEUE: "AgentQueue"
    :vartype AGENTQUEUE: str
    :cvar TRANSFERTOEXTENSION: "TransferToExtension"
    :vartype TRANSFERTOEXTENSION: str
    :cvar TAKEMESSAGESONLY: "TakeMessagesOnly"
    :vartype TAKEMESSAGESONLY: str
    :cvar PLAYANNOUNCEMENTONLY: "PlayAnnouncementOnly"
    :vartype PLAYANNOUNCEMENTONLY: str
    :cvar SHAREDLINES: "SharedLines"
    :vartype SHAREDLINES: str
    """

    FORWARDCALLS = "ForwardCalls"
    UNCONDITIONALFORWARDING = "UnconditionalForwarding"
    AGENTQUEUE = "AgentQueue"
    TRANSFERTOEXTENSION = "TransferToExtension"
    TAKEMESSAGESONLY = "TakeMessagesOnly"
    PLAYANNOUNCEMENTONLY = "PlayAnnouncementOnly"
    SHAREDLINES = "SharedLines"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(
            map(
                lambda x: x.value,
                AnsweringRuleInfoCallHandlingAction._member_map_.values(),
            )
        )


class AnsweringRuleInfoScreening(Enum):
    """An enumeration representing different categories.

    :cvar OFF: "Off"
    :vartype OFF: str
    :cvar NOCALLERID: "NoCallerId"
    :vartype NOCALLERID: str
    :cvar UNKNOWNCALLERID: "UnknownCallerId"
    :vartype UNKNOWNCALLERID: str
    :cvar ALWAYS: "Always"
    :vartype ALWAYS: str
    """

    OFF = "Off"
    NOCALLERID = "NoCallerId"
    UNKNOWNCALLERID = "UnknownCallerId"
    ALWAYS = "Always"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(
            map(lambda x: x.value, AnsweringRuleInfoScreening._member_map_.values())
        )


@JsonMap(
    {
        "id_": "id",
        "type_": "type",
        "called_numbers": "calledNumbers",
        "call_handling_action": "callHandlingAction",
        "unconditional_forwarding": "unconditionalForwarding",
        "shared_lines": "sharedLines",
        "missed_call": "missedCall",
    }
)
class AnsweringRuleInfo(BaseModel):
    """AnsweringRuleInfo

    :param uri: Canonical URI to an answering rule resource, defaults to None
    :type uri: str, optional
    :param id_: Internal identifier of an answering rule, defaults to None
    :type id_: str, optional
    :param type_: Type of an answering rule, defaults to None
    :type type_: AnsweringRuleInfoType, optional
    :param name: Name of an answering rule specified by user, defaults to None
    :type name: str, optional
    :param enabled: Specifies if an answering rule is active or inactive, defaults to None
    :type enabled: bool, optional
    :param schedule: Schedule when an answering rule should be applied, defaults to None
    :type schedule: ScheduleInfo, optional
    :param called_numbers: Answering rules are applied when calling to selected number(s), defaults to None
    :type called_numbers: List[CalledNumberInfo], optional
    :param callers: Answering rules are applied when calls are received from specified caller(s), defaults to None
    :type callers: List[CallersInfo], optional
    :param call_handling_action: Specifies how incoming calls are forwarded, defaults to None
    :type call_handling_action: AnsweringRuleInfoCallHandlingAction, optional
    :param forwarding: Forwarding parameters. Returned if 'ForwardCalls' is specified in 'callHandlingAction'. These settings determine the forwarding numbers to which the call will be forwarded, defaults to None
    :type forwarding: ForwardingInfo, optional
    :param unconditional_forwarding: Unconditional forwarding parameters.<br>Returned if 'UnconditionalForwarding' value is specified for the `callHandlingAction` parameter<br>, defaults to None
    :type unconditional_forwarding: UnconditionalForwardingInfo, optional
    :param queue: Queue settings applied for department (call queue) extension type,<br>with the 'AgentQueue' value specified as a call handling action<br>, defaults to None
    :type queue: QueueInfo, optional
    :param transfer: transfer, defaults to None
    :type transfer: TransferredExtensionInfo, optional
    :param voicemail: Specifies whether to take a voicemail and who should do it, defaults to None
    :type voicemail: VoicemailInfo, optional
    :param greetings: Greetings applied for an answering rule; only predefined greetings can be applied, see Dictionary Greeting List, defaults to None
    :type greetings: List[GreetingInfo], optional
    :param screening: Call screening status. 'Off' - no call screening; 'NoCallerId' - if caller ID is missing, then callers are asked to say their name before connecting; 'UnknownCallerId' - if caller ID is not in contact list, then callers are asked to say their name before connecting; 'Always' - the callers are always asked to say their name before connecting. The default value is 'Off', defaults to None
    :type screening: AnsweringRuleInfoScreening, optional
    :param shared_lines: SharedLines call handling action settings, defaults to None
    :type shared_lines: SharedLinesInfo, optional
    :param missed_call: Specifies behavior for the missed call scenario. Returned only if `enabled` parameter of a voicemail is set to 'false', defaults to None
    :type missed_call: MissedCallInfo, optional
    """

    def __init__(
        self,
        uri: str = None,
        id_: str = None,
        type_: AnsweringRuleInfoType = None,
        name: str = None,
        enabled: bool = None,
        schedule: ScheduleInfo = None,
        called_numbers: List[CalledNumberInfo] = None,
        callers: List[CallersInfo] = None,
        call_handling_action: AnsweringRuleInfoCallHandlingAction = None,
        forwarding: ForwardingInfo = None,
        unconditional_forwarding: UnconditionalForwardingInfo = None,
        queue: QueueInfo = None,
        transfer: TransferredExtensionInfo = None,
        voicemail: VoicemailInfo = None,
        greetings: List[GreetingInfo] = None,
        screening: AnsweringRuleInfoScreening = None,
        shared_lines: SharedLinesInfo = None,
        missed_call: MissedCallInfo = None,
    ):
        if uri is not None:
            self.uri = uri
        if id_ is not None:
            self.id_ = id_
        if type_ is not None:
            self.type_ = self._enum_matching(
                type_, AnsweringRuleInfoType.list(), "type_"
            )
        if name is not None:
            self.name = name
        if enabled is not None:
            self.enabled = enabled
        if schedule is not None:
            self.schedule = self._define_object(schedule, ScheduleInfo)
        if called_numbers is not None:
            self.called_numbers = self._define_list(called_numbers, CalledNumberInfo)
        if callers is not None:
            self.callers = self._define_list(callers, CallersInfo)
        if call_handling_action is not None:
            self.call_handling_action = self._enum_matching(
                call_handling_action,
                AnsweringRuleInfoCallHandlingAction.list(),
                "call_handling_action",
            )
        if forwarding is not None:
            self.forwarding = self._define_object(forwarding, ForwardingInfo)
        if unconditional_forwarding is not None:
            self.unconditional_forwarding = self._define_object(
                unconditional_forwarding, UnconditionalForwardingInfo
            )
        if queue is not None:
            self.queue = self._define_object(queue, QueueInfo)
        if transfer is not None:
            self.transfer = self._define_object(transfer, TransferredExtensionInfo)
        if voicemail is not None:
            self.voicemail = self._define_object(voicemail, VoicemailInfo)
        if greetings is not None:
            self.greetings = self._define_list(greetings, GreetingInfo)
        if screening is not None:
            self.screening = self._enum_matching(
                screening, AnsweringRuleInfoScreening.list(), "screening"
            )
        if shared_lines is not None:
            self.shared_lines = self._define_object(shared_lines, SharedLinesInfo)
        if missed_call is not None:
            self.missed_call = self._define_object(missed_call, MissedCallInfo)
