# This file was generated by liblab | https://liblab.com/

from __future__ import annotations
from enum import Enum
from .utils.json_map import JsonMap
from .base import BaseModel
from .custom_greeting_answering_rule_info import CustomGreetingAnsweringRuleInfo


class CustomUserGreetingInfoType(Enum):
    """An enumeration representing different categories.

    :cvar INTRODUCTORY: "Introductory"
    :vartype INTRODUCTORY: str
    :cvar ANNOUNCEMENT: "Announcement"
    :vartype ANNOUNCEMENT: str
    :cvar INTERRUPTPROMPT: "InterruptPrompt"
    :vartype INTERRUPTPROMPT: str
    :cvar CONNECTINGAUDIO: "ConnectingAudio"
    :vartype CONNECTINGAUDIO: str
    :cvar CONNECTINGMESSAGE: "ConnectingMessage"
    :vartype CONNECTINGMESSAGE: str
    :cvar VOICEMAIL: "Voicemail"
    :vartype VOICEMAIL: str
    :cvar UNAVAILABLE: "Unavailable"
    :vartype UNAVAILABLE: str
    :cvar HOLDMUSIC: "HoldMusic"
    :vartype HOLDMUSIC: str
    :cvar PRONOUNCEDNAME: "PronouncedName"
    :vartype PRONOUNCEDNAME: str
    :cvar TEMPLATEGREETING: "TemplateGreeting"
    :vartype TEMPLATEGREETING: str
    """

    INTRODUCTORY = "Introductory"
    ANNOUNCEMENT = "Announcement"
    INTERRUPTPROMPT = "InterruptPrompt"
    CONNECTINGAUDIO = "ConnectingAudio"
    CONNECTINGMESSAGE = "ConnectingMessage"
    VOICEMAIL = "Voicemail"
    UNAVAILABLE = "Unavailable"
    HOLDMUSIC = "HoldMusic"
    PRONOUNCEDNAME = "PronouncedName"
    TEMPLATEGREETING = "TemplateGreeting"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(
            map(lambda x: x.value, CustomUserGreetingInfoType._member_map_.values())
        )


class CustomUserGreetingInfoContentType(Enum):
    """An enumeration representing different categories.

    :cvar AUDIO_MPEG: "audio/mpeg"
    :vartype AUDIO_MPEG: str
    :cvar AUDIO_WAV: "audio/wav"
    :vartype AUDIO_WAV: str
    """

    AUDIO_MPEG = "audio/mpeg"
    AUDIO_WAV = "audio/wav"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(
            map(
                lambda x: x.value,
                CustomUserGreetingInfoContentType._member_map_.values(),
            )
        )


@JsonMap(
    {
        "id_": "id",
        "type_": "type",
        "content_type": "contentType",
        "content_uri": "contentUri",
        "answering_rule": "answeringRule",
    }
)
class CustomUserGreetingInfo(BaseModel):
    """CustomUserGreetingInfo

    :param uri: Link to a custom user greeting, defaults to None
    :type uri: str, optional
    :param id_: Internal identifier of a custom user greeting, defaults to None
    :type id_: str, optional
    :param type_: Type of custom user greeting, defaults to None
    :type type_: CustomUserGreetingInfoType, optional
    :param content_type: Content media type, defaults to None
    :type content_type: CustomUserGreetingInfoContentType, optional
    :param content_uri: Link to a greeting content (audio file), defaults to None
    :type content_uri: str, optional
    :param answering_rule: Information on an answering rule that the greeting is applied to, defaults to None
    :type answering_rule: CustomGreetingAnsweringRuleInfo, optional
    """

    def __init__(
        self,
        uri: str = None,
        id_: str = None,
        type_: CustomUserGreetingInfoType = None,
        content_type: CustomUserGreetingInfoContentType = None,
        content_uri: str = None,
        answering_rule: CustomGreetingAnsweringRuleInfo = None,
    ):
        if uri is not None:
            self.uri = uri
        if id_ is not None:
            self.id_ = id_
        if type_ is not None:
            self.type_ = self._enum_matching(
                type_, CustomUserGreetingInfoType.list(), "type_"
            )
        if content_type is not None:
            self.content_type = self._enum_matching(
                content_type, CustomUserGreetingInfoContentType.list(), "content_type"
            )
        if content_uri is not None:
            self.content_uri = content_uri
        if answering_rule is not None:
            self.answering_rule = self._define_object(
                answering_rule, CustomGreetingAnsweringRuleInfo
            )
