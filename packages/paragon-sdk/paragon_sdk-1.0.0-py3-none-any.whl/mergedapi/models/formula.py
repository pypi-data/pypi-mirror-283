# -*- coding: utf-8 -*-

"""
mergedapi

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from mergedapi.api_helper import APIHelper
from mergedapi.models.anomaly_detection import AnomalyDetection
from mergedapi.models.capture_groups import CaptureGroups
from mergedapi.models.concatenate import Concatenate
from mergedapi.models.count import Count
from mergedapi.models.dynamic_threshold import DynamicThreshold
from mergedapi.models.elapsed_time import ElapsedTime
from mergedapi.models.eval import Eval
from mergedapi.models.jaiml_anomaly_detection import JaimlAnomalyDetection
from mergedapi.models.max import Max
from mergedapi.models.mean import Mean
from mergedapi.models.microburst import Microburst
from mergedapi.models.min import Min
from mergedapi.models.outlier_detection import OutlierDetection
from mergedapi.models.predict import Predict
from mergedapi.models.rate_of_change import RateOfChange
from mergedapi.models.stddev import Stddev
from mergedapi.models.sum import Sum
from mergedapi.models.user_defined_function import UserDefinedFunction
from mergedapi.models.value_difference import ValueDifference


class Formula(object):

    """Implementation of the 'Formula' model.

    TODO: type model description here.

    Attributes:
        anomaly_detection (AnomalyDetection): Apply anomaly detection. Learn
            dynamic threshold value over period of time and apply it on value
        count (Count): Find number of occurances
        dynamic_threshold (DynamicThreshold): Apply dynamic threshold. Learn
            dynamic threshold value over period of time and apply it on value
        eval (Eval): Evaluates the expression
        max (Max): Find the max value
        mean (Mean): Find the mean value
        concatenate (Concatenate): String concatenation
        microburst (Microburst): Detect microbursts in the egress queues. This
            has to be used only with qmon sensors
        min (Min): Find the min value
        outlier_detection (OutlierDetection): Apply outlier detection.
        predict (Predict): Learn baseline threshold based on the ML alogrithms
            and predict value in future
        rate_of_change (RateOfChange): Rate of change between present and
            previous value
        elapsed_time (ElapsedTime): Elapsed time between present and previous
            value
        value_difference (ValueDifference): Value difference between present
            and previous value
        stddev (Stddev): Find the standard deviation
        sum (Sum): Find the sum of values
        user_defined_function (UserDefinedFunction): User defined function to
            populate field value
        jaiml_anomaly_detection (JaimlAnomalyDetection): Apply jaiml anomaly
            detection. Call the Jaiml/Columbo api to Learn dynamic threshold
            value over period of time and apply it on value
        capture_groups (CaptureGroups): Capture regex groups from the provided
            field. New fields will be created in the format
            '<curr-field>-<group-name>' if named capture groups are provided

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "anomaly_detection": 'anomaly-detection',
        "count": 'count',
        "dynamic_threshold": 'dynamic-threshold',
        "eval": 'eval',
        "max": 'max',
        "mean": 'mean',
        "concatenate": 'concatenate',
        "microburst": 'microburst',
        "min": 'min',
        "outlier_detection": 'outlier-detection',
        "predict": 'predict',
        "rate_of_change": 'rate-of-change',
        "elapsed_time": 'elapsed-time',
        "value_difference": 'value-difference',
        "stddev": 'stddev',
        "sum": 'sum',
        "user_defined_function": 'user-defined-function',
        "jaiml_anomaly_detection": 'jaiml-anomaly-detection',
        "capture_groups": 'capture-groups'
    }

    _optionals = [
        'anomaly_detection',
        'count',
        'dynamic_threshold',
        'eval',
        'max',
        'mean',
        'concatenate',
        'microburst',
        'min',
        'outlier_detection',
        'predict',
        'rate_of_change',
        'elapsed_time',
        'value_difference',
        'stddev',
        'sum',
        'user_defined_function',
        'jaiml_anomaly_detection',
        'capture_groups',
    ]

    def __init__(self,
                 anomaly_detection=APIHelper.SKIP,
                 count=APIHelper.SKIP,
                 dynamic_threshold=APIHelper.SKIP,
                 eval=APIHelper.SKIP,
                 max=APIHelper.SKIP,
                 mean=APIHelper.SKIP,
                 concatenate=APIHelper.SKIP,
                 microburst=APIHelper.SKIP,
                 min=APIHelper.SKIP,
                 outlier_detection=APIHelper.SKIP,
                 predict=APIHelper.SKIP,
                 rate_of_change=APIHelper.SKIP,
                 elapsed_time=APIHelper.SKIP,
                 value_difference=APIHelper.SKIP,
                 stddev=APIHelper.SKIP,
                 sum=APIHelper.SKIP,
                 user_defined_function=APIHelper.SKIP,
                 jaiml_anomaly_detection=APIHelper.SKIP,
                 capture_groups=APIHelper.SKIP):
        """Constructor for the Formula class"""

        # Initialize members of the class
        if anomaly_detection is not APIHelper.SKIP:
            self.anomaly_detection = anomaly_detection 
        if count is not APIHelper.SKIP:
            self.count = count 
        if dynamic_threshold is not APIHelper.SKIP:
            self.dynamic_threshold = dynamic_threshold 
        if eval is not APIHelper.SKIP:
            self.eval = eval 
        if max is not APIHelper.SKIP:
            self.max = max 
        if mean is not APIHelper.SKIP:
            self.mean = mean 
        if concatenate is not APIHelper.SKIP:
            self.concatenate = concatenate 
        if microburst is not APIHelper.SKIP:
            self.microburst = microburst 
        if min is not APIHelper.SKIP:
            self.min = min 
        if outlier_detection is not APIHelper.SKIP:
            self.outlier_detection = outlier_detection 
        if predict is not APIHelper.SKIP:
            self.predict = predict 
        if rate_of_change is not APIHelper.SKIP:
            self.rate_of_change = rate_of_change 
        if elapsed_time is not APIHelper.SKIP:
            self.elapsed_time = elapsed_time 
        if value_difference is not APIHelper.SKIP:
            self.value_difference = value_difference 
        if stddev is not APIHelper.SKIP:
            self.stddev = stddev 
        if sum is not APIHelper.SKIP:
            self.sum = sum 
        if user_defined_function is not APIHelper.SKIP:
            self.user_defined_function = user_defined_function 
        if jaiml_anomaly_detection is not APIHelper.SKIP:
            self.jaiml_anomaly_detection = jaiml_anomaly_detection 
        if capture_groups is not APIHelper.SKIP:
            self.capture_groups = capture_groups 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """

        if dictionary is None:
            return None

        # Extract variables from the dictionary
        anomaly_detection = AnomalyDetection.from_dictionary(dictionary.get('anomaly-detection')) if 'anomaly-detection' in dictionary.keys() else APIHelper.SKIP
        count = Count.from_dictionary(dictionary.get('count')) if 'count' in dictionary.keys() else APIHelper.SKIP
        dynamic_threshold = DynamicThreshold.from_dictionary(dictionary.get('dynamic-threshold')) if 'dynamic-threshold' in dictionary.keys() else APIHelper.SKIP
        eval = Eval.from_dictionary(dictionary.get('eval')) if 'eval' in dictionary.keys() else APIHelper.SKIP
        max = Max.from_dictionary(dictionary.get('max')) if 'max' in dictionary.keys() else APIHelper.SKIP
        mean = Mean.from_dictionary(dictionary.get('mean')) if 'mean' in dictionary.keys() else APIHelper.SKIP
        concatenate = Concatenate.from_dictionary(dictionary.get('concatenate')) if 'concatenate' in dictionary.keys() else APIHelper.SKIP
        microburst = Microburst.from_dictionary(dictionary.get('microburst')) if 'microburst' in dictionary.keys() else APIHelper.SKIP
        min = Min.from_dictionary(dictionary.get('min')) if 'min' in dictionary.keys() else APIHelper.SKIP
        outlier_detection = OutlierDetection.from_dictionary(dictionary.get('outlier-detection')) if 'outlier-detection' in dictionary.keys() else APIHelper.SKIP
        predict = Predict.from_dictionary(dictionary.get('predict')) if 'predict' in dictionary.keys() else APIHelper.SKIP
        rate_of_change = RateOfChange.from_dictionary(dictionary.get('rate-of-change')) if 'rate-of-change' in dictionary.keys() else APIHelper.SKIP
        elapsed_time = ElapsedTime.from_dictionary(dictionary.get('elapsed-time')) if 'elapsed-time' in dictionary.keys() else APIHelper.SKIP
        value_difference = ValueDifference.from_dictionary(dictionary.get('value-difference')) if 'value-difference' in dictionary.keys() else APIHelper.SKIP
        stddev = Stddev.from_dictionary(dictionary.get('stddev')) if 'stddev' in dictionary.keys() else APIHelper.SKIP
        sum = Sum.from_dictionary(dictionary.get('sum')) if 'sum' in dictionary.keys() else APIHelper.SKIP
        user_defined_function = UserDefinedFunction.from_dictionary(dictionary.get('user-defined-function')) if 'user-defined-function' in dictionary.keys() else APIHelper.SKIP
        jaiml_anomaly_detection = JaimlAnomalyDetection.from_dictionary(dictionary.get('jaiml-anomaly-detection')) if 'jaiml-anomaly-detection' in dictionary.keys() else APIHelper.SKIP
        capture_groups = CaptureGroups.from_dictionary(dictionary.get('capture-groups')) if 'capture-groups' in dictionary.keys() else APIHelper.SKIP
        # Return an object of this model
        return cls(anomaly_detection,
                   count,
                   dynamic_threshold,
                   eval,
                   max,
                   mean,
                   concatenate,
                   microburst,
                   min,
                   outlier_detection,
                   predict,
                   rate_of_change,
                   elapsed_time,
                   value_difference,
                   stddev,
                   sum,
                   user_defined_function,
                   jaiml_anomaly_detection,
                   capture_groups)
