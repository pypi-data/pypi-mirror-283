# -*- coding: utf-8 -*-

"""
mergedapi

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from mergedapi.api_helper import APIHelper
from mergedapi.models.device_aggregation import DeviceAggregation
from mergedapi.models.outer_query import OuterQuery


class Items(object):

    """Implementation of the 'Items' model.

    TODO: type model description here.

    Attributes:
        query_name (str): Name of the query object. Optional. Not used for
            now
        device_group (str): Name of the deviceGroup(s). Multiple device groups
            should be separated by ','. This can be used in combination with
            device, but is not mandatory. If device is given, then query will
            be executed only for that particular devices in the given device
            group, else all devices in group will be considered. Given devices
            will be applicable for all give device-groups.
        device (str): Name of the device. Multiple device should be separated
            by ','. This should be used along with deviceGroup. Without
            deviceGroup, this config will not be considered
        db (str): Name of the database. Multiple databases should be separated
            by ','. '*' can be used to specify all databases.
        topic (str): Name of Healthbot topic. Optional if measurement is used
        rule (str): Name of Healthbot rule. Required if topic is used.
            Optional if measurement is used
        trigger (str): Name of Healthbot trigger. Optional if measurement is
            used or rule table is being queried
        measurement (str): Name of the measurement. Optional if
            topic/rule/trigger is used
        where (str): Where clause filters data based on fields, tags, and/or
            timestamps. Eg: where="interface-name" = 'ge-0/0/1' and "in-pkts"
            > 0
        order (str): Sort points in descending order based on time. By default
            points will be sorted in ascending order. Eg: order=desc
        limit (int): Limit number of points in the result. If groupBy is used
            limit is applied per group. Eg: limit=10
        fields (List[str]): TODO: type description here.
        group_by (List[str]): TODO: type description here.
        outer_queries (List[OuterQuery]): TODO: type description here.
        device_aggregation (DeviceAggregation): TODO: type description here.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "query_name": 'queryName',
        "device_group": 'deviceGroup',
        "device": 'device',
        "db": 'db',
        "topic": 'topic',
        "rule": 'rule',
        "trigger": 'trigger',
        "measurement": 'measurement',
        "where": 'where',
        "order": 'order',
        "limit": 'limit',
        "fields": 'fields',
        "group_by": 'GroupBy',
        "outer_queries": 'outerQueries',
        "device_aggregation": 'deviceAggregation'
    }

    _optionals = [
        'query_name',
        'device_group',
        'device',
        'db',
        'topic',
        'rule',
        'trigger',
        'measurement',
        'where',
        'order',
        'limit',
        'fields',
        'group_by',
        'outer_queries',
        'device_aggregation',
    ]

    def __init__(self,
                 query_name=APIHelper.SKIP,
                 device_group=APIHelper.SKIP,
                 device=APIHelper.SKIP,
                 db=APIHelper.SKIP,
                 topic=APIHelper.SKIP,
                 rule=APIHelper.SKIP,
                 trigger=APIHelper.SKIP,
                 measurement=APIHelper.SKIP,
                 where=APIHelper.SKIP,
                 order=APIHelper.SKIP,
                 limit=APIHelper.SKIP,
                 fields=APIHelper.SKIP,
                 group_by=APIHelper.SKIP,
                 outer_queries=APIHelper.SKIP,
                 device_aggregation=APIHelper.SKIP):
        """Constructor for the Items class"""

        # Initialize members of the class
        if query_name is not APIHelper.SKIP:
            self.query_name = query_name 
        if device_group is not APIHelper.SKIP:
            self.device_group = device_group 
        if device is not APIHelper.SKIP:
            self.device = device 
        if db is not APIHelper.SKIP:
            self.db = db 
        if topic is not APIHelper.SKIP:
            self.topic = topic 
        if rule is not APIHelper.SKIP:
            self.rule = rule 
        if trigger is not APIHelper.SKIP:
            self.trigger = trigger 
        if measurement is not APIHelper.SKIP:
            self.measurement = measurement 
        if where is not APIHelper.SKIP:
            self.where = where 
        if order is not APIHelper.SKIP:
            self.order = order 
        if limit is not APIHelper.SKIP:
            self.limit = limit 
        if fields is not APIHelper.SKIP:
            self.fields = fields 
        if group_by is not APIHelper.SKIP:
            self.group_by = group_by 
        if outer_queries is not APIHelper.SKIP:
            self.outer_queries = outer_queries 
        if device_aggregation is not APIHelper.SKIP:
            self.device_aggregation = device_aggregation 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """

        if dictionary is None:
            return None

        # Extract variables from the dictionary
        query_name = dictionary.get("queryName") if dictionary.get("queryName") else APIHelper.SKIP
        device_group = dictionary.get("deviceGroup") if dictionary.get("deviceGroup") else APIHelper.SKIP
        device = dictionary.get("device") if dictionary.get("device") else APIHelper.SKIP
        db = dictionary.get("db") if dictionary.get("db") else APIHelper.SKIP
        topic = dictionary.get("topic") if dictionary.get("topic") else APIHelper.SKIP
        rule = dictionary.get("rule") if dictionary.get("rule") else APIHelper.SKIP
        trigger = dictionary.get("trigger") if dictionary.get("trigger") else APIHelper.SKIP
        measurement = dictionary.get("measurement") if dictionary.get("measurement") else APIHelper.SKIP
        where = dictionary.get("where") if dictionary.get("where") else APIHelper.SKIP
        order = dictionary.get("order") if dictionary.get("order") else APIHelper.SKIP
        limit = dictionary.get("limit") if dictionary.get("limit") else APIHelper.SKIP
        fields = dictionary.get("fields") if dictionary.get("fields") else APIHelper.SKIP
        group_by = dictionary.get("GroupBy") if dictionary.get("GroupBy") else APIHelper.SKIP
        outer_queries = None
        if dictionary.get('outerQueries') is not None:
            outer_queries = [OuterQuery.from_dictionary(x) for x in dictionary.get('outerQueries')]
        else:
            outer_queries = APIHelper.SKIP
        device_aggregation = DeviceAggregation.from_dictionary(dictionary.get('deviceAggregation')) if 'deviceAggregation' in dictionary.keys() else APIHelper.SKIP
        # Return an object of this model
        return cls(query_name,
                   device_group,
                   device,
                   db,
                   topic,
                   rule,
                   trigger,
                   measurement,
                   where,
                   order,
                   limit,
                   fields,
                   group_by,
                   outer_queries,
                   device_aggregation)
