# -*- coding: utf-8 -*-

"""
mergedapi

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from mergedapi.api_helper import APIHelper
from mergedapi.models.input import Input
from mergedapi.models.output import Output
from mergedapi.models.suspend import Suspend
from mergedapi.models.task_1 import Task1
from mergedapi.models.workflow_1 import Workflow1
from mergedapi.models.workflow_command_schema import WorkflowCommandSchema
from mergedapi.models.workflow_notification_schema import WorkflowNotificationSchema


class Step(object):

    """Implementation of the 'Step' model.

    TODO: type model description here.

    Attributes:
        cli_command (List[WorkflowCommandSchema]): Run CLI command(s)
        executable (List[WorkflowCommandSchema]): Run an arbitrary executable
            file such as bash, python, ruby, etc.
        netconf_command (List[WorkflowCommandSchema]): Run netconf command(s)
        notification (List[WorkflowNotificationSchema]): Send a notification
            message (configured under notification section)
        condition (List[str]): TODO: type description here.
        condition_description (str): Description of the configured conditions
        condition_type (ConditionTypeEnum): Call the step if any of the
            conditions evaluates to true or all of the conditions evaluate to
            true (default any)
        dependencies (List[str]): TODO: type description here.
        description (str): Description about the step being called
        input (List[Input]): Workflow input parameters configuration
        output (List[Output]): Workflow output parameters configuration
        step_name (str): Name of the step being called. Should be of pattern
            [a-zA-Z][a-zA-Z0-9_-]*
        suspend (Suspend): Suspend workflow execution
        task (Task1): Trigger another configured task in this workflow
        workflow (Workflow1): Trigger another configured worlflow

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "step_name": 'step-name',
        "cli_command": 'cli-command',
        "executable": 'executable',
        "netconf_command": 'netconf-command',
        "notification": 'notification',
        "condition": 'condition',
        "condition_description": 'condition-description',
        "condition_type": 'condition-type',
        "dependencies": 'dependencies',
        "description": 'description',
        "input": 'input',
        "output": 'output',
        "suspend": 'suspend',
        "task": 'task',
        "workflow": 'workflow'
    }

    _optionals = [
        'cli_command',
        'executable',
        'netconf_command',
        'notification',
        'condition',
        'condition_description',
        'condition_type',
        'dependencies',
        'description',
        'input',
        'output',
        'suspend',
        'task',
        'workflow',
    ]

    def __init__(self,
                 step_name=None,
                 cli_command=APIHelper.SKIP,
                 executable=APIHelper.SKIP,
                 netconf_command=APIHelper.SKIP,
                 notification=APIHelper.SKIP,
                 condition=APIHelper.SKIP,
                 condition_description=APIHelper.SKIP,
                 condition_type=APIHelper.SKIP,
                 dependencies=APIHelper.SKIP,
                 description=APIHelper.SKIP,
                 input=APIHelper.SKIP,
                 output=APIHelper.SKIP,
                 suspend=APIHelper.SKIP,
                 task=APIHelper.SKIP,
                 workflow=APIHelper.SKIP):
        """Constructor for the Step class"""

        # Initialize members of the class
        if cli_command is not APIHelper.SKIP:
            self.cli_command = cli_command 
        if executable is not APIHelper.SKIP:
            self.executable = executable 
        if netconf_command is not APIHelper.SKIP:
            self.netconf_command = netconf_command 
        if notification is not APIHelper.SKIP:
            self.notification = notification 
        if condition is not APIHelper.SKIP:
            self.condition = condition 
        if condition_description is not APIHelper.SKIP:
            self.condition_description = condition_description 
        if condition_type is not APIHelper.SKIP:
            self.condition_type = condition_type 
        if dependencies is not APIHelper.SKIP:
            self.dependencies = dependencies 
        if description is not APIHelper.SKIP:
            self.description = description 
        if input is not APIHelper.SKIP:
            self.input = input 
        if output is not APIHelper.SKIP:
            self.output = output 
        self.step_name = step_name 
        if suspend is not APIHelper.SKIP:
            self.suspend = suspend 
        if task is not APIHelper.SKIP:
            self.task = task 
        if workflow is not APIHelper.SKIP:
            self.workflow = workflow 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """

        if dictionary is None:
            return None

        # Extract variables from the dictionary
        step_name = dictionary.get("step-name") if dictionary.get("step-name") else None
        cli_command = None
        if dictionary.get('cli-command') is not None:
            cli_command = [WorkflowCommandSchema.from_dictionary(x) for x in dictionary.get('cli-command')]
        else:
            cli_command = APIHelper.SKIP
        executable = None
        if dictionary.get('executable') is not None:
            executable = [WorkflowCommandSchema.from_dictionary(x) for x in dictionary.get('executable')]
        else:
            executable = APIHelper.SKIP
        netconf_command = None
        if dictionary.get('netconf-command') is not None:
            netconf_command = [WorkflowCommandSchema.from_dictionary(x) for x in dictionary.get('netconf-command')]
        else:
            netconf_command = APIHelper.SKIP
        notification = None
        if dictionary.get('notification') is not None:
            notification = [WorkflowNotificationSchema.from_dictionary(x) for x in dictionary.get('notification')]
        else:
            notification = APIHelper.SKIP
        condition = dictionary.get("condition") if dictionary.get("condition") else APIHelper.SKIP
        condition_description = dictionary.get("condition-description") if dictionary.get("condition-description") else APIHelper.SKIP
        condition_type = dictionary.get("condition-type") if dictionary.get("condition-type") else APIHelper.SKIP
        dependencies = dictionary.get("dependencies") if dictionary.get("dependencies") else APIHelper.SKIP
        description = dictionary.get("description") if dictionary.get("description") else APIHelper.SKIP
        input = None
        if dictionary.get('input') is not None:
            input = [Input.from_dictionary(x) for x in dictionary.get('input')]
        else:
            input = APIHelper.SKIP
        output = None
        if dictionary.get('output') is not None:
            output = [Output.from_dictionary(x) for x in dictionary.get('output')]
        else:
            output = APIHelper.SKIP
        suspend = Suspend.from_dictionary(dictionary.get('suspend')) if 'suspend' in dictionary.keys() else APIHelper.SKIP
        task = Task1.from_dictionary(dictionary.get('task')) if 'task' in dictionary.keys() else APIHelper.SKIP
        workflow = Workflow1.from_dictionary(dictionary.get('workflow')) if 'workflow' in dictionary.keys() else APIHelper.SKIP
        # Return an object of this model
        return cls(step_name,
                   cli_command,
                   executable,
                   netconf_command,
                   notification,
                   condition,
                   condition_description,
                   condition_type,
                   dependencies,
                   description,
                   input,
                   output,
                   suspend,
                   task,
                   workflow)
