# -*- coding: utf-8 -*-

"""
mergedapi

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from mergedapi.api_helper import APIHelper
from mergedapi.models.for_every_device import ForEveryDevice
from mergedapi.models.for_every_network_group import ForEveryNetworkGroup
from mergedapi.models.get_dependencies_from_cache import GetDependenciesFromCache
from mergedapi.models.locate_resource import LocateResource
from mergedapi.models.user_defined_function_3 import UserDefinedFunction3
from mergedapi.models.with_capture_group import WithCaptureGroup


class Term1(object):

    """Implementation of the 'Term1' model.

    TODO: type model description here.

    Attributes:
        for_every_device (ForEveryDevice): Loop over all devices
        for_every_network_group (ForEveryNetworkGroup): Loop over all network
            groups
        get_dependencies_from_cache (GetDependenciesFromCache): TODO: type
            description here.
        locate_resource (List[LocateResource]): TODO: type description here.
        next (bool): Continue evaluating next term
        term_name (str): Term name. Should be of pattern
            [a-zA-Z][a-zA-Z0-9-]*
        user_defined_function (UserDefinedFunction3): User defined function to
            populate field value
        with_capture_group (List[WithCaptureGroup]): TODO: type description
            here.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "term_name": 'term-name',
        "for_every_device": 'for-every-device',
        "for_every_network_group": 'for-every-network-group',
        "get_dependencies_from_cache": 'get-dependencies-from-cache',
        "locate_resource": 'locate-resource',
        "next": 'next',
        "user_defined_function": 'user-defined-function',
        "with_capture_group": 'with-capture-group'
    }

    _optionals = [
        'for_every_device',
        'for_every_network_group',
        'get_dependencies_from_cache',
        'locate_resource',
        'next',
        'user_defined_function',
        'with_capture_group',
    ]

    def __init__(self,
                 term_name=None,
                 for_every_device=APIHelper.SKIP,
                 for_every_network_group=APIHelper.SKIP,
                 get_dependencies_from_cache=APIHelper.SKIP,
                 locate_resource=APIHelper.SKIP,
                 next=APIHelper.SKIP,
                 user_defined_function=APIHelper.SKIP,
                 with_capture_group=APIHelper.SKIP):
        """Constructor for the Term1 class"""

        # Initialize members of the class
        if for_every_device is not APIHelper.SKIP:
            self.for_every_device = for_every_device 
        if for_every_network_group is not APIHelper.SKIP:
            self.for_every_network_group = for_every_network_group 
        if get_dependencies_from_cache is not APIHelper.SKIP:
            self.get_dependencies_from_cache = get_dependencies_from_cache 
        if locate_resource is not APIHelper.SKIP:
            self.locate_resource = locate_resource 
        if next is not APIHelper.SKIP:
            self.next = next 
        self.term_name = term_name 
        if user_defined_function is not APIHelper.SKIP:
            self.user_defined_function = user_defined_function 
        if with_capture_group is not APIHelper.SKIP:
            self.with_capture_group = with_capture_group 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """

        if dictionary is None:
            return None

        # Extract variables from the dictionary
        term_name = dictionary.get("term-name") if dictionary.get("term-name") else None
        for_every_device = ForEveryDevice.from_dictionary(dictionary.get('for-every-device')) if 'for-every-device' in dictionary.keys() else APIHelper.SKIP
        for_every_network_group = ForEveryNetworkGroup.from_dictionary(dictionary.get('for-every-network-group')) if 'for-every-network-group' in dictionary.keys() else APIHelper.SKIP
        get_dependencies_from_cache = GetDependenciesFromCache.from_dictionary(dictionary.get('get-dependencies-from-cache')) if 'get-dependencies-from-cache' in dictionary.keys() else APIHelper.SKIP
        locate_resource = None
        if dictionary.get('locate-resource') is not None:
            locate_resource = [LocateResource.from_dictionary(x) for x in dictionary.get('locate-resource')]
        else:
            locate_resource = APIHelper.SKIP
        next = dictionary.get("next") if "next" in dictionary.keys() else APIHelper.SKIP
        user_defined_function = UserDefinedFunction3.from_dictionary(dictionary.get('user-defined-function')) if 'user-defined-function' in dictionary.keys() else APIHelper.SKIP
        with_capture_group = None
        if dictionary.get('with-capture-group') is not None:
            with_capture_group = [WithCaptureGroup.from_dictionary(x) for x in dictionary.get('with-capture-group')]
        else:
            with_capture_group = APIHelper.SKIP
        # Return an object of this model
        return cls(term_name,
                   for_every_device,
                   for_every_network_group,
                   get_dependencies_from_cache,
                   locate_resource,
                   next,
                   user_defined_function,
                   with_capture_group)
