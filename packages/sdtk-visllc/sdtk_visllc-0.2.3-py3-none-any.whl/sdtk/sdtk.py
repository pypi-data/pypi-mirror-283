#    Copyright (C) 2019 Vis LLC - All Rights Reserved
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Lesser General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
#
#
#    Simple Data Toolkit (SDTK) - Source code can be found on SourceForge.net
#

# Generated by Haxe 4.3.2
# coding: utf-8
import sys

import math as python_lib_Math
import math as Math
import inspect as python_lib_Inspect
import sys as python_lib_Sys
import builtins as python_lib_Builtins
import functools as python_lib_Functools
import os as python_lib_Os
import re as python_lib_Re
import subprocess as python_lib_Subprocess
import tempfile as python_lib_Tempfile
import time as python_lib_Time
import traceback as python_lib_Traceback
from datetime import datetime as python_lib_datetime_Datetime
from datetime import timezone as python_lib_datetime_Timezone
from io import BufferedReader as python_lib_io_BufferedReader
from io import BufferedWriter as python_lib_io_BufferedWriter
from io import StringIO as python_lib_io_StringIO
from io import TextIOWrapper as python_lib_io_TextIOWrapper
from socket import socket as python_lib_socket_Socket
from subprocess import Popen as python_lib_subprocess_Popen
import urllib.parse as python_lib_urllib_Parse


class _hx_AnonObject:
    _hx_disable_getattr = False
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)
    def __contains__(self, item):
        return item in self.__dict__
    def __getitem__(self, item):
        return self.__dict__[item]
    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError('field does not exist')
        else:
            return None
    def _hx_hasattr(self,field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False



class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            return self.tag + '(' + (', '.join(str(v) for v in self.params)) + ')'

Enum._hx_class = Enum


class Class: pass


class Date:
    _hx_class_name = "Date"
    __slots__ = ("date", "dateUTC")
    _hx_fields = ["date", "dateUTC"]
    _hx_methods = ["toString"]
    _hx_statics = ["now", "fromTime", "makeLocal", "fromString"]

    def __init__(self,year,month,day,hour,_hx_min,sec):
        self.dateUTC = None
        if (year < python_lib_datetime_Datetime.min.year):
            year = python_lib_datetime_Datetime.min.year
        if (day == 0):
            day = 1
        self.date = Date.makeLocal(python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0))
        self.dateUTC = self.date.astimezone(python_lib_datetime_Timezone.utc)

    def toString(self):
        return self.date.strftime("%Y-%m-%d %H:%M:%S")

    @staticmethod
    def now():
        d = Date(2000,0,1,0,0,0)
        d.date = Date.makeLocal(python_lib_datetime_Datetime.now())
        d.dateUTC = d.date.astimezone(python_lib_datetime_Timezone.utc)
        return d

    @staticmethod
    def fromTime(t):
        d = Date(2000,0,1,0,0,0)
        d.date = Date.makeLocal(python_lib_datetime_Datetime.fromtimestamp((t / 1000.0)))
        d.dateUTC = d.date.astimezone(python_lib_datetime_Timezone.utc)
        return d

    @staticmethod
    def makeLocal(date):
        try:
            return date.astimezone()
        except BaseException as _g:
            None
            tzinfo = python_lib_datetime_Datetime.now(python_lib_datetime_Timezone.utc).astimezone().tzinfo
            return date.replace(**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'tzinfo': tzinfo})))

    @staticmethod
    def fromString(s):
        _g = len(s)
        if (_g == 8):
            k = s.split(":")
            return Date.fromTime((((Std.parseInt((k[0] if 0 < len(k) else None)) * 3600000.) + ((Std.parseInt((k[1] if 1 < len(k) else None)) * 60000.))) + ((Std.parseInt((k[2] if 2 < len(k) else None)) * 1000.))))
        elif (_g == 10):
            k = s.split("-")
            return Date(Std.parseInt((k[0] if 0 < len(k) else None)),(Std.parseInt((k[1] if 1 < len(k) else None)) - 1),Std.parseInt((k[2] if 2 < len(k) else None)),0,0,0)
        elif (_g == 19):
            k = s.split(" ")
            _this = (k[0] if 0 < len(k) else None)
            y = _this.split("-")
            _this = (k[1] if 1 < len(k) else None)
            t = _this.split(":")
            return Date(Std.parseInt((y[0] if 0 < len(y) else None)),(Std.parseInt((y[1] if 1 < len(y) else None)) - 1),Std.parseInt((y[2] if 2 < len(y) else None)),Std.parseInt((t[0] if 0 < len(t) else None)),Std.parseInt((t[1] if 1 < len(t) else None)),Std.parseInt((t[2] if 2 < len(t) else None)))
        else:
            raise haxe_Exception.thrown(("Invalid date format : " + ("null" if s is None else s)))

Date._hx_class = Date


class DateTools:
    _hx_class_name = "DateTools"
    __slots__ = ()
    _hx_statics = ["DAY_SHORT_NAMES", "DAY_NAMES", "MONTH_SHORT_NAMES", "MONTH_NAMES", "__format_get", "__format", "format"]

    @staticmethod
    def _hx___format_get(d,e):
        e1 = e
        if (e1 == "%"):
            return "%"
        elif (e1 == "A"):
            return python_internal_ArrayImpl._get(DateTools.DAY_NAMES, HxOverrides.mod(d.date.isoweekday(), 7))
        elif (e1 == "B"):
            return python_internal_ArrayImpl._get(DateTools.MONTH_NAMES, (d.date.month - 1))
        elif (e1 == "C"):
            x = (d.date.year / 100)
            tmp = None
            try:
                tmp = int(x)
            except BaseException as _g:
                None
                tmp = None
            return StringTools.lpad(Std.string(tmp),"0",2)
        elif (e1 == "D"):
            return DateTools._hx___format(d,"%m/%d/%y")
        elif (e1 == "F"):
            return DateTools._hx___format(d,"%Y-%m-%d")
        elif (e1 == "M"):
            return StringTools.lpad(Std.string(d.date.minute),"0",2)
        elif (e1 == "R"):
            return DateTools._hx___format(d,"%H:%M")
        elif (e1 == "S"):
            return StringTools.lpad(Std.string(d.date.second),"0",2)
        elif (e1 == "T"):
            return DateTools._hx___format(d,"%H:%M:%S")
        elif (e1 == "Y"):
            return Std.string(d.date.year)
        elif (e1 == "a"):
            return python_internal_ArrayImpl._get(DateTools.DAY_SHORT_NAMES, HxOverrides.mod(d.date.isoweekday(), 7))
        elif (e1 == "d"):
            return StringTools.lpad(Std.string(d.date.day),"0",2)
        elif (e1 == "e"):
            return Std.string(d.date.day)
        elif ((e1 == "h") or ((e1 == "b"))):
            return python_internal_ArrayImpl._get(DateTools.MONTH_SHORT_NAMES, (d.date.month - 1))
        elif ((e1 == "k") or ((e1 == "H"))):
            return StringTools.lpad(Std.string(d.date.hour),("0" if ((e == "H")) else " "),2)
        elif ((e1 == "l") or ((e1 == "I"))):
            hour = HxOverrides.mod(d.date.hour, 12)
            return StringTools.lpad(Std.string((12 if ((hour == 0)) else hour)),("0" if ((e == "I")) else " "),2)
        elif (e1 == "m"):
            return StringTools.lpad(Std.string(((d.date.month - 1) + 1)),"0",2)
        elif (e1 == "n"):
            return "\n"
        elif (e1 == "p"):
            if (d.date.hour > 11):
                return "PM"
            else:
                return "AM"
        elif (e1 == "r"):
            return DateTools._hx___format(d,"%I:%M:%S %p")
        elif (e1 == "s"):
            x = ((d.date.timestamp() * 1000) / 1000)
            tmp = None
            try:
                tmp = int(x)
            except BaseException as _g:
                None
                tmp = None
            return Std.string(tmp)
        elif (e1 == "t"):
            return "\t"
        elif (e1 == "u"):
            t = HxOverrides.mod(d.date.isoweekday(), 7)
            if (t == 0):
                return "7"
            else:
                return Std.string(t)
        elif (e1 == "w"):
            return Std.string(HxOverrides.mod(d.date.isoweekday(), 7))
        elif (e1 == "y"):
            return StringTools.lpad(Std.string(HxOverrides.mod(d.date.year, 100)),"0",2)
        else:
            raise haxe_exceptions_NotImplementedException((("Date.format %" + ("null" if e is None else e)) + "- not implemented yet."),None,_hx_AnonObject({'fileName': "DateTools.hx", 'lineNumber': 101, 'className': "DateTools", 'methodName': "__format_get"}))

    @staticmethod
    def _hx___format(d,f):
        r_b = python_lib_io_StringIO()
        p = 0
        while True:
            np = (f.find("%") if ((p is None)) else HxString.indexOfImpl(f,"%",p))
            if (np < 0):
                break
            _hx_len = (np - p)
            r_b.write((HxString.substr(f,p,None) if ((_hx_len is None)) else HxString.substr(f,p,_hx_len)))
            r_b.write(Std.string(DateTools._hx___format_get(d,HxString.substr(f,(np + 1),1))))
            p = (np + 2)
        _hx_len = (len(f) - p)
        r_b.write((HxString.substr(f,p,None) if ((_hx_len is None)) else HxString.substr(f,p,_hx_len)))
        return r_b.getvalue()

    @staticmethod
    def format(d,f):
        return DateTools._hx___format(d,f)
DateTools._hx_class = DateTools


class EReg:
    _hx_class_name = "EReg"
    __slots__ = ("pattern", "matchObj", "_hx_global")
    _hx_fields = ["pattern", "matchObj", "global"]
    _hx_methods = ["split", "replace"]

    def __init__(self,r,opt):
        self.matchObj = None
        self._hx_global = False
        options = 0
        _g = 0
        _g1 = len(opt)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            if (c == 109):
                options = (options | python_lib_Re.M)
            if (c == 105):
                options = (options | python_lib_Re.I)
            if (c == 115):
                options = (options | python_lib_Re.S)
            if (c == 117):
                options = (options | python_lib_Re.U)
            if (c == 103):
                self._hx_global = True
        self.pattern = python_lib_Re.compile(r,options)

    def split(self,s):
        if self._hx_global:
            ret = []
            lastEnd = 0
            x = python_HaxeIterator(python_lib_Re.finditer(self.pattern,s))
            while x.hasNext():
                x1 = x.next()
                x2 = HxString.substring(s,lastEnd,x1.start())
                ret.append(x2)
                lastEnd = x1.end()
            x = HxString.substr(s,lastEnd,None)
            ret.append(x)
            return ret
        else:
            self.matchObj = python_lib_Re.search(self.pattern,s)
            if (self.matchObj is None):
                return [s]
            else:
                return [HxString.substring(s,0,self.matchObj.start()), HxString.substr(s,self.matchObj.end(),None)]

    def replace(self,s,by):
        _this = by.split("$$")
        by = "_hx_#repl#__".join([python_Boot.toString1(x1,'') for x1 in _this])
        def _hx_local_0(x):
            res = by
            g = x.groups()
            _g = 0
            _g1 = len(g)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                gs = g[i]
                if (gs is None):
                    continue
                delimiter = ("$" + HxOverrides.stringOrNull(str((i + 1))))
                _this = (list(res) if ((delimiter == "")) else res.split(delimiter))
                res = gs.join([python_Boot.toString1(x1,'') for x1 in _this])
            _this = res.split("_hx_#repl#__")
            res = "$".join([python_Boot.toString1(x1,'') for x1 in _this])
            return res
        replace = _hx_local_0
        return python_lib_Re.sub(self.pattern,replace,s,(0 if (self._hx_global) else 1))

EReg._hx_class = EReg


class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["field", "setField", "isFunction", "compare"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)

    @staticmethod
    def setField(o,field,value):
        setattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)

    @staticmethod
    def isFunction(f):
        if (not ((python_lib_Inspect.isfunction(f) or python_lib_Inspect.ismethod(f)))):
            return python_Boot.hasField(f,"func_code")
        else:
            return True

    @staticmethod
    def compare(a,b):
        if ((a is None) and ((b is None))):
            return 0
        if (a is None):
            return 1
        elif (b is None):
            return -1
        elif HxOverrides.eq(a,b):
            return 0
        elif (a > b):
            return 1
        else:
            return -1
Reflect._hx_class = Reflect


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["is", "isOfType", "string", "parseInt", "shortenPossibleNumber", "parseFloat"]

    @staticmethod
    def _hx_is(v,t):
        return Std.isOfType(v,t)

    @staticmethod
    def isOfType(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if ((type(t) == type) and (t == Dynamic)):
            return (v is not None)
        isBool = isinstance(v,bool)
        if (((type(t) == type) and (t == Bool)) and isBool):
            return True
        if ((((not isBool) and (not ((type(t) == type) and (t == Bool)))) and ((type(t) == type) and (t == Int))) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and ((type(t) == type) and (t == Int))):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp1 = None
            try:
                tmp1 = int(v)
            except BaseException as _g:
                None
                tmp1 = None
            tmp = (v == tmp1)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        if (((not isBool) and ((type(t) == type) and (t == Float))) and isinstance(v,(float, int))):
            return True
        if ((type(t) == type) and (t == str)):
            return isinstance(v,str)
        isEnumType = ((type(t) == type) and (t == Enum))
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = ((type(t) == type) and (t == Class))
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp = None
        try:
            tmp = isinstance(v,t)
        except BaseException as _g:
            None
            tmp = False
        if tmp:
            return True
        if python_lib_Inspect.isclass(t):
            cls = t
            loop = None
            def _hx_local_1(intf):
                f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f is not None):
                    _g = 0
                    while (_g < len(f)):
                        i = (f[_g] if _g >= 0 and _g < len(f) else None)
                        _g = (_g + 1)
                        if (i == cls):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            result = False
            while (currentClass is not None):
                if loop(currentClass):
                    result = True
                    break
                currentClass = python_Boot.getSuperClass(currentClass)
            return result
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        if (x is None):
            return None
        _hx_len = len(x)
        index = 0
        while (index < _hx_len):
            if (not (x[index] in " \n\r\t\x0B\x0C")):
                break
            index = (index + 1)
        isNegative = None
        if (index < _hx_len):
            sign = x[index]
            if ((sign == "-") or ((sign == "+"))):
                index = (index + 1)
            isNegative = (sign == "-")
        else:
            isNegative = False
        isHexadecimal = None
        if ((index + 1) < _hx_len):
            cur = x[index]
            next = x[(index + 1)]
            isHexadecimal = ((cur == "0") and (((next == "x") or ((next == "X")))))
        else:
            isHexadecimal = False
        if isHexadecimal:
            index = (index + 2)
        cur = index
        if isHexadecimal:
            while (cur < _hx_len):
                if (not (x[cur] in "0123456789abcdefABCDEF")):
                    break
                cur = (cur + 1)
        else:
            while (cur < _hx_len):
                if (not (x[cur] in "0123456789")):
                    break
                cur = (cur + 1)
        firstInvalidIndex = cur
        if (index == firstInvalidIndex):
            return None
        result = int(HxString.substring(x,index,firstInvalidIndex),(16 if isHexadecimal else 10))
        if isNegative:
            return -result
        else:
            return result

    @staticmethod
    def shortenPossibleNumber(x):
        r = ""
        _g = 0
        _g1 = len(x)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            else:
                _g3 = _g2
                if (((((((((((_g3 == 57) or ((_g3 == 56))) or ((_g3 == 55))) or ((_g3 == 54))) or ((_g3 == 53))) or ((_g3 == 52))) or ((_g3 == 51))) or ((_g3 == 50))) or ((_g3 == 49))) or ((_g3 == 48))) or ((_g3 == 46))):
                    r = (("null" if r is None else r) + ("null" if c is None else c))
                else:
                    break
        return r

    @staticmethod
    def parseFloat(x):
        try:
            return float(x)
        except BaseException as _g:
            None
            if (x is not None):
                r1 = Std.shortenPossibleNumber(x)
                if (r1 != x):
                    return Std.parseFloat(r1)
            return Math.NaN
Std._hx_class = Std


class Float: pass


class Int: pass


class Bool: pass


class Dynamic: pass


class StringBuf:
    _hx_class_name = "StringBuf"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["get_length", "toString"]

    def __init__(self):
        self.b = python_lib_io_StringIO()

    def get_length(self):
        pos = self.b.tell()
        self.b.seek(0,2)
        _hx_len = self.b.tell()
        self.b.seek(pos,0)
        return _hx_len

    def toString(self):
        return self.b.getvalue()

StringBuf._hx_class = StringBuf


class StringTools:
    _hx_class_name = "StringTools"
    __slots__ = ()
    _hx_statics = ["htmlEscape", "isSpace", "ltrim", "rtrim", "trim", "lpad", "replace"]

    @staticmethod
    def htmlEscape(s,quotes = None):
        buf_b = python_lib_io_StringIO()
        _g_offset = 0
        _g_s = s
        while (_g_offset < len(_g_s)):
            index = _g_offset
            _g_offset = (_g_offset + 1)
            code = ord(_g_s[index])
            code1 = code
            if (code1 == 34):
                if quotes:
                    buf_b.write("&quot;")
                else:
                    buf_b.write("".join(map(chr,[code])))
            elif (code1 == 38):
                buf_b.write("&amp;")
            elif (code1 == 39):
                if quotes:
                    buf_b.write("&#039;")
                else:
                    buf_b.write("".join(map(chr,[code])))
            elif (code1 == 60):
                buf_b.write("&lt;")
            elif (code1 == 62):
                buf_b.write("&gt;")
            else:
                buf_b.write("".join(map(chr,[code])))
        return buf_b.getvalue()

    @staticmethod
    def isSpace(s,pos):
        if (((len(s) == 0) or ((pos < 0))) or ((pos >= len(s)))):
            return False
        c = HxString.charCodeAt(s,pos)
        if (not (((c > 8) and ((c < 14))))):
            return (c == 32)
        else:
            return True

    @staticmethod
    def ltrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,r)):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,r,(l - r))
        else:
            return s

    @staticmethod
    def rtrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,((l - r) - 1))):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,0,(l - r))
        else:
            return s

    @staticmethod
    def trim(s):
        return StringTools.ltrim(StringTools.rtrim(s))

    @staticmethod
    def lpad(s,c,l):
        if (len(c) <= 0):
            return s
        buf = StringBuf()
        l = (l - len(s))
        while (buf.get_length() < l):
            s1 = Std.string(c)
            buf.b.write(s1)
        s1 = Std.string(s)
        buf.b.write(s1)
        return buf.b.getvalue()

    @staticmethod
    def replace(s,sub,by):
        _this = (list(s) if ((sub == "")) else s.split(sub))
        return by.join([python_Boot.toString1(x1,'') for x1 in _this])
StringTools._hx_class = StringTools


class sys_FileSystem:
    _hx_class_name = "sys.FileSystem"
    __slots__ = ()
    _hx_statics = ["deleteFile"]

    @staticmethod
    def deleteFile(path):
        python_lib_Os.remove(path)
sys_FileSystem._hx_class = sys_FileSystem


class Sys:
    _hx_class_name = "Sys"
    __slots__ = ()
    _hx_statics = ["args", "getEnv", "environment", "getCwd", "setCwd", "systemName"]

    @staticmethod
    def args():
        argv = python_lib_Sys.argv
        return argv[1:None]

    @staticmethod
    def getEnv(s):
        return python_lib_Os.environ.get(s,None)

    @staticmethod
    def environment():
        environ = haxe_ds_StringMap()
        env = python_lib_Os.environ
        key = python_HaxeIterator(iter(env.keys()))
        while key.hasNext():
            key1 = key.next()
            value = env.get(key1,None)
            environ.h[key1] = value
        return environ

    @staticmethod
    def getCwd():
        return haxe_io_Path.addTrailingSlash(python_lib_Os.getcwd())

    @staticmethod
    def setCwd(s):
        python_lib_Os.chdir(s)

    @staticmethod
    def systemName():
        _g = python_lib_Sys.platform
        x = _g
        if x.startswith("linux"):
            return "Linux"
        else:
            _g1 = _g
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 5):
                if (_g1 == "win32"):
                    return "Windows"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g1 == "cygwin"):
                    return "Windows"
                elif (_g1 == "darwin"):
                    return "Mac"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            else:
                raise haxe_Exception.thrown("not supported platform")
Sys._hx_class = Sys

class ValueType(Enum):
    __slots__ = ()
    _hx_class_name = "ValueType"
    _hx_constructs = ["TNull", "TInt", "TFloat", "TBool", "TObject", "TFunction", "TClass", "TEnum", "TUnknown"]

    @staticmethod
    def TClass(c):
        return ValueType("TClass", 6, (c,))

    @staticmethod
    def TEnum(e):
        return ValueType("TEnum", 7, (e,))
ValueType.TNull = ValueType("TNull", 0, ())
ValueType.TInt = ValueType("TInt", 1, ())
ValueType.TFloat = ValueType("TFloat", 2, ())
ValueType.TBool = ValueType("TBool", 3, ())
ValueType.TObject = ValueType("TObject", 4, ())
ValueType.TFunction = ValueType("TFunction", 5, ())
ValueType.TUnknown = ValueType("TUnknown", 8, ())
ValueType._hx_class = ValueType


class Type:
    _hx_class_name = "Type"
    __slots__ = ()
    _hx_statics = ["getClass", "getClassName", "typeof"]

    @staticmethod
    def getClass(o):
        if (o is None):
            return None
        o1 = o
        if ((o1 is not None) and ((HxOverrides.eq(o1,str) or python_lib_Inspect.isclass(o1)))):
            return None
        if isinstance(o,_hx_AnonObject):
            return None
        if hasattr(o,"_hx_class"):
            return o._hx_class
        if hasattr(o,"__class__"):
            return o.__class__
        else:
            return None

    @staticmethod
    def getClassName(c):
        if hasattr(c,"_hx_class_name"):
            return c._hx_class_name
        else:
            if (c == list):
                return "Array"
            if (c == Math):
                return "Math"
            if (c == str):
                return "String"
            try:
                return c.__name__
            except BaseException as _g:
                None
                return None

    @staticmethod
    def typeof(v):
        if (v is None):
            return ValueType.TNull
        elif isinstance(v,bool):
            return ValueType.TBool
        elif isinstance(v,int):
            return ValueType.TInt
        elif isinstance(v,float):
            return ValueType.TFloat
        elif isinstance(v,str):
            return ValueType.TClass(str)
        elif isinstance(v,list):
            return ValueType.TClass(list)
        elif (isinstance(v,_hx_AnonObject) or python_lib_Inspect.isclass(v)):
            return ValueType.TObject
        elif isinstance(v,Enum):
            return ValueType.TEnum(v.__class__)
        elif (isinstance(v,type) or hasattr(v,"_hx_class")):
            return ValueType.TClass(v.__class__)
        elif callable(v):
            return ValueType.TFunction
        else:
            return ValueType.TUnknown
Type._hx_class = Type


class _Xml_XmlType_Impl_:
    _hx_class_name = "_Xml.XmlType_Impl_"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(this1):
        _g = this1
        if (_g == 0):
            return "Element"
        elif (_g == 1):
            return "PCData"
        elif (_g == 2):
            return "CData"
        elif (_g == 3):
            return "Comment"
        elif (_g == 4):
            return "DocType"
        elif (_g == 5):
            return "ProcessingInstruction"
        elif (_g == 6):
            return "Document"
        else:
            pass
_Xml_XmlType_Impl_._hx_class = _Xml_XmlType_Impl_


class Xml:
    _hx_class_name = "Xml"
    __slots__ = ("nodeType", "nodeName", "nodeValue", "parent", "children", "attributeMap")
    _hx_fields = ["nodeType", "nodeName", "nodeValue", "parent", "children", "attributeMap"]
    _hx_methods = ["get", "set", "exists", "attributes", "elementsNamed", "firstElement", "addChild", "removeChild", "toString"]
    _hx_statics = ["Element", "PCData", "CData", "Comment", "DocType", "ProcessingInstruction", "Document", "parse", "createElement", "createPCData", "createCData", "createComment", "createDocType", "createProcessingInstruction", "createDocument"]

    def __init__(self,nodeType):
        self.parent = None
        self.nodeValue = None
        self.nodeName = None
        self.nodeType = nodeType
        self.children = []
        self.attributeMap = haxe_ds_StringMap()

    def get(self,att):
        if (self.nodeType != Xml.Element):
            raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        return self.attributeMap.h.get(att,None)

    def set(self,att,value):
        if (self.nodeType != Xml.Element):
            raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        self.attributeMap.h[att] = value

    def exists(self,att):
        if (self.nodeType != Xml.Element):
            raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        return (att in self.attributeMap.h)

    def attributes(self):
        if (self.nodeType != Xml.Element):
            raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        return self.attributeMap.keys()

    def elementsNamed(self,name):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        _g = []
        _g1 = 0
        _g2 = self.children
        while (_g1 < len(_g2)):
            child = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            tmp = None
            if (child.nodeType == Xml.Element):
                if (child.nodeType != Xml.Element):
                    raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((child.nodeType is None)) else _Xml_XmlType_Impl_.toString(child.nodeType))))))
                tmp = (child.nodeName == name)
            else:
                tmp = False
            if tmp:
                _g.append(child)
        ret = _g
        return haxe_iterators_ArrayIterator(ret)

    def firstElement(self):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            child = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (child.nodeType == Xml.Element):
                return child
        return None

    def addChild(self,x):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        if (x.parent is not None):
            x.parent.removeChild(x)
        _this = self.children
        _this.append(x)
        x.parent = self

    def removeChild(self,x):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        if python_internal_ArrayImpl.remove(self.children,x):
            x.parent = None
            return True
        return False

    def toString(self):
        return haxe_xml_Printer.print(self)

    @staticmethod
    def parse(_hx_str):
        return haxe_xml_Parser.parse(_hx_str)

    @staticmethod
    def createElement(name):
        xml = Xml(Xml.Element)
        if (xml.nodeType != Xml.Element):
            raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((xml.nodeType is None)) else _Xml_XmlType_Impl_.toString(xml.nodeType))))))
        xml.nodeName = name
        return xml

    @staticmethod
    def createPCData(data):
        xml = Xml(Xml.PCData)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((xml.nodeType is None)) else _Xml_XmlType_Impl_.toString(xml.nodeType))))))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createCData(data):
        xml = Xml(Xml.CData)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((xml.nodeType is None)) else _Xml_XmlType_Impl_.toString(xml.nodeType))))))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createComment(data):
        xml = Xml(Xml.Comment)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((xml.nodeType is None)) else _Xml_XmlType_Impl_.toString(xml.nodeType))))))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createDocType(data):
        xml = Xml(Xml.DocType)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((xml.nodeType is None)) else _Xml_XmlType_Impl_.toString(xml.nodeType))))))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createProcessingInstruction(data):
        xml = Xml(Xml.ProcessingInstruction)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((xml.nodeType is None)) else _Xml_XmlType_Impl_.toString(xml.nodeType))))))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createDocument():
        return Xml(Xml.Document)

Xml._hx_class = Xml


class com_sdtk_api_API:

    def __init__(self,name):
        self._inited = None
        self._progress = None
        self._name = name

    def name(self):
        return self._name

    def mappingValueToType(self,value):
        try:
            return com_sdtk_std_Normalize.parseJson(value)
        except BaseException as _g:
            None
            return value

    def fetch(self,method,root,api,key,accessToken,query,body,callback,headers = None,cookies = None):
        if (query is None):
            query = ""
        if (key is None):
            key = (self.getKey() is not None)
        if (accessToken is None):
            accessToken = ((self.getAccessToken() is not None) and ((self.getAuthorizationHeader() is not None)))
        cookieToSend = None
        if (cookies is not None):
            cookieToSend = StringBuf()
            c = cookies.keys()
            while c.hasNext():
                c1 = c.next()
                s = Std.string(c1)
                cookieToSend.b.write(s)
                cookieToSend.b.write("=")
                s1 = Std.string(cookies.h.get(c1,None))
                cookieToSend.b.write(s1)
                cookieToSend.b.write("; ")
        url = ((((("https://" + ("null" if root is None else root)) + "/") + ("null" if api is None else api)) + ("null" if query is None else query)) + HxOverrides.stringOrNull((((((HxOverrides.stringOrNull((("?" if ((query == "")) else "&"))) + HxOverrides.stringOrNull(self.getKeyParameter())) + "=") + HxOverrides.stringOrNull(self.getKey())) if key else ""))))
        import urllib.request
        import urllib.parse
        import ssl
        h = {}
        h["User-Agent"] = "SimpleData-Toolkit"
        if accessToken:
            h[self.getAuthorizationHeader()] = (HxOverrides.stringOrNull(self.getAuthorizationHeaderBearer()) + HxOverrides.stringOrNull(self.getAccessToken()))
        if (self.getUserHeader() is not None):
            Reflect.field(h,"set")(self.getUserHeader(),self.getUser())
        tmp = None
        if (body is not None):
            startIndex = None
            tmp = (((body.find("--divider--sdtk--") if ((startIndex is None)) else HxString.indexOfImpl(body,"--divider--sdtk--",startIndex))) >= 0)
        else:
            tmp = False
        if tmp:
            h["Content-Type"] = "multipart/related; boundary=--divider--sdtk--"
        if (body is not None):
            body = body.encode('utf-8')
        if (headers is not None):
            header = headers.keys()
            while header.hasNext():
                header1 = header.next()
                h[header1] = headers.h.get(header1,None)
        if (cookieToSend is not None):
            h["Cookie"] = cookieToSend.b.getvalue()
        context = ssl._create_unverified_context()
        if (((self.getUser() is not None) and ((self.getUserHeader() is None))) and ((self.getAccessToken() is not None))):
            passwordManager = urllib.request.HTTPPasswordMgrWithDefaultRealm()
            passwordManager.add_password(None, url, self.getUser(), self.getAccessToken())
            authHandler = urllib.request.HTTPBasicAuthHandler(passwordManager)
            opener = urllib.request.build_opener(authHandler)
            urllib.request.install_opener(opener)
        r = urllib.request.urlopen(urllib.request.Request(url, method=method, data=body, headers=h), context=context)
        d = r.read()
        encoding = r.info().get_content_charset('utf-8')
        d = d.decode(encoding)
        callback(d)

    def processIfNeeded(self,value):
        tmp = None
        if ((("" if ((0 >= len(value))) else value[0])) == "<"):
            index = (len(value) - 1)
            tmp = ((("" if (((index < 0) or ((index >= len(value))))) else value[index])) == ">")
        else:
            tmp = False
        if (tmp and ((value.upper() == value))):
            value2 = None
            try:
                value2 = Sys.getEnv(HxString.substr(value,1,(len(value) - 2)))
            except BaseException as _g:
                None
            if ((value2 is None) or ((value2 == ""))):
                return value
            else:
                return value2
        else:
            return value

    def normalizeMapping(self,mapping):
        return com_sdtk_std_Normalize.haxeMapValuesToStrings(com_sdtk_std_Normalize.nativeToHaxe(mapping))

    def getUserHeader(self):
        return None

    def getUser(self):
        return None

    def getAuthorizationHeader(self):
        return "Authorization"

    def getAuthorizationHeaderBearer(self):
        return "Bearer "

    def getKeyParameter(self):
        return "key"

    def getKey(self):
        return None

    def getAccessToken(self):
        return None

    def waitForObjects(self,callback):
        pass

    def load(self,file,callback,waitFor = None):
        if (self._progress is None):
            self._progress = com_sdtk_api_APILoadProgress()
        _this = self._progress._files
        _this.append(file)
        if (waitFor is not None):
            tmp = (self._progress._objects + waitFor)
            self._progress._objects = tmp

    def requireAPI(self,api,callback):
        api.requireInit(callback)

    def startInit(self,callback):
        callback()

    def requireInit(self,callback):
        _gthis = self
        if self._inited:
            callback()
        else:
            def _hx_local_0():
                _gthis._progress = None
                _gthis._inited = True
                callback()
            self.startInit(_hx_local_0)

    def parse(self,value):
        return None

    def findElementsByClass(self,data,tags,c,includeTagInResults = None,includeBodyInResults = None):
        if (includeTagInResults is None):
            includeTagInResults = False
        if (includeBodyInResults is None):
            includeBodyInResults = True
        check = list()
        results = list()
        _g = 0
        while (_g < len(tags)):
            tag = (tags[_g] if _g >= 0 and _g < len(tags) else None)
            _g = (_g + 1)
            i = 0
            while True:
                _hx_str = ("<" + ("null" if tag is None else tag))
                i = (data.find(_hx_str) if ((i is None)) else HxString.indexOfImpl(data,_hx_str,i))
                if (i < 0):
                    break
                check.append(i)
                i = (i + 1)
        _g = 0
        while (_g < len(check)):
            tagToCheck = (check[_g] if _g >= 0 and _g < len(check) else None)
            _g = (_g + 1)
            myTag = HxString.substring(data,(tagToCheck + 1),(com_sdtk_api_API.findEndOfTag(data,tagToCheck) + 1))
            endOfTag = (data.find(">") if ((tagToCheck is None)) else HxString.indexOfImpl(data,">",tagToCheck))
            if (c is not None):
                startOfClass = (data.find("class=") if ((tagToCheck is None)) else HxString.indexOfImpl(data,"class=",tagToCheck))
                if ((startOfClass < 0) or ((startOfClass > endOfTag))):
                    continue
                startIndex = (startOfClass + 7)
                endOfClass = (data.find("\"") if ((startIndex is None)) else HxString.indexOfImpl(data,"\"",startIndex))
                startIndex1 = (startOfClass + 7)
                endOfClass2 = (data.find("'") if ((startIndex1 is None)) else HxString.indexOfImpl(data,"'",startIndex1))
                if ((endOfClass2 >= 0) and ((endOfClass2 < endOfClass))):
                    endOfClass = endOfClass2
                if ((endOfClass < 0) or ((endOfClass > endOfTag))):
                    continue
                startIndex2 = (startOfClass + 7)
                indexOfC = (data.find(c) if ((startIndex2 is None)) else HxString.indexOfImpl(data,c,startIndex2))
                if ((indexOfC < 0) or ((indexOfC > endOfClass))):
                    continue
                index = (indexOfC - 1)
                beforeClass = ("" if (((index < 0) or ((index >= len(data))))) else data[index])
                index1 = (indexOfC + len(c))
                afterClass = ("" if (((index1 < 0) or ((index1 >= len(data))))) else data[index1])
                beforeClass1 = beforeClass
                if ((((beforeClass1 == "'") or ((beforeClass1 == "\""))) or ((beforeClass1 == " "))) or ((beforeClass1 == "\t"))):
                    pass
                else:
                    continue
                afterClass1 = afterClass
                if (((((afterClass1 == "=") or ((afterClass1 == "'"))) or ((afterClass1 == "\""))) or ((afterClass1 == " "))) or ((afterClass1 == "\t"))):
                    pass
                else:
                    continue
            _hx_str = (("</" + ("null" if myTag is None else myTag)) + ">")
            endOfData = (data.find(_hx_str) if ((endOfTag is None)) else HxString.indexOfImpl(data,_hx_str,endOfTag))
            nestedSearch = endOfTag
            while (endOfData >= 0):
                str1 = ("<" + ("null" if myTag is None else myTag))
                nested = (data.find(str1) if ((nestedSearch is None)) else HxString.indexOfImpl(data,str1,nestedSearch))
                if ((nested > 0) and ((endOfData > nested))):
                    nestedSearch = ((nested + len(myTag)) + 2)
                    str2 = ("</" + ("null" if myTag is None else myTag))
                    startIndex3 = (endOfData + 1)
                    possibleEnd = (data.find(str2) if ((startIndex3 is None)) else HxString.indexOfImpl(data,str2,startIndex3))
                    if (possibleEnd > 0):
                        endOfData = possibleEnd
                else:
                    if includeTagInResults:
                        x = HxString.substring(data,tagToCheck,endOfTag)
                        results.append(x)
                    if includeBodyInResults:
                        x1 = HxString.substring(data,(endOfTag + 1),endOfData)
                        results.append(x1)
                    break
        return results

    @staticmethod
    def findEndOfTag(data,tag):
        check = list()
        def _hx_local_0(c):
            r = (data.find(c) if ((tag is None)) else HxString.indexOfImpl(data,c,tag))
            if (r >= 0):
                check.append(r)
        search = _hx_local_0
        search(">")
        search(" ")
        search("\t")
        search("\n")
        search("\r")
        def _hx_local_1(a,b):
            return (a - b)
        check.sort(key= python_lib_Functools.cmp_to_key(_hx_local_1))
        return ((check[0] if 0 < len(check) else None) - 1)


class com_sdtk_api_ACMAPI(com_sdtk_api_API):

    def __init__(self):
        super().__init__("ACM")
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_ACMAPI._instance is None):
            com_sdtk_api_ACMAPI._instance = com_sdtk_api_ACMAPI()
        return com_sdtk_api_ACMAPI._instance

    @staticmethod
    def events(callback,start):
        if (start is None):
            start = Date.now()
        tmp = com_sdtk_api_ACMAPI.instance()
        tmp1 = com_sdtk_api_ACMAPI._acmRoot
        tmp2 = com_sdtk_api_ACMAPI._eventsAPI
        _this = start.toString()
        _this1 = python_internal_ArrayImpl._get(_this.split(" "), 0)
        _this = _this1.split("-")
        def _hx_local_0(r):
            o = com_sdtk_std_Normalize.parseJson(r)
            callback(o)
        tmp.fetch("GET",tmp1,tmp2,None,None,(("?startDate0=" + HxOverrides.stringOrNull("".join([python_Boot.toString1(x1,'') for x1 in _this]))) + "&eventType0=Conferences&view0=month"),None,_hx_local_0)

    @staticmethod
    def eventsAPI():
        return com_sdtk_api_ACMAPIEvents.instance()


class com_sdtk_api_InputAPI(com_sdtk_api_API):

    def __init__(self,name):
        super().__init__(name)

    def isFormat(self):
        return False

    def getInputNames(self):
        return None

    def scriptable(self):
        return False

    def retrieveData(self,mapping,callback):
        callback(None,None)

    def parseData(self,data,mapping,callback):
        callback(None,None)

    def externalKey(self):
        return None

    def externalValue(self):
        return None

    def wrapWithMapping(self,mapping):
        return com_sdtk_api_InputAPIWrapper(self,mapping)


class com_sdtk_api_ACMAPIEvents(com_sdtk_api_InputAPI):

    def __init__(self):
        super().__init__("Cloud - ACM - Events")

    def getInputNames(self):
        return ["start"]

    def retrieveData(self,mapping,callback):
        _gthis = self
        mapping = self.normalizeMapping(mapping)
        start = None
        if ((mapping.h.get("start",None) is not None) and ((mapping.h.get("start",None) != ""))):
            start = Date.fromString(mapping.h.get("start",None))
        else:
            start = Date.now()
        start = Date(Date.now().date.year,(Date.now().date.month - 1),1,0,0,0)
        _this = start.toString()
        v = python_internal_ArrayImpl._get(_this.split(" "), 0)
        mapping.h["start"] = v
        def _hx_local_0(r):
            _gthis.parseData(r,mapping,callback)
        com_sdtk_api_ACMAPI.events(_hx_local_0,start)

    def parseData(self,data,mapping,callback):
        _hx_map = list()
        days = self.findElementsByClass(data,["li"],"day")
        currentDate = None
        if (mapping.h.get("start",None) is not None):
            currentDate = Date.fromString(mapping.h.get("start",None))
        else:
            currentDate = Date.now()
        year = currentDate.date.year
        month = (currentDate.date.month - 1)
        _g = 0
        while (_g < len(days)):
            day = (days[_g] if _g >= 0 and _g < len(days) else None)
            _g = (_g + 1)
            currentDay = StringTools.trim(python_internal_ArrayImpl._get(self.findElementsByClass(day,["div"],"date"), 0))
            events = self.findElementsByClass(day,["div"],"event")
            currentDate = Date(year,month,Std.parseInt(currentDay),0,0,0)
            _this = currentDate.toString()
            currentDateAsString = python_internal_ArrayImpl._get(_this.split(" "), 0)
            _g1 = 0
            while (_g1 < len(events)):
                event = (events[_g1] if _g1 >= 0 and _g1 < len(events) else None)
                _g1 = (_g1 + 1)
                eventMap = haxe_ds_StringMap()
                eventMap.h["date"] = currentDateAsString
                value = StringTools.trim(python_internal_ArrayImpl._get(self.findElementsByClass(event,["div"],"event-time"), 0))
                eventMap.h["event-time"] = value
                desc = StringTools.trim(python_internal_ArrayImpl._get(self.findElementsByClass(event,["div"],"event-desc"), 0))
                value1 = StringTools.trim(python_internal_ArrayImpl._get(self.findElementsByClass(event,["a"],None), 0))
                eventMap.h["title"] = value1
                startIndex = None
                linkStart = (((desc.find("href=\"") if ((startIndex is None)) else HxString.indexOfImpl(desc,"href=\"",startIndex))) + 6)
                linkEnd = (desc.find("\"") if ((linkStart is None)) else HxString.indexOfImpl(desc,"\"",linkStart))
                value2 = HxString.substring(desc,linkStart,linkEnd)
                eventMap.h["link"] = value2
                _hx_map.append(eventMap)
        callback(data,com_sdtk_table_ArrayOfMapsReader.readWholeArray(_hx_map))
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_ACMAPIEvents._instance is None):
            com_sdtk_api_ACMAPIEvents._instance = com_sdtk_api_ACMAPIEvents()
        return com_sdtk_api_ACMAPIEvents._instance


class com_sdtk_api_APILoadProgress:

    def __init__(self):
        self._done = 0
        self._files = list()
        self._objects = list()


class com_sdtk_api_APIList:

    @staticmethod
    def apis():
        if (com_sdtk_api_APIList._apis is None):
            com_sdtk_api_APIList._apis = [com_sdtk_api_GitAPI.instance(), com_sdtk_api_BitTorrentAPI.instance(), com_sdtk_api_BTCAPI.instance(), com_sdtk_api_EtherscanAPI.instance(), com_sdtk_api_TortoiseTTSAPI.instance(), com_sdtk_api_ChatGPTAPI.instance(), com_sdtk_api_TableauAPI.instance()]
        return com_sdtk_api_APIList._apis

    @staticmethod
    def executors():
        if (com_sdtk_api_APIList._executors is None):
            com_sdtk_api_APIList._executors = [com_sdtk_api_ChatGPTAPI.queryAsReaderWithDataAPI()]
        return com_sdtk_api_APIList._executors

    @staticmethod
    def inputs():
        if (com_sdtk_api_APIList._inputs is None):
            com_sdtk_api_APIList._inputs = [com_sdtk_api_GitAPI.filesAPI(), com_sdtk_api_GitAPI.reposAPI(), com_sdtk_api_GitAPI.branchesAPI(), com_sdtk_api_GitAPI.commitsAPI(), com_sdtk_api_GitAPI.retrieveAPI(), com_sdtk_api_OrtingoAPI.postsAPI(), com_sdtk_api_OrtingoAPI.suggestionsAPI(), com_sdtk_api_OrtingoAPI.commentsAPI(), com_sdtk_api_BitTorrentAPI.transactionsAPI(), com_sdtk_api_BitTorrentAPI.transfersAPI(), com_sdtk_api_BTCAPI.transactionsAPI(), com_sdtk_api_ChatGPTAPI.queryAsReaderAPI(), com_sdtk_api_EtherscanAPI.transactionsAPI(), com_sdtk_api_ACMAPI.eventsAPI(), com_sdtk_api_IEEEAPI.eventsAPI(), com_sdtk_api_TableauAPI.pullAPI(), com_sdtk_api_SSRSAPI.pullAPI()]
        return com_sdtk_api_APIList._inputs

    @staticmethod
    def writers():
        if (com_sdtk_api_APIList._writers is None):
            com_sdtk_api_APIList._writers = []
        return com_sdtk_api_APIList._writers

    @staticmethod
    def apisByName():
        if (com_sdtk_api_APIList._apisByName is None):
            com_sdtk_api_APIList._apisByName = com_sdtk_api_APIList.byName(com_sdtk_api_APIList.apis())
        return com_sdtk_api_APIList._apisByName

    @staticmethod
    def executorsByName():
        if (com_sdtk_api_APIList._executorsByName is None):
            com_sdtk_api_APIList._executorsByName = com_sdtk_api_APIList.byName(com_sdtk_api_APIList.executors())
        return com_sdtk_api_APIList._executorsByName

    @staticmethod
    def inputsByName():
        if (com_sdtk_api_APIList._inputsByName is None):
            com_sdtk_api_APIList._inputsByName = com_sdtk_api_APIList.byName(com_sdtk_api_APIList.inputs())
        return com_sdtk_api_APIList._inputsByName

    @staticmethod
    def writersByName():
        if (com_sdtk_api_APIList._writersByName is None):
            com_sdtk_api_APIList._writersByName = com_sdtk_api_APIList.byName(com_sdtk_api_APIList.writers())
        return com_sdtk_api_APIList._writersByName

    @staticmethod
    def byName(arr):
        _hx_map = haxe_ds_StringMap()
        _g = 0
        while (_g < len(arr)):
            o = (arr[_g] if _g >= 0 and _g < len(arr) else None)
            _g = (_g + 1)
            k = Reflect.field(o,"name")()
            v = o
            _hx_map.h[k] = v
        return _hx_map


class com_sdtk_api_BTCAPI(com_sdtk_api_API):

    def __init__(self):
        super().__init__("BTC")
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_BTCAPI._instance is None):
            com_sdtk_api_BTCAPI._instance = com_sdtk_api_BTCAPI()
        return com_sdtk_api_BTCAPI._instance

    @staticmethod
    def transactions(callback,block,address,page):
        api = None
        value = None
        if ((address is None) or ((len(address) <= 0))):
            api = com_sdtk_api_BTCAPI._blockAPI
            if (block is None):
                block = com_sdtk_api_BTCAPI._latest
            value = block
        else:
            api = com_sdtk_api_BTCAPI._addressAPI
            value = address
        if (page is None):
            page = 1
            arr = list()
            progress = None
            def _hx_local_1(r):
                r = com_sdtk_std_Normalize.parseJson(r)
                arr.append(r)
                if (Reflect.field(Reflect.field(r,"data"),"page") < Reflect.field(Reflect.field(r,"data"),"page_total")):
                    com_sdtk_api_BTCAPI.transactions(progress,block,address,python_Boot._add_dynamic(Reflect.field(Reflect.field(r,"data"),"page"),1))
                else:
                    r = (arr[0] if 0 < len(arr) else None)
                    i = 1
                    while (i < len(arr)):
                        Reflect.setField(Reflect.field(r,"data"),"list",Reflect.field(Reflect.field(Reflect.field(r,"data"),"list"),"concat")(Reflect.field(Reflect.field((arr[i] if i >= 0 and i < len(arr) else None),"data"),"list")))
                        i = (i + 1)
                    callback(haxe_format_JsonPrinter.print(r,None,None))
            progress = _hx_local_1
            com_sdtk_api_BTCAPI.transactions(progress,block,address,page)
        else:
            def _hx_local_2(r):
                o = com_sdtk_std_Normalize.parseJson(r)
                callback(r)
            com_sdtk_api_BTCAPI.instance().fetch("GET",com_sdtk_api_BTCAPI._btcRoot,api,None,None,((((("null" if value is None else value) + HxOverrides.stringOrNull(com_sdtk_api_BTCAPI._transactions)) + HxOverrides.stringOrNull(com_sdtk_api_BTCAPI._pagesize)) + "&page=") + Std.string(page)),None,_hx_local_2)

    @staticmethod
    def transactionsAPI():
        return com_sdtk_api_BTCAPITransactions.instance()


class com_sdtk_api_BTCAPITransactions(com_sdtk_api_InputAPI):

    def __init__(self):
        super().__init__("Blockchain - Bitcoin - BTC - Transactions")

    def getInputNames(self):
        return ["address", "block"]

    def retrieveData(self,mapping,callback):
        _gthis = self
        mapping = self.normalizeMapping(mapping)
        def _hx_local_0(r):
            _gthis.parseData(r,mapping,callback)
        com_sdtk_api_BTCAPI.transactions(_hx_local_0,mapping.h.get("block",None),mapping.h.get("address",None),None)

    def parseData(self,data,mapping,callback):
        callback(data,com_sdtk_table_ArrayOfObjectsReader.readWholeArray(Reflect.field(Reflect.field(com_sdtk_std_Normalize.parseJson(data),"data"),"list")))
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_BTCAPITransactions._instance is None):
            com_sdtk_api_BTCAPITransactions._instance = com_sdtk_api_BTCAPITransactions()
        return com_sdtk_api_BTCAPITransactions._instance


class com_sdtk_api_BitTorrentAPI(com_sdtk_api_API):

    def __init__(self):
        super().__init__("BitTorrent")
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_BitTorrentAPI._instance is None):
            com_sdtk_api_BitTorrentAPI._instance = com_sdtk_api_BitTorrentAPI()
        return com_sdtk_api_BitTorrentAPI._instance

    @staticmethod
    def status(callback):
        com_sdtk_api_BitTorrentAPI.instance().fetch("GET",com_sdtk_api_BitTorrentAPI._bttRoot,com_sdtk_api_BitTorrentAPI._statusAPI,None,None,None,None,callback)

    @staticmethod
    def getDefaultStart():
        return 1529906400000

    @staticmethod
    def getDefaultEnd():
        import time
        return int(time.time()*1000.0)

    @staticmethod
    def transactions(callback,sort,limit,start,startTimestamp,endTimestamp,address):
        if (sort is None):
            sort = "-timestamp"
        if (limit is None):
            limit = com_sdtk_api_BitTorrentAPI._maxLimit
        if (start is None):
            start = 0
        if (startTimestamp is None):
            startTimestamp = com_sdtk_api_BitTorrentAPI.getDefaultStart()
        if (endTimestamp is None):
            endTimestamp = com_sdtk_api_BitTorrentAPI.getDefaultEnd()
        if (limit > ((com_sdtk_api_BitTorrentAPI._maxLimit * com_sdtk_api_BitTorrentAPI._maxMultiple))):
            limit = (com_sdtk_api_BitTorrentAPI._maxLimit * com_sdtk_api_BitTorrentAPI._maxMultiple)
        if (limit <= com_sdtk_api_BitTorrentAPI._maxLimit):
            def _hx_local_1(r):
                o = com_sdtk_std_Normalize.parseJson(r)
                if (Reflect.field(Reflect.field(o,"data"),"length") == limit):
                    callback(r)
                else:
                    def _hx_local_0(r):
                        o2 = com_sdtk_std_Normalize.parseJson(r)
                        Reflect.setField(o,"data",Reflect.field(Reflect.field(o,"data"),"concat")(Reflect.field(o2,"data")))
                        callback(haxe_format_JsonPrinter.print(o,None,None))
                    com_sdtk_api_BitTorrentAPI.transactions(_hx_local_0,sort,(limit - Reflect.field(Reflect.field(o,"data"),"length")),python_Boot._add_dynamic(start,Reflect.field(Reflect.field(o,"data"),"length")),startTimestamp,endTimestamp,address)
            com_sdtk_api_BitTorrentAPI.instance().fetch("GET",com_sdtk_api_BitTorrentAPI._bttRoot,com_sdtk_api_BitTorrentAPI._transactionAPI,None,None,(((((((((("?sort=" + ("null" if sort is None else sort)) + "&count=true&limit=") + Std.string(limit)) + "&start=") + Std.string(start)) + "&start_timestamp=") + Std.string(startTimestamp)) + "&end_timestamp=") + Std.string(endTimestamp)) + HxOverrides.stringOrNull(((("&address=" + ("null" if address is None else address)) if ((address is not None)) else "")))),None,_hx_local_1)
        else:
            i = start
            j = com_sdtk_api_BitTorrentAPI._maxLimit
            arr = list()
            cnt = 0
            loaded = 0
            while (i < limit):
                def _hx_local_5(k):
                    def _hx_local_2(r):
                        nonlocal loaded
                        python_internal_ArrayImpl._set(arr, (k[0] if 0 < len(k) else None), r)
                        loaded = (loaded + 1)
                        if (loaded == cnt):
                            r = com_sdtk_std_Normalize.parseJson((arr[0] if 0 < len(arr) else None))
                            r.data = []
                            _g = 0
                            while (_g < len(arr)):
                                s = (arr[_g] if _g >= 0 and _g < len(arr) else None)
                                _g = (_g + 1)
                                o = com_sdtk_std_Normalize.parseJson(s)
                                r.data = (r.data + Reflect.field(o,"data"))
                            callback(haxe_format_JsonPrinter.print(r,None,None))
                    return _hx_local_2
                com_sdtk_api_BitTorrentAPI.transactions(_hx_local_5([cnt]),sort,j,i,startTimestamp,endTimestamp,address)
                i = (i + j)
                j = (com_sdtk_api_BitTorrentAPI._maxLimit if (((limit - i) > com_sdtk_api_BitTorrentAPI._maxLimit)) else (limit - i))
                cnt = (cnt + 1)

    @staticmethod
    def transactionsAPI():
        return com_sdtk_api_BitTorrentAPITransactions.instance()

    @staticmethod
    def transfers(callback,sort,limit,start,startTimestamp,endTimestamp,address):
        if (sort is None):
            sort = "-timestamp"
        if (limit is None):
            limit = com_sdtk_api_BitTorrentAPI._maxLimit
        if (start is None):
            start = 0
        if (startTimestamp is None):
            startTimestamp = com_sdtk_api_BitTorrentAPI.getDefaultStart()
        if (endTimestamp is None):
            endTimestamp = com_sdtk_api_BitTorrentAPI.getDefaultEnd()
        if (limit > ((com_sdtk_api_BitTorrentAPI._maxLimit * com_sdtk_api_BitTorrentAPI._maxMultiple))):
            limit = (com_sdtk_api_BitTorrentAPI._maxLimit * com_sdtk_api_BitTorrentAPI._maxMultiple)
        if (limit <= com_sdtk_api_BitTorrentAPI._maxLimit):
            def _hx_local_1(r):
                o = com_sdtk_std_Normalize.parseJson(r)
                if (Reflect.field(Reflect.field(o,"token_transfers"),"length") == limit):
                    callback(r)
                else:
                    def _hx_local_0(r):
                        o2 = com_sdtk_std_Normalize.parseJson(r)
                        Reflect.setField(o,"token_transfers",Reflect.field(Reflect.field(o,"token_transfers"),"concat")(Reflect.field(o2,"token_transfers")))
                        callback(haxe_format_JsonPrinter.print(o,None,None))
                    com_sdtk_api_BitTorrentAPI.transfers(_hx_local_0,sort,(limit - Reflect.field(Reflect.field(o,"token_transfers"),"length")),python_Boot._add_dynamic(start,Reflect.field(Reflect.field(o,"token_transfers"),"length")),startTimestamp,endTimestamp,address)
            com_sdtk_api_BitTorrentAPI.instance().fetch("GET",com_sdtk_api_BitTorrentAPI._bttRoot,com_sdtk_api_BitTorrentAPI._transfersAPI,None,None,(((((((((("?sort=" + ("null" if sort is None else sort)) + "&count=true&limit=") + Std.string(limit)) + "&start=") + Std.string(start)) + "&start_timestamp=") + Std.string(startTimestamp)) + "&end_timestamp=") + Std.string(endTimestamp)) + HxOverrides.stringOrNull(((("relatedAddress=" + ("null" if address is None else address)) if ((address is not None)) else "")))),None,_hx_local_1)
        else:
            i = start
            j = com_sdtk_api_BitTorrentAPI._maxLimit
            arr = list()
            cnt = 0
            loaded = 0
            while (i < limit):
                def _hx_local_5(k):
                    def _hx_local_2(r):
                        nonlocal loaded
                        python_internal_ArrayImpl._set(arr, (k[0] if 0 < len(k) else None), r)
                        loaded = (loaded + 1)
                        if (loaded == cnt):
                            r = com_sdtk_std_Normalize.parseJson((arr[0] if 0 < len(arr) else None))
                            r.token_transfers = []
                            _g = 0
                            while (_g < len(arr)):
                                s = (arr[_g] if _g >= 0 and _g < len(arr) else None)
                                _g = (_g + 1)
                                o = com_sdtk_std_Normalize.parseJson(s)
                                r.token_transfers = (r.token_transfers + Reflect.field(o,"token_transfers"))
                            callback(haxe_format_JsonPrinter.print(r,None,None))
                    return _hx_local_2
                com_sdtk_api_BitTorrentAPI.transfers(_hx_local_5([cnt]),sort,j,i,startTimestamp,endTimestamp,address)
                i = (i + j)
                j = (com_sdtk_api_BitTorrentAPI._maxLimit if (((limit - i) > com_sdtk_api_BitTorrentAPI._maxLimit)) else (limit - i))
                cnt = (cnt + 1)

    @staticmethod
    def transfersAPI():
        return com_sdtk_api_BitTorrentAPITransfers.instance()

    @staticmethod
    def price(callback):
        com_sdtk_api_BitTorrentAPI.instance().fetch("GET",com_sdtk_api_BitTorrentAPI._bttRoot,com_sdtk_api_BitTorrentAPI._priceAPI,None,None,None,None,callback)


class com_sdtk_api_BitTorrentAPITransactions(com_sdtk_api_InputAPI):

    def __init__(self):
        super().__init__("Blockchain - BitTorrent - Transactions")

    def getInputNames(self):
        return ["address", "startTimestamp", "endTimestamp", "start", "limit"]

    def retrieveData(self,mapping,callback):
        _gthis = self
        mapping = self.normalizeMapping(mapping)
        def _hx_local_0(r):
            _gthis.parseData(r,mapping,callback)
        com_sdtk_api_BitTorrentAPI.transactions(_hx_local_0,None,Std.parseInt(mapping.h.get("limit",None)),Std.parseInt(mapping.h.get("start",None)),Std.parseInt(mapping.h.get("startTimestamp",None)),Std.parseInt(mapping.h.get("endTimestamp",None)),mapping.h.get("address",None))

    def parseData(self,data,mapping,callback):
        callback(data,com_sdtk_table_ArrayOfObjectsReader.readWholeArray(Reflect.field(com_sdtk_std_Normalize.parseJson(data),"data")))
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_BitTorrentAPITransactions._instance is None):
            com_sdtk_api_BitTorrentAPITransactions._instance = com_sdtk_api_BitTorrentAPITransactions()
        return com_sdtk_api_BitTorrentAPITransactions._instance


class com_sdtk_api_BitTorrentAPITransfers(com_sdtk_api_InputAPI):

    def __init__(self):
        super().__init__("Blockchain - BitTorrent - Transfers")

    def getInputNames(self):
        return ["address", "startTimestamp", "endTimestamp", "start", "limit"]

    def retrieveData(self,mapping,callback):
        _gthis = self
        mapping = self.normalizeMapping(mapping)
        def _hx_local_0(r):
            _gthis.parseData(r,mapping,callback)
        com_sdtk_api_BitTorrentAPI.transfers(_hx_local_0,None,Std.parseInt(mapping.h.get("limit",None)),Std.parseInt(mapping.h.get("start",None)),Std.parseInt(mapping.h.get("startTimestamp",None)),Std.parseInt(mapping.h.get("endTimestamp",None)),mapping.h.get("address",None))

    def parseData(self,data,mapping,callback):
        callback(data,com_sdtk_table_ArrayOfObjectsReader.readWholeArray(Reflect.field(com_sdtk_std_Normalize.parseJson(data),"token_transfers")))
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_BitTorrentAPITransfers._instance is None):
            com_sdtk_api_BitTorrentAPITransfers._instance = com_sdtk_api_BitTorrentAPITransfers()
        return com_sdtk_api_BitTorrentAPITransfers._instance


class com_sdtk_api_ChatGPTAPI(com_sdtk_api_API):

    def __init__(self):
        super().__init__("ChatGPT")

    def getAccessToken(self):
        return self.processIfNeeded(com_sdtk_api_ChatGPTAPI._apiKey)

    def query(self,callback,query):
        model = com_sdtk_api_ChatGPTAPI._model
        if ((model is None) or ((model == "<CHATGPT_MODEL>"))):
            model = "gpt-4o"
        _g = haxe_ds_StringMap()
        _g.h["model"] = model
        _g1 = haxe_ds_StringMap()
        _g1.h["role"] = "user"
        _g1.h["content"] = query
        _g.h["messages"] = [_g1]
        data = _g
        tmp = com_sdtk_api_ChatGPTAPI._chatGPTRoot
        tmp1 = com_sdtk_api_ChatGPTAPI._completions
        tmp2 = haxe_format_JsonPrinter.print(data,None,None)
        _g = haxe_ds_StringMap()
        _g.h["Content-Type"] = "application/json"
        def _hx_local_0(response):
            responseData = com_sdtk_std_Normalize.nativeToHaxe(com_sdtk_std_Normalize.parseJson(Std.string(response)))
            choices = responseData.h.get("choices",None)
            responseData = com_sdtk_std_Normalize.nativeToHaxe((choices[0] if 0 < len(choices) else None))
            responseData = com_sdtk_std_Normalize.nativeToHaxe(responseData.h.get("message",None))
            callback(responseData.h.get("content",None))
        self.fetch("POST",tmp,tmp1,None,True,None,tmp2,_hx_local_0,_g)

    def queryAsTable(self,callback,query,format):
        details = ""
        if (format.index == 5):
            details = "  Like an array of objects."
        def _hx_local_0(response):
            callback(response)
        com_sdtk_api_ChatGPTAPI.instance().query(_hx_local_0,((((("null" if query is None else query) + "\n\nGive the result as only ") + Std.string(format)) + " content file in the chat like a table of values, as simple as possible.") + ("null" if details is None else details)))

    def queryAsReader(self,callback,query):
        def _hx_local_0(response):
            callback(response,com_sdtk_table_KeyValueReader.createJSONReader(com_sdtk_std_StringReader(response)))
        self.queryAsTable(_hx_local_0,query,com_sdtk_table_Format.JSON)

    def queryAsReaderWithData(self,callback,query,reader):
        writer = com_sdtk_std_StringWriter(None)
        reader.convertTo(com_sdtk_table_KeyValueWriter.createJSONWriter(writer))
        data = writer.toString()
        self.queryAsReader(callback,((("Given the following data in JSON format.\n\n" + ("null" if data is None else data)) + "\n\n") + ("null" if query is None else query)))
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_ChatGPTAPI._instance is None):
            com_sdtk_api_ChatGPTAPI._instance = com_sdtk_api_ChatGPTAPI()
        return com_sdtk_api_ChatGPTAPI._instance

    @staticmethod
    def queryAsReaderAPI():
        return com_sdtk_api_ChatGPTQueryAsReaderAPI.instance()

    @staticmethod
    def queryAsReaderWithDataAPI():
        return com_sdtk_api_ChatGPTQueryAsReaderWithDataAPI.instance()

    @staticmethod
    def queryWithDataAPI():
        return com_sdtk_api_ChatGPTQueryWithDataAPI.instance()


class com_sdtk_api_ChatGPTQueryAsReaderAPI(com_sdtk_api_InputAPI):

    def __init__(self):
        super().__init__("Large Language Model - ChatGPT - Table")

    def retrieveData(self,mapping,callback):
        mapping = self.normalizeMapping(mapping)
        com_sdtk_api_ChatGPTAPI.instance().queryAsReader(callback,mapping.h.get("query",None))
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_ChatGPTQueryAsReaderAPI._instance is None):
            com_sdtk_api_ChatGPTQueryAsReaderAPI._instance = com_sdtk_api_ChatGPTQueryAsReaderAPI()
        return com_sdtk_api_ChatGPTQueryAsReaderAPI._instance


class com_sdtk_api_ExecutorAPI(com_sdtk_api_API):

    def __init__(self,name):
        super().__init__(name)

    def acceptedFormat(self):
        return None

    def execute(self,script,mapping,readers,callback):
        callback(None)

    def keywords(self):
        return None

    def keywordsAreCaseSensitive(self):
        return True

    def exportReader(self,o,raw,callback):
        isPrimitive = False
        isArrayOfArrays = False
        if ((o is None) and ((raw is not None))):
            isPrimitive = True
            isArrayOfArrays = True
            arr = list()
            arr.append(raw)
            o = arr
        arr = None
        _hx_map = None
        size = None
        if com_sdtk_api_ExecutorAPI.isArray(o):
            arr = list()
            _hx_len = Reflect.field(o,"length")
            l = len(arr)
            if (l < _hx_len):
                idx = (_hx_len - 1)
                v = None
                l1 = len(arr)
                while (l1 < idx):
                    arr.append(None)
                    l1 = (l1 + 1)
                if (l1 == idx):
                    arr.append(v)
                else:
                    arr[idx] = v
            elif (l > _hx_len):
                pos = _hx_len
                len1 = (l - _hx_len)
                if (pos < 0):
                    pos = (len(arr) + pos)
                if (pos < 0):
                    pos = 0
                res = arr[pos:(pos + len1)]
                del arr[pos:(pos + len1)]
            size = Reflect.field(o,"length")
        else:
            _hx_map = haxe_ds_StringMap()
            size = Reflect.field(Reflect.field(o,"keys")(),"length")
        i = 0
        while (i < size):
            if (arr is not None):
                o2 = HxOverrides.arrayGet(o, i)
                if (not isPrimitive):
                    if com_sdtk_api_ExecutorAPI.isArray(o2):
                        python_internal_ArrayImpl._set(arr, i, o2)
                        isArrayOfArrays = True
                    elif (Reflect.field(o2,"keys") is None):
                        python_internal_ArrayImpl._set(arr, i, [o2])
                        isArrayOfArrays = True
                    else:
                        v = com_sdtk_api_ExecutorAPI.emptyObject()
                        iterator = Reflect.field(o2,"keys")()
                        cur = Reflect.field(iterator,"next")()
                        while (((cur is not None) and ((Reflect.field(cur,"value") is not None))) and ((Reflect.field(cur,"done") == False))):
                            HxOverrides.arraySet(v,Reflect.field(cur,"value"),Reflect.field(o2,"get")(Reflect.field(cur,"value")))
                            cur = Reflect.field(iterator,"next")()
                        python_internal_ArrayImpl._set(arr, i, v)
                else:
                    python_internal_ArrayImpl._set(arr, i, o2)
            else:
                o21 = HxOverrides.arrayGet(o, HxOverrides.arrayGet(Reflect.field(o,"keys")(), i))
                if com_sdtk_api_ExecutorAPI.isArray(o21):
                    k = HxOverrides.arrayGet(Reflect.field(o,"keys")(), i)
                    v1 = o21
                    _hx_map.h[k] = v1
                    isArrayOfArrays = True
                elif (Reflect.field(o21,"keys") is None):
                    k1 = HxOverrides.arrayGet(Reflect.field(o,"keys")(), i)
                    v2 = [o21]
                    _hx_map.h[k1] = v2
                    isArrayOfArrays = True
                else:
                    v3 = com_sdtk_api_ExecutorAPI.emptyObject()
                    iterator1 = Reflect.field(o21,"keys")()
                    cur1 = Reflect.field(iterator1,"next")()
                    while (((cur1 is not None) and ((Reflect.field(cur1,"value") is not None))) and ((Reflect.field(cur1,"done") == False))):
                        HxOverrides.arraySet(v3,Reflect.field(cur1,"value"),Reflect.field(o21,"get")(Reflect.field(cur1,"value")))
                        cur1 = Reflect.field(iterator1,"next")()
                    k2 = HxOverrides.arrayGet(Reflect.field(o,"keys")(), i)
                    v4 = v3
                    _hx_map.h[k2] = v4
            i = (i + 1)
        if (arr is not None):
            if (not isArrayOfArrays):
                callback(com_sdtk_table_ArrayOfObjectsReader.readWholeArray(arr))
            else:
                callback(com_sdtk_table_Array2DReader.readWholeArray(arr))
        elif (not isArrayOfArrays):
            callback(com_sdtk_table_ObjectOfArraysReader.readWholeObject(_hx_map))
        else:
            callback(com_sdtk_table_ObjectOfObjectsReader.readWholeObject(_hx_map))

    @staticmethod
    def isArray(o):
        return Std.isOfType(o,list)

    @staticmethod
    def emptyObject():
        return _hx_AnonObject({})


class com_sdtk_api_ChatGPTQueryAsReaderWithDataAPI(com_sdtk_api_ExecutorAPI):

    def __init__(self):
        super().__init__("Large Language Model - ChatGPT - Process")

    def acceptedFormat(self):
        return "plain/text"

    def keywords(self):
        return None

    def execute(self,script,mapping,readers,callback):
        mapping = com_sdtk_std_Normalize.nativeToHaxe(mapping)
        readers = com_sdtk_std_Normalize.nativeToHaxe(readers)
        init = ""
        if (mapping is not None):
            i = mapping.keys()
            while i.hasNext():
                i1 = i.next()
                init = (("null" if init is None else init) + HxOverrides.stringOrNull(((((("Given the following data, referred to as \"" + ("null" if i1 is None else i1)) + "\", in JSON format.\n\n") + HxOverrides.stringOrNull(haxe_format_JsonPrinter.print(self.mappingValueToType(mapping.h.get(i1,None)),None,None))) + "\n\n"))))
        if (readers is not None):
            i = readers.keys()
            while i.hasNext():
                i1 = i.next()
                writer = com_sdtk_std_StringWriter(None)
                readers.h.get(i1,None).convertTo(com_sdtk_table_KeyValueWriter.createJSONWriter(writer))
                init = (("null" if init is None else init) + HxOverrides.stringOrNull(((((("Given the following data, referred to as \"" + ("null" if i1 is None else i1)) + "\", in JSON format.\n\n") + HxOverrides.stringOrNull(writer.toString())) + "\n\n"))))
        def _hx_local_2(data,reader):
            callback(reader)
        com_sdtk_api_ChatGPTAPI.instance().queryAsReader(_hx_local_2,(("null" if init is None else init) + ("null" if script is None else script)))

    def startInit(self,callback):
        callback()
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_ChatGPTQueryAsReaderWithDataAPI._instance is None):
            com_sdtk_api_ChatGPTQueryAsReaderWithDataAPI._instance = com_sdtk_api_ChatGPTQueryAsReaderWithDataAPI()
        return com_sdtk_api_ChatGPTQueryAsReaderWithDataAPI._instance


class com_sdtk_api_ChatGPTQueryWithDataAPI(com_sdtk_api_API):

    def __init__(self):
        super().__init__("Large Language Model - ChatGPT - Narrative")

    def acceptedFormat(self):
        return "plain/text"

    def keywords(self):
        return None

    def execute(self,script,mapping,readers,callback):
        mapping = com_sdtk_std_Normalize.nativeToHaxe(mapping)
        readers = com_sdtk_std_Normalize.nativeToHaxe(readers)
        init = ""
        if (mapping is not None):
            i = mapping.keys()
            while i.hasNext():
                i1 = i.next()
                init = (("null" if init is None else init) + HxOverrides.stringOrNull(((((("Given the following data, referred to as \"" + ("null" if i1 is None else i1)) + "\", in JSON format.\n\n") + HxOverrides.stringOrNull(haxe_format_JsonPrinter.print(self.mappingValueToType(mapping.h.get(i1,None)),None,None))) + "\n\n"))))
        if (readers is not None):
            i = readers.keys()
            while i.hasNext():
                i1 = i.next()
                writer = com_sdtk_std_StringWriter(None)
                readers.h.get(i1,None).convertTo(com_sdtk_table_KeyValueWriter.createJSONWriter(writer))
                init = (("null" if init is None else init) + HxOverrides.stringOrNull(((((("Given the following data, referred to as \"" + ("null" if i1 is None else i1)) + "\", in JSON format.\n\n") + HxOverrides.stringOrNull(writer.toString())) + "\n\n"))))
        def _hx_local_2(data):
            callback(data)
        com_sdtk_api_ChatGPTAPI.instance().query(_hx_local_2,(("null" if init is None else init) + ("null" if script is None else script)))

    def startInit(self,callback):
        callback()
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_ChatGPTQueryWithDataAPI._instance is None):
            com_sdtk_api_ChatGPTQueryWithDataAPI._instance = com_sdtk_api_ChatGPTQueryWithDataAPI()
        return com_sdtk_api_ChatGPTQueryWithDataAPI._instance


class com_sdtk_api_CustomWebAPI(com_sdtk_api_API):

    def __init__(self,name):
        self._accessToken = None
        self._key = None
        self._keyParameter = None
        self._authorizationHeaderBearer = None
        self._authorizationHeader = None
        self._user = None
        self._userHeader = None
        self._cookiesByKey = None
        self._cookies = None
        self._bodyType = None
        self._body = None
        self._headersByKey = None
        self._headers = None
        self._queryByKey = None
        self._query = None
        self._method = None
        self._url = None
        super().__init__(name)

    def toJSON(self):
        return haxe_format_JsonPrinter.print(self.toMap(),None,None)

    def toMap(self):
        _hx_map = haxe_ds_StringMap()
        _hx_map.h["name"] = self._name
        _hx_map.h["url"] = self._url
        _hx_map.h["method"] = self._method
        _hx_map.h["body"] = self._body
        _hx_map.h["bodyType"] = self._bodyType
        _hx_map.h["userHeader"] = self._userHeader
        _hx_map.h["user"] = self._user
        _hx_map.h["authorizationHeader"] = self._authorizationHeader
        _hx_map.h["authorizationHeaderBearer"] = self._authorizationHeaderBearer
        _hx_map.h["keyParameter"] = self._keyParameter
        _hx_map.h["key"] = self._key
        _hx_map.h["accessToken"] = self._accessToken
        value = com_sdtk_api_CustomWebAPI.saveParams(self._headers)
        _hx_map.h["headers"] = value
        value = com_sdtk_api_CustomWebAPI.saveParams(self._cookies)
        _hx_map.h["cookies"] = value
        value = com_sdtk_api_CustomWebAPI.saveParams(self._query)
        _hx_map.h["query"] = value
        return _hx_map

    def buildString(self,params):
        s_b = python_lib_io_StringIO()
        if (len(params) > 0):
            s_b.write("?")
            _g = 0
            while (_g < len(params)):
                p = (params[_g] if _g >= 0 and _g < len(params) else None)
                _g = (_g + 1)
                s_b.write(Std.string(python_lib_urllib_Parse.quote(p._name,"")))
                s_b.write("=")
                s_b.write(Std.string(python_lib_urllib_Parse.quote(p._value,"")))
                s_b.write("&")
            s2 = s_b.getvalue()
            return HxString.substring(s2,0,(len(s2) - 1))
        else:
            return ""

    def buildQuery(self):
        return self.buildString(self._query)

    def buildMap(self,params):
        v = haxe_ds_StringMap()
        k = params.keys()
        while k.hasNext():
            k1 = k.next()
            value = params.h.get(k1,None)._value
            v.h[k1] = value
        return v

    def buildHeaders(self):
        return self.buildMap(self._headersByKey)

    def buildCookies(self):
        return self.buildMap(self._cookiesByKey)

    def execute(self,callback):
        def _hx_local_0(r):
            callback(r)
        self.fetch(self._method,self._url,"",None,None,self.buildQuery(),self._body,_hx_local_0,self.buildHeaders(),self.buildCookies())

    def getQuery(self):
        return self._query

    def getQueryByKey(self):
        return self._queryByKey

    def addQueryParameter(self,name,value,comments):
        param = com_sdtk_api_CustomWebAPIParam()
        param._name = name
        param._value = value
        param._comments = comments
        _this = self._query
        _this.append(param)
        self._queryByKey.h[name] = param

    def getHeaders(self):
        return self._headers

    def getHeadersByKey(self):
        return self._headersByKey

    def addHeader(self,name,value,comments):
        param = com_sdtk_api_CustomWebAPIParam()
        param._name = name
        param._value = value
        param._comments = comments
        _this = self._headers
        _this.append(param)
        self._headersByKey.h[name] = param

    def getCookies(self):
        return self._cookies

    def getCookiesByKey(self):
        return self._cookiesByKey

    def addCookie(self,name,value,comments):
        param = com_sdtk_api_CustomWebAPIParam()
        param._name = name
        param._value = value
        param._comments = comments
        _this = self._cookies
        _this.append(param)
        self._cookiesByKey.h[name] = param

    def getBody(self):
        return self._body

    def setBody(self,body):
        self._body = body

    def getBodyType(self):
        return self._bodyType

    def setBodyType(self,bodyType):
        self._bodyType = bodyType

    def getUrl(self):
        return self._url

    def setUrl(self,url):
        self._url = url

    def getMethod(self):
        return self._method

    def setMethod(self,method):
        self._method = method

    def setLogin(self,user,password):
        self._userHeader = None
        self._user = user
        self._accessToken = password

    def setUserHeader(self,userHeader,user):
        self._userHeader = userHeader
        self._user = user

    def setAccessToken(self,header,accessToken,bearer = None):
        if (bearer is None):
            bearer = ""
        self._accessToken = accessToken
        self._authorizationHeader = header
        self._authorizationHeaderBearer = bearer

    def setKeyParameter(self,parameter,key):
        self._keyParameter = parameter
        self._key = key

    def getUserHeader(self):
        return self._userHeader

    def getUser(self):
        return self._user

    def getAuthorizationHeader(self):
        return self._authorizationHeader

    def getAuthorizationHeaderBearer(self):
        return self._authorizationHeaderBearer

    def getKeyParameter(self):
        return self._keyParameter

    def getKey(self):
        return self._key

    def getAccessToken(self):
        return self._accessToken

    @staticmethod
    def singleFromJSON(json):
        return com_sdtk_api_CustomWebAPI.fromMap(com_sdtk_std_Normalize.parseJson(json))

    @staticmethod
    def multipleFromJSON(json):
        return com_sdtk_api_CustomWebAPI.fromMaps(com_sdtk_std_Normalize.parseJson(json))

    @staticmethod
    def loadParam(params,paramsByKey,_hx_map):
        _hx_map = com_sdtk_std_Normalize.nativeToHaxe(_hx_map)
        param = com_sdtk_api_CustomWebAPIParam()
        param._name = _hx_map.h.get("name",None)
        param._value = _hx_map.h.get("value",None)
        param._comments = _hx_map.h.get("comments",None)
        params.append(param)
        paramsByKey.h[param._name] = param

    @staticmethod
    def loadParams(params,paramsByKey,_hx_map):
        if (_hx_map is not None):
            _hx_map = com_sdtk_std_Normalize.nativeToHaxe(_hx_map)
            k = _hx_map.keys()
            while k.hasNext():
                k1 = k.next()
                com_sdtk_api_CustomWebAPI.loadParam(params,paramsByKey,_hx_map.h.get(k1,None))

    @staticmethod
    def create(name,url = None,method = None,body = None,bodyType = None,query = None,headers = None,cookies = None):
        api = com_sdtk_api_CustomWebAPI(name)
        tmp = None
        if (url is None):
            startIndex = None
            if (((name.find("http://") if ((startIndex is None)) else HxString.indexOfImpl(name,"http://",startIndex))) != 0):
                startIndex = None
                tmp = (((name.find("https://") if ((startIndex is None)) else HxString.indexOfImpl(name,"https://",startIndex))) == 0)
            else:
                tmp = True
        else:
            tmp = False
        if tmp:
            api._url = name
        else:
            api._url = url
        if (method is None):
            api._method = "GET"
        else:
            api._method = method
        if (body is None):
            api._body = None
        else:
            api._body = body
        if (bodyType is None):
            api._bodyType = None
        else:
            api._bodyType = bodyType
        if (query is not None):
            query = com_sdtk_std_Normalize.nativeToHaxe(query)
            k = query.keys()
            while k.hasNext():
                k1 = k.next()
                api.addQueryParameter(k1,query.h.get(k1,None),"")
        if (headers is not None):
            headers = com_sdtk_std_Normalize.nativeToHaxe(headers)
            k = headers.keys()
            while k.hasNext():
                k1 = k.next()
                api.addHeader(k1,headers.h.get(k1,None),"")
        if (cookies is not None):
            cookies = com_sdtk_std_Normalize.nativeToHaxe(cookies)
            k = cookies.keys()
            while k.hasNext():
                k1 = k.next()
                api.addCookie(k1,cookies.h.get(k1,None),"")
        return api

    @staticmethod
    def fromMap(_hx_map):
        _hx_map = com_sdtk_std_Normalize.nativeToHaxe(_hx_map)
        api = com_sdtk_api_CustomWebAPI(_hx_map.h.get("name",None))
        api._url = _hx_map.h.get("url",None)
        api._method = _hx_map.h.get("method",None)
        api._body = _hx_map.h.get("body",None)
        api._bodyType = _hx_map.h.get("bodyType",None)
        api._userHeader = _hx_map.h.get("userHeader",None)
        api._user = _hx_map.h.get("user",None)
        api._authorizationHeader = _hx_map.h.get("authorizationHeader",None)
        api._authorizationHeaderBearer = _hx_map.h.get("authorizationHeaderBearer",None)
        api._keyParameter = _hx_map.h.get("keyParameter",None)
        api._key = _hx_map.h.get("key",None)
        api._accessToken = _hx_map.h.get("accessToken",None)
        com_sdtk_api_CustomWebAPI.loadParams(api._headers,api._headersByKey,_hx_map.h.get("headers",None))
        com_sdtk_api_CustomWebAPI.loadParams(api._cookies,api._cookiesByKey,_hx_map.h.get("cookies",None))
        com_sdtk_api_CustomWebAPI.loadParams(api._query,api._queryByKey,_hx_map.h.get("query",None))
        return api

    @staticmethod
    def fromMaps(_hx_map):
        apis = haxe_ds_StringMap()
        _hx_map = com_sdtk_std_Normalize.nativeToHaxe(_hx_map)
        k = _hx_map.keys()
        while k.hasNext():
            k1 = k.next()
            api = com_sdtk_api_CustomWebAPI.fromMap(_hx_map.h.get(k1,None))
            apis.h[api._name] = api
        return apis

    @staticmethod
    def saveParam(param):
        _hx_map = haxe_ds_StringMap()
        _hx_map.h["name"] = param._name
        _hx_map.h["value"] = param._value
        _hx_map.h["comments"] = param._comments
        return _hx_map

    @staticmethod
    def saveParams(params):
        _hx_map = haxe_ds_StringMap()
        _g = 0
        while (_g < len(params)):
            p = (params[_g] if _g >= 0 and _g < len(params) else None)
            _g = (_g + 1)
            key = p._name
            value = com_sdtk_api_CustomWebAPI.saveParam(p)
            _hx_map.h[key] = value
        return _hx_map


class com_sdtk_api_CustomWebAPIParam:

    def __init__(self):
        self._comments = None
        self._value = None
        self._name = None


class com_sdtk_api_EtherscanAPI(com_sdtk_api_API):

    def __init__(self):
        super().__init__("Etherscan")
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_EtherscanAPI._instance is None):
            com_sdtk_api_EtherscanAPI._instance = com_sdtk_api_EtherscanAPI()
        return com_sdtk_api_EtherscanAPI._instance

    @staticmethod
    def transactions(callback,limit,start,address,apikey):
        if (limit is None):
            limit = com_sdtk_api_EtherscanAPI._maxLimit
        if (start is None):
            start = 0
        if (apikey is None):
            apikey = "YourApiKeyToken"
        def _hx_local_0(r):
            o = com_sdtk_std_Normalize.parseJson(r)
            callback(r)
        com_sdtk_api_EtherscanAPI.instance().fetch("GET",com_sdtk_api_EtherscanAPI._etherscanRoot,com_sdtk_api_EtherscanAPI._transactionAPI,None,None,((((((("&sort=asc&startblock=" + Std.string(start)) + "endblock=") + Std.string(((limit + start)))) + "&address=") + ("null" if address is None else address)) + "&apikey=") + ("null" if apikey is None else apikey)),None,_hx_local_0)

    @staticmethod
    def transactionsAPI():
        return com_sdtk_api_EtherscanAPITransactions.instance()


class com_sdtk_api_EtherscanAPITransactions(com_sdtk_api_InputAPI):

    def __init__(self):
        super().__init__("Blockchain - Ethereum - Etherscan - Transactions")

    def getInputNames(self):
        return ["address", "start", "limit", "apikey"]

    def retrieveData(self,mapping,callback):
        _gthis = self
        mapping = self.normalizeMapping(mapping)
        def _hx_local_0(r):
            _gthis.parseData(r,mapping,callback)
        com_sdtk_api_EtherscanAPI.transactions(_hx_local_0,Std.parseInt(mapping.h.get("limit",None)),Std.parseInt(mapping.h.get("start",None)),mapping.h.get("address",None),mapping.h.get("apikey",None))

    def parseData(self,data,mapping,callback):
        callback(data,com_sdtk_table_ArrayOfObjectsReader.readWholeArray(Reflect.field(com_sdtk_std_Normalize.parseJson(data),"result")))
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_EtherscanAPITransactions._instance is None):
            com_sdtk_api_EtherscanAPITransactions._instance = com_sdtk_api_EtherscanAPITransactions()
        return com_sdtk_api_EtherscanAPITransactions._instance


class com_sdtk_api_GitAPI(com_sdtk_api_API):

    def __init__(self):
        super().__init__("Git")

    def files(self,callback,owner,repo,branch = None,recursive = None):
        if (branch is None):
            branch = "main"
        if (recursive is None):
            recursive = 1
        try:
            self.fetch("GET",com_sdtk_api_GitAPI._gitRoot,com_sdtk_api_GitAPI._reposAPI,None,None,((((((("/" + ("null" if owner is None else owner)) + "/") + ("null" if repo is None else repo)) + "/git/trees/") + ("null" if branch is None else branch)) + "?recursive=") + Std.string(recursive)),None,callback)
        except BaseException as _g:
            None
            if (branch == "main"):
                self.files(callback,owner,repo,"master",recursive)

    def repos(self,callback,owner):
        self.fetch("GET",com_sdtk_api_GitAPI._gitRoot,com_sdtk_api_GitAPI._usersAPI,None,None,(("/" + ("null" if owner is None else owner)) + "/repos"),None,callback)

    def branches(self,callback,owner,repo):
        self.fetch("GET",com_sdtk_api_GitAPI._gitRoot,com_sdtk_api_GitAPI._reposAPI,None,None,(((("/" + ("null" if owner is None else owner)) + "/") + ("null" if repo is None else repo)) + "/branches"),None,callback)

    def commits(self,callback,owner,repo,branch = None):
        if (branch is None):
            branch = "main"
        _gthis = self
        if ((branch == "main") or ((branch == "master"))):
            self.fetch("GET",com_sdtk_api_GitAPI._gitRoot,com_sdtk_api_GitAPI._reposAPI,None,None,(((("/" + ("null" if owner is None else owner)) + "/") + ("null" if repo is None else repo)) + "/commits"),None,callback)
        else:
            def _hx_local_1(r):
                sha = None
                arr = r
                _g = 0
                while (_g < len(arr)):
                    branch = (arr[_g] if _g >= 0 and _g < len(arr) else None)
                    _g = (_g + 1)
                    if HxOverrides.eq(Reflect.field(branch,"name"),branch):
                        sha = Reflect.field(Reflect.field(branch,"commit"),"sha")
                _gthis.fetch("GET",com_sdtk_api_GitAPI._gitRoot,com_sdtk_api_GitAPI._reposAPI,None,None,((((("/" + ("null" if owner is None else owner)) + "/") + ("null" if repo is None else repo)) + "/commits?sha=") + ("null" if sha is None else sha)),None,callback)
            self.branches(_hx_local_1,owner,repo)

    def retrieve(self,callback,owner,repo,path,tag = None):
        if (tag is None):
            tag = "main"
        def _hx_local_1(r):
            def _hx_local_0(b64):
                try:
                    import base64
                    return base64.b64decode(b64)
                except BaseException as _g:
                    None
                return None
            base64ToSomething = _hx_local_0
            r = com_sdtk_std_Normalize.parseJson(r)
            callback(base64ToSomething(Reflect.field(r,"content")),_hx_AnonObject({'name': Reflect.field(r,"name"), 'path': Reflect.field(r,"path"), 'sha': Reflect.field(r,"sha"), 'size': Reflect.field(r,"size"), 'url': Reflect.field(r,"url"), 'html_url': Reflect.field(r,"html_url"), 'git_url': Reflect.field(r,"git_url"), 'download_url': Reflect.field(r,"download_url"), 'type': Reflect.field(r,"type"), 'encoding': Reflect.field(r,"encoding"), '_links': Reflect.field(r,"_links")}))
        try:
            self.fetch("GET",com_sdtk_api_GitAPI._gitRoot,com_sdtk_api_GitAPI._reposAPI,None,None,(((((("/" + ("null" if owner is None else owner)) + "/") + ("null" if repo is None else repo)) + "/contents/") + ("null" if path is None else path)) + HxOverrides.stringOrNull(((("?ref=" + ("null" if tag is None else tag)) if ((tag is not None)) else "")))),None,_hx_local_1)
        except BaseException as _g:
            None
            if (tag == "main"):
                self.retrieve(callback,owner,repo,path,"master")

    def getUserHeader(self):
        if (com_sdtk_api_GitAPI._user is None):
            return None
        else:
            _this = com_sdtk_api_GitAPI._apiKey
            startIndex = None
            if (((_this.find("github_pat_") if ((startIndex is None)) else HxString.indexOfImpl(_this,"github_pat_",startIndex))) == 0):
                return None
            else:
                return "Username"

    def getUser(self):
        return com_sdtk_api_GitAPI._user

    def getAuthorizationHeader(self):
        if (com_sdtk_api_GitAPI._apiKey is None):
            return None
        else:
            _this = com_sdtk_api_GitAPI._apiKey
            startIndex = None
            if ((((_this.find("github_pat_") if ((startIndex is None)) else HxString.indexOfImpl(_this,"github_pat_",startIndex))) == 0) and ((com_sdtk_api_GitAPI._user is not None))):
                return None
            else:
                return "Authorization"

    def getAuthorizationHeaderBearer(self):
        if (com_sdtk_api_GitAPI._apiKey is None):
            return None
        else:
            _this = com_sdtk_api_GitAPI._apiKey
            startIndex = None
            if ((((_this.find("github_pat_") if ((startIndex is None)) else HxString.indexOfImpl(_this,"github_pat_",startIndex))) == 0) and ((com_sdtk_api_GitAPI._user is not None))):
                return ""
            else:
                return "token "

    def getAccessToken(self):
        return com_sdtk_api_GitAPI._apiKey

    def setKey(self,key):
        com_sdtk_api_GitAPI._apiKey = key
        return self

    def setUser(self,user):
        com_sdtk_api_GitAPI._user = user
        return self

    def parse(self,value):
        mapping = haxe_ds_StringMap()
        parts1 = value.split(":")
        _g = (parts1[0] if 0 < len(parts1) else None)
        _hx_local_0 = len(_g)
        if (_hx_local_0 == 15):
            if (_g == "x-github-client"):
                parts2 = value.split("/")
                mapping.h["owner"] = (parts2[6] if 6 < len(parts2) else None)
                mapping.h["repo"] = (parts2[7] if 7 < len(parts2) else None)
                return com_sdtk_api_GitAPIRetrieveAll.instance().wrapWithMapping(mapping)
        elif (_hx_local_0 == 10):
            if (_g == "git-client"):
                _this = python_lib_urllib_Parse.unquote(HxOverrides.arrayGet(value.split("="), 1))
                parts2 = _this.split("/")
                mapping.h["owner"] = (parts2[3] if 3 < len(parts2) else None)
                mapping.h["repo"] = (parts2[4] if 4 < len(parts2) else None)
                return com_sdtk_api_GitAPIRetrieveAll.instance().wrapWithMapping(mapping)
        elif (_hx_local_0 == 5):
            if (_g == "https"):
                parts2 = value.split("/")
                _g = len(parts2)
                if (_g == 5):
                    mapping.h["owner"] = (parts2[3] if 3 < len(parts2) else None)
                    _this = (parts2[4] if 4 < len(parts2) else None)
                    value1 = python_internal_ArrayImpl._get(_this.split("."), 0)
                    mapping.h["repo"] = value1
                    return com_sdtk_api_GitAPIRetrieveAll.instance().wrapWithMapping(mapping)
                elif (_g == 8):
                    _this = (parts2[7] if 7 < len(parts2) else None)
                    fileParts = _this.split("?")
                    mapping.h["owner"] = (parts2[4] if 4 < len(parts2) else None)
                    mapping.h["repo"] = (parts2[5] if 5 < len(parts2) else None)
                    mapping.h["path"] = (fileParts[0] if 0 < len(fileParts) else None)
                    if (len(fileParts) > 1):
                        _this = (fileParts[1] if 1 < len(fileParts) else None)
                        value1 = python_internal_ArrayImpl._get(_this.split("="), 1)
                        mapping.h["branch"] = value1
                    return com_sdtk_api_GitAPIRetrieveAll.instance().wrapWithMapping(mapping)
                elif (_g == 9):
                    pass
                else:
                    pass
        else:
            pass
        return None
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_GitAPI._instance is None):
            com_sdtk_api_GitAPI._instance = com_sdtk_api_GitAPI()
        return com_sdtk_api_GitAPI._instance

    @staticmethod
    def filesAPI():
        return com_sdtk_api_GitAPIFiles.instance()

    @staticmethod
    def reposAPI():
        return com_sdtk_api_GitAPIRepos.instance()

    @staticmethod
    def branchesAPI():
        return com_sdtk_api_GitAPIBranches.instance()

    @staticmethod
    def commitsAPI():
        return com_sdtk_api_GitAPICommits.instance()

    @staticmethod
    def retrieveAPI():
        return com_sdtk_api_GitAPIRetrieve.instance()


class com_sdtk_api_GitAPIFiles(com_sdtk_api_InputAPI):

    def __init__(self):
        super().__init__("Version Control System - GitHub - Files")

    def getInputNames(self):
        return ["owner", "repo", "branch"]

    def retrieveData(self,mapping,callback):
        _gthis = self
        mapping = self.normalizeMapping(mapping)
        def _hx_local_0(r):
            _gthis.parseData(r,mapping,callback)
        com_sdtk_api_GitAPI.instance().files(_hx_local_0,mapping.h.get("owner",None),mapping.h.get("repo",None),mapping.h.get("branch",None))

    def parseData(self,data,mapping,callback):
        callback(data,com_sdtk_table_ArrayOfObjectsReader.readWholeArray(Reflect.field(com_sdtk_std_Normalize.parseJson(data),"tree")))

    def externalKey(self):
        return "path"

    def externalValue(self):
        return "url"
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_GitAPIFiles._instance is None):
            com_sdtk_api_GitAPIFiles._instance = com_sdtk_api_GitAPIFiles()
        return com_sdtk_api_GitAPIFiles._instance


class com_sdtk_api_GitAPIRepos(com_sdtk_api_InputAPI):

    def __init__(self):
        super().__init__("Version Control System - GitHub - Repo")

    def getInputNames(self):
        return ["owner"]

    def retrieveData(self,mapping,callback):
        _gthis = self
        mapping = self.normalizeMapping(mapping)
        def _hx_local_0(r):
            _gthis.parseData(r,mapping,callback)
        com_sdtk_api_GitAPI.instance().repos(_hx_local_0,mapping.h.get("owner",None))

    def parseData(self,data,mapping,callback):
        callback(data,com_sdtk_table_ArrayOfObjectsReader.readWholeArray(com_sdtk_std_Normalize.parseJson(data)))
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_GitAPIRepos._instance is None):
            com_sdtk_api_GitAPIRepos._instance = com_sdtk_api_GitAPIRepos()
        return com_sdtk_api_GitAPIRepos._instance


class com_sdtk_api_GitAPIBranches(com_sdtk_api_InputAPI):

    def __init__(self):
        super().__init__("Version Control System - GitHub - Branches")

    def getInputNames(self):
        return ["owner", "repo"]

    def retrieveData(self,mapping,callback):
        _gthis = self
        mapping = self.normalizeMapping(mapping)
        def _hx_local_0(r):
            _gthis.parseData(r,mapping,callback)
        com_sdtk_api_GitAPI.instance().branches(_hx_local_0,mapping.h.get("owner",None),mapping.h.get("repo",None))

    def parseData(self,data,mapping,callback):
        arr = com_sdtk_std_Normalize.parseJson(data)
        _g = 0
        while (_g < len(arr)):
            o = (arr[_g] if _g >= 0 and _g < len(arr) else None)
            _g = (_g + 1)
            Reflect.setField(o,"commit_url",Reflect.field(Reflect.field(o,"commit"),"url"))
            Reflect.setField(o,"commit",Reflect.field(Reflect.field(o,"commit"),"sha"))
        callback(data,com_sdtk_table_ArrayOfObjectsReader.readWholeArrayI(arr))
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_GitAPIBranches._instance is None):
            com_sdtk_api_GitAPIBranches._instance = com_sdtk_api_GitAPIBranches()
        return com_sdtk_api_GitAPIBranches._instance


class com_sdtk_api_GitAPICommits(com_sdtk_api_InputAPI):

    def __init__(self):
        super().__init__("Version Control System - GitHub - Commits")

    def getInputNames(self):
        return ["owner", "repo", "branch"]

    def retrieveData(self,mapping,callback):
        _gthis = self
        mapping = self.normalizeMapping(mapping)
        def _hx_local_0(r):
            _gthis.parseData(r,mapping,callback)
        com_sdtk_api_GitAPI.instance().commits(_hx_local_0,mapping.h.get("owner",None),mapping.h.get("repo",None),mapping.h.get("branch",None))

    def parseData(self,data,mapping,callback):
        arr = com_sdtk_std_Normalize.parseJson(data)
        _g = 0
        while (_g < len(arr)):
            o = (arr[_g] if _g >= 0 and _g < len(arr) else None)
            _g = (_g + 1)
            Reflect.setField(o,"author",Reflect.field(Reflect.field(o,"author"),"login"))
            Reflect.setField(o,"author_email",Reflect.field(Reflect.field(Reflect.field(o,"commit"),"author"),"email"))
            Reflect.setField(o,"comment_count",Reflect.field(Reflect.field(o,"commit"),"comment_count"))
            Reflect.setField(o,"commit_message",Reflect.field(Reflect.field(o,"commit"),"message"))
            Reflect.setField(o,"date",Reflect.field(Reflect.field(o,"commit"),"date"))
            Reflect.setField(o,"committer",Reflect.field(Reflect.field(o,"committer"),"login"))
            Reflect.setField(o,"committer_email",Reflect.field(Reflect.field(Reflect.field(o,"commit"),"committer"),"email"))
            Reflect.setField(o,"commit",Reflect.field(Reflect.field(o,"commit"),"url"))
            parentsI = Reflect.field(o,"parents")
            parents = list()
            _g1 = 0
            while (_g1 < len(parentsI)):
                parent = (parentsI[_g1] if _g1 >= 0 and _g1 < len(parentsI) else None)
                _g1 = (_g1 + 1)
                x = Reflect.field(parent,"sha")
                parents.append(x)
            Reflect.setField(o,"parents",",".join([python_Boot.toString1(x1,'') for x1 in parents]))
        callback(data,com_sdtk_table_ArrayOfObjectsReader.readWholeArrayI(arr))
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_GitAPICommits._instance is None):
            com_sdtk_api_GitAPICommits._instance = com_sdtk_api_GitAPICommits()
        return com_sdtk_api_GitAPICommits._instance


class com_sdtk_api_GitAPIRetrieve(com_sdtk_api_InputAPI):

    def __init__(self):
        super().__init__("Version Control System - GitHub - Retrieve")

    def getInputNames(self):
        return ["owner", "repo", "branch", "path", "format"]

    def retrieveData(self,mapping,callback):
        _gthis = self
        mapping = self.normalizeMapping(mapping)
        def _hx_local_0(r,info):
            _gthis.parseData(r,mapping,callback)
        com_sdtk_api_GitAPI.instance().retrieve(_hx_local_0,mapping.h.get("owner",None),mapping.h.get("repo",None),mapping.h.get("path",None),mapping.h.get("branch",None))

    def parseData(self,data,mapping,callback):
        callback(data,None)

    def externalKey(self):
        return "name"

    def externalValue(self):
        return "content"
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_GitAPIRetrieve._instance is None):
            com_sdtk_api_GitAPIRetrieve._instance = com_sdtk_api_GitAPIRetrieve()
        return com_sdtk_api_GitAPIRetrieve._instance


class com_sdtk_api_GitAPIRetrieveAll(com_sdtk_api_InputAPI):

    def __init__(self):
        super().__init__("Version Control System - GitHub - RetrieveAll")

    def getInputNames(self):
        return ["owner", "repo", "branch"]

    def retrieveData(self,mapping,callback):
        mapping = self.normalizeMapping(mapping)
        def _hx_local_3(r):
            arr = Reflect.field(com_sdtk_std_Normalize.parseJson(r),"tree")
            result = haxe_ds_StringMap()
            next = None
            i = -1
            def _hx_local_2():
                nonlocal i
                i = (i + 1)
                if (i >= len(arr)):
                    callback(None,com_sdtk_table_MapReader.readWholeMap(result))
                    return
                else:
                    next1 = com_sdtk_api_GitAPI.instance()
                    next2 = mapping.h.get("owner",None)
                    next3 = mapping.h.get("repo",None)
                    key = com_sdtk_api_GitAPIFiles.instance().externalKey()
                    def _hx_local_1(r,info):
                        key = com_sdtk_api_GitAPIFiles.instance().externalKey()
                        key1 = Reflect.field((arr[i] if i >= 0 and i < len(arr) else None),key)
                        result.h[key1] = r
                        next()
                    next1.retrieve(_hx_local_1,next2,next3,Reflect.field((arr[i] if i >= 0 and i < len(arr) else None),key),mapping.h.get("branch",None))
            next = _hx_local_2
            next()
        com_sdtk_api_GitAPI.instance().files(_hx_local_3,mapping.h.get("owner",None),mapping.h.get("repo",None),mapping.h.get("branch",None))

    def externalKey(self):
        return "name"

    def externalValue(self):
        return "content"
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_GitAPIRetrieveAll._instance is None):
            com_sdtk_api_GitAPIRetrieveAll._instance = com_sdtk_api_GitAPIRetrieveAll()
        return com_sdtk_api_GitAPIRetrieveAll._instance


class com_sdtk_api_GoogleAPI(com_sdtk_api_API):

    def __init__(self):
        self._email = None
        self._token = None
        self._loggedIn = False
        self._currentScope = None
        super().__init__("Google")

    def getKey(self):
        return com_sdtk_api_GoogleAPI._apiKey

    def getAccessToken(self):
        return self._token
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_GoogleAPI._instance is None):
            com_sdtk_api_GoogleAPI._instance = com_sdtk_api_GoogleAPI()
        return com_sdtk_api_GoogleAPI._instance

    @staticmethod
    def isWorking():
        return (com_sdtk_api_GoogleAPI.instance()._token is not None)

    @staticmethod
    def hasScope(scope):
        _this = com_sdtk_api_GoogleAPI.instance()._currentScope
        startIndex = None
        return (((_this.find(scope) if ((startIndex is None)) else HxString.indexOfImpl(_this,scope,startIndex))) >= 0)

    @staticmethod
    def dataScope():
        return com_sdtk_api_GoogleAPI._dataScope

    @staticmethod
    def setAccessToken(token):
        com_sdtk_api_GoogleAPI.instance()._token = token

    @staticmethod
    def setEmail(email):
        com_sdtk_api_GoogleAPI.instance()._email = email

    @staticmethod
    def createAppFile(name,data,callback):
        metadata = _hx_AnonObject({'name': name, 'parents': ["appDataFolder"]})
        form = (((("--divider--sdtk--\nContent-Type: application/json; charset=UTF-8\n\n" + HxOverrides.stringOrNull(haxe_format_JsonPrinter.print(metadata,None,None))) + "\n\n--divider--sdtk--\n\nContent-Type: application/octet\n\n") + ("null" if data is None else data)) + "\n\n--divider--sdtk--\n")
        com_sdtk_api_GoogleAPI.instance().fetch("POST",com_sdtk_api_GoogleAPI._mainRoot,com_sdtk_api_GoogleAPI._uploadAPI,False,True,"?uploadType=multipart",form,callback)

    @staticmethod
    def createFile(name,data,callback):
        metadata = _hx_AnonObject({'name': name})
        form = (((("--divider--sdtk--\nContent-Type: application/json; charset=UTF-8\n\n" + HxOverrides.stringOrNull(haxe_format_JsonPrinter.print(metadata,None,None))) + "\n\n--divider--sdtk--\n\nContent-Type: application/octet\n\n") + ("null" if data is None else data)) + "\n\n--divider--sdtk--\n")
        com_sdtk_api_GoogleAPI.instance().fetch("POST",com_sdtk_api_GoogleAPI._mainRoot,com_sdtk_api_GoogleAPI._uploadAPI,False,True,"?uploadType=multipart",form,callback)

    @staticmethod
    def updateAppFile(id,data,callback):
        com_sdtk_api_GoogleAPI.instance().fetch("PATCH",com_sdtk_api_GoogleAPI._mainRoot,com_sdtk_api_GoogleAPI._uploadAPI,False,True,(("/" + ("null" if id is None else id)) + "?uploadType=media"),data,callback)

    @staticmethod
    def getAppFileId(name,callback):
        path = name.split("/")
        name = python_internal_ArrayImpl._get(path, (len(path) - 1))
        com_sdtk_api_GoogleAPI.instance().fetch("GET",com_sdtk_api_GoogleAPI._contentRoot,com_sdtk_api_GoogleAPI._fileAPI,True,True,(("?q=name%20%3D%20%27" + ("null" if name is None else name)) + "%27&spaces=appDataFolder&fields=files(id%2C%20name)"),None,callback)

    @staticmethod
    def readAppFileI(id,callback):
        com_sdtk_api_GoogleAPI.instance().fetch("GET",com_sdtk_api_GoogleAPI._contentRoot,com_sdtk_api_GoogleAPI._fileAPI,True,True,(("/" + ("null" if id is None else id)) + "?alt=media"),None,callback)

    @staticmethod
    def readAppFile(name,callback):
        def _hx_local_0(id):
            com_sdtk_api_GoogleAPI.readAppFileI(id,callback)
        com_sdtk_api_GoogleAPI.getAppFileId(name,_hx_local_0)

    @staticmethod
    def listAppFiles(callback):
        com_sdtk_api_GoogleAPI.instance().fetch("GET",com_sdtk_api_GoogleAPI._mainRoot,com_sdtk_api_GoogleAPI._fileAPI,True,True,"?spaces=appDataFolder&fields=files(name)",None,callback)

    @staticmethod
    def listFiles(callback):
        com_sdtk_api_GoogleAPI.instance().fetch("GET",com_sdtk_api_GoogleAPI._mainRoot,com_sdtk_api_GoogleAPI._fileAPI,True,True,"?fields=files(name)",None,callback)

    @staticmethod
    def deleteAppFileI(id,callback):
        com_sdtk_api_GoogleAPI.instance().fetch("DELETE",com_sdtk_api_GoogleAPI._contentRoot,com_sdtk_api_GoogleAPI._fileAPI,True,True,("/" + ("null" if id is None else id)),None,callback)

    @staticmethod
    def deleteAppFile(name,callback):
        def _hx_local_0(id):
            com_sdtk_api_GoogleAPI.deleteAppFileI(id,callback)
        com_sdtk_api_GoogleAPI.getAppFileId(name,_hx_local_0)

    @staticmethod
    def renameAppFileI(id,newName,callback):
        com_sdtk_api_GoogleAPI.instance().fetch("PATCH",com_sdtk_api_GoogleAPI._mainRoot,com_sdtk_api_GoogleAPI._fileAPI,True,True,("/" + ("null" if id is None else id)),haxe_format_JsonPrinter.print(_hx_AnonObject({'title': newName}),None,None),callback)

    @staticmethod
    def renameAppFile(oldName,newName,callback):
        def _hx_local_0(id):
            com_sdtk_api_GoogleAPI.renameAppFileI(id,newName,callback)
        com_sdtk_api_GoogleAPI.getAppFileId(oldName,_hx_local_0)

    @staticmethod
    def encode(s):
        import base64
        return base64.b64encode(s)

    @staticmethod
    def emailFile(to,subject,body,name,file,contentType,callback):
        if (contentType is None):
            contentType = "text-plain"
        encodedEmail = None
        if (file is None):
            encodedEmail = com_sdtk_api_GoogleAPI.encode((((((("To: " + ("null" if to is None else to)) + "\r\nSubject: ") + ("null" if subject is None else subject)) + "\r\nContent-Type: multipart/mixed; boundary=message\r\n--message\r\nContent-Type: text/plain; charset=UTF-8\r\n") + ("null" if body is None else body)) + "\r\n--message"))
        else:
            encodedEmail = com_sdtk_api_GoogleAPI.encode((((((((((((("To: " + ("null" if to is None else to)) + "\r\nSubject: ") + ("null" if subject is None else subject)) + "\r\nContent-Type: multipart/mixed; boundary=message\r\n--message\r\nContent-Type: text/plain; charset=UTF-8\r\n") + ("null" if body is None else body)) + "\r\n--message\r\nContent-Type: ") + ("null" if contentType is None else contentType)) + "\r\nContent-Disposition: attachment; filename=") + ("null" if name is None else name)) + "\r\nContent-Transfer-Encoding: base64\r\n") + Std.string(com_sdtk_api_GoogleAPI.encode(file))) + "\r\n--message--"))
        com_sdtk_api_GoogleAPI.instance().fetch("POST",com_sdtk_api_GoogleAPI._gmailRoot,com_sdtk_api_GoogleAPI._gmailSendAPI,True,True,"",haxe_format_JsonPrinter.print(_hx_AnonObject({'raw': encodedEmail}),None,None),callback)

    @staticmethod
    def listEmails(query,callback):
        com_sdtk_api_GoogleAPI.instance().fetch("GET",com_sdtk_api_GoogleAPI._gmailRoot,com_sdtk_api_GoogleAPI._gmailListAPI,True,True,("?q=" + ("null" if query is None else query)),None,callback)

    @staticmethod
    def getEmail(id,callback):
        com_sdtk_api_GoogleAPI.instance().fetch("GET",com_sdtk_api_GoogleAPI._gmailRoot,com_sdtk_api_GoogleAPI._gmailGetAPI,True,True,("/" + ("null" if id is None else id)),None,callback)

    @staticmethod
    def getAttachment(id,attachmentId,callback):
        com_sdtk_api_GoogleAPI.instance().fetch("GET",com_sdtk_api_GoogleAPI._gmailRoot,com_sdtk_api_GoogleAPI._gmailAttachmentAPI,True,True,((("/" + ("null" if id is None else id)) + "/attachments/") + ("null" if attachmentId is None else attachmentId)),None,callback)


class com_sdtk_api_IEEEAPI(com_sdtk_api_API):

    def __init__(self):
        super().__init__("IEEE")
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_IEEEAPI._instance is None):
            com_sdtk_api_IEEEAPI._instance = com_sdtk_api_IEEEAPI()
        return com_sdtk_api_IEEEAPI._instance

    @staticmethod
    def events(callback,limit,start,end):
        if (limit is None):
            limit = com_sdtk_api_IEEEAPI._maxLimit
        def _hx_local_0(r):
            o = com_sdtk_std_Normalize.parseJson(r)
            callback(o)
        com_sdtk_api_IEEEAPI.instance().fetch("GET",com_sdtk_api_IEEEAPI._ieeeRoot,com_sdtk_api_IEEEAPI._eventsAPI,None,None,((("/list?limit=" + Std.string(limit)) + "&sort=-start-time") + HxOverrides.stringOrNull((("" if (((start is None) and ((end is None)))) else ((("?span=" + HxOverrides.stringOrNull((("" if ((start is None)) else ("" + Std.string(start)))))) + "~") + HxOverrides.stringOrNull((("" if ((end is None)) else ("" + Std.string(end)))))))))),None,_hx_local_0)

    @staticmethod
    def eventsAPI():
        return com_sdtk_api_IEEEAPIEvents.instance()


class com_sdtk_api_IEEEAPIEvents(com_sdtk_api_InputAPI):

    def __init__(self):
        super().__init__("Cloud - IEEE - Events")

    def getInputNames(self):
        return ["start", "end", "limit"]

    def retrieveData(self,mapping,callback):
        _gthis = self
        mapping = self.normalizeMapping(mapping)
        limit = None
        if ((mapping.h.get("limit",None) is not None) and ((mapping.h.get("limit",None) != ""))):
            limit = Std.parseInt(mapping.h.get("limit",None))
        start = None
        if ((mapping.h.get("start",None) is not None) and ((mapping.h.get("start",None) != ""))):
            start = Date.fromString(mapping.h.get("start",None))
        end = None
        if ((mapping.h.get("end",None) is not None) and ((mapping.h.get("end",None) != ""))):
            end = Date.fromString(mapping.h.get("end",None))
        def _hx_local_0(r):
            _gthis.parseData(r,mapping,callback)
        com_sdtk_api_IEEEAPI.events(_hx_local_0,limit,start,end)

    def parseData(self,data,mapping,callback):
        if (not Std.isOfType(data,str)):
            data = haxe_format_JsonPrinter.print(data,None,None)
        callback(data,com_sdtk_table_ArrayOfObjectsReader.readWholeArray(Reflect.field(com_sdtk_std_Normalize.parseJson(data),"data")))
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_IEEEAPIEvents._instance is None):
            com_sdtk_api_IEEEAPIEvents._instance = com_sdtk_api_IEEEAPIEvents()
        return com_sdtk_api_IEEEAPIEvents._instance


class com_sdtk_api_InputAPIWrapper(com_sdtk_api_InputAPI):

    def __init__(self,api,mapping):
        self._mapping = None
        self._api = None
        super().__init__(api.name())
        self._api = api
        self._mapping = mapping

    def retrieveData(self,mapping,callback):
        self._api.retrieveData(self._mapping,callback)


class com_sdtk_api_OrtingoAPI(com_sdtk_api_API):

    def __init__(self):
        super().__init__("Ortingo")
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_OrtingoAPI._instance is None):
            com_sdtk_api_OrtingoAPI._instance = com_sdtk_api_OrtingoAPI()
        return com_sdtk_api_OrtingoAPI._instance

    @staticmethod
    def posts(callback,owner,privateData):
        def _hx_local_0(r):
            callback(r)
        com_sdtk_api_OrtingoAPI.instance().fetch("GET",com_sdtk_api_OrtingoAPI._ortingoRoot,com_sdtk_api_OrtingoAPI._postsAPI,None,None,(("null" if owner is None else owner) + HxOverrides.stringOrNull((("/private" if ((privateData == True)) else "")))),None,_hx_local_0)

    @staticmethod
    def suggestions(callback,query):
        def _hx_local_0(r):
            callback(r)
        com_sdtk_api_OrtingoAPI.instance().fetch("GET",com_sdtk_api_OrtingoAPI._ortingoRoot,"handlers/dom-triggered/suggestions?",None,None,("q=" + HxOverrides.stringOrNull(python_lib_urllib_Parse.quote(query,""))),None,_hx_local_0)

    @staticmethod
    def comments(callback,owner,privateData,id):
        def _hx_local_0(r):
            callback(r)
        com_sdtk_api_OrtingoAPI.instance().fetch("GET",com_sdtk_api_OrtingoAPI._ortingoRoot,com_sdtk_api_OrtingoAPI._postsAPI,None,None,(((("null" if owner is None else owner) + HxOverrides.stringOrNull((("/private" if ((privateData == True)) else "")))) + "/") + ("null" if id is None else id)),None,_hx_local_0)

    @staticmethod
    def postsAPI():
        return com_sdtk_api_OrtingoAPIPosts.instance()

    @staticmethod
    def suggestionsAPI():
        return com_sdtk_api_OrtingoAPISuggestions.instance()

    @staticmethod
    def commentsAPI():
        return com_sdtk_api_OrtingoAPIComments.instance()


class com_sdtk_api_OrtingoAPIPosts(com_sdtk_api_InputAPI):

    def __init__(self):
        super().__init__("Cloud - Ortingo - Posts")

    def getInputNames(self):
        return ["owner", "private"]

    def retrieveData(self,mapping,callback):
        _gthis = self
        mapping = self.normalizeMapping(mapping)
        privateData = False
        if (mapping.h.get("private",None) is None):
            privateData = False
        else:
            _this = StringTools.trim(mapping.h.get("private",None))
            _g = ("" if ((0 >= len(_this))) else _this[0]).upper()
            if (((_g == "N") or ((_g == "F"))) or ((_g == "0"))):
                privateData = False
            elif (((_g == "Y") or ((_g == "T"))) or ((_g == "1"))):
                privateData = True
            else:
                pass
        def _hx_local_0(r):
            _gthis.parseData(r,mapping,callback)
        com_sdtk_api_OrtingoAPI.posts(_hx_local_0,mapping.h.get("owner",None),privateData)

    def parseData(self,data,mapping,callback):
        _hx_map = list()
        posts = self.findElementsByClass(data,["a"],"item",True)
        tag = True
        url = None
        id = None
        owner = None
        _g = 0
        while (_g < len(posts)):
            post = (posts[_g] if _g >= 0 and _g < len(posts) else None)
            _g = (_g + 1)
            if tag:
                startIndex = None
                href = (post.find("href=") if ((startIndex is None)) else HxString.indexOfImpl(post,"href=",startIndex))
                if (href >= 0):
                    href = (href + 6)
                    endOfHref1 = (post.find("\"") if ((href is None)) else HxString.indexOfImpl(post,"\"",href))
                    endOfHref2 = (post.find("'") if ((href is None)) else HxString.indexOfImpl(post,"'",href))
                    if (endOfHref1 < 0):
                        endOfHref1 = len(post)
                    if (endOfHref2 < 0):
                        endOfHref2 = len(post)
                    endOfHref = (endOfHref1 if ((endOfHref1 < endOfHref2)) else endOfHref2)
                    url = HxString.substring(post,href,endOfHref)
                    startIndex1 = None
                    startIndex2 = None
                    if (startIndex1 is None):
                        startIndex2 = url.rfind("/", 0, len(url))
                    else:
                        i = url.rfind("/", 0, (startIndex1 + 1))
                        startLeft = (max(0,((startIndex1 + 1) - len("/"))) if ((i == -1)) else (i + 1))
                        check = url.find("/", startLeft, len(url))
                        startIndex2 = (check if (((check > i) and ((check <= startIndex1)))) else i)
                    id = HxString.substring(url,(startIndex2 + 1),None)
                    startIndex3 = None
                    startIndex4 = None
                    if (startIndex3 is None):
                        startIndex4 = url.rfind("/", 0, len(url))
                    else:
                        i1 = url.rfind("/", 0, (startIndex3 + 1))
                        startLeft1 = (max(0,((startIndex3 + 1) - len("/"))) if ((i1 == -1)) else (i1 + 1))
                        check1 = url.find("/", startLeft1, len(url))
                        startIndex4 = (check1 if (((check1 > i1) and ((check1 <= startIndex3)))) else i1)
                    startIndex5 = (startIndex4 - 1)
                    startIndex6 = None
                    if (startIndex5 is None):
                        startIndex6 = url.rfind("/", 0, len(url))
                    else:
                        i2 = url.rfind("/", 0, (startIndex5 + 1))
                        startLeft2 = (max(0,((startIndex5 + 1) - len("/"))) if ((i2 == -1)) else (i2 + 1))
                        check2 = url.find("/", startLeft2, len(url))
                        startIndex6 = (check2 if (((check2 > i2) and ((check2 <= startIndex5)))) else i2)
                    owner = HxString.substring(url,startIndex6,None)
            else:
                postMap = haxe_ds_StringMap()
                value = python_internal_ArrayImpl._get(self.findElementsByClass(post,["span"],"post"), 0)
                postMap.h["post"] = value
                value1 = python_internal_ArrayImpl._get(self.findElementsByClass(post,["span"],"title"), 0)
                postMap.h["title"] = value1
                value2 = python_internal_ArrayImpl._get(self.findElementsByClass(post,["span"],"subtitle"), 0)
                postMap.h["subtitle"] = value2
                postMap.h["url"] = url
                postMap.h["id"] = id
                postMap.h["owner"] = owner
                if (postMap.h.get("post",None) is None):
                    continue
                url = None
                id = None
                owner = None
                _hx_map.append(postMap)
            tag = (not tag)
        callback(data,com_sdtk_table_ArrayOfMapsReader.readWholeArray(_hx_map))
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_OrtingoAPIPosts._instance is None):
            com_sdtk_api_OrtingoAPIPosts._instance = com_sdtk_api_OrtingoAPIPosts()
        return com_sdtk_api_OrtingoAPIPosts._instance


class com_sdtk_api_OrtingoAPISuggestions(com_sdtk_api_InputAPI):

    def __init__(self):
        super().__init__("Cloud - Ortingo - Suggestions")

    def getInputNames(self):
        return ["query"]

    def retrieveData(self,mapping,callback):
        _gthis = self
        mapping = self.normalizeMapping(mapping)
        def _hx_local_0(r):
            _gthis.parseData(r,mapping,callback)
        com_sdtk_api_OrtingoAPI.suggestions(_hx_local_0,mapping.h.get("query",None))

    def parseData(self,data,mapping,callback):
        _hx_map = list()
        posts = self.findElementsByClass(data,["a"],"item",True)
        tag = True
        url = None
        id = None
        owner = None
        _g = 0
        while (_g < len(posts)):
            post = (posts[_g] if _g >= 0 and _g < len(posts) else None)
            _g = (_g + 1)
            if tag:
                startIndex = None
                href = (post.find("href=") if ((startIndex is None)) else HxString.indexOfImpl(post,"href=",startIndex))
                if (href >= 0):
                    href = (href + 6)
                    endOfHref1 = (post.find("\"") if ((href is None)) else HxString.indexOfImpl(post,"\"",href))
                    endOfHref2 = (post.find("'") if ((href is None)) else HxString.indexOfImpl(post,"'",href))
                    if (endOfHref1 < 0):
                        endOfHref1 = len(post)
                    if (endOfHref2 < 0):
                        endOfHref2 = len(post)
                    endOfHref = (endOfHref1 if ((endOfHref1 < endOfHref2)) else endOfHref2)
                    url = HxString.substring(post,href,endOfHref)
                    startIndex1 = None
                    startIndex2 = None
                    if (startIndex1 is None):
                        startIndex2 = url.rfind("/", 0, len(url))
                    else:
                        i = url.rfind("/", 0, (startIndex1 + 1))
                        startLeft = (max(0,((startIndex1 + 1) - len("/"))) if ((i == -1)) else (i + 1))
                        check = url.find("/", startLeft, len(url))
                        startIndex2 = (check if (((check > i) and ((check <= startIndex1)))) else i)
                    id = HxString.substring(url,(startIndex2 + 1),None)
                    startIndex3 = None
                    startIndex4 = None
                    if (startIndex3 is None):
                        startIndex4 = url.rfind("/", 0, len(url))
                    else:
                        i1 = url.rfind("/", 0, (startIndex3 + 1))
                        startLeft1 = (max(0,((startIndex3 + 1) - len("/"))) if ((i1 == -1)) else (i1 + 1))
                        check1 = url.find("/", startLeft1, len(url))
                        startIndex4 = (check1 if (((check1 > i1) and ((check1 <= startIndex3)))) else i1)
                    startIndex5 = (startIndex4 - 1)
                    startIndex6 = None
                    if (startIndex5 is None):
                        startIndex6 = url.rfind("/", 0, len(url))
                    else:
                        i2 = url.rfind("/", 0, (startIndex5 + 1))
                        startLeft2 = (max(0,((startIndex5 + 1) - len("/"))) if ((i2 == -1)) else (i2 + 1))
                        check2 = url.find("/", startLeft2, len(url))
                        startIndex6 = (check2 if (((check2 > i2) and ((check2 <= startIndex5)))) else i2)
                    owner = HxString.substring(url,startIndex6,None)
            else:
                postMap = haxe_ds_StringMap()
                value = python_internal_ArrayImpl._get(self.findElementsByClass(post,["span"],"description"), 0)
                postMap.h["post"] = value
                value1 = python_internal_ArrayImpl._get(self.findElementsByClass(post,["span"],"title"), 0)
                postMap.h["title"] = value1
                value2 = python_internal_ArrayImpl._get(self.findElementsByClass(post,["span"],"subtitle"), 0)
                postMap.h["subtitle"] = value2
                postMap.h["url"] = url
                postMap.h["id"] = id
                postMap.h["owner"] = owner
                url = None
                id = None
                owner = None
                _hx_map.append(postMap)
            tag = (not tag)
        callback(data,com_sdtk_table_ArrayOfMapsReader.readWholeArray(_hx_map))
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_OrtingoAPISuggestions._instance is None):
            com_sdtk_api_OrtingoAPISuggestions._instance = com_sdtk_api_OrtingoAPISuggestions()
        return com_sdtk_api_OrtingoAPISuggestions._instance


class com_sdtk_api_OrtingoAPIComments(com_sdtk_api_InputAPI):

    def __init__(self):
        super().__init__("Cloud - Ortingo - Comments")

    def getInputNames(self):
        return ["owner", "private", "id"]

    def retrieveData(self,mapping,callback):
        _gthis = self
        mapping = self.normalizeMapping(mapping)
        privateData = False
        if (mapping.h.get("private",None) is None):
            privateData = False
        else:
            _this = StringTools.trim(mapping.h.get("private",None))
            _g = ("" if ((0 >= len(_this))) else _this[0]).upper()
            if (((_g == "N") or ((_g == "F"))) or ((_g == "0"))):
                privateData = False
            elif (((_g == "Y") or ((_g == "T"))) or ((_g == "1"))):
                privateData = True
            else:
                pass
        def _hx_local_0(r):
            _gthis.parseData(r,mapping,callback)
        com_sdtk_api_OrtingoAPI.comments(_hx_local_0,mapping.h.get("owner",None),privateData,mapping.h.get("id",None))

    def parseData(self,data,mapping,callback):
        _hx_map = list()
        posts = self.findElementsByClass(data,["div"],"comment",True)
        tag = True
        id = None
        _g = 0
        while (_g < len(posts)):
            post = (posts[_g] if _g >= 0 and _g < len(posts) else None)
            _g = (_g + 1)
            if tag:
                startIndex = None
                idStart = (post.find("id=") if ((startIndex is None)) else HxString.indexOfImpl(post,"id=",startIndex))
                if (idStart >= 0):
                    idStart = (idStart + 4)
                    endOfId1 = (post.find("\"") if ((idStart is None)) else HxString.indexOfImpl(post,"\"",idStart))
                    endOfId2 = (post.find("'") if ((idStart is None)) else HxString.indexOfImpl(post,"'",idStart))
                    if (endOfId1 < 0):
                        endOfId1 = len(post)
                    if (endOfId2 < 0):
                        endOfId2 = len(post)
                    endOfId = (endOfId1 if ((endOfId1 < endOfId2)) else endOfId2)
                    id = HxString.substring(post,idStart,endOfId)
            else:
                postMap = haxe_ds_StringMap()
                replyTo = None
                links = self.findElementsByClass(post,["a"],None,True)
                if (len(links) > 2):
                    replyTo = (links[2] if 2 < len(links) else None)
                    startIndex1 = None
                    end = None
                    if (startIndex1 is None):
                        end = replyTo.rfind("/", 0, len(replyTo))
                    else:
                        i = replyTo.rfind("/", 0, (startIndex1 + 1))
                        startLeft = (max(0,((startIndex1 + 1) - len("/"))) if ((i == -1)) else (i + 1))
                        check = replyTo.find("/", startLeft, len(replyTo))
                        end = (check if (((check > i) and ((check <= startIndex1)))) else i)
                    startIndex2 = (end - 1)
                    start = None
                    if (startIndex2 is None):
                        start = replyTo.rfind("/", 0, len(replyTo))
                    else:
                        i1 = replyTo.rfind("/", 0, (startIndex2 + 1))
                        startLeft1 = (max(0,((startIndex2 + 1) - len("/"))) if ((i1 == -1)) else (i1 + 1))
                        check1 = replyTo.find("/", startLeft1, len(replyTo))
                        start = (check1 if (((check1 > i1) and ((check1 <= startIndex2)))) else i1)
                    replyTo = HxString.substring(replyTo,(start + 1),end)
                value = python_internal_ArrayImpl._get(self.findElementsByClass(post,["p"],None), 0)
                postMap.h["post"] = value
                value1 = python_internal_ArrayImpl._get(self.findElementsByClass(post,["span"],"commenter_profile_link"), 0)
                postMap.h["owner"] = value1
                postMap.h["id"] = id
                postMap.h["replyTo"] = replyTo
                value2 = python_internal_ArrayImpl._get(self.findElementsByClass(post,["h5"],None), 0)
                postMap.h["commentDate"] = value2
                id = None
                _hx_map.append(postMap)
            tag = (not tag)
        callback(data,com_sdtk_table_ArrayOfMapsReader.readWholeArray(_hx_map))
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_OrtingoAPIComments._instance is None):
            com_sdtk_api_OrtingoAPIComments._instance = com_sdtk_api_OrtingoAPIComments()
        return com_sdtk_api_OrtingoAPIComments._instance


class com_sdtk_api_SSRSAPI(com_sdtk_api_API):

    def __init__(self):
        self._site = None
        self._user = None
        self._executionId = None
        self._token = None
        super().__init__("SSRS")

    def getAuthorizationHeader(self):
        return "Cookie"

    def getAuthorizationHeaderBearer(self):
        return ""

    def getAccessToken(self):
        return self._token
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_SSRSAPI._instance is None):
            com_sdtk_api_SSRSAPI._instance = com_sdtk_api_SSRSAPI()
        return com_sdtk_api_SSRSAPI._instance

    @staticmethod
    def pull(callback,user,password,site,view,format = None):
        if (format is None):
            format = "CSV"
        instance = com_sdtk_api_SSRSAPI.instance()
        def _hx_local_2(response):
            instance1 = instance
            tmp = ((HxOverrides.stringOrNull(com_sdtk_api_SSRSAPI._ssrsRoot1) + ("null" if site is None else site)) + HxOverrides.stringOrNull(com_sdtk_api_SSRSAPI._ssrsRoot2))
            tmp1 = com_sdtk_api_SSRSAPI._viewAPI
            _g = haxe_ds_StringMap()
            _g.h["report"] = view
            def _hx_local_1(response):
                instance1 = instance
                tmp = ((HxOverrides.stringOrNull(com_sdtk_api_SSRSAPI._ssrsRoot1) + ("null" if site is None else site)) + HxOverrides.stringOrNull(com_sdtk_api_SSRSAPI._ssrsRoot2))
                tmp1 = com_sdtk_api_SSRSAPI._viewAPI
                _g = haxe_ds_StringMap()
                _g.h["report"] = view
                _g.h["format"] = format
                _g.h["parameters"] = None
                _g.h["executionId"] = instance._executionId
                def _hx_local_0(response):
                    callback(response)
                instance1.fetch("POST",tmp,tmp1,None,None,None,com_sdtk_api_SSRSAPI.getSoapEnvelope("Render",_g),_hx_local_0)
            instance1.fetch("POST",tmp,tmp1,None,None,None,com_sdtk_api_SSRSAPI.getSoapEnvelope("LoadReport",_g),_hx_local_1)
        com_sdtk_api_SSRSAPI.login(_hx_local_2,user,password,site)

    @staticmethod
    def pullAPI():
        return com_sdtk_api_SSRSAPIPull.instance()

    @staticmethod
    def login(callback,user,password,site):
        instance = com_sdtk_api_SSRSAPI.instance()
        if (((user == instance._user) and ((site == instance._site))) and ((instance._token is not None))):
            callback(True)
        else:
            instance1 = instance
            tmp = ((HxOverrides.stringOrNull(com_sdtk_api_SSRSAPI._ssrsRoot1) + ("null" if site is None else site)) + HxOverrides.stringOrNull(com_sdtk_api_SSRSAPI._ssrsRoot2))
            tmp1 = com_sdtk_api_SSRSAPI._viewAPI
            _g = haxe_ds_StringMap()
            _g.h["username"] = user
            _g.h["password"] = password
            def _hx_local_0(response):
                instance._executionId = com_sdtk_api_SSRSAPI.getSessionId(response)
                instance._token = Reflect.field(response,"cookie")
                instance._user = user
                instance._site = site
                callback(response)
            instance1.fetch("POST",tmp,tmp1,None,None,None,com_sdtk_api_SSRSAPI.getSoapEnvelope("LogonUser",_g),_hx_local_0)

    @staticmethod
    def getSoapEnvelope(method,args):
        soapNs = "http://schemas.xmlsoap.org/soap/envelope/"
        soapEnv = Xml.createElement("soapenv:Envelope")
        soapEnv.set("xmlns:soapenv",soapNs)
        soapEnv.set("xmlns:ser","http://schemas.microsoft.com/sqlserver/2005/06/30/reporting/reportingservices")
        soapHeader = Xml.createElement("soapenv:Header")
        soapBody = Xml.createElement("soapenv:Body")
        soapMethod = Xml.createElement(("ser:" + ("null" if method is None else method)))
        key = args.keys()
        while key.hasNext():
            key1 = key.next()
            _this = Xml.createElement(key1)
            v = args.h.get(key1,None)
            if ((_this.nodeType == Xml.Document) or ((_this.nodeType == Xml.Element))):
                raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((_this.nodeType is None)) else _Xml_XmlType_Impl_.toString(_this.nodeType))))))
            _this.nodeValue = v
        soapEnv.addChild(soapHeader)
        soapEnv.addChild(soapBody)
        return haxe_xml_Printer.print(soapEnv)

    @staticmethod
    def getSessionId(response):
        doc = Xml.parse(response)
        _this = doc.firstElement().firstElement().elementsNamed("ExecutionID").next()
        if ((_this.nodeType == Xml.Document) or ((_this.nodeType == Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((_this.nodeType is None)) else _Xml_XmlType_Impl_.toString(_this.nodeType))))))
        return _this.nodeValue


class com_sdtk_api_SSRSAPIPull(com_sdtk_api_InputAPI):

    def __init__(self):
        super().__init__("Reporting - SQL Server Reporting Services - View")

    def getInputNames(self):
        return ["user", "password", "site", "view"]

    def retrieveData(self,mapping,callback):
        _gthis = self
        mapping = self.normalizeMapping(mapping)
        def _hx_local_0(r):
            _gthis.parseData(r,mapping,callback)
        com_sdtk_api_SSRSAPI.pull(_hx_local_0,mapping.h.get("user",None),mapping.h.get("password",None),mapping.h.get("site",None),mapping.h.get("view",None))

    def parseData(self,data,mapping,callback):
        callback(data,com_sdtk_table_ArrayOfObjectsReader.readWholeArray(Reflect.field(com_sdtk_std_Normalize.parseJson(data),"token_transfers")))
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_SSRSAPIPull._instance is None):
            com_sdtk_api_SSRSAPIPull._instance = com_sdtk_api_SSRSAPIPull()
        return com_sdtk_api_SSRSAPIPull._instance


class com_sdtk_api_TableauAPI(com_sdtk_api_API):

    def __init__(self):
        self._site = None
        self._user = None
        self._token = None
        super().__init__("Tableau")

    def getAuthorizationHeader(self):
        return "X-Tableau-Auth"

    def getAuthorizationHeaderBearer(self):
        return ""

    def getAccessToken(self):
        return self._token
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_TableauAPI._instance is None):
            com_sdtk_api_TableauAPI._instance = com_sdtk_api_TableauAPI()
        return com_sdtk_api_TableauAPI._instance

    @staticmethod
    def pull(callback,user,password,site,view):
        def _hx_local_1(response):
            def _hx_local_0(r):
                callback(r)
            com_sdtk_api_TableauAPI.instance().fetch("GET",com_sdtk_api_TableauAPI._tableauRoot,(((("null" if site is None else site) + HxOverrides.stringOrNull(com_sdtk_api_TableauAPI._viewAPI)) + ("null" if view is None else view)) + HxOverrides.stringOrNull(com_sdtk_api_TableauAPI._dataAPI)),None,True,None,None,_hx_local_0)
        com_sdtk_api_TableauAPI.login(_hx_local_1,user,password,site)

    @staticmethod
    def pullAPI():
        return com_sdtk_api_TableauAPIPull.instance()

    @staticmethod
    def login(callback,user,password,site):
        instance = com_sdtk_api_TableauAPI.instance()
        if (((user == instance._user) and ((site == instance._site))) and ((instance._token is not None))):
            callback(True)
        else:
            params = _hx_AnonObject({'credentials': _hx_AnonObject({'name': user, 'password': password, 'site': _hx_AnonObject({'contentUrl': site})})})
            def _hx_local_0(response):
                instance._token = Reflect.field(Reflect.field(com_sdtk_std_Normalize.parseJson(response),"credentials"),"token")
                instance._user = user
                instance._site = site
                callback(response)
            instance.fetch("POST",com_sdtk_api_TableauAPI._tableauSigninRoot,com_sdtk_api_TableauAPI._signinAPI,None,None,None,haxe_format_JsonPrinter.print(params,None,None),_hx_local_0)


class com_sdtk_api_TableauAPIPull(com_sdtk_api_InputAPI):

    def __init__(self):
        super().__init__("Reporting - Tableau - View")

    def getInputNames(self):
        return ["user", "password", "site", "view"]

    def retrieveData(self,mapping,callback):
        _gthis = self
        mapping = self.normalizeMapping(mapping)
        def _hx_local_0(r):
            _gthis.parseData(r,mapping,callback)
        com_sdtk_api_TableauAPI.pull(_hx_local_0,mapping.h.get("user",None),mapping.h.get("password",None),mapping.h.get("site",None),mapping.h.get("view",None))

    def parseData(self,data,mapping,callback):
        callback(data,com_sdtk_table_ArrayOfObjectsReader.readWholeArray(Reflect.field(com_sdtk_std_Normalize.parseJson(data),"token_transfers")))
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_TableauAPIPull._instance is None):
            com_sdtk_api_TableauAPIPull._instance = com_sdtk_api_TableauAPIPull()
        return com_sdtk_api_TableauAPIPull._instance


class com_sdtk_api_TensorflowAPI(com_sdtk_api_API):

    def __init__(self):
        super().__init__("Tensorflow")

    def startInit(self,callback):
        def _hx_local_0():
            callback()
        self.load("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest",_hx_local_0)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_TensorflowAPI._instance is None):
            com_sdtk_api_TensorflowAPI._instance = com_sdtk_api_TensorflowAPI()
        return com_sdtk_api_TensorflowAPI._instance

    @staticmethod
    def createModel(_hx_type):
        pass


class com_sdtk_api_TortoiseTTSAPI(com_sdtk_api_API):

    def __init__(self):
        super().__init__("TortoiseTTS")

    def convert(self,callback,query,voice):
        def _hx_local_0(text,audio,tts,voiceSamples,conditioningLatents):
            import torchaudio
            temp = (((HxOverrides.stringOrNull(python_lib_Tempfile.gettempdir()) + "/SDTK-TTS-") + Std.string(len(audio))) + ".mp3")
            audio.append(temp)
            pcm_audio = tts.tts_with_preset(text, voice_samples=voiceSamples, conditioning_latents=conditioningLatents)
            torchaudio.save(temp, pcm_audio.squeeze(0).cpu(), 24000)
        generateAudioSegment = _hx_local_0
        def _hx_local_2(audio,query,voice):
            r = EReg("[.;,:'\"\\(\\)\\[\\]\n]+","g")
            text = r.split(query)
            query = None
            voiceSamples = None
            conditioningLatents = None
            from tortoise.api import TextToSpeech, MODELS_DIR
            from tortoise.utils.audio import load_voice
            [voiceSamples, conditioningLatents] = load_voice(voice)
            tts = TextToSpeech()
            _g = 0
            while (_g < len(text)):
                t = (text[_g] if _g >= 0 and _g < len(text) else None)
                _g = (_g + 1)
                generateAudioSegment(t,audio,tts,voiceSamples,conditioningLatents)
        generateAudio = _hx_local_2
        def _hx_local_5(audio):
            import torch
            import torchaudio
            audioData = None
            _g = 0
            while (_g < len(audio)):
                file = (audio[_g] if _g >= 0 and _g < len(audio) else None)
                _g = (_g + 1)
                fileData = None
                fileData, _ = torchaudio.load(file)
                if (audioData is None):
                    audioData = fileData
                else:
                    audioData = torch.cat((audioData, fileData), dim=1)
            _g = 0
            while (_g < len(audio)):
                file = (audio[_g] if _g >= 0 and _g < len(audio) else None)
                _g = (_g + 1)
                sys_FileSystem.deleteFile(file)
            return audioData
        mergeAudio = _hx_local_5
        audio = list()
        generateAudio(audio,query,voice)
        result = mergeAudio(audio)
        callback(query,result)

    def convertToFile(self,callback,query,voice,file):
        def _hx_local_0(query,result):
            import torchaudio
            torchaudio.save(file, result.cpu(), 24000)
        self.convert(_hx_local_0,query,voice)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_api_TortoiseTTSAPI._instance is None):
            com_sdtk_api_TortoiseTTSAPI._instance = com_sdtk_api_TortoiseTTSAPI()
        return com_sdtk_api_TortoiseTTSAPI._instance


class com_sdtk_api_WriterAPI(com_sdtk_api_API):

    def __init__(self,name):
        super().__init__(name)

    def isFormat(self):
        return False

    def createWriter(self,mapping,w,finish,header):
        return None

    def getInputNames(self):
        return None

    def scriptable(self):
        return False


class com_sdtk_calendar_CalendarInviteFormat:
    pass


class com_sdtk_calendar_ACMEventFormat:

    def __init__(self):
        pass

    def convertDateTime(self,dDateTime):
        return dDateTime.toString()

    def convert(self,ciInvite,wWriter):
        mMap = haxe_ds_StringMap()
        mMap.h["created-at"] = ciInvite.created
        mMap.h["start-time"] = ciInvite.start
        mMap.h["title"] = ciInvite.summary
        mMap.h["link"] = ciInvite.url
        com_sdtk_table_JSONHandler.instance().write(wWriter,mMap,None,-1)

    def convertToString(self,ciInvite):
        sw = com_sdtk_std_StringWriter(None)
        self.convert(ciInvite,sw)
        return sw.toString()

    def toArray(self,field,d):
        a = list()
        if Std.isOfType(d,list):
            aD = d
            _g = 0
            while (_g < len(aD)):
                d1 = (aD[_g] if _g >= 0 and _g < len(aD) else None)
                _g = (_g + 1)
                mMap = com_sdtk_std_Normalize.nativeToHaxe(d1)
                if (field in mMap.h):
                    s = mMap.h.get(field,None)
                    if ((s is not None) and ((len(s) > 0))):
                        a.append(s)
        else:
            return self.toArray(field,[d])
        return a

    def merge(self,mMap,sSeparator,aFields):
        s_b = python_lib_io_StringIO()
        bFirst = True
        _g = 0
        while (_g < len(aFields)):
            sField = (aFields[_g] if _g >= 0 and _g < len(aFields) else None)
            _g = (_g + 1)
            v = mMap.h.get(sField,None)
            if ((v is not None) and ((Reflect.field(v,"length") > 0))):
                if bFirst:
                    bFirst = False
                else:
                    s_b.write(Std.string(sSeparator))
                s_b.write(Std.string(v))
        return s_b.getvalue()

    def read(self,rReader):
        ciInvite = com_sdtk_calendar_CalendarInvite()
        mMap = None
        if Std.isOfType(rReader,com_sdtk_table_DataTableRowReader):
            rr = rReader
            mMap = rr.toHaxeMap(None)
        elif Std.isOfType(rReader,com_sdtk_std_Reader):
            mMap = com_sdtk_table_JSONHandler.instance().read(rReader)
        else:
            mMap = com_sdtk_std_Normalize.nativeToHaxe(rReader)
        ciInvite.created = mMap.h.get("date",None)
        ciInvite.start = mMap.h.get("date",None)
        ciInvite.summary = mMap.h.get("title",None)
        ciInvite.url = mMap.h.get("link",None)
        ciInvite.format = self
        return ciInvite

    def arrayToReader(self,aArray):
        return None

    def mapToReader(self,aArray):
        return None

    def validColumns(self):
        return ["created", "start", "summary", "url"]
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_calendar_ACMEventFormat._instance is None):
            com_sdtk_calendar_ACMEventFormat._instance = com_sdtk_calendar_ACMEventFormat()
        return com_sdtk_calendar_ACMEventFormat._instance


class com_sdtk_calendar_AbstractCalendarInviteFormat:

    def __init__(self,sDateTimeFormat,sStartOfFile,sEndOfFile,sUID,sCreated,sStart,sEnd,sSummary,sSeparator,sLineEnd,iLimit):
        self.sDateTimeFormat = sDateTimeFormat
        self._startOfFile = sStartOfFile
        self._endOfFile = sEndOfFile
        self._uid = sUID
        self._created = sCreated
        self._start = sStart
        self._end = sEnd
        self._summary = sSummary
        self._separator = sSeparator
        self._lineEnd = sLineEnd
        self._limit = iLimit

    def convertDateTime(self,dDateTime):
        return DateTools.format(dDateTime,self.sDateTimeFormat)

    def toDateTime(self,sValue):
        try:
            return Date(Std.parseInt(HxString.substring(sValue,0,4)),Std.parseInt(HxString.substr(sValue,4,2)),Std.parseInt(HxString.substr(sValue,6,2)),Std.parseInt(HxString.substr(sValue,9,2)),Std.parseInt(HxString.substr(sValue,11,2)),Std.parseInt(HxString.substr(sValue,13,2)))
        except BaseException as _g:
            None
            return None

    def convert(self,ciInvite,wWriter):
        wWriter.start()
        if (self._startOfFile is not None):
            wWriter.write(self._startOfFile)
        if ((self._uid is not None) and ((ciInvite.uid is not None))):
            wWriter.write(self._uid)
            wWriter.write(self._separator)
            wWriter.write(ciInvite.uid)
            wWriter.write(self._lineEnd)
        if ((self._created is not None) and ((ciInvite.created is not None))):
            wWriter.write(self._created)
            wWriter.write(self._separator)
            wWriter.write(self.convertDateTime(ciInvite.created))
            wWriter.write(self._lineEnd)
        if ((self._start is not None) and ((ciInvite.start is not None))):
            wWriter.write(self._start)
            wWriter.write(self._separator)
            wWriter.write(self.convertDateTime(ciInvite.start))
            wWriter.write(self._lineEnd)
        if ((self._end is not None) and ((ciInvite.end is not None))):
            wWriter.write(self._end)
            wWriter.write(self._separator)
            wWriter.write(self.convertDateTime(ciInvite.end))
            wWriter.write(self._lineEnd)
        if ((self._summary is not None) and ((ciInvite.summary is not None))):
            wWriter.write(self._summary)
            wWriter.write(self._separator)
            wWriter.write(ciInvite.summary)
            wWriter.write(self._lineEnd)
        if (self._endOfFile is not None):
            wWriter.write(self._endOfFile)
        wWriter.dispose()

    def convertToString(self,ciInvite):
        wWriter = com_sdtk_std_StringWriter(None)
        self.convert(ciInvite,wWriter)
        return wWriter.toString()

    def read(self,rReader):
        ciInvite = com_sdtk_calendar_CalendarInvite()
        ciInvite.format = self
        sbBuffer = StringBuf()
        sCurrentLabel = ""
        rReader.start()
        while rReader.hasNext():
            c = rReader.next()
            if (c == self._lineEnd):
                if (sbBuffer.get_length() > 0):
                    sValue = sbBuffer.b.getvalue()
                    if (sCurrentLabel == self._uid):
                        ciInvite.uid = sValue
                    elif (sCurrentLabel == self._created):
                        ciInvite.created = self.toDateTime(sValue)
                    elif (sCurrentLabel == self._start):
                        ciInvite.start = self.toDateTime(sValue)
                    elif (sCurrentLabel == self._end):
                        ciInvite.end = self.toDateTime(sValue)
                    elif (sCurrentLabel == self._summary):
                        ciInvite.summary = sValue
                    sbBuffer = StringBuf()
            elif (c == self._separator):
                sLabel = sbBuffer.b.getvalue()
                sbBuffer = StringBuf()
            elif (sbBuffer.get_length() < self._limit):
                s = Std.string(c)
                sbBuffer.b.write(s)
        return ciInvite

    def arrayToReader(self,aArray):
        return None

    def mapToReader(self,aArray):
        return None

    def validColumns(self):
        return ["created", "start", "end", "uid"]


class com_sdtk_calendar_BTCFormat:

    def __init__(self):
        pass

    def convertDateTime(self,dDateTime):
        return dDateTime.toString()

    def convert(self,ciInvite,wWriter):
        mMap = haxe_ds_StringMap()
        mAttributes = haxe_ds_StringMap()
        iTime = ((ciInvite.created.date.timestamp() * 1000) / 1000)
        mMap.h["block_time"] = iTime
        mMap.h["hash"] = ciInvite.uid
        com_sdtk_table_JSONHandler.instance().write(wWriter,mMap,None,-1)

    def convertToString(self,ciInvite):
        sw = com_sdtk_std_StringWriter(None)
        self.convert(ciInvite,sw)
        return sw.toString()

    def toArray(self,field,d):
        a = list()
        if Std.isOfType(d,list):
            aD = d
            _g = 0
            while (_g < len(aD)):
                d = (aD[_g] if _g >= 0 and _g < len(aD) else None)
                _g = (_g + 1)
                mMap = com_sdtk_std_Normalize.nativeToHaxe(d)
                if (field in mMap.h):
                    s = mMap.h.get(field,None)
                    if ((s is not None) and ((len(s) > 0))):
                        a.append(s)
        return a

    def read(self,rReader):
        ciInvite = com_sdtk_calendar_CalendarInvite()
        mMap = None
        if Std.isOfType(rReader,com_sdtk_table_DataTableRowReader):
            rr = rReader
            mMap = rr.toHaxeMap(None)
        elif Std.isOfType(rReader,com_sdtk_std_Reader):
            mMap = com_sdtk_table_JSONHandler.instance().read(rReader)
        else:
            mMap = com_sdtk_std_Normalize.nativeToHaxe(rReader)
        ciInvite.created = Date.fromTime((mMap.h.get("block_time",None) * 1000))
        ciInvite.start = ciInvite.created
        ciInvite.end = ciInvite.created
        ciInvite.uid = mMap.h.get("hash",None)
        ciInvite.groupUid = mMap.h.get("block_hash",None)
        ciInvite.cost = mMap.h.get("fee",None)
        ciInvite._hx_from = self.toArray("prev_addresses",mMap.h.get("inputs",None))
        ciInvite.to = self.toArray("addresses",mMap.h.get("outputs",None))
        ciInvite.format = self
        return ciInvite

    def arrayToReader(self,aArray):
        return None

    def mapToReader(self,aArray):
        return None

    def validColumns(self):
        return ["created", "start", "end", "uid", "groupUid", "cost", "from", "to"]
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_calendar_BTCFormat._instance is None):
            com_sdtk_calendar_BTCFormat._instance = com_sdtk_calendar_BTCFormat()
        return com_sdtk_calendar_BTCFormat._instance


class com_sdtk_calendar_BitTorrentFormat:

    def __init__(self):
        pass

    def convertDateTime(self,dDateTime):
        return dDateTime.toString()

    def convert(self,ciInvite,wWriter):
        mMap = haxe_ds_StringMap()
        mAttributes = haxe_ds_StringMap()
        iTime = (ciInvite.created.date.timestamp() * 1000)
        mMap.h["timeStamp"] = iTime
        mMap.h["hash"] = ciInvite.uid
        mMap.h["block"] = ciInvite.groupUid
        mMap.h["ownerAddress"] = ciInvite._hx_from
        mMap.h["toAddress"] = ciInvite.to
        com_sdtk_table_JSONHandler.instance().write(wWriter,mMap,None,-1)

    def convertToString(self,ciInvite):
        sw = com_sdtk_std_StringWriter(None)
        self.convert(ciInvite,sw)
        return sw.toString()

    def read(self,rReader):
        ciInvite = com_sdtk_calendar_CalendarInvite()
        mMap = None
        if Std.isOfType(rReader,com_sdtk_table_DataTableRowReader):
            rr = rReader
            mMap = rr.toHaxeMap(None)
        elif Std.isOfType(rReader,com_sdtk_std_Reader):
            mMap = com_sdtk_table_JSONHandler.instance().read(rReader)
        else:
            mMap = com_sdtk_std_Normalize.nativeToHaxe(rReader)
        mCost = mMap.h.get("cost",None)
        if (mCost is None):
            mCost = mMap
        else:
            mCost = com_sdtk_std_Normalize.nativeToHaxe(mCost)
        ciInvite.created = Date.fromTime(mMap.h.get("timestamp",None))
        ciInvite.start = ciInvite.created
        ciInvite.end = ciInvite.created
        ciInvite.groupUid = mMap.h.get("block",None)
        ciInvite.cost = mCost.h.get("gas",None)
        ciInvite._hx_from = mMap.h.get("ownerAddress",None)
        ciInvite.to = mMap.h.get("toAddress",None)
        ciInvite.uid = mMap.h.get("hash",None)
        ciInvite.format = self
        return ciInvite

    def arrayToReader(self,aArray):
        return None

    def mapToReader(self,aArray):
        return None

    def validColumns(self):
        return ["created", "start", "end", "uid", "from", "to", "cost", "groupUid"]
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_calendar_BitTorrentFormat._instance is None):
            com_sdtk_calendar_BitTorrentFormat._instance = com_sdtk_calendar_BitTorrentFormat()
        return com_sdtk_calendar_BitTorrentFormat._instance


class com_sdtk_calendar_BrowserTaskScheduler:

    def __init__(self,_hx_exec = None):
        if (_hx_exec is None):
            _hx_exec = False
        self._tasks = list()
        self._exec = False
        self._exec = _hx_exec

    def _hx_exec(self,writer,command):
        if (writer is not None):
            writer.write(command)
        tmp = self._exec
        return None

    def createTask(self,writer,event):
        newEvent = com_sdtk_calendar_BrowserTask()
        taskIn = ""
        if (event.actionExecuteIn is not None):
            taskIn = (HxOverrides.stringOrNull(event.actionExecuteIn) + ".")
        taskParameters = ""
        if ((event.actionExecuteParameters is not None) and ((len(event.actionExecuteParameters) > 0))):
            _this = event.actionExecuteParameters
            taskParameters = (("\"" + HxOverrides.stringOrNull("\", \"".join([python_Boot.toString1(x1,'') for x1 in _this]))) + "\"")
        task = ((((((("function() {\n" + "\t") + ("null" if taskIn is None else taskIn)) + HxOverrides.stringOrNull(event.actionExecute)) + "(") + ("null" if taskParameters is None else taskParameters)) + "\t);") + "}")
        newEvent.command = (((((((((((((("setTimeout(" + ("null" if task is None else task)) + ", new Date(") + Std.string(event.start.date.year)) + ", ") + Std.string(((event.start.date.month - 1)))) + ", ") + Std.string(event.start.date.day)) + ", ") + Std.string(event.start.date.hour)) + ", ") + Std.string(event.start.date.minute)) + ", ") + Std.string(event.start.date.second)) + ") - Date.now())")
        newEvent.id = self._hx_exec(writer,newEvent.command)
        newEvent.event = event
        return newEvent


class com_sdtk_calendar_BrowserTask:

    def __init__(self):
        self.event = None
        self.command = None
        self.id = None


class com_sdtk_calendar_CalendarInvite:

    def __init__(self):
        self.format = None
        self.url = None
        self.location = None
        self.cost = None
        self._hx_from = None
        self.to = None
        self.hosts = None
        self.actionExecuteParameters = None
        self.actionExecuteIn = None
        self.actionExecute = None
        self.schedulingType = None
        self.groupUid = None
        self.uid = None
        self.summary = None
        self.end = None
        self.start = None
        self.created = None

    def __str__(self):
        sb_b = python_lib_io_StringIO()
        if (self.format is None):
            _g = 0
            _g1 = python_Boot.fields(self)
            while (_g < len(_g1)):
                field = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (field != "format"):
                    sb_b.write(Std.string((((("null" if field is None else field) + ": ") + Std.string(Reflect.field(self,field))) + "\n")))
        else:
            _g = 0
            _g1 = self.format.validColumns()
            while (_g < len(_g1)):
                field = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                sb_b.write(Std.string((((("null" if field is None else field) + ": ") + Std.string(Reflect.field(self,field))) + "\n")))
        return sb_b.getvalue()


class com_sdtk_calendar_ConsoleFormat(com_sdtk_calendar_AbstractCalendarInviteFormat):

    def __init__(self):
        super().__init__("%y-%m-%d T%H%M%SZ",None,None,"UID","Created","Start","End","Summary",": ","\n",1024)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_calendar_ConsoleFormat._instance is None):
            com_sdtk_calendar_ConsoleFormat._instance = com_sdtk_calendar_ConsoleFormat()
        return com_sdtk_calendar_ConsoleFormat._instance


class com_sdtk_calendar_Create:

    @staticmethod
    def main():
        pParameters = com_sdtk_calendar_Parameters()
        if pParameters.getNothing():
            cifOutputFormat = com_sdtk_calendar_ICS.instance()
            cifOutputFormat.convert(pParameters.getInvite(),com_sdtk_std_StdoutWriter())
        elif pParameters.getInvalid():
            return
        elif ((pParameters.getInput() is not None) and ((pParameters.getOutput() is not None))):
            cifInputFormat = com_sdtk_calendar_ICS.instance()
            cifOutputFormat = com_sdtk_calendar_ICS.instance()
            ciInvite = cifInputFormat.read(com_sdtk_std_FileReader(pParameters.getInput()))
            cifOutputFormat.convert(ciInvite,com_sdtk_std_FileWriter(pParameters.getOutput(),False))
        elif (pParameters.getInput() is not None):
            cifInputFormat = com_sdtk_calendar_ICS.instance()
            ciInvite = cifInputFormat.read(com_sdtk_std_FileReader(pParameters.getInput()))
            cifOutputFormat = com_sdtk_calendar_ConsoleFormat.instance()
            cifOutputFormat.convert(ciInvite,com_sdtk_std_StdoutWriter())
        else:
            cifOutputFormat = com_sdtk_calendar_ICS.instance()
            cifOutputFormat.convert(pParameters.getInvite(),com_sdtk_std_FileWriter(pParameters.getOutput(),False))


class com_sdtk_calendar_CronSchedulerAbstract:

    def __init__(self,_hx_exec = None):
        if (_hx_exec is None):
            _hx_exec = False
        self._exec = False
        self._exec = _hx_exec

    def _hx_exec(self,writer,command,args,send = None):
        if (writer is not None):
            writer.write((((("null" if command is None else command) + " ") + HxOverrides.stringOrNull(" ".join([python_Boot.toString1(x1,'') for x1 in args]))) + "\n"))
        if self._exec:
            process = sys_io_Process(command,args)
            if (send is not None):
                process.stdin.writeString(send)
                process.stdin.flush()
                process.stdin.close()
            output = process.stdout.readAll().toString()
            process.close()
            return output
        return None

    def getListI(self):
        return self._hx_exec(None,"crontab",["-l"])

    def getList(self,folder,data = None):
        if (data is None):
            data = self.getListI()
        arr = list()
        r = com_sdtk_std_StringReader(data)
        field = 0
        minute = StringBuf()
        hour = StringBuf()
        dayOfMonth = StringBuf()
        month = StringBuf()
        dayOfWeek = StringBuf()
        command = StringBuf()
        while True:
            c = r.next()
            if (c is None):
                break
            elif (c is None):
                field1 = field
                if (field1 == 0):
                    s = Std.string(c)
                    minute.b.write(s)
                    break
                elif (field1 == 1):
                    s1 = Std.string(c)
                    hour.b.write(s1)
                    break
                elif (field1 == 2):
                    s2 = Std.string(c)
                    dayOfMonth.b.write(s2)
                    break
                elif (field1 == 3):
                    s3 = Std.string(c)
                    month.b.write(s3)
                    break
                elif (field1 == 4):
                    s4 = Std.string(c)
                    dayOfWeek.b.write(s4)
                    break
                elif (field1 == 5):
                    s5 = Std.string(c)
                    command.b.write(s5)
                    break
                else:
                    pass
            else:
                c1 = c
                if (c1 == "\n"):
                    field = 0
                    x = com_sdtk_calendar_CronSchedulerTaskToMap.build(minute.b.getvalue(),hour.b.getvalue(),dayOfMonth.b.getvalue(),month.b.getvalue(),dayOfWeek.b.getvalue(),command.b.getvalue())
                    arr.append(x)
                    minute = StringBuf()
                    hour = StringBuf()
                    dayOfMonth = StringBuf()
                    month = StringBuf()
                    dayOfWeek = StringBuf()
                    command = StringBuf()
                    break
                elif (c1 == " "):
                    if (field < 5):
                        field = (field + 1)
                    else:
                        s6 = Std.string(c)
                        command.b.write(s6)
                    break
                else:
                    field2 = field
                    if (field2 == 0):
                        s7 = Std.string(c)
                        minute.b.write(s7)
                        break
                    elif (field2 == 1):
                        s8 = Std.string(c)
                        hour.b.write(s8)
                        break
                    elif (field2 == 2):
                        s9 = Std.string(c)
                        dayOfMonth.b.write(s9)
                        break
                    elif (field2 == 3):
                        s10 = Std.string(c)
                        month.b.write(s10)
                        break
                    elif (field2 == 4):
                        s11 = Std.string(c)
                        dayOfWeek.b.write(s11)
                        break
                    elif (field2 == 5):
                        s12 = Std.string(c)
                        command.b.write(s12)
                        break
                    else:
                        pass
        return arr

    def createTask(self,writer,folder,task,data = None):
        if (data is None):
            data = self.getListI()
        if (folder is not None):
            task = ((("/" + Std.string(folder)) + "/") + ("null" if task is None else task))
        startIndex = None
        if (((data.find(task) if ((startIndex is None)) else HxString.indexOfImpl(data,task,startIndex))) < 0):
            if (writer is None):
                self._hx_exec(writer,"crontab",["-"],(((("null" if data is None else data) + "\n") + "* * * * * ") + ("null" if task is None else task)))
        return ((("/" + Std.string(folder)) + "/") + ("null" if task is None else task))

    def deleteTask(self,writer,folder,task,data = None,add = None):
        if (add is None):
            add = ""
        if (data is None):
            data = self.getListI()
        if (folder is not None):
            task = ((("/" + Std.string(folder)) + "/") + ("null" if task is None else task))
        startIndex = None
        index = (data.find(task) if ((startIndex is None)) else HxString.indexOfImpl(data,task,startIndex))
        if (index >= 0):
            startIndex = index
            start = None
            if (startIndex is None):
                start = data.rfind("\n", 0, len(data))
            else:
                i = data.rfind("\n", 0, (startIndex + 1))
                startLeft = (max(0,((startIndex + 1) - len("\n"))) if ((i == -1)) else (i + 1))
                check = data.find("\n", startLeft, len(data))
                start = (check if (((check > i) and ((check <= startIndex)))) else i)
            end = (data.find("\n") if ((index is None)) else HxString.indexOfImpl(data,"\n",index))
            if (writer is None):
                self._hx_exec(writer,"crontab",["-"],((HxOverrides.stringOrNull(HxString.substring(data,0,start)) + HxOverrides.stringOrNull(HxString.substring(data,(end + 1),None))) + ("null" if add is None else add)))

    def updateTaskForDate(self,writer,task,start,end):
        pass

    def updateTaskForSchedule(self,writer,task,schedulingType):
        schedule = "* * * * *"
        tmp = schedulingType.index
        if (tmp == 0):
            self.deleteTask(writer,None,task)
            return
        elif (tmp == 1):
            schedule = "0 * * * *"
        elif (tmp == 2):
            schedule = "0 0 * * *"
        elif (tmp == 3):
            schedule = "0 0 * * 0"
        elif (tmp == 4):
            schedule = "0 0 1 * *"
        elif (tmp == 5):
            schedule = "0 0 1 1 *"
        else:
            pass
        self.deleteTask(writer,task,schedule,None,((("\n" + ("null" if schedule is None else schedule)) + " ") + Std.string(task)))

    def updateTaskForAction(self,writer,task,cmd,arguments,workingDirectory):
        pass


class com_sdtk_calendar_CronSchedulerExecutor(com_sdtk_calendar_CronSchedulerAbstract):

    def __init__(self):
        super().__init__(True)

    def convert(self,ciInvite,folder):
        task = self.createTask(None,folder,ciInvite.summary)
        self.updateTaskForDate(None,task,ciInvite.start,ciInvite.end)
        self.updateTaskForSchedule(None,task,ciInvite.schedulingType)
        self.updateTaskForAction(None,task,ciInvite.actionExecute,ciInvite.actionExecuteParameters,ciInvite.actionExecuteIn)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_calendar_CronSchedulerExecutor._instance is None):
            com_sdtk_calendar_CronSchedulerExecutor._instance = com_sdtk_calendar_CronSchedulerExecutor()
        return com_sdtk_calendar_CronSchedulerExecutor._instance


class com_sdtk_calendar_CronSchedulerText(com_sdtk_calendar_CronSchedulerAbstract):

    def __init__(self):
        super().__init__(False)

    def convert(self,ciInvite,wWriter,folder):
        task = self.createTask(wWriter,folder,ciInvite.summary)
        self.updateTaskForDate(wWriter,task,ciInvite.start,ciInvite.end)
        self.updateTaskForSchedule(wWriter,task,ciInvite.schedulingType)
        self.updateTaskForAction(wWriter,task,ciInvite.actionExecute,ciInvite.actionExecuteParameters,ciInvite.actionExecuteIn)

    def convertToString(self,ciInvite,folder):
        sw = com_sdtk_std_StringWriter(None)
        self.convert(ciInvite,sw,folder)
        sw.dispose()
        return sw.toString()
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_calendar_CronSchedulerText._instance is None):
            com_sdtk_calendar_CronSchedulerText._instance = com_sdtk_calendar_CronSchedulerText()
        return com_sdtk_calendar_CronSchedulerText._instance


class com_sdtk_calendar_CronSchedulerTask:
    pass


class com_sdtk_calendar_CronSchedulerTaskAbstract(com_sdtk_calendar_CalendarInvite):

    def __init__(self):
        super().__init__()

    def startDate(self):
        d = Date.now()
        if (self.hour() != "*"):
            iHour = Std.parseInt(self.hour())
            if (iHour < d.date.hour):
                d = Date.fromTime((((d.date.timestamp() * 1000) + 86400000) - ((((((d.date.hour - iHour)) * 60) * 60) * 1000))))
        if (self.dayOfMonth() != "*"):
            iDayOfMonth = Std.parseInt(self.dayOfMonth())
            if (iDayOfMonth < d.date.day):
                d = Date(d.date.year,(0 if (((d.date.month - 1) >= 11)) else ((d.date.month - 1) + 1)),iDayOfMonth,d.date.hour,d.date.minute,d.date.second)
        if (self.month() != "*"):
            iMonth = Std.parseInt(self.month())
            if (iMonth < (((d.date.month - 1) + 1))):
                d = Date((d.date.year + 1),iMonth,d.date.day,d.date.hour,d.date.minute,d.date.second)
        return d

    def update(self):
        self.created = self.startDate()
        self.start = self.created
        self.end = None
        self.summary = self.command()

    def minute(self):
        return None

    def hour(self):
        return None

    def dayOfMonth(self):
        return None

    def month(self):
        return None

    def dayOfWeek(self):
        return None

    def command(self):
        return None


class com_sdtk_calendar_CronSchedulerTaskToMap(com_sdtk_calendar_CronSchedulerTaskAbstract):

    def __init__(self,m):
        self._m = None
        super().__init__()
        self._m = m
        self.update()

    def value(self,v):
        return v

    def minute(self):
        return self.value(self._m.h.get("minute",None))

    def hour(self):
        return self.value(self._m.h.get("hour",None))

    def dayOfMonth(self):
        return self.value(self._m.h.get("dayOfMonth",None))

    def month(self):
        return self.value(self._m.h.get("month",None))

    def dayOfWeek(self):
        return self.value(self._m.h.get("dayOfWeek",None))

    def command(self):
        return self.value(self._m.h.get("command",None))

    @staticmethod
    def build(minute,hour,dayOfMonth,month,dayOfWeek,command):
        _hx_map = haxe_ds_StringMap()
        _hx_map.h["minute"] = minute
        _hx_map.h["hour"] = hour
        _hx_map.h["dayOfMonth"] = dayOfMonth
        _hx_map.h["month"] = month
        _hx_map.h["dayOfWeek"] = dayOfWeek
        _hx_map.h["command"] = command
        return com_sdtk_calendar_CronSchedulerTaskToMap(_hx_map)


class com_sdtk_calendar_EtherscanFormat:

    def __init__(self):
        pass

    def convertDateTime(self,dDateTime):
        return dDateTime.toString()

    def convert(self,ciInvite,wWriter):
        mMap = haxe_ds_StringMap()
        mAttributes = haxe_ds_StringMap()
        iTime = ((ciInvite.created.date.timestamp() * 1000) / 1000)
        mMap.h["timeStamp"] = iTime
        mMap.h["hash"] = ciInvite.uid
        mMap.h["blockHash"] = ciInvite.groupUid
        com_sdtk_table_JSONHandler.instance().write(wWriter,mMap,None,-1)

    def convertToString(self,ciInvite):
        sw = com_sdtk_std_StringWriter(None)
        self.convert(ciInvite,sw)
        return sw.toString()

    def read(self,rReader):
        ciInvite = com_sdtk_calendar_CalendarInvite()
        mMap = None
        if Std.isOfType(rReader,com_sdtk_table_DataTableRowReader):
            rr = rReader
            mMap = rr.toHaxeMap(None)
        elif Std.isOfType(rReader,com_sdtk_std_Reader):
            mMap = com_sdtk_table_JSONHandler.instance().read(rReader)
        else:
            mMap = com_sdtk_std_Normalize.nativeToHaxe(rReader)
        ciInvite.created = Date.fromTime((Std.parseInt(mMap.h.get("timeStamp",None)) * 1000))
        ciInvite.start = ciInvite.created
        ciInvite.end = ciInvite.created
        ciInvite.groupUid = mMap.h.get("blockHash",None)
        ciInvite.cost = mMap.h.get("gas",None)
        ciInvite._hx_from = mMap.h.get("from",None)
        ciInvite.to = mMap.h.get("to",None)
        ciInvite.uid = mMap.h.get("hash",None)
        ciInvite.format = self
        return ciInvite

    def arrayToReader(self,aArray):
        return None

    def mapToReader(self,aArray):
        return None

    def validColumns(self):
        return ["created", "start", "end", "uid", "from", "to", "cost", "groupUid"]
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_calendar_EtherscanFormat._instance is None):
            com_sdtk_calendar_EtherscanFormat._instance = com_sdtk_calendar_EtherscanFormat()
        return com_sdtk_calendar_EtherscanFormat._instance


class com_sdtk_calendar_Executor:

    def __init__(self):
        pass

    def convert(self,ciInvite,ciNext):
        if ((((ciInvite.start is not None) and (((Date.now().date.timestamp() * 1000) > ((ciInvite.start.date.timestamp() * 1000))))) and ((ciInvite.actionExecute is not None))) and ((ciInvite.actionExecute != ""))):
            orgDir = Sys.getCwd()
            command = ciInvite.actionExecute
            if ((ciInvite.actionExecuteIn is not None) and ((ciInvite.actionExecuteIn != ""))):
                Sys.setCwd(ciInvite.actionExecuteIn)
            additionalParameters = list()
            startIndex = None
            tmp = None
            if (startIndex is None):
                tmp = command.rfind(".py", 0, len(command))
            else:
                i = command.rfind(".py", 0, (startIndex + 1))
                startLeft = (max(0,((startIndex + 1) - len(".py"))) if ((i == -1)) else (i + 1))
                check = command.find(".py", startLeft, len(command))
                tmp = (check if (((check > i) and ((check <= startIndex)))) else i)
            if (tmp == ((len(command) - 3))):
                additionalParameters.append(command)
                command = "python"
            if (ciInvite.actionExecuteParameters is None):
                ciInvite.actionExecuteParameters = list()
            process = sys_io_Process(command,(additionalParameters + ciInvite.actionExecuteParameters))
            output = process.stdout.readAll().toString()
            process.close()
            if ((ciInvite.actionExecuteIn is not None) and ((ciInvite.actionExecuteIn != ""))):
                Sys.setCwd(orgDir)
            if ((ciInvite.schedulingType is not None) and ((ciInvite.schedulingType != com_sdtk_calendar_ScheduleType.NONE))):
                _g = 0
                _g1 = python_Boot.fields(ciInvite)
                while (_g < len(_g1)):
                    field = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    value = Reflect.field(ciInvite,field)
                    setattr(ciNext,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)
                while ((ciNext.start.date.timestamp() * 1000) < ((Date.now().date.timestamp() * 1000))):
                    tmp = ciInvite.schedulingType.index
                    if (tmp == 0):
                        break
                    elif (tmp == 1):
                        ciNext.start = Date(ciInvite.start.date.year,(ciInvite.start.date.month - 1),ciInvite.start.date.day,(ciInvite.start.date.hour + 1),ciInvite.start.date.minute,ciInvite.start.date.second)
                    elif (tmp == 2):
                        ciNext.start = Date(ciInvite.start.date.year,(ciInvite.start.date.month - 1),(ciInvite.start.date.day + 1),ciInvite.start.date.hour,ciInvite.start.date.minute,ciInvite.start.date.second)
                    elif (tmp == 3):
                        ciNext.start = Date(ciInvite.start.date.year,(ciInvite.start.date.month - 1),(ciInvite.start.date.day + 7),ciInvite.start.date.hour,ciInvite.start.date.minute,ciInvite.start.date.second)
                    elif (tmp == 4):
                        ciNext.start = Date(ciInvite.start.date.year,((ciInvite.start.date.month - 1) + 1),ciInvite.start.date.day,ciInvite.start.date.hour,ciInvite.start.date.minute,ciInvite.start.date.second)
                    elif (tmp == 5):
                        ciNext.start = Date((ciInvite.start.date.year + 1),(ciInvite.start.date.month - 1),ciInvite.start.date.day,ciInvite.start.date.hour,ciInvite.start.date.minute,ciInvite.start.date.second)
                    else:
                        pass
            else:
                _g = 0
                _g1 = python_Boot.fields(ciInvite)
                while (_g < len(_g1)):
                    field = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    value = Reflect.field(ciInvite,field)
                    setattr(ciNext,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)
                ciNext.end = ciNext.start
                ciNext.start = None
        else:
            _g = 0
            _g1 = python_Boot.fields(ciInvite)
            while (_g < len(_g1)):
                field = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                value = Reflect.field(ciInvite,field)
                setattr(ciNext,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)

    def convertAll(self,aInvites):
        aiNewInvites = list()
        _g = 0
        while (_g < len(aInvites)):
            ci = (aInvites[_g] if _g >= 0 and _g < len(aInvites) else None)
            _g = (_g + 1)
            ciNext = com_sdtk_calendar_CalendarInvite()
            self.convert(ci,ciNext)
            aiNewInvites.append(ciNext)
        return aiNewInvites

    def convertDateTime(self,dDateTime):
        return None

    def convertToString(self,ciInvite):
        return None

    def read(self,rReader):
        return None

    def arrayToReader(self,aArray):
        return None

    def mapToReader(self,aArray):
        return None

    def validColumns(self):
        return None
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_calendar_Executor._instance is None):
            com_sdtk_calendar_Executor._instance = com_sdtk_calendar_Executor()
        return com_sdtk_calendar_Executor._instance

    @staticmethod
    def main():
        file = com_sdtk_std_Parameters().getParameter(0)
        row = 0
        reader = None
        writer = None
        if (file is None):
            reader = com_sdtk_table_KeyValueReader.createJSONReader(com_sdtk_std_StdinReader())
            writer = com_sdtk_table_KeyValueWriter.createJSONWriter(com_sdtk_std_StdoutWriter())
        else:
            reader = com_sdtk_table_KeyValueReader.createJSONReader(com_sdtk_std_FileReader(file).convertToStringReader())
            writer = com_sdtk_table_KeyValueWriter.createJSONWriter(com_sdtk_std_FileWriter(file,False))
        reader.start()
        writer.start()
        while reader.hasNext():
            rowReader = reader.next()
            _hx_map = rowReader.toHaxeMap(haxe_ds_StringMap())
            invite = com_sdtk_calendar_CalendarInvite()
            _g = 0
            _g1 = python_Boot.fields(invite)
            while (_g < len(_g1)):
                field = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                v = _hx_map.h.get(field,None)
                if (v is not None):
                    try:
                        v2 = Date.fromString(v)
                        if (v2 is not None):
                            v = v2
                    except BaseException as _g2:
                        None
                    try:
                        v21 = v
                        _g3 = v21.upper()
                        _hx_local_1 = len(_g3)
                        if (_hx_local_1 == 5):
                            if (_g3 == "DAILY"):
                                v = com_sdtk_calendar_ScheduleType.DAILY
                        elif (_hx_local_1 == 4):
                            if (_g3 == "NONE"):
                                v = com_sdtk_calendar_ScheduleType.NONE
                        elif (_hx_local_1 == 7):
                            if (_g3 == "MONTHLY"):
                                v = com_sdtk_calendar_ScheduleType.MONTHLY
                        elif (_hx_local_1 == 6):
                            if (_g3 == "HOURLY"):
                                v = com_sdtk_calendar_ScheduleType.HOURLY
                            elif (_g3 == "WEEKLY"):
                                v = com_sdtk_calendar_ScheduleType.WEEKLY
                            elif (_g3 == "YEARLY"):
                                v = com_sdtk_calendar_ScheduleType.YEARLY
                        else:
                            pass
                    except BaseException as _g4:
                        None
                    try:
                        v22 = v
                        v23 = v22
                        if (v23 == 0):
                            v = com_sdtk_calendar_ScheduleType.NONE
                        elif (v23 == 1):
                            v = com_sdtk_calendar_ScheduleType.HOURLY
                        elif (v23 == 2):
                            v = com_sdtk_calendar_ScheduleType.DAILY
                        elif (v23 == 3):
                            v = com_sdtk_calendar_ScheduleType.WEEKLY
                        elif (v23 == 4):
                            v = com_sdtk_calendar_ScheduleType.MONTHLY
                        elif (v23 == 5):
                            v = com_sdtk_calendar_ScheduleType.YEARLY
                        else:
                            pass
                    except BaseException as _g5:
                        None
                setattr(invite,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),v)
            next = com_sdtk_calendar_CalendarInvite()
            com_sdtk_calendar_Executor.instance().convert(invite,next)
            rowWriter = writer.writeStart(None,row)
            rowWriter.start()
            row = (row + 1)
            column = 0
            _g6 = 0
            _g7 = python_Boot.fields(next)
            while (_g6 < len(_g7)):
                field1 = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
                _g6 = (_g6 + 1)
                rowWriter.write(Reflect.field(next,field1),field1,column)
                column = (column + 1)
            rowReader.dispose()
            rowWriter.dispose()
        reader.dispose()
        writer.dispose()


class com_sdtk_calendar_ICS(com_sdtk_calendar_AbstractCalendarInviteFormat):

    def __init__(self):
        super().__init__("%y%m%dT%H%M%SZ","BEGIN:VCALENDAR\nVERSION:2.0\nPRODID:-//hacksw/handcal//NONSGML v1.0//EN\nBEGIN:VEVENT\n","END:VEVENT\nEND:VCALENDAR","UID","DTSTAMP","DTSTART","DTEND","SUMMARY",":","\n",1024)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_calendar_ICS._instance is None):
            com_sdtk_calendar_ICS._instance = com_sdtk_calendar_ICS()
        return com_sdtk_calendar_ICS._instance


class com_sdtk_calendar_IEEEEventFormat:

    def __init__(self):
        pass

    def convertDateTime(self,dDateTime):
        return dDateTime.toString()

    def convert(self,ciInvite,wWriter):
        mMap = haxe_ds_StringMap()
        mAttributes = haxe_ds_StringMap()
        mMap.h["attributes"] = mAttributes
        mAttributes.h["created-at"] = ciInvite.created
        mAttributes.h["start-time"] = ciInvite.start
        mAttributes.h["end-time"] = ciInvite.end
        mAttributes.h["title"] = ciInvite.summary
        mAttributes.h["uid"] = ciInvite.uid
        mAttributes.h["link"] = ciInvite.url
        com_sdtk_table_JSONHandler.instance().write(wWriter,mMap,None,-1)

    def convertToString(self,ciInvite):
        sw = com_sdtk_std_StringWriter(None)
        self.convert(ciInvite,sw)
        return sw.toString()

    def toArray(self,field,d):
        a = list()
        if Std.isOfType(d,list):
            aD = d
            _g = 0
            while (_g < len(aD)):
                d1 = (aD[_g] if _g >= 0 and _g < len(aD) else None)
                _g = (_g + 1)
                mMap = com_sdtk_std_Normalize.nativeToHaxe(d1)
                if (field in mMap.h):
                    s = mMap.h.get(field,None)
                    if ((s is not None) and ((len(s) > 0))):
                        a.append(s)
        else:
            return self.toArray(field,[d])
        return a

    def merge(self,mMap,sSeparator,aFields):
        s_b = python_lib_io_StringIO()
        bFirst = True
        _g = 0
        while (_g < len(aFields)):
            sField = (aFields[_g] if _g >= 0 and _g < len(aFields) else None)
            _g = (_g + 1)
            v = mMap.h.get(sField,None)
            if ((v is not None) and ((Reflect.field(v,"length") > 0))):
                if bFirst:
                    bFirst = False
                else:
                    s_b.write(Std.string(sSeparator))
                s_b.write(Std.string(v))
        return s_b.getvalue()

    def read(self,rReader):
        ciInvite = com_sdtk_calendar_CalendarInvite()
        mMap = None
        if Std.isOfType(rReader,com_sdtk_table_DataTableRowReader):
            rr = rReader
            mMap = rr.toHaxeMap(None)
        elif Std.isOfType(rReader,com_sdtk_std_Reader):
            mMap = com_sdtk_table_JSONHandler.instance().read(rReader)
        else:
            mMap = com_sdtk_std_Normalize.nativeToHaxe(rReader)
        mAttributes = mMap.h.get("attributes",None)
        if (mAttributes is None):
            mAttributes = mMap
        else:
            mAttributes = com_sdtk_std_Normalize.nativeToHaxe(mAttributes)
        ciInvite.created = mAttributes.h.get("created-at",None)
        ciInvite.start = mAttributes.h.get("start-time",None)
        ciInvite.end = mAttributes.h.get("end-time",None)
        ciInvite.summary = mAttributes.h.get("title",None)
        ciInvite.uid = mAttributes.h.get("uid",None)
        ciInvite.hosts = (self.toArray("name",mAttributes.h.get("primary-host",None)) + self.toArray("name",mAttributes.h.get("cohosts",None)))
        ciInvite.location = self.merge(mAttributes,",",["address1", "address2", "city", "postal-code", "building", "room-number"])
        ciInvite.url = mAttributes.h.get("link",None)
        ciInvite.format = self
        return ciInvite

    def arrayToReader(self,aArray):
        return None

    def mapToReader(self,aArray):
        return None

    def validColumns(self):
        return ["created", "start", "end", "summary", "hosts", "location", "url", "uid"]
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_calendar_IEEEEventFormat._instance is None):
            com_sdtk_calendar_IEEEEventFormat._instance = com_sdtk_calendar_IEEEEventFormat()
        return com_sdtk_calendar_IEEEEventFormat._instance


class com_sdtk_std_Parameters:

    def __init__(self):
        self._arguments = None
        self.getArguments()

    def getArguments(self):
        self._arguments = Sys.args()

    def getParameter(self,i):
        try:
            return (self._arguments[i] if i >= 0 and i < len(self._arguments) else None)
        except BaseException as _g:
            None
            return None

    def length(self):
        return len(self._arguments)

    def isCGI(self):
        return (Sys.environment().h.get("GATEWAY_INTERFACE",None) is not None)

    def isWindows(self):
        _this = Sys.systemName().upper()
        startIndex = None
        return (((_this.find("WIN") if ((startIndex is None)) else HxString.indexOfImpl(_this,"WIN",startIndex))) >= 0)

    def checkLoginLDAP(self,user,password):
        un = None
        if ((com_sdtk_std_Parameters._ldapBaseDN is not None) and ((com_sdtk_std_Parameters._ldapUsersDN is not None))):
            un = ((((("uid=" + ("null" if user is None else user)) + ",") + HxOverrides.stringOrNull(com_sdtk_std_Parameters._ldapUsersDN)) + ",") + HxOverrides.stringOrNull(com_sdtk_std_Parameters._ldapBaseDN))
        else:
            un = user
        import ldap
        connect = ldap.initialize(((("ldap://" + HxOverrides.stringOrNull(com_sdtk_std_Parameters._ldapHost)) + ":") + Std.string(com_sdtk_std_Parameters._ldapPort)))
        connect.simple_bind_s(un, password)
        return False

    def checkLogin(self,user,password):
        if (com_sdtk_std_Parameters._ldapHost is not None):
            return self.checkLoginLDAP(user,password)
        elif (com_sdtk_std_Parameters._builtInUsers is not None):
            p = com_sdtk_std_Parameters._builtInUsers.h.get(user,None)
            if (p is None):
                return False
            else:
                return (p == password)
        else:
            return False

    def checkLoginVariable(self):
        return (Sys.environment().h.get(com_sdtk_std_Parameters._loginVariable,None) is not None)

    def redirectToLogin(self):
        w = com_sdtk_std_StdoutWriter()
        w.write(("Location: " + HxOverrides.stringOrNull(com_sdtk_std_Parameters._loginPath)))
        w.write("\n\n")
        w.dispose()

    def checkLoginPost(self):
        r = com_sdtk_std_StdinReader()
        value_b = python_lib_io_StringIO()
        while True:
            s = r.next()
            if (s is None):
                break
            value_b.write(Std.string(s))
        r.dispose()
        r = None
        _this = value_b.getvalue()
        arr = _this.split("&")
        _this = (arr[0] if 0 < len(arr) else None)
        python_internal_ArrayImpl._set(arr, 0, python_internal_ArrayImpl._get(_this.split("="), 1))
        _this = (arr[1] if 1 < len(arr) else None)
        python_internal_ArrayImpl._set(arr, 1, python_internal_ArrayImpl._get(_this.split("="), 1))
        return self.checkLogin(python_lib_urllib_Parse.unquote((arr[0] if 0 < len(arr) else None)),python_lib_urllib_Parse.unquote((arr[1] if 1 < len(arr) else None)))

    def validLogin(self):
        if (not com_sdtk_std_Parameters._enableLogin):
            return True
        if self.isCGI():
            if self.checkLoginVariable():
                return True
            elif (com_sdtk_std_Parameters._loginPath is not None):
                self.redirectToLogin()
                return False
            elif self.checkLoginPost():
                return True
            else:
                w = com_sdtk_std_StdoutWriter()
                w.write(com_sdtk_std_Parameters._loginPageTemplate)
                w.dispose()
                return False
        else:
            w = com_sdtk_std_StdoutWriter()
            w.write(python_internal_ArrayImpl._get(com_sdtk_std_Parameters._loginCommandLineTemplate, 0))
            w.flush()
            r = com_sdtk_std_StdinReader().switchToLineReader()
            user = r.next()
            w.write(python_internal_ArrayImpl._get(com_sdtk_std_Parameters._loginCommandLineTemplate, 1))
            w.flush()
            password = r.next()
            valid = self.checkLogin(user,password)
            if (not valid):
                w.write(python_internal_ArrayImpl._get(com_sdtk_std_Parameters._loginCommandLineTemplate, 2))
            w.dispose()
            r.dispose()
            return valid


class com_sdtk_calendar_Parameters(com_sdtk_std_Parameters):

    def __init__(self):
        self._invalid = None
        self._nothing = None
        self._output = None
        self._input = None
        self._format = None
        self._invite = None
        super().__init__()
        ciInvite = com_sdtk_calendar_CalendarInvite()
        iDates = 0
        iText = 0
        sFiles = list()
        regexp = EReg("[.]ics$","i")
        i = 0
        sParameter = None
        while True:
            sParameter = self.getParameter(i)
            if (sParameter is not None):
                dDate = None
                try:
                    dDate = Date.fromString(sParameter)
                    tmp = None
                    if (not dDate.toString().startswith("NaN")):
                        _hx_str = ("" + Std.string(dDate.date.year))
                        startIndex = None
                        tmp = (((sParameter.find(_hx_str) if ((startIndex is None)) else HxString.indexOfImpl(sParameter,_hx_str,startIndex))) < 0)
                    else:
                        tmp = True
                    if tmp:
                        dDate = None
                except BaseException as _g:
                    None
                if (dDate is not None):
                    iDates1 = iDates
                    if (iDates1 == 0):
                        ciInvite.start = dDate
                        self._invite = ciInvite
                    elif (iDates1 == 1):
                        ciInvite.end = dDate
                        self._invite = ciInvite
                    else:
                        pass
                    iDates = (iDates + 1)
                else:
                    regexp.matchObj = python_lib_Re.search(regexp.pattern,sParameter)
                    if (regexp.matchObj is not None):
                        sFiles.append(sParameter)
                    else:
                        if (iText == 0):
                            ciInvite.summary = sParameter
                            self._invite = ciInvite
                        iText = (iText + 1)
            i = (i + 1)
            if (not ((sParameter is not None))):
                break
        if (((len(sFiles) == 0) and ((iText > 0))) and ((iDates > 0))):
            self._nothing = True
            self._invalid = False
        elif (((len(sFiles) == 1) and ((iText > 0))) and ((iDates > 0))):
            self._output = (sFiles[0] if 0 < len(sFiles) else None)
            self._nothing = False
            self._invalid = False
        elif (((len(sFiles) == 1) and ((iText == 0))) and ((iDates == 0))):
            self._input = (sFiles[0] if 0 < len(sFiles) else None)
            self._nothing = False
            self._invalid = False
        elif (len(sFiles) == 2):
            self._input = (sFiles[0] if 0 < len(sFiles) else None)
            self._output = (sFiles[1] if 1 < len(sFiles) else None)
            self._nothing = False
            self._invalid = False
        else:
            self._invalid = True
            self._nothing = False

    def getInvite(self):
        return self._invite

    def getOutput(self):
        return self._output

    def getInput(self):
        return self._input

    def getNothing(self):
        return self._nothing

    def getInvalid(self):
        return self._invalid

class com_sdtk_calendar_ScheduleType(Enum):
    __slots__ = ()
    _hx_class_name = "com.sdtk.calendar.ScheduleType"
    _hx_constructs = ["NONE", "HOURLY", "DAILY", "WEEKLY", "MONTHLY", "YEARLY"]
com_sdtk_calendar_ScheduleType.NONE = com_sdtk_calendar_ScheduleType("NONE", 0, ())
com_sdtk_calendar_ScheduleType.HOURLY = com_sdtk_calendar_ScheduleType("HOURLY", 1, ())
com_sdtk_calendar_ScheduleType.DAILY = com_sdtk_calendar_ScheduleType("DAILY", 2, ())
com_sdtk_calendar_ScheduleType.WEEKLY = com_sdtk_calendar_ScheduleType("WEEKLY", 3, ())
com_sdtk_calendar_ScheduleType.MONTHLY = com_sdtk_calendar_ScheduleType("MONTHLY", 4, ())
com_sdtk_calendar_ScheduleType.YEARLY = com_sdtk_calendar_ScheduleType("YEARLY", 5, ())
com_sdtk_calendar_ScheduleType._hx_class = com_sdtk_calendar_ScheduleType


class com_sdtk_calendar_TableFormat:

    def __init__(self):
        self.sDateTimeFormat = None

    def convertDateTime(self,dDateTime):
        return DateTools.format(dDateTime,self.sDateTimeFormat)

    def toDateTime(self,sValue):
        try:
            return Date(Std.parseInt(HxString.substring(sValue,0,4)),Std.parseInt(HxString.substr(sValue,4,2)),Std.parseInt(HxString.substr(sValue,6,2)),Std.parseInt(HxString.substr(sValue,9,2)),Std.parseInt(HxString.substr(sValue,11,2)),Std.parseInt(HxString.substr(sValue,13,2)))
        except BaseException as _g:
            None
            return None

    def convert(self,ciInvite,wWriter):
        pass

    def convertToString(self,ciInvite):
        return ""

    def read(self,rReader):
        ciInvite = com_sdtk_calendar_CalendarInvite()
        return ciInvite

    def arrayToReader(self,aArray):
        return None

    def mapToReader(self,aArray):
        return None

    def validColumns(self):
        return None
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_calendar_TableFormat._instance is None):
            com_sdtk_calendar_TableFormat._instance = com_sdtk_calendar_TableFormat()
        return com_sdtk_calendar_TableFormat._instance


class com_sdtk_calendar_WindowsTaskSchedulerAbstract:

    def __init__(self,_hx_exec = None):
        if (_hx_exec is None):
            _hx_exec = False
        self._exec = False
        self._exec = _hx_exec

    def _hx_exec(self,writer,command,args):
        if (writer is not None):
            writer.write((((("null" if command is None else command) + " ") + HxOverrides.stringOrNull(" ".join([python_Boot.toString1(x1,'') for x1 in args]))) + "\n"))
        if self._exec:
            process = sys_io_Process(command,args)
            output = process.stdout.readAll().toString()
            process.close()
            return output
        return None

    def connect(self):
        return None

    def getFolder(self,path):
        return path

    def getList(self,folder,data = None):
        if (data is None):
            data = self._hx_exec(None,"schtasks",["/query", "/v", "/tn", (("\\" + Std.string(folder)) + "\\"), "/fo", "csv"])
        d = com_sdtk_table_DelimitedReader.createCSVReader(com_sdtk_std_StringReader(data)).toArrayOfHaxeMaps(None)
        return com_sdtk_calendar_WindowsTaskSchedulerAbstract.convertToObj(d)

    def deleteTask(self,writer,folder,task):
        self._hx_exec(writer,"schtasks",["/delete", "/tn", ((("\\" + Std.string(folder)) + "\\") + ("null" if task is None else task)), "/f"])

    def createTask(self,writer,folder,task):
        self._hx_exec(writer,"schtasks",["/create", "/tn", ((("\\" + Std.string(folder)) + "\\") + ("null" if task is None else task))])
        return ((("\\" + Std.string(folder)) + "\\") + ("null" if task is None else task))

    def updateTaskForDate(self,writer,task,start,end):
        self._hx_exec(writer,"schtasks",["/change", "/tn", task, "/sd", ((((("" + Std.string((((start.date.month - 1) + 1)))) + "/") + Std.string(start.date.day)) + "/") + Std.string(start.date.year)), "/st", ((((("" + Std.string(((12 if ((start.date.hour == 0)) else ((start.date.hour - 12) if ((start.date.hour > 12)) else start.date.hour))))) + ":") + Std.string(start.date.minute)) + " ") + HxOverrides.stringOrNull((("AM" if ((start.date.hour < 12)) else "PM")))), "/ed", ((((("" + Std.string((((end.date.month - 1) + 1)))) + "/") + Std.string(end.date.day)) + "/") + Std.string(end.date.year)), "/et", ((((("" + Std.string(((12 if ((end.date.hour == 0)) else ((end.date.hour - 12) if ((end.date.hour > 12)) else end.date.hour))))) + ":") + Std.string(end.date.minute)) + " ") + HxOverrides.stringOrNull((("AM" if ((end.date.hour < 12)) else "PM"))))])

    def updateTaskForSchedule(self,writer,task,schedulingType):
        ri = 0
        tmp = schedulingType.index
        if (tmp == 0):
            ri = 0
        elif (tmp == 1):
            ri = 60
        elif (tmp == 2):
            ri = 1440
        elif (tmp == 3):
            ri = 10080
        elif (tmp == 4):
            ri = 43200
        elif (tmp == 5):
            ri = 525600
        else:
            pass
        self._hx_exec(writer,"schtasks",["/change", "/tn", task, "/ri", ("" + Std.string(ri))])

    def updateTaskForAction(self,writer,task,cmd,arguments,workingDirectory):
        execute = None
        if (workingDirectory is None):
            if (cmd is None):
                execute = ""
            else:
                execute = cmd
        elif (cmd is not None):
            execute = ((("null" if workingDirectory is None else workingDirectory) + "\\") + ("null" if cmd is None else cmd))
        else:
            execute = ""
        if ((execute != "") and ((arguments is not None))):
            execute = (("null" if execute is None else execute) + HxOverrides.stringOrNull(((" " + HxOverrides.stringOrNull(" ".join([python_Boot.toString1(x1,'') for x1 in arguments]))))))
        self._hx_exec(writer,"schtasks",["/change", "/tn", task, "/tr", execute])

    @staticmethod
    def convertToObj(i):
        arr = list()
        m = HxOverrides.iterator(i)
        while m.hasNext():
            m1 = m.next()
            if (m1.h.get("Status",None) != "Status"):
                x = com_sdtk_calendar_WindowsTaskSchedulerTaskToMap(m1)
                arr.append(x)
        return arr


class com_sdtk_calendar_WindowsTaskSchedulerExecutor(com_sdtk_calendar_WindowsTaskSchedulerAbstract):

    def __init__(self):
        super().__init__(True)

    def read(self,folder):
        return self.getList(folder,None)

    def convert(self,ciInvite,folder):
        task = self.createTask(None,folder,ciInvite.summary)
        self.updateTaskForDate(None,task,ciInvite.start,ciInvite.end)
        self.updateTaskForSchedule(None,task,ciInvite.schedulingType)
        self.updateTaskForAction(None,task,ciInvite.actionExecute,ciInvite.actionExecuteParameters,ciInvite.actionExecuteIn)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_calendar_WindowsTaskSchedulerExecutor._instance is None):
            com_sdtk_calendar_WindowsTaskSchedulerExecutor._instance = com_sdtk_calendar_WindowsTaskSchedulerExecutor()
        return com_sdtk_calendar_WindowsTaskSchedulerExecutor._instance


class com_sdtk_calendar_WindowsTaskSchedulerText(com_sdtk_calendar_WindowsTaskSchedulerAbstract):

    def __init__(self):
        super().__init__(False)

    def read(self,rReader):
        sw = com_sdtk_std_StringWriter(None)
        while True:
            d = rReader.next()
            if (d is not None):
                sw.write(d)
            else:
                break
        return self.getList(None,sw.toString())

    def convert(self,ciInvite,wWriter,folder):
        task = self.createTask(wWriter,folder,ciInvite.summary)
        self.updateTaskForDate(wWriter,task,ciInvite.start,ciInvite.end)
        self.updateTaskForSchedule(wWriter,task,ciInvite.schedulingType)
        self.updateTaskForAction(wWriter,task,ciInvite.actionExecute,ciInvite.actionExecuteParameters,ciInvite.actionExecuteIn)

    def convertToString(self,ciInvite,folder):
        sw = com_sdtk_std_StringWriter(None)
        self.convert(ciInvite,sw,folder)
        sw.dispose()
        return sw.toString()
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_calendar_WindowsTaskSchedulerText._instance is None):
            com_sdtk_calendar_WindowsTaskSchedulerText._instance = com_sdtk_calendar_WindowsTaskSchedulerText()
        return com_sdtk_calendar_WindowsTaskSchedulerText._instance


class com_sdtk_calendar_WindowsTaskSchedulerTask:
    pass


class com_sdtk_calendar_WindowsTaskSchedulerTaskAbstract(com_sdtk_calendar_CalendarInvite):

    def __init__(self):
        super().__init__()

    def update(self):
        a = self.startDate()
        _this = self.startTime()
        b = _this.split(":")
        _this = (b[2] if 2 < len(b) else None)
        b2 = _this.split(" ")
        python_internal_ArrayImpl._set(b, 2, (b2[0] if 0 < len(b2) else None))
        b.append((b2[1] if 1 < len(b2) else None))
        c = list()
        python_internal_ArrayImpl._set(c, 0, Std.parseInt((b[0] if 0 < len(b) else None)))
        python_internal_ArrayImpl._set(c, 1, Std.parseInt((b[1] if 1 < len(b) else None)))
        python_internal_ArrayImpl._set(c, 2, Std.parseInt((b[2] if 2 < len(b) else None)))
        if (((b[3] if 3 < len(b) else None).upper() == "PM") and (((c[0] if 0 < len(c) else None) < 12))):
            _hx_local_0 = c
            _hx_local_1 = 0
            _hx_local_2 = (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
            python_internal_ArrayImpl._set(_hx_local_0, _hx_local_1, (_hx_local_2 + 12))
            (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
        elif (((b[3] if 3 < len(b) else None).upper() == "AM") and (((c[0] if 0 < len(c) else None) == 12))):
            python_internal_ArrayImpl._set(c, 0, 0)
        self.created = Date(a.date.year,(a.date.month - 1),a.date.day,(c[0] if 0 < len(c) else None),(c[1] if 1 < len(c) else None),(c[2] if 2 < len(c) else None))
        self.start = self.created
        self.end = self.endDate()
        self.summary = self.taskName()
        self.actionExecute = self.taskToRun()
        self.actionExecuteIn = self.startIn()
        _g = self.scheduleType()
        _hx_local_3 = len(_g)
        if (_hx_local_3 == 5):
            if (_g == "Daily"):
                self.schedulingType = com_sdtk_calendar_ScheduleType.DAILY
            else:
                _this = self.repeatEvery()
                startIndex = None
                hour = (_this.find("Hour") if ((startIndex is None)) else HxString.indexOfImpl(_this,"Hour",startIndex))
                _this = self.repeatEvery()
                startIndex = None
                minute = (_this.find("Minute") if ((startIndex is None)) else HxString.indexOfImpl(_this,"Minute",startIndex))
                if ((hour < 0) and ((minute < 0))):
                    self.schedulingType = com_sdtk_calendar_ScheduleType.NONE
                else:
                    _this = self.repeatEvery()
                    s = _this.split(",")
                    _g = 0
                    while (_g < len(s)):
                        s2 = (s[_g] if _g >= 0 and _g < len(s) else None)
                        _g = (_g + 1)
                        hour = 0
                        minute = 0
                        parts = s2.split(" ")
                        unit = (parts[1] if 1 < len(parts) else None)
                        value = (parts[0] if 0 < len(parts) else None)
                        unit1 = unit
                        _hx_local_5 = len(unit1)
                        if (_hx_local_5 == 4):
                            if (unit1 == "Hour"):
                                hour = Std.parseInt(value)
                        elif (_hx_local_5 == 6):
                            if (unit1 == "Minute"):
                                minute = Std.parseInt(value)
                        else:
                            pass
                    hour = (hour + Math.floor((minute / 60)))
                    if ((hour > 0) and ((hour < 24))):
                        self.schedulingType = com_sdtk_calendar_ScheduleType.HOURLY
                    elif ((hour >= 24) and ((hour < 168))):
                        self.schedulingType = com_sdtk_calendar_ScheduleType.DAILY
                    elif ((hour >= 168) and ((hour < 672))):
                        self.schedulingType = com_sdtk_calendar_ScheduleType.WEEKLY
                    elif ((hour >= 672) and ((hour < 8064))):
                        self.schedulingType = com_sdtk_calendar_ScheduleType.MONTHLY
                    else:
                        self.schedulingType = com_sdtk_calendar_ScheduleType.YEARLY
        elif (_hx_local_3 == 13):
            if (_g == "One Time Only"):
                self.schedulingType = com_sdtk_calendar_ScheduleType.NONE
            else:
                _this = self.repeatEvery()
                startIndex = None
                hour = (_this.find("Hour") if ((startIndex is None)) else HxString.indexOfImpl(_this,"Hour",startIndex))
                _this = self.repeatEvery()
                startIndex = None
                minute = (_this.find("Minute") if ((startIndex is None)) else HxString.indexOfImpl(_this,"Minute",startIndex))
                if ((hour < 0) and ((minute < 0))):
                    self.schedulingType = com_sdtk_calendar_ScheduleType.NONE
                else:
                    _this = self.repeatEvery()
                    s = _this.split(",")
                    _g = 0
                    while (_g < len(s)):
                        s2 = (s[_g] if _g >= 0 and _g < len(s) else None)
                        _g = (_g + 1)
                        hour = 0
                        minute = 0
                        parts = s2.split(" ")
                        unit = (parts[1] if 1 < len(parts) else None)
                        value = (parts[0] if 0 < len(parts) else None)
                        unit1 = unit
                        _hx_local_8 = len(unit1)
                        if (_hx_local_8 == 4):
                            if (unit1 == "Hour"):
                                hour = Std.parseInt(value)
                        elif (_hx_local_8 == 6):
                            if (unit1 == "Minute"):
                                minute = Std.parseInt(value)
                        else:
                            pass
                    hour = (hour + Math.floor((minute / 60)))
                    if ((hour > 0) and ((hour < 24))):
                        self.schedulingType = com_sdtk_calendar_ScheduleType.HOURLY
                    elif ((hour >= 24) and ((hour < 168))):
                        self.schedulingType = com_sdtk_calendar_ScheduleType.DAILY
                    elif ((hour >= 168) and ((hour < 672))):
                        self.schedulingType = com_sdtk_calendar_ScheduleType.WEEKLY
                    elif ((hour >= 672) and ((hour < 8064))):
                        self.schedulingType = com_sdtk_calendar_ScheduleType.MONTHLY
                    else:
                        self.schedulingType = com_sdtk_calendar_ScheduleType.YEARLY
        elif (_hx_local_3 == 7):
            if (_g == "Monthly"):
                self.schedulingType = com_sdtk_calendar_ScheduleType.MONTHLY
            else:
                _this = self.repeatEvery()
                startIndex = None
                hour = (_this.find("Hour") if ((startIndex is None)) else HxString.indexOfImpl(_this,"Hour",startIndex))
                _this = self.repeatEvery()
                startIndex = None
                minute = (_this.find("Minute") if ((startIndex is None)) else HxString.indexOfImpl(_this,"Minute",startIndex))
                if ((hour < 0) and ((minute < 0))):
                    self.schedulingType = com_sdtk_calendar_ScheduleType.NONE
                else:
                    _this = self.repeatEvery()
                    s = _this.split(",")
                    _g = 0
                    while (_g < len(s)):
                        s2 = (s[_g] if _g >= 0 and _g < len(s) else None)
                        _g = (_g + 1)
                        hour = 0
                        minute = 0
                        parts = s2.split(" ")
                        unit = (parts[1] if 1 < len(parts) else None)
                        value = (parts[0] if 0 < len(parts) else None)
                        unit1 = unit
                        _hx_local_11 = len(unit1)
                        if (_hx_local_11 == 4):
                            if (unit1 == "Hour"):
                                hour = Std.parseInt(value)
                        elif (_hx_local_11 == 6):
                            if (unit1 == "Minute"):
                                minute = Std.parseInt(value)
                        else:
                            pass
                    hour = (hour + Math.floor((minute / 60)))
                    if ((hour > 0) and ((hour < 24))):
                        self.schedulingType = com_sdtk_calendar_ScheduleType.HOURLY
                    elif ((hour >= 24) and ((hour < 168))):
                        self.schedulingType = com_sdtk_calendar_ScheduleType.DAILY
                    elif ((hour >= 168) and ((hour < 672))):
                        self.schedulingType = com_sdtk_calendar_ScheduleType.WEEKLY
                    elif ((hour >= 672) and ((hour < 8064))):
                        self.schedulingType = com_sdtk_calendar_ScheduleType.MONTHLY
                    else:
                        self.schedulingType = com_sdtk_calendar_ScheduleType.YEARLY
        elif (_hx_local_3 == 6):
            if (_g == "Weekly"):
                self.schedulingType = com_sdtk_calendar_ScheduleType.WEEKLY
            else:
                _this = self.repeatEvery()
                startIndex = None
                hour = (_this.find("Hour") if ((startIndex is None)) else HxString.indexOfImpl(_this,"Hour",startIndex))
                _this = self.repeatEvery()
                startIndex = None
                minute = (_this.find("Minute") if ((startIndex is None)) else HxString.indexOfImpl(_this,"Minute",startIndex))
                if ((hour < 0) and ((minute < 0))):
                    self.schedulingType = com_sdtk_calendar_ScheduleType.NONE
                else:
                    _this = self.repeatEvery()
                    s = _this.split(",")
                    _g = 0
                    while (_g < len(s)):
                        s2 = (s[_g] if _g >= 0 and _g < len(s) else None)
                        _g = (_g + 1)
                        hour = 0
                        minute = 0
                        parts = s2.split(" ")
                        unit = (parts[1] if 1 < len(parts) else None)
                        value = (parts[0] if 0 < len(parts) else None)
                        unit1 = unit
                        _hx_local_14 = len(unit1)
                        if (_hx_local_14 == 4):
                            if (unit1 == "Hour"):
                                hour = Std.parseInt(value)
                        elif (_hx_local_14 == 6):
                            if (unit1 == "Minute"):
                                minute = Std.parseInt(value)
                        else:
                            pass
                    hour = (hour + Math.floor((minute / 60)))
                    if ((hour > 0) and ((hour < 24))):
                        self.schedulingType = com_sdtk_calendar_ScheduleType.HOURLY
                    elif ((hour >= 24) and ((hour < 168))):
                        self.schedulingType = com_sdtk_calendar_ScheduleType.DAILY
                    elif ((hour >= 168) and ((hour < 672))):
                        self.schedulingType = com_sdtk_calendar_ScheduleType.WEEKLY
                    elif ((hour >= 672) and ((hour < 8064))):
                        self.schedulingType = com_sdtk_calendar_ScheduleType.MONTHLY
                    else:
                        self.schedulingType = com_sdtk_calendar_ScheduleType.YEARLY
        else:
            _this = self.repeatEvery()
            startIndex = None
            hour = (_this.find("Hour") if ((startIndex is None)) else HxString.indexOfImpl(_this,"Hour",startIndex))
            _this = self.repeatEvery()
            startIndex = None
            minute = (_this.find("Minute") if ((startIndex is None)) else HxString.indexOfImpl(_this,"Minute",startIndex))
            if ((hour < 0) and ((minute < 0))):
                self.schedulingType = com_sdtk_calendar_ScheduleType.NONE
            else:
                _this = self.repeatEvery()
                s = _this.split(",")
                _g = 0
                while (_g < len(s)):
                    s2 = (s[_g] if _g >= 0 and _g < len(s) else None)
                    _g = (_g + 1)
                    hour = 0
                    minute = 0
                    parts = s2.split(" ")
                    unit = (parts[1] if 1 < len(parts) else None)
                    value = (parts[0] if 0 < len(parts) else None)
                    unit1 = unit
                    _hx_local_17 = len(unit1)
                    if (_hx_local_17 == 4):
                        if (unit1 == "Hour"):
                            hour = Std.parseInt(value)
                    elif (_hx_local_17 == 6):
                        if (unit1 == "Minute"):
                            minute = Std.parseInt(value)
                    else:
                        pass
                hour = (hour + Math.floor((minute / 60)))
                if ((hour > 0) and ((hour < 24))):
                    self.schedulingType = com_sdtk_calendar_ScheduleType.HOURLY
                elif ((hour >= 24) and ((hour < 168))):
                    self.schedulingType = com_sdtk_calendar_ScheduleType.DAILY
                elif ((hour >= 168) and ((hour < 672))):
                    self.schedulingType = com_sdtk_calendar_ScheduleType.WEEKLY
                elif ((hour >= 672) and ((hour < 8064))):
                    self.schedulingType = com_sdtk_calendar_ScheduleType.MONTHLY
                else:
                    self.schedulingType = com_sdtk_calendar_ScheduleType.YEARLY

    def hostName(self):
        return None

    def taskName(self):
        return None

    def nextRuntime(self):
        return None

    def status(self):
        return None

    def logonMode(self):
        return None

    def lastRuntime(self):
        return None

    def lastResult(self):
        return None

    def author(self):
        return None

    def taskToRun(self):
        return None

    def startIn(self):
        return None

    def comment(self):
        return None

    def scheduledTaskState(self):
        return None

    def idleTime(self):
        return None

    def powerManagement(self):
        return None

    def runAsUser(self):
        return None

    def deleteTaskIfNotRescheduled(self):
        return None

    def stopTaskIfRunsXHoursAndXMins(self):
        return None

    def schedule(self):
        return None

    def scheduleType(self):
        return None

    def startTime(self):
        return None

    def startDate(self):
        return None

    def endDate(self):
        return None

    def days(self):
        return None

    def months(self):
        return None

    def repeatEvery(self):
        return None

    def repeatUntilTime(self):
        return None

    def repeatUntilDuration(self):
        return None

    def repeatStopIfStillRunning(self):
        return None


class com_sdtk_calendar_WindowsTaskSchedulerTaskToMap(com_sdtk_calendar_WindowsTaskSchedulerTaskAbstract):

    def __init__(self,m):
        self._m = None
        super().__init__()
        self._m = m
        self.update()

    def value(self,v):
        if (v == "N/A"):
            return None
        else:
            return v

    def hostName(self):
        return self.value(self._m.h.get("HostName",None))

    def taskName(self):
        return self.value(self._m.h.get("TaskName",None))

    def nextRuntime(self):
        return self.value(self._m.h.get("Next Run Time",None))

    def status(self):
        return self.value(self._m.h.get("Status",None))

    def logonMode(self):
        return self.value(self._m.h.get("Logon Mode",None))

    def lastRuntime(self):
        return self.value(self._m.h.get("Last Run Time",None))

    def lastResult(self):
        return self.value(self._m.h.get("Last Result",None))

    def author(self):
        return self.value(self._m.h.get("Author",None))

    def taskToRun(self):
        return self.value(self._m.h.get("Task To Run",None))

    def startIn(self):
        return self.value(self._m.h.get("Start In",None))

    def comment(self):
        return self.value(self._m.h.get("Comment",None))

    def scheduledTaskState(self):
        return self.value(self._m.h.get("Scheduled Task State",None))

    def idleTime(self):
        return self.value(self._m.h.get("Idle Time",None))

    def powerManagement(self):
        return self.value(self._m.h.get("Power Management",None))

    def runAsUser(self):
        return self.value(self._m.h.get("Run As User",None))

    def deleteTaskIfNotRescheduled(self):
        return self.value(self._m.h.get("Delete Task If Not Rescheduled",None))

    def stopTaskIfRunsXHoursAndXMins(self):
        return self.value(self._m.h.get("Stop Task If Runs X Hours and X Mins",None))

    def schedule(self):
        return self.value(self._m.h.get("Schedule",None))

    def scheduleType(self):
        return self.value(self._m.h.get("Schedule Type",None))

    def startTime(self):
        return self.value(self._m.h.get("Start Time",None))

    def startDate(self):
        return self.value(self._m.h.get("Start Date",None))

    def endDate(self):
        return self.value(self._m.h.get("End Date",None))

    def days(self):
        return self.value(self._m.h.get("Days",None))

    def months(self):
        return self.value(self._m.h.get("Months",None))

    def repeatEvery(self):
        return self.value(self._m.h.get("Repeat: Every",None))

    def repeatUntilTime(self):
        return self.value(self._m.h.get("Repeat: Until: Time",None))

    def repeatUntilDuration(self):
        return self.value(self._m.h.get("Repeat: Until: Duration",None))

    def repeatStopIfStillRunning(self):
        return self.value(self._m.h.get("Repeat: Stop If Still Running",None))


class com_sdtk_graphs_GrapherInterface:
    pass


class com_sdtk_graphs_Grapher:

    def __init__(self,options):
        self._dataGroup = None
        self._dataY = None
        self._dataX = None
        self._reader = None
        self._fillGap = None
        self._dataByIndex = None
        self._lastI = None
        self._lastX = None
        self._convertedData = None
        self._originY = None
        self._originX = None
        self._shiftY = None
        self._shiftX = None
        self._changed = None
        self._groups = None
        self._coordinates = None
        self._locationsX = None
        self._locationsY = None
        self._plotType = None
        self._tileHeight = None
        self._tileWidth = None
        fo = options.toMap()
        width = fo.h.get("tileWidth",None)
        height = fo.h.get("tileHeight",None)
        shiftX = fo.h.get("shiftX",None)
        shiftY = fo.h.get("shiftY",None)
        plotFunction = fo.h.get("plotFunction",None)
        self._colors = fo.h.get("colors",None)
        self._plotFunctions = fo.h.get("plotFunctions",None)
        if (self._plotFunctions is None):
            self._plotFunctions = list()
            _this = self._plotFunctions
            l = len(_this)
            if (l < 1):
                idx = 0
                v = None
                l1 = len(_this)
                while (l1 < idx):
                    _this.append(None)
                    l1 = (l1 + 1)
                if (l1 == idx):
                    _this.append(v)
                else:
                    _this[idx] = v
            elif (l > 1):
                pos = 1
                _hx_len = (l - 1)
                if (pos < 0):
                    pos = (len(_this) + pos)
                if (pos < 0):
                    pos = 0
                res = _this[pos:(pos + _hx_len)]
                del _this[pos:(pos + _hx_len)]
            python_internal_ArrayImpl._set(self._plotFunctions, 0, plotFunction)
        self._plotType = fo.h.get("plotType",None)
        if (shiftX is None):
            shiftX = 0
        if (shiftY is None):
            shiftY = 0
        self._shiftX = shiftX
        self._shiftY = shiftY
        self._reader = fo.h.get("reader",None)
        self._dataX = fo.h.get("dataX",None)
        self._dataY = fo.h.get("dataY",None)
        self._dataGroup = fo.h.get("dataGroup",None)
        self._dataByIndex = fo.h.get("dataByIndex",None)
        self._fillGap = False
        if (((self._plotFunctions[0] if 0 < len(self._plotFunctions) else None) is None) and ((self._reader is not None))):
            python_internal_ArrayImpl._set(self._plotFunctions, 0, self.plotForData)

    def updateLocations(self):
        self._convertedData = com_sdtk_graphs_Grapher._updateData(self._convertedData,self._reader,self._plotType,self._dataByIndex,self._dataX,self._dataY,self._dataGroup)
        results = com_sdtk_graphs_Grapher._updateLocations(self._originX,self._originY,1,1,self._tileWidth,self._tileHeight,self._shiftX,self._shiftY,self._plotFunctions,self._plotType,self._locationsX,self._locationsY,self._coordinates,self._groups,self._convertedData)
        self._changed = results._changed
        self._locationsX = results._locationsX
        self._locationsY = results._locationsY
        self._coordinates = results._coordinates
        self._groups = results._groups

    def exportOptions(self):
        return com_sdtk_graphs_GraphExportTypeOptions(self)

    def export(self,options,callback = None):
        return com_sdtk_graphs_Grapher._export(None,options,callback,self._originX,self._originY,1,1,self._tileWidth,self._tileHeight,self._shiftX,self._shiftY,self._plotType,self._locationsX,self._locationsY,self._coordinates,self._groups,self._convertedData,self._colors)

    def plotForData(self,x):
        return com_sdtk_graphs_Grapher._plotForData(x,self._convertedData)

    def getGroups(self):
        return com_sdtk_graphs_Grapher._getGroups(self._groups)

    @staticmethod
    def getValidGraphColors():
        return com_sdtk_graphs_Grapher._validGraphColors

    @staticmethod
    def create(options):
        return com_sdtk_graphs_Grapher(options)

    @staticmethod
    def options():
        return com_sdtk_graphs_GrapherOptions()

    @staticmethod
    def _updateData(convertedData,reader,plotType,dataByIndex,dataX,dataY,dataGroup):
        if ((reader is not None) and ((convertedData is None))):
            if dataByIndex:
                convertedData = com_sdtk_graphs_Grapher.convertDataForPlotByColumnIndex(reader,plotType,dataX,dataY,dataGroup)
            else:
                convertedData = com_sdtk_graphs_Grapher.convertDataForPlotByColumnName(reader,plotType,dataX,dataY,dataGroup)
        return convertedData

    @staticmethod
    def _updateLocations(originX,originY,rectWidth,rectHeight,tileWidth,tileHeight,shiftX,shiftY,plotFunctions,plotType,_locationsX,_locationsY,_coordinates,_groups,convertedData):
        results = com_sdtk_graphs_GrapherUpdateLocationsResults()
        start = -1
        end = -1
        increment = -1
        size = None
        plotType1 = plotType
        if (plotType1 == 1):
            start = (originY - shiftY)
            end = (start + tileHeight)
            increment = (1 / rectHeight)
        elif (plotType1 == 2):
            start = (originX - shiftX)
            end = (start + tileWidth)
            increment = (1 / rectWidth)
        else:
            pass
        if (convertedData is None):
            size = Math.floor(((((end - start)) / increment) + 0.5))
        else:
            size = len(convertedData)
            increment = 1
        locationsY = list()
        l = len(locationsY)
        if (l < size):
            idx = (size - 1)
            v = None
            l1 = len(locationsY)
            while (l1 < idx):
                locationsY.append(None)
                l1 = (l1 + 1)
            if (l1 == idx):
                locationsY.append(v)
            else:
                locationsY[idx] = v
        elif (l > size):
            pos = size
            _hx_len = (l - size)
            if (pos < 0):
                pos = (len(locationsY) + pos)
            if (pos < 0):
                pos = 0
            res = locationsY[pos:(pos + _hx_len)]
            del locationsY[pos:(pos + _hx_len)]
        locationsX = list()
        l = len(locationsX)
        if (l < size):
            idx = (size - 1)
            v = None
            l1 = len(locationsX)
            while (l1 < idx):
                locationsX.append(None)
                l1 = (l1 + 1)
            if (l1 == idx):
                locationsX.append(v)
            else:
                locationsX[idx] = v
        elif (l > size):
            pos = size
            _hx_len = (l - size)
            if (pos < 0):
                pos = (len(locationsX) + pos)
            if (pos < 0):
                pos = 0
            res = locationsX[pos:(pos + _hx_len)]
            del locationsX[pos:(pos + _hx_len)]
        coordinates = list()
        l = len(coordinates)
        if (l < size):
            idx = (size - 1)
            v = None
            l1 = len(coordinates)
            while (l1 < idx):
                coordinates.append(None)
                l1 = (l1 + 1)
            if (l1 == idx):
                coordinates.append(v)
            else:
                coordinates[idx] = v
        elif (l > size):
            pos = size
            _hx_len = (l - size)
            if (pos < 0):
                pos = (len(coordinates) + pos)
            if (pos < 0):
                pos = 0
            res = coordinates[pos:(pos + _hx_len)]
            del coordinates[pos:(pos + _hx_len)]
        groups = list()
        l = len(groups)
        if (l < size):
            idx = (size - 1)
            v = None
            l1 = len(groups)
            while (l1 < idx):
                groups.append(None)
                l1 = (l1 + 1)
            if (l1 == idx):
                groups.append(v)
            else:
                groups[idx] = v
        elif (l > size):
            pos = size
            _hx_len = (l - size)
            if (pos < 0):
                pos = (len(groups) + pos)
            if (pos < 0):
                pos = 0
            res = groups[pos:(pos + _hx_len)]
            del groups[pos:(pos + _hx_len)]
        locationUse = None
        locationResult = None
        locationCompare = None
        shiftUse = -1
        shiftResult = -1
        getCoordinates = None
        plotType1 = plotType
        if (plotType1 == 1):
            locationUse = locationsY
            locationResult = locationsX
            locationCompare = _locationsX
            shiftUse = shiftY
            shiftResult = shiftX
            def _hx_local_4(y,x):
                return ((("" + Std.string(x)) + ",") + Std.string(y))
            getCoordinates = _hx_local_4
        elif (plotType1 == 2):
            locationUse = locationsX
            locationResult = locationsY
            locationCompare = _locationsY
            shiftUse = shiftX
            shiftResult = shiftY
            def _hx_local_5(x,y):
                return ((("" + Std.string(x)) + ",") + Std.string(y))
            getCoordinates = _hx_local_5
        else:
            pass
        group = 0
        changed = (_locationsX is None)
        groupSize = size
        if (convertedData is not None):
            groupSize = com_sdtk_graphs_Grapher.getSizeOfGroups(convertedData)
        _g = 0
        while (_g < len(plotFunctions)):
            plotFunction = (plotFunctions[_g] if _g >= 0 and _g < len(plotFunctions) else None)
            _g = (_g + 1)
            i = start
            j = 0
            while (j < size):
                result = plotFunction(i)
                python_internal_ArrayImpl._set(locationUse, j, (HxOverrides.modf(i, groupSize) + shiftUse))
                python_internal_ArrayImpl._set(locationResult, j, (result + shiftResult))
                if (convertedData is None):
                    python_internal_ArrayImpl._set(coordinates, j, getCoordinates(HxOverrides.modf(i, groupSize),result))
                    python_internal_ArrayImpl._set(groups, j, Std.string(group))
                else:
                    python_internal_ArrayImpl._set(coordinates, j, ((Std.string(python_internal_ArrayImpl._get((convertedData[j] if j >= 0 and j < len(convertedData) else None), 0)) + " - ") + Std.string(python_internal_ArrayImpl._get((convertedData[j] if j >= 0 and j < len(convertedData) else None), 1))))
                    if (len((convertedData[j] if j >= 0 and j < len(convertedData) else None)) == 3):
                        python_internal_ArrayImpl._set(groups, j, python_internal_ArrayImpl._get((convertedData[j] if j >= 0 and j < len(convertedData) else None), 2))
                    else:
                        python_internal_ArrayImpl._set(groups, j, "")
                if ((not changed) and (((locationCompare[j] if j >= 0 and j < len(locationCompare) else None) != (locationResult[j] if j >= 0 and j < len(locationResult) else None)))):
                    changed = True
                i = (i + increment)
                j = (j + 1)
            group = (group + 1)
        results._changed = changed
        if changed:
            results._locationsX = locationsX
            results._locationsY = locationsY
            results._coordinates = coordinates
            results._groups = groups
        else:
            results._locationsX = _locationsX
            results._locationsY = _locationsY
            results._coordinates = _coordinates
            results._groups = _groups
        return results

    @staticmethod
    def _exportOptions():
        return com_sdtk_graphs_GraphExportTypeOptions(None)

    @staticmethod
    def _export(exporter,options,callback = None,originX = None,originY = None,rectWidth = None,rectHeight = None,tileWidth = None,tileHeight = None,shiftX = None,shiftY = None,plotType = None,locationsX = None,locationsY = None,coordinates = None,groups = None,convertedData = None,colors = None):
        if (colors is None):
            colors = com_sdtk_graphs_Grapher._defaultGraphColors
        width = None
        height = None
        if (options is not None):
            fo = options.toMap()
            if (exporter is None):
                exporter = fo.h.get("type",None)
            width = fo.h.get("width",None)
            height = fo.h.get("height",None)
        sb = exporter.getTarget()
        if (width is None):
            width = Math.floor(((tileWidth * rectWidth) + 0.5))
        if (height is None):
            height = Math.floor(((tileHeight * rectHeight) + 0.5))
        if (width == -1):
            plotType1 = plotType
            if (plotType1 == 1):
                width = python_internal_ArrayImpl._get((convertedData[0] if 0 < len(convertedData) else None), 1)
                _g = 0
                while (_g < len(convertedData)):
                    v = (convertedData[_g] if _g >= 0 and _g < len(convertedData) else None)
                    _g = (_g + 1)
                    if ((v[1] if 1 < len(v) else None) > width):
                        width = (v[1] if 1 < len(v) else None)
                v = (width / tileWidth)
                width = (Math.pow(10,Math.floor(((((Math.NEGATIVE_INFINITY if ((v == 0.0)) else (Math.NaN if ((v < 0.0)) else python_lib_Math.log(v)))) / python_lib_Math.log(10)) + 0.5))) * tileWidth)
            elif (plotType1 == 2):
                width = com_sdtk_graphs_Grapher.getSizeOfGroups(convertedData)
            else:
                pass
        if (height == -1):
            plotType1 = plotType
            if (plotType1 == 1):
                height = com_sdtk_graphs_Grapher.getSizeOfGroups(convertedData)
            elif (plotType1 == 2):
                height = python_internal_ArrayImpl._get((convertedData[0] if 0 < len(convertedData) else None), 1)
                _g = 0
                while (_g < len(convertedData)):
                    v = (convertedData[_g] if _g >= 0 and _g < len(convertedData) else None)
                    _g = (_g + 1)
                    if ((v[1] if 1 < len(v) else None) > height):
                        height = (v[1] if 1 < len(v) else None)
                v = (height / tileHeight)
                height = (Math.pow(10,Math.floor(((((Math.NEGATIVE_INFINITY if ((v == 0.0)) else (Math.NaN if ((v < 0.0)) else python_lib_Math.log(v)))) / python_lib_Math.log(10)) + 0.5))) * tileHeight)
            else:
                pass
        scaleX = -1
        scaleY = -1
        scaleY = (height / tileHeight)
        scaleX = (width / tileWidth)
        width = (width * rectWidth)
        height = (height * rectHeight)
        start = -1
        end = -1
        increment = -1
        plotType1 = plotType
        if (plotType1 == 1):
            start = originY
            end = (start + tileHeight)
            increment = (1 / rectHeight)
        elif (plotType1 == 2):
            start = originX
            end = (start + tileWidth)
            increment = (1 / rectWidth)
        else:
            pass
        size = None
        if (convertedData is None):
            size = Math.floor(((((end - start)) / increment) + 0.5))
        else:
            size = len(convertedData)
        exporter.start(sb,width,height,scaleX,scaleY)
        j = 0
        multiX = (rectWidth / scaleX)
        multiY = (rectHeight / scaleY)
        prevGroup = None
        prevX = Math.floor(((python_internal_ArrayImpl._get(locationsX, (j - 1)) * multiX) + 0.5))
        prevY = Math.floor(((python_internal_ArrayImpl._get(locationsY, (j - 1)) * multiY) + 0.5))
        groupI = -1
        groupCount = 0
        while (j < size):
            curGroup = (groups[j] if j >= 0 and j < len(groups) else None)
            if (curGroup != prevGroup):
                prevGroup = curGroup
                groupCount = (groupCount + 1)
            j = (j + 1)
        prevGroup = None
        j = 0
        while (j < size):
            curGroup = (groups[j] if j >= 0 and j < len(groups) else None)
            if (curGroup != prevGroup):
                prevX = Math.floor((((locationsX[j] if j >= 0 and j < len(locationsX) else None) * multiX) + 0.5))
                prevY = Math.floor((((locationsY[j] if j >= 0 and j < len(locationsY) else None) * multiY) + 0.5))
                prevGroup = curGroup
                groupI = (groupI + 1)
            else:
                newX = Math.floor((((locationsX[j] if j >= 0 and j < len(locationsX) else None) * multiX) + 0.5))
                newY = Math.floor((((locationsY[j] if j >= 0 and j < len(locationsY) else None) * multiY) + 0.5))
                exporter.drawLine(sb,prevX,prevY,newX,newY)
                if (groupCount > 1):
                    exporter.setColor(sb,python_internal_ArrayImpl._get(colors, HxOverrides.mod(groupI, len(colors))))
                prevX = newX
                prevY = newY
            j = (j + 1)
        startX = originX
        startY = originY
        endX = (startX + tileWidth)
        endY = (startY + tileHeight)
        tickHeight = (rectHeight / 10)
        tickWidth = (rectWidth / 10)
        i = startX
        j = 0
        while (j < tileWidth):
            caption = None
            exporter.drawLine(sb,(((j + startX)) * rectWidth),((-tickHeight / 2) + ((((originY + shiftY)) * rectHeight))),(((j + startX)) * rectWidth),((tickHeight / 2) + ((((originY + shiftY)) * rectHeight))))
            exporter.setColor(sb,"black")
            if ((convertedData is not None) and ((plotType == 2))):
                caption = python_internal_ArrayImpl._get((convertedData[j] if j >= 0 and j < len(convertedData) else None), 0)
            else:
                caption = Std.string((((j - shiftX)) * scaleX))
            exporter.setCaption(sb,caption)
            if ((plotType == 2) or ((j > 0))):
                exporter.drawText(sb,(((j + startX)) * rectWidth),0,0,caption)
            j = (j + 1)
        j = 0
        while (j < tileHeight):
            caption = None
            exporter.drawLine(sb,((-tickWidth / 2) + ((((originX + shiftX)) * rectWidth))),(((j + startY)) * rectHeight),((tickWidth / 2) + ((((originX + shiftX)) * rectWidth))),(((j + startY)) * rectHeight))
            exporter.setColor(sb,"black")
            if ((convertedData is not None) and ((plotType == 1))):
                caption = python_internal_ArrayImpl._get((convertedData[j] if j >= 0 and j < len(convertedData) else None), 1)
            else:
                caption = Std.string((((j - shiftY)) * scaleY))
            exporter.setCaption(sb,caption)
            if ((plotType == 1) or ((j > 0))):
                exporter.drawText(sb,0,(((j + startY)) * rectHeight),3,caption)
            j = (j + 1)
        exporter.drawLine(sb,(startX * rectWidth),(((originY + shiftY)) * rectHeight),(endX * rectWidth),(((originY + shiftY)) * rectHeight))
        exporter.setColor(sb,"black")
        exporter.drawLine(sb,(((originX + shiftX)) * rectWidth),(startY * rectHeight),(((originX + shiftX)) * rectWidth),(endY * rectHeight))
        exporter.setColor(sb,"black")
        s = exporter.end(sb)
        if (callback is not None):
            callback(s)
            return None
        else:
            return s

    @staticmethod
    def convertData(columns,r):
        awWriter = com_sdtk_table_Array2DWriter.writeToExpandableArray(None)
        arr = awWriter.getArray()
        com_sdtk_table_Converter.convertWithOptions(r,None,awWriter,com_sdtk_table_Formats.ARRAY(),None,columns,None,None,columns,False,False,None,None)
        possibleIMap = haxe_ds_StringMap()
        possibleIArray = list()
        if ((len(arr) == 0) or ((len((arr[0] if 0 < len(arr) else None)) == 2))):
            return arr
        else:
            convertedData = list()
            _g = 0
            while (_g < len(arr)):
                row = (arr[_g] if _g >= 0 and _g < len(arr) else None)
                _g = (_g + 1)
                possibleIMap.h[(row[0] if 0 < len(row) else None)] = True
            i = possibleIMap.keys()
            while i.hasNext():
                i1 = i.next()
                possibleIArray.append(i1)
            possibleIArray.sort(key= python_lib_Functools.cmp_to_key(Reflect.compare))
            i = 0
            j = 0
            curGroup = None
            while ((j < len(arr)) or ((HxOverrides.mod(i, len(possibleIArray)) != 0))):
                if (HxOverrides.mod(i, len(possibleIArray)) == 0):
                    curGroup = python_internal_ArrayImpl._get((arr[j] if j >= 0 and j < len(arr) else None), 2)
                x = python_internal_ArrayImpl._get(possibleIArray, HxOverrides.mod(i, len(possibleIArray)))
                if HxOverrides.eq(x,python_internal_ArrayImpl._get((arr[j] if j >= 0 and j < len(arr) else None), 0)):
                    convertedData.append((arr[j] if j >= 0 and j < len(arr) else None))
                    j = (j + 1)
                else:
                    dummyRow = list()
                    l = len(dummyRow)
                    if (l < 3):
                        idx = 2
                        v = None
                        l1 = len(dummyRow)
                        while (l1 < idx):
                            dummyRow.append(None)
                            l1 = (l1 + 1)
                        if (l1 == idx):
                            dummyRow.append(v)
                        else:
                            dummyRow[idx] = v
                    elif (l > 3):
                        pos = 3
                        _hx_len = (l - 3)
                        if (pos < 0):
                            pos = (len(dummyRow) + pos)
                        if (pos < 0):
                            pos = 0
                        res = dummyRow[pos:(pos + _hx_len)]
                        del dummyRow[pos:(pos + _hx_len)]
                    python_internal_ArrayImpl._set(dummyRow, 0, x)
                    python_internal_ArrayImpl._set(dummyRow, 1, None)
                    python_internal_ArrayImpl._set(dummyRow, 2, curGroup)
                    convertedData.append(dummyRow)
                i = (i + 1)
            return convertedData

    @staticmethod
    def convertDataForPlotByColumnName(r,plotType,x,y,group):
        columns = list()
        if (group is None):
            plotType1 = plotType
            if (plotType1 == 1):
                columns.append(y)
                columns.append(x)
            elif (plotType1 == 2):
                columns.append(x)
                columns.append(y)
            else:
                raise haxe_Exception.thrown("Invalid direction")
        else:
            plotType1 = plotType
            if (plotType1 == 1):
                columns.append(group)
                columns.append(y)
                columns.append(x)
            elif (plotType1 == 2):
                columns.append(group)
                columns.append(x)
                columns.append(y)
            else:
                raise haxe_Exception.thrown("Invalid direction")
        return com_sdtk_graphs_Grapher.convertData(columns,r)

    @staticmethod
    def convertDataForPlotByColumnIndex(r,plotType,x,y,group):
        columns = list()
        if (group is None):
            plotType1 = plotType
            if (plotType1 == 1):
                columns.append(y)
                columns.append(x)
            elif (plotType1 == 2):
                columns.append(x)
                columns.append(y)
            else:
                raise haxe_Exception.thrown("Invalid direction")
        else:
            plotType1 = plotType
            if (plotType1 == 1):
                columns.append(group)
                columns.append(y)
                columns.append(x)
            elif (plotType1 == 2):
                columns.append(group)
                columns.append(x)
                columns.append(y)
            else:
                raise haxe_Exception.thrown("Invalid direction")
        return com_sdtk_graphs_Grapher.convertData(columns,r)

    @staticmethod
    def _plotForData(x,convertedData):
        return python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(convertedData, x), 1)

    @staticmethod
    def getSizeOfGroups(convertedData):
        if (len(convertedData) == 0):
            return 0
        elif (len((convertedData[0] if 0 < len(convertedData) else None)) < 3):
            return len(convertedData)
        else:
            maxSize = -1
            curSize = 0
            prevGroup = None
            j = 0
            while (j < len(convertedData)):
                curGroup = python_internal_ArrayImpl._get((convertedData[j] if j >= 0 and j < len(convertedData) else None), 2)
                if (curGroup != prevGroup):
                    if (curSize > maxSize):
                        maxSize = curSize
                    curSize = 0
                    prevGroup = curGroup
                curSize = (curSize + 1)
                j = (j + 1)
            if (curSize > maxSize):
                maxSize = curSize
            return maxSize

    @staticmethod
    def _getGroups(groups):
        mGroups = haxe_ds_StringMap()
        group = HxOverrides.iterator(groups)
        while group.hasNext():
            group1 = group.next()
            mGroups.h[group1] = True
        aGroups = list()
        group = mGroups.keys()
        while group.hasNext():
            group1 = group.next()
            aGroups.append(group1)
        return aGroups


class com_sdtk_graphs_GrapherUpdateLocationsResults:

    def __init__(self):
        self._groups = None
        self._coordinates = None
        self._locationsY = None
        self._locationsX = None
        self._changed = None


class com_sdtk_graphs_GraphExportTypeOptions:

    def __init__(self,view):
        self._values = haxe_ds_StringMap()
        self._view = view

    def html(self):
        return self.setType(com_sdtk_graphs_GrapherHTMLExporter.getInstance())

    def svg(self):
        return self.setType(com_sdtk_graphs_GrapherSVGExporter.getInstance())

    def tex(self):
        return self.setType(com_sdtk_graphs_GrapherTEXExporter.getInstance())

    def setType(self,t):
        self._values.h["type"] = t
        return com_sdtk_graphs_GraphExportTypeOptionsFinish(self._view,self._values)


class com_sdtk_graphs_GraphExportTypeOptionsFinish:

    def __init__(self,view,values):
        self._view = view
        self._values = values

    def width(self,width):
        self._values.h["width"] = width
        return self

    def height(self,height):
        self._values.h["height"] = height
        return self

    def matchWidth(self):
        self._values.h["width"] = -1
        return self

    def matchHeight(self):
        self._values.h["height"] = -1
        return self

    def toMap(self):
        return self._values

    def execute(self,callback = None):
        return self._view.export(self,callback)


class com_sdtk_graphs_GrapherExporter:
    pass


class com_sdtk_graphs_GrapherHTMLExporter:

    def __init__(self):
        pass

    def getTarget(self):
        return com_sdtk_graphs_StringBufRef()

    def start(self,sb,width,height,scaleX,scaleY):
        sb.add("<html><head><style>.line-segment { transform: rotate(calc(var(--angle) * 1deg)); transform-origin: left bottom; bottom: calc(var(--y1) * 1px); left: calc(var(--x1) * 1px); height: 1px; position: absolute; background-color: black; width: calc(var(--length) * 1px); }</style></head><body><div style=\"width:")
        sb.add((width / scaleX))
        sb.add("px; height: ")
        sb.add((height / scaleY))
        sb.add("px;\">")

    def setCaption(self,sb,caption):
        pass

    def setColor(self,sb,color):
        s = sb.toString()
        update = "style=\""
        startIndex = None
        i = None
        if (startIndex is None):
            i = s.rfind(update, 0, len(s))
        elif (update == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            i = (length if ((startIndex > length)) else startIndex)
        else:
            i1 = s.rfind(update, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(update))) if ((i1 == -1)) else (i1 + 1))
            check = s.find(update, startLeft, len(s))
            i = (check if (((check > i1) and ((check <= startIndex)))) else i1)
        i1 = (i + len(update))
        sb.reset()
        sb.add(HxString.substring(s,0,i1))
        sb.add("color: ")
        sb.add(color)
        sb.add("; background-color: ")
        sb.add(color)
        sb.add("; ")
        sb.add(HxString.substring(s,i1,None))

    def end(self,sb):
        sb.add("</div></body></html>")
        return sb.toString()

    def drawLine(self,sb,x1,y1,x2,y2):
        angle = ((-Math.atan2((y2 - y1),(x2 - x1)) / Math.PI) * 180)
        v = ((((x2 - x1)) * ((x2 - x1))) + ((((y2 - y1)) * ((y2 - y1)))))
        length = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
        sb.add("<div ")
        sb.add("class=\"line-segment\" ")
        sb.add("style=\"--x1: ")
        sb.add(x1)
        sb.add("; --y1: ")
        sb.add(y1)
        sb.add("; --x2: ")
        sb.add(x2)
        sb.add("; --y2: ")
        sb.add(y2)
        sb.add("; --angle: ")
        sb.add(angle)
        sb.add("; --length: ")
        sb.add(length)
        sb.add("; \"> </div>\n")

    def drawRect(self,sb,x1,y1,x2,y2):
        width = (("" + Std.string(((x2 - x1)))) + "px")
        height = (("" + Std.string(((y2 - y1)))) + "px")
        sb.add("<div ")
        sb.add("class=\"graph-box\" ")
        sb.add("style=\"")
        sb.add("left: ")
        sb.add(x1)
        sb.add("; bottom: ")
        sb.add(y1)
        sb.add("; height: ")
        sb.add(height)
        sb.add("; min-height: ")
        sb.add(height)
        sb.add("; max-height: ")
        sb.add(height)
        sb.add("; width: ")
        sb.add(width)
        sb.add("; min-width: ")
        sb.add(width)
        sb.add("; max-width: ")
        sb.add(width)
        sb.add("; \">")
        sb.add("</div>\n")

    def drawCircle(self,sb,x,y,radius):
        size = (("" + Std.string((radius * 2))) + "px")
        sb.add("<div ")
        sb.add("class=\"graph-circle\" ")
        sb.add("style=\"")
        sb.add("left: ")
        sb.add(x)
        sb.add("; bottom: ")
        sb.add(y)
        sb.add("; height: ")
        sb.add(size)
        sb.add("; min-height: ")
        sb.add(size)
        sb.add("; max-height: ")
        sb.add(size)
        sb.add("; width: ")
        sb.add(size)
        sb.add("; min-width: ")
        sb.add(size)
        sb.add("; max-width: ")
        sb.add(size)
        sb.add("; \">")
        sb.add("</div>\n")

    def drawText(self,sb,x,y,p,s):
        sb.add("<div ")
        sb.add("class=\"graph-text\" ")
        sb.add("style=\"")
        sb.add("left: ")
        sb.add(x)
        sb.add("; bottom: ")
        sb.add(y)
        sb.add("; position: absolute; \">")
        sb.add(s)
        sb.add("</div>\n")

    @staticmethod
    def getInstance():
        return com_sdtk_graphs_GrapherHTMLExporter._instance


class com_sdtk_graphs_GrapherSVGExporter:

    def __init__(self):
        pass

    def getTarget(self):
        return com_sdtk_graphs_StringBufRef()

    def start(self,sb,width,height,scaleX,scaleY):
        sb.add("<svg viewBox=\"0 0 ")
        sb.add((width / scaleX))
        sb.add(" ")
        sb.add((height / scaleY))
        sb.add("\" transform=\"scale(1,-1)\" xmlns=\"http://www.w3.org/2000/svg\">")

    def setCaption(self,sb,caption):
        pass

    def setColor(self,sb,color):
        s = sb.toString()
        update = "stroke=\""
        startIndex = None
        i = None
        if (startIndex is None):
            i = s.rfind(update, 0, len(s))
        elif (update == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            i = (length if ((startIndex > length)) else startIndex)
        else:
            i1 = s.rfind(update, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(update))) if ((i1 == -1)) else (i1 + 1))
            check = s.find(update, startLeft, len(s))
            i = (check if (((check > i1) and ((check <= startIndex)))) else i1)
        i1 = (i + len(update))
        j = (s.find("\"") if ((i1 is None)) else HxString.indexOfImpl(s,"\"",i1))
        sb.reset()
        sb.add(HxString.substring(s,0,i1))
        sb.add(color)
        sb.add(HxString.substring(s,j,None))
        s = sb.toString()
        update = "fill=\""
        i1 = (s.find(update) if ((i1 is None)) else HxString.indexOfImpl(s,update,i1))
        if (i1 >= 0):
            i1 = (i1 + len(update))
            j = (s.find("\"") if ((i1 is None)) else HxString.indexOfImpl(s,"\"",i1))
            sb.reset()
            sb.add(HxString.substring(s,0,i1))
            sb.add(color)
            sb.add(HxString.substring(s,j,None))

    def end(self,sb):
        sb.add("</svg>")
        return sb.toString()

    def drawLine(self,sb,x1,y1,x2,y2):
        sb.add("<line x1=\"")
        sb.add(x1)
        sb.add("\" y1=\"")
        sb.add(y1)
        sb.add("\" x2=\"")
        sb.add(x2)
        sb.add("\" y2=\"")
        sb.add(y2)
        sb.add("\" stroke=\"black\" />\n")

    def drawRect(self,sb,x1,y1,x2,y2):
        sb.add("<rect x=\"")
        sb.add(x1)
        sb.add("\" y=\"")
        sb.add(y1)
        sb.add("\" width=\"")
        sb.add((x2 - x1))
        sb.add("\" y2=\"")
        sb.add((y2 - y1))
        sb.add("\" stroke=\"black\" fill=\"black\" />\n")

    def drawCircle(self,sb,x,y,radius):
        sb.add("<circle cx=\"")
        sb.add(x)
        sb.add("\" cy=\"")
        sb.add(y)
        sb.add("\" r=\"")
        sb.add(radius)
        sb.add("\" stroke=\"black\" fill=\"black\" />")

    def drawText(self,sb,x,y,p,s):
        sb.add("<text x=\"")
        sb.add(x)
        sb.add("\" y=\"")
        sb.add(-y)
        sb.add("\" font-family=\"arial\" font-size=\"10\" stroke=\"black\" transform=\"scale(1,-1)\">")
        sb.add(s)
        sb.add("</text>")

    @staticmethod
    def getInstance():
        return com_sdtk_graphs_GrapherSVGExporter._instance


class com_sdtk_graphs_GrapherTEXExporter:

    def __init__(self):
        pass

    def getTarget(self):
        return com_sdtk_graphs_StringBufRef()

    def start(self,sb,width,height,scaleX,scaleY):
        width = (width / scaleX)
        height = (height / scaleY)
        pageHeight = 254
        pageWidth = 190.5
        adjustHeight = (pageHeight / height)
        adjustWidth = (pageWidth / width)
        sb.add("\\documentclass{article}\n")
        sb.add("\\usepackage[left=0cm, right=0cm]{geometry}\n")
        sb.add("\\usepackage{xcolor}")
        sb.add("\\setlength{\\unitlength}{")
        sb.add((adjustHeight if ((adjustHeight < adjustWidth)) else adjustWidth))
        sb.add("mm}\n")
        sb.add("\\begin{document}\n")
        sb.add("\\begin{picture}(")
        sb.add(width)
        sb.add(",")
        sb.add(height)
        sb.add(")\n")

    def setCaption(self,sb,caption):
        pass

    def setColor(self,sb,color):
        s = sb.toString()
        update = "\\"
        startIndex = None
        i = None
        if (startIndex is None):
            i = s.rfind(update, 0, len(s))
        elif (update == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            i = (length if ((startIndex > length)) else startIndex)
        else:
            i1 = s.rfind(update, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(update))) if ((i1 == -1)) else (i1 + 1))
            check = s.find(update, startLeft, len(s))
            i = (check if (((check > i1) and ((check <= startIndex)))) else i1)
        sb.reset()
        sb.add(HxString.substring(s,0,i))
        sb.add("\\color{")
        sb.add(color)
        sb.add("}\n")
        sb.add(HxString.substring(s,i,None))

    def end(self,sb):
        sb.add("\\end{picture}\n")
        sb.add("\\end{document}\n")
        return sb.toString()

    def drawLine(self,sb,x1,y1,x2,y2):
        sb.add("\\qbezier(")
        sb.add(x1)
        sb.add(",")
        sb.add(y1)
        sb.add(")(")
        sb.add((((x1 + x2)) / 2))
        sb.add(",")
        sb.add((((y1 + y2)) / 2))
        sb.add(")(")
        sb.add(x2)
        sb.add(",")
        sb.add(y2)
        sb.add(")\n")

    def drawRect(self,sb,x1,y1,x2,y2):
        pass

    def drawCircle(self,sb,x,y,radius):
        pass

    def drawText(self,sb,x,y,p,s):
        sb.add("\\put(")
        sb.add(x)
        sb.add(",")
        sb.add(y)
        sb.add("){")
        sb.add(s)
        sb.add("}\n")

    @staticmethod
    def getInstance():
        return com_sdtk_graphs_GrapherTEXExporter._instance


class com_sdtk_graphs_StringBufRef:

    def __init__(self):
        self.sb = None
        self.reset()

    def add(self,s):
        _this = self.sb
        s1 = Std.string(s)
        _this.b.write(s1)

    def toString(self):
        return self.sb.b.getvalue()

    def reset(self):
        self.sb = StringBuf()


class com_sdtk_graphs_GrapherOptions:

    def __init__(self):
        self._values = haxe_ds_StringMap()

    def plotFunctionForX(self,f):
        return com_sdtk_graphs_GrapherOptions._plotFunctionForX(com_sdtk_graphs_GrapherOptions.setOnceI,self,f)

    def plotFunctionForY(self,f):
        return com_sdtk_graphs_GrapherOptions._plotFunctionForY(com_sdtk_graphs_GrapherOptions.setOnceI,self,f)

    def plotFunctionsForX(self,f):
        return com_sdtk_graphs_GrapherOptions._plotFunctionsForX(com_sdtk_graphs_GrapherOptions.setOnceI,self,f)

    def plotFunctionsForY(self,f):
        return com_sdtk_graphs_GrapherOptions._plotFunctionsForY(com_sdtk_graphs_GrapherOptions.setOnceI,self,f)

    def plotDataByColumnNameForY(self,r,x,y,group = None):
        return com_sdtk_graphs_GrapherOptions._plotDataByColumnNameForY(com_sdtk_graphs_GrapherOptions.setOnceI,self,r,x,y,group)

    def plotDataByColumnNameForX(self,r,x,y,group = None):
        return com_sdtk_graphs_GrapherOptions._plotDataByColumnNameForX(com_sdtk_graphs_GrapherOptions.setOnceI,self,r,x,y,group)

    def plotDataByColumnIndexForY(self,r,x,y,group = None):
        return com_sdtk_graphs_GrapherOptions._plotDataByColumnIndexForY(com_sdtk_graphs_GrapherOptions.setOnceI,self,r,x,y,group)

    def plotDataByColumnIndexForX(self,r,x,y,group = None):
        return com_sdtk_graphs_GrapherOptions._plotDataByColumnIndexForX(com_sdtk_graphs_GrapherOptions.setOnceI,self,r,x,y,group)

    def positiveOnlyY(self):
        return com_sdtk_graphs_GrapherOptions._positiveOnlyY(com_sdtk_graphs_GrapherOptions.setOnceI,self)

    def negativeOnlyY(self):
        return com_sdtk_graphs_GrapherOptions._negativeOnlyY(com_sdtk_graphs_GrapherOptions.setOnceI,self)

    def positiveAndNegativeY(self):
        return com_sdtk_graphs_GrapherOptions._positiveAndNegativeY(com_sdtk_graphs_GrapherOptions.setOnceI,self)

    def positiveOnlyX(self):
        return com_sdtk_graphs_GrapherOptions._positiveOnlyX(com_sdtk_graphs_GrapherOptions.setOnceI,self)

    def negativeOnlyX(self):
        return com_sdtk_graphs_GrapherOptions._negativeOnlyX(com_sdtk_graphs_GrapherOptions.setOnceI,self)

    def positiveAndNegativeX(self):
        return com_sdtk_graphs_GrapherOptions._positiveAndNegativeX(com_sdtk_graphs_GrapherOptions.setOnceI,self)

    def matchWidth(self):
        return com_sdtk_graphs_GrapherOptions._matchWidth(com_sdtk_graphs_GrapherOptions.setOnceI,self)

    def matchHeight(self):
        return com_sdtk_graphs_GrapherOptions._matchHeight(com_sdtk_graphs_GrapherOptions.setOnceI,self)

    def width(self,w):
        return com_sdtk_graphs_GrapherOptions._width(com_sdtk_graphs_GrapherOptions.setOnceI,self,w)

    def height(self,h):
        return com_sdtk_graphs_GrapherOptions._height(com_sdtk_graphs_GrapherOptions.setOnceI,self,h)

    def colors(self,colors):
        return com_sdtk_graphs_GrapherOptions._colors(com_sdtk_graphs_GrapherOptions.setOnceI,self,colors)

    def setOnce(self,key,value):
        if (self._values.h.get(key,None) is None):
            self._values.h[key] = value
            return value
        else:
            raise haxe_Exception.thrown("Can only set once.")

    def toMap(self):
        return self._values

    def execute(self):
        return com_sdtk_graphs_Grapher.create(self)

    @staticmethod
    def _plotFunctionForX(setOnce,options,f):
        setOnce(options,"plotFunction",f)
        return setOnce(options,"plotType",1)

    @staticmethod
    def _plotFunctionForY(setOnce,options,f):
        setOnce(options,"plotFunction",f)
        return setOnce(options,"plotType",2)

    @staticmethod
    def _plotFunctionsForX(setOnce,options,f):
        setOnce(options,"plotFunctions",f)
        return setOnce(options,"plotType",1)

    @staticmethod
    def _plotFunctionsForY(setOnce,options,f):
        setOnce(options,"plotFunctions",f)
        return setOnce(options,"plotType",2)

    @staticmethod
    def _plotDataByColumnNameForY(setOnce,options,r,x,y,group = None):
        setOnce(options,"plotType",2)
        setOnce(options,"reader",r)
        setOnce(options,"dataX",x)
        setOnce(options,"dataY",y)
        setOnce(options,"dataGroup",group)
        return setOnce(options,"dataByIndex",False)

    @staticmethod
    def _plotDataByColumnNameForX(setOnce,options,r,x,y,group = None):
        setOnce(options,"plotType",1)
        setOnce(options,"reader",r)
        setOnce(options,"dataX",x)
        setOnce(options,"dataY",y)
        setOnce(options,"dataGroup",group)
        return setOnce(options,"dataByIndex",False)

    @staticmethod
    def _plotDataByColumnIndexForY(setOnce,options,r,x,y,group = None):
        setOnce(options,"plotType",2)
        setOnce(options,"reader",r)
        setOnce(options,"dataX",x)
        setOnce(options,"dataY",y)
        setOnce(options,"dataGroup",group)
        return setOnce(options,"dataByIndex",True)

    @staticmethod
    def _plotDataByColumnIndexForX(setOnce,options,r,x,y,group = None):
        setOnce(options,"plotType",1)
        setOnce(options,"reader",r)
        setOnce(options,"dataX",x)
        setOnce(options,"dataY",y)
        setOnce(options,"dataGroup",group)
        return setOnce(options,"dataByIndex",True)

    @staticmethod
    def _positiveOnlyY(setOnce,options):
        return setOnce(options,"centerOfY",1)

    @staticmethod
    def _negativeOnlyY(setOnce,options):
        return setOnce(options,"centerOfY",-1)

    @staticmethod
    def _positiveAndNegativeY(setOnce,options):
        return setOnce(options,"centerOfY",0)

    @staticmethod
    def _positiveOnlyX(setOnce,options):
        return setOnce(options,"centerOfX",1)

    @staticmethod
    def _negativeOnlyX(setOnce,options):
        return setOnce(options,"centerOfX",-1)

    @staticmethod
    def _positiveAndNegativeX(setOnce,options):
        return setOnce(options,"centerOfX",0)

    @staticmethod
    def _matchWidth(setOnce,options):
        return setOnce(options,"width",-1)

    @staticmethod
    def _matchHeight(setOnce,options):
        return setOnce(options,"height",-1)

    @staticmethod
    def _width(setOnce,options,w):
        return setOnce(options,"width",w)

    @staticmethod
    def _height(setOnce,options,h):
        return setOnce(options,"height",h)

    @staticmethod
    def _colors(setOnce,options,colors):
        return setOnce(options,"colors",colors)

    @staticmethod
    def setOnceI(o,key,value):
        o2 = o
        o2.setOnce(key,value)
        return o


class com_sdtk_log_Parameters(com_sdtk_std_Parameters):

    def __init__(self):
        self._outputControlId = None
        self._file = None
        self._processParams = None
        self._process = None
        self._exclude = None
        self._include = None
        self._inputMode = 0
        self._outputMode = 0
        super().__init__()
        i = 0
        sParameter = None
        while True:
            sParameter = self.getParameter(i)
            if (sParameter is not None):
                if (self._process is not None):
                    _this = self._processParams
                    _this.append(sParameter)
                else:
                    _g = sParameter.upper()
                    _hx_local_0 = len(_g)
                    if (_hx_local_0 == 11):
                        if (_g == "EVENTLOGGER"):
                            self._outputMode = 1
                        elif (_g == "EVENTVIEWER"):
                            self._outputMode = 1
                        else:
                            startIndex = None
                            iPeriod = (sParameter.find(".") if ((startIndex is None)) else HxString.indexOfImpl(sParameter,".",startIndex))
                            startIndex1 = None
                            iHash = (sParameter.find("#") if ((startIndex1 is None)) else HxString.indexOfImpl(sParameter,"#",startIndex1))
                            if ((iPeriod == 0) or ((iHash == 0))):
                                self._outputControlId = sParameter
                                self._outputMode = 3
                            elif (iPeriod < 0):
                                self._process = sParameter
                                self._inputMode = 1
                            else:
                                self._file = sParameter
                                self._inputMode = 0
                    elif (_hx_local_0 == 9):
                        if (_g == "EVENTLOGS"):
                            self._outputMode = 1
                        else:
                            startIndex = None
                            iPeriod = (sParameter.find(".") if ((startIndex is None)) else HxString.indexOfImpl(sParameter,".",startIndex))
                            startIndex1 = None
                            iHash = (sParameter.find("#") if ((startIndex1 is None)) else HxString.indexOfImpl(sParameter,"#",startIndex1))
                            if ((iPeriod == 0) or ((iHash == 0))):
                                self._outputControlId = sParameter
                                self._outputMode = 3
                            elif (iPeriod < 0):
                                self._process = sParameter
                                self._inputMode = 1
                            else:
                                self._file = sParameter
                                self._inputMode = 0
                    elif (_hx_local_0 == 5):
                        if (_g == "ALERT"):
                            self._outputMode = 2
                        elif (_g == "POPUP"):
                            self._outputMode = 2
                        elif (_g == "EVENT"):
                            self._outputMode = 1
                        else:
                            startIndex = None
                            iPeriod = (sParameter.find(".") if ((startIndex is None)) else HxString.indexOfImpl(sParameter,".",startIndex))
                            startIndex1 = None
                            iHash = (sParameter.find("#") if ((startIndex1 is None)) else HxString.indexOfImpl(sParameter,"#",startIndex1))
                            if ((iPeriod == 0) or ((iHash == 0))):
                                self._outputControlId = sParameter
                                self._outputMode = 3
                            elif (iPeriod < 0):
                                self._process = sParameter
                                self._inputMode = 1
                            else:
                                self._file = sParameter
                                self._inputMode = 0
                    elif (_hx_local_0 == 3):
                        if (_g == "POP"):
                            self._outputMode = 2
                        else:
                            startIndex = None
                            iPeriod = (sParameter.find(".") if ((startIndex is None)) else HxString.indexOfImpl(sParameter,".",startIndex))
                            startIndex1 = None
                            iHash = (sParameter.find("#") if ((startIndex1 is None)) else HxString.indexOfImpl(sParameter,"#",startIndex1))
                            if ((iPeriod == 0) or ((iHash == 0))):
                                self._outputControlId = sParameter
                                self._outputMode = 3
                            elif (iPeriod < 0):
                                self._process = sParameter
                                self._inputMode = 1
                            else:
                                self._file = sParameter
                                self._inputMode = 0
                    elif (_hx_local_0 == 7):
                        if (_g == "CONTROL"):
                            i = (i + 1)
                            self._outputControlId = self.getParameter(i)
                            self._outputMode = 3
                        elif (_g == "EXCLUDE"):
                            i = (i + 1)
                            self._exclude = self.getParameter(i)
                        elif (_g == "INCLUDE"):
                            i = (i + 1)
                            self._include = self.getParameter(i)
                        elif (_g == "VERSION"):
                            _hx_str = Std.string(("Version " + HxOverrides.stringOrNull(com_sdtk_std_Version.get())))
                            python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
                        else:
                            startIndex = None
                            iPeriod = (sParameter.find(".") if ((startIndex is None)) else HxString.indexOfImpl(sParameter,".",startIndex))
                            startIndex1 = None
                            iHash = (sParameter.find("#") if ((startIndex1 is None)) else HxString.indexOfImpl(sParameter,"#",startIndex1))
                            if ((iPeriod == 0) or ((iHash == 0))):
                                self._outputControlId = sParameter
                                self._outputMode = 3
                            elif (iPeriod < 0):
                                self._process = sParameter
                                self._inputMode = 1
                            else:
                                self._file = sParameter
                                self._inputMode = 0
                    elif (_hx_local_0 == 8):
                        if (_g == "EVENTLOG"):
                            self._outputMode = 1
                        else:
                            startIndex = None
                            iPeriod = (sParameter.find(".") if ((startIndex is None)) else HxString.indexOfImpl(sParameter,".",startIndex))
                            startIndex1 = None
                            iHash = (sParameter.find("#") if ((startIndex1 is None)) else HxString.indexOfImpl(sParameter,"#",startIndex1))
                            if ((iPeriod == 0) or ((iHash == 0))):
                                self._outputControlId = sParameter
                                self._outputMode = 3
                            elif (iPeriod < 0):
                                self._process = sParameter
                                self._inputMode = 1
                            else:
                                self._file = sParameter
                                self._inputMode = 0
                    elif (_hx_local_0 == 6):
                        if (_g == "ALERTS"):
                            self._outputMode = 2
                        elif (_g == "EVENTS"):
                            self._outputMode = 1
                        else:
                            startIndex = None
                            iPeriod = (sParameter.find(".") if ((startIndex is None)) else HxString.indexOfImpl(sParameter,".",startIndex))
                            startIndex1 = None
                            iHash = (sParameter.find("#") if ((startIndex1 is None)) else HxString.indexOfImpl(sParameter,"#",startIndex1))
                            if ((iPeriod == 0) or ((iHash == 0))):
                                self._outputControlId = sParameter
                                self._outputMode = 3
                            elif (iPeriod < 0):
                                self._process = sParameter
                                self._inputMode = 1
                            else:
                                self._file = sParameter
                                self._inputMode = 0
                    else:
                        startIndex = None
                        iPeriod = (sParameter.find(".") if ((startIndex is None)) else HxString.indexOfImpl(sParameter,".",startIndex))
                        startIndex1 = None
                        iHash = (sParameter.find("#") if ((startIndex1 is None)) else HxString.indexOfImpl(sParameter,"#",startIndex1))
                        if ((iPeriod == 0) or ((iHash == 0))):
                            self._outputControlId = sParameter
                            self._outputMode = 3
                        elif (iPeriod < 0):
                            self._process = sParameter
                            self._inputMode = 1
                        else:
                            self._file = sParameter
                            self._inputMode = 0
            i = (i + 1)
            if (not ((sParameter is not None))):
                break

    def getOutputMode(self):
        return self._outputMode

    def getInputMode(self):
        return self._inputMode

    def getFileParam(self):
        return self._file

    def getProcessParams(self):
        return self._processParams

    def getProcessParam(self):
        return self._process

    def getControlParam(self):
        return self._outputControlId

    def getInclude(self):
        return self._include

    def getExclude(self):
        return self._exclude


class com_sdtk_std_DataIterable:
    pass


class com_sdtk_std_DataIterator:
    pass


class com_sdtk_std_Disposable:
    pass


class com_sdtk_std_Reader:

    def __init__(self):
        pass

    def flip(self):
        return None

    def start(self):
        pass

    def rawIndex(self):
        return -1

    def jumpTo(self,index):
        pass

    def hasNext(self):
        return False

    def next(self):
        return None

    def peek(self):
        return None

    def dispose(self):
        pass

    def iterator(self):
        return self

    def switchToLineReader(self):
        return com_sdtk_std_WholeLineReader(self)

    def unwrapOne(self):
        return self

    def unwrapAll(self):
        return self

    def toString(self):
        sb_b = python_lib_io_StringIO()
        while self.hasNext():
            sb_b.write(Std.string(self.next()))
        return sb_b.getvalue()

    def convertToStringReader(self):
        sr = com_sdtk_std_StringReader(self.toString())
        self.dispose()
        return sr

    def reset(self):
        pass


class com_sdtk_log_ProcessReader(com_sdtk_std_Reader):

    def __init__(self,sCommand,sParameters):
        self._process = None
        super().__init__()
        self._process = sys_io_Process(sCommand,sParameters)

    def get(self):
        return self._process.stdout.readLine()

    def end(self):
        try:
            self._process.close()
        except BaseException as _g:
            None


class com_sdtk_std_Flushable:
    pass


class com_sdtk_std_Writer:

    def __init__(self):
        pass

    def flip(self):
        return None

    def start(self):
        pass

    def dispose(self):
        pass

    def flush(self):
        pass

    def write(self,_hx_str):
        pass

    def switchToLineWriter(self):
        return com_sdtk_std_WholeLineWriter(self)

    def unwrapOne(self):
        return self

    def unwrapAll(self):
        return self


class com_sdtk_log_TSFileWriter(com_sdtk_std_Writer):

    def __init__(self,sLocation):
        self._path = None
        self._location = None
        super().__init__()
        self._location = sLocation
        sSeparator = ""
        tmp = ("" if ((self._location is None)) else self._location)
        v = (self.getTimeStamp() * 1000.0)
        self._path = ((("null" if tmp is None else tmp) + ("null" if sSeparator is None else sSeparator)) + Std.string(((v if (((v == Math.POSITIVE_INFINITY) or ((v == Math.NEGATIVE_INFINITY)))) else (Math.NaN if (python_lib_Math.isnan(v)) else Math.floor(v))))))
        self._path = haxe_io_Path(self._path).toString()

    def getTimeStamp(self):
        return python_lib_Time.time()

    def write(self,sLine):
        try:
            out = sys_io_File.append(self._path,False)
            try:
                out.writeString(sLine)
                out.writeString("\n")
            except BaseException as _g:
                None
            out.close()
        except BaseException as _g:
            None


class com_sdtk_log_TimeStampWriter(com_sdtk_std_Writer):

    def __init__(self,sWrapped,sDateFormat,sEntryFormat,bIndicateStartAndEnd):
        self._indicateStartEnd = None
        self._entryFormat = None
        self._dateFormat = None
        self._wrapped = None
        super().__init__()
        self._wrapped = sWrapped
        self._dateFormat = ("%Y-%m-%d_%H:%M:%S" if ((sDateFormat is None)) else sDateFormat)
        self._entryFormat = ("%timestamp% - %entry%" if ((sEntryFormat is None)) else sEntryFormat)
        _this = self._entryFormat
        startIndex = None
        if (((_this.find("%timestamp%") if ((startIndex is None)) else HxString.indexOfImpl(_this,"%timestamp%",startIndex))) < 0):
            self._entryFormat = ("%timestamp%" + HxOverrides.stringOrNull(self._entryFormat))
        _this = self._entryFormat
        startIndex = None
        if (((_this.find("%entry%") if ((startIndex is None)) else HxString.indexOfImpl(_this,"%entry%",startIndex))) < 0):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0._entryFormat
            _hx_local_0._entryFormat = (("null" if _hx_local_1 is None else _hx_local_1) + "%entry%")
            _hx_local_0._entryFormat
        self._indicateStartEnd = bIndicateStartAndEnd
        if self._indicateStartEnd:
            self.write("Started")

    def write(self,sLine):
        self._wrapped.write(StringTools.replace(StringTools.replace(self._entryFormat,"%timestamp%",DateTools.format(Date.now(),self._dateFormat)),"%entry%",sLine))

    def dispose(self):
        if self._indicateStartEnd:
            self.write("Ended")
        self._wrapped.dispose()


class com_sdtk_log_Transfer:

    def __init__(self):
        pass

    def transfer(self,reader,writer):
        sLine = reader.next()
        while (sLine is not None):
            writer.write(sLine)
            sLine = reader.next()
        reader.dispose()
        writer.dispose()

    @staticmethod
    def defaultTransfer(sLocation,pParameters):
        rReader = None
        wWriter = None
        _g = pParameters.getOutputMode()
        if (_g == 0):
            wWriter = com_sdtk_log_TSFileWriter(sLocation)
        elif (_g == 1):
            wWriter = com_sdtk_std_SysLogWriter()
        elif (_g == 2):
            wWriter = com_sdtk_std_PopUpWriter()
        elif (_g == 3):
            wWriter = com_sdtk_std_ControlWriter(pParameters.getControlParam())
        else:
            pass
        wWriter = wWriter.switchToLineWriter()
        _g = pParameters.getInputMode()
        if (_g == 0):
            rReader = com_sdtk_std_StdinReader()
        elif (_g == 1):
            rReader = com_sdtk_log_ProcessReader(pParameters.getProcessParam(),pParameters.getProcessParams())
        else:
            pass
        rReader = rReader.switchToLineReader()
        if ((pParameters.getInclude() is not None) or ((pParameters.getExclude() is not None))):
            frReader = com_sdtk_std_FilterReader(rReader)
            rReader = frReader
            if (pParameters.getInclude() is not None):
                frReader.addFilter(com_sdtk_std_Filter.parse(pParameters.getInclude(),False))
            if (pParameters.getExclude() is not None):
                frReader.addFilter(com_sdtk_std_Filter.parse(pParameters.getExclude(),True))
        com_sdtk_log_Transfer().transfer(rReader,wWriter)

    @staticmethod
    def main():
        pParameters = com_sdtk_log_Parameters()
        sLocation = None
        try:
            sLocation = pParameters.getFileParam()
        except BaseException as _g:
            None
        if (sLocation is None):
            sLocation = "~/Log"
        bWindows = False
        _this = Sys.systemName()
        startIndex = None
        bWindows = (((_this.find("Windows") if ((startIndex is None)) else HxString.indexOfImpl(_this,"Windows",startIndex))) >= 0)
        if bWindows:
            sLocation = StringTools.replace(StringTools.replace(sLocation,"/","\\"),"~","%userprofile%")
            env = Sys.environment()
            v = env.keys()
            while v.hasNext():
                v1 = v.next()
                val = env.h.get(v1,None)
                sLocation = StringTools.replace(sLocation,(("%" + HxOverrides.stringOrNull(v1.lower())) + "%"),val)
                sLocation = StringTools.replace(sLocation,(("%" + HxOverrides.stringOrNull(v1.upper())) + "%"),val)
        com_sdtk_log_Transfer.defaultTransfer(sLocation,pParameters)


class com_sdtk_proxy_Proxy:

    @staticmethod
    def proxy(obj):
        db = com_sdtk_table_DatabaseReaderOptions().database(Reflect.field(obj,"connector"))
        if (Reflect.field(obj,"user") is not None):
            db.user(Reflect.field(obj,"user"))
        if (Reflect.field(obj,"password") is not None):
            db.password(Reflect.field(obj,"password"))
        if (Reflect.field(obj,"account") is not None):
            db.account(Reflect.field(obj,"account"))
        if (Reflect.field(obj,"warehouse") is not None):
            db.warehouse(Reflect.field(obj,"warehouse"))
        if (Reflect.field(obj,"role") is not None):
            db.role(Reflect.field(obj,"role"))
        if (Reflect.field(obj,"database") is not None):
            db.database(Reflect.field(obj,"database"))
        if (Reflect.field(obj,"schema") is not None):
            db.schema(Reflect.field(obj,"schema"))
        if (Reflect.field(obj,"host") is not None):
            db.host(Reflect.field(obj,"host"))
        if (Reflect.field(obj,"file") is not None):
            db.file(Reflect.field(obj,"file"))
        if (Reflect.field(obj,"driver") is not None):
            db.driver(Reflect.field(obj,"driver"))
        if (Reflect.field(obj,"size") is not None):
            db.size(Reflect.field(obj,"size"))
        def _hx_local_0(reader):
            reader.convertTo(com_sdtk_table_KeyValueWriter.createJSONWriter(com_sdtk_std_StdoutWriter()))
        db.queryForReader(Reflect.field(obj,"query"),Reflect.field(obj,"params"),_hx_local_0)

    @staticmethod
    def getURL(url):
        return None

    @staticmethod
    def getGoogleEmail(token):
        return com_sdtk_proxy_Proxy.getURL(("http://www.googleapis.com/oauth2/v1/userinfo?access_token=" + ("null" if token is None else token)))

    @staticmethod
    def requestVariable(v):
        return None

    @staticmethod
    def main():
        data = ""
        if com_sdtk_proxy_Proxy.checkForLogin:
            accessToken = com_sdtk_proxy_Proxy.requestVariable("access_token")
            email = None
            if com_sdtk_proxy_Proxy.verifyLogin:
                if (com_sdtk_proxy_Proxy.requestVariable("access_token_type") == "google"):
                    email = com_sdtk_proxy_Proxy.getGoogleEmail(accessToken)
            else:
                email = com_sdtk_proxy_Proxy.requestVariable("access_email")
            if (email is None):
                return
        try:
            reader = com_sdtk_std_StdinReader()
            while reader.hasNext():
                data = (("null" if data is None else data) + HxOverrides.stringOrNull(reader.next()))
        except BaseException as _g:
            None
        data = StringTools.trim(data)
        if (len(data) > 0):
            obj = com_sdtk_std_Normalize.parseJson(data)
            data = None
            com_sdtk_proxy_Proxy.proxy(obj)


class com_sdtk_puller_Parameters(com_sdtk_std_Parameters):

    def __init__(self):
        self._parameterList = None
        self._stage = -1
        self._output = list()
        self._sources = list()
        super().__init__()
        i = 0
        sParameter = None
        while True:
            sParameter = self.getParameter(i)
            if (self.isDataFile(sParameter) and ((i == 0))):
                self._parameterList = list()
                sDataFile = sParameter
                i = (i + 1)
                sParameter = self.getParameter(i)
                while (sParameter is not None):
                    self.addParameterListSection(sParameter)
                    i = (i + 1)
                    sParameter = self.getParameter(i)
                self.setParameterList(sDataFile)
                i = 0
                if (sParameter is None):
                    break
                else:
                    continue
            if (i == ((self.length() - 1))):
                _this = self._output
                _this.append(sParameter)
            else:
                _this1 = self._sources
                _this1.append(sParameter)
            i = (i + 1)
            if (sParameter is None):
                break

    def getParameter(self,i):
        if (self._parameterList is None):
            return super().getParameter(i)
        elif (i < len(self._parameterList)):
            return (self._parameterList[i] if i >= 0 and i < len(self._parameterList) else None)
        else:
            return None

    def isDataFile(self,s):
        s = s.lower()
        if (not (((((((com_sdtk_puller_Parameters.endsWith(s,".csv") or com_sdtk_puller_Parameters.endsWith(s,".tsv")) or com_sdtk_puller_Parameters.endsWith(s,".psv")) or com_sdtk_puller_Parameters.endsWith(s,".json")) or com_sdtk_puller_Parameters.endsWith(s,".xml")) or com_sdtk_puller_Parameters.endsWith(s,".yaml")) or com_sdtk_puller_Parameters.endsWith(s,".yml")))):
            return com_sdtk_puller_Parameters.endsWith(s,".json")
        else:
            return True

    def addParameterListSection(self,s):
        _this = self._parameterList
        _this.append(s)

    def setParameterList(self,sFile):
        sFileType = None
        parameterListSection = self._parameterList
        self._parameterList = list()
        i = 0
        _this = sFile.lower()
        sFile2 = _this.split(".")
        sFileType = python_internal_ArrayImpl._get(sFile2, (len(sFile2) - 1))
        sFile2 = None
        rReader = com_sdtk_std_FileReader(sFile)
        drReader = None
        sFile1 = sFile
        _hx_local_0 = len(sFile1)
        if (_hx_local_0 == 4):
            if (sFile1 == "json"):
                drReader = com_sdtk_table_KeyValueReader.createJSONReader(rReader)
        elif (_hx_local_0 == 3):
            if (sFile1 == "csv"):
                drReader = com_sdtk_table_DelimitedReader.createCSVReader(rReader)
            elif (sFile1 == "psv"):
                drReader = com_sdtk_table_DelimitedReader.createPSVReader(rReader)
            elif (sFile1 == "tsv"):
                drReader = com_sdtk_table_DelimitedReader.createTSVReader(rReader)
        else:
            pass
        rReader = None
        drReader.start()
        while drReader.hasNext():
            rRow = drReader.next()
            mRow = rRow.toHaxeMap()
            if ((len(parameterListSection) <= 0) or ((python_internal_ArrayImpl.indexOf(parameterListSection,mRow.get("name"),None) >= 0))):
                tmp = (mRow.get("type") == "CustomWebAPI")
        drReader.dispose()

    def getSource(self):
        _hx_str = Std.string(((("Stage: " + Std.string(self._stage)) + " of ") + Std.string(((len(self._sources) + len(self._output))))))
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        if ((self._stage > len(self._sources)) or ((self._stage < 0))):
            return None
        else:
            try:
                return com_sdtk_puller_Parameters.getSourceFrom(python_internal_ArrayImpl._get(self._sources, self._stage))
            except BaseException as _g:
                None
                return None

    def getOutput(self):
        return None

    def next(self):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._stage
        _hx_local_0._stage = (_hx_local_1 + 1)
        _hx_local_1
        return (self._stage < ((len(self._sources) + len(self._output))))

    @staticmethod
    def typeOfAccess(s):
        startIndex = None
        if (((s.find("https://github.com/") if ((startIndex is None)) else HxString.indexOfImpl(s,"https://github.com/",startIndex))) == 0):
            return com_sdtk_puller_Parameters.GET_GIT_HTTP
        else:
            startIndex = None
            if (((s.find("x-github-client://") if ((startIndex is None)) else HxString.indexOfImpl(s,"x-github-client://",startIndex))) == 0):
                return com_sdtk_puller_Parameters.GET_GIT_CLIENT
            else:
                tmp = None
                startIndex = None
                if (((s.find("http://") if ((startIndex is None)) else HxString.indexOfImpl(s,"http://",startIndex))) != 0):
                    startIndex = None
                    tmp = (((s.find("https://") if ((startIndex is None)) else HxString.indexOfImpl(s,"https://",startIndex))) == 0)
                else:
                    tmp = True
                if tmp:
                    return com_sdtk_puller_Parameters.GET_HTTP
                else:
                    startIndex = None
                    if (((s.find("{") if ((startIndex is None)) else HxString.indexOfImpl(s,"{",startIndex))) == 0):
                        return com_sdtk_puller_Parameters.GET_CUSTOM_WEB_API
                    else:
                        startIndex = None
                        if (((s.find("x-sdtk-custom-web-api://") if ((startIndex is None)) else HxString.indexOfImpl(s,"x-sdtk-custom-web-api://",startIndex))) == 0):
                            return com_sdtk_puller_Parameters.GET_CUSTOM_WEB_API_FILE
                        else:
                            return com_sdtk_puller_Parameters.GET_EXECUTE

    @staticmethod
    def endsWith(s,e):
        return (HxString.substr(s,(len(s) - len(e)),None) == e)

    @staticmethod
    def getSourceFrom(s):
        input = None
        mapping = haxe_ds_StringMap()
        _g = com_sdtk_puller_Parameters.typeOfAccess(s)
        if (_g == com_sdtk_puller_Parameters.GET_CUSTOM_WEB_API):
            custom = com_sdtk_api_CustomWebAPI.singleFromJSON(s)
            return com_sdtk_puller_Source.fromCustomWebAPI(custom)
        elif (_g == com_sdtk_puller_Parameters.GET_CUSTOM_WEB_API_FILE):
            startIndex = None
            if (((s.find("x-sdtk-custom-web-api://") if ((startIndex is None)) else HxString.indexOfImpl(s,"x-sdtk-custom-web-api://",startIndex))) == 0):
                s = HxString.substr(s,len("x-sdtk-custom-web-api://"),None)
            custom = com_sdtk_api_CustomWebAPI.singleFromJSON(com_sdtk_std_FileReader(s).toString())
            return com_sdtk_puller_Source.fromCustomWebAPI(custom)
        elif ((_g == com_sdtk_puller_Parameters.GET_GIT_HTTP) or ((_g == com_sdtk_puller_Parameters.GET_GIT_CLIENT))):
            input = com_sdtk_api_GitAPI.instance().parse(s)
        elif (_g == com_sdtk_puller_Parameters.GET_HTTP):
            custom = com_sdtk_api_CustomWebAPI.create(s)
            custom.setUrl(s)
            return com_sdtk_puller_Source.fromCustomWebAPI(custom)
        else:
            pass
        return com_sdtk_puller_Source.fromInputAPI(input)


class com_sdtk_puller_Puller:

    def __init__(self):
        self._outputs = list()
        self._sources = list()

    def addSource(self,source):
        _this = self._sources
        _this.append(source)

    def addOutput(self,output):
        _this = self._sources
        _this.append(output)

    def pull(self):
        self.nextPull(0)

    def nextPull(self,i):
        _gthis = self
        _hx_str = "Start"
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        def _hx_local_0(result):
            _hx_str = "Done"
            python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
            _hx_str = Std.string(haxe_format_JsonPrinter.print(result,None,None))
            python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
            if ((i + 1) < len(_gthis._sources)):
                _gthis.nextPull((i + 1))
            else:
                _gthis.nextPut(0)
        (self._sources[i] if i >= 0 and i < len(self._sources) else None).pullAsMap(_hx_local_0)

    def nextPut(self,i):
        pass

    @staticmethod
    def main():
        import ssl
        orig_sslsocket_init = ssl.SSLSocket.__init__
        ssl.SSLSocket.__init__ = lambda *args, cert_reqs=ssl.CERT_NONE, **kwargs: orig_sslsocket_init(*args, cert_reqs=ssl.CERT_NONE, **kwargs)
        pParameters = com_sdtk_puller_Parameters()
        pPuller = com_sdtk_puller_Puller()
        while pParameters.next():
            source = pParameters.getSource()
            output = pParameters.getOutput()
            if (source is not None):
                _hx_str = "Add source"
                python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
                pPuller.addSource(source)
            if (output is not None):
                str1 = "Add output"
                python_Lib.printString((("" + ("null" if str1 is None else str1)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
                pPuller.addOutput(output)
        pPuller.pull()

    @staticmethod
    def validSource(source):
        return (com_sdtk_puller_Parameters.typeOfAccess(source) >= 0)

    @staticmethod
    def pullAsString(source,callback):
        com_sdtk_puller_Parameters.getSourceFrom(source).pullAsString(callback)

    @staticmethod
    def pullAsMap(source,callback):
        com_sdtk_puller_Parameters.getSourceFrom(source).pullAsMap(callback)


class com_sdtk_puller_Source:

    def __init__(self):
        pass

    def pullAsMap(self,callback):
        pass

    def pullAsString(self,callback):
        pass

    @staticmethod
    def fromInputAPI(api):
        return com_sdtk_puller_SourceInputAPI(api)

    @staticmethod
    def fromCustomWebAPI(api):
        return com_sdtk_puller_SourceCustomWebAPI(api)

    @staticmethod
    def fromDataTableReader(reader):
        return com_sdtk_puller_Source()


class com_sdtk_puller_SourceInputAPI(com_sdtk_puller_Source):

    def __init__(self,api):
        self._value = None
        self._key = None
        self._api = None
        super().__init__()
        self._api = api
        self._key = api.externalKey()
        self._value = api.externalValue()

    def pullAsMap(self,callback):
        _gthis = self
        def _hx_local_0(s,r):
            result = haxe_ds_StringMap()
            r.toHaxeMap(result,_gthis._key,_gthis._value)
            callback(result)
        self._api.retrieveData(None,_hx_local_0)

    def pullAsString(self,callback):
        def _hx_local_0(s,r):
            callback(s)
        self._api.retrieveData(None,_hx_local_0)


class com_sdtk_puller_SourceCustomWebAPI(com_sdtk_puller_Source):

    def __init__(self,api):
        self._api = None
        super().__init__()
        self._api = api

    def pullAsMap(self,callback):
        pass

    def pullAsString(self,callback):
        self._api.execute(callback)


class com_sdtk_std_Calc:

    @staticmethod
    def average(reader):
        total = 0
        count = 0
        readerI = reader.iterator()
        while readerI.hasNext():
            total = (total + readerI.next())
            count = (count + 1)
        return (total / count)

    @staticmethod
    def standardDeviation(reader,avg = None):
        if (avg is None):
            avg = com_sdtk_std_Calc.average(reader)
        total = 0
        count = 0
        reader2 = reader.iterator()
        while reader2.hasNext():
            value = reader2.next()
            total = (total + ((((value - avg)) * ((value - avg)))))
            count = (count + 1)
        v = (total / count)
        if (v < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(v)

    @staticmethod
    def correlation(readerI,readerJ,avgI = None,avgJ = None,sdI = None,sdJ = None):
        if (avgI is None):
            avgI = com_sdtk_std_Calc.average(readerI)
        if (avgJ is None):
            avgJ = com_sdtk_std_Calc.average(readerJ)
        if (sdI is None):
            sdI = com_sdtk_std_Calc.standardDeviation(readerI,avgI)
        if (sdJ is None):
            sdJ = com_sdtk_std_Calc.standardDeviation(readerJ,avgJ)
        count = 0
        total = 0
        readerI2 = readerI.iterator()
        readerJ2 = readerJ.iterator()
        while readerI2.hasNext():
            i = readerI2.next()
            j = readerJ2.next()
            total = (total + ((i * j)))
            count = (count + 1)
        return (((total - (((count * avgI) * avgJ)))) / (((((count - 1)) * sdI) * sdJ)))

    @staticmethod
    def regressionSlope(readerI,readerJ,avgI = None,avgJ = None,sdI = None,sdJ = None,correlationIJ = None):
        if ((avgI is None) and (((correlationIJ is None) or ((sdI is None))))):
            avgI = com_sdtk_std_Calc.average(readerI)
        if ((avgJ is None) and (((correlationIJ is None) or ((sdJ is None))))):
            avgJ = com_sdtk_std_Calc.average(readerJ)
        if (sdI is None):
            sdI = com_sdtk_std_Calc.standardDeviation(readerI,avgI)
        if (sdJ is None):
            sdJ = com_sdtk_std_Calc.standardDeviation(readerJ,avgJ)
        if (correlationIJ is None):
            correlationIJ = com_sdtk_std_Calc.correlation(readerI,readerJ,avgI,avgJ,sdI,sdJ)
        return ((correlationIJ * sdJ) / sdI)

    @staticmethod
    def regressionIntercept(readerI,readerJ,avgI = None,avgJ = None,sdI = None,sdJ = None,correlationIJ = None,slope = None):
        if (avgI is None):
            avgI = com_sdtk_std_Calc.average(readerI)
        if (avgJ is None):
            avgJ = com_sdtk_std_Calc.average(readerJ)
        if (slope is None):
            slope = com_sdtk_std_Calc.regressionSlope(readerI,readerJ,avgI,avgJ,sdI,sdJ,correlationIJ)
        return (avgJ - ((slope * avgI)))


class com_sdtk_std_StringReader(com_sdtk_std_Reader):

    def __init__(self,sValue):
        self._method = None
        self._dropping = -1
        self._index = 0
        self._value = None
        self._next = None
        super().__init__()
        self._value = sValue
        self._next = ""
        self._method = com_sdtk_std_StringReaderEachChar.instance()
        self.moveToNext()

    def flip(self):
        return com_sdtk_std_StringWriter(None)

    def reset(self):
        self._index = 0
        self._next = ""
        self.moveToNext()

    def rawIndex(self):
        return self._index

    def jumpTo(self,index):
        self._index = index

    def setString(self,sValue):
        self._value = sValue

    def moveToNext(self):
        try:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0._index
            _hx_local_0._index = (_hx_local_1 + len(self._next))
            _hx_local_0._index
            self._next = None
            if ((self._dropping > 0) and ((self._index >= self._dropping))):
                self._value = HxString.substr(self._value,self._index,None)
                self._index = 0
            self._next = self._method.moveToNext(self._index,self._value)
            if ((self._next is not None) and ((len(self._next) <= 0))):
                self._next = None
        except BaseException as _g:
            None
        if (self._next is None):
            self.dispose()

    def hasNext(self):
        return (self._next is not None)

    def next(self):
        sValue = self._next
        if (sValue is not None):
            self.moveToNext()
        return sValue

    def peek(self):
        return self._next

    def dispose(self):
        if (self._value is not None):
            self._value = None
            self._next = None
            self._index = -1

    def iterator(self):
        return self

    def switchToLineReader(self):
        self._method = com_sdtk_std_StringReaderEachLine.instance()
        return self

    def unwrapOne(self):
        self._method = com_sdtk_std_StringReaderEachChar.instance()
        return self

    def unwrapAll(self):
        self._method = com_sdtk_std_StringReaderEachChar.instance()
        return self

    def switchToDroppingCharacters(self,chars = None):
        if (chars is None):
            chars = 10000
        self._dropping = chars
        return self

    def toString(self):
        return self._value

    def convertToStringReader(self):
        return self


class com_sdtk_std_ControlReader(com_sdtk_std_StringReader):

    def __init__(self,sControl,bPlainText):
        self._id = None
        self._control = None
        super().__init__(com_sdtk_std_ControlReader.getValue(sControl,bPlainText))
        self._control = com_sdtk_std_ControlReader.getControl(sControl)
        self._id = sControl

    def dispose(self):
        super().dispose()
        self._control = None

    @staticmethod
    def getControl(sControl):
        return None

    @staticmethod
    def getValue(sControl,bPlainText):
        cControl = com_sdtk_std_ControlReader.getControl(sControl)
        sValue = None
        return sValue


class com_sdtk_std_ControlWriter(com_sdtk_std_Writer):

    def __init__(self,sControl):
        self._id = None
        self._control = None
        super().__init__()
        self._id = sControl

    def flip(self):
        return com_sdtk_std_ControlReader(self._id,False)

    def send(self,sLine):
        try:
            pass
        except BaseException as _g:
            None
            return

    def dispose(self):
        self._control = None


class com_sdtk_std_FileReader(com_sdtk_std_Reader):

    def __init__(self,sName):
        self._currentRawIndex = None
        self._nextRawIndex = None
        self._path = None
        self._in = None
        self._next = None
        super().__init__()
        self._path = sName
        self.reset()

    def flip(self):
        return com_sdtk_std_FileWriter(self._path,False)

    def reset(self):
        self.open()
        self._nextRawIndex = 0

    def open(self):
        self._in = open(self._path, "r")

    def rawIndex(self):
        return self._currentRawIndex

    def jumpTo(self,index):
        if (index < self._nextRawIndex):
            self.reset()
        self._in.seek((index - self._nextRawIndex))
        self._nextRawIndex = index
        self.check()

    def start(self):
        self.check()

    def check(self):
        if (self._in is not None):
            try:
                self._next = self._in.read(1)
            except BaseException as _g:
                None
                self._next = None
            if (self._next == ""):
                self._next = None
            if (self._next is None):
                self.dispose()
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0._nextRawIndex
            _hx_local_0._nextRawIndex = (_hx_local_1 + 1)
            _hx_local_1
        else:
            self._next = None

    def hasNext(self):
        return (self._next is not None)

    def next(self):
        _current = self._next
        self.check()
        return _current

    def peek(self):
        return self._next

    def close(self):
        self._in.close()

    def dispose(self):
        if (self._path is not None):
            self._path = None
            self.close()
            self._in = None

    def toString(self):
        s = ""
        if (self._next is not None):
            s = (("null" if s is None else s) + HxOverrides.stringOrNull(self._next))
        s = (("null" if s is None else s) + Std.string(self._in.read()))
        return s


class com_sdtk_std_FileWriter(com_sdtk_std_Writer):

    def __init__(self,sName,bAppend):
        self._path = None
        self._out = None
        super().__init__()
        self._path = sName
        if (not bAppend):
            self.open(False)

    def flip(self):
        return com_sdtk_std_FileReader(self._path)

    def open(self,bAppend):
        self._out = open(self._path, ("a" if bAppend else "w"))

    def close(self):
        self._out.close()
        self._out = None

    def writeI(self,_hx_str):
        try:
            self._out.write(_hx_str)
        except BaseException as _g:
            None

    def write(self,_hx_str):
        if (self._out is None):
            self.open(True)
            self.writeI(_hx_str)
            self.close()
        else:
            self.writeI(_hx_str)

    def dispose(self):
        if (self._path is not None):
            self._path = None
            if (self._out is not None):
                self.close()
                self._out = None

    def convertToStringWriter(self):
        sw = com_sdtk_std_StringWriter(None)
        sw.endWith(self)
        return sw


class com_sdtk_std_Filter:

    def __init__(self):
        pass

    def filter(self,sValue):
        return sValue

    def _hx_and(self,fFilter):
        cfAnd = com_sdtk_std_FilterCompositeAnd()
        cfAnd._hx_and(self)
        cfAnd._hx_and(fFilter)
        return cfAnd

    def _hx_or(self,fFilter):
        cfAnd = com_sdtk_std_FilterCompositeOr()
        cfAnd._hx_or(self)
        cfAnd._hx_or(fFilter)
        return cfAnd

    @staticmethod
    def list(sValue,bBlock):
        if bBlock:
            fFilter = None
            _g = 0
            while (_g < len(sValue)):
                s = (sValue[_g] if _g >= 0 and _g < len(sValue) else None)
                _g = (_g + 1)
                if (fFilter is None):
                    fFilter = com_sdtk_std_FilterBlockWithString(s)
                else:
                    fFilter = fFilter._hx_and(com_sdtk_std_FilterBlockWithString(s))
            return fFilter
        else:
            fFilter = None
            _g = 0
            while (_g < len(sValue)):
                s = (sValue[_g] if _g >= 0 and _g < len(sValue) else None)
                _g = (_g + 1)
                if (fFilter is None):
                    fFilter = com_sdtk_std_FilterAllowEqualString(s)
                else:
                    fFilter = fFilter._hx_or(com_sdtk_std_FilterAllowEqualString(s))
            return fFilter

    @staticmethod
    def parse(sValue,bBlock):
        if (sValue is None):
            return None
        elif bBlock:
            _g = ("" if ((0 >= len(sValue))) else sValue[0])
            if (_g == "#"):
                sValue = HxString.substring(sValue,1,None)
                startIndex = None
                if (((sValue.find("-") if ((startIndex is None)) else HxString.indexOfImpl(sValue,"-",startIndex))) > 0):
                    iRange = com_sdtk_std_Filter.parseRange(sValue)
                    return com_sdtk_std_FilterBlockCountingRange((iRange[0] if 0 < len(iRange) else None),(iRange[1] if 1 < len(iRange) else None))
                else:
                    startIndex = None
                    if (((sValue.find(",") if ((startIndex is None)) else HxString.indexOfImpl(sValue,",",startIndex))) > 0):
                        return com_sdtk_std_FilterBlockCountingList(com_sdtk_std_Filter.parseList(sValue))
                    else:
                        return com_sdtk_std_FilterBlockCountingSingle(Std.parseInt(StringTools.trim(sValue)))
            elif (_g == "/"):
                return com_sdtk_std_FilterBlockRegularExpression(sValue)
            elif (_g == "="):
                return com_sdtk_std_FilterBlockEqualString(HxString.substring(sValue,1,None))
            else:
                return com_sdtk_std_FilterBlockWithString(sValue)
        else:
            _g = ("" if ((0 >= len(sValue))) else sValue[0])
            if (_g == "#"):
                sValue = HxString.substring(sValue,1,None)
                startIndex = None
                if (((sValue.find("-") if ((startIndex is None)) else HxString.indexOfImpl(sValue,"-",startIndex))) > 0):
                    iRange = com_sdtk_std_Filter.parseRange(sValue)
                    return com_sdtk_std_FilterAllowCountingRange((iRange[0] if 0 < len(iRange) else None),(iRange[1] if 1 < len(iRange) else None))
                else:
                    startIndex = None
                    if (((sValue.find(",") if ((startIndex is None)) else HxString.indexOfImpl(sValue,",",startIndex))) > 0):
                        return com_sdtk_std_FilterAllowCountingList(com_sdtk_std_Filter.parseList(sValue))
                    else:
                        return com_sdtk_std_FilterAllowCountingSingle(Std.parseInt(StringTools.trim(sValue)))
            elif (_g == "/"):
                return com_sdtk_std_FilterAllowRegularExpression(sValue)
            elif (_g == "="):
                return com_sdtk_std_FilterAllowEqualString(HxString.substring(sValue,1,None))
            else:
                return com_sdtk_std_FilterAllowWithString(sValue)

    @staticmethod
    def parseList(sList):
        iList = list()
        _g = 0
        _g1 = sList.split(",")
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            x = Std.parseInt(StringTools.trim(s))
            iList.append(x)
        return iList

    @staticmethod
    def parseRange(sRange):
        iRange = list()
        _g = 0
        _g1 = sRange.split("-")
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            x = Std.parseInt(StringTools.trim(s))
            iRange.append(x)
        return iRange


class com_sdtk_std_FilterCounting(com_sdtk_std_Filter):

    def __init__(self):
        self._count = 0
        super().__init__()

    def filter(self,sValue):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._count
        _hx_local_0._count = (_hx_local_1 + 1)
        _hx_local_1
        return None

    def getCount(self):
        return self._count


class com_sdtk_std_FilterAllowCountingList(com_sdtk_std_FilterCounting):

    def __init__(self,iSearchFor):
        self._searchFor = None
        super().__init__()
        self._searchFor = iSearchFor

    def filter(self,sValue):
        super().filter(sValue)
        if ((self._searchFor is not None) and ((len(self._searchFor) > 0))):
            if (python_internal_ArrayImpl.indexOf(self._searchFor,self.getCount(),None) >= 0):
                return sValue
            else:
                return None
        else:
            return None


class com_sdtk_std_FilterAllowCountingRange(com_sdtk_std_FilterCounting):

    def __init__(self,iSearchForStart,iSearchForEnd):
        self._searchForEnd = None
        self._searchForStart = None
        super().__init__()
        self._searchForStart = iSearchForStart
        self._searchForEnd = iSearchForEnd

    def filter(self,sValue):
        super().filter(sValue)
        if ((self._searchForStart > 0) and ((self._searchForEnd > 0))):
            if ((self.getCount() >= self._searchForStart) and ((self.getCount() <= self._searchForEnd))):
                return sValue
            else:
                return None
        else:
            return None


class com_sdtk_std_FilterAllowCountingSingle(com_sdtk_std_FilterCounting):

    def __init__(self,iSearchFor):
        self._searchFor = None
        super().__init__()
        self._searchFor = iSearchFor

    def filter(self,sValue):
        super().filter(sValue)
        if (self._searchFor > 0):
            if (self.getCount() == self._searchFor):
                return sValue
            else:
                return None
        else:
            return None


class com_sdtk_std_FilterAllowEqualString(com_sdtk_std_Filter):

    def __init__(self,sSearchFor):
        self._searchFor = None
        super().__init__()
        self._searchFor = sSearchFor

    def filter(self,sValue):
        if (sValue is not None):
            if (sValue == self._searchFor):
                return sValue
            else:
                return None
        else:
            return None


class com_sdtk_std_FilterAllowRegularExpression(com_sdtk_std_Filter):

    def __init__(self,sSearchFor):
        self._searchFor = None
        super().__init__()
        sSearchFor = HxString.substr(sSearchFor,1,None)
        startIndex = None
        i = None
        if (startIndex is None):
            i = sSearchFor.rfind("/", 0, len(sSearchFor))
        else:
            i1 = sSearchFor.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i1 == -1)) else (i1 + 1))
            check = sSearchFor.find("/", startLeft, len(sSearchFor))
            i = (check if (((check > i1) and ((check <= startIndex)))) else i1)
        self._searchFor = EReg(HxString.substring(sSearchFor,0,i),HxString.substring(sSearchFor,(i + 1),None))

    def filter(self,sValue):
        if (sValue is not None):
            _this = self._searchFor
            _this.matchObj = python_lib_Re.search(_this.pattern,sValue)
            if (_this.matchObj is not None):
                return sValue
            else:
                return None
        else:
            return None


class com_sdtk_std_FilterAllowWithString(com_sdtk_std_Filter):

    def __init__(self,sSearchFor):
        self._searchFor = None
        super().__init__()
        self._searchFor = sSearchFor

    def filter(self,sValue):
        if (sValue is not None):
            _hx_str = self._searchFor
            startIndex = None
            if (((sValue.find(_hx_str) if ((startIndex is None)) else HxString.indexOfImpl(sValue,_hx_str,startIndex))) >= 0):
                return sValue
            else:
                return None
        else:
            return None


class com_sdtk_std_FilterBlockCountingList(com_sdtk_std_FilterCounting):

    def __init__(self,iSearchFor):
        self._searchFor = None
        super().__init__()
        self._searchFor = iSearchFor

    def filter(self,sValue):
        super().filter(sValue)
        if ((self._searchFor is not None) and ((len(self._searchFor) > 0))):
            if (python_internal_ArrayImpl.indexOf(self._searchFor,self.getCount(),None) >= 0):
                return None
            else:
                return sValue
        else:
            return None


class com_sdtk_std_FilterBlockCountingRange(com_sdtk_std_FilterCounting):

    def __init__(self,iSearchForStart,iSearchForEnd):
        self._searchForEnd = None
        self._searchForStart = None
        super().__init__()
        self._searchForStart = iSearchForStart
        self._searchForEnd = iSearchForEnd

    def filter(self,sValue):
        super().filter(sValue)
        if ((self._searchForStart > 0) and ((self._searchForEnd > 0))):
            if ((self.getCount() >= self._searchForStart) and ((self.getCount() <= self._searchForEnd))):
                return None
            else:
                return sValue
        else:
            return None


class com_sdtk_std_FilterBlockCountingSingle(com_sdtk_std_FilterCounting):

    def __init__(self,iSearchFor):
        self._searchFor = None
        super().__init__()
        self._searchFor = iSearchFor

    def filter(self,sValue):
        super().filter(sValue)
        if (self._searchFor > 0):
            if (self.getCount() == self._searchFor):
                return None
            else:
                return sValue
        else:
            return None


class com_sdtk_std_FilterBlockEqualString(com_sdtk_std_Filter):

    def __init__(self,sSearchFor):
        self._searchFor = None
        super().__init__()
        self._searchFor = sSearchFor

    def filter(self,sValue):
        if (sValue is not None):
            if (sValue == self._searchFor):
                return None
            else:
                return sValue
        else:
            return None


class com_sdtk_std_FilterBlockRegularExpression(com_sdtk_std_Filter):

    def __init__(self,sSearchFor):
        self._searchFor = None
        super().__init__()
        sSearchFor = HxString.substr(sSearchFor,1,None)
        startIndex = None
        i = None
        if (startIndex is None):
            i = sSearchFor.rfind("/", 0, len(sSearchFor))
        else:
            i1 = sSearchFor.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i1 == -1)) else (i1 + 1))
            check = sSearchFor.find("/", startLeft, len(sSearchFor))
            i = (check if (((check > i1) and ((check <= startIndex)))) else i1)
        self._searchFor = EReg(HxString.substring(sSearchFor,0,i),HxString.substring(sSearchFor,(i + 1),None))

    def filter(self,sValue):
        if (sValue is not None):
            _this = self._searchFor
            _this.matchObj = python_lib_Re.search(_this.pattern,sValue)
            if (_this.matchObj is not None):
                return None
            else:
                return sValue
        else:
            return None


class com_sdtk_std_FilterBlockWithString(com_sdtk_std_Filter):

    def __init__(self,sSearchFor):
        self._searchFor = None
        super().__init__()
        self._searchFor = sSearchFor

    def filter(self,sValue):
        if (sValue is not None):
            _hx_str = self._searchFor
            startIndex = None
            if (((sValue.find(_hx_str) if ((startIndex is None)) else HxString.indexOfImpl(sValue,_hx_str,startIndex))) >= 0):
                return None
            else:
                return sValue
        else:
            return None


class com_sdtk_std_FilterCompositeAnd(com_sdtk_std_Filter):

    def __init__(self):
        self._list = list()
        super().__init__()

    def filter(self,sValue):
        if (sValue is None):
            return None
        _g = 0
        _g1 = self._list
        while (_g < len(_g1)):
            fFilter = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            sValue = fFilter.filter(sValue)
            if (sValue is None):
                return None
        return sValue

    def _hx_and(self,fFilter):
        _this = self._list
        _this.append(fFilter)
        return self


class com_sdtk_std_FilterCompositeOr(com_sdtk_std_Filter):

    def __init__(self):
        self._list = list()
        super().__init__()

    def filter(self,sValue):
        if (sValue is None):
            return None
        _g = 0
        _g1 = self._list
        while (_g < len(_g1)):
            fFilter = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (fFilter.filter(sValue) is not None):
                return sValue
        return None

    def _hx_or(self,fFilter):
        _this = self._list
        _this.append(fFilter)
        return self


class com_sdtk_std_FilterReader(com_sdtk_std_Reader):

    def __init__(self,rReader):
        self._currentRawIndex = None
        self._current = None
        self._filter = None
        self._reader = None
        super().__init__()
        self._reader = rReader

    def rawIndex(self):
        return self._currentRawIndex

    def jumpTo(self,index):
        self._reader.jumpTo(index)
        self._current = None
        self.check()

    def addFilter(self,fFilter):
        if (self._filter is None):
            self._filter = list()
        _this = self._filter
        _this.append(fFilter)

    def check(self):
        if (self._current is None):
            if (self._filter is None):
                self._current = self._reader.next()
            else:
                while (self._current is None):
                    iNext = self._reader.rawIndex()
                    sNext = self._reader.next()
                    if (sNext is None):
                        break
                    _g = 0
                    _g1 = self._filter
                    while (_g < len(_g1)):
                        fFilter = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                        _g = (_g + 1)
                        sNext = fFilter.filter(sNext)
                    if (sNext is not None):
                        self._current = sNext
                        self._currentRawIndex = iNext

    def hasNext(self):
        self.check()
        return (self._current is not None)

    def next(self):
        self.check()
        sCurrent = self._current
        self._current = None
        return sCurrent

    def peek(self):
        self.check()
        return self._current

    def dispose(self):
        if (self._reader is not None):
            self._reader.dispose()
            self._reader = None
            self._current = None
            self._filter = None

    def switchToLineReader(self):
        self._reader = self._reader.switchToLineReader()
        return self

    def unwrapOne(self):
        return self._reader

    def unwrapAll(self):
        return self._reader.unwrapAll()

    def reset(self):
        self._reader.reset()
        self._current = None


class com_sdtk_std_FilterWriter(com_sdtk_std_Writer):

    def __init__(self,wWriter):
        self._filter = None
        self._writer = None
        super().__init__()
        self._writer = wWriter

    def addFilter(self,fFilter):
        if (self._filter is None):
            self._filter = list()
        _this = self._filter
        _this.append(fFilter)

    def write(self,_hx_str):
        if (self._filter is None):
            self._writer.write(_hx_str)
        else:
            sWrite = _hx_str
            _g = 0
            _g1 = self._filter
            while (_g < len(_g1)):
                fFilter = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                sWrite = fFilter.filter(sWrite)
            if (sWrite is not None):
                self._writer.write(sWrite)

    def switchToLineWriter(self):
        self._writer = self._writer.switchToLineWriter()
        return self

    def unwrapOne(self):
        return self._writer

    def unwrapAll(self):
        return self._writer.unwrapAll()

    def flush(self):
        self._writer.flush()

    def dispose(self):
        if (self._writer is not None):
            self._writer.dispose()
            self._writer = None
            self._filter = None


class com_sdtk_std_AbstractReader(com_sdtk_std_Reader):
    _hx_class_name = "com.sdtk.std.AbstractReader"
    __slots__ = ("_next", "_reader", "_mode", "_nextRawIndex", "_rawIndex")
    _hx_fields = ["_next", "_reader", "_mode", "_nextRawIndex", "_rawIndex"]
    _hx_methods = ["reset", "rawIndex", "jumpTo", "start", "moveToNext", "next", "peek", "dispose", "unwrapOne", "unwrapAll", "switchToLineReader", "hasNext"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_sdtk_std_Reader


    def __init__(self,iReader):
        self._rawIndex = None
        self._nextRawIndex = None
        self._reader = None
        self._mode = 0
        self._next = None
        super().__init__()
        self._reader = iReader
        self._next = ""

    def reset(self):
        self._nextRawIndex = 0

    def rawIndex(self):
        return self._rawIndex

    def jumpTo(self,index):
        if (index < self._nextRawIndex):
            self.reset()
        self._reader.readString((index - self._nextRawIndex))
        self._nextRawIndex = index

    def start(self):
        self.moveToNext()

    def moveToNext(self):
        try:
            _g = self._mode
            if (_g == 0):
                self._next = self._reader.readString(1)
            elif (_g == 1):
                self._next = self._reader.readLine()
            else:
                pass
        except BaseException as _g:
            None
            self.dispose()

    def next(self):
        sValue = self._next
        if (sValue is not None):
            self.moveToNext()
        return sValue

    def peek(self):
        return self._next

    def dispose(self):
        if (self._reader is not None):
            self._reader.close()
            self._reader = None
            self._next = None

    def unwrapOne(self):
        self._mode = 0
        return self

    def unwrapAll(self):
        self._mode = 0
        return self

    def switchToLineReader(self):
        self._mode = 1
        return self

    def hasNext(self):
        return (self._next is not None)

com_sdtk_std_AbstractReader._hx_class = com_sdtk_std_AbstractReader


class com_sdtk_std_AbstractWriter(com_sdtk_std_Writer):
    _hx_class_name = "com.sdtk.std.AbstractWriter"
    __slots__ = ("_writer",)
    _hx_fields = ["_writer"]
    _hx_methods = ["dispose", "flush", "write"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_sdtk_std_Writer


    def __init__(self,oWriter):
        self._writer = None
        super().__init__()
        self._writer = oWriter

    def dispose(self):
        if (self._writer is not None):
            self._writer.close()
            self._writer = None

    def flush(self):
        self._writer.flush()

    def write(self,_hx_str):
        self._writer.writeString(_hx_str)

com_sdtk_std_AbstractWriter._hx_class = com_sdtk_std_AbstractWriter


class com_sdtk_std_Normalize:

    @staticmethod
    def parseJson(data):
        import json
        jsonData = Std.string(data)
        tmp = None
        if ((("" if ((0 >= len(jsonData))) else jsonData[0])) == "`"):
            startIndex = None
            tmp = (((jsonData.find("```json\n") if ((startIndex is None)) else HxString.indexOfImpl(jsonData,"```json\n",startIndex))) == 0)
        else:
            tmp = False
        if tmp:
            jsonData = HxString.substr(jsonData,8,(len(jsonData) - 11))
        return json.loads(jsonData)

    @staticmethod
    def nativeToHaxe(mapping):
        if (((Std.isOfType(mapping,haxe_ds_StringMap) or Std.isOfType(mapping,haxe_ds_IntMap)) or Std.isOfType(mapping,haxe_ds_WeakMap)) or Std.isOfType(mapping,haxe_ds_ObjectMap)):
            return mapping
        elif Std.isOfType(mapping,dict):
            _hx_map = haxe_ds_StringMap()
            m2 = mapping
            field = python_HaxeIterator(iter(m2.keys()))
            while field.hasNext():
                field1 = field.next()
                value = Reflect.field(mapping,"get")(field1)
                _hx_map.h[field1] = value
            return _hx_map
        else:
            _hx_map = haxe_ds_StringMap()
            size = 0
            _g = 0
            _g1 = python_Boot.fields(mapping)
            while (_g < len(_g1)):
                field = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                value = Reflect.field(mapping,field)
                _hx_map.h[field] = value
                size = (size + 1)
            if (size == 1):
                k = _hx_map.keys().next()
                k1 = k
                if ((k1 == "h") or ((k1 == "d"))):
                    return com_sdtk_std_Normalize.nativeToHaxe(_hx_map.h.get(k,None))
                else:
                    pass
            return _hx_map

    @staticmethod
    def haxeMapValuesToStrings(mapping):
        _hx_map = haxe_ds_StringMap()
        field = mapping.keys()
        while field.hasNext():
            field1 = field.next()
            value = Std.string(mapping.h.get(field1,None))
            _hx_map.h[field1] = value
        return _hx_map

    @staticmethod
    def haxeToNative(mapping):
        _hx_map = dict()
        field = mapping.keys()
        while field.hasNext():
            field1 = field.next()
            _hx_map[field1] = mapping.h.get(field1,None)
        return _hx_map


class com_sdtk_std_ParametersReader(com_sdtk_std_Reader):

    def __init__(self,pParameters):
        self._parameters = None
        self._index = 0
        self._next = None
        super().__init__()
        if (pParameters is None):
            pParameters = com_sdtk_std_Parameters()
        self._parameters = pParameters
        self._next = ""
        self.moveToNext()

    def reset(self):
        self._index = 0
        self._next = ""

    def rawIndex(self):
        return self._index

    def jumpTo(self,index):
        self._index = index

    def moveToNext(self):
        try:
            self._next = None
            self._next = self._parameters.getParameter(self._index)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0._index
            _hx_local_0._index = (_hx_local_1 + 1)
            _hx_local_1
        except BaseException as _g:
            None
        if (self._next is None):
            self.dispose()

    def hasNext(self):
        return (self._next is not None)

    def next(self):
        sValue = self._next
        if (sValue is not None):
            self.moveToNext()
        return sValue

    def peek(self):
        return self._next

    def dispose(self):
        if (self._parameters is not None):
            self._parameters = None
            self._next = None
            self._index = -1

    def iterator(self):
        return self


class com_sdtk_std_PopUpWriter(com_sdtk_std_Writer):

    def __init__(self):
        super().__init__()

    def write(self,sLine):
        try:
            pass
        except BaseException as _g:
            None
            return


class com_sdtk_std_ReaderAsync:
    pass


class com_sdtk_std_ReaderAsyncAbstract:

    def __init__(self):
        self._handlers = list()

    def readTo(self,rhHandler):
        _this = self._handlers
        _this.append(rhHandler)
        return self

    def read(self,sValue):
        _g = 0
        _g1 = self._handlers
        while (_g < len(_g1)):
            rhHandler = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            rhHandler.read(sValue)

    def start(self):
        return self

    def dispose(self):
        self._handlers = None


class com_sdtk_std_ReaderHandler:
    pass


class com_sdtk_std_StdinReader(com_sdtk_std_FileReader):

    def __init__(self):
        super().__init__(None)

    def open(self):
        self._in = sys.stdin

    def close(self):
        pass

    def flip(self):
        return com_sdtk_std_StdoutWriter()


class com_sdtk_std_StdoutWriter(com_sdtk_std_FileWriter):

    def __init__(self):
        super().__init__(None,False)

    def open(self,bAppend):
        self._out = sys.stdout

    def close(self):
        self._out = self._out.flush()

    def flip(self):
        return com_sdtk_std_StdinReader()


class com_sdtk_std_StringReaderMethod:
    pass


class com_sdtk_std_StringReaderEachChar:

    def __init__(self):
        pass

    def moveToNext(self,index,value):
        return HxString.substr(value,index,1)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_std_StringReaderEachChar._instance is None):
            com_sdtk_std_StringReaderEachChar._instance = com_sdtk_std_StringReaderEachChar()
        return com_sdtk_std_StringReaderEachChar._instance


class com_sdtk_std_StringReaderEachLine:

    def __init__(self):
        pass

    def moveToNext(self,index,value):
        j = (value.find("\n") if ((index is None)) else HxString.indexOfImpl(value,"\n",index))
        if (j < 0):
            j = len(value)
        return HxString.substr(value,index,(j - index))
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_std_StringReaderEachLine._instance is None):
            com_sdtk_std_StringReaderEachLine._instance = com_sdtk_std_StringReaderEachLine()
        return com_sdtk_std_StringReaderEachLine._instance


class com_sdtk_std_StringWriter(com_sdtk_std_Writer):

    def __init__(self,reuse):
        self._dropping = -1
        self._end = None
        self._writer = None
        self._buffer = None
        super().__init__()
        if (reuse is None):
            self._buffer = StringBuf()
        else:
            self._buffer = reuse

    def flip(self):
        return com_sdtk_std_StringReader(self._buffer.b.getvalue())

    def endWith(self,writer):
        self._writer = writer

    def dispose(self):
        if (self._buffer is not None):
            self._end = self._buffer.b.getvalue()
        if (self._writer is not None):
            self._writer.write(self._end)
            self._writer.dispose()
            self._writer = None
        self._buffer = None

    def toString(self):
        if (self._buffer is not None):
            return self._buffer.b.getvalue()
        else:
            return self._end

    def write(self,_hx_str):
        _this = self._buffer
        s = Std.string(_hx_str)
        _this.b.write(s)
        if ((self._dropping > 0) and ((self._buffer.get_length() > self._dropping))):
            self._writer.write(self._buffer.b.getvalue())
            self._buffer = StringBuf()

    def switchToDroppingCharacters(self,chars = None):
        if (chars is None):
            chars = 10000
        self._dropping = chars
        return self


class com_sdtk_std_UsesCompletionHandler:
    pass


class com_sdtk_std_WriterAsync:
    pass


class com_sdtk_std_StringWriterAsync:

    def __init__(self):
        self._buffer = StringBuf()

    def done(self,iBytes,oAttachment):
        pass

    def write(self,sData,whHandler):
        _this = self._buffer
        s = Std.string(sData)
        _this.b.write(s)
        whHandler.done()
        return self

    def toString(self):
        return self._buffer.b.getvalue()

    def dispose(self):
        self._buffer = None


class com_sdtk_std_SysLogWriter(com_sdtk_std_Writer):

    def __init__(self):
        super().__init__()

    def write(self,sLine):
        try:
            sLineUpper = sLine.upper()
            iLevel = 0
            startIndex = None
            if (((sLineUpper.find("WARN") if ((startIndex is None)) else HxString.indexOfImpl(sLineUpper,"WARN",startIndex))) >= 0):
                iLevel = 1
            startIndex = None
            if (((sLineUpper.find("ERR") if ((startIndex is None)) else HxString.indexOfImpl(sLineUpper,"ERR",startIndex))) >= 0):
                iLevel = 2
        except BaseException as _g:
            None
            return

    def dispose(self):
        super().dispose()


class com_sdtk_std_Version:

    @staticmethod
    def get():
        return com_sdtk_std_Version._code


class com_sdtk_std_WholeLineReader(com_sdtk_std_Reader):

    def __init__(self,rReader):
        self._reader = None
        self._currentRawIndex = None
        self._current = None
        self._list = None
        self._buffer = StringBuf()
        self._empty = True
        super().__init__()
        self._reader = rReader

    def reset(self):
        self._reader.reset()

    def rawIndex(self):
        return self._currentRawIndex

    def jumpTo(self,index):
        self._current = None
        self._reader.jumpTo(index)
        self.check()

    def check(self):
        if (self._current is None):
            if ((self._list is not None) and ((len(self._list) > 0))):
                _this = self._list
                self._current = (None if ((len(_this) == 0)) else _this.pop(0))
            elif (self._empty and ((self._reader.hasNext() == False))):
                return
            else:
                try:
                    self._currentRawIndex = self._reader.rawIndex()
                    while True:
                        s = self._reader.next()
                        if ((s is None) and (not self._empty)):
                            s = "\n"
                        if (s is not None):
                            _this = self._buffer
                            s1 = Std.string(s)
                            _this.b.write(s1)
                            self._empty = False
                        tmp = None
                        if (s is not None):
                            startIndex = None
                            tmp = (((s.find("\n") if ((startIndex is None)) else HxString.indexOfImpl(s,"\n",startIndex))) >= 0)
                        else:
                            tmp = True
                        if tmp:
                            sLines = s.split("\n")
                            _this1 = self._buffer
                            s2 = Std.string((sLines[0] if 0 < len(sLines) else None))
                            _this1.b.write(s2)
                            self._current = self._buffer.b.getvalue()
                            self._buffer = StringBuf()
                            if ((len(sLines) <= 1) or ((len(python_internal_ArrayImpl._get(sLines, (len(sLines) - 1))) == 0))):
                                self._empty = True
                            else:
                                _this2 = self._buffer
                                s3 = Std.string(python_internal_ArrayImpl._get(sLines, (len(sLines) - 1)))
                                _this2.b.write(s3)
                                inlarr_0 = (len(sLines) - 1)
                                self._empty = False
                            i = 1
                            while (i < ((len(sLines) - 1))):
                                _this3 = self._list
                                x = i
                                i = (i + 1)
                                x1 = (sLines[x] if x >= 0 and x < len(sLines) else None)
                                _this3.append(x1)
                            break
                except BaseException as _g:
                    None
                    self._current = None

    def hasNext(self):
        self.check()
        return (self._current is not None)

    def next(self):
        self.check()
        sCurrent = self._current
        self._current = None
        return sCurrent

    def peek(self):
        self.check()
        return self._current

    def dispose(self):
        if (self._reader is not None):
            self._reader.dispose()
            self._reader = None
            self._buffer = None
            self._current = None
            self._list = None

    def switchToLineReader(self):
        return self

    def unwrapOne(self):
        return self._reader

    def unwrapAll(self):
        return self._reader.unwrapAll()


class com_sdtk_std_WholeLineWriter(com_sdtk_std_Writer):

    def __init__(self,wWriter):
        self._writer = None
        self._buffer = StringBuf()
        self._empty = True
        super().__init__()
        self._writer = wWriter

    def write(self,_hx_str):
        startIndex = None
        tmp = None
        if (startIndex is None):
            tmp = _hx_str.rfind("\n", 0, len(_hx_str))
        else:
            i = _hx_str.rfind("\n", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("\n"))) if ((i == -1)) else (i + 1))
            check = _hx_str.find("\n", startLeft, len(_hx_str))
            tmp = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (tmp < 0):
            _this = self._buffer
            s = Std.string(_hx_str)
            _this.b.write(s)
            self._empty = False
        else:
            sLines = _hx_str.split("\n")
            iLine = 1
            _g = 0
            while (_g < len(sLines)):
                sLine = (sLines[_g] if _g >= 0 and _g < len(sLines) else None)
                _g = (_g + 1)
                if (iLine == len(sLines)):
                    if (len(sLine) > 0):
                        _this = self._buffer
                        s = Std.string(sLine)
                        _this.b.write(s)
                elif self._empty:
                    self._writer.write(_hx_str)
                else:
                    _this1 = self._buffer
                    s1 = Std.string(sLine)
                    _this1.b.write(s1)
                    self._writer.write(self._buffer.b.getvalue())
                    self._buffer = StringBuf()
                    self._empty = True
                iLine = (iLine + 1)

    def switchToLineWriter(self):
        return self

    def unwrapOne(self):
        return self._writer

    def unwrapAll(self):
        return self._writer.unwrapAll()

    def flush(self):
        self._writer.flush()

    def dispose(self):
        if (self._writer is not None):
            self._writer.dispose()
            self._writer = None
            self._buffer = None


class com_sdtk_std_WriterHandler:
    pass


class com_sdtk_std_WriterWithDispose(com_sdtk_std_Writer):

    def __init__(self,writer,onDispose):
        self._onDispose = None
        self._writer = None
        super().__init__()
        self._writer = writer
        self._onDispose = onDispose

    def start(self):
        self._writer.start()

    def endWith(self,writer):
        self._writer = writer

    def dispose(self):
        self._writer.dispose()
        self._onDispose()

    def flush(self):
        self._writer.flush()

    def write(self,_hx_str):
        self._writer.write(_hx_str)

    def switchToLineWriter(self):
        return com_sdtk_std_WriterWithDispose(self._writer.switchToLineWriter(),self._onDispose)

    def unwrapOne(self):
        return self._writer

    def unwrapAll(self):
        return self._writer.unwrapAll()


class com_sdtk_table_AbstractTableReader:

    def __init__(self,tdInfo,oElement):
        self._next = None
        self._info = tdInfo
        self._element = oElement
        self._accessor = None
        self.findNext()

    def elementCheck(self,oElement):
        return False

    def getValue(self,oElement):
        return None

    def findNext(self):
        pass

    def hasNext(self):
        return (self._next is not None)

    def peek(self):
        if (self._next is None):
            return None
        else:
            return self.getValue(self._next)

    def next(self):
        self._accessor = self._next
        self.findNext()
        if (self._accessor is None):
            return None
        else:
            return self.getValue(self._accessor)


class com_sdtk_table_DataTableRowWriter:

    def __init__(self):
        pass

    def write(self,data,name,index):
        pass

    def start(self):
        pass

    def dispose(self):
        pass


class com_sdtk_table_AbstractTableRowWriter(com_sdtk_table_DataTableRowWriter):

    def __init__(self,tdInfo,writer,sHeader):
        self._writer = None
        self._info = None
        self._header = None
        super().__init__()
        self.reuse(tdInfo,writer,sHeader)

    def reuse(self,tdInfo,writer,sHeader):
        self._info = tdInfo
        self._writer = writer
        self._header = sHeader

    def dispose(self):
        self._header = None
        self._info = None
        self._writer = None


class com_sdtk_table_ArrayInfo:

    def __init__(self,arr,start,end,entriesInRow,increment,rowIncrement):
        self._arr = arr
        self._start = start
        self._end = end
        self._entriesInRow = entriesInRow
        self._increment = increment
        self._rowIncrement = rowIncrement


class com_sdtk_table_Array2DInfo(com_sdtk_table_ArrayInfo):

    def __init__(self,arr,start,end,entriesInRow,increment,rowIncrement):
        super().__init__(arr,start,end,entriesInRow,increment,rowIncrement)


class com_sdtk_table_DataEntryReader:

    def __init__(self):
        self._nameIsIndex = None
        self._autoNamed = None
        self._value = None
        self._name = None
        self._started = False
        self._rawIndex = -1
        self._index = -1

    def incrementTo(self,name,value,rawIndex):
        self._rawIndex = rawIndex
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._index
        _hx_local_0._index = (_hx_local_1 + 1)
        _hx_local_1
        indexAsString = Std.string(self._index)
        self._value = value
        if (name is None):
            self._name = indexAsString
            self._autoNamed = True
            self._nameIsIndex = True
        else:
            self._name = name
            self._autoNamed = False
            self._nameIsIndex = (indexAsString == name)

    def hasNext(self):
        return False

    def next(self):
        return None

    def iterator(self):
        return self

    def name(self):
        return self._name

    def index(self):
        return self._index

    def rawIndex(self):
        return self._rawIndex

    def value(self):
        return self._value

    def isAutoNamed(self):
        return self._autoNamed

    def isNameIndex(self):
        return self._nameIsIndex

    def start(self):
        if (not self._started):
            self._started = True
            self.startI()

    def startI(self):
        pass

    def dispose(self):
        pass


class com_sdtk_table_DataTableReader(com_sdtk_table_DataEntryReader):

    def __init__(self):
        self._iteratorData = None
        self._alwaysString = False
        self.HEADER_ROW_INDEX = -1
        self.HEADER_ROW_NAME = None
        self.ROW_NAME_INDEX = -1
        self.ROW_NAME = "__name__"
        super().__init__()

    def writeRowNameHeader(self,writers,rowWriters,sName):
        bWritingRowNames = False
        if ((sName is not None) and ((len(sName) > 0))):
            i = 0
            writer = HxOverrides.iterator(writers)
            while writer.hasNext():
                writer1 = writer.next()
                if writer1.writeRowNameFirst():
                    (rowWriters[i] if i >= 0 and i < len(rowWriters) else None).write(self.ROW_NAME,self.ROW_NAME,self.ROW_NAME_INDEX)
                    bWritingRowNames = True
                i = (i + 1)
        return bWritingRowNames

    def writeRowName(self,writers,rowWriters,sName,bWritingRowNames):
        if bWritingRowNames:
            bWritingRowNames = False
            if ((sName is not None) and ((len(sName) > 0))):
                i = 0
                writer = HxOverrides.iterator(writers)
                while writer.hasNext():
                    writer1 = writer.next()
                    if writer1.writeRowNameFirst():
                        (rowWriters[i] if i >= 0 and i < len(rowWriters) else None).write(sName,self.ROW_NAME,self.ROW_NAME_INDEX)
                        bWritingRowNames = True
                    i = (i + 1)
        return bWritingRowNames

    def nextReuse(self,reader):
        return None

    def writeFirstRow(self,writers,rowWriters):
        bBufferFirstRow = False
        rowReader = self.next()
        rowReader.alwaysString(self._alwaysString)
        bWritingRowNames = ((not self.isAutoNamed()) and (not self.isNameIndex()))
        sName = self.name()
        iIndex = self.index()
        if self.headerRowNotIncluded():
            writer = HxOverrides.iterator(writers)
            while writer.hasNext():
                writer1 = writer.next()
                bBufferFirstRow = (bBufferFirstRow or writer1.writeHeaderFirst())
        if (not bBufferFirstRow):
            if (not self.headerRowNotIncluded()):
                i = 0
                iNulls = 0
                writer = HxOverrides.iterator(writers)
                while writer.hasNext():
                    writer1 = writer.next()
                    if (not writer1.writeHeaderFirst()):
                        tmp = i
                        i = (i + 1)
                        python_internal_ArrayImpl._set(rowWriters, tmp, com_sdtk_table_NullRowWriter.instance())
                        iNulls = (iNulls + 1)
                    else:
                        tmp1 = i
                        i = (i + 1)
                        python_internal_ArrayImpl._set(rowWriters, tmp1, writer1.writeStart(sName,iIndex))
                if (iNulls == i):
                    rowReader.convertTo(com_sdtk_table_NullRowWriter.instance())
                else:
                    bWritingRowNames = self.writeRowName(writers,rowWriters,sName,bWritingRowNames)
                    rowReader.convertToAll(rowWriters)
                i = 0
                _g = 0
                while (_g < len(rowWriters)):
                    rowWriter = (rowWriters[_g] if _g >= 0 and _g < len(rowWriters) else None)
                    _g = (_g + 1)
                    if (rowWriter is not None):
                        if (rowWriter == com_sdtk_table_NullRowWriter.instance()):
                            python_internal_ArrayImpl._set(rowWriters, i, None)
                        else:
                            rowWriter.dispose()
                    i = (i + 1)
            else:
                i = 0
                writer = HxOverrides.iterator(writers)
                while writer.hasNext():
                    writer1 = writer.next()
                    tmp = i
                    i = (i + 1)
                    python_internal_ArrayImpl._set(rowWriters, tmp, writer1.writeStart(sName,iIndex))
                bWritingRowNames = self.writeRowName(writers,rowWriters,sName,bWritingRowNames)
                rowReader.convertToAll(rowWriters)
                _g = 0
                while (_g < len(rowWriters)):
                    rowWriter = (rowWriters[_g] if _g >= 0 and _g < len(rowWriters) else None)
                    _g = (_g + 1)
                    if (rowWriter is not None):
                        rowWriter.dispose()
        else:
            i = 0
            aData = list()
            aName = list()
            aIndex = list()
            writer = HxOverrides.iterator(writers)
            while writer.hasNext():
                writer1 = writer.next()
                if writer1.writeHeaderFirst():
                    tmp = i
                    i = (i + 1)
                    python_internal_ArrayImpl._set(rowWriters, tmp, writer1.writeStart(self.HEADER_ROW_NAME,self.HEADER_ROW_INDEX))
                else:
                    tmp1 = i
                    i = (i + 1)
                    python_internal_ArrayImpl._set(rowWriters, tmp1, None)
            rowReader.start()
            _g = 0
            while (_g < len(rowWriters)):
                rowWriter = (rowWriters[_g] if _g >= 0 and _g < len(rowWriters) else None)
                _g = (_g + 1)
                if (rowWriter is not None):
                    rowWriter.start()
            if bWritingRowNames:
                bWritingRowNames = self.writeRowNameHeader(writers,rowWriters,sName)
            while rowReader.hasNext():
                try:
                    data = rowReader.next()
                    sName1 = rowReader.name()
                    iIndex1 = rowReader.index()
                    _g = 0
                    while (_g < len(rowWriters)):
                        rowWriter = (rowWriters[_g] if _g >= 0 and _g < len(rowWriters) else None)
                        _g = (_g + 1)
                        if (rowWriter is not None):
                            rowWriter.write(sName1,sName1,iIndex1)
                    aData.append(data)
                    aName.append(sName1)
                    aIndex.append(iIndex1)
                except BaseException as _g1:
                    None
                    break
            rowReader.dispose()
            _g = 0
            while (_g < len(rowWriters)):
                rowWriter = (rowWriters[_g] if _g >= 0 and _g < len(rowWriters) else None)
                _g = (_g + 1)
                if (rowWriter is not None):
                    rowWriter.dispose()
            i = 0
            writer = HxOverrides.iterator(writers)
            while writer.hasNext():
                writer1 = writer.next()
                tmp = i
                i = (i + 1)
                python_internal_ArrayImpl._set(rowWriters, tmp, writer1.writeStart(sName,iIndex))
            _g = 0
            while (_g < len(rowWriters)):
                rowWriter = (rowWriters[_g] if _g >= 0 and _g < len(rowWriters) else None)
                _g = (_g + 1)
                rowWriter.start()
            bWritingRowNames = self.writeRowName(writers,rowWriters,sName,bWritingRowNames)
            i = 0
            _g = 0
            while (_g < len(aData)):
                o = (aData[_g] if _g >= 0 and _g < len(aData) else None)
                _g = (_g + 1)
                _g1 = 0
                while (_g1 < len(rowWriters)):
                    rowWriter = (rowWriters[_g1] if _g1 >= 0 and _g1 < len(rowWriters) else None)
                    _g1 = (_g1 + 1)
                    rowWriter.write(o,(aName[i] if i >= 0 and i < len(aName) else None),(aIndex[i] if i >= 0 and i < len(aIndex) else None))
                i = (i + 1)
            _g = 0
            while (_g < len(rowWriters)):
                rowWriter = (rowWriters[_g] if _g >= 0 and _g < len(rowWriters) else None)
                _g = (_g + 1)
                rowWriter.dispose()
        return bWritingRowNames

    def convertTo(self,writer):
        aSingle = list()
        aSingle.append(writer)
        self.convertToAll(aSingle)

    def toHaxeMap(self,_hx_map,keyField,valueField):
        self.convertTo(com_sdtk_table_MapWriter.writeToExpandableMap(_hx_map,keyField,valueField))
        return _hx_map

    def toNativeMap(self,_hx_map,keyField,valueField):
        if (_hx_map is not None):
            _hx_map = com_sdtk_std_Normalize.nativeToHaxe(_hx_map)
        return com_sdtk_std_Normalize.haxeToNative(self.toHaxeMap(_hx_map,keyField,valueField))

    def toObject(self,_hx_map,keyField,valueField):
        self.convertTo(com_sdtk_table_ObjectWriter.writeToWholeObject(_hx_map,keyField,valueField))
        return _hx_map

    def toArrayOfHaxeMaps(self,arr):
        if (arr is None):
            arr = list()
        self.convertTo(com_sdtk_table_ArrayOfMapsWriter.writeToExpandableArray(arr))
        return arr

    def toArrayOfNativeMaps(self,arr):
        if (arr is not None):
            i = 0
            while (i < len(arr)):
                python_internal_ArrayImpl._set(arr, i, com_sdtk_std_Normalize.nativeToHaxe((arr[i] if i >= 0 and i < len(arr) else None)))
                i = (i + 1)
        arr = self.toArrayOfHaxeMaps(arr)
        i = 0
        while (i < len(arr)):
            python_internal_ArrayImpl._set(arr, i, com_sdtk_std_Normalize.haxeToNative((arr[i] if i >= 0 and i < len(arr) else None)))
            i = (i + 1)
        return arr

    def toArrayOfArrays(self,arr):
        if (arr is None):
            arr = list()
        self.convertTo(com_sdtk_table_Array2DWriter.writeToExpandableArray(arr))
        return arr

    def toArrayOfObjects(self,arr,constructor):
        if (arr is None):
            arr = list()
        self.convertTo(com_sdtk_table_ArrayOfObjectsWriter.writeToExpandableArray(arr,constructor))
        return arr

    def toHTMLTable(self):
        sw = com_sdtk_std_StringWriter(None)
        writer = com_sdtk_table_TableWriter.createStandardTableWriterForWriter(sw)
        self.convertTo(writer)
        return sw.toString()

    def to(self,o):
        return None

    def filterColumnsOnly(self,arr):
        return com_sdtk_table_ColumnFilterDataTableReader(self,com_sdtk_std_Filter.list(arr,False))

    def filterColumnsExclude(self,arr):
        return com_sdtk_table_ColumnFilterDataTableReader(self,com_sdtk_std_Filter.list(arr,True))

    def convertToAll(self,writers):
        bWritingRowNames = True
        bFirst = True
        bCanWrite = True
        self.start()
        writer = HxOverrides.iterator(writers)
        while writer.hasNext():
            writer1 = writer.next()
            writer1.start()
        try:
            rowReader = None
            rowWriters = []
            writer = HxOverrides.iterator(writers)
            while writer.hasNext():
                writer1 = writer.next()
                rowWriters.append(None)
            while (self.hasNext() and bCanWrite):
                if bFirst:
                    bWritingRowNames = self.writeFirstRow(writers,rowWriters)
                    bFirst = False
                else:
                    rowReader = self.nextReuse(rowReader)
                    if (rowReader is None):
                        break
                    rowReader.alwaysString(self._alwaysString)
                    rowReader.start()
                    try:
                        i = 0
                        sName = self.name()
                        iIndex = self.index()
                        writer = HxOverrides.iterator(writers)
                        while writer.hasNext():
                            writer1 = writer.next()
                            python_internal_ArrayImpl._set(rowWriters, i, writer1.writeStartReuse(sName,iIndex,(rowWriters[i] if i >= 0 and i < len(rowWriters) else None)))
                            i = (i + 1)
                        bWritingRowNames = self.writeRowName(writers,rowWriters,sName,bWritingRowNames)
                        rowReader.convertToAll(rowWriters)
                    except BaseException as _g:
                        None
                bCanWrite = False
                writer2 = HxOverrides.iterator(writers)
                while writer2.hasNext():
                    writer3 = writer2.next()
                    bCanWrite = (bCanWrite or writer3.canWrite())
            _g = 0
            while (_g < len(rowWriters)):
                rowWriter = (rowWriters[_g] if _g >= 0 and _g < len(rowWriters) else None)
                _g = (_g + 1)
                if (rowWriter is not None):
                    rowWriter.dispose()
            if (rowReader is not None):
                rowReader.dispose()
        except BaseException as _g:
            None
        self.dispose()
        writer = HxOverrides.iterator(writers)
        while writer.hasNext():
            writer1 = writer.next()
            writer1.dispose()

    def headerRowNotIncluded(self):
        return True

    def oneRowPerFile(self):
        return False

    def alwaysString(self,value = None):
        if (value is None):
            return self._alwaysString
        else:
            self._alwaysString = value
            return self._alwaysString

    def reset(self):
        pass

    def moveTo(self,row):
        if (row < self._index):
            self.reset()
        while (self._index < row):
            pass

    def noHeaderIncluded(self,noHeader):
        pass

    def allowNoHeaderInclude(self):
        return False

    def indexer(self):
        _gthis = self
        if (self._iteratorData is None):
            self._iteratorData = com_sdtk_table_DataTableReaderSharedIterator(self)
        def _hx_local_1():
            def _hx_local_0():
                return _gthis._iteratorData._row
            return com_sdtk_table_DataTableReaderIterable(self._iteratorData,_hx_local_0)
        return _hx_local_1()

    def readColumnIndex(self,i):
        _gthis = self
        if (self._iteratorData is None):
            self._iteratorData = com_sdtk_table_DataTableReaderSharedIterator(self)
        def _hx_local_1():
            def _hx_local_0():
                return python_internal_ArrayImpl._get(_gthis._iteratorData._dataByIndex, i)
            return com_sdtk_table_DataTableReaderIterable(self._iteratorData,_hx_local_0)
        return _hx_local_1()

    def readColumnName(self,s):
        _gthis = self
        if (self._iteratorData is None):
            self._iteratorData = com_sdtk_table_DataTableReaderSharedIterator(self)
        def _hx_local_1():
            def _hx_local_0():
                return _gthis._iteratorData._dataByName.h.get(s,None)
            return com_sdtk_table_DataTableReaderIterable(self._iteratorData,_hx_local_0)
        return _hx_local_1()

    def getColumns(self):
        return None

    def flip(self):
        return None


class com_sdtk_table_Array2DReader(com_sdtk_table_DataTableReader):

    def __init__(self,info):
        self._info = None
        self._i = None
        super().__init__()
        self._info = info
        self._i = info._start

    def hasNext(self):
        return (self._i <= (((len(self._info._arr) - 1) if ((self._info._end < 0)) else self._info._end)))

    def nextReuse(self,rowReader):
        if (rowReader is None):
            rowReader = com_sdtk_table_ArrayRowReader.readWholeArray(python_internal_ArrayImpl._get(self._info._arr, self._i))
        else:
            rr = rowReader
            com_sdtk_table_ArrayRowReader.readWholeArrayReuse(python_internal_ArrayImpl._get(self._info._arr, self._i),rr)
        self.incrementTo(None,rowReader,self._i)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._i
        _hx_local_0._i = (_hx_local_1 + self._info._rowIncrement)
        _hx_local_0._i
        return rowReader

    def next(self):
        return self.nextReuse(None)

    def iterator(self):
        return com_sdtk_table_Array2DReader(self._info)

    def flip(self):
        return com_sdtk_table_Array2DWriter.reuse(self._info)

    def headerRowNotIncluded(self):
        return False

    def reset(self):
        self._i = self._info._start

    @staticmethod
    def readWholeArray(arr):
        return com_sdtk_table_Array2DReader(com_sdtk_table_Array2DInfo(arr,0,(len(arr) - 1),(len(arr) - 1),1,1))

    @staticmethod
    def readWholeArrayI(arr):
        return com_sdtk_table_Array2DReader(com_sdtk_table_Array2DInfo(arr,0,(len(arr) - 1),(len(arr) - 1),1,1))

    @staticmethod
    def reuse(info):
        return com_sdtk_table_Array2DReader(info)


class com_sdtk_table_DataTableWriter:

    def __init__(self):
        self._written = 0

    def start(self):
        pass

    def writeStart(self,name,index):
        return self.writeStartReuse(name,index,None)

    def writeStartReuse(self,name,index,rowWriter):
        if (not self.canWrite()):
            return None
        else:
            dtrwWriter = self.writeStartI(name,index,rowWriter)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0._written
            _hx_local_0._written = (_hx_local_1 + 1)
            _hx_local_1
            return dtrwWriter

    def writeStartI(self,name,index,rowWriter):
        return None

    def writeHeaderFirst(self):
        return False

    def writeRowNameFirst(self):
        return False

    def oneRowPerFile(self):
        return False

    def canWrite(self):
        if (self._written > 0):
            return (not self.oneRowPerFile())
        else:
            return True

    def flip(self):
        return None

    def dispose(self):
        pass


class com_sdtk_table_Array2DWriter(com_sdtk_table_DataTableWriter):

    def __init__(self,info):
        self._info = None
        self._i = None
        super().__init__()
        self._info = info
        self._i = info._start

    def start(self):
        pass

    def writeStartI(self,name,index,rowWriter):
        arr = self._info._arr
        if ((self._info._end >= 0) and (((index + self._info._start) > self._info._end))):
            return None
        while (len(arr) <= self._i):
            x = list()
            arr.append(x)
        rowWriter1 = com_sdtk_table_ArrayRowWriter.writeToExpandableArrayReuse(python_internal_ArrayImpl._get(arr, self._i),rowWriter)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._i
        _hx_local_0._i = (_hx_local_1 + self._info._rowIncrement)
        _hx_local_0._i
        return rowWriter1

    def flip(self):
        return com_sdtk_table_Array2DReader.reuse(self._info)

    def getArray(self):
        return self._info._arr

    def dispose(self):
        if (self._info is not None):
            self._info = None

    def writeHeaderFirst(self):
        return False

    def writeRowNameFirst(self):
        return True

    @staticmethod
    def writeToWholeArray(arr):
        return com_sdtk_table_Array2DWriter(com_sdtk_table_Array2DInfo(arr,0,(len(arr) - 1),(len(arr) - 1),1,1))

    @staticmethod
    def writeToExpandableArrayI(arr):
        if (arr is None):
            arr = list()
        return com_sdtk_table_Array2DWriter(com_sdtk_table_Array2DInfo(arr,0,-1,-1,1,1))

    @staticmethod
    def writeToExpandableArray(arr):
        if (arr is None):
            arr = list()
        return com_sdtk_table_Array2DWriter(com_sdtk_table_Array2DInfo(arr,0,-1,-1,1,1))

    @staticmethod
    def reuse(info):
        return com_sdtk_table_Array2DWriter(info)


class com_sdtk_table_ArrayOfMapsInfo(com_sdtk_table_ArrayInfo):

    def __init__(self,arr,start,end,entriesInRow,increment,rowIncrement):
        super().__init__(arr,start,end,entriesInRow,increment,rowIncrement)


class com_sdtk_table_ArrayOfMapsReader(com_sdtk_table_DataTableReader):

    def __init__(self,info):
        self._info = None
        self._i = None
        super().__init__()
        self._info = info
        self._i = info._start

    def hasNext(self):
        return (self._i <= (((len(self._info._arr) - 1) if ((self._info._end < 0)) else self._info._end)))

    def nextReuse(self,rowReader):
        if (rowReader is None):
            rowReader = com_sdtk_table_MapRowReader.readWholeMap(python_internal_ArrayImpl._get(self._info._arr, self._i))
        else:
            rr = rowReader
            rr.reuse(python_internal_ArrayImpl._get(self._info._arr, self._i),None,None)
        self.incrementTo(None,rowReader,self._i)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._i
        _hx_local_0._i = (_hx_local_1 + self._info._rowIncrement)
        _hx_local_0._i
        return rowReader

    def next(self):
        return self.nextReuse(None)

    def iterator(self):
        return com_sdtk_table_ArrayOfMapsReader(self._info)

    def flip(self):
        return com_sdtk_table_ArrayOfMapsWriter.reuse(self._info)

    def headerRowNotIncluded(self):
        return True

    def reset(self):
        self._i = self._info._start

    def toArrayOfHaxeMaps(self,arr):
        return self._info._arr[self._info._start:((len(self._info._arr) - 1) if ((self._info._end < 0)) else self._info._end)]

    @staticmethod
    def readWholeArray(arr):
        return com_sdtk_table_ArrayOfMapsReader(com_sdtk_table_ArrayOfMapsInfo(arr,0,(len(arr) - 1),(len(arr) - 1),1,1))

    @staticmethod
    def readWholeArrayI(arr):
        return com_sdtk_table_ArrayOfMapsReader(com_sdtk_table_ArrayOfMapsInfo(arr,0,(len(arr) - 1),(len(arr) - 1),1,1))

    @staticmethod
    def reuse(info):
        return com_sdtk_table_ArrayOfMapsReader(info)


class com_sdtk_table_ArrayOfMapsWriter(com_sdtk_table_DataTableWriter):

    def __init__(self,info):
        self._info = None
        self._i = None
        super().__init__()
        self._info = info
        self._i = info._start

    def start(self):
        pass

    def writeStartI(self,name,index,rowWriter):
        arr = self._info._arr
        if ((self._info._end >= 0) and (((index + self._info._start) > self._info._end))):
            return None
        while (len(arr) <= self._i):
            x = haxe_ds_StringMap()
            arr.append(x)
        rowWriter1 = com_sdtk_table_MapRowWriter.continueWriteReuse(python_internal_ArrayImpl._get(arr, self._i),True,None,None,rowWriter)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._i
        _hx_local_0._i = (_hx_local_1 + self._info._rowIncrement)
        _hx_local_0._i
        return rowWriter1

    def flip(self):
        return com_sdtk_table_ArrayOfMapsReader.reuse(self._info)

    def getArray(self):
        return self._info._arr

    def dispose(self):
        if (self._info is not None):
            self._info = None

    def writeHeaderFirst(self):
        return False

    def writeRowNameFirst(self):
        return True

    @staticmethod
    def writeToWholeArray(arr):
        return com_sdtk_table_ArrayOfMapsWriter(com_sdtk_table_ArrayOfMapsInfo(arr,0,(len(arr) - 1),(len(arr) - 1),1,1))

    @staticmethod
    def writeToExpandableArrayI(arr):
        if (arr is None):
            arr = list()
        return com_sdtk_table_ArrayOfMapsWriter(com_sdtk_table_ArrayOfMapsInfo(arr,0,-1,-1,1,1))

    @staticmethod
    def writeToExpandableArray(arr):
        if (arr is None):
            arr = list()
        return com_sdtk_table_ArrayOfMapsWriter(com_sdtk_table_ArrayOfMapsInfo(arr,0,-1,-1,1,1))

    @staticmethod
    def reuse(info):
        return com_sdtk_table_ArrayOfMapsWriter(info)


class com_sdtk_table_ArrayOfObjectsInfo(com_sdtk_table_ArrayInfo):

    def __init__(self,arr,start,end,entriesInRow,increment,rowIncrement,constructor):
        self._constructor = None
        super().__init__(arr,start,end,entriesInRow,increment,rowIncrement)
        self._constructor = constructor


class com_sdtk_table_ArrayOfObjectsReader(com_sdtk_table_DataTableReader):

    def __init__(self,info):
        self._info = None
        self._i = None
        super().__init__()
        self._info = info
        self._i = info._start

    def hasNext(self):
        return (self._i <= (((len(self._info._arr) - 1) if ((self._info._end < 0)) else self._info._end)))

    def nextReuse(self,rowReader):
        if (rowReader is None):
            rowReader = com_sdtk_table_ObjectRowReader.readWholeObject(python_internal_ArrayImpl._get(self._info._arr, self._i))
        else:
            rr = rowReader
            rr.reuse(python_internal_ArrayImpl._get(self._info._arr, self._i),None)
        self.incrementTo(None,rowReader,self._i)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._i
        _hx_local_0._i = (_hx_local_1 + self._info._rowIncrement)
        _hx_local_0._i
        return rowReader

    def next(self):
        return self.nextReuse(None)

    def iterator(self):
        return com_sdtk_table_ArrayOfObjectsReader(self._info)

    def flip(self):
        return com_sdtk_table_ArrayOfObjectsWriter.reuse(self._info)

    def headerRowNotIncluded(self):
        return True

    def reset(self):
        self._i = self._info._start

    @staticmethod
    def readWholeArray(arr):
        return com_sdtk_table_ArrayOfObjectsReader(com_sdtk_table_ArrayOfObjectsInfo(arr,0,(len(arr) - 1),(len(arr) - 1),1,1,None))

    @staticmethod
    def readWholeArrayI(arr):
        return com_sdtk_table_ArrayOfObjectsReader(com_sdtk_table_ArrayOfObjectsInfo(arr,0,(len(arr) - 1),(len(arr) - 1),1,1,None))

    @staticmethod
    def reuse(info):
        return com_sdtk_table_ArrayOfObjectsReader(info)


class com_sdtk_table_ArrayOfObjectsWriter(com_sdtk_table_DataTableWriter):

    def __init__(self,info):
        self._info = None
        self._i = None
        super().__init__()
        self._info = info
        self._i = info._start

    def start(self):
        pass

    def writeStartI(self,name,index,rowWriter):
        arr = self._info._arr
        if ((self._info._end >= 0) and (((index + self._info._start) > self._info._end))):
            return None
        while (len(arr) <= self._i):
            x = self._info._constructor()
            arr.append(x)
        rowWriter1 = com_sdtk_table_ObjectRowWriter.continueWriteReuse(python_internal_ArrayImpl._get(arr, self._i),None,None,rowWriter)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._i
        _hx_local_0._i = (_hx_local_1 + self._info._rowIncrement)
        _hx_local_0._i
        return rowWriter1

    def flip(self):
        return com_sdtk_table_ArrayOfObjectsReader.reuse(self._info)

    def getArray(self):
        return self._info._arr

    def dispose(self):
        if (self._info is not None):
            self._info = None

    def writeHeaderFirst(self):
        return False

    def writeRowNameFirst(self):
        return True

    @staticmethod
    def writeToWholeArray(arr):
        return com_sdtk_table_ArrayOfObjectsWriter(com_sdtk_table_ArrayOfObjectsInfo(arr,0,(len(arr) - 1),(len(arr) - 1),1,1,None))

    @staticmethod
    def writeToExpandableArrayI(arr,constructor):
        if (arr is None):
            arr = list()
        return com_sdtk_table_ArrayOfObjectsWriter(com_sdtk_table_ArrayOfObjectsInfo(arr,0,-1,-1,1,1,constructor))

    @staticmethod
    def writeToExpandableArray(arr,constructor):
        if (arr is None):
            arr = list()
        return com_sdtk_table_ArrayOfObjectsWriter(com_sdtk_table_ArrayOfObjectsInfo(arr,0,-1,-1,1,1,constructor))

    @staticmethod
    def reuse(info):
        return com_sdtk_table_ArrayOfObjectsWriter(info)


class com_sdtk_table_ArrayReader(com_sdtk_table_DataTableReader):

    def __init__(self,info):
        self._info = None
        self._i = None
        super().__init__()
        self._info = info
        self._i = info._start

    def hasNext(self):
        return (self._i <= self._info._end)

    def nextReuse(self,rowReader):
        if (rowReader is None):
            rowReader = com_sdtk_table_ArrayRowReader.continueRead(self._info,self._i,((self._i + self._info._entriesInRow) - 1))
        else:
            rr = rowReader
            rr.reuse(python_internal_ArrayImpl._get(self._info._arr, self._i))
        self._value = rowReader
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._i
        _hx_local_0._i = (_hx_local_1 + self._info._rowIncrement)
        _hx_local_0._i
        return rowReader

    def next(self):
        return self.nextReuse(None)

    def iterator(self):
        return com_sdtk_table_ArrayReader(self._info)

    def flip(self):
        return com_sdtk_table_ArrayWriter.reuse(self._info)

    def reset(self):
        self._i = self._info._start

    @staticmethod
    def readSlicesOfArray(arr,start,end,entriesInRow,increment,rowIncrement):
        return com_sdtk_table_ArrayReader(com_sdtk_table_ArrayInfo(arr,start,end,entriesInRow,increment,rowIncrement))

    @staticmethod
    def readPartOfArray(arr,start,end,increment):
        return com_sdtk_table_ArrayReader(com_sdtk_table_ArrayInfo(arr,start,end,(len(arr) - 1),increment,1))

    @staticmethod
    def readWholeArray(arr):
        return com_sdtk_table_ArrayReader(com_sdtk_table_ArrayInfo(arr,0,(len(arr) - 1),(len(arr) - 1),1,0))

    @staticmethod
    def reuse(info):
        return com_sdtk_table_ArrayReader(info)


class com_sdtk_table_Stopwatch:

    def __init__(self):
        pass

    def start(self):
        pass

    def end(self):
        pass

    def toString(self):
        return None

    def isNull(self):
        return True

    @staticmethod
    def getStopwatch(name):
        watch = com_sdtk_table_Stopwatch._watches.h.get(name,None)
        if (watch is None):
            if com_sdtk_table_Stopwatch._defaultActual:
                watch = com_sdtk_table_StopwatchWrapper(com_sdtk_table_StopwatchActual(name))
            else:
                if (com_sdtk_table_Stopwatch._null is None):
                    com_sdtk_table_Stopwatch._null = com_sdtk_table_StopwatchNull()
                watch = com_sdtk_table_StopwatchWrapper(com_sdtk_table_Stopwatch._null)
            com_sdtk_table_Stopwatch._watches.h[name] = watch
        return watch

    @staticmethod
    def setDefaultActual(defaultActual):
        com_sdtk_table_Stopwatch._defaultActual = defaultActual
        if defaultActual:
            k = com_sdtk_table_Stopwatch._watches.keys()
            while k.hasNext():
                k1 = k.next()
                com_sdtk_table_Stopwatch.setActual(k1)

    @staticmethod
    def setActual(name):
        watch = com_sdtk_table_Stopwatch._watches.h.get(name,None)
        if (watch is None):
            watch = com_sdtk_table_StopwatchWrapper(com_sdtk_table_StopwatchActual(name))
            com_sdtk_table_Stopwatch._watches.h[name] = watch
        elif watch.isNull():
            wrapper = watch
            wrapper.set(com_sdtk_table_StopwatchActual(name))

    @staticmethod
    def printResults():
        buffer = ""
        k = com_sdtk_table_Stopwatch._watches.keys()
        while k.hasNext():
            k1 = k.next()
            watch = com_sdtk_table_Stopwatch._watches.h.get(k1,None)
            if (watch is not None):
                _hx_str = watch.toString()
                if (_hx_str is not None):
                    buffer = (("null" if buffer is None else buffer) + HxOverrides.stringOrNull(((("null" if _hx_str is None else _hx_str) + "\n"))))
        _hx_str = Std.string(buffer)
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))


class com_sdtk_table_StopwatchActual(com_sdtk_table_Stopwatch):
    _hx_class_name = "com.sdtk.table.StopwatchActual"
    __slots__ = ("_start", "_end", "_duration", "_invocations", "_name")
    _hx_fields = ["_start", "_end", "_duration", "_invocations", "_name"]
    _hx_methods = ["start", "end", "toString", "isNull"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_sdtk_table_Stopwatch


    def __init__(self,name):
        self._name = None
        self._end = None
        self._start = None
        self._invocations = 0
        self._duration = 0
        super().__init__()
        self._name = name

    def start(self):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._invocations
        _hx_local_0._invocations = (_hx_local_1 + 1)
        _hx_local_1
        self._start = Date.now()

    def end(self):
        self._end = Date.now()
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._duration
        _hx_local_0._duration = (_hx_local_1 + Math.floor(((self._end.date.timestamp() * 1000) - ((self._start.date.timestamp() * 1000)))))
        _hx_local_0._duration

    def toString(self):
        if (self._invocations == 1):
            return (((("Duration for " + HxOverrides.stringOrNull(self._name)) + " was ") + Std.string(self._duration)) + "ms")
        else:
            return (((((("Total duration for " + HxOverrides.stringOrNull(self._name)) + " was ") + Std.string(self._duration)) + "ms and it was invoked ") + Std.string(self._invocations)) + " times.")

    def isNull(self):
        return False

com_sdtk_table_StopwatchActual._hx_class = com_sdtk_table_StopwatchActual


class com_sdtk_table_StopwatchWrapper(com_sdtk_table_Stopwatch):
    _hx_class_name = "com.sdtk.table.StopwatchWrapper"
    __slots__ = ("_watch",)
    _hx_fields = ["_watch"]
    _hx_methods = ["start", "end", "toString", "set", "isNull"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_sdtk_table_Stopwatch


    def __init__(self,watch):
        self._watch = None
        super().__init__()
        self._watch = watch

    def start(self):
        self._watch.start()

    def end(self):
        self._watch.end()

    def toString(self):
        return self._watch.toString()

    def set(self,watch):
        self._watch = watch

    def isNull(self):
        return self._watch.isNull()

com_sdtk_table_StopwatchWrapper._hx_class = com_sdtk_table_StopwatchWrapper


class com_sdtk_table_StopwatchNull(com_sdtk_table_Stopwatch):
    _hx_class_name = "com.sdtk.table.StopwatchNull"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_sdtk_table_Stopwatch


    def __init__(self):
        super().__init__()
com_sdtk_table_StopwatchNull._hx_class = com_sdtk_table_StopwatchNull


class com_sdtk_table_DataTableRowReader(com_sdtk_table_DataEntryReader):

    def __init__(self):
        self._alwaysString = False
        super().__init__()

    def convertTo(self,rowWriter):
        aSingle = list()
        aSingle.append(rowWriter)
        self.convertToAll(aSingle)

    def fromStringToType(self,_hx_str):
        com_sdtk_table_DataTableRowReader._watch.start()
        result = None
        if self._alwaysString:
            result = _hx_str
        else:
            isInt = True
            isHex = True
            isFloat = True
            foundPoint = False
            foundComma = False
            foundX = False
            i = 0
            _g = _hx_str.lower()
            _hx_local_0 = len(_g)
            if (_hx_local_0 == 5):
                if (_g == "false"):
                    result = False
                else:
                    while (i < len(_hx_str)):
                        _g = ("" if (((i < 0) or ((i >= len(_hx_str))))) else _hx_str[i])
                        if (_g == ","):
                            foundComma = True
                        elif (_g == "."):
                            if foundPoint:
                                isFloat = False
                                break
                            else:
                                foundPoint = True
                            isHex = False
                            isInt = False
                        elif ((((((((((_g == "9") or ((_g == "8"))) or ((_g == "7"))) or ((_g == "6"))) or ((_g == "5"))) or ((_g == "4"))) or ((_g == "3"))) or ((_g == "2"))) or ((_g == "1"))) or ((_g == "0"))):
                            pass
                        elif ((((((((((((_g == "f") or ((_g == "e"))) or ((_g == "d"))) or ((_g == "c"))) or ((_g == "b"))) or ((_g == "a"))) or ((_g == "F"))) or ((_g == "E"))) or ((_g == "D"))) or ((_g == "C"))) or ((_g == "B"))) or ((_g == "A"))):
                            isInt = False
                            isFloat = False
                        elif ((_g == "x") or ((_g == "X"))):
                            if foundX:
                                isHex = False
                                break
                            else:
                                foundX = True
                            isFloat = False
                            isInt = False
                        else:
                            isFloat = False
                            isHex = False
                            isInt = False
                            break
                        i = (i + 1)
                    if foundComma:
                        _hx_str = StringTools.replace(_hx_str,",","")
                    if isFloat:
                        result = Std.parseFloat(_hx_str)
                    elif isHex:
                        if foundX:
                            result = Std.parseInt(_hx_str)
                        else:
                            result = Std.parseInt(("0x" + ("null" if _hx_str is None else _hx_str)))
                    elif isInt:
                        result = Std.parseInt(_hx_str)
                    else:
                        startIndex = None
                        if (((_hx_str.find("datetime.datetime(") if ((startIndex is None)) else HxString.indexOfImpl(_hx_str,"datetime.datetime(",startIndex))) == 0):
                            _hx_str = StringTools.replace(_hx_str,"datetime.datetime(","")
                            _hx_str = StringTools.replace(_hx_str,")","")
                            str2 = _hx_str.split(",")
                            i2 = list()
                            _hx_len = len(str2)
                            l = len(i2)
                            if (l < _hx_len):
                                idx = (_hx_len - 1)
                                v = None
                                l1 = len(i2)
                                while (l1 < idx):
                                    i2.append(None)
                                    l1 = (l1 + 1)
                                if (l1 == idx):
                                    i2.append(v)
                                else:
                                    i2[idx] = v
                            elif (l > _hx_len):
                                pos = _hx_len
                                len1 = (l - _hx_len)
                                if (pos < 0):
                                    pos = (len(i2) + pos)
                                if (pos < 0):
                                    pos = 0
                                res = i2[pos:(pos + len1)]
                                del i2[pos:(pos + len1)]
                            i = 0
                            while (i < len(i2)):
                                python_internal_ArrayImpl._set(i2, i, Std.parseInt(StringTools.trim((str2[i] if i >= 0 and i < len(str2) else None))))
                                i = (i + 1)
                            result = Date((i2[0] if 0 < len(i2) else None),(i2[1] if 1 < len(i2) else None),(i2[2] if 2 < len(i2) else None),(i2[3] if 3 < len(i2) else None),(i2[4] if 4 < len(i2) else None),(i2[5] if 5 < len(i2) else None))
                        else:
                            result = _hx_str
            elif (_hx_local_0 == 4):
                if (_g == "true"):
                    result = True
                else:
                    while (i < len(_hx_str)):
                        _g = ("" if (((i < 0) or ((i >= len(_hx_str))))) else _hx_str[i])
                        if (_g == ","):
                            foundComma = True
                        elif (_g == "."):
                            if foundPoint:
                                isFloat = False
                                break
                            else:
                                foundPoint = True
                            isHex = False
                            isInt = False
                        elif ((((((((((_g == "9") or ((_g == "8"))) or ((_g == "7"))) or ((_g == "6"))) or ((_g == "5"))) or ((_g == "4"))) or ((_g == "3"))) or ((_g == "2"))) or ((_g == "1"))) or ((_g == "0"))):
                            pass
                        elif ((((((((((((_g == "f") or ((_g == "e"))) or ((_g == "d"))) or ((_g == "c"))) or ((_g == "b"))) or ((_g == "a"))) or ((_g == "F"))) or ((_g == "E"))) or ((_g == "D"))) or ((_g == "C"))) or ((_g == "B"))) or ((_g == "A"))):
                            isInt = False
                            isFloat = False
                        elif ((_g == "x") or ((_g == "X"))):
                            if foundX:
                                isHex = False
                                break
                            else:
                                foundX = True
                            isFloat = False
                            isInt = False
                        else:
                            isFloat = False
                            isHex = False
                            isInt = False
                            break
                        i = (i + 1)
                    if foundComma:
                        _hx_str = StringTools.replace(_hx_str,",","")
                    if isFloat:
                        result = Std.parseFloat(_hx_str)
                    elif isHex:
                        if foundX:
                            result = Std.parseInt(_hx_str)
                        else:
                            result = Std.parseInt(("0x" + ("null" if _hx_str is None else _hx_str)))
                    elif isInt:
                        result = Std.parseInt(_hx_str)
                    else:
                        startIndex = None
                        if (((_hx_str.find("datetime.datetime(") if ((startIndex is None)) else HxString.indexOfImpl(_hx_str,"datetime.datetime(",startIndex))) == 0):
                            _hx_str = StringTools.replace(_hx_str,"datetime.datetime(","")
                            _hx_str = StringTools.replace(_hx_str,")","")
                            str2 = _hx_str.split(",")
                            i2 = list()
                            _hx_len = len(str2)
                            l = len(i2)
                            if (l < _hx_len):
                                idx = (_hx_len - 1)
                                v = None
                                l1 = len(i2)
                                while (l1 < idx):
                                    i2.append(None)
                                    l1 = (l1 + 1)
                                if (l1 == idx):
                                    i2.append(v)
                                else:
                                    i2[idx] = v
                            elif (l > _hx_len):
                                pos = _hx_len
                                len1 = (l - _hx_len)
                                if (pos < 0):
                                    pos = (len(i2) + pos)
                                if (pos < 0):
                                    pos = 0
                                res = i2[pos:(pos + len1)]
                                del i2[pos:(pos + len1)]
                            i = 0
                            while (i < len(i2)):
                                python_internal_ArrayImpl._set(i2, i, Std.parseInt(StringTools.trim((str2[i] if i >= 0 and i < len(str2) else None))))
                                i = (i + 1)
                            result = Date((i2[0] if 0 < len(i2) else None),(i2[1] if 1 < len(i2) else None),(i2[2] if 2 < len(i2) else None),(i2[3] if 3 < len(i2) else None),(i2[4] if 4 < len(i2) else None),(i2[5] if 5 < len(i2) else None))
                        else:
                            result = _hx_str
            else:
                while (i < len(_hx_str)):
                    _g = ("" if (((i < 0) or ((i >= len(_hx_str))))) else _hx_str[i])
                    if (_g == ","):
                        foundComma = True
                    elif (_g == "."):
                        if foundPoint:
                            isFloat = False
                            break
                        else:
                            foundPoint = True
                        isHex = False
                        isInt = False
                    elif ((((((((((_g == "9") or ((_g == "8"))) or ((_g == "7"))) or ((_g == "6"))) or ((_g == "5"))) or ((_g == "4"))) or ((_g == "3"))) or ((_g == "2"))) or ((_g == "1"))) or ((_g == "0"))):
                        pass
                    elif ((((((((((((_g == "f") or ((_g == "e"))) or ((_g == "d"))) or ((_g == "c"))) or ((_g == "b"))) or ((_g == "a"))) or ((_g == "F"))) or ((_g == "E"))) or ((_g == "D"))) or ((_g == "C"))) or ((_g == "B"))) or ((_g == "A"))):
                        isInt = False
                        isFloat = False
                    elif ((_g == "x") or ((_g == "X"))):
                        if foundX:
                            isHex = False
                            break
                        else:
                            foundX = True
                        isFloat = False
                        isInt = False
                    else:
                        isFloat = False
                        isHex = False
                        isInt = False
                        break
                    i = (i + 1)
                if foundComma:
                    _hx_str = StringTools.replace(_hx_str,",","")
                if isFloat:
                    result = Std.parseFloat(_hx_str)
                elif isHex:
                    if foundX:
                        result = Std.parseInt(_hx_str)
                    else:
                        result = Std.parseInt(("0x" + ("null" if _hx_str is None else _hx_str)))
                elif isInt:
                    result = Std.parseInt(_hx_str)
                else:
                    startIndex = None
                    if (((_hx_str.find("datetime.datetime(") if ((startIndex is None)) else HxString.indexOfImpl(_hx_str,"datetime.datetime(",startIndex))) == 0):
                        _hx_str = StringTools.replace(_hx_str,"datetime.datetime(","")
                        _hx_str = StringTools.replace(_hx_str,")","")
                        str2 = _hx_str.split(",")
                        i2 = list()
                        _hx_len = len(str2)
                        l = len(i2)
                        if (l < _hx_len):
                            idx = (_hx_len - 1)
                            v = None
                            l1 = len(i2)
                            while (l1 < idx):
                                i2.append(None)
                                l1 = (l1 + 1)
                            if (l1 == idx):
                                i2.append(v)
                            else:
                                i2[idx] = v
                        elif (l > _hx_len):
                            pos = _hx_len
                            len1 = (l - _hx_len)
                            if (pos < 0):
                                pos = (len(i2) + pos)
                            if (pos < 0):
                                pos = 0
                            res = i2[pos:(pos + len1)]
                            del i2[pos:(pos + len1)]
                        i = 0
                        while (i < len(i2)):
                            python_internal_ArrayImpl._set(i2, i, Std.parseInt(StringTools.trim((str2[i] if i >= 0 and i < len(str2) else None))))
                            i = (i + 1)
                        result = Date((i2[0] if 0 < len(i2) else None),(i2[1] if 1 < len(i2) else None),(i2[2] if 2 < len(i2) else None),(i2[3] if 3 < len(i2) else None),(i2[4] if 4 < len(i2) else None),(i2[5] if 5 < len(i2) else None))
                    else:
                        result = _hx_str
        com_sdtk_table_DataTableRowReader._watch.end()
        return result

    def toHaxeMap(self,_hx_map):
        if (_hx_map is None):
            _hx_map = haxe_ds_StringMap()
        self.convertTo(com_sdtk_table_MapRowWriter.continueWrite(_hx_map,True,None,None))
        return _hx_map

    def toNativeMap(self,_hx_map,keyField,valueField):
        if (_hx_map is not None):
            _hx_map = com_sdtk_std_Normalize.nativeToHaxe(_hx_map)
        return com_sdtk_std_Normalize.haxeToNative(self.toHaxeMap(_hx_map))

    def toObject(self,obj):
        self.convertTo(com_sdtk_table_ObjectRowWriter.continueWrite(obj,None,None))
        return obj

    def convertToAll(self,rowWriters):
        self.start()
        rowWriter = HxOverrides.iterator(rowWriters)
        while rowWriter.hasNext():
            rowWriter1 = rowWriter.next()
            rowWriter1.start()
        while self.hasNext():
            data = self.next()
            sName = self.name()
            iIndex = self.index()
            rowWriter = HxOverrides.iterator(rowWriters)
            while rowWriter.hasNext():
                rowWriter1 = rowWriter.next()
                if (rowWriter1 is not None):
                    rowWriter1.write(data,sName,iIndex)

    def alwaysString(self,value = None):
        if (value is None):
            return self._alwaysString
        else:
            self._alwaysString = value
            return self._alwaysString

    def eachEntryToRow(self,includeName = None,includeIndex = None,includeRawIndex = None,includeValue = None):
        if (includeName is None):
            includeName = True
        if (includeIndex is None):
            includeIndex = False
        if (includeRawIndex is None):
            includeRawIndex = False
        if (includeValue is None):
            includeValue = True
        return com_sdtk_table_DataTableRowReaderAdapter(self,includeName,includeIndex,includeRawIndex,includeValue)

    def toArrayOfObjects(self,arr):
        if (arr is None):
            arr = list()
        self.convertTo(com_sdtk_table_ArrayRowWriter.writeToWholeArray(arr))
        return arr

    def to(self,o):
        return None

    def buffer(self):
        _hx_map = self.toHaxeMap(None)
        return com_sdtk_table_MapRowReader.readWholeMap(_hx_map)


class com_sdtk_table_ArrayRowReader(com_sdtk_table_DataTableRowReader):

    def __init__(self,info):
        self._info = None
        self._i = None
        super().__init__()
        self.reuse(info)

    def reuse(self,info):
        self._info = info
        self._i = info._start
        self._started = False
        self._index = -1
        self._rawIndex = -1
        self._started = False
        self._value = None

    def hasNext(self):
        return (self._i <= self._info._end)

    def next(self):
        self._name = Std.string(self._index)
        self._value = python_internal_ArrayImpl._get(self._info._arr, self._i)
        self.incrementTo(None,self._value,self._i)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._i
        _hx_local_0._i = (_hx_local_1 + self._info._increment)
        _hx_local_0._i
        return self._value

    def iterator(self):
        return com_sdtk_table_ArrayRowReader(self._info)

    def reset(self):
        self._i = self._info._start

    def dispose(self):
        if (self._info is not None):
            self._info = None

    @staticmethod
    def continueRead(info,start,end):
        return com_sdtk_table_ArrayRowReader.continueReadReuse(info,start,end,None)

    @staticmethod
    def readPartOfArray(arr,start,end,increment):
        return com_sdtk_table_ArrayRowReader.readPartOfArrayReuse(arr,start,end,increment,None)

    @staticmethod
    def readWholeArray(arr):
        return com_sdtk_table_ArrayRowReader.readWholeArrayReuse(arr,None)

    @staticmethod
    def continueReadReuse(info,start,end,rowReader):
        info1 = com_sdtk_table_ArrayInfo(info._arr,start,end,info._entriesInRow,info._increment,info._rowIncrement)
        if (rowReader is None):
            rowReader = com_sdtk_table_ArrayRowReader(info1)
        else:
            rowReader.reuse(info1)
        return rowReader

    @staticmethod
    def readPartOfArrayReuse(arr,start,end,increment,rowReader):
        info = com_sdtk_table_ArrayInfo(arr,start,end,(len(arr) - 1),increment,1)
        if (rowReader is None):
            rowReader = com_sdtk_table_ArrayRowReader(info)
        else:
            rowReader.reuse(info)
        return rowReader

    @staticmethod
    def readWholeArrayReuse(arr,rowReader):
        info = com_sdtk_table_ArrayInfo(arr,0,(len(arr) - 1),(len(arr) - 1),1,0)
        if (rowReader is None):
            rowReader = com_sdtk_table_ArrayRowReader(info)
        else:
            rowReader.reuse(info)
        return rowReader


class com_sdtk_table_ArrayRowWriter(com_sdtk_table_DataTableRowWriter):

    def __init__(self,info):
        self._info = None
        self._i = None
        super().__init__()
        self.reuse(info)

    def reuse(self,info):
        self._info = info
        self._i = info._start

    def write(self,data,name,index):
        if (self._info is not None):
            if ((self._info._end >= 0) and (((index + self._info._start) > self._info._end))):
                return
            arr = self._info._arr
            while (len(arr) <= index):
                arr.append(None)
            python_internal_ArrayImpl._set(arr, index, data)

    def reset(self):
        self._i = self._info._start

    def dispose(self):
        if (self._info is not None):
            self._info = None

    @staticmethod
    def continueWrite(info,start,end):
        return com_sdtk_table_ArrayRowWriter.continueWriteReuse(info,start,end,None)

    @staticmethod
    def writeToPartOfArray(arr,start,end,increment):
        return com_sdtk_table_ArrayRowWriter.writeToPartOfArrayReuse(arr,start,end,increment,None)

    @staticmethod
    def writeToWholeArray(arr):
        return com_sdtk_table_ArrayRowWriter.writeToWholeArrayReuse(arr,None)

    @staticmethod
    def writeToExpandableArray(arr):
        return com_sdtk_table_ArrayRowWriter.writeToExpandableArrayReuse(arr,None)

    @staticmethod
    def continueWriteReuse(info,start,end,rowWriter):
        info1 = com_sdtk_table_ArrayInfo(info._arr,start,end,info._entriesInRow,info._increment,info._rowIncrement)
        if (rowWriter is None):
            rowWriter = com_sdtk_table_ArrayRowWriter(info1)
        else:
            rowWriter.reuse(info1)
        return rowWriter

    @staticmethod
    def writeToPartOfArrayReuse(arr,start,end,increment,rowWriter):
        info = com_sdtk_table_ArrayInfo(arr,start,end,(len(arr) - 1),increment,1)
        if (rowWriter is None):
            rowWriter = com_sdtk_table_ArrayRowWriter(info)
        else:
            rowWriter.reuse(info)
        return rowWriter

    @staticmethod
    def writeToWholeArrayReuse(arr,rowWriter):
        info = com_sdtk_table_ArrayInfo(arr,0,(len(arr) - 1),(len(arr) - 1),1,0)
        if (rowWriter is None):
            rowWriter = com_sdtk_table_ArrayRowWriter(info)
        else:
            rowWriter.reuse(info)
        return rowWriter

    @staticmethod
    def writeToExpandableArrayReuse(arr,rowWriter):
        info = com_sdtk_table_ArrayInfo(arr,0,-1,-1,1,0)
        if (rowWriter is None):
            rowWriter = com_sdtk_table_ArrayRowWriter(info)
        else:
            rowWriter.reuse(info)
        return rowWriter


class com_sdtk_table_ArrayWriter(com_sdtk_table_DataTableWriter):

    def __init__(self,info):
        self._info = None
        self._i = None
        super().__init__()
        self._info = info
        self._i = info._start

    def start(self):
        pass

    def flip(self):
        return com_sdtk_table_ArrayReader.reuse(self._info)

    def writeStartI(self,name,index,rowWriter):
        if ((self._info._end >= 0) and (((index + self._info._start) > self._info._end))):
            return None
        rowWriter1 = com_sdtk_table_ArrayRowWriter.continueWriteReuse(self._info,self._i,((self._i + self._info._entriesInRow) - 1),rowWriter)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._i
        _hx_local_0._i = (_hx_local_1 + self._info._rowIncrement)
        _hx_local_0._i
        return rowWriter1

    def dispose(self):
        if (self._info is not None):
            self._info = None

    @staticmethod
    def writeToSlicesOfArray(arr,start,end,entriesInRow,increment,rowIncrement):
        return com_sdtk_table_ArrayWriter(com_sdtk_table_ArrayInfo(arr,start,end,entriesInRow,increment,rowIncrement))

    @staticmethod
    def writeToPartOfArray(arr,start,end,increment):
        return com_sdtk_table_ArrayWriter(com_sdtk_table_ArrayInfo(arr,start,end,(len(arr) - 1),increment,1))

    @staticmethod
    def writeToWholeArray(arr):
        return com_sdtk_table_ArrayWriter(com_sdtk_table_ArrayInfo(arr,0,(len(arr) - 1),(len(arr) - 1),1,0))

    @staticmethod
    def writeToExpandableArray(arr):
        return com_sdtk_table_ArrayWriter(com_sdtk_table_ArrayInfo(arr,0,-1,-1,1,0))

    @staticmethod
    def reuse(info):
        return com_sdtk_table_ArrayWriter(info)


class com_sdtk_table_FileSystemHandler:
    pass


class com_sdtk_table_CMDDirHandler:

    def __init__(self):
        self._NAME = 2
        self._extension = "."
        self._tilde = "~"
        self._zero = "0"
        self._footerFreeSpace = " bytes free"
        self._total = "     Total Files Listed:"
        self._footerSize = "  bytes"
        self._footerDirs = " Dir(s)  "
        self._footerFiles = " File(s) "
        self._trueNameEnd = "]"
        self._trueNameStart = "["
        self._space = " "
        self._numberSeparator = ","
        self._dateIndicator = "/"
        self._timeIndicator = ":"
        self._driveIndicator = ":"
        self._startOfSection = " "
        self._endOfSection = "\n\n"
        self._endOfEntry = "\n"
        self._directorySeparator = "\\"
        self._noDirIndicator = "     "
        self._junctionIndicator2 = "    "
        self._junctionIndicator = "<JUNCTION>"
        self._dirIndicator2 = "         "
        self._dirIndicator = "<DIR>"
        self._dtSeparator = "    "
        self._timeSeparator = "  "
        self._secondEntry = " .."
        self._firstEntry = " ."
        self._directoryOf = " Directory of "
        self._serial = " Volume Serial Number is "
        self._is = " is "
        self._volumeInDrive = " Volume in drive "

    def convertFromDateTime(self,dDate):
        iHours = dDate.date.hour
        return ((((((((((Std.string(((dDate.date.month - 1) - 1)) + "/") + Std.string(dDate.date.day)) + "/") + Std.string(dDate.date.year)) + " ") + Std.string(((12 if (((iHours == 0) or ((iHours == 12)))) else HxOverrides.mod(iHours, 12))))) + ":") + Std.string(dDate.date.minute)) + " ") + HxOverrides.stringOrNull((("AM" if ((iHours < 12)) else "PM"))))

    def convertToDate(self,sDate):
        iMonth = Std.parseInt(HxString.substr(sDate,0,2))
        iDay = Std.parseInt(HxString.substr(sDate,2,2))
        iYear = Std.parseInt(HxString.substr(sDate,4,4))
        return Date(iYear,(iMonth - 1),iDay,0,0,0)

    def convertToTime(self,sTime):
        iHours = Std.parseInt(HxString.substr(sTime,0,2))
        if (HxString.substr(sTime,4,2).lower() == "pm"):
            if (iHours < 12):
                iHours = (iHours + 12)
        elif (iHours == 12):
            iHours = 0
        iMinutes = ((iHours * 60) + Std.parseInt(HxString.substr(sTime,2,2)))
        return ((iMinutes * 60) * 1000)

    def convertToSize(self,sSize):
        return Std.parseInt(StringTools.replace(StringTools.replace(sSize,self._numberSeparator,""),self._space,""))

    def convertFromSize(self,iSize,iOptions):
        if (iSize <= 0):
            return self._zero
        elif (iSize < 1000):
            return Std.string(iSize)
        elif (((iOptions & com_sdtk_table_CMDDirHandler.OPTION_COMMAS)) != 0):
            sParts = list()
            while (iSize > 0):
                iPart = HxOverrides.mod(iSize, 1000)
                iSize1 = None
                try:
                    iSize1 = int((iSize / 1000))
                except BaseException as _g:
                    None
                    iSize1 = None
                iSize = iSize1
                x = Std.string(iPart)
                sParts.append(x)
            sParts.reverse()
            return self._numberSeparator.join([python_Boot.toString1(x1,'') for x1 in sParts])
        else:
            return Std.string(iSize)

    def convertFromCount(self,iCount):
        return Std.string(iCount)

    def displayFooter(self,wWriter,diInfo,iOptions,tiTally):
        iCount = diInfo.getCount()
        iSize = diInfo.getSize()
        wWriter.write(self.convertFromCount(iCount))
        wWriter.write(self._footerFiles)
        wWriter.write(self.convertFromSize(iSize,iOptions))
        wWriter.write(self._footerSize)
        wWriter.write(self._endOfSection)
        tiTally.add(iCount,iSize)

    def write(self,wWriter,fiPrevious,fiCurrent,iOptions,tiTally):
        if (((iOptions & com_sdtk_table_CMDDirHandler.OPTION_BARE)) == com_sdtk_table_CMDDirHandler.OPTION_BARE):
            wWriter.write(fiCurrent.getName())
            wWriter.write(self._endOfEntry)
        elif (((iOptions & com_sdtk_table_CMDDirHandler.OPTION_FULL_PATH)) == com_sdtk_table_CMDDirHandler.OPTION_FULL_PATH):
            wWriter.write(fiCurrent.getFullPath())
            wWriter.write(self._endOfEntry)
        else:
            if (fiCurrent is None):
                self.displayFooter(wWriter,fiPrevious.getDirectoryInfo(),iOptions,tiTally)
                if (tiTally.getNumberOfEntries() > 1):
                    wWriter.write(self._total)
                    wWriter.write(self._endOfEntry)
                    wWriter.write(self.convertFromCount(tiTally.getFileCount()))
                    wWriter.write(self._footerFiles)
                    wWriter.write(self.convertFromSize(tiTally.getFileSize(),iOptions))
                    wWriter.write(self._footerSize)
                    wWriter.write(self._endOfEntry)
                    wWriter.write(self.convertFromCount(tiTally.getNumberOfEntries()))
                    wWriter.write(self._footerDirs)
                    try:
                        wWriter.write(self.convertFromSize(tiTally.getFreeSpace(),iOptions))
                        wWriter.write(self._footerFreeSpace)
                    except BaseException as _g:
                        None
                    wWriter.write(self._endOfSection)
            elif ((fiPrevious is None) or ((fiPrevious.getDrive() != fiCurrent.getDrive()))):
                if (fiPrevious is not None):
                    self.displayFooter(wWriter,fiPrevious.getDirectoryInfo(),iOptions,tiTally)
                wWriter.write(self._volumeInDrive)
                wWriter.write(fiCurrent.getDrive())
                wWriter.write(self._is)
                wWriter.write(fiCurrent.getLabel())
                wWriter.write(self._endOfEntry)
                wWriter.write(self._serial)
                wWriter.write(fiCurrent.getSerial())
                wWriter.write(self._endOfSection)
                wWriter.write(self._directoryOf)
                wWriter.write(fiCurrent.getDirectory())
                wWriter.write(self._endOfSection)
            elif (fiPrevious.getDirectory() != fiCurrent.getDirectory()):
                wWriter.write(self._directoryOf)
                wWriter.write(fiCurrent.getDirectory())
                wWriter.write(self._endOfSection)
            wWriter.write(self.convertFromDateTime(fiCurrent.getDate()))
            wWriter.write(self._dtSeparator)
            if fiCurrent.getIsDirectory():
                wWriter.write(self._dirIndicator)
                wWriter.write(self._dirIndicator2)
            elif fiCurrent.getIsJunction():
                wWriter.write(self._junctionIndicator)
                wWriter.write(self._junctionIndicator2)
            else:
                wWriter.write(self.convertFromSize(fiCurrent.getSize(),iOptions))
                if (((iOptions & com_sdtk_table_CMDDirHandler.OPTION_SHORT_NAME)) == com_sdtk_table_CMDDirHandler.OPTION_SHORT_NAME):
                    if (((iOptions & com_sdtk_table_CMDDirHandler.OPTION_LOWER_CASE_NAMES)) == com_sdtk_table_CMDDirHandler.OPTION_LOWER_CASE_NAMES):
                        wWriter.write(fiCurrent.getShortName().lower())
                    else:
                        wWriter.write(fiCurrent.getShortName())
                if (((iOptions & com_sdtk_table_CMDDirHandler.OPTION_OWNER_NAME)) == com_sdtk_table_CMDDirHandler.OPTION_OWNER_NAME):
                    wWriter.write(fiCurrent.getOwner())
                if (((iOptions & com_sdtk_table_CMDDirHandler.OPTION_LOWER_CASE_NAMES)) == com_sdtk_table_CMDDirHandler.OPTION_LOWER_CASE_NAMES):
                    wWriter.write(fiCurrent.getName().lower())
                else:
                    wWriter.write(fiCurrent.getName())
                if (((iOptions & com_sdtk_table_CMDDirHandler.OPTION_TRUE_NAME)) == com_sdtk_table_CMDDirHandler.OPTION_TRUE_NAME):
                    sTrueName = fiCurrent.getTrueName()
                    if ((sTrueName is not None) and ((len(sTrueName) > 0))):
                        wWriter.write(self._trueNameStart)
                        wWriter.write(sTrueName)
                        wWriter.write(self._trueNameEnd)
                wWriter.write(self._endOfEntry)

    def next(self,rReader,fiPrevious):
        rReader = rReader.switchToLineReader()
        sLine = rReader.next()
        if (sLine is not None):
            sCurrentDrive = None
            sCurrentLabel = None
            sCurrentSerial = None
            sCurrentDirectory = None
            bChanged = False
            if (fiPrevious is not None):
                sCurrentDrive = fiPrevious.getDrive()
                sCurrentLabel = fiPrevious.getLabel()
                sCurrentSerial = fiPrevious.getSerial()
                sCurrentDirectory = fiPrevious.getDirectory()
            while True:
                start = self._startOfSection
                if sLine.startswith(start):
                    break
                start1 = self._volumeInDrive
                if sLine.startswith(start1):
                    sLine = HxString.substr(sLine,0,len(self._volumeInDrive))
                    _hx_str = self._is
                    startIndex = None
                    iIs = None
                    if (startIndex is None):
                        iIs = sLine.rfind(_hx_str, 0, len(sLine))
                    elif (_hx_str == ""):
                        length = len(sLine)
                        if (startIndex < 0):
                            startIndex = (length + startIndex)
                            if (startIndex < 0):
                                startIndex = 0
                        iIs = (length if ((startIndex > length)) else startIndex)
                    else:
                        i = sLine.rfind(_hx_str, 0, (startIndex + 1))
                        startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
                        check = sLine.find(_hx_str, startLeft, len(sLine))
                        iIs = (check if (((check > i) and ((check <= startIndex)))) else i)
                    sCurrentDrive = HxString.substr(sLine,0,iIs)
                    sCurrentLabel = HxString.substr(sLine,(iIs + len(self._is)),None)
                    bChanged = True
                else:
                    start2 = self._serial
                    if sLine.startswith(start2):
                        sCurrentSerial = HxString.substr(sLine,len(self._serial),None)
                        bChanged = True
                    else:
                        start3 = self._directoryOf
                        if sLine.startswith(start3):
                            sCurrentDirectory = HxString.substr(sLine,len(self._directoryOf),None)
                            bChanged = True
                sLine = rReader.next()
                if (sLine is None):
                    return None
            while True:
                tmp = None
                end = self._firstEntry
                if (not sLine.endswith(end)):
                    end1 = self._secondEntry
                    tmp = sLine.endswith(end1)
                else:
                    tmp = True
                if (not tmp):
                    break
                sLine = rReader.next()
                if (sLine is None):
                    return None
            fiNew = com_sdtk_table_FileInfo()
            if ((("" if ((1 >= len(sLine))) else sLine[1])) == self._driveIndicator):
                _hx_str = self._directorySeparator
                startIndex = None
                iSeparator = None
                if (startIndex is None):
                    iSeparator = sLine.rfind(_hx_str, 0, len(sLine))
                elif (_hx_str == ""):
                    length = len(sLine)
                    if (startIndex < 0):
                        startIndex = (length + startIndex)
                        if (startIndex < 0):
                            startIndex = 0
                    iSeparator = (length if ((startIndex > length)) else startIndex)
                else:
                    i = sLine.rfind(_hx_str, 0, (startIndex + 1))
                    startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
                    check = sLine.find(_hx_str, startLeft, len(sLine))
                    iSeparator = (check if (((check > i) and ((check <= startIndex)))) else i)
                sNewDrive = HxString.substr(sLine,0,1)
                sNewDirectory = HxString.substr(sLine,0,iSeparator)
                diNew = None
                if ((sCurrentDirectory != sNewDirectory) or ((sCurrentDrive != sNewDrive))):
                    diNew = com_sdtk_table_DirectoryInfo()
                    diNew.setDrive(sNewDrive)
                    diNew.setFullPath(sNewDirectory)
                else:
                    diNew = fiPrevious.getDirectoryInfo()
                fiNew.setDirectoryInfo(diNew)
                fiNew.setName(HxString.substr(sLine,(iSeparator + 1),None))
            elif ((((len(sLine) < 27) or (((("" if ((2 >= len(sLine))) else sLine[2])) != self._dateIndicator))) or (((("" if ((5 >= len(sLine))) else sLine[5])) != self._dateIndicator))) or (((("" if ((14 >= len(sLine))) else sLine[14])) != self._timeIndicator))):
                fiNew.setName(sLine)
            else:
                diNew = None
                if bChanged:
                    diNew = com_sdtk_table_DirectoryInfo()
                    diNew.setDrive(sCurrentDrive)
                    diNew.setLabel(sCurrentLabel)
                    diNew.setSerial(sCurrentSerial)
                    diNew.setFullPath(sCurrentDirectory)
                elif (fiPrevious is not None):
                    diNew = fiPrevious.getDirectoryInfo()
                else:
                    diNew = com_sdtk_table_DirectoryInfo()
                fiNew.setDirectoryInfo(diNew)
                _hx_str = self._timeSeparator
                startIndex = None
                iSeparator = (sLine.find(_hx_str) if ((startIndex is None)) else HxString.indexOfImpl(sLine,_hx_str,startIndex))
                fiNew.setDate(self.convertToDate(HxString.substr(sLine,0,iSeparator)))
                sLine = HxString.substr(sLine,(iSeparator + len(self._timeSeparator)),None)
                _hx_str = self._dtSeparator
                startIndex = None
                iSeparator = (sLine.find(_hx_str) if ((startIndex is None)) else HxString.indexOfImpl(sLine,_hx_str,startIndex))
                fiNew.setTime(self.convertToTime(HxString.substr(sLine,0,iSeparator)))
                sLine = HxString.substr(sLine,(iSeparator + len(self._dtSeparator)),None)
                start = self._dirIndicator
                if sLine.startswith(start):
                    fiNew.setIsDirectory(True)
                    sLine = HxString.substr(sLine,len(self._dirIndicator),None)
                else:
                    start = self._junctionIndicator
                    if sLine.startswith(start):
                        fiNew.setIsJunction(True)
                        sLine = HxString.substr(sLine,len(self._junctionIndicator),None)
                    else:
                        sLine = StringTools.ltrim(sLine)
                        startIndex = None
                        iSeparator = (sLine.find(" ") if ((startIndex is None)) else HxString.indexOfImpl(sLine," ",startIndex))
                        fiNew.setSize(self.convertToSize(HxString.substring(sLine,0,iSeparator)))
                        sLine = HxString.substring(sLine,(iSeparator + 1),None)
                        _hx_str = self._driveIndicator
                        startIndex = None
                        iTruePathLocation = None
                        if (startIndex is None):
                            iTruePathLocation = sLine.rfind(_hx_str, 0, len(sLine))
                        elif (_hx_str == ""):
                            length = len(sLine)
                            if (startIndex < 0):
                                startIndex = (length + startIndex)
                                if (startIndex < 0):
                                    startIndex = 0
                            iTruePathLocation = (length if ((startIndex > length)) else startIndex)
                        else:
                            i = sLine.rfind(_hx_str, 0, (startIndex + 1))
                            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
                            check = sLine.find(_hx_str, startLeft, len(sLine))
                            iTruePathLocation = (check if (((check > i) and ((check <= startIndex)))) else i)
                        if (iTruePathLocation > 0):
                            iTruePathLocation = (iTruePathLocation - 1)
                            _hx_str = self._trueNameEnd
                            startIndex = None
                            iTruePathEnd = None
                            if (startIndex is None):
                                iTruePathEnd = sLine.rfind(_hx_str, 0, len(sLine))
                            elif (_hx_str == ""):
                                length = len(sLine)
                                if (startIndex < 0):
                                    startIndex = (length + startIndex)
                                    if (startIndex < 0):
                                        startIndex = 0
                                iTruePathEnd = (length if ((startIndex > length)) else startIndex)
                            else:
                                i = sLine.rfind(_hx_str, 0, (startIndex + 1))
                                startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
                                check = sLine.find(_hx_str, startLeft, len(sLine))
                                iTruePathEnd = (check if (((check > i) and ((check <= startIndex)))) else i)
                            if (iTruePathEnd < iTruePathLocation):
                                iTruePathEnd = len(sLine)
                            fiNew.setTrueName(HxString.substr(sLine,iTruePathLocation,(iTruePathEnd - iTruePathLocation)))
                            sLine = HxString.substr(sLine,0,iTruePathLocation)
                            end = self._trueNameStart
                            if sLine.endswith(end):
                                sLine = HxString.substr(sLine,0,(iTruePathLocation - 1))
                            sLine = StringTools.rtrim(sLine)
                        _hx_str = self._startOfSection
                        startIndex = None
                        iEndOfFirstColumn = (sLine.find(_hx_str) if ((startIndex is None)) else HxString.indexOfImpl(sLine,_hx_str,startIndex))
                        _hx_str = self._tilde
                        startIndex = None
                        iTilde = (sLine.find(_hx_str) if ((startIndex is None)) else HxString.indexOfImpl(sLine,_hx_str,startIndex))
                        _hx_str = self._extension
                        startIndex = None
                        iNameLength = (sLine.find(_hx_str) if ((startIndex is None)) else HxString.indexOfImpl(sLine,_hx_str,startIndex))
                        _hx_str = self._directorySeparator
                        startIndex = None
                        iDirectory = (sLine.find(_hx_str) if ((startIndex is None)) else HxString.indexOfImpl(sLine,_hx_str,startIndex))
                        if ((((iEndOfFirstColumn > iTilde) and ((iEndOfFirstColumn > iNameLength))) and ((iNameLength >= iTilde))) and (((iDirectory < 0) or ((iDirectory > iEndOfFirstColumn))))):
                            fiNew.setShortName(HxString.substr(sLine,0,iEndOfFirstColumn))
                            sLine = HxString.substr(sLine,(iEndOfFirstColumn + 1),None)
                        sOwner = HxString.substr(sLine,0,23)
                        _hx_str = self._directorySeparator
                        startIndex = None
                        if (((sOwner.find(_hx_str) if ((startIndex is None)) else HxString.indexOfImpl(sOwner,_hx_str,startIndex))) > 0):
                            sOwner = StringTools.rtrim(sOwner)
                            fiNew.setOwner(sOwner)
                            sLine = HxString.substr(sLine,23,None)
                        fiNew.setName(sLine)
            return fiNew
        else:
            return None
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_CMDDirHandler._instance is None):
            com_sdtk_table_CMDDirHandler._instance = com_sdtk_table_CMDDirHandler()
        return com_sdtk_table_CMDDirHandler._instance


class com_sdtk_table_DelimitedInfo:
    pass


class com_sdtk_table_CSVInfo:

    def __init__(self):
        pass

    def fileStart(self):
        return ""

    def fileEnd(self):
        return ""

    def delimiter(self):
        return ","

    def rowDelimiter(self):
        return "\n"

    def boolStart(self):
        return ""

    def boolEnd(self):
        return ""

    def stringStart(self):
        return "\""

    def stringEnd(self):
        return "\""

    def intStart(self):
        return ""

    def intEnd(self):
        return ""

    def floatStart(self):
        return ""

    def floatEnd(self):
        return ""

    def replacements(self):
        return ["\\\\", "\\", "\"\"", "\"", "\\\n", "\n", "\\\t", "\t", "\\\r", "\r"]

    def replacementIndicator(self):
        return "\\"

    def widthMinimum(self):
        return -1

    def widthMaximum(self):
        return -1
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_CSVInfo._instance is None):
            com_sdtk_table_CSVInfo._instance = com_sdtk_table_CSVInfo()
        return com_sdtk_table_CSVInfo._instance


class com_sdtk_table_CodeInfo:
    pass


class com_sdtk_table_CSharpInfoAbstract:

    def __init__(self):
        pass

    def start(self):
        return ""

    def end(self):
        return ""

    def arrayStart(self):
        return "new [] { "

    def arrayEnd(self):
        return " }"

    def mapStart(self):
        return "new Dictionary<object, object> {"

    def mapEnd(self):
        return " }"

    def rowStart(self,name,index):
        return ""

    def rowEnd(self):
        return ""

    def betweenRows(self):
        return ",\n"

    def mapRowEnd(self):
        return "}"

    def arrayRowEnd(self):
        return ""

    def arrayRowStart(self,name,index):
        return ""

    def mapRowStart(self,name,index):
        if ((name is not None) and ((name != ""))):
            return (("[\"" + ("null" if name is None else name)) + "\"] = ")
        else:
            return (("[" + Std.string(index)) + "] = ")

    def mapIntEntry(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return ((("[\"" + ("null" if name is None else name)) + "\"] = ") + Std.string(data))
        else:
            return ((("[" + Std.string(index)) + "] = ") + Std.string(data))

    def mapBoolEntry(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return ((("[\"" + ("null" if name is None else name)) + "\"] = ") + Std.string(data))
        else:
            return ((("[" + Std.string(index)) + "] = ") + Std.string(data))

    def mapFloatEntry(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return ((("[\"" + ("null" if name is None else name)) + "\"] = ") + Std.string(data))
        else:
            return ((("[" + Std.string(index)) + "] = ") + Std.string(data))

    def mapOtherEntry(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return (((("[\"" + ("null" if name is None else name)) + "\"] = \"") + ("null" if data is None else data)) + "\"")
        else:
            return (((("[" + Std.string(index)) + "] = \"") + ("null" if data is None else data)) + "\"")

    def mapNullEntry(self,name,index):
        if ((name is not None) and ((name != ""))):
            return (("[\"" + ("null" if name is None else name)) + "\"] = null")
        else:
            return (("[" + Std.string(index)) + "] = null")

    def arrayIntEntry(self,data,name,index):
        return Std.string(data)

    def arrayBoolEntry(self,data,name,index):
        return Std.string(data)

    def arrayFloatEntry(self,data,name,index):
        return Std.string(data)

    def arrayOtherEntry(self,data,name,index):
        return (("\"" + ("null" if data is None else data)) + "\"")

    def arrayNullEntry(self,name,index):
        return "null"

    def intEntry(self,data,name,index):
        return None

    def boolEntry(self,data,name,index):
        return None

    def floatEntry(self,data,name,index):
        return None

    def otherEntry(self,data,name,index):
        return None

    def nullEntry(self,name,index):
        return None

    def betweenEntries(self):
        return ","

    def replacements(self):
        return ["\\\"", "\"", "\\\n", "\n", "\\\t", "\t"]


class com_sdtk_table_CSharpInfoArrayOfArrays(com_sdtk_table_CSharpInfoAbstract):

    def __init__(self):
        super().__init__()

    def start(self):
        return self.arrayStart()

    def end(self):
        return self.arrayEnd()

    def rowEnd(self):
        return self.arrayEnd()

    def rowStart(self,name,index):
        return (HxOverrides.stringOrNull(self.arrayRowStart(name,index)) + HxOverrides.stringOrNull(self.arrayStart()))

    def intEntry(self,data,name,index):
        return self.arrayIntEntry(data,name,index)

    def boolEntry(self,data,name,index):
        return self.arrayBoolEntry(data,name,index)

    def floatEntry(self,data,name,index):
        return self.arrayFloatEntry(data,name,index)

    def otherEntry(self,data,name,index):
        return self.arrayOtherEntry(data,name,index)

    def nullEntry(self,name,index):
        return self.arrayNullEntry(name,index)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_CSharpInfoArrayOfArrays._instance is None):
            com_sdtk_table_CSharpInfoArrayOfArrays._instance = com_sdtk_table_CSharpInfoArrayOfArrays()
        return com_sdtk_table_CSharpInfoArrayOfArrays._instance


class com_sdtk_table_CSharpInfoArrayOfMaps(com_sdtk_table_CSharpInfoAbstract):

    def __init__(self):
        super().__init__()

    def start(self):
        return self.arrayStart()

    def end(self):
        return self.arrayEnd()

    def rowEnd(self):
        return self.mapEnd()

    def rowStart(self,name,index):
        return (HxOverrides.stringOrNull(self.arrayRowStart(name,index)) + HxOverrides.stringOrNull(self.mapStart()))

    def intEntry(self,data,name,index):
        return self.mapIntEntry(data,name,index)

    def boolEntry(self,data,name,index):
        return self.mapBoolEntry(data,name,index)

    def floatEntry(self,data,name,index):
        return self.mapFloatEntry(data,name,index)

    def otherEntry(self,data,name,index):
        return self.mapOtherEntry(data,name,index)

    def nullEntry(self,name,index):
        return self.mapNullEntry(name,index)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_CSharpInfoArrayOfMaps._instance is None):
            com_sdtk_table_CSharpInfoArrayOfMaps._instance = com_sdtk_table_CSharpInfoArrayOfMaps()
        return com_sdtk_table_CSharpInfoArrayOfMaps._instance


class com_sdtk_table_CSharpInfoMapOfArrays(com_sdtk_table_CSharpInfoAbstract):

    def __init__(self):
        super().__init__()

    def start(self):
        return self.mapStart()

    def end(self):
        return self.mapEnd()

    def rowEnd(self):
        return self.arrayEnd()

    def rowStart(self,name,index):
        return (HxOverrides.stringOrNull(self.mapRowStart(name,index)) + HxOverrides.stringOrNull(self.arrayStart()))

    def intEntry(self,data,name,index):
        return self.arrayIntEntry(data,name,index)

    def boolEntry(self,data,name,index):
        return self.arrayBoolEntry(data,name,index)

    def floatEntry(self,data,name,index):
        return self.arrayFloatEntry(data,name,index)

    def otherEntry(self,data,name,index):
        return self.arrayOtherEntry(data,name,index)

    def nullEntry(self,name,index):
        return self.arrayNullEntry(name,index)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_CSharpInfoMapOfArrays._instance is None):
            com_sdtk_table_CSharpInfoMapOfArrays._instance = com_sdtk_table_CSharpInfoMapOfArrays()
        return com_sdtk_table_CSharpInfoMapOfArrays._instance


class com_sdtk_table_CSharpInfoMapOfMaps(com_sdtk_table_CSharpInfoAbstract):

    def __init__(self):
        super().__init__()

    def start(self):
        return self.mapStart()

    def end(self):
        return self.mapEnd()

    def rowEnd(self):
        return self.mapEnd()

    def rowStart(self,name,index):
        return (HxOverrides.stringOrNull(self.mapRowStart(name,index)) + HxOverrides.stringOrNull(self.mapStart()))

    def intEntry(self,data,name,index):
        return self.mapIntEntry(data,name,index)

    def boolEntry(self,data,name,index):
        return self.mapBoolEntry(data,name,index)

    def floatEntry(self,data,name,index):
        return self.mapFloatEntry(data,name,index)

    def otherEntry(self,data,name,index):
        return self.mapOtherEntry(data,name,index)

    def nullEntry(self,name,index):
        return self.mapNullEntry(name,index)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_CSharpInfoMapOfMaps._instance is None):
            com_sdtk_table_CSharpInfoMapOfMaps._instance = com_sdtk_table_CSharpInfoMapOfMaps()
        return com_sdtk_table_CSharpInfoMapOfMaps._instance


class com_sdtk_table_CodeRowWriter(com_sdtk_table_DataTableRowWriter):

    def __init__(self,info,writer):
        self._writer = None
        self._done = False
        self._written = False
        self._info = None
        super().__init__()
        self.reuse(info,writer)

    def reuse(self,info,writer):
        self._done = False
        if self._written:
            self._writer.write(self._info.rowEnd())
            self._writer.flush()
        self._written = False
        self._info = info
        self._writer = writer

    def write(self,data,name,index):
        com_sdtk_table_CodeRowWriter._watch.start()
        buf = StringBuf()
        if (not self._done):
            if self._written:
                s = Std.string(self._info.betweenEntries())
                buf.b.write(s)
            else:
                self._written = True
            self.writeValue(data,name,index,buf)
            self._writer.write(buf.b.getvalue())
        com_sdtk_table_CodeRowWriter._watch.end()

    def replacement(self,data):
        replacements = self._info.replacements()
        if ((replacements is not None) and ((len(replacements) > 0))):
            replaceI = 1
            while (replaceI < len(replacements)):
                data = StringTools.replace(data,(replacements[replaceI] if replaceI >= 0 and replaceI < len(replacements) else None),python_internal_ArrayImpl._get(replacements, (replaceI - 1)))
                replaceI = (replaceI + 2)
        return data

    def writeValue(self,data,name,index,buf):
        if (data is not None):
            _g = Type.typeof(data)
            tmp = _g.index
            if (tmp == 1):
                s = Std.string(self._info.intEntry(data,name,index))
                buf.b.write(s)
            elif (tmp == 2):
                s = Std.string(self._info.floatEntry(data,name,index))
                buf.b.write(s)
            elif (tmp == 3):
                s = Std.string(self._info.boolEntry(data,name,index))
                buf.b.write(s)
            else:
                other = _g
                s = Std.string(self._info.otherEntry(self.replacement(data),name,index))
                buf.b.write(s)
        else:
            s = Std.string(self._info.nullEntry(name,index))
            buf.b.write(s)

    def dispose(self):
        if (not self._done):
            self._writer.write(self._info.rowEnd())
            self._writer.flush()
            self._done = True
            self._written = False


class com_sdtk_table_CodeWriter(com_sdtk_table_DataTableWriter):

    def __init__(self,diInfo,wWriter):
        self._writer = None
        self._done = False
        self._info = None
        super().__init__()
        self._info = diInfo
        self._writer = wWriter

    def start(self):
        self._writer.start()

    def writeStartI(self,name,index,rowWriter):
        if (self._written == 0):
            self._writer.write(self._info.start())
        if (rowWriter is None):
            self._writer.write(self._info.rowStart(name,index))
            rowWriter = com_sdtk_table_CodeRowWriter(self._info,self._writer)
        else:
            rw = rowWriter
            rw.reuse(self._info,self._writer)
            self._writer.write(self._info.betweenRows())
            self._writer.write(self._info.rowStart(name,index))
        return rowWriter

    def dispose(self):
        if (not self._done):
            self._writer.write(self._info.end())
            self._done = True
            self._writer.dispose()

    def writeHeaderFirst(self):
        return False

    def writeRowNameFirst(self):
        return False

    @staticmethod
    def createSQLSelectWriter(writer,namesUseSingleQuote = None):
        if (namesUseSingleQuote is None):
            namesUseSingleQuote = False
        return com_sdtk_table_CodeWriter(com_sdtk_table_SQLSelectInfo.instance().namesUseSingleQuote(namesUseSingleQuote),writer)

    @staticmethod
    def createSQLCreatetWriter(writer,name,namesUseSingleQuote = None):
        if (namesUseSingleQuote is None):
            namesUseSingleQuote = False
        return com_sdtk_table_CodeWriter(com_sdtk_table_SQLSelectInfo.createTable(name).namesUseSingleQuote(namesUseSingleQuote),writer)

    @staticmethod
    def createSQLCreatetOrReplaceWriter(writer,name,namesUseSingleQuote = None):
        if (namesUseSingleQuote is None):
            namesUseSingleQuote = False
        return com_sdtk_table_CodeWriter(com_sdtk_table_SQLSelectInfo.createOrReplaceTable(name).namesUseSingleQuote(namesUseSingleQuote),writer)

    @staticmethod
    def createSQLInsertSelectWriter(writer,name,namesUseSingleQuote = None):
        if (namesUseSingleQuote is None):
            namesUseSingleQuote = False
        return com_sdtk_table_CodeWriter(com_sdtk_table_SQLSelectInfo.insertIntoTable(name).namesUseSingleQuote(namesUseSingleQuote),writer)

    @staticmethod
    def createCSharpArrayOfArraysWriter(writer):
        return com_sdtk_table_CodeWriter(com_sdtk_table_CSharpInfoArrayOfArrays.instance(),writer)

    @staticmethod
    def createCSharpArrayOfMapsWriter(writer):
        return com_sdtk_table_CodeWriter(com_sdtk_table_CSharpInfoArrayOfMaps.instance(),writer)

    @staticmethod
    def createCSharpMapOfArraysWriter(writer):
        return com_sdtk_table_CodeWriter(com_sdtk_table_CSharpInfoMapOfArrays.instance(),writer)

    @staticmethod
    def createCSharpMapOfMapsWriter(writer):
        return com_sdtk_table_CodeWriter(com_sdtk_table_CSharpInfoMapOfMaps.instance(),writer)

    @staticmethod
    def createPythonArrayOfArraysWriter(writer):
        return com_sdtk_table_CodeWriter(com_sdtk_table_PythonInfoArrayOfArrays.instance(),writer)

    @staticmethod
    def createPythonArrayOfMapsWriter(writer):
        return com_sdtk_table_CodeWriter(com_sdtk_table_PythonInfoArrayOfMaps.instance(),writer)

    @staticmethod
    def createPythonMapOfArraysWriter(writer):
        return com_sdtk_table_CodeWriter(com_sdtk_table_PythonInfoMapOfArrays.instance(),writer)

    @staticmethod
    def createPythonMapOfMapsWriter(writer):
        return com_sdtk_table_CodeWriter(com_sdtk_table_PythonInfoMapOfMaps.instance(),writer)

    @staticmethod
    def createHaxeArrayOfArraysWriter(writer):
        return com_sdtk_table_CodeWriter(com_sdtk_table_HaxeInfoArrayOfArrays.instance(),writer)

    @staticmethod
    def createHaxeArrayOfMapsWriter(writer):
        return com_sdtk_table_CodeWriter(com_sdtk_table_HaxeInfoArrayOfMaps.instance(),writer)

    @staticmethod
    def createHaxeMapOfArraysWriter(writer):
        return com_sdtk_table_CodeWriter(com_sdtk_table_HaxeInfoMapOfArrays.instance(),writer)

    @staticmethod
    def createHaxeMapOfMapsWriter(writer):
        return com_sdtk_table_CodeWriter(com_sdtk_table_HaxeInfoMapOfMaps.instance(),writer)

    @staticmethod
    def createJavaArrayOfArraysWriter(writer):
        return com_sdtk_table_CodeWriter(com_sdtk_table_JavaInfoArrayOfArrays.instance(),writer)

    @staticmethod
    def createJavaArrayOfMapsWriter(writer):
        return com_sdtk_table_CodeWriter(com_sdtk_table_JavaInfoArrayOfMaps.instance(),writer)

    @staticmethod
    def createJavaMapOfArraysWriter(writer):
        return com_sdtk_table_CodeWriter(com_sdtk_table_JavaInfoMapOfArrays.instance(),writer)

    @staticmethod
    def createJavaMapOfMapsWriter(writer):
        return com_sdtk_table_CodeWriter(com_sdtk_table_JavaInfoMapOfMaps.instance(),writer)

    @staticmethod
    def createJavaArrayOfMapsWriterLegacy(writer):
        return com_sdtk_table_CodeWriter(com_sdtk_table_JavaInfoArrayOfMapsLegacy.instance(),writer)

    @staticmethod
    def createJavaMapOfArraysWriterLegacy(writer):
        return com_sdtk_table_CodeWriter(com_sdtk_table_JavaInfoMapOfArraysLegacy.instance(),writer)

    @staticmethod
    def createJavaMapOfMapsWriterLegacy(writer):
        return com_sdtk_table_CodeWriter(com_sdtk_table_JavaInfoMapOfMapsLegacy.instance(),writer)


class com_sdtk_table_ColumnFilterDataTableReader(com_sdtk_table_DataTableReader):

    def __init__(self,dtrReader,fColumnHeaderFilter):
        self._buffer = None
        self._header = None
        self._columnHeaderFilter = None
        self._current = None
        self._remove = None
        self._reader = None
        self._prev = None
        self._sentHeader = False
        super().__init__()
        self._reader = dtrReader
        self._columnHeaderFilter = fColumnHeaderFilter

    def startI(self):
        self._reader.start()
        super().startI()
        if self._reader.hasNext():
            self._header = list()
            self._buffer = haxe_ds_StringMap()
            self._remove = list()
            dtrrHeader = self._reader.next()
            dtrrHeader.start()
            i = 0
            while dtrrHeader.hasNext():
                sValue = dtrrHeader.next()
                sHeader = dtrrHeader.name()
                if (self._columnHeaderFilter.filter(sHeader) is None):
                    _this = self._remove
                    _this.append(True)
                else:
                    _this1 = self._remove
                    _this1.append(False)
                self._buffer.h[sHeader] = sValue
                _this2 = self._header
                _this2.append(sHeader)
                i = (i + 1)

    def hasNext(self):
        if self._sentHeader:
            return self._reader.hasNext()
        else:
            return (self._header is not None)

    def nextReuse(self,rowReader):
        nextValue = None
        if ((rowReader is None) or ((self._index <= 0))):
            nextValue = self.nextI()
            nextValue = com_sdtk_table_ColumnFilterDataTableRowReader(nextValue,self._remove)
        else:
            rr = rowReader
            rr.reuse(self.nextI(),self._remove)
            nextValue = rr
        self.incrementTo(self._reader.name(),nextValue,self._reader.rawIndex())
        return self.value()

    def nextI(self):
        if self._sentHeader:
            self._prev = self._reader.nextReuse(self._prev)
            return self._prev
        else:
            self._sentHeader = True
            reader = com_sdtk_table_MapRowReader.readWholeMap(self._buffer)
            self._buffer = None
            return reader

    def next(self):
        return self.nextReuse(None)

    def isAutoNamed(self):
        return self._reader.isAutoNamed()

    def isNameIndex(self):
        return self._reader.isNameIndex()

    def headerRowNotIncluded(self):
        return self._reader.headerRowNotIncluded()

    def dispose(self):
        if (self._reader is not None):
            super().dispose()
            self._reader.dispose()
            self._reader = None
            self._current = None
            self._columnHeaderFilter = None
            self._prev = None
            self._buffer = None

    def reset(self):
        self._reader.reset()

    def getColumns(self):
        header = list()
        i = 0
        while (i < len(self._header)):
            if (not (self._remove[i] if i >= 0 and i < len(self._remove) else None)):
                x = (self._header[i] if i >= 0 and i < len(self._header) else None)
                header.append(x)
            i = (i + 1)
        return header


class com_sdtk_table_ColumnFilterDataTableRowReader(com_sdtk_table_DataTableRowReader):

    def __init__(self,dtrrReader,iRemove):
        self._current = None
        self._remove = None
        self._reader = None
        super().__init__()
        self.reuse(dtrrReader,iRemove)

    def reuse(self,dtrrReader,iRemove):
        self._reader = dtrrReader
        self._remove = iRemove
        self._current = None
        self._started = False
        self._index = -1

    def startI(self):
        self._reader.start()
        self.check()
        super().startI()

    def check(self):
        if (self._reader is not None):
            current = None
            current = self._reader.next()
            while python_internal_ArrayImpl._get(self._remove, self._reader.index()):
                current = None
                if (self._reader.index() >= ((len(self._remove) - 1))):
                    break
                current = self._reader.next()
            self._current = current

    def hasNext(self):
        return (self._current is not None)

    def next(self):
        oCurrent = self._current
        self.incrementTo(self._reader.name(),oCurrent,self._reader.rawIndex())
        self.check()
        return oCurrent

    def isAutoNamed(self):
        return self._reader.isAutoNamed()

    def isNameIndex(self):
        return self._reader.isNameIndex()

    def dispose(self):
        if (self._reader is not None):
            super().dispose()
            self._reader.dispose()
            self._reader = None
            self._remove = None
            self._current = None


class com_sdtk_table_Converter:

    @staticmethod
    def convert(oSource,oTarget):
        com_sdtk_table_Converter.convertWithOptions(oSource,None,oTarget,None,None,None,None,None,None,False,False,None,None)

    @staticmethod
    def length(o):
        if com_sdtk_table_Converter.isString(o):
            s = o
            return Reflect.field(o,"length")
        elif Std.isOfType(o,list):
            a = o
            return len(a)
        else:
            return -1

    @staticmethod
    def isString(o):
        return Std.isOfType(o,str)

    @staticmethod
    def convertWithOptions(oSource,fSource,oTarget,fTarget,sFilterColumnsExclude,sFilterColumnsInclude,sFilterRowsExclude,sFilterRowsInclude,sSortRowsBy,leftTrim,rightTrim,inputOptions,outputOptions):
        com_sdtk_table_Converter._watch.start()
        aStages = list()
        error = None
        try:
            if ((sSortRowsBy is not None) and ((com_sdtk_table_Converter.length(sSortRowsBy) > 0))):
                awWriter = None
                if Std.isOfType(oTarget,com_sdtk_table_Array2DWriter):
                    awWriter = oTarget
                else:
                    awWriter = com_sdtk_table_Array2DWriter.writeToExpandableArray(None)
                x = com_sdtk_table_ConverterStageStandard(oSource,fSource,awWriter,com_sdtk_table_Format.ARRAY,sFilterColumnsExclude,sFilterColumnsInclude,sFilterRowsExclude,sFilterRowsInclude,leftTrim,rightTrim,inputOptions,None)
                aStages.append(x)
                if com_sdtk_table_Converter.isString(sSortRowsBy):
                    x = com_sdtk_table_ConverterStageSort.createWithArrayAndColumnsString(awWriter.getArray(),sSortRowsBy)
                    aStages.append(x)
                else:
                    x = com_sdtk_table_ConverterStageSort.createWithArrayAndColumns(awWriter.getArray(),sSortRowsBy)
                    aStages.append(x)
                if (awWriter != oTarget):
                    arReader = awWriter.flip()
                    x = com_sdtk_table_ConverterStageStandard(arReader,com_sdtk_table_Format.ARRAY,oTarget,fTarget,None,None,None,None,False,False,None,outputOptions)
                    aStages.append(x)
            else:
                x = com_sdtk_table_ConverterStageStandard(oSource,fSource,oTarget,fTarget,sFilterColumnsExclude,sFilterColumnsInclude,sFilterRowsExclude,sFilterRowsInclude,leftTrim,rightTrim,inputOptions,outputOptions)
                aStages.append(x)
            columns = None
            _g = 0
            while (_g < len(aStages)):
                csStage = (aStages[_g] if _g >= 0 and _g < len(aStages) else None)
                _g = (_g + 1)
                csStage.setColumns(columns)
                csStage.convert()
                columns = csStage.getColumns()
        except BaseException as _g:
            None
            message = haxe_Exception.caught(_g).unwrap()
            error = message
        _g = 0
        while (_g < len(aStages)):
            csStage = (aStages[_g] if _g >= 0 and _g < len(aStages) else None)
            _g = (_g + 1)
            try:
                csStage.dispose()
            except BaseException as _g1:
                None
        com_sdtk_table_Converter._watch.end()
        if (error is not None):
            raise haxe_Exception.thrown(error)

    @staticmethod
    def main():
        pParameters = com_sdtk_table_Parameters()
        if pParameters.getRunInTestMode():
            _hx_str = Std.string(com_sdtk_table_Tests.runTests(pParameters.getRecordPass(),pParameters.getVerbose()))
            python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        elif ((pParameters.getInput() is None) or ((pParameters.getOutput() is None))):
            pParameters.fullPrint()
        else:
            com_sdtk_table_Converter.convertWithOptions(pParameters.getInput(),pParameters.getInputFormat(),pParameters.getOutput(),pParameters.getOutputFormat(),pParameters.getFilterColumnsExclude(),pParameters.getFilterColumnsInclude(),pParameters.getFilterRowsExclude(),pParameters.getFilterRowsInclude(),pParameters.getSortRowsBy(),pParameters.getLeftTrim(),pParameters.getRightTrim(),pParameters.getInputOptions(),pParameters.getOutputOptions())
        com_sdtk_table_Stopwatch.printResults()

    @staticmethod
    def start():
        return com_sdtk_table_ConverterInputOptions()

    @staticmethod
    def quick():
        return com_sdtk_table_ConverterQuickInputOptions()


class com_sdtk_table_ConverterInputFormatOptions:

    def __init__(self,values = None):
        if (values is None):
            values = haxe_ds_StringMap()
        self._values = values

    def raw(self):
        return self.setSourceFormatDelimited(com_sdtk_table_Format.RAW)

    def csv(self):
        return self.setSourceFormatDelimited(com_sdtk_table_Format.CSV)

    def psv(self):
        return self.setSourceFormatDelimited(com_sdtk_table_Format.PSV)

    def tsv(self):
        return self.setSourceFormatDelimited(com_sdtk_table_Format.TSV)

    def htmlTable(self):
        return self.setSourceFormat(com_sdtk_table_Format.HTMLTable)

    def dir(self):
        return self.setSourceFormat(com_sdtk_table_Format.DIR)

    def ini(self):
        return self.setSourceFormat(com_sdtk_table_Format.INI)

    def json(self):
        return self.setSourceFormat(com_sdtk_table_Format.JSON)

    def properties(self):
        return self.setSourceFormat(com_sdtk_table_Format.PROPERTIES)

    def splunk(self):
        return self.setSourceFormat(com_sdtk_table_Format.SPLUNK)

    def setSourceFormat(self,value):
        self._values.h["sourceFormat"] = value
        return com_sdtk_table_ConverterInputOperationsOptions(self._values)

    def setSourceFormatDelimited(self,value):
        self._values.h["sourceFormat"] = value
        return com_sdtk_table_ConverterInputOperationsOptionsDelimited(self._values)


class com_sdtk_table_ConverterInputOperationsOptions:

    def __init__(self,values = None):
        if (values is None):
            values = haxe_ds_StringMap()
        self._values = values

    def excludeColumn(self,value):
        return self.mergeFilter("filterColumnsExclude",com_sdtk_std_FilterBlockEqualString(value))

    def includeColumn(self,value):
        return self.mergeFilter("filterColumnsInclude",com_sdtk_std_FilterAllowEqualString(value))

    def excludeRow(self,value):
        return self.mergeFilter("filterRowsExclude",com_sdtk_std_FilterBlockEqualString(value))

    def includeRow(self,value):
        return self.mergeFilter("filterRowsIncludee",com_sdtk_std_FilterAllowEqualString(value))

    def mergeFilter(self,key,value):
        current = self._values.h.get(key,None)
        if (current is None):
            current = list()
        current.append(value)
        self._values.h[key] = current
        return self

    def output(self):
        return com_sdtk_table_ConverterOutputOptions(self._values)


class com_sdtk_table_ConverterInputOperationsOptionsDelimited(com_sdtk_table_ConverterInputOperationsOptions):

    def __init__(self,values = None):
        super().__init__(values)

    def excludeHeader(self,value = None):
        if (value is None):
            value = True
        return self.setValue("header",(not value))

    def textOnly(self,value = None):
        if (value is None):
            value = True
        return self.setValue("textOnly",(not value))

    def setValue(self,key,value):
        options = self._values.h.get("inputOptions",None)
        if (options is None):
            options = haxe_ds_StringMap()
            self._values.h["inputOptions"] = options
        options.h[key] = value
        return self


class com_sdtk_table_ConverterInputOptions:

    def __init__(self,values = None):
        if (values is None):
            values = haxe_ds_StringMap()
        self._values = values

    def readFile(self,file):
        return self.setSource(file,"file")

    def readString(self,value):
        return self.setSource(value,"string")

    def readDatabase(self,value):
        self._values.h["source"] = value
        self._values.h["sourceType"] = "db"
        self._values.h["sourceFormat"] = com_sdtk_table_Format.DB
        return com_sdtk_table_ConverterInputOperationsOptions(self._values)

    def readArrayOfArrays(self,value):
        self._values.h["source"] = value
        self._values.h["sourceType"] = "array"
        self._values.h["sourceFormat"] = com_sdtk_table_Format.ARRAY
        return com_sdtk_table_ConverterInputOperationsOptions(self._values)

    def setSource(self,value,sourceType):
        self._values.h["source"] = value
        self._values.h["sourceType"] = sourceType
        return com_sdtk_table_ConverterInputFormatOptions(self._values)


class com_sdtk_table_ConverterOutputFormatOptions:

    def __init__(self,values = None):
        if (values is None):
            values = haxe_ds_StringMap()
        self._values = values

    def tex(self):
        return self.setTargetFormatDelimited(com_sdtk_table_Format.TEX)

    def raw(self):
        return self.setTargetFormatDelimited(com_sdtk_table_Format.RAW)

    def csv(self):
        return self.setTargetFormatDelimited(com_sdtk_table_Format.CSV)

    def psv(self):
        return self.setTargetFormatDelimited(com_sdtk_table_Format.PSV)

    def tsv(self):
        return self.setTargetFormatDelimited(com_sdtk_table_Format.TSV)

    def htmlTable(self):
        return self.setTargetFormat(com_sdtk_table_Format.HTMLTable)

    def dir(self):
        return self.setTargetFormat(com_sdtk_table_Format.DIR)

    def ini(self):
        return self.setTargetFormat(com_sdtk_table_Format.INI)

    def json(self):
        return self.setTargetFormat(com_sdtk_table_Format.JSON)

    def properties(self):
        return self.setTargetFormat(com_sdtk_table_Format.PROPERTIES)

    def splunk(self):
        return self.setTargetFormat(com_sdtk_table_Format.SPLUNK)

    def sql(self):
        self._values.h["targetFormat"] = com_sdtk_table_Format.SQL
        return com_sdtk_table_ConverterOutputOperationsOptionsSQL(self._values)

    def csharp(self):
        return self.setTargetFormat(com_sdtk_table_Format.CSharp)

    def java(self):
        return self.setTargetFormat(com_sdtk_table_Format.Java)

    def haxe(self):
        return self.setTargetFormat(com_sdtk_table_Format.Haxe)

    def python(self):
        return self.setTargetFormat(com_sdtk_table_Format.Python)

    def setTargetFormat(self,value):
        self._values.h["targetFormat"] = value
        return com_sdtk_table_ConverterOutputOperationsOptions(self._values)

    def setTargetFormatDelimited(self,value):
        self._values.h["targetFormat"] = value
        return com_sdtk_table_ConverterOutputOperationsOptionsDelimited(self._values)


class com_sdtk_table_ConverterOutputOperationsOptions:

    def __init__(self,values = None):
        if (values is None):
            values = haxe_ds_StringMap()
        self._values = values

    def sortRowsBy(self,value):
        return self.mergeSortBy("sortRowsBy",value)

    def mergeSortBy(self,key,value):
        current = self._values.h.get(key,None)
        if (current is None):
            current = list()
        current.append(value)
        self._values.h[key] = current
        return self

    def execute(self,callback = None):
        result = None
        eTarget = None
        if ((self._values.h.get("targetType",None) == "element") and ((self._values.h.get("targetFormat",None) != com_sdtk_table_Format.HTMLTable))):
            eTarget = self._values.h.get("target",None)
            this1 = self._values
            value = StringBuf()
            this1.h["target"] = value
            self._values.h["targetType"] = "string"
        com_sdtk_table_Converter.convertWithOptions(self._values.h.get("source",None),self._values.h.get("sourceFormat",None),self._values.h.get("target",None),self._values.h.get("targetFormat",None),self._values.h.get("filterColumnsExclude",None),self._values.h.get("filterColumnsInclude",None),self._values.h.get("filterRowsExclude",None),self._values.h.get("filterRowsInclude",None),self._values.h.get("sortRowsBy",None),False,False,self._values.h.get("inputOptions",None),self._values.h.get("outputOptions",None))
        _g = self._values.h.get("targetType",None)
        if (_g == "array"):
            result = self._values.h.get("target",None)
        elif (_g == "string"):
            sb = self._values.h.get("target",None)
            result = sb.b.getvalue()
        else:
            pass
        if (eTarget is not None):
            result = None
        if (callback is None):
            return result
        else:
            callback(result)
            return None


class com_sdtk_table_ConverterOutputOperationsOptionsSQL(com_sdtk_table_ConverterOutputOperationsOptions):

    def __init__(self,values = None):
        super().__init__(values)

    def createTable(self,name):
        return self.setValue("Create",name)

    def createOrReplaceTable(self,name):
        return self.setValue("CreateOrReplace",name)

    def insertIntoTable(self,name):
        return self.setValue("Insert",name)

    def setValue(self,sqlType,tableName):
        options = self._values.h.get("outputOptions",None)
        if (options is None):
            options = haxe_ds_StringMap()
            self._values.h["outputOptions"] = options
        options.h["sqlType"] = sqlType
        options.h["tableName"] = tableName
        return com_sdtk_table_ConverterOutputOperationsOptions(self._values)


class com_sdtk_table_ConverterOutputOperationsOptionsDelimited(com_sdtk_table_ConverterOutputOperationsOptions):

    def __init__(self,values = None):
        super().__init__(values)

    def excludeHeader(self,value = None):
        if (value is None):
            value = True
        return self.setValue("header",(not value))

    def textOnly(self,value = None):
        if (value is None):
            value = True
        return self.setValue("textOnly",(not value))

    def setValue(self,key,value):
        options = self._values.h.get("outputOptions",None)
        if (options is None):
            options = haxe_ds_StringMap()
            self._values.h["outputOptions"] = options
        options.h[key] = value
        return self


class com_sdtk_table_ConverterOutputOptions:

    def __init__(self,values = None):
        if (values is None):
            values = haxe_ds_StringMap()
        self._values = values

    def writeFile(self,file):
        return self.setTarget(file,"file")

    def writeElement(self,e):
        return self.setTarget(e,"element")

    def writeString(self):
        return self.setTarget(StringBuf(),"string")

    def writeArrayOfArrays(self):
        this1 = self._values
        value = list()
        this1.h["target"] = value
        self._values.h["targetType"] = "array"
        self._values.h["targetFormat"] = com_sdtk_table_Format.ARRAY
        return com_sdtk_table_ConverterOutputOperationsOptions(self._values)

    def setTarget(self,value,targetType):
        self._values.h["target"] = value
        self._values.h["targetType"] = targetType
        return com_sdtk_table_ConverterOutputFormatOptions(self._values)


class com_sdtk_table_ConverterQuickInputOptions:

    def __init__(self):
        pass

    def raw(self,value):
        return self.next(self.read(value).raw())

    def csv(self,value):
        return self.next(self.read(value).csv())

    def psv(self,value):
        return self.next(self.read(value).psv())

    def tsv(self,value):
        return self.next(self.read(value).tsv())

    def htmlTable(self,value):
        return self.next(self.read(value).htmlTable())

    def dir(self,value):
        return self.next(self.read(value).dir())

    def ini(self,value):
        return self.next(self.read(value).ini())

    def json(self,value):
        return self.next(self.read(value).json())

    def properties(self,value):
        return self.next(self.read(value).properties())

    def splunk(self,value):
        return self.next(self.read(value).splunk())

    def readDatabase(self,value):
        return self.next(com_sdtk_table_Converter.start().readDatabase(value))

    def readArrayOfArrays(self,value):
        return self.next(com_sdtk_table_Converter.start().readArrayOfArrays(value))

    def read(self,value):
        return com_sdtk_table_Converter.start().readString(value)

    def next(self,value):
        return com_sdtk_table_ConverterQuickOutputOptions(value.output())


class com_sdtk_table_ConverterQuickOutputOptions:

    def __init__(self,values):
        self._values = values

    def tex(self,callback = None):
        return self._values.writeString().tex().execute(callback)

    def raw(self,callback = None):
        return self._values.writeString().raw().execute(callback)

    def csv(self,callback = None):
        return self._values.writeString().csv().execute(callback)

    def psv(self,callback = None):
        return self._values.writeString().psv().execute(callback)

    def tsv(self,callback = None):
        return self._values.writeString().tsv().execute(callback)

    def htmlTable(self,callback = None):
        return self._values.writeString().htmlTable().execute(callback)

    def dir(self,callback = None):
        return self._values.writeString().dir().execute(callback)

    def ini(self,callback = None):
        return self._values.writeString().ini().execute(callback)

    def json(self,callback = None):
        return self._values.writeString().json().execute(callback)

    def properties(self,callback = None):
        return self._values.writeString().properties().execute(callback)

    def splunk(self,callback = None):
        return self._values.writeString().splunk().execute(callback)

    def sql(self,callback = None):
        return self._values.writeString().sql().execute(callback)

    def csharp(self,callback = None):
        return self._values.writeString().csharp().execute(callback)

    def java(self,callback = None):
        return self._values.writeString().java().execute(callback)

    def haxe(self,callback = None):
        return self._values.writeString().haxe().execute(callback)

    def python(self,callback = None):
        return self._values.writeString().python().execute(callback)

    def writeArrayOfArrays(self,callback = None):
        return self._values.writeArrayOfArrays().execute(callback)


class com_sdtk_table_ConverterStage:
    pass


class com_sdtk_table_ConverterStageSort:

    def __init__(self):
        self._names = None
        self._reverse = None
        self._foundColumns = None
        self._columns = None
        self._array = None
        self._firstRowIsHeader = True

    def setArray(self,aArray):
        self._array = aArray

    def addColumn(self,iColumn,bReverse):
        if (self._columns is None):
            self._columns = list()
            self._reverse = list()
        _this = self._columns
        _this.append(iColumn)
        _this = self._reverse
        _this.append(bReverse)

    def addColumnName(self,sColumn,bReverse):
        if (self._names is None):
            self._names = list()
            self._reverse = list()
        _this = self._names
        _this.append(sColumn)
        _this = self._reverse
        _this.append(bReverse)

    def findNames(self):
        oFirstRow = (self._array[0] if 0 < len(self._array) else None)
        self._columns = list()
        if (len(self._names) == 1):
            _g = 0
            _g1 = self._names
            while (_g < len(_g1)):
                sName = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _this = self._columns
                x = python_internal_ArrayImpl.indexOf(self._foundColumns,sName,None)
                _this.append(x)
        else:
            self._firstRowIsHeader = True
            i = 0
            foundColumns = haxe_ds_StringMap()
            _g = 0
            _g1 = self._foundColumns
            while (_g < len(_g1)):
                o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (o != (oFirstRow[i] if i >= 0 and i < len(oFirstRow) else None)):
                    self._firstRowIsHeader = False
                value = i
                i = (i + 1)
                foundColumns.h[o] = value
            _g = 0
            _g1 = self._names
            while (_g < len(_g1)):
                sName = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _this = self._columns
                x = foundColumns.h.get(sName,None)
                _this.append(x)

    def convert(self):
        _gthis = self
        com_sdtk_table_ConverterStageSort._watch.start()
        oFirstRow = None
        if ((self._columns is None) and ((self._names is not None))):
            self.findNames()
            oFirstRow = (self._array[0] if 0 < len(self._array) else None)
        def _hx_local_2(a,b):
            if _gthis._firstRowIsHeader:
                if (a is oFirstRow):
                    return -1
                elif (b is oFirstRow):
                    return 1
            i = 0
            _g = 0
            _g1 = _gthis._columns
            while (_g < len(_g1)):
                iColumn = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                bReverse = (_gthis._reverse[i] if i >= 0 and i < len(_gthis._reverse) else None)
                columnA = Std.string((a[iColumn] if iColumn >= 0 and iColumn < len(a) else None))
                columnB = Std.string((b[iColumn] if iColumn >= 0 and iColumn < len(b) else None))
                _g2 = (-1 if ((columnA < columnB)) else (1 if ((columnA > columnB)) else 0))
                if (_g2 == -1):
                    if bReverse:
                        return 1
                    else:
                        return -1
                elif (_g2 == 1):
                    if bReverse:
                        return -1
                    else:
                        return 1
                else:
                    pass
                i = (i + 1)
            return 0
        self._array.sort(key= python_lib_Functools.cmp_to_key(_hx_local_2))
        com_sdtk_table_ConverterStageSort._watch.end()

    def setColumns(self,columns):
        self._foundColumns = columns

    def getColumns(self):
        return self._foundColumns

    def dispose(self):
        if (self._array is not None):
            self._array = None
            self._columns = None
            self._foundColumns = None
            self._reverse = None
            self._names = None

    @staticmethod
    def createWithArrayAndColumns(aArray,sColumns):
        stage = com_sdtk_table_ConverterStageSort()
        stage.setArray(aArray)
        _g = 0
        while (_g < len(sColumns)):
            sColumn = (sColumns[_g] if _g >= 0 and _g < len(sColumns) else None)
            _g = (_g + 1)
            stage.addColumnName(sColumn,False)
        return stage

    @staticmethod
    def createWithArrayAndColumnsString(aArray,sColumns):
        return com_sdtk_table_ConverterStageSort.createWithArrayAndColumns(aArray,sColumns.split(","))


class com_sdtk_table_ConverterStageStandard:

    def __init__(self,oSource,fSource,oTarget,fTarget,sFilterColumnsExclude,sFilterColumnsInclude,sFilterRowsExclude,sFilterRowsInclude,leftTrim,rightTrim,inputOptions,outputOptions):
        self._columns = None
        self._reader = None
        self._writer = None
        self._writer = com_sdtk_table_ConverterStageStandard.createWriter(oTarget,fTarget,outputOptions)
        self._reader = com_sdtk_table_ConverterStageStandard.createReader(oSource,fSource,sFilterColumnsExclude,sFilterColumnsInclude,sFilterRowsExclude,sFilterRowsInclude,leftTrim,rightTrim,inputOptions)

    def convert(self):
        self._reader.convertTo(self._writer)
        self._columns = self._reader.getColumns()

    def setColumns(self,columns):
        pass

    def getColumns(self):
        return self._columns

    def dispose(self):
        if (self._writer is not None):
            self._writer.dispose()
            self._writer = None
            self._reader.dispose()
            self._reader = None
            self._columns = None

    @staticmethod
    def isString(o):
        return Std.isOfType(o,str)

    @staticmethod
    def isInt(o):
        return Std.isOfType(o,Int)

    @staticmethod
    def mergeFilters(a,b):
        if ((((a is None) or ((len(a) <= 0)))) and (((b is None) or ((len(b) <= 0))))):
            return None
        else:
            mergedA = None
            mergedB = None
            if ((a is None) or ((len(a) <= 0))):
                mergedA = None
            else:
                _hx_filter = None
                _g = 0
                while (_g < len(a)):
                    f = (a[_g] if _g >= 0 and _g < len(a) else None)
                    _g = (_g + 1)
                    if (_hx_filter is None):
                        _hx_filter = f
                    else:
                        _hx_filter = _hx_filter._hx_or(f)
                mergedA = _hx_filter
            if ((b is None) or ((len(b) <= 0))):
                mergedB = None
            else:
                _hx_filter = None
                _g = 0
                while (_g < len(a)):
                    f = (a[_g] if _g >= 0 and _g < len(a) else None)
                    _g = (_g + 1)
                    if (_hx_filter is None):
                        _hx_filter = f
                    else:
                        _hx_filter = _hx_filter._hx_and(f)
                mergedB = _hx_filter
            if ((mergedA is not None) and ((mergedB is not None))):
                return mergedA._hx_and(mergedB)
            elif (mergedA is not None):
                return mergedA
            else:
                return mergedB

    @staticmethod
    def getOption(options,key,_hx_def = None):
        if (options is None):
            return _hx_def
        else:
            value = options.h.get(key,None)
            if (value is None):
                return _hx_def
            else:
                return value

    @staticmethod
    def createWriter(oTarget,fTarget,outputOptions):
        writer = None
        if (oTarget is not None):
            if Std.isOfType(oTarget,com_sdtk_table_DataTableWriter):
                writer = oTarget
            if (writer is None):
                sTarget = None
                if (oTarget == Std.string(oTarget)):
                    sTarget = "STRING"
                else:
                    sTarget = Type.getClassName(Type.getClass(oTarget)).upper()
                sTarget1 = sTarget
                _hx_local_0 = len(sTarget1)
                if (_hx_local_0 == 9):
                    if (sTarget1 == "STRINGBUF"):
                        oTarget = com_sdtk_std_StringWriter(oTarget)
                elif (_hx_local_0 == 5):
                    if (sTarget1 == "ARRAY"):
                        if (fTarget is None):
                            fTarget = com_sdtk_table_Format.ARRAY
                elif (_hx_local_0 == 6):
                    if (sTarget1 == "STRING"):
                        def _hx_local_2():
                            _hx_local_1 = oTarget
                            if (Std.isOfType(_hx_local_1,str) or ((_hx_local_1 is None))):
                                _hx_local_1
                            else:
                                raise "Class cast error"
                            return _hx_local_1
                        sString = _hx_local_2()
                        _g = ("" if ((0 >= len(sString))) else sString[0])
                        if ((_g == ".") or ((_g == "#"))):
                            oTarget = com_sdtk_table_ConverterStageStandard.getControl(oTarget)
                        else:
                            oTarget = com_sdtk_std_FileWriter(sString,False).convertToStringWriter().switchToDroppingCharacters()
                else:
                    pass
                if (fTarget is None):
                    if (com_sdtk_table_ConverterStageStandard.getControlType(oTarget) == 1):
                        fTarget = com_sdtk_table_Format.CSV
                diTarget = None
                ciTarget = None
                tiTarget = None
                fshTarget = None
                kvhTarget = None
                if (fTarget is not None):
                    tmp = fTarget.index
                    if (tmp == 0):
                        diTarget = com_sdtk_table_CSVInfo.instance()
                    elif (tmp == 1):
                        diTarget = com_sdtk_table_PSVInfo.instance()
                    elif (tmp == 2):
                        diTarget = com_sdtk_table_TSVInfo.instance()
                    elif (tmp == 3):
                        fshTarget = com_sdtk_table_CMDDirHandler.instance()
                        writer = com_sdtk_table_FileSystemWriter.createCMDDirWriter(oTarget)
                    elif (tmp == 4):
                        kvhTarget = com_sdtk_table_INIHandler.instance()
                        writer = com_sdtk_table_KeyValueWriter.createINIWriter(oTarget)
                    elif (tmp == 5):
                        kvhTarget = com_sdtk_table_JSONHandler.instance()
                        writer = com_sdtk_table_KeyValueWriter.createJSONWriter(oTarget)
                    elif (tmp == 6):
                        kvhTarget = com_sdtk_table_PropertiesHandler.instance()
                        writer = com_sdtk_table_KeyValueWriter.createPropertiesWriter(oTarget)
                    elif (tmp == 7):
                        sqlType = com_sdtk_table_ConverterStageStandard.getOption(outputOptions,"sqlType")
                        if (sqlType is not None):
                            tableName = com_sdtk_table_ConverterStageStandard.getOption(outputOptions,"tableName")
                            sqlType1 = sqlType
                            _hx_local_3 = len(sqlType1)
                            if (_hx_local_3 == 15):
                                if (sqlType1 == "CreateOrReplace"):
                                    ciTarget = com_sdtk_table_SQLSelectInfo.createOrReplaceTable(tableName)
                                else:
                                    ciTarget = com_sdtk_table_SQLSelectInfo.instance()
                            elif (_hx_local_3 == 6):
                                if (sqlType1 == "Create"):
                                    ciTarget = com_sdtk_table_SQLSelectInfo.createTable(tableName)
                                elif (sqlType1 == "Insert"):
                                    ciTarget = com_sdtk_table_SQLSelectInfo.insertIntoTable(tableName)
                                else:
                                    ciTarget = com_sdtk_table_SQLSelectInfo.instance()
                            else:
                                ciTarget = com_sdtk_table_SQLSelectInfo.instance()
                        else:
                            ciTarget = com_sdtk_table_SQLSelectInfo.instance()
                    elif (tmp == 8):
                        ciTarget = com_sdtk_table_HaxeInfoArrayOfMaps.instance()
                    elif (tmp == 9):
                        ciTarget = com_sdtk_table_PythonInfoArrayOfMaps.instance()
                    elif (tmp == 10):
                        ciTarget = com_sdtk_table_JavaInfoArrayOfMaps.instance()
                    elif (tmp == 11):
                        ciTarget = com_sdtk_table_CSharpInfoArrayOfMaps.instance()
                    elif (tmp == 12):
                        kvhTarget = com_sdtk_table_SplunkHandler.instance()
                        writer = com_sdtk_table_KeyValueWriter.createSplunkWriter(oTarget)
                    elif (tmp == 13):
                        tiTarget = com_sdtk_table_StandardTableInfo.instance()
                        if Std.isOfType(oTarget,com_sdtk_std_Writer):
                            writer = com_sdtk_table_TableWriter.createStandardTableWriterForWriter(oTarget)
                        else:
                            writer = com_sdtk_table_TableWriter.createStandardTableWriterForElement(oTarget)
                    elif (tmp == 14):
                        writer = com_sdtk_table_Array2DWriter.writeToExpandableArrayI(oTarget)
                    elif (tmp == 18):
                        pass
                    elif (tmp == 19):
                        diTarget = com_sdtk_table_RAWInfo.instance()
                    elif (tmp == 20):
                        diTarget = com_sdtk_table_TeXInfo.instance()
                    else:
                        pass
                if (diTarget is not None):
                    dwWriter = com_sdtk_table_DelimitedWriter(diTarget,oTarget)
                    writer = dwWriter
                    if com_sdtk_table_ConverterStageStandard.getOption(outputOptions,"header",True):
                        dwWriter.noHeaderIncluded(False)
                    else:
                        dwWriter.noHeaderIncluded(True)
                elif (ciTarget is not None):
                    writer = com_sdtk_table_CodeWriter(ciTarget,oTarget)
        return writer

    @staticmethod
    def createReader(oSource,fSource,sFilterColumnsExclude,sFilterColumnsInclude,sFilterRowsExclude,sFilterRowsInclude,leftTrim,rightTrim,inputOptions):
        reader = None
        if (oSource is not None):
            if Std.isOfType(oSource,com_sdtk_table_DataTableReader):
                reader = oSource
            if (reader is None):
                sSource = None
                if (oSource == Std.string(oSource)):
                    sSource = "STRING"
                else:
                    sSource = Type.getClassName(Type.getClass(oSource)).upper()
                if (sSource == "STRINGBUF"):
                    sb = oSource
                    oSource = sb.b.getvalue()
                    sSource = "STRING"
                sSource1 = sSource
                _hx_local_0 = len(sSource1)
                if (_hx_local_0 == 5):
                    if (sSource1 == "ARRAY"):
                        if (fSource is None):
                            fSource = com_sdtk_table_Format.ARRAY
                elif (_hx_local_0 == 6):
                    if (sSource1 == "STRING"):
                        def _hx_local_2():
                            _hx_local_1 = oSource
                            if (Std.isOfType(_hx_local_1,str) or ((_hx_local_1 is None))):
                                _hx_local_1
                            else:
                                raise "Class cast error"
                            return _hx_local_1
                        sString = _hx_local_2()
                        _g = ("" if ((0 >= len(sString))) else sString[0])
                        if ((_g == ".") or ((_g == "#"))):
                            oSource = com_sdtk_table_ConverterStageStandard.getControl(oSource)
                        else:
                            tmp = None
                            tmp1 = None
                            tmp2 = None
                            startIndex = None
                            if (((sString.find("\n") if ((startIndex is None)) else HxString.indexOfImpl(sString,"\n",startIndex))) < 0):
                                startIndex = None
                                tmp2 = (((sString.find("\t") if ((startIndex is None)) else HxString.indexOfImpl(sString,"\t",startIndex))) >= 0)
                            else:
                                tmp2 = True
                            if (not tmp2):
                                startIndex = None
                                tmp1 = (((sString.find(",") if ((startIndex is None)) else HxString.indexOfImpl(sString,",",startIndex))) >= 0)
                            else:
                                tmp1 = True
                            if (not tmp1):
                                startIndex = None
                                tmp = (((sString.find("|") if ((startIndex is None)) else HxString.indexOfImpl(sString,"|",startIndex))) >= 0)
                            else:
                                tmp = True
                            if tmp:
                                oSource = com_sdtk_std_StringReader(sString)
                            elif (fSource != com_sdtk_table_Format.DB):
                                oSource = com_sdtk_std_FileReader(sString).convertToStringReader().switchToDroppingCharacters()
                else:
                    pass
                if (fSource is None):
                    if (com_sdtk_table_ConverterStageStandard.getControlType(oSource) == 0):
                        fSource = com_sdtk_table_Format.HTMLTable
                diSource = None
                ciSource = None
                tiSource = None
                fshSource = None
                kvhSource = None
                if (fSource is not None):
                    tmp = fSource.index
                    if (tmp == 0):
                        diSource = com_sdtk_table_CSVInfo.instance()
                    elif (tmp == 1):
                        diSource = com_sdtk_table_PSVInfo.instance()
                    elif (tmp == 2):
                        diSource = com_sdtk_table_TSVInfo.instance()
                    elif (tmp == 3):
                        fshSource = com_sdtk_table_CMDDirHandler.instance()
                        reader = com_sdtk_table_FileSystemReader.createCMDDirReader(oSource)
                    elif (tmp == 4):
                        kvhSource = com_sdtk_table_INIHandler.instance()
                        reader = com_sdtk_table_KeyValueReader.createINIReader(oSource)
                    elif (tmp == 5):
                        kvhSource = com_sdtk_table_JSONHandler.instance()
                        reader = com_sdtk_table_KeyValueReader.createJSONReader(oSource)
                    elif (tmp == 6):
                        kvhSource = com_sdtk_table_PropertiesHandler.instance()
                        reader = com_sdtk_table_KeyValueReader.createPropertiesReader(oSource)
                    elif (tmp == 7):
                        ciSource = com_sdtk_table_SQLSelectInfo.instance()
                    elif (tmp == 8):
                        ciSource = com_sdtk_table_HaxeInfoArrayOfMaps.instance()
                    elif (tmp == 9):
                        ciSource = com_sdtk_table_PythonInfoArrayOfMaps.instance()
                    elif (tmp == 10):
                        ciSource = com_sdtk_table_JavaInfoArrayOfMaps.instance()
                    elif (tmp == 11):
                        ciSource = com_sdtk_table_CSharpInfoArrayOfMaps.instance()
                    elif (tmp == 12):
                        kvhSource = com_sdtk_table_SplunkHandler.instance()
                        reader = com_sdtk_table_KeyValueReader.createSplunkReader(oSource)
                    elif (tmp == 13):
                        tiSource = com_sdtk_table_StandardTableInfo.instance()
                        reader = com_sdtk_table_TableReader.createStandardTableReader(oSource)
                    elif (tmp == 14):
                        reader = com_sdtk_table_Array2DReader.readWholeArrayI(oSource)
                    elif (tmp == 18):
                        if Std.isOfType(oSource,str):
                            sb = StringBuf()
                            reader = com_sdtk_table_DatabaseReaderOptions.parse(oSource,sb).queryForReader(sb.b.getvalue())
                        else:
                            reader = com_sdtk_table_DatabaseReader.read(oSource)
                    elif (tmp == 19):
                        diSource = com_sdtk_table_RAWInfo.instance()
                    else:
                        pass
                if (diSource is not None):
                    drReader = com_sdtk_table_DelimitedReader(diSource,oSource)
                    reader = drReader
                    if com_sdtk_table_ConverterStageStandard.getOption(inputOptions,"header",True):
                        drReader.noHeaderIncluded(False)
                    else:
                        drReader.noHeaderIncluded(True)
                    if com_sdtk_table_ConverterStageStandard.getOption(inputOptions,"textOnly",False):
                        drReader.alwaysString(True)
                    else:
                        drReader.alwaysString(False)
                else:
                    tmp = (ciSource is not None)
                if (leftTrim and rightTrim):
                    reader = com_sdtk_table_DataTableReaderTrim(reader)
                elif leftTrim:
                    reader = com_sdtk_table_DataTableReaderLeftTrim(reader)
                elif rightTrim:
                    reader = com_sdtk_table_DataTableReaderRightTrim(reader)
                if ((sFilterRowsInclude is not None) or ((sFilterRowsExclude is not None))):
                    fFilter = None
                    if (com_sdtk_table_ConverterStageStandard.isString(sFilterRowsInclude) or com_sdtk_table_ConverterStageStandard.isString(sFilterRowsExclude)):
                        if ((sFilterRowsInclude is not None) and ((sFilterRowsExclude is not None))):
                            fFilter = com_sdtk_std_Filter.parse(sFilterRowsInclude,False)
                            fFilter._hx_and(com_sdtk_std_Filter.parse(sFilterRowsExclude,True))
                        elif (sFilterRowsInclude is not None):
                            fFilter = com_sdtk_std_Filter.parse(sFilterRowsInclude,False)
                        else:
                            fFilter = com_sdtk_std_Filter.parse(sFilterRowsExclude,True)
                    else:
                        fFilter = com_sdtk_table_ConverterStageStandard.mergeFilters(sFilterRowsInclude,sFilterRowsExclude)
                    reader = com_sdtk_table_RowFilterDataTableReader(reader,fFilter)
            if ((sFilterColumnsInclude is not None) or ((sFilterColumnsExclude is not None))):
                fFilter = None
                if (com_sdtk_table_ConverterStageStandard.isString(sFilterColumnsInclude) or com_sdtk_table_ConverterStageStandard.isString(sFilterColumnsExclude)):
                    if ((sFilterColumnsInclude is not None) and ((sFilterColumnsExclude is not None))):
                        fFilter = com_sdtk_std_Filter.parse(sFilterColumnsInclude,False)
                        fFilter._hx_and(com_sdtk_std_Filter.parse(sFilterColumnsExclude,True))
                    elif (sFilterColumnsInclude is not None):
                        fFilter = com_sdtk_std_Filter.parse(sFilterColumnsInclude,False)
                    else:
                        fFilter = com_sdtk_std_Filter.parse(sFilterColumnsExclude,True)
                else:
                    if ((sFilterColumnsInclude is not None) and ((Reflect.field(sFilterColumnsInclude,"length") > 0))):
                        if (com_sdtk_table_ConverterStageStandard.isString(HxOverrides.arrayGet(sFilterColumnsInclude, 0)) or com_sdtk_table_ConverterStageStandard.isInt(HxOverrides.arrayGet(sFilterColumnsInclude, 0))):
                            fFilters = list()
                            sFilters = sFilterColumnsInclude
                            _g = 0
                            while (_g < len(sFilters)):
                                sFilter = (sFilters[_g] if _g >= 0 and _g < len(sFilters) else None)
                                _g = (_g + 1)
                                fFilter1 = com_sdtk_std_Filter.parse(sFilter,False)
                                fFilters.append(fFilter1)
                            sFilterColumnsInclude = fFilters
                    if ((sFilterColumnsExclude is not None) and ((Reflect.field(sFilterColumnsExclude,"length") > 0))):
                        if (com_sdtk_table_ConverterStageStandard.isString(HxOverrides.arrayGet(sFilterColumnsExclude, 0)) or com_sdtk_table_ConverterStageStandard.isInt(HxOverrides.arrayGet(sFilterColumnsExclude, 0))):
                            fFilters = list()
                            sFilters = sFilterColumnsExclude
                            _g = 0
                            while (_g < len(sFilters)):
                                sFilter = (sFilters[_g] if _g >= 0 and _g < len(sFilters) else None)
                                _g = (_g + 1)
                                fFilter1 = com_sdtk_std_Filter.parse(sFilter,True)
                                fFilters.append(fFilter1)
                    fFilter = com_sdtk_table_ConverterStageStandard.mergeFilters(sFilterColumnsInclude,sFilterColumnsExclude)
                reader = com_sdtk_table_ColumnFilterDataTableReader(reader,fFilter)
        return reader

    @staticmethod
    def getControl(sName):
        return None

    @staticmethod
    def getControlType(oControl):
        sTag = None
        if (sTag is None):
            return -1
        else:
            sTag1 = sTag
            _hx_local_0 = len(sTag1)
            if (_hx_local_0 == 4):
                if (sTag1 == "BODY"):
                    return 1
                elif (sTag1 == "HEAD"):
                    return 1
                elif (sTag1 == "HTML"):
                    return 1
                else:
                    return -1
            elif (_hx_local_0 == 5):
                if (sTag1 == "TABLE"):
                    return 0
                else:
                    return -1
            elif (_hx_local_0 == 3):
                if (sTag1 == "DIV"):
                    return 1
                else:
                    return -1
            elif (_hx_local_0 == 8):
                if (sTag1 == "DOCUMENT"):
                    return 1
                else:
                    return -1
            else:
                return -1


class com_sdtk_table_DataEntryReaderDecorator(com_sdtk_table_DataEntryReader):

    def __init__(self,reader):
        self._reader = None
        super().__init__()
        self._reader = reader

    def hasNext(self):
        return self._reader.hasNext()

    def next(self):
        return self._reader.next()

    def iterator(self):
        return self

    def name(self):
        return self._reader.name()

    def index(self):
        return self._reader.index()

    def value(self):
        return self._reader.value()

    def isAutoNamed(self):
        return self._reader.isAutoNamed()

    def isNameIndex(self):
        return self._reader.isNameIndex()

    def start(self):
        self._reader.start()

    def dispose(self):
        self._reader.dispose()


class com_sdtk_table_DataTableReaderIterable:

    def __init__(self,shared,f):
        self._shared = shared
        self._f = f

    def iterator(self):
        return com_sdtk_table_DataTableReaderIterator(self._shared,self._f)


class com_sdtk_table_DataTableReaderIterator:

    def __init__(self,shared,f):
        self._row = 0
        self._shared = shared
        self._f = f

    def hasNext(self):
        return False

    def next(self):
        self._shared.moveTo((self._row + 1))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._row
        _hx_local_0._row = (_hx_local_1 + 1)
        _hx_local_1
        return self._f()


class com_sdtk_table_DataTableReaderSharedIterator:

    def __init__(self,reader):
        self._dataByName = None
        self._dataByIndex = None
        self._row = 0
        self._reader = reader

    def moveTo(self,row = None):
        if (row != self._row):
            self._reader.moveTo(row)


class com_sdtk_table_DataTableReaderDecorator(com_sdtk_table_DataTableReader):

    def __init__(self,reader):
        self._reader = None
        super().__init__()
        self._reader = reader

    def hasNext(self):
        return self._reader.hasNext()

    def nextReuse(self,rowReader):
        return self._reader.nextReuse(rowReader)

    def next(self):
        return self._reader.next()

    def iterator(self):
        return self

    def name(self):
        return self._reader.name()

    def index(self):
        return self._reader.index()

    def value(self):
        return self._reader.value()

    def isAutoNamed(self):
        return self._reader.isAutoNamed()

    def isNameIndex(self):
        return self._reader.isNameIndex()

    def start(self):
        self._reader.start()

    def alwaysString(self,value = None):
        self._reader.alwaysString(value)
        return super().alwaysString(value)

    def dispose(self):
        self._reader.dispose()

    def headerRowNotIncluded(self):
        return self._reader.headerRowNotIncluded()

    def oneRowPerFile(self):
        return self._reader.oneRowPerFile()

    def reset(self):
        self._reader.reset()

    def getColumns(self):
        return self._reader.getColumns()


class com_sdtk_table_DataTableReaderTrimAbstract(com_sdtk_table_DataTableReaderDecorator):

    def __init__(self,reader):
        super().__init__(reader)

    def rowReaderInstance(self,reader):
        return None

    def nextReuse(self,rowReader):
        if (rowReader is None):
            rowReader = self.rowReaderInstance(self._reader.next())
        else:
            rr = rowReader
            rr.reuse(rr.reader())
        return rowReader

    def next(self):
        return self.nextReuse(None)

    def value(self):
        return self._value


class com_sdtk_table_DataTableReaderLeftTrim(com_sdtk_table_DataTableReaderTrimAbstract):

    def __init__(self,reader):
        super().__init__(reader)

    def rowReaderInstance(self,reader):
        return com_sdtk_table_DataTableRowReaderLeftTrim(reader)


class com_sdtk_table_DataTableRowReaderDecorator(com_sdtk_table_DataTableRowReader):

    def __init__(self,reader):
        self._reader = None
        super().__init__()
        self.reuse(reader)

    def reuse(self,reader):
        self._reader = reader
        self._index = -1
        self._started = False
        self._value = None

    def reader(self):
        return self._reader

    def hasNext(self):
        return self._reader.hasNext()

    def next(self):
        return self._reader.next()

    def iterator(self):
        return self

    def name(self):
        return self._reader.name()

    def index(self):
        return self._reader.index()

    def value(self):
        return self._reader.value()

    def isAutoNamed(self):
        return self._reader.isAutoNamed()

    def isNameIndex(self):
        return self._reader.isNameIndex()

    def start(self):
        self._reader.start()

    def alwaysString(self,value = None):
        self._reader.alwaysString(value)
        return super().alwaysString(value)

    def dispose(self):
        self._reader.dispose()


class com_sdtk_table_DataTableRowReaderTrimAbstract(com_sdtk_table_DataTableRowReaderDecorator):

    def __init__(self,reader):
        super().__init__(reader)

    def trimI(self,value):
        return None

    def trim(self,value):
        if Std.isOfType(value,str):
            return self.trimI(Std.string(value))
        else:
            return value

    def next(self):
        self._value = self.trim(self._reader.next())
        return self._value

    def value(self):
        return self._value


class com_sdtk_table_DataTableRowReaderLeftTrim(com_sdtk_table_DataTableRowReaderTrimAbstract):

    def __init__(self,reader):
        super().__init__(reader)

    def trimI(self,value):
        return StringTools.ltrim(value)


class com_sdtk_table_DataTableReaderRightTrim(com_sdtk_table_DataTableReaderTrimAbstract):

    def __init__(self,reader):
        super().__init__(reader)

    def rowReaderInstance(self,reader):
        return com_sdtk_table_DataTableRowReaderRightTrim(reader)


class com_sdtk_table_DataTableRowReaderRightTrim(com_sdtk_table_DataTableRowReaderTrimAbstract):

    def __init__(self,reader):
        super().__init__(reader)

    def trimI(self,value):
        return StringTools.rtrim(value)


class com_sdtk_table_DataTableReaderTrim(com_sdtk_table_DataTableReaderTrimAbstract):

    def __init__(self,reader):
        super().__init__(reader)

    def rowReaderInstance(self,reader):
        return com_sdtk_table_DataTableRowReaderTrim(reader)


class com_sdtk_table_DataTableRowReaderTrim(com_sdtk_table_DataTableRowReaderTrimAbstract):

    def __init__(self,reader):
        super().__init__(reader)

    def trimI(self,value):
        return StringTools.trim(value)


class com_sdtk_table_DataTableRowReaderAdapter(com_sdtk_table_DataTableReader):

    def __init__(self,rowReader,includeName,includeIndex,includeRawIndex,includeValue):
        self._includeValue = None
        self._includeRawIndex = None
        self._includeIndex = None
        self._includeName = None
        self._rowReader = None
        super().__init__()
        self._rowReader = rowReader
        self._includeName = includeName
        self._includeIndex = includeIndex
        self._includeRawIndex = includeRawIndex
        self._includeValue = includeValue

    def hasNext(self):
        return self._rowReader.hasNext()

    def nextReuse(self,rowReader):
        if (rowReader is None):
            rr = com_sdtk_table_DataTableRowReaderAdapterRowReader()
            rowReader = rr
            rr.reuseWithOptions(self._rowReader,self._includeName,self._includeIndex,self._includeRawIndex,self._includeValue)
        else:
            rr = rowReader
            rr.reuse(self._rowReader)
        self._value = rowReader
        return rowReader

    def next(self):
        return self.nextReuse(None)

    def iterator(self):
        return self

    def reset(self):
        super().reset()


class com_sdtk_table_DataTableRowReaderAdapterRowReader(com_sdtk_table_DataTableRowReader):

    def __init__(self):
        self._totalElements = None
        self._valueIndex = None
        self._rawIndexIndex = None
        self._indexIndex = None
        self._nameIndex = None
        self._wrappedValue = None
        self._wrappedRawIndex = None
        self._wrappedIndex = None
        self._wrappedName = None
        self._element = None
        super().__init__()

    def reuseWithOptions(self,wrappedRowReader,includeName,includeIndex,includeRawIndex,includeValue):
        self.reuse(wrappedRowReader)
        baseIndex = 0
        self._nameIndex = -1
        self._indexIndex = -1
        self._rawIndexIndex = -1
        self._valueIndex = -1
        if includeName:
            tmp = baseIndex
            baseIndex = (baseIndex + 1)
            self._nameIndex = tmp
        if includeIndex:
            tmp = baseIndex
            baseIndex = (baseIndex + 1)
            self._indexIndex = tmp
        if includeRawIndex:
            tmp = baseIndex
            baseIndex = (baseIndex + 1)
            self._rawIndexIndex = tmp
        if includeValue:
            tmp = baseIndex
            baseIndex = (baseIndex + 1)
            self._valueIndex = tmp
        self._totalElements = baseIndex

    def reuse(self,wrappedRowReader):
        self._element = 0
        self._wrappedName = wrappedRowReader.name()
        self._wrappedIndex = wrappedRowReader.index()
        self._wrappedRawIndex = wrappedRowReader.rawIndex()
        self._wrappedValue = wrappedRowReader.value()

    def hasNext(self):
        return (self._element < self._totalElements)

    def next(self):
        value = None
        name = None
        if (self._element >= self._totalElements):
            return None
        elif (self._element == self._nameIndex):
            value = self._wrappedName
            name = "name"
        elif (self._element == self._indexIndex):
            value = self._wrappedIndex
            name = "index"
        elif (self._element == self._rawIndexIndex):
            value = self._wrappedRawIndex
            name = "rawIndex"
        elif (self._element == self._valueIndex):
            value = self._wrappedValue
            name = "value"
        self.incrementTo(name,value,self._element)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._element
        _hx_local_0._element = (_hx_local_1 + 1)
        _hx_local_1
        return self._value

    def iterator(self):
        return self

    def dispose(self):
        if (self._wrappedName is not None):
            super().dispose()
            self._wrappedName = None
            self._wrappedValue = None


class com_sdtk_table_DatabaseReader(com_sdtk_table_DataTableReader):

    def __init__(self,cur):
        self._columns = None
        self._row = None
        self._cur = None
        self._replaceNextRow = False
        self._hold = None
        self._reading = False
        self._done = False
        super().__init__()
        self._cur = cur
        self.checkColumns()
        self.finalPrep()

    def columns(self):
        return len(self._columns)

    def nextRow(self):
        self._row = self._cur.__next__()
        return (self._row is not None)

    def checkColumns(self):
        if (self._columns is None):
            self._columns = list()
            it = self._cur.description
            description = HxOverrides.iterator(it)
            while description.hasNext():
                description1 = description.next()
                _this = self._columns
                x = description1[0]
                _this.append(x)

    def finalPrep(self):
        self._cur = self._cur.__iter__()

    def columnName(self,i):
        return (self._columns[i] if i >= 0 and i < len(self._columns) else None)

    def readColumn(self,i):
        self._reading = False
        return self._row[i]

    def hasNext(self):
        if (not self._reading):
            if self.nextRow():
                self._reading = True
            else:
                self._reading = False
        return self._reading

    def nextReuse(self,rowReader):
        if (rowReader is None):
            return com_sdtk_table_DatabaseRowReader(self)
        else:
            rr = rowReader
            rr.reuse(self)
            return rr

    def next(self):
        return self.nextReuse(None)

    def reset(self):
        pass

    def dispose(self):
        super().dispose()
        self._hold = None

    def hold(self,o):
        self._hold = o

    @staticmethod
    def read(o):
        return com_sdtk_table_DatabaseReader(o)


class com_sdtk_table_DatabaseReaderLoginOptions:

    def __init__(self,values):
        self._cancelClose = False
        self._values = values

    def user(self,v):
        self._values.h["user"] = v
        return self

    def password(self,v):
        self._values.h["password"] = v
        return self

    def account(self,v):
        self._values.h["account"] = v
        return self

    def warehouse(self,v):
        self._values.h["warehouse"] = v
        return self

    def role(self,v):
        self._values.h["role"] = v
        return self

    def database(self,v):
        self._values.h["database"] = v
        return self

    def schema(self,v):
        self._values.h["schema"] = v
        return self

    def host(self,v):
        self._values.h["host"] = v
        return self

    def file(self,v):
        self._values.h["file"] = v
        return self

    def driver(self,v):
        self._values.h["driver"] = v
        return self

    def size(self,v):
        self._values.h["size"] = v
        return self

    def connect(self,callback = None):
        connector = StringTools.trim(self._values.h.get("connector",None)).lower()
        con = None
        connector1 = connector
        _hx_local_0 = len(connector1)
        if (_hx_local_0 == 9):
            if (connector1 == "snowflake"):
                import snowflake.connector as connector
                con = connector.connect(user=self._values.h.get("user",None), password=self._values.h.get("password",None), database=self._values.h.get("database",None), role=self._values.h.get("role",None), account=self._values.h.get("account",None), warehouse=self._values.h.get("warehouse",None), schema=self._values.h.get("schema",None))
            elif (connector1 == "sqlserver"):
                import pyodbc
                if (self._values.h.get("driver",None) is None):
                    self._values.h["driver"] = "ODBC Driver 18 for SQL Server"
                tmp = self._values.h.get("driver",None)
                connectString = ("null" if ((tmp is None)) else Std.string(tmp))
                tmp = self._values.h.get("host",None)
                connectString1 = ("null" if ((tmp is None)) else Std.string(tmp))
                tmp = self._values.h.get("database",None)
                connectString2 = ("null" if ((tmp is None)) else Std.string(tmp))
                tmp = self._values.h.get("user",None)
                connectString3 = ("null" if ((tmp is None)) else Std.string(tmp))
                tmp = self._values.h.get("password",None)
                connectString4 = ((((((((("DRIVER={" + ("null" if connectString is None else connectString)) + "};SERVER=") + ("null" if connectString1 is None else connectString1)) + ";DATABASE=") + ("null" if connectString2 is None else connectString2)) + ";UID=") + ("null" if connectString3 is None else connectString3)) + ";PWD=") + HxOverrides.stringOrNull((("null" if ((tmp is None)) else Std.string(tmp)))))
                con = pyodbc.connect(connectString4)
        elif (_hx_local_0 == 5):
            if (connector1 == "derby"):
                pass
            elif (connector1 == "mysql"):
                import mysql.connector
                con = mysql.connector.connect(user=self._values.h.get("user",None), password=self._values.h.get("password",None), database=self._values.h.get("database",None), host=self._values.h.get("host",None))
        elif (_hx_local_0 == 7):
            if (connector1 == "dataset"):
                pass
        elif (_hx_local_0 == 8):
            if (connector1 == "postgres"):
                import psycopg2
                tmp = self._values.h.get("host",None)
                connectString = ("null" if ((tmp is None)) else Std.string(tmp))
                tmp = self._values.h.get("database",None)
                connectString1 = ("null" if ((tmp is None)) else Std.string(tmp))
                tmp = self._values.h.get("user",None)
                connectString2 = ("null" if ((tmp is None)) else Std.string(tmp))
                tmp = self._values.h.get("password",None)
                connectString3 = (((((((("host='" + ("null" if connectString is None else connectString)) + "' dbname='") + ("null" if connectString1 is None else connectString1)) + "' user='") + ("null" if connectString2 is None else connectString2)) + "' password='") + HxOverrides.stringOrNull((("null" if ((tmp is None)) else Std.string(tmp))))) + "'")
                con = psycopg2.connect(connectString3)
        elif (_hx_local_0 == 6):
            if (connector1 == "oracle"):
                import cx_Oracle
                tmp = self._values.h.get("user",None)
                connectString = ("null" if ((tmp is None)) else Std.string(tmp))
                tmp = self._values.h.get("password",None)
                connectString1 = ("null" if ((tmp is None)) else Std.string(tmp))
                tmp = self._values.h.get("host",None)
                connectString2 = ("null" if ((tmp is None)) else Std.string(tmp))
                tmp = self._values.h.get("database",None)
                connectString3 = ((((((("null" if connectString is None else connectString) + "/") + ("null" if connectString1 is None else connectString1)) + "@") + ("null" if connectString2 is None else connectString2)) + "/") + HxOverrides.stringOrNull((("null" if ((tmp is None)) else Std.string(tmp)))))
                con = cx_Oracle.connect(connectString3)
            elif (connector1 == "sqlite"):
                import sqlite3
                con = sqlite3.connect(self._values.h.get("file",None))
        else:
            pass
        if (callback is not None):
            cur = con.cursor()
            try:
                callback(cur)
            except BaseException as _g:
                None
            if (not self._cancelClose):
                cur.close()
                con.close()
            else:
                v = cur
                self._values.h["cur"] = v
                v = con
                self._values.h["con"] = v
            return None
        else:
            v = con
            self._values.h["con"] = v
            return con

    def test(self):
        r = False
        def _hx_local_0(o):
            nonlocal r
            r = True
        try:
            self.connect(_hx_local_0)
        except BaseException as _g:
            None
        return r

    def cancelClose(self):
        self._cancelClose = True

    def query(self,query,params = None,callback = None):
        _gthis = self
        connector = StringTools.trim(self._values.h.get("connector",None)).lower()
        r = None
        if (params is not None):
            param = params.iterator()
            while param.hasNext():
                param1 = param.next()
                value = params.h.get(param1,None)
                if (value is None):
                    value = "null"
                elif (Std.isOfType(value,Int) or Std.isOfType(value,Float)):
                    value = ("" + Std.string(value))
                elif Std.isOfType(value,Bool):
                    d = value
                    value = (("DATETIME('" + HxOverrides.stringOrNull(d.toString())) + "')")
                elif Std.isOfType(value,Date):
                    b = value
                    value = ("true" if value else "false")
                else:
                    value = StringTools.replace(value,"'","''")
                    value = (("'" + Std.string(value)) + "'")
                query = StringTools.replace(query,("@" + ("null" if param1 is None else param1)),value)
                query = StringTools.replace(query,(":" + ("null" if param1 is None else param1)),value)
                query = StringTools.replace(query,(("(" + ("null" if param1 is None else param1)) + ")"),value)
        def _hx_local_0():
            return _gthis._cancelClose
        inProgress = com_sdtk_table_DRLOQuery(query,params,callback,connector,r,self.cancelClose,_hx_local_0)
        self.connect(inProgress.query)
        r = inProgress._r
        if (callback is not None):
            return None
        else:
            return r

    def queryForReader(self,query,params = None,callback = None):
        _gthis = self
        r = None
        def _hx_local_0(cur):
            nonlocal r
            r = com_sdtk_table_DatabaseReader.read(cur)
            r.hold(_gthis._values)
            if (callback is not None):
                try:
                    callback(r)
                except BaseException as _g:
                    None
                r.dispose()
            else:
                _gthis.cancelClose()
        self.query(query,params,_hx_local_0)
        if (callback is not None):
            return None
        else:
            return r


class com_sdtk_table_DRLOQuery:

    def __init__(self,query,params,callback,connector,r,cancelClose,isCancelClose):
        self._query = query
        self._params = params
        self._callback = callback
        self._connector = connector
        self._r = r
        self._cancelClose = cancelClose
        self._isCancelClose = isCancelClose

    def query(self,cur):
        cur.execute(self._query)
        self._r = cur
        if (self._callback is not None):
            self._callback(self._r)
        else:
            self._cancelClose()


class com_sdtk_table_DatabaseReaderOptions:

    def __init__(self):
        self._values = haxe_ds_StringMap()

    def mysql(self):
        return self.database("mysql")

    def snowflake(self):
        return self.database("snowflake")

    def oracle(self):
        return self.database("oracle")

    def sqlite(self):
        return self.database("sqlite")

    def derby(self):
        return self.database("derby")

    def sqlServer(self):
        return self.database("sqlserver")

    def postgres(self):
        return self.database("postgres")

    def dataset(self):
        return self.database("dataset")

    def database(self,s):
        self._values.h["connector"] = s
        return com_sdtk_table_DatabaseReaderLoginOptions(self._values)

    @staticmethod
    def parse(s,query = None):
        o1 = com_sdtk_table_DatabaseReaderOptions()
        o2 = None
        values = haxe_ds_StringMap()
        _g = 0
        _g1 = s.split(";")
        while (_g < len(_g1)):
            s2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            s3 = s2.split("=")
            k = StringTools.trim((s3[0] if 0 < len(s3) else None)).lower()
            v = StringTools.trim((s3[1] if 1 < len(s3) else None))
            values.h[k] = v
        k = values.keys()
        while k.hasNext():
            k1 = k.next()
            if (k1 == "dbtype"):
                _g = values.h.get(k1,None).lower()
                _hx_local_1 = len(_g)
                if (_hx_local_1 == 9):
                    if (_g == "snowflake"):
                        o2 = o1.snowflake()
                    elif (_g == "sqlserver"):
                        o2 = o1.sqlServer()
                elif (_hx_local_1 == 5):
                    if (_g == "derby"):
                        o2 = o1.derby()
                    elif (_g == "mysql"):
                        o2 = o1.mysql()
                elif (_hx_local_1 == 7):
                    if (_g == "dataset"):
                        o2 = o1.dataset()
                elif (_hx_local_1 == 8):
                    if (_g == "postgres"):
                        o2 = o1.postgres()
                elif (_hx_local_1 == 6):
                    if (_g == "oracle"):
                        o2 = o1.oracle()
                    elif (_g == "sqlite"):
                        o2 = o1.sqlite()
                else:
                    pass
        k = values.keys()
        while k.hasNext():
            k1 = k.next()
            v = values.h.get(k1,None)
            k2 = k1
            _hx_local_2 = len(k2)
            if (_hx_local_2 == 9):
                if (k2 == "warehouse"):
                    o2 = o2.warehouse(v)
            elif (_hx_local_2 == 4):
                if (k2 == "file"):
                    o2 = o2.file(v)
                elif (k2 == "host"):
                    o2 = o2.host(v)
                elif (k2 == "role"):
                    o2 = o2.role(v)
                elif (k2 == "user"):
                    o2 = o2.user(v)
            elif (_hx_local_2 == 5):
                if (k2 == "query"):
                    s = Std.string(v)
                    query.b.write(s)
            elif (_hx_local_2 == 7):
                if (k2 == "account"):
                    o2 = o2.account(v)
            elif (_hx_local_2 == 8):
                if (k2 == "database"):
                    o2 = o2.database(v)
                elif (k2 == "password"):
                    o2 = o2.password(v)
            elif (_hx_local_2 == 6):
                if (k2 == "driver"):
                    o2 = o2.driver(v)
                elif (k2 == "schema"):
                    o2 = o2.schema(v)
            else:
                pass
        return o2


class com_sdtk_table_DatabaseRowReader(com_sdtk_table_DataTableRowReader):

    def __init__(self,reader):
        self._reader = None
        super().__init__()
        self.reuse(reader)

    def reuse(self,reader):
        self._reader = reader
        self._index = -1

    def hasNext(self):
        return (self.index() < ((self._reader.columns() - 1)))

    def startI(self):
        pass

    def next(self):
        self.incrementTo(self._reader.columnName((self.index() + 1)),self._reader.readColumn((self.index() + 1)),-1)
        return self.value()

    def dispose(self):
        self._reader = None


class com_sdtk_table_DelimitedInfoCustom:

    def fileStart(self):
        return self._fileStart

    def fileEnd(self):
        return self._fileEnd

    def delimiter(self):
        return self._delimiter

    def rowDelimiter(self):
        return self._boolStart

    def boolStart(self):
        return self._boolStart

    def boolEnd(self):
        return self._boolEnd

    def stringStart(self):
        return self._stringStart

    def stringEnd(self):
        return self._stringEnd

    def intStart(self):
        return self._intStart

    def intEnd(self):
        return self._intEnd

    def floatStart(self):
        return self._floatStart

    def floatEnd(self):
        return self._floatEnd

    def replacements(self):
        return self._replacements

    def replacementIndicator(self):
        return None

    def widthMinimum(self):
        return -1

    def widthMaximum(self):
        return -1


class com_sdtk_table_DelimitedReader(com_sdtk_table_DataTableReader):

    def __init__(self,diInfo,rReader):
        self._reader = None
        self._noHeaderIncluded = False
        self._header = None
        self._done = False
        self._info = None
        super().__init__()
        self._info = diInfo
        self._reader = rReader

    def startI(self):
        self._reader.start()

    def flip(self):
        return com_sdtk_table_DelimitedWriter(self._info,self._reader.flip())

    def dispose(self):
        if (not self._done):
            self._done = True
            self._reader.dispose()

    def hasNext(self):
        return self._reader.hasNext()

    def nextReuse(self,rowReader):
        while (self._reader.hasNext() and ((self._reader.peek() == self._info.rowDelimiter()))):
            self._reader.next()
        if (not self._reader.hasNext()):
            rowReader = None
        elif (self._header is None):
            self._header = list()
            if (rowReader is None):
                rowReader = com_sdtk_table_DelimitedRowReader(self._info,self._reader,self._header,(not self._noHeaderIncluded))
            else:
                rr = rowReader
                rr.reuse(self._info,self._reader,self._header,True)
        elif (rowReader is None):
            rowReader = com_sdtk_table_DelimitedRowReader(self._info,self._reader,self._header,False)
        else:
            rr = rowReader
            rr.reuse(self._info,self._reader,self._header,False)
        self.incrementTo(None,rowReader,self._reader.rawIndex())
        return rowReader

    def next(self):
        return self.nextReuse(None)

    def headerRowNotIncluded(self):
        return self._noHeaderIncluded

    def noHeaderIncluded(self,noHeader):
        self._noHeaderIncluded = noHeader

    def allowNoHeaderInclude(self):
        return True

    def skipRows(self,rows):
        noHeaderIncluded = self._noHeaderIncluded
        reader = None
        while (rows > 0):
            reader = self.nextReuse(reader)
            rows = (rows - 1)
        self._noHeaderIncluded = noHeaderIncluded

    def reset(self):
        self._reader.reset()
        self._header = None
        self._done = False

    def getColumns(self):
        return self._header

    @staticmethod
    def createRawReader(reader):
        return com_sdtk_table_DelimitedReader(com_sdtk_table_RAWInfo.instance(),reader)

    @staticmethod
    def createCSVReader(reader):
        return com_sdtk_table_DelimitedReader(com_sdtk_table_CSVInfo.instance(),reader)

    @staticmethod
    def createTSVReader(reader):
        return com_sdtk_table_DelimitedReader(com_sdtk_table_TSVInfo.instance(),reader)

    @staticmethod
    def createPSVReader(reader):
        return com_sdtk_table_DelimitedReader(com_sdtk_table_PSVInfo.instance(),reader)


class com_sdtk_table_DelimitedRowReader(com_sdtk_table_DataTableRowReader):

    def __init__(self,diInfo,rReader,sHeader,bInitHeader):
        self._initHeader = None
        self._currentRawIndex = None
        self._current = None
        self._reader = None
        self._header = None
        self._done = False
        self._info = None
        super().__init__()
        self.reuse(diInfo,rReader,sHeader,bInitHeader)

    def reuse(self,diInfo,rReader,sHeader,bInitHeader):
        self._info = diInfo
        self._reader = rReader
        self._header = sHeader
        self._initHeader = bInitHeader
        self._done = False
        self._index = -1
        self._rawIndex = -1
        self._started = False
        self._value = None

    def check(self):
        if ((self._reader is not None) and ((self._done != True))):
            com_sdtk_table_DelimitedRowReader._watch.start()
            sChar = ""
            iGettingValue = -1
            iGot = -1
            iCount = 0
            sValue = StringBuf()
            self._currentRawIndex = self._reader.rawIndex()
            if (not self._reader.hasNext()):
                self._current = None
                self._done = True
                return
            rowDelimiter = self._info.rowDelimiter()
            delimiter = self._info.delimiter()
            hasNext = self._reader.hasNext()
            minimum = self._info.widthMinimum()
            maximum = self._info.widthMaximum()
            replacementIndicator = self._info.replacementIndicator()
            replacements = self._info.replacements()
            while ((hasNext and (((iGettingValue >= 0) or (((sChar != rowDelimiter) and ((sChar != delimiter))))))) and (not self._done)):
                bSkip = False
                bNoNext = False
                bEndValue = False
                sChar = self._reader.peek()
                if (iGettingValue >= 0):
                    if (iGettingValue == self.isEnd(sChar)):
                        bEndValue = True
                        bSkip = True
                elif (sChar == delimiter):
                    bSkip = True
                elif (sChar == rowDelimiter):
                    bSkip = True
                    self._done = True
                elif (sChar == "\r"):
                    bSkip = True
                elif (iCount == 0):
                    iGettingValue = self.isStart(sChar)
                    if (iGettingValue >= 0):
                        iGot = iGettingValue
                        bSkip = True
                elif ((iCount >= maximum) and ((maximum > 0))):
                    bSkip = True
                    bNoNext = True
                iCount = (iCount + 1)
                if (not bNoNext):
                    self._reader.next()
                if ((replacementIndicator is None) or ((replacementIndicator == sChar))):
                    if ((replacements is not None) and ((len(replacements) > 0))):
                        checkReplace = (("null" if sChar is None else sChar) + HxOverrides.stringOrNull(self._reader.peek()))
                        replaceI = (len(replacements) - 2)
                        while (replaceI >= 0):
                            if ((replacements[replaceI] if replaceI >= 0 and replaceI < len(replacements) else None) == checkReplace):
                                sChar = python_internal_ArrayImpl._get(replacements, (replaceI + 1))
                                bSkip = False
                                bEndValue = False
                                self._reader.next()
                                break
                            replaceI = (replaceI - 2)
                hasNext = self._reader.hasNext()
                if (not bSkip):
                    s = Std.string(sChar)
                    sValue.b.write(s)
                if bEndValue:
                    iGettingValue = -1
            com_sdtk_table_DelimitedRowReader._watch.end()
            if (sValue.get_length() <= 0):
                self._current = None
            else:
                self._current = self.fromStringToType(sValue.b.getvalue())
        else:
            self._current = None

    def hasNext(self):
        if (self._current is None):
            return (not self._done)
        else:
            return True

    def isStart(self,sChar):
        if (self._info.boolStart() == sChar):
            return 0
        elif (self._info.floatStart() == sChar):
            return 1
        elif (self._info.intStart() == sChar):
            return 2
        elif (self._info.stringStart() == sChar):
            return 3
        else:
            return -1

    def isEnd(self,sChar):
        if (self._info.boolEnd() == sChar):
            return 0
        elif (self._info.floatEnd() == sChar):
            return 1
        elif (self._info.intEnd() == sChar):
            return 2
        elif (self._info.stringEnd() == sChar):
            return 3
        else:
            return -1

    def startI(self):
        self.check()

    def next(self):
        sCurrent = self._current
        iRawIndex = self._currentRawIndex
        self.check()
        if (self._header is None):
            self.incrementTo(None,sCurrent,iRawIndex)
        else:
            if self._initHeader:
                _this = self._header
                _this.append(sCurrent)
            self.incrementTo(python_internal_ArrayImpl._get(self._header, (self.index() + 1)),sCurrent,iRawIndex)
        return sCurrent

    def dispose(self):
        self._current = None
        self._info = None
        self._reader = None
        self._header = None


class com_sdtk_table_DelimitedRowWriter(com_sdtk_table_DataTableRowWriter):

    def __init__(self,info,writer):
        self._writer = None
        self._done = False
        self._written = False
        self._info = None
        super().__init__()
        self.reuse(info,writer)

    def reuse(self,info,writer):
        self._done = False
        if self._written:
            self._writer.write(self._info.rowDelimiter())
        self._written = False
        self._info = info
        self._writer = writer

    def write(self,data,name,index):
        com_sdtk_table_DelimitedRowWriter._watch.start()
        buf = StringBuf()
        if (not self._done):
            if self._written:
                s = Std.string(self._info.delimiter())
                buf.b.write(s)
            else:
                self._written = True
            self.writeValue(data,buf)
            self._writer.write(buf.b.getvalue())
        com_sdtk_table_DelimitedRowWriter._watch.end()

    def replacement(self,data):
        replacements = self._info.replacements()
        if ((replacements is not None) and ((len(replacements) > 0))):
            replaceI = 1
            while (replaceI < len(replacements)):
                data = StringTools.replace(data,(replacements[replaceI] if replaceI >= 0 and replaceI < len(replacements) else None),python_internal_ArrayImpl._get(replacements, (replaceI - 1)))
                replaceI = (replaceI + 2)
        return data

    def writeValue(self,data,buf):
        if (data is not None):
            t = Type.typeof(data)
            tmp = t.index
            if (tmp == 1):
                s = Std.string(self._info.intStart())
                buf.b.write(s)
                s = Std.string(Std.string(data))
                buf.b.write(s)
                s = Std.string(self._info.intEnd())
                buf.b.write(s)
            elif (tmp == 2):
                s = Std.string(self._info.floatStart())
                buf.b.write(s)
                s = Std.string(Std.string(data))
                buf.b.write(s)
                s = Std.string(self._info.floatEnd())
                buf.b.write(s)
            elif (tmp == 3):
                s = Std.string(self._info.boolStart())
                buf.b.write(s)
                s = Std.string(Std.string(data))
                buf.b.write(s)
                s = Std.string(self._info.boolEnd())
                buf.b.write(s)
            else:
                other = t
                s = Std.string(data)
                startIndex = None
                if (((s.find("datetime.datetime(") if ((startIndex is None)) else HxString.indexOfImpl(s,"datetime.datetime(",startIndex))) == 0):
                    s = data.strftime("%m/%d/%Y %H:%M:%S")
                s1 = Std.string(self._info.stringStart())
                buf.b.write(s1)
                s1 = Std.string(self.replacement(s))
                buf.b.write(s1)
                s = Std.string(self._info.stringEnd())
                buf.b.write(s)

    def dispose(self):
        if (not self._done):
            self._writer.write(self._info.rowDelimiter())
            self._writer.flush()
            self._done = True
            self._written = False


class com_sdtk_table_DelimitedWriter(com_sdtk_table_DataTableWriter):

    def __init__(self,diInfo,wWriter):
        self._writer = None
        self._noHeaderIncluded = False
        self._done = False
        self._info = None
        super().__init__()
        self._info = diInfo
        self._writer = wWriter

    def flip(self):
        return com_sdtk_table_DelimitedReader(self._info,self._writer.flip())

    def start(self):
        self._writer.start()
        self._writer.write(self._info.fileStart())

    def noHeaderIncluded(self,noHeader):
        self._noHeaderIncluded = noHeader

    def writeStartI(self,name,index,rowWriter):
        if (rowWriter is None):
            rowWriter = com_sdtk_table_DelimitedRowWriter(self._info,self._writer)
        else:
            rw = rowWriter
            rw.reuse(self._info,self._writer)
        return rowWriter

    def dispose(self):
        if (not self._done):
            self._writer.write(self._info.fileEnd())
            self._done = True
            self._writer.dispose()

    def writeHeaderFirst(self):
        return (not self._noHeaderIncluded)

    def writeRowNameFirst(self):
        return True

    @staticmethod
    def createTeXWriter(writer):
        return com_sdtk_table_DelimitedWriter(com_sdtk_table_TeXInfo.instance(),writer)

    @staticmethod
    def createRawWriter(writer):
        return com_sdtk_table_DelimitedWriter(com_sdtk_table_RAWInfo.instance(),writer)

    @staticmethod
    def createCSVWriter(writer):
        return com_sdtk_table_DelimitedWriter(com_sdtk_table_CSVInfo.instance(),writer)

    @staticmethod
    def createTSVWriter(writer):
        return com_sdtk_table_DelimitedWriter(com_sdtk_table_TSVInfo.instance(),writer)

    @staticmethod
    def createPSVWriter(writer):
        return com_sdtk_table_DelimitedWriter(com_sdtk_table_PSVInfo.instance(),writer)


class com_sdtk_table_DirectoryInfo:

    def __init__(self):
        self._name = None
        self._path = None
        self._serial = None
        self._label = None
        self._count = 0
        self._size = 0
        self._drive = None

    def setDrive(self,sDrive):
        self._drive = sDrive

    def setLabel(self,sLabel):
        self._label = sLabel

    def setSerial(self,sSerial):
        self._serial = sSerial

    def setFullPath(self,sPath):
        self._path = sPath

    def setName(self,sName):
        self._name = sName

    def addFile(self,fiInfo):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._size
        _hx_local_0._size = (_hx_local_1 + fiInfo.getSize())
        _hx_local_0._size
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._count
        _hx_local_2._count = (_hx_local_3 + 1)
        _hx_local_3

    def getDrive(self):
        return self._drive

    def getLabel(self):
        return self._label

    def getSerial(self):
        return self._serial

    def getFullPath(self):
        return self._path

    def getName(self):
        return self._name

    def getCount(self):
        return self._count

    def getSize(self):
        return self._size


class com_sdtk_table_FileInfo:

    def __init__(self):
        self._date = None
        self._time = 0
        self._type = 0
        self._size = 0
        self._owner = None
        self._shortName = None
        self._trueName = None
        self._name = None
        self._parent = None

    def getDirectoryInfo(self):
        return self._parent

    def getDirectory(self):
        return self._parent.getFullPath()

    def setDirectory(self,sDirectory):
        self._parent.setFullPath(sDirectory)

    def setDirectoryInfo(self,diParent):
        self._parent = diParent

    def setDrive(self,sDrive):
        self._parent.setDrive(sDrive)

    def setLabel(self,sLabel):
        self._parent.setLabel(sLabel)

    def setSerial(self,sSerial):
        self._parent.setSerial(sSerial)

    def setFullPath(self,sPath):
        startIndex = None
        iEnd = None
        if (startIndex is None):
            iEnd = sPath.rfind("\\", 0, len(sPath))
        else:
            i = sPath.rfind("\\", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("\\"))) if ((i == -1)) else (i + 1))
            check = sPath.find("\\", startLeft, len(sPath))
            iEnd = (check if (((check > i) and ((check <= startIndex)))) else i)
        self._parent.setName(HxString.substr(sPath,iEnd,None))
        self._name = HxString.substr(sPath,(iEnd + 1),None)

    def setName(self,sName):
        self._name = sName

    def addFile(self,fiInfo):
        self._parent.addFile(fiInfo)

    def getDrive(self):
        return self.getDirectoryInfo().getDrive()

    def getLabel(self):
        return self.getDirectoryInfo().getLabel()

    def getSerial(self):
        return self.getDirectoryInfo().getSerial()

    def getFullPath(self):
        return ((Std.string(self.getDirectoryInfo().getFullPath) + "\\") + HxOverrides.stringOrNull(self.getName()))

    def getName(self):
        return self._name

    def getCount(self):
        return self.getDirectoryInfo().getCount()

    def getDate(self):
        return self._date

    def getTime(self):
        return self._time

    def getIsDirectory(self):
        return (((self._type & com_sdtk_table_FileInfo.IS_DIRECTORY)) == com_sdtk_table_FileInfo.IS_DIRECTORY)

    def getIsJunction(self):
        return (((self._type & com_sdtk_table_FileInfo.IS_JUNCTION)) == com_sdtk_table_FileInfo.IS_JUNCTION)

    def MergeDateTime(self):
        pass

    def setTrueName(self,sTrueName):
        self._trueName = sTrueName

    def getTrueName(self):
        return self._trueName

    def setShortName(self,sShortName):
        self._shortName = sShortName

    def getShortName(self):
        return self._shortName

    def setOwner(self,sOwner):
        self._owner = sOwner

    def getOwner(self):
        return self._owner

    def setDate(self,dDate):
        self._date = dDate
        self.MergeDateTime()

    def setTime(self,iTime):
        self._time = iTime
        self.MergeDateTime()

    def setSize(self,iSize):
        self._size = iSize

    def getSize(self):
        return self._size

    def setIsDirectory(self,bIsDirectory):
        self._type = ((self._type | com_sdtk_table_FileInfo.IS_DIRECTORY) if bIsDirectory else (self._type & ((-1 ^ com_sdtk_table_FileInfo.IS_DIRECTORY))))

    def setIsJunction(self,bIsJunction):
        self._type = ((self._type | com_sdtk_table_FileInfo.IS_JUNCTION) if bIsJunction else (self._type & ((-1 ^ com_sdtk_table_FileInfo.IS_JUNCTION))))


class com_sdtk_table_FileSystemReader(com_sdtk_table_DataTableReader):

    def __init__(self,fshHandler,rReader):
        self._current = None
        self._previous = None
        self._reader = None
        self._handler = None
        super().__init__()
        self._handler = fshHandler
        self._reader = rReader

    def check(self,reuse):
        if (reuse == False):
            self._current = com_sdtk_table_FileSystemRowReader(self._handler,self._reader,self._current)
        elif (self._previous is None):
            self.check(False)
        else:
            self._previous.reuse(self._handler,self._reader,self._current)
            self._current = self._previous

    def startI(self):
        self._reader.start()
        self.check(False)

    def dispose(self):
        if (self._reader is not None):
            self._reader.dispose()
            self._reader = None
            self._handler = None
            self._previous = None
            self._current = None

    def hasNext(self):
        return (self._current is not None)

    def nextI(self,reuse):
        if (self._current is not None):
            fsrrCurrent = self._current
            self.check(reuse)
            self._previous = fsrrCurrent
            return fsrrCurrent
        else:
            return None

    def nextReuse(self,rowReader):
        return self.nextI(True)

    def next(self):
        return self.nextI(False)

    def reset(self):
        self._reader.reset()
        self._previous = None
        self._current = None

    @staticmethod
    def createCMDDirReader(rReader):
        return com_sdtk_table_FileSystemReader(com_sdtk_table_CMDDirHandler.instance(),rReader)


class com_sdtk_table_FileSystemRowReader(com_sdtk_table_DataTableRowReader):

    def __init__(self,fshHandler,rReader,fsrrPrevious):
        self._array = None
        self._current = None
        self._reader = None
        self._handler = None
        super().__init__()
        self.reuse(fshHandler,rReader,fsrrPrevious)

    def reuse(self,fshHandler,rReader,fsrrPrevious):
        self._handler = fshHandler
        self._reader = rReader
        if (fsrrPrevious is not None):
            self._current = self._handler.next(self._reader,fsrrPrevious._current)
            fsrrPrevious._current = None
        else:
            self._current = self._handler.next(self._reader,None)
        if (self._current is not None):
            self._array = list()
            _this = self._array
            x = self._current.getDrive()
            _this.append(x)
            _this = self._array
            x = self._current.getLabel()
            _this.append(x)
            _this = self._array
            x = self._current.getSerial()
            _this.append(x)
            _this = self._array
            x = self._current.getDirectory()
            _this.append(x)
            _this = self._array
            x = self._current.getOwner()
            _this.append(x)
            _this = self._array
            x = self._current.getName()
            _this.append(x)
            _this = self._array
            x = self._current.getShortName()
            _this.append(x)
            _this = self._array
            x = self._current.getTrueName()
            _this.append(x)
            _this = self._array
            x = self._current.getDate()
            _this.append(x)
            _this = self._array
            x = self._current.getSize()
            _this.append(x)
            _this = self._array
            x = ("Directory" if (self._current.getIsDirectory()) else ("Junction" if (self._current.getIsJunction()) else "File"))
            _this.append(x)
        self._index = -1
        self._started = False
        self._value = None

    def startI(self):
        pass

    def dispose(self):
        if (self._reader is not None):
            self._reader.dispose()
            self._reader = None
            self._handler = None
            self._array = None

    def hasNext(self):
        if (self._current is not None):
            return (self.index() < len(self._array))
        else:
            return False

    def next(self):
        self.incrementTo(python_internal_ArrayImpl._get(com_sdtk_table_FileSystemRowReader._fields, self.index()),python_internal_ArrayImpl._get(self._array, self.index()),self.index())
        return self.value()


class com_sdtk_table_FileSystemRowWriter(com_sdtk_table_DataTableRowWriter):

    def __init__(self,fshHandler,wWriter,fsrwPrevious,iOptions):
        self._options = None
        self._tally = None
        self._current = None
        self._previous = None
        self._writer = None
        self._handler = None
        super().__init__()
        self.reuse(fshHandler,wWriter,fsrwPrevious,iOptions)

    def reuse(self,fshHandler,wWriter,fsrwPrevious,iOptions):
        self._current = com_sdtk_table_FileInfo()
        self._handler = fshHandler
        self._writer = wWriter
        if ((fsrwPrevious is not None) and ((fsrwPrevious != self))):
            self._previous = fsrwPrevious._current
            self._tally = fsrwPrevious._tally
            fsrwPrevious._current = None
            fsrwPrevious._tally = None
        else:
            self._tally = com_sdtk_table_TallyInfo()
        self._options = iOptions

    def write(self,data,name,index):
        _g = StringTools.trim(name).lower()
        _hx_local_0 = len(_g)
        if (_hx_local_0 == 9):
            if (_g == "directory"):
                self._current.setDirectory(data)
        elif (_hx_local_0 == 5):
            if (_g == "drive"):
                self._current.setDrive(data)
            elif (_g == "label"):
                self._current.setLabel(data)
            elif (_g == "owner"):
                self._current.setOwner(data)
            elif (_g == "short"):
                self._current.setShortName(data)
        elif (_hx_local_0 == 4):
            if (_g == "file"):
                self._current.setName(data)
            elif (_g == "size"):
                self._current.setSize(data)
            elif (_g == "true"):
                self._current.setTrueName(data)
            elif (_g == "type"):
                _g = HxString.substr(StringTools.trim(Std.string(data)),0,3).lower()
                if (_g == "dir"):
                    self._current.setIsDirectory(True)
                elif (_g == "jun"):
                    self._current.setIsJunction(True)
                else:
                    pass
        elif (_hx_local_0 == 8):
            if (_g == "modified"):
                self._current.setDate(data)
        elif (_hx_local_0 == 6):
            if (_g == "serial"):
                self._current.setSerial(data)
        else:
            pass

    def dispose(self):
        if (self._writer is not None):
            self._writer = None
            self._handler = None
            self._previous = None
            super().dispose()


class com_sdtk_table_FileSystemWriter(com_sdtk_table_DataTableWriter):

    def __init__(self,fshHandler,wWriter):
        self._previous = None
        self._writer = None
        self._handler = None
        super().__init__()
        self._handler = fshHandler
        self._writer = wWriter

    def start(self):
        self._writer.start()

    def writeStartI(self,name,index,rowWriter):
        if (rowWriter is None):
            self._previous = com_sdtk_table_FileSystemRowWriter(self._handler,self._writer,self._previous,0)
        else:
            self._previous = rowWriter
            self._previous.reuse(self._handler,self._writer,self._previous,0)
        return self._previous

    def dispose(self):
        if (self._writer is not None):
            self._writer.dispose()
            self._writer = None
            self._handler = None
            self._previous = None
            super().dispose()

    @staticmethod
    def createCMDDirWriter(wWriter):
        return com_sdtk_table_FileSystemWriter(com_sdtk_table_CMDDirHandler.instance(),wWriter)

class com_sdtk_table_Format(Enum):
    __slots__ = ()
    _hx_class_name = "com.sdtk.table.Format"
    _hx_constructs = ["CSV", "PSV", "TSV", "DIR", "INI", "JSON", "PROPERTIES", "SQL", "Haxe", "Python", "Java", "CSharp", "SPLUNK", "HTMLTable", "ARRAY", "MAP", "ARRAYMAP", "MAPARRAY", "DB", "RAW", "TEX"]
com_sdtk_table_Format.CSV = com_sdtk_table_Format("CSV", 0, ())
com_sdtk_table_Format.PSV = com_sdtk_table_Format("PSV", 1, ())
com_sdtk_table_Format.TSV = com_sdtk_table_Format("TSV", 2, ())
com_sdtk_table_Format.DIR = com_sdtk_table_Format("DIR", 3, ())
com_sdtk_table_Format.INI = com_sdtk_table_Format("INI", 4, ())
com_sdtk_table_Format.JSON = com_sdtk_table_Format("JSON", 5, ())
com_sdtk_table_Format.PROPERTIES = com_sdtk_table_Format("PROPERTIES", 6, ())
com_sdtk_table_Format.SQL = com_sdtk_table_Format("SQL", 7, ())
com_sdtk_table_Format.Haxe = com_sdtk_table_Format("Haxe", 8, ())
com_sdtk_table_Format.Python = com_sdtk_table_Format("Python", 9, ())
com_sdtk_table_Format.Java = com_sdtk_table_Format("Java", 10, ())
com_sdtk_table_Format.CSharp = com_sdtk_table_Format("CSharp", 11, ())
com_sdtk_table_Format.SPLUNK = com_sdtk_table_Format("SPLUNK", 12, ())
com_sdtk_table_Format.HTMLTable = com_sdtk_table_Format("HTMLTable", 13, ())
com_sdtk_table_Format.ARRAY = com_sdtk_table_Format("ARRAY", 14, ())
com_sdtk_table_Format.MAP = com_sdtk_table_Format("MAP", 15, ())
com_sdtk_table_Format.ARRAYMAP = com_sdtk_table_Format("ARRAYMAP", 16, ())
com_sdtk_table_Format.MAPARRAY = com_sdtk_table_Format("MAPARRAY", 17, ())
com_sdtk_table_Format.DB = com_sdtk_table_Format("DB", 18, ())
com_sdtk_table_Format.RAW = com_sdtk_table_Format("RAW", 19, ())
com_sdtk_table_Format.TEX = com_sdtk_table_Format("TEX", 20, ())
com_sdtk_table_Format._hx_class = com_sdtk_table_Format


class com_sdtk_table_Formats:

    def __init__(self):
        pass

    @staticmethod
    def CSV():
        return com_sdtk_table_Format.CSV

    @staticmethod
    def PSV():
        return com_sdtk_table_Format.PSV

    @staticmethod
    def TSV():
        return com_sdtk_table_Format.TSV

    @staticmethod
    def DIR():
        return com_sdtk_table_Format.DIR

    @staticmethod
    def INI():
        return com_sdtk_table_Format.INI

    @staticmethod
    def JSON():
        return com_sdtk_table_Format.JSON

    @staticmethod
    def PROPERTIES():
        return com_sdtk_table_Format.PROPERTIES

    @staticmethod
    def SQL():
        return com_sdtk_table_Format.SQL

    @staticmethod
    def Haxe():
        return com_sdtk_table_Format.Haxe

    @staticmethod
    def Python():
        return com_sdtk_table_Format.Python

    @staticmethod
    def Java():
        return com_sdtk_table_Format.Java

    @staticmethod
    def CSharp():
        return com_sdtk_table_Format.CSharp

    @staticmethod
    def SPLUNK():
        return com_sdtk_table_Format.SPLUNK

    @staticmethod
    def HTMLTable():
        return com_sdtk_table_Format.HTMLTable

    @staticmethod
    def ARRAY():
        return com_sdtk_table_Format.ARRAY

    @staticmethod
    def MAP():
        return com_sdtk_table_Format.MAP

    @staticmethod
    def ARRAYMAP():
        return com_sdtk_table_Format.ARRAYMAP

    @staticmethod
    def MAPARRAY():
        return com_sdtk_table_Format.MAPARRAY

    @staticmethod
    def DB():
        return com_sdtk_table_Format.DB

    @staticmethod
    def RAW():
        return com_sdtk_table_Format.RAW

    @staticmethod
    def TEX():
        return com_sdtk_table_Format.TEX


class com_sdtk_table_HaxeInfoAbstract:

    def __init__(self):
        pass

    def start(self):
        return "["

    def end(self):
        return "]"

    def rowStart(self,name,index):
        return ""

    def betweenRows(self):
        return ",\n"

    def rowEnd(self):
        return "]"

    def arrayRowStart(self,name,index):
        return "[ "

    def mapRowStart(self,name,index):
        if ((name is not None) and ((name != ""))):
            return (("\"" + ("null" if name is None else name)) + "\" => [")
        else:
            return (Std.string(index) + " => [")

    def mapIntEntry(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return ((("\"" + ("null" if name is None else name)) + "\" => ") + Std.string(data))
        else:
            return ((Std.string(index) + " => ") + Std.string(data))

    def mapBoolEntry(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return ((("\"" + ("null" if name is None else name)) + "\" => ") + Std.string(data))
        else:
            return ((Std.string(index) + " => ") + Std.string(data))

    def mapFloatEntry(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return ((("\"" + ("null" if name is None else name)) + "\" => ") + Std.string(data))
        else:
            return ((Std.string(index) + " => ") + Std.string(data))

    def mapOtherEntry(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return (((("\"" + ("null" if name is None else name)) + "\" => \"") + ("null" if data is None else data)) + "\"")
        else:
            return (((Std.string(index) + " => \"") + ("null" if data is None else data)) + "\"")

    def mapNullEntry(self,name,index):
        if ((name is not None) and ((name != ""))):
            return (("\"" + ("null" if name is None else name)) + "\" => null")
        else:
            return (Std.string(index) + " => null")

    def arrayIntEntry(self,data,name,index):
        return Std.string(data)

    def arrayBoolEntry(self,data,name,index):
        return Std.string(data)

    def arrayFloatEntry(self,data,name,index):
        return Std.string(data)

    def arrayOtherEntry(self,data,name,index):
        return (("\"" + ("null" if data is None else data)) + "\"")

    def arrayNullEntry(self,name,index):
        return "null"

    def intEntry(self,data,name,index):
        return None

    def boolEntry(self,data,name,index):
        return None

    def floatEntry(self,data,name,index):
        return None

    def otherEntry(self,data,name,index):
        return None

    def nullEntry(self,name,index):
        return None

    def betweenEntries(self):
        return ","

    def replacements(self):
        return ["\\\"", "\"", "\\\n", "\n", "\\\t", "\t"]


class com_sdtk_table_HaxeInfoArrayOfArrays(com_sdtk_table_HaxeInfoAbstract):

    def __init__(self):
        super().__init__()

    def rowStart(self,name,index):
        return self.arrayRowStart(name,index)

    def intEntry(self,data,name,index):
        return self.arrayIntEntry(data,name,index)

    def boolEntry(self,data,name,index):
        return self.arrayBoolEntry(data,name,index)

    def floatEntry(self,data,name,index):
        return self.arrayFloatEntry(data,name,index)

    def otherEntry(self,data,name,index):
        return self.arrayOtherEntry(data,name,index)

    def nullEntry(self,name,index):
        return self.arrayNullEntry(name,index)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_HaxeInfoArrayOfArrays._instance is None):
            com_sdtk_table_HaxeInfoArrayOfArrays._instance = com_sdtk_table_HaxeInfoArrayOfArrays()
        return com_sdtk_table_HaxeInfoArrayOfArrays._instance


class com_sdtk_table_HaxeInfoArrayOfMaps(com_sdtk_table_HaxeInfoAbstract):

    def __init__(self):
        super().__init__()

    def rowStart(self,name,index):
        return self.arrayRowStart(name,index)

    def intEntry(self,data,name,index):
        return self.mapIntEntry(data,name,index)

    def boolEntry(self,data,name,index):
        return self.mapBoolEntry(data,name,index)

    def floatEntry(self,data,name,index):
        return self.mapFloatEntry(data,name,index)

    def otherEntry(self,data,name,index):
        return self.mapOtherEntry(data,name,index)

    def nullEntry(self,name,index):
        return self.mapNullEntry(name,index)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_HaxeInfoArrayOfMaps._instance is None):
            com_sdtk_table_HaxeInfoArrayOfMaps._instance = com_sdtk_table_HaxeInfoArrayOfMaps()
        return com_sdtk_table_HaxeInfoArrayOfMaps._instance


class com_sdtk_table_HaxeInfoMapOfArrays(com_sdtk_table_HaxeInfoAbstract):

    def __init__(self):
        super().__init__()

    def rowStart(self,name,index):
        return self.mapRowStart(name,index)

    def intEntry(self,data,name,index):
        return self.arrayIntEntry(data,name,index)

    def boolEntry(self,data,name,index):
        return self.arrayBoolEntry(data,name,index)

    def floatEntry(self,data,name,index):
        return self.arrayFloatEntry(data,name,index)

    def otherEntry(self,data,name,index):
        return self.arrayOtherEntry(data,name,index)

    def nullEntry(self,name,index):
        return self.arrayNullEntry(name,index)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_HaxeInfoMapOfArrays._instance is None):
            com_sdtk_table_HaxeInfoMapOfArrays._instance = com_sdtk_table_HaxeInfoMapOfArrays()
        return com_sdtk_table_HaxeInfoMapOfArrays._instance


class com_sdtk_table_HaxeInfoMapOfMaps(com_sdtk_table_HaxeInfoAbstract):

    def __init__(self):
        super().__init__()

    def rowStart(self,name,index):
        return self.mapRowStart(name,index)

    def intEntry(self,data,name,index):
        return self.mapIntEntry(data,name,index)

    def boolEntry(self,data,name,index):
        return self.mapBoolEntry(data,name,index)

    def floatEntry(self,data,name,index):
        return self.mapFloatEntry(data,name,index)

    def otherEntry(self,data,name,index):
        return self.mapOtherEntry(data,name,index)

    def nullEntry(self,name,index):
        return self.mapNullEntry(name,index)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_HaxeInfoMapOfMaps._instance is None):
            com_sdtk_table_HaxeInfoMapOfMaps._instance = com_sdtk_table_HaxeInfoMapOfMaps()
        return com_sdtk_table_HaxeInfoMapOfMaps._instance


class com_sdtk_table_KeyValueHandler:
    pass


class com_sdtk_table_INIHandler:

    def __init__(self):
        pass

    def favorReadAll(self):
        return True

    def oneRowPerFile(self):
        return False

    def read(self,rReader):
        rReader = rReader.switchToLineReader()
        mMap = haxe_ds_StringMap()
        while rReader.hasNext():
            sLine = rReader.peek()
            sFirst = ("" if ((0 >= len(sLine))) else sLine[0])
            if (sFirst == "["):
                break
            elif ((sFirst == ";") or (((sFirst == "#") and (((("" if ((1 >= len(sLine))) else sLine[1])) == " "))))):
                rReader.next()
                continue
            else:
                startIndex = None
                iIndex = (sLine.find("=") if ((startIndex is None)) else HxString.indexOfImpl(sLine,"=",startIndex))
                key = com_sdtk_table_INIHandler.convertFrom(HxString.substr(sLine,0,iIndex))
                value = com_sdtk_table_INIHandler.convertFrom(HxString.substr(sLine,(iIndex + 1),None))
                mMap.h[key] = value
                rReader.next()
        return mMap

    def write(self,wWriter,mMap,name,index):
        wWriter = wWriter.switchToLineWriter()
        value = mMap.h.get("__name__",None)
        if (value is not None):
            wWriter.write((("[" + HxOverrides.stringOrNull(com_sdtk_table_INIHandler.convertTo(Std.string(value)))) + "]\n"))
            value = None
        key = mMap.keys()
        while key.hasNext():
            key1 = key.next()
            value = mMap.h.get(key1,None)
            if (key1 != "__name__"):
                wWriter.write((((HxOverrides.stringOrNull(com_sdtk_table_INIHandler.convertTo(key1)) + "=") + HxOverrides.stringOrNull(com_sdtk_table_INIHandler.convertTo(Std.string(value)))) + "\n"))

    def writeEnd(self,wWriter,lastName,lastIndex):
        pass

    def readAll(self,rReader,aMaps,aNames):
        rReader = rReader.switchToLineReader()
        while rReader.hasNext():
            sLine = rReader.peek()
            sFirst = ("" if ((0 >= len(sLine))) else sLine[0])
            if ((sFirst == ";") or (((sFirst == "#") and (((("" if ((1 >= len(sLine))) else sLine[1])) == " "))))):
                continue
            elif (sFirst == "["):
                sKey = HxString.substr(sLine,1,None)
                index = (len(sKey) - 1)
                if ((("" if (((index < 0) or ((index >= len(sKey))))) else sKey[index])) == "\n"):
                    sKey = HxString.substr(sKey,0,(len(sKey) - 1))
                index1 = (len(sKey) - 1)
                if ((("" if (((index1 < 0) or ((index1 >= len(sKey))))) else sKey[index1])) == "]"):
                    sKey = HxString.substr(sKey,0,(len(sKey) - 1))
                sKey = com_sdtk_table_INIHandler.convertTo(sKey)
                rReader.next()
                x = self.read(rReader)
                aMaps.append(x)
                aNames.append(sKey)
            else:
                x1 = self.read(rReader)
                aMaps.append(x1)
                aNames.append("")

    def writeAll(self,wWriter,aMaps,aNames):
        i = 0
        wWriter = wWriter.switchToLineWriter()
        while (i < len(aMaps)):
            wWriter.write((("[" + HxOverrides.stringOrNull(com_sdtk_table_INIHandler.convertTo((aNames[i] if i >= 0 and i < len(aNames) else None)))) + "]"))
            aMaps1 = i
            i = (i + 1)
            self.write(wWriter,(aMaps[aMaps1] if aMaps1 >= 0 and aMaps1 < len(aMaps) else None),None,0)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_INIHandler._instance is None):
            com_sdtk_table_INIHandler._instance = com_sdtk_table_INIHandler()
        return com_sdtk_table_INIHandler._instance

    @staticmethod
    def convertFrom(sValue):
        sValue = StringTools.trim(sValue)
        sValue = StringTools.replace(sValue,"\\\\","\\")
        sValue = StringTools.replace(sValue,"\\'","'")
        sValue = StringTools.replace(sValue,"\\\"","\"")
        sValue = StringTools.replace(sValue,"\\0","\x00")
        sValue = StringTools.replace(sValue,"\\a","\x07")
        sValue = StringTools.replace(sValue,"\\b","\x08")
        sValue = StringTools.replace(sValue,"\\t","\t")
        sValue = StringTools.replace(sValue,"\\r","\r")
        sValue = StringTools.replace(sValue,"\\n","\n")
        sValue = StringTools.replace(sValue,"\\;",";")
        sValue = StringTools.replace(sValue,"\\#","#")
        sValue = StringTools.replace(sValue,"\\=","=")
        sValue = StringTools.replace(sValue,"\\:",":")
        return sValue

    @staticmethod
    def convertTo(sValue):
        sValue = StringTools.replace(sValue,"\\","\\\\")
        sValue = StringTools.replace(sValue,"'","\\'")
        sValue = StringTools.replace(sValue,"\"","\\\"")
        sValue = StringTools.replace(sValue,"\x00","\\0")
        sValue = StringTools.replace(sValue,"\x07","\\a")
        sValue = StringTools.replace(sValue,"\x08","\\b")
        sValue = StringTools.replace(sValue,"\t","\\t")
        sValue = StringTools.replace(sValue,"\r","\\r")
        sValue = StringTools.replace(sValue,"\n","\\n")
        sValue = StringTools.replace(sValue,";","\\;")
        sValue = StringTools.replace(sValue,"#","\\#")
        sValue = StringTools.replace(sValue,"=","\\=")
        sValue = StringTools.replace(sValue,":","\\:")
        sValue = StringTools.trim(sValue)
        return sValue


class com_sdtk_table_JSONHandler:

    def __init__(self):
        pass

    def favorReadAll(self):
        return True

    def oneRowPerFile(self):
        return False

    def read(self,rReader):
        return com_sdtk_std_Normalize.nativeToHaxe(com_sdtk_std_Normalize.parseJson(com_sdtk_table_JSONHandler.readValue(rReader)))

    def write(self,wWriter,mMap,name,index):
        if (index > 0):
            wWriter.write(",")
        elif ((index == 0) and ((name is None))):
            wWriter.write("[")
        elif (index == 0):
            wWriter.write("{")
        if (name is not None):
            wWriter.write("\"")
            wWriter.write(name)
            wWriter.write("\":")
        wWriter.write(haxe_format_JsonPrinter.print(mMap,None,None))

    def writeEnd(self,wWriter,lastName,lastIndex):
        if (lastName is not None):
            wWriter.write("}")
        else:
            wWriter.write("]")

    def readAll(self,rReader,aMaps,aNames):
        dData = com_sdtk_std_Normalize.parseJson(com_sdtk_table_JSONHandler.readValue(rReader))
        if Std.isOfType(dData,list):
            aValues = dData
            _g = 0
            while (_g < len(aValues)):
                value = (aValues[_g] if _g >= 0 and _g < len(aValues) else None)
                _g = (_g + 1)
                x = com_sdtk_std_Normalize.nativeToHaxe(value)
                aMaps.append(x)
                x1 = (len(aMaps) - 1)
                aNames.append(x1)
        else:
            m = com_sdtk_std_Normalize.nativeToHaxe(dData)
            keyRow = m.keys()
            while keyRow.hasNext():
                keyRow1 = keyRow.next()
                valueRow = m.h.get(keyRow1,None)
                x = com_sdtk_std_Normalize.nativeToHaxe(valueRow)
                aMaps.append(x)
                aNames.append(keyRow1)

    def writeAll(self,wWriter,aMaps,aNames):
        if (((aNames[0] if 0 < len(aNames) else None) == 0) and ((python_internal_ArrayImpl._get(aNames, (len(aNames) - 1)) == ((len(aNames) - 1))))):
            aValues = list()
            _g = 0
            while (_g < len(aMaps)):
                value = (aMaps[_g] if _g >= 0 and _g < len(aMaps) else None)
                _g = (_g + 1)
                aValues.append(value)
            wWriter.write(haxe_format_JsonPrinter.print(aValues,None,None))
        else:
            i = 0
            wWriter.write("{\n")
            while (i < len(aNames)):
                aName = (aNames[i] if i >= 0 and i < len(aNames) else None)
                sName = Std.string(aName)
                mValue = (aMaps[i] if i >= 0 and i < len(aMaps) else None)
                if (aName == sName):
                    wWriter.write("\"")
                    wWriter.write(sName)
                    wWriter.write("\"")
                else:
                    wWriter.write(sName)
                wWriter.write(":")
                self.write(wWriter,mValue,None,-1)
                wWriter.write(",\n")
                i = (i + 1)
            wWriter.write("}")
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_JSONHandler._instance is None):
            com_sdtk_table_JSONHandler._instance = com_sdtk_table_JSONHandler()
        return com_sdtk_table_JSONHandler._instance

    @staticmethod
    def readValue(rReader):
        sbBuffer_b = python_lib_io_StringIO()
        while rReader.hasNext():
            sbBuffer_b.write(Std.string(rReader.next()))
        return sbBuffer_b.getvalue()


class com_sdtk_table_JavaInfoAbstract:

    def __init__(self):
        pass

    def start(self):
        return ""

    def end(self):
        return ""

    def arrayStart(self):
        return "{"

    def arrayEnd(self):
        return "}"

    def mapStart(self):
        return "java.util.Map.ofEntries("

    def mapEnd(self):
        return ")"

    def mapStartLegacy(self):
        return "new java.util.HashMap<String, String>() {{"

    def mapEndLegacy(self):
        return "}};"

    def rowStart(self,name,index):
        return ""

    def rowEnd(self):
        return ""

    def betweenRows(self):
        return ",\n"

    def mapRowEnd(self):
        return ")"

    def mapRowEndLegacy(self):
        return "}}"

    def arrayRowEnd(self):
        return ""

    def arrayRowStart(self,name,index):
        return ""

    def mapRowStart(self,name,index):
        if ((name is not None) and ((name != ""))):
            return (("entry(\"" + ("null" if name is None else name)) + "\", ")
        else:
            return (("entry(" + Std.string(index)) + ", ")

    def mapIntEntry(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return (((("entry(\"" + ("null" if name is None else name)) + "\", ") + Std.string(data)) + ")")
        else:
            return (((("entry(" + Std.string(index)) + ", ") + Std.string(data)) + ")")

    def mapBoolEntry(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return (((("entry(\"" + ("null" if name is None else name)) + "\", ") + Std.string(data)) + ")")
        else:
            return (((("entry(" + Std.string(index)) + ", ") + Std.string(data)) + ")")

    def mapFloatEntry(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return (((("entry(\"" + ("null" if name is None else name)) + "\", ") + Std.string(data)) + ")")
        else:
            return (((("entry(" + Std.string(index)) + ", ") + Std.string(data)) + ")")

    def mapOtherEntry(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return (((("entry(\"" + ("null" if name is None else name)) + "\", \"") + ("null" if data is None else data)) + "\")")
        else:
            return (((("entry(" + Std.string(index)) + ", \"") + ("null" if data is None else data)) + "\")")

    def mapNullEntry(self,name,index):
        if ((name is not None) and ((name != ""))):
            return (("entry(\"" + ("null" if name is None else name)) + "\", null)")
        else:
            return (("entry(" + Std.string(index)) + ",  null)")

    def mapRowStartLegacy(self,name,index):
        if ((name is not None) and ((name != ""))):
            return (("put(\"" + ("null" if name is None else name)) + "\", ")
        else:
            return (("put(" + Std.string(index)) + ", ")

    def mapIntEntryLegacy(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return (((("put(\"" + ("null" if name is None else name)) + "\", ") + Std.string(data)) + ")")
        else:
            return (((("put(" + Std.string(index)) + ", ") + Std.string(data)) + ")")

    def mapBoolEntryLegacy(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return (((("put(\"" + ("null" if name is None else name)) + "\", ") + Std.string(data)) + ")")
        else:
            return (((("put(" + Std.string(index)) + ", ") + Std.string(data)) + ")")

    def mapFloatEntryLegacy(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return (((("put(\"" + ("null" if name is None else name)) + "\", ") + Std.string(data)) + ")")
        else:
            return (((("put(" + Std.string(index)) + ", ") + Std.string(data)) + ")")

    def mapOtherEntryLegacy(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return (((("put(\"" + ("null" if name is None else name)) + "\", \"") + ("null" if data is None else data)) + "\")")
        else:
            return (((("put(" + Std.string(index)) + ", \"") + ("null" if data is None else data)) + "\")")

    def mapNullEntryLegacy(self,name,index):
        if ((name is not None) and ((name != ""))):
            return (("put(\"" + ("null" if name is None else name)) + "\", null)")
        else:
            return (("put(" + Std.string(index)) + ",  null)")

    def arrayIntEntry(self,data,name,index):
        return Std.string(data)

    def arrayBoolEntry(self,data,name,index):
        return Std.string(data)

    def arrayFloatEntry(self,data,name,index):
        return Std.string(data)

    def arrayOtherEntry(self,data,name,index):
        return (("\"" + ("null" if data is None else data)) + "\"")

    def arrayNullEntry(self,name,index):
        return "null"

    def intEntry(self,data,name,index):
        return None

    def boolEntry(self,data,name,index):
        return None

    def floatEntry(self,data,name,index):
        return None

    def otherEntry(self,data,name,index):
        return None

    def nullEntry(self,name,index):
        return None

    def betweenEntries(self):
        return ","

    def replacements(self):
        return ["\\\"", "\"", "\\\n", "\n", "\\\t", "\t"]


class com_sdtk_table_JavaInfoArrayOfArrays(com_sdtk_table_JavaInfoAbstract):

    def __init__(self):
        super().__init__()

    def start(self):
        return self.arrayStart()

    def end(self):
        return self.arrayEnd()

    def rowEnd(self):
        return self.arrayEnd()

    def rowStart(self,name,index):
        return (HxOverrides.stringOrNull(self.arrayRowStart(name,index)) + HxOverrides.stringOrNull(self.arrayStart()))

    def intEntry(self,data,name,index):
        return self.arrayIntEntry(data,name,index)

    def boolEntry(self,data,name,index):
        return self.arrayBoolEntry(data,name,index)

    def floatEntry(self,data,name,index):
        return self.arrayFloatEntry(data,name,index)

    def otherEntry(self,data,name,index):
        return self.arrayOtherEntry(data,name,index)

    def nullEntry(self,name,index):
        return self.arrayNullEntry(name,index)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_JavaInfoArrayOfArrays._instance is None):
            com_sdtk_table_JavaInfoArrayOfArrays._instance = com_sdtk_table_JavaInfoArrayOfArrays()
        return com_sdtk_table_JavaInfoArrayOfArrays._instance


class com_sdtk_table_JavaInfoArrayOfMaps(com_sdtk_table_JavaInfoAbstract):

    def __init__(self):
        super().__init__()

    def start(self):
        return self.arrayStart()

    def rowEnd(self):
        return self.mapEnd()

    def end(self):
        return self.arrayEnd()

    def rowStart(self,name,index):
        return (HxOverrides.stringOrNull(self.arrayRowStart(name,index)) + HxOverrides.stringOrNull(self.mapStart()))

    def intEntry(self,data,name,index):
        return self.mapIntEntry(data,name,index)

    def boolEntry(self,data,name,index):
        return self.mapBoolEntry(data,name,index)

    def floatEntry(self,data,name,index):
        return self.mapFloatEntry(data,name,index)

    def otherEntry(self,data,name,index):
        return self.mapOtherEntry(data,name,index)

    def nullEntry(self,name,index):
        return self.mapNullEntry(name,index)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_JavaInfoArrayOfMaps._instance is None):
            com_sdtk_table_JavaInfoArrayOfMaps._instance = com_sdtk_table_JavaInfoArrayOfMaps()
        return com_sdtk_table_JavaInfoArrayOfMaps._instance


class com_sdtk_table_JavaInfoArrayOfMapsLegacy(com_sdtk_table_JavaInfoAbstract):

    def __init__(self):
        super().__init__()

    def start(self):
        return self.arrayStart()

    def rowEnd(self):
        return self.mapEndLegacy()

    def end(self):
        return self.arrayEnd()

    def rowStart(self,name,index):
        return (HxOverrides.stringOrNull(self.arrayRowStart(name,index)) + HxOverrides.stringOrNull(self.mapStartLegacy()))

    def intEntry(self,data,name,index):
        return self.mapIntEntry(data,name,index)

    def boolEntry(self,data,name,index):
        return self.mapBoolEntry(data,name,index)

    def floatEntry(self,data,name,index):
        return self.mapFloatEntry(data,name,index)

    def otherEntry(self,data,name,index):
        return self.mapOtherEntry(data,name,index)

    def nullEntry(self,name,index):
        return self.mapNullEntry(name,index)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_JavaInfoArrayOfMapsLegacy._instance is None):
            com_sdtk_table_JavaInfoArrayOfMapsLegacy._instance = com_sdtk_table_JavaInfoArrayOfMapsLegacy()
        return com_sdtk_table_JavaInfoArrayOfMapsLegacy._instance


class com_sdtk_table_JavaInfoMapOfArrays(com_sdtk_table_JavaInfoAbstract):

    def __init__(self):
        super().__init__()

    def start(self):
        return self.mapStart()

    def rowEnd(self):
        return self.arrayEnd()

    def end(self):
        return self.mapEnd()

    def rowStart(self,name,index):
        return (HxOverrides.stringOrNull(self.mapRowStart(name,index)) + HxOverrides.stringOrNull(self.arrayStart()))

    def intEntry(self,data,name,index):
        return self.arrayIntEntry(data,name,index)

    def boolEntry(self,data,name,index):
        return self.arrayBoolEntry(data,name,index)

    def floatEntry(self,data,name,index):
        return self.arrayFloatEntry(data,name,index)

    def otherEntry(self,data,name,index):
        return self.arrayOtherEntry(data,name,index)

    def nullEntry(self,name,index):
        return self.arrayNullEntry(name,index)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_JavaInfoMapOfArrays._instance is None):
            com_sdtk_table_JavaInfoMapOfArrays._instance = com_sdtk_table_JavaInfoMapOfArrays()
        return com_sdtk_table_JavaInfoMapOfArrays._instance


class com_sdtk_table_JavaInfoMapOfArraysLegacy(com_sdtk_table_JavaInfoAbstract):

    def __init__(self):
        super().__init__()

    def start(self):
        return self.mapStartLegacy()

    def rowEnd(self):
        return self.arrayEnd()

    def end(self):
        return self.mapEndLegacy()

    def rowStart(self,name,index):
        return (HxOverrides.stringOrNull(self.mapRowStartLegacy(name,index)) + HxOverrides.stringOrNull(self.arrayStart()))

    def intEntry(self,data,name,index):
        return self.arrayIntEntry(data,name,index)

    def boolEntry(self,data,name,index):
        return self.arrayBoolEntry(data,name,index)

    def floatEntry(self,data,name,index):
        return self.arrayFloatEntry(data,name,index)

    def otherEntry(self,data,name,index):
        return self.arrayOtherEntry(data,name,index)

    def nullEntry(self,name,index):
        return self.arrayNullEntry(name,index)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_JavaInfoMapOfArraysLegacy._instance is None):
            com_sdtk_table_JavaInfoMapOfArraysLegacy._instance = com_sdtk_table_JavaInfoMapOfArraysLegacy()
        return com_sdtk_table_JavaInfoMapOfArraysLegacy._instance


class com_sdtk_table_JavaInfoMapOfMaps(com_sdtk_table_JavaInfoAbstract):

    def __init__(self):
        super().__init__()

    def start(self):
        return self.mapStart()

    def end(self):
        return self.mapEnd()

    def rowEnd(self):
        return self.mapEnd()

    def rowStart(self,name,index):
        return (HxOverrides.stringOrNull(self.mapRowStart(name,index)) + HxOverrides.stringOrNull(self.mapStart()))

    def intEntry(self,data,name,index):
        return self.mapIntEntry(data,name,index)

    def boolEntry(self,data,name,index):
        return self.mapBoolEntry(data,name,index)

    def floatEntry(self,data,name,index):
        return self.mapFloatEntry(data,name,index)

    def otherEntry(self,data,name,index):
        return self.mapOtherEntry(data,name,index)

    def nullEntry(self,name,index):
        return self.mapNullEntry(name,index)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_JavaInfoMapOfMaps._instance is None):
            com_sdtk_table_JavaInfoMapOfMaps._instance = com_sdtk_table_JavaInfoMapOfMaps()
        return com_sdtk_table_JavaInfoMapOfMaps._instance


class com_sdtk_table_JavaInfoMapOfMapsLegacy(com_sdtk_table_JavaInfoAbstract):

    def __init__(self):
        super().__init__()

    def start(self):
        return self.mapStartLegacy()

    def end(self):
        return self.mapEndLegacy()

    def rowEnd(self):
        return self.mapEndLegacy()

    def rowStart(self,name,index):
        return (HxOverrides.stringOrNull(self.mapRowStartLegacy(name,index)) + HxOverrides.stringOrNull(self.mapStartLegacy()))

    def intEntry(self,data,name,index):
        return self.mapIntEntryLegacy(data,name,index)

    def boolEntry(self,data,name,index):
        return self.mapBoolEntryLegacy(data,name,index)

    def floatEntry(self,data,name,index):
        return self.mapFloatEntryLegacy(data,name,index)

    def otherEntry(self,data,name,index):
        return self.mapOtherEntryLegacy(data,name,index)

    def nullEntry(self,name,index):
        return self.mapNullEntryLegacy(name,index)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_JavaInfoMapOfMapsLegacy._instance is None):
            com_sdtk_table_JavaInfoMapOfMapsLegacy._instance = com_sdtk_table_JavaInfoMapOfMapsLegacy()
        return com_sdtk_table_JavaInfoMapOfMapsLegacy._instance


class com_sdtk_table_KeyValueReader(com_sdtk_table_DataTableReader):

    def __init__(self,fshHandler,rReader):
        self._columns = None
        self._names = None
        self._maps = None
        self._reader = None
        self._handler = None
        super().__init__()
        self._handler = fshHandler
        self._reader = rReader

    def flip(self):
        return com_sdtk_table_KeyValueWriter(self._handler,self._reader.flip())

    def check(self):
        self._maps = list()
        self._names = list()
        self._handler.readAll(self._reader,self._maps,self._names)
        self._columns = list()
        mDefinedColumns = haxe_ds_StringMap()
        _g = 0
        _g1 = self._maps
        while (_g < len(_g1)):
            mMap = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            key = mMap.keys()
            while key.hasNext():
                key1 = key.next()
                value = mMap.h.get(key1,None)
                keyString = ("" + ("null" if key1 is None else key1))
                if (mDefinedColumns.h.get(keyString,None) is None):
                    mDefinedColumns.h[keyString] = len(self._columns)
                    _this = self._columns
                    _this.append(key1)

    def startI(self):
        self._reader.start()
        self.check()

    def dispose(self):
        if (self._reader is not None):
            self._reader.dispose()
            self._reader = None
            self._handler = None
            self._maps = None
            self._names = None
            self._columns = None
            super().dispose()

    def hasNext(self):
        return (self.index() < ((len(self._maps) - 1)))

    def nextReuse(self,rowReader):
        if self.hasNext():
            if (rowReader is None):
                rowReader = com_sdtk_table_MapRowReader.readWholeMap(python_internal_ArrayImpl._get(self._maps, (self.index() + 1)))
            else:
                rr = rowReader
                rr.reuse(python_internal_ArrayImpl._get(self._maps, (self.index() + 1)),None,None)
            self.incrementTo(None,rowReader,(self.index() + 1))
            return rowReader
        else:
            return None

    def next(self):
        return self.nextReuse(None)

    def reset(self):
        self._reader.reset()
        self._maps = None
        self._names = None
        self._columns = None

    @staticmethod
    def createINIReader(rReader):
        return com_sdtk_table_KeyValueReader(com_sdtk_table_INIHandler.instance(),rReader)

    @staticmethod
    def createJSONReader(rReader):
        return com_sdtk_table_KeyValueReader(com_sdtk_table_JSONHandler.instance(),rReader)

    @staticmethod
    def createPropertiesReader(rReader):
        return com_sdtk_table_KeyValueReader(com_sdtk_table_PropertiesHandler.instance(),rReader)

    @staticmethod
    def createSplunkReader(rReader):
        return com_sdtk_table_KeyValueReader(com_sdtk_table_SplunkHandler.instance(),rReader)


class com_sdtk_table_KeyValueRowReader(com_sdtk_table_DataTableRowReader):

    def __init__(self,mMap,cColumns):
        self._columns = None
        self._map = None
        super().__init__()
        self.reuse(mMap,cColumns)

    def reuse(self,mMap,cColumns):
        self._map = mMap
        self._columns = cColumns
        self._index = -1
        self._rawIndex = -1
        self._started = False
        self._value = None

    def startI(self):
        pass

    def dispose(self):
        self._map = None
        self._columns = None

    def hasNext(self):
        return (self.index() < ((len(self._columns) - 1)))

    def next(self):
        sColumn = python_internal_ArrayImpl._get(self._columns, (self.index() + 1))
        self.incrementTo(sColumn,self._map.h.get(sColumn,None),(self.index() + 1))
        return self.value()


class com_sdtk_table_KeyValueRowWriter(com_sdtk_table_DataTableRowWriter):

    def __init__(self,fshHandler,wWriter,name,index):
        self._map = None
        self._rowIndex = None
        self._name = None
        self._writer = None
        self._handler = None
        super().__init__()
        self.reuse(fshHandler,wWriter,name,index)

    def reuse(self,fshHandler,wWriter,name,index):
        if (self._writer is not None):
            self._handler.write(self._writer,self._map,self._name,self._rowIndex)
        self._handler = fshHandler
        self._writer = wWriter
        self._name = name
        self._rowIndex = index
        self._map = haxe_ds_StringMap()

    def start(self):
        self._writer.start()

    def write(self,data,name,index):
        if (data is not None):
            self._map.h[name] = data

    def dispose(self):
        if (self._writer is not None):
            self._handler.write(self._writer,self._map,self._name,self._rowIndex)
            self._writer = None
            self._handler = None
            self._name = None
            self._map = None
            super().dispose()


class com_sdtk_table_KeyValueWriter(com_sdtk_table_DataTableWriter):

    def __init__(self,fshHandler,wWriter):
        self._lastIndex = None
        self._lastName = None
        self._writer = None
        self._handler = None
        super().__init__()
        self._handler = fshHandler
        self._writer = wWriter

    def flip(self):
        return com_sdtk_table_KeyValueReader(self._handler,self._writer.flip())

    def start(self):
        self._writer.start()

    def writeStartI(self,name,index,rowWriter):
        if (rowWriter is None):
            rowWriter = com_sdtk_table_KeyValueRowWriter(self._handler,self._writer,name,index)
        else:
            rw = rowWriter
            rw.reuse(self._handler,self._writer,name,index)
        return rowWriter

    def oneRowPerFile(self):
        return self._handler.oneRowPerFile()

    def dispose(self):
        if (self._writer is not None):
            self._handler.writeEnd(self._writer,self._lastName,self._lastIndex)
            self._writer.dispose()
            self._writer = None
            self._handler = None
            self._lastName = None
            self._lastIndex = None
            super().dispose()

    @staticmethod
    def createINIWriter(wWriter):
        return com_sdtk_table_KeyValueWriter(com_sdtk_table_INIHandler.instance(),wWriter)

    @staticmethod
    def createJSONWriter(wWriter):
        return com_sdtk_table_KeyValueWriter(com_sdtk_table_JSONHandler.instance(),wWriter)

    @staticmethod
    def createPropertiesWriter(wWriter):
        return com_sdtk_table_KeyValueWriter(com_sdtk_table_PropertiesHandler.instance(),wWriter)

    @staticmethod
    def createSplunkWriter(wWriter):
        return com_sdtk_table_KeyValueWriter(com_sdtk_table_SplunkHandler.instance(),wWriter)


class com_sdtk_table_MapReader(com_sdtk_table_DataTableReader):

    def __init__(self,_hx_map):
        self._iterator = None
        self._map = None
        super().__init__()
        self._map = com_sdtk_std_Normalize.nativeToHaxe(_hx_map)
        self._iterator = self._map.keys()

    def hasNext(self):
        return self._iterator.hasNext()

    def nextReuse(self,rowReader):
        if (rowReader is None):
            rowReader = com_sdtk_table_MapRowReader.continueRead(self._map,self._iterator)
        else:
            rr = rowReader
            rr.reuse(self._map,self._iterator,None)
        self._value = rowReader
        return rowReader

    def next(self):
        return self.nextReuse(None)

    def iterator(self):
        return com_sdtk_table_MapReader(self._map)

    def reset(self):
        self._iterator = self._map.keys()

    def flip(self):
        return com_sdtk_table_MapWriter.writeToWholeMap(self._map,None,None)

    def toHaxeMap(self,_hx_map,keyField,valueField):
        key = self._map.keys()
        while key.hasNext():
            key1 = key.next()
            value = self._map.h.get(key1,None)
            _hx_map.h[key1] = value
        return _hx_map

    @staticmethod
    def readWholeMap(_hx_map):
        return com_sdtk_table_MapReader(_hx_map)


class com_sdtk_table_MapRowReader(com_sdtk_table_DataTableRowReader):

    def __init__(self,_hx_map,iterator,nextKey):
        self._whole = None
        self._originalKey = None
        self._nextKey = None
        self._iterator = None
        self._map = None
        super().__init__()
        self.reuse(_hx_map,iterator,nextKey)

    def reuse(self,_hx_map,iterator,nextKey):
        self._map = com_sdtk_std_Normalize.nativeToHaxe(_hx_map)
        if (iterator is None):
            self._iterator = self._map.keys()
            self._whole = True
        else:
            self._iterator = iterator
            self._whole = False
        if (nextKey is not None):
            self._nextKey = nextKey
            self._originalKey = self._nextKey
        else:
            self._nextKey = self._iterator.next()
            self._originalKey = self._nextKey
        self._started = False
        self._index = -1
        self._rawIndex = -1
        self._started = False
        self._value = None

    def hasNext(self):
        if (self._index == -1):
            return (self._nextKey is not None)
        elif self._whole:
            if (not self._iterator.hasNext()):
                return (self._nextKey is not None)
            else:
                return True
        else:
            return False

    def next(self):
        if (self._nextKey is None):
            return None
        else:
            self._name = Std.string(self._nextKey)
            self._value = self._map.h.get(self._nextKey,None)
            self.incrementTo(self._name,self._value,(self._index + 1))
            if self._whole:
                self._nextKey = self._iterator.next()
            else:
                self._nextKey = None
            return self._value

    def iterator(self):
        return com_sdtk_table_MapRowReader(self._map,(None if (self._whole) else self._iterator),(None if (self._whole) else self._nextKey))

    def reset(self):
        if self._whole:
            self._iterator = self._map.keys()
        else:
            self._nextKey = self._originalKey

    def dispose(self):
        if (self._map is not None):
            self._map = None
            self._iterator = None
            self._nextKey = None
            self._originalKey = None

    @staticmethod
    def continueRead(_hx_map,iterator):
        return com_sdtk_table_MapRowReader(_hx_map,iterator,None)

    @staticmethod
    def readWholeMap(_hx_map):
        return com_sdtk_table_MapRowReader(_hx_map,None,None)


class com_sdtk_table_MapRowWriter(com_sdtk_table_DataTableRowWriter):

    def __init__(self,_hx_map,expandable,keyField,valueField):
        self._got = None
        self._valueCurrent = None
        self._keyCurrent = None
        self._valueField = None
        self._keyField = None
        self._expandable = None
        self._map = None
        super().__init__()
        self.reuse(_hx_map,expandable,keyField,valueField)

    def reuse(self,_hx_map,expandable,keyField,valueField):
        self._map = _hx_map
        self._expandable = expandable
        self._keyField = keyField
        self._valueField = valueField
        self._keyCurrent = None
        self._valueCurrent = None
        self._got = 0

    def write(self,data,name,index):
        if (self._map is not None):
            if (self._keyField is None):
                if self._expandable:
                    self._map.h[name] = data
                else:
                    self._map.h[name] = data
            else:
                if (name == self._keyField):
                    self._keyCurrent = data
                    _hx_local_0 = self
                    _hx_local_1 = _hx_local_0._got
                    _hx_local_0._got = (_hx_local_1 + 1)
                    _hx_local_1
                elif (name == self._valueField):
                    self._valueCurrent = data
                    _hx_local_2 = self
                    _hx_local_3 = _hx_local_2._got
                    _hx_local_2._got = (_hx_local_3 + 1)
                    _hx_local_3
                if (self._got == 2):
                    self._map.h[self._keyCurrent] = self._valueCurrent
                    self._got = 0

    def reset(self):
        pass

    def dispose(self):
        if (self._map is not None):
            self._map = None
            self._keyField = None
            self._valueField = None
            self._keyCurrent = None
            self._valueCurrent = None
            self._got = 0

    @staticmethod
    def continueWrite(_hx_map,expandable,keyField,valueField):
        return com_sdtk_table_MapRowWriter.continueWriteReuse(_hx_map,expandable,keyField,valueField,None)

    @staticmethod
    def continueWriteReuse(_hx_map,expandable,keyField,valueField,rowWriter):
        if (rowWriter is None):
            rowWriter = com_sdtk_table_MapRowWriter(_hx_map,expandable,keyField,valueField)
        else:
            rowWriter.reuse(_hx_map,expandable,keyField,valueField)
        return rowWriter


class com_sdtk_table_MapWriter(com_sdtk_table_DataTableWriter):

    def __init__(self,_hx_map,expandable,keyField,valueField):
        self._valueField = None
        self._keyField = None
        self._expandable = None
        self._map = None
        super().__init__()
        self.reuse(_hx_map,expandable,keyField,valueField)

    def reuse(self,_hx_map,expandable,keyField,valueField):
        self._map = _hx_map
        self._expandable = expandable
        self._keyField = keyField
        self._valueField = valueField

    def start(self):
        pass

    def writeStartI(self,name,index,rowWriter):
        rowWriter1 = com_sdtk_table_MapRowWriter.continueWriteReuse(self._map,self._expandable,self._keyField,self._valueField,rowWriter)
        return rowWriter1

    def flip(self):
        return com_sdtk_table_MapReader.readWholeMap(self._map)

    def dispose(self):
        if (self._map is not None):
            self._map = None
            self._keyField = None
            self._valueField = None

    @staticmethod
    def writeToWholeMap(_hx_map,keyField,valueField):
        return com_sdtk_table_MapWriter(_hx_map,False,keyField,valueField)

    @staticmethod
    def writeToExpandableMap(_hx_map,keyField,valueField):
        return com_sdtk_table_MapWriter(_hx_map,True,keyField,valueField)


class com_sdtk_table_MatrixInfo:

    def __init__(self):
        self._currentRow = None
        self._headersFlatten = None
        self._headers = None
        self._columnList = None
        self._headerRows = None
        self._headerColumns = None
        self._currentI = 0


class com_sdtk_table_MatrixReader(com_sdtk_table_DataTableReaderDecorator):

    def __init__(self,reader,headerColumns,headerRows,columnList):
        self._info = com_sdtk_table_MatrixInfo()
        super().__init__(reader)
        self._info._headerColumns = headerColumns
        self._info._headerRows = headerRows
        self._info._columnList = columnList
        self._info._headers = list()
        _this = self._info._headers
        l = len(_this)
        if (l < headerColumns):
            idx = (headerColumns - 1)
            v = None
            l1 = len(_this)
            while (l1 < idx):
                _this.append(None)
                l1 = (l1 + 1)
            if (l1 == idx):
                _this.append(v)
            else:
                _this[idx] = v
        elif (l > headerColumns):
            pos = headerColumns
            _hx_len = (l - headerColumns)
            if (pos < 0):
                pos = (len(_this) + pos)
            if (pos < 0):
                pos = 0
            res = _this[pos:(pos + _hx_len)]
            del _this[pos:(pos + _hx_len)]
        reader.noHeaderIncluded(True)
        if (headerRows > 0):
            i = 0
            while (i < headerRows):
                rowBuffer = list()
                python_internal_ArrayImpl._set(self._info._headers, i, rowBuffer)
                reader.start()
                rowReader = reader.next()
                rowReader.start()
                while rowReader.hasNext():
                    x = rowReader.next()
                    rowBuffer.append(x)
                i = (i + 1)
            self._info._headersFlatten = list()
            i = 0
            while (i < len(python_internal_ArrayImpl._get(self._info._headers, 0))):
                j = 0
                while (j < headerRows):
                    _this = self._info._headersFlatten
                    x = python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(self._info._headers, j), i)
                    _this.append(x)
                    j = (j + 1)
                i = (i + 1)

    def dispose(self):
        self._info = None
        super().dispose()

    def nextReuse(self,rowReader):
        reader = None
        if (self._info._currentI == 0):
            reader = self._reader.next()
        else:
            reader = self._reader.value()
        if (rowReader is None):
            rowReader = com_sdtk_table_MatrixRowReader(self._info,reader)
        else:
            rr = rowReader
            rr.reuse(reader)
        self.incrementTo(None,rowReader,self._reader.rawIndex())
        return rowReader

    def next(self):
        return self.nextReuse(None)

    def skipRows(self,rows):
        pass

    @staticmethod
    def createMatrixReader(reader,headerColumns,headerRows,columnList):
        return com_sdtk_table_MatrixReader(reader,headerColumns,headerRows,columnList)


class com_sdtk_table_MatrixRowReader(com_sdtk_table_DataTableRowReaderDecorator):

    def __init__(self,info,reader):
        self._info = None
        super().__init__(reader)
        self._info = info
        self._started = False

    def reuse(self,reader):
        super().reuse(reader)
        self._started = False

    def next(self):
        current = None
        name = None
        i = (self.index() + 1)
        j = (i - len(self._info._currentRow))
        if (j < 0):
            current = python_internal_ArrayImpl._get(self._info._currentRow, i)
        elif (j < len(self._info._headers)):
            current = python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(self._info._headers, j), (self._info._currentI + self._info._headerColumns))
        elif (j == len(self._info._headers)):
            current = self._reader.next()
            _hx_local_0 = self._info
            _hx_local_1 = _hx_local_0._currentI
            _hx_local_0._currentI = (_hx_local_1 + 1)
            _hx_local_1
            if (not self._reader.hasNext()):
                self._info._currentI = 0
        if ((self._info._columnList is not None) and ((i < len(self._info._columnList)))):
            name = python_internal_ArrayImpl._get(self._info._columnList, i)
        else:
            name = None
        self.incrementTo(name,current,self._reader.rawIndex())
        return current

    def hasNext(self):
        i = (self.index() + 1)
        j = (i - len(self._info._currentRow))
        return (j <= len(self._info._headers))

    def start(self):
        if (not self._started):
            self._started = True
            if (self._info._currentI == 0):
                super().start()
                i = 0
                if (self._info._currentRow is None):
                    self._info._currentRow = list()
                    _this = self._info._currentRow
                    _hx_len = self._info._headerColumns
                    l = len(_this)
                    if (l < _hx_len):
                        idx = (_hx_len - 1)
                        v = None
                        l1 = len(_this)
                        while (l1 < idx):
                            _this.append(None)
                            l1 = (l1 + 1)
                        if (l1 == idx):
                            _this.append(v)
                        else:
                            _this[idx] = v
                    elif (l > _hx_len):
                        pos = _hx_len
                        len1 = (l - _hx_len)
                        if (pos < 0):
                            pos = (len(_this) + pos)
                        if (pos < 0):
                            pos = 0
                        res = _this[pos:(pos + len1)]
                        del _this[pos:(pos + len1)]
                while (i < self._info._headerColumns):
                    python_internal_ArrayImpl._set(self._info._currentRow, i, self._reader.next())
                    i = (i + 1)

    def name(self):
        return self._name

    def value(self):
        return self._value

    def index(self):
        return self._index


class com_sdtk_table_NullReader(com_sdtk_table_DataTableReader):

    def __init__(self):
        super().__init__()

    def hasNext(self):
        return False

    def next(self):
        return None

    def iterator(self):
        return self

    def flip(self):
        return com_sdtk_table_NullWriter.instance()

    def reset(self):
        pass
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_NullReader._instance is None):
            com_sdtk_table_NullReader._instance = com_sdtk_table_NullReader()
        return com_sdtk_table_NullReader._instance


class com_sdtk_table_NullRowReader(com_sdtk_table_DataTableRowReader):

    def __init__(self):
        super().__init__()

    def hasNext(self):
        return False

    def next(self):
        return None

    def iterator(self):
        return self

    def reset(self):
        pass

    def dispose(self):
        pass
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_NullRowReader._instance is None):
            com_sdtk_table_NullRowReader._instance = com_sdtk_table_NullRowReader()
        return com_sdtk_table_NullRowReader._instance


class com_sdtk_table_NullRowWriter(com_sdtk_table_DataTableRowWriter):

    def __init__(self):
        super().__init__()
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_NullRowWriter._instance is None):
            com_sdtk_table_NullRowWriter._instance = com_sdtk_table_NullRowWriter()
        return com_sdtk_table_NullRowWriter._instance


class com_sdtk_table_NullWriter(com_sdtk_table_DataTableWriter):

    def __init__(self):
        super().__init__()

    def start(self):
        pass

    def writeStartI(self,name,index,rowWriter):
        return com_sdtk_table_NullRowWriter.instance()

    def flip(self):
        return com_sdtk_table_NullReader.instance()

    def dispose(self):
        pass
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_NullWriter._instance is None):
            com_sdtk_table_NullWriter._instance = com_sdtk_table_NullWriter()
        return com_sdtk_table_NullWriter._instance


class com_sdtk_table_ObjectOfArraysReader(com_sdtk_table_DataTableReader):

    def __init__(self,o):
        self._iterator = None
        self._o = None
        super().__init__()
        self._o = o
        self._iterator = haxe_iterators_ArrayIterator(python_Boot.fields(self._o))

    def hasNext(self):
        return self._iterator.hasNext()

    def nextReuse(self,rowReader):
        field = self._iterator.next()
        self._value = Reflect.field(self._o,field)
        if (rowReader is None):
            rowReader = com_sdtk_table_ArrayRowReader.readWholeArray(self._value)
        else:
            rr = rowReader
            com_sdtk_table_ArrayRowReader.readWholeArrayReuse(self._value,rr)
        self.incrementTo(field,rowReader,(self._index + 1))
        return rowReader

    def next(self):
        return self.nextReuse(None)

    def iterator(self):
        return com_sdtk_table_ObjectOfArraysReader(self._o)

    def flip(self):
        return com_sdtk_table_ObjectOfArraysWriter.writeToWholeObject(self._o)

    def reset(self):
        self._iterator = haxe_iterators_ArrayIterator(python_Boot.fields(self._o))
        super().reset()

    @staticmethod
    def readWholeObject(o):
        return com_sdtk_table_ObjectOfArraysReader(o)


class com_sdtk_table_ObjectOfArraysWriter(com_sdtk_table_DataTableWriter):

    def __init__(self,o):
        self._iterator = None
        self._o = None
        super().__init__()
        self.reuse(o)

    def reuse(self,o):
        self._o = o
        self._iterator = haxe_iterators_ArrayIterator(python_Boot.fields(self._o))

    def start(self):
        pass

    def writeStartI(self,name,index,rowWriter):
        field = self._iterator.next()
        value = list()
        return com_sdtk_table_ArrayRowWriter.writeToExpandableArrayReuse(value,rowWriter)

    def flip(self):
        return com_sdtk_table_ObjectOfArraysReader.readWholeObject(self._o)

    def dispose(self):
        if (self._o is not None):
            self._o = None
            self._iterator = None

    @staticmethod
    def writeToWholeObject(o):
        return com_sdtk_table_ObjectOfArraysWriter(o)


class com_sdtk_table_ObjectOfObjectsReader(com_sdtk_table_DataTableReader):

    def __init__(self,o):
        self._iterator = None
        self._o = None
        super().__init__()
        self._o = o
        self._iterator = haxe_iterators_ArrayIterator(python_Boot.fields(self._o))

    def hasNext(self):
        return self._iterator.hasNext()

    def nextReuse(self,rowReader):
        field = self._iterator.next()
        self._value = Reflect.field(self._o,field)
        if (rowReader is None):
            rowReader = com_sdtk_table_ObjectRowReader.readWholeObject(self._value)
        else:
            rr = rowReader
            com_sdtk_table_ObjectRowReader.readWholeObjectReuse(self._value,rr)
        self.incrementTo(field,rowReader,(self._index + 1))
        return rowReader

    def next(self):
        return self.nextReuse(None)

    def iterator(self):
        return com_sdtk_table_ObjectOfObjectsReader(self._o)

    def flip(self):
        return com_sdtk_table_ObjectOfObjectsWriter.writeToWholeObject(self._o,None)

    def reset(self):
        self._iterator = haxe_iterators_ArrayIterator(python_Boot.fields(self._o))
        super().reset()

    @staticmethod
    def readWholeObject(o):
        return com_sdtk_table_ObjectOfObjectsReader(o)


class com_sdtk_table_ObjectOfObjectsWriter(com_sdtk_table_DataTableWriter):

    def __init__(self,o,constructor):
        self._constructor = None
        self._iterator = None
        self._o = None
        super().__init__()
        self.reuse(o,constructor)

    def reuse(self,o,constructor):
        self._o = o
        self._iterator = haxe_iterators_ArrayIterator(python_Boot.fields(self._o))
        self._constructor = constructor

    def start(self):
        pass

    def writeStartI(self,name,index,rowWriter):
        field = self._iterator.next()
        value = self._constructor(field,self._written)
        rowWriter1 = com_sdtk_table_ObjectRowWriter.continueWriteReuse(value,None,None,rowWriter)
        return rowWriter1

    def flip(self):
        return com_sdtk_table_ObjectOfObjectsReader.readWholeObject(self._o)

    def dispose(self):
        if (self._o is not None):
            self._o = None
            self._iterator = None
            self._constructor = None

    @staticmethod
    def writeToWholeObject(o,constructor):
        def _hx_local_1():
            def _hx_local_0(name,index):
                return constructor()
            return com_sdtk_table_ObjectOfObjectsWriter(o,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def writeToWholeObjectWithField(o,constructor):
        def _hx_local_1():
            def _hx_local_0(name,index):
                return constructor(name)
            return com_sdtk_table_ObjectOfObjectsWriter(o,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def writeToWholeObjectWithIndex(o,constructor):
        def _hx_local_1():
            def _hx_local_0(name,index):
                return constructor(index)
            return com_sdtk_table_ObjectOfObjectsWriter(o,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def writeToWholeObjectWithFieldAndIndex(o,constructor):
        return com_sdtk_table_ObjectOfObjectsWriter(o,constructor)


class com_sdtk_table_ObjectReader(com_sdtk_table_DataTableReader):

    def __init__(self,o):
        self._iterator = None
        self._o = None
        super().__init__()
        self._o = o
        self._iterator = haxe_iterators_ArrayIterator(python_Boot.fields(self._o))

    def hasNext(self):
        return self._iterator.hasNext()

    def nextReuse(self,rowReader):
        if (rowReader is None):
            rowReader = com_sdtk_table_ObjectRowReader.continueRead(self._o,self._iterator)
        else:
            rr = rowReader
            rr.reuse(self._o,self._iterator)
        self._value = rowReader
        return rowReader

    def next(self):
        return self.nextReuse(None)

    def iterator(self):
        return com_sdtk_table_ObjectReader(self._o)

    def flip(self):
        return com_sdtk_table_ObjectWriter.writeToWholeObject(self._o,None,None)

    def reset(self):
        self._iterator = haxe_iterators_ArrayIterator(python_Boot.fields(self._o))
        super().reset()

    @staticmethod
    def readWholeObject(o):
        return com_sdtk_table_ObjectReader(o)


class com_sdtk_table_ObjectRowReader(com_sdtk_table_DataTableRowReader):

    def __init__(self,o,iterator):
        self._o = None
        self._fields = None
        self._iterator = None
        self._i = None
        super().__init__()
        self.reuse(o,iterator)

    def reuse(self,o,iterator):
        if (iterator is None):
            if (self._fields is None):
                self._fields = python_Boot.fields(o)
            self._iterator = haxe_iterators_ArrayIterator(self._fields)
        else:
            self._iterator = iterator
        self._o = o
        self._i = 0
        self._started = False
        self._index = -1
        self._rawIndex = -1
        self._started = False
        self._value = None

    def hasNext(self):
        return self._iterator.hasNext()

    def next(self):
        field = self._iterator.next()
        self._value = Reflect.field(self._o,field)
        self.incrementTo(field,self._value,self._i)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._i
        _hx_local_0._i = (_hx_local_1 + 1)
        _hx_local_0._i
        return self._value

    def iterator(self):
        return self

    def reset(self):
        self._i = 0

    def dispose(self):
        if (self._iterator is not None):
            self._iterator = None
            self._o = None

    @staticmethod
    def continueRead(o,iterator):
        return com_sdtk_table_ObjectRowReader(o,iterator)

    @staticmethod
    def readWholeObject(o):
        return com_sdtk_table_ObjectRowReader.readWholeObjectReuse(o,None)

    @staticmethod
    def readWholeObjectReuse(o,rowReader):
        if (rowReader is None):
            rowReader = com_sdtk_table_ObjectRowReader(o,None)
        else:
            rowReader.reuse(o,None)
        return rowReader


class com_sdtk_table_ObjectRowWriter(com_sdtk_table_DataTableRowWriter):

    def __init__(self,o,keyField,valueField):
        self._fields = None
        self._got = None
        self._valueCurrent = None
        self._keyCurrent = None
        self._valueField = None
        self._keyField = None
        self._o = None
        super().__init__()
        self._fields = haxe_ds_StringMap()
        _g = 0
        _g1 = python_Boot.fields(o)
        while (_g < len(_g1)):
            field = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self._fields.h[field] = field
        self.reuse(o,keyField,valueField)

    def reuse(self,o,keyField,valueField):
        self._o = o
        self._keyField = keyField
        self._valueField = valueField
        self._keyCurrent = None
        self._valueCurrent = None
        self._got = 0

    def write(self,data,name,index):
        if (self._o is not None):
            if (self._keyField is None):
                if (self._fields.h.get(name,None) is not None):
                    setattr(self._o,(("_hx_" + name) if ((name in python_Boot.keywords)) else (("_hx_" + name) if (((((len(name) > 2) and ((ord(name[0]) == 95))) and ((ord(name[1]) == 95))) and ((ord(name[(len(name) - 1)]) != 95)))) else name)),data)
            else:
                if (name == self._keyField):
                    self._keyCurrent = data
                    _hx_local_0 = self
                    _hx_local_1 = _hx_local_0._got
                    _hx_local_0._got = (_hx_local_1 + 1)
                    _hx_local_1
                elif (name == self._valueField):
                    self._valueCurrent = data
                    _hx_local_2 = self
                    _hx_local_3 = _hx_local_2._got
                    _hx_local_2._got = (_hx_local_3 + 1)
                    _hx_local_3
                if (self._got == 2):
                    field = self._keyCurrent
                    value = self._valueCurrent
                    setattr(self._o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)
                    self._got = 0

    def reset(self):
        pass

    def dispose(self):
        if (self._o is not None):
            self._o = None
            self._keyField = None
            self._valueField = None
            self._keyCurrent = None
            self._valueCurrent = None
            self._got = 0

    @staticmethod
    def continueWrite(o,keyField,valueField):
        return com_sdtk_table_ObjectRowWriter.continueWriteReuse(o,keyField,valueField,None)

    @staticmethod
    def continueWriteReuse(o,keyField,valueField,rowWriter):
        if (rowWriter is None):
            rowWriter = com_sdtk_table_ObjectRowWriter(o,keyField,valueField)
        else:
            rowWriter.reuse(o,keyField,valueField)
        return rowWriter


class com_sdtk_table_ObjectWriter(com_sdtk_table_DataTableWriter):

    def __init__(self,o,keyField,valueField):
        self._valueField = None
        self._keyField = None
        self._o = None
        super().__init__()
        self.reuse(o,keyField,valueField)

    def reuse(self,o,keyField,valueField):
        self._o = o
        self._keyField = keyField
        self._valueField = valueField

    def start(self):
        pass

    def writeStartI(self,name,index,rowWriter):
        rowWriter1 = com_sdtk_table_ObjectRowWriter.continueWriteReuse(self._o,self._keyField,self._valueField,rowWriter)
        return rowWriter1

    def flip(self):
        return com_sdtk_table_ObjectReader.readWholeObject(self._o)

    def dispose(self):
        if (self._o is not None):
            self._o = None
            self._keyField = None
            self._valueField = None

    @staticmethod
    def writeToWholeObject(o,keyField,valueField):
        return com_sdtk_table_ObjectWriter(o,keyField,valueField)


class com_sdtk_table_PSVInfo:

    def __init__(self):
        pass

    def fileStart(self):
        return ""

    def fileEnd(self):
        return ""

    def delimiter(self):
        return "|"

    def rowDelimiter(self):
        return "\n"

    def boolStart(self):
        return ""

    def boolEnd(self):
        return ""

    def stringStart(self):
        return "\""

    def stringEnd(self):
        return "\""

    def intStart(self):
        return ""

    def intEnd(self):
        return ""

    def floatStart(self):
        return ""

    def floatEnd(self):
        return ""

    def replacements(self):
        return ["\\\\", "\\", "\\\n", "\n", "\\\t", "\t", "\\\r", "\r"]

    def replacementIndicator(self):
        return "\\"

    def widthMinimum(self):
        return -1

    def widthMaximum(self):
        return -1
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_PSVInfo._instance is None):
            com_sdtk_table_PSVInfo._instance = com_sdtk_table_PSVInfo()
        return com_sdtk_table_PSVInfo._instance


class com_sdtk_table_Parameters(com_sdtk_std_Parameters):

    def __init__(self):
        self._sortRowsBy = None
        self._filterColumnsInclude = None
        self._filterRowsInclude = None
        self._filterColumnsExclude = None
        self._filterRowsExclude = None
        self._input = None
        self._output = None
        self._outputOptions = None
        self._inputOptions = None
        self._rightTrim = False
        self._leftTrim = False
        self._recordPass = False
        self._verbose = False
        self._runInTestMode = False
        super().__init__()
        i = 0
        sParameter = None
        sLocations = list()
        while True:
            sParameter = self.getParameter(i)
            if (sParameter is not None):
                _g = sParameter.upper()
                _hx_local_0 = len(_g)
                if (_hx_local_0 == 15):
                    if (_g == "CREATEORREPLACE"):
                        self._outputOptions = com_sdtk_table_Parameters.setValue(self._outputOptions,"sqlType","CreateOrReplace")
                        i = (i + 1)
                        self._outputOptions = com_sdtk_table_Parameters.setValue(self._outputOptions,"tableName",self.getParameter(i))
                    else:
                        sLocations.append(sParameter)
                elif (_hx_local_0 == 10):
                    if (_g == "RECORDPASS"):
                        self._recordPass = True
                    else:
                        sLocations.append(sParameter)
                elif (_hx_local_0 == 11):
                    if (_g == "EXCLUDEROWS"):
                        i = (i + 1)
                        self._filterRowsExclude = self.getParameter(i)
                    elif (_g == "INCLUDEROWS"):
                        i = (i + 1)
                        self._filterRowsInclude = self.getParameter(i)
                    else:
                        sLocations.append(sParameter)
                elif (_hx_local_0 == 9):
                    if (_g == "RIGHTTRIM"):
                        self._rightTrim = True
                    else:
                        sLocations.append(sParameter)
                elif (_hx_local_0 == 4):
                    if (_g == "TRIM"):
                        self._leftTrim = True
                        self._rightTrim = True
                    else:
                        sLocations.append(sParameter)
                elif (_hx_local_0 == 13):
                    if (_g == "EXCLUDEHEADER"):
                        if (len(sLocations) == 1):
                            self._inputOptions = com_sdtk_table_Parameters.setValue(self._inputOptions,"header",False)
                        elif (len(sLocations) == 2):
                            self._outputOptions = com_sdtk_table_Parameters.setValue(self._outputOptions,"header",False)
                    else:
                        sLocations.append(sParameter)
                elif (_hx_local_0 == 7):
                    if (_g == "ORDERBY"):
                        i = (i + 1)
                        self._sortRowsBy = self.getParameter(i)
                    elif (_g == "PROFILE"):
                        com_sdtk_table_Stopwatch.setDefaultActual(True)
                    elif (_g == "RUNTIME"):
                        com_sdtk_table_Stopwatch.setActual("Converter")
                    elif (_g == "VERBOSE"):
                        self._verbose = True
                    elif (_g == "VERSION"):
                        self.printVersion()
                    else:
                        sLocations.append(sParameter)
                elif (_hx_local_0 == 8):
                    if (_g == "LEFTTRIM"):
                        self._leftTrim = True
                    elif (_g == "RUNTESTS"):
                        self._runInTestMode = True
                    elif (_g == "TEXTONLY"):
                        if (len(sLocations) == 1):
                            self._inputOptions = com_sdtk_table_Parameters.setValue(self._inputOptions,"textOnly",True)
                        elif (len(sLocations) == 2):
                            self._outputOptions = com_sdtk_table_Parameters.setValue(self._outputOptions,"textOnly",True)
                    else:
                        sLocations.append(sParameter)
                elif (_hx_local_0 == 14):
                    if (_g == "EXCLUDECOLUMNS"):
                        i = (i + 1)
                        self._filterColumnsExclude = self.getParameter(i)
                    elif (_g == "INCLUDECOLUMNS"):
                        i = (i + 1)
                        self._filterColumnsInclude = self.getParameter(i)
                    else:
                        sLocations.append(sParameter)
                elif (_hx_local_0 == 6):
                    if (_g == "CREATE"):
                        self._outputOptions = com_sdtk_table_Parameters.setValue(self._outputOptions,"sqlType","Create")
                        i = (i + 1)
                        self._outputOptions = com_sdtk_table_Parameters.setValue(self._outputOptions,"tableName",self.getParameter(i))
                    elif (_g == "INSERT"):
                        self._outputOptions = com_sdtk_table_Parameters.setValue(self._outputOptions,"sqlType","Insert")
                        i = (i + 1)
                        self._outputOptions = com_sdtk_table_Parameters.setValue(self._outputOptions,"tableName",self.getParameter(i))
                    else:
                        sLocations.append(sParameter)
                else:
                    sLocations.append(sParameter)
            i = (i + 1)
            if (not ((sParameter is not None))):
                break
        _g = len(sLocations)
        if (_g == 0):
            pass
        elif (_g == 1):
            self.setInput((sLocations[0] if 0 < len(sLocations) else None))
        elif (_g == 2):
            self.setInput((sLocations[0] if 0 < len(sLocations) else None))
            self.setOutput((sLocations[1] if 1 < len(sLocations) else None))
        else:
            raise haxe_Exception.thrown("More than two files specified.  This indicates that the tool was run improperly.")

    def fullPrint(self):
        self.printName()
        self.printVersion()
        self.printDetails()

    def printName(self):
        _hx_str = "Simple Data Toolkit - Simple Table Converter"
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))

    def printVersion(self):
        _hx_str = Std.string(("Version " + HxOverrides.stringOrNull(com_sdtk_std_Version.get())))
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))

    def printDetails(self):
        _hx_str = "Copyright (C) 2019 Vis LLC - All Rights Reserved"
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        _hx_str = ""
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        _hx_str = "Project Home - https://sourceforge.net/projects/simple-data-toolkit/"
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        _hx_str = ""
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        _hx_str = "This program is free software: you can redistribute it and/or modify"
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        _hx_str = "it under the terms of the GNU Lesser General Public License as published by"
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        _hx_str = "the Free Software Foundation, either version 3 of the License, or"
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        _hx_str = "(at your option) any later version."
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        _hx_str = ""
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        _hx_str = "This program is distributed in the hope that it will be useful,"
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        _hx_str = "but WITHOUT ANY WARRANTY; without even the implied warranty of"
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        _hx_str = "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the"
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        _hx_str = "GNU General Public License for more details."
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        _hx_str = ""
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        _hx_str = "You should have received a copy of the GNU Lesser General Public License"
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        _hx_str = "along with this program.  If not, see <https://www.gnu.org/licenses/>."
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))

    def print(self,s):
        _hx_str = Std.string(s)
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))

    def getType(self,sLocation):
        startIndex = None
        iDot = (sLocation.find(".") if ((startIndex is None)) else HxString.indexOfImpl(sLocation,".",startIndex))
        startIndex = None
        iHash = (sLocation.find("#") if ((startIndex is None)) else HxString.indexOfImpl(sLocation,"#",startIndex))
        if ((iDot == 0) or ((iHash == 0))):
            return 0
        elif (iDot > 0):
            return 1
        else:
            return -1

    def setInput(self,sLocation):
        _g = self.getType(sLocation)
        if (_g == 0):
            self._input = sLocation
        elif (_g == 1):
            self._input = sLocation
        else:
            pass

    def setOutput(self,sLocation):
        _g = self.getType(sLocation)
        if (_g == 0):
            self._output = sLocation
        elif (_g == 1):
            self._output = sLocation
        else:
            pass

    def getRunInTestMode(self):
        return self._runInTestMode

    def getRecordPass(self):
        return self._recordPass

    def getVerbose(self):
        return self._verbose

    def getOutput(self):
        return self._output

    def getInput(self):
        return self._input

    def getOutputFormat(self):
        return com_sdtk_table_Parameters.getFormat(self.getOutput())

    def getInputFormat(self):
        return com_sdtk_table_Parameters.getFormat(self.getInput())

    def getFilterRowsExclude(self):
        return self._filterRowsExclude

    def getFilterRowsInclude(self):
        return self._filterRowsInclude

    def getFilterColumnsExclude(self):
        return self._filterColumnsExclude

    def getFilterColumnsInclude(self):
        return self._filterColumnsInclude

    def getSortRowsBy(self):
        return self._sortRowsBy

    def getLeftTrim(self):
        return self._leftTrim

    def getRightTrim(self):
        return self._rightTrim

    def getInputOptions(self):
        return self._inputOptions

    def getOutputOptions(self):
        return self._outputOptions

    @staticmethod
    def setValue(options,key,value):
        if (options is None):
            options = haxe_ds_StringMap()
        options.h[key] = value
        return options

    @staticmethod
    def endsWith(s,t):
        s1 = len(s)
        startIndex = None
        tmp = None
        if (startIndex is None):
            tmp = s.rfind(t, 0, len(s))
        elif (t == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            tmp = (length if ((startIndex > length)) else startIndex)
        else:
            i = s.rfind(t, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(t))) if ((i == -1)) else (i + 1))
            check = s.find(t, startLeft, len(s))
            tmp = (check if (((check > i) and ((check <= startIndex)))) else i)
        return ((s1 - tmp) == len(t))

    @staticmethod
    def getFormat(sName):
        if ((sName is None) or ((len(sName) <= 0))):
            return com_sdtk_table_Format.CSV
        sName = sName.lower()
        startIndex = None
        pos = None
        if (startIndex is None):
            pos = sName.rfind(".", 0, len(sName))
        else:
            i = sName.rfind(".", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("."))) if ((i == -1)) else (i + 1))
            check = sName.find(".", startLeft, len(sName))
            pos = (check if (((check > i) and ((check <= startIndex)))) else i)
        _g = HxString.substr(sName,pos,None)
        _hx_local_0 = len(_g)
        if (_hx_local_0 == 11):
            if (_g == ".properties"):
                return com_sdtk_table_Format.PROPERTIES
            else:
                startIndex = None
                if (((sName.find("dbtype=") if ((startIndex is None)) else HxString.indexOfImpl(sName,"dbtype=",startIndex))) >= 0):
                    return com_sdtk_table_Format.DB
                return None
        elif (_hx_local_0 == 4):
            if (_g == ".csv"):
                return com_sdtk_table_Format.CSV
            elif (_g == ".ini"):
                return com_sdtk_table_Format.INI
            elif (_g == ".psv"):
                return com_sdtk_table_Format.PSV
            elif (_g == ".sql"):
                return com_sdtk_table_Format.SQL
            elif (_g == ".tex"):
                return com_sdtk_table_Format.TEX
            elif (_g == ".tsv"):
                return com_sdtk_table_Format.TSV
            elif (_g == ".txt"):
                return com_sdtk_table_Format.RAW
            else:
                startIndex = None
                if (((sName.find("dbtype=") if ((startIndex is None)) else HxString.indexOfImpl(sName,"dbtype=",startIndex))) >= 0):
                    return com_sdtk_table_Format.DB
                return None
        elif (_hx_local_0 == 5):
            if (_g == ".html"):
                return com_sdtk_table_Format.HTMLTable
            elif (_g == ".java"):
                return com_sdtk_table_Format.Java
            elif (_g == ".json"):
                return com_sdtk_table_Format.JSON
            else:
                startIndex = None
                if (((sName.find("dbtype=") if ((startIndex is None)) else HxString.indexOfImpl(sName,"dbtype=",startIndex))) >= 0):
                    return com_sdtk_table_Format.DB
                return None
        elif (_hx_local_0 == 3):
            if (_g == ".cs"):
                return com_sdtk_table_Format.CSharp
            elif (_g == ".hx"):
                return com_sdtk_table_Format.Haxe
            elif (_g == ".py"):
                return com_sdtk_table_Format.Python
            else:
                startIndex = None
                if (((sName.find("dbtype=") if ((startIndex is None)) else HxString.indexOfImpl(sName,"dbtype=",startIndex))) >= 0):
                    return com_sdtk_table_Format.DB
                return None
        else:
            startIndex = None
            if (((sName.find("dbtype=") if ((startIndex is None)) else HxString.indexOfImpl(sName,"dbtype=",startIndex))) >= 0):
                return com_sdtk_table_Format.DB
            return None


class com_sdtk_table_PropertiesHandler:

    def __init__(self):
        pass

    def favorReadAll(self):
        return True

    def oneRowPerFile(self):
        return True

    def read(self,rReader):
        rReader = rReader.switchToLineReader()
        mMap = haxe_ds_StringMap()
        while rReader.hasNext():
            sLine = rReader.peek()
            sFirst = ("" if ((0 >= len(sLine))) else sLine[0])
            if ((sFirst == "!") or ((sFirst == "#"))):
                rReader.next()
                continue
            else:
                startIndex = None
                iIndex1 = (sLine.find("=") if ((startIndex is None)) else HxString.indexOfImpl(sLine,"=",startIndex))
                startIndex1 = None
                iIndex2 = (sLine.find(":") if ((startIndex1 is None)) else HxString.indexOfImpl(sLine,":",startIndex1))
                iIndexFinal = (iIndex2 if ((iIndex1 < 0)) else (iIndex1 if ((iIndex2 < 0)) else (iIndex1 if ((iIndex1 < iIndex2)) else iIndex2)))
                key = com_sdtk_table_PropertiesHandler.convertFrom(StringTools.trim(HxString.substr(sLine,0,iIndexFinal)),None)
                value = com_sdtk_table_PropertiesHandler.convertFrom(StringTools.ltrim(HxString.substr(sLine,(iIndexFinal + 1),None)),rReader)
                mMap.h[key] = value
                rReader.next()
        return mMap

    def write(self,wWriter,mMap,name,index):
        wWriter = wWriter.switchToLineWriter()
        key = mMap.keys()
        while key.hasNext():
            key1 = key.next()
            value = mMap.h.get(key1,None)
            wWriter.write((((HxOverrides.stringOrNull(com_sdtk_table_PropertiesHandler.convertTo(key1)) + "=") + HxOverrides.stringOrNull(com_sdtk_table_PropertiesHandler.convertTo(Std.string(value)))) + "\n"))

    def writeEnd(self,wWriter,lastName,lastIndex):
        pass

    def readAll(self,rReader,aMaps,aNames):
        x = self.read(rReader)
        aMaps.append(x)
        aNames.append("")

    def writeAll(self,wWriter,aMaps,aNames):
        self.write(wWriter,(aMaps[0] if 0 < len(aMaps) else None),None,0)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_PropertiesHandler._instance is None):
            com_sdtk_table_PropertiesHandler._instance = com_sdtk_table_PropertiesHandler()
        return com_sdtk_table_PropertiesHandler._instance

    @staticmethod
    def convertFrom(sValue,rReader):
        sValue = StringTools.replace(sValue,"\\\\","\\")
        sValue = StringTools.replace(sValue,"\\ "," ")
        if (rReader is not None):
            while sValue.endswith("\\"):
                sValue = HxString.substr(sValue,0,(len(sValue) - 1))
                if rReader.hasNext():
                    rReader.next()
                    sValue = (("null" if sValue is None else sValue) + HxOverrides.stringOrNull(rReader.peek()))
                else:
                    break
        if sValue.endswith("\n"):
            sValue = HxString.substr(sValue,0,(len(sValue) - 1))
        return sValue

    @staticmethod
    def convertTo(sValue):
        sValue = StringTools.replace(sValue,"\\","\\\\")
        sValue = StringTools.replace(sValue," ","\\ ")
        sValue = StringTools.replace(sValue,"\n","\\\n")
        return sValue


class com_sdtk_table_PythonInfoAbstract:

    def __init__(self):
        pass

    def start(self):
        return ""

    def end(self):
        return ""

    def arrayStart(self):
        return "["

    def arrayEnd(self):
        return "]"

    def mapStart(self):
        return "{"

    def mapEnd(self):
        return "}"

    def rowStart(self,name,index):
        return ""

    def rowEnd(self):
        return ""

    def betweenRows(self):
        return ","

    def mapRowEnd(self):
        return "}"

    def arrayRowEnd(self):
        return ""

    def arrayRowStart(self,name,index):
        return ""

    def mapRowStart(self,name,index):
        if ((name is not None) and ((name != ""))):
            return (("\"" + ("null" if name is None else name)) + "\": ")
        else:
            return (Std.string(index) + ": ")

    def mapIntEntry(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return ((("\"" + ("null" if name is None else name)) + "\": ") + Std.string(data))
        else:
            return ((Std.string(index) + ": ") + Std.string(data))

    def mapBoolEntry(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return ((("\"" + ("null" if name is None else name)) + "\": ") + Std.string(data))
        else:
            return ((Std.string(index) + ": ") + Std.string(data))

    def mapFloatEntry(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return ((("\"" + ("null" if name is None else name)) + "\": ") + Std.string(data))
        else:
            return ((Std.string(index) + ": ") + Std.string(data))

    def mapOtherEntry(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return (((("\"" + ("null" if name is None else name)) + "\": \"") + ("null" if data is None else data)) + "\"")
        else:
            return (((Std.string(index) + ": \"") + ("null" if data is None else data)) + "\"")

    def mapNullEntry(self,name,index):
        if ((name is not None) and ((name != ""))):
            return (("\"" + ("null" if name is None else name)) + "\": None")
        else:
            return (Std.string(index) + ": None")

    def arrayIntEntry(self,data,name,index):
        return Std.string(data)

    def arrayBoolEntry(self,data,name,index):
        return Std.string(data)

    def arrayFloatEntry(self,data,name,index):
        return Std.string(data)

    def arrayOtherEntry(self,data,name,index):
        return (("\"" + ("null" if data is None else data)) + "\"")

    def arrayNullEntry(self,name,index):
        return "None"

    def intEntry(self,data,name,index):
        return None

    def boolEntry(self,data,name,index):
        return None

    def floatEntry(self,data,name,index):
        return None

    def otherEntry(self,data,name,index):
        return None

    def nullEntry(self,name,index):
        return None

    def betweenEntries(self):
        return ","

    def replacements(self):
        return ["\\\"", "\"", "\\\n", "\n", "\\\t", "\t"]


class com_sdtk_table_PythonInfoArrayOfArrays(com_sdtk_table_PythonInfoAbstract):

    def __init__(self):
        super().__init__()

    def start(self):
        return self.arrayStart()

    def end(self):
        return self.arrayEnd()

    def rowEnd(self):
        return self.arrayEnd()

    def rowStart(self,name,index):
        return (HxOverrides.stringOrNull(self.arrayRowStart(name,index)) + HxOverrides.stringOrNull(self.arrayStart()))

    def intEntry(self,data,name,index):
        return self.arrayIntEntry(data,name,index)

    def boolEntry(self,data,name,index):
        return self.arrayBoolEntry(data,name,index)

    def floatEntry(self,data,name,index):
        return self.arrayFloatEntry(data,name,index)

    def otherEntry(self,data,name,index):
        return self.arrayOtherEntry(data,name,index)

    def nullEntry(self,name,index):
        return self.arrayNullEntry(name,index)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_PythonInfoArrayOfArrays._instance is None):
            com_sdtk_table_PythonInfoArrayOfArrays._instance = com_sdtk_table_PythonInfoArrayOfArrays()
        return com_sdtk_table_PythonInfoArrayOfArrays._instance


class com_sdtk_table_PythonInfoArrayOfMaps(com_sdtk_table_PythonInfoAbstract):

    def __init__(self):
        super().__init__()

    def start(self):
        return self.arrayStart()

    def end(self):
        return self.arrayEnd()

    def rowEnd(self):
        return self.mapEnd()

    def rowStart(self,name,index):
        return (HxOverrides.stringOrNull(self.arrayRowStart(name,index)) + HxOverrides.stringOrNull(self.mapStart()))

    def intEntry(self,data,name,index):
        return self.mapIntEntry(data,name,index)

    def boolEntry(self,data,name,index):
        return self.mapBoolEntry(data,name,index)

    def floatEntry(self,data,name,index):
        return self.mapFloatEntry(data,name,index)

    def otherEntry(self,data,name,index):
        return self.mapOtherEntry(data,name,index)

    def nullEntry(self,name,index):
        return self.mapNullEntry(name,index)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_PythonInfoArrayOfMaps._instance is None):
            com_sdtk_table_PythonInfoArrayOfMaps._instance = com_sdtk_table_PythonInfoArrayOfMaps()
        return com_sdtk_table_PythonInfoArrayOfMaps._instance


class com_sdtk_table_PythonInfoMapOfArrays(com_sdtk_table_PythonInfoAbstract):

    def __init__(self):
        super().__init__()

    def start(self):
        return self.mapStart()

    def end(self):
        return self.mapEnd()

    def rowEnd(self):
        return self.arrayEnd()

    def rowStart(self,name,index):
        return (HxOverrides.stringOrNull(self.mapRowStart(name,index)) + HxOverrides.stringOrNull(self.arrayStart()))

    def intEntry(self,data,name,index):
        return self.arrayIntEntry(data,name,index)

    def boolEntry(self,data,name,index):
        return self.arrayBoolEntry(data,name,index)

    def floatEntry(self,data,name,index):
        return self.arrayFloatEntry(data,name,index)

    def otherEntry(self,data,name,index):
        return self.arrayOtherEntry(data,name,index)

    def nullEntry(self,name,index):
        return self.arrayNullEntry(name,index)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_PythonInfoMapOfArrays._instance is None):
            com_sdtk_table_PythonInfoMapOfArrays._instance = com_sdtk_table_PythonInfoMapOfArrays()
        return com_sdtk_table_PythonInfoMapOfArrays._instance


class com_sdtk_table_PythonInfoMapOfMaps(com_sdtk_table_PythonInfoAbstract):

    def __init__(self):
        super().__init__()

    def start(self):
        return self.mapStart()

    def end(self):
        return self.mapEnd()

    def rowEnd(self):
        return self.mapEnd()

    def rowStart(self,name,index):
        return (HxOverrides.stringOrNull(self.mapRowStart(name,index)) + HxOverrides.stringOrNull(self.mapStart()))

    def intEntry(self,data,name,index):
        return self.mapIntEntry(data,name,index)

    def boolEntry(self,data,name,index):
        return self.mapBoolEntry(data,name,index)

    def floatEntry(self,data,name,index):
        return self.mapFloatEntry(data,name,index)

    def otherEntry(self,data,name,index):
        return self.mapOtherEntry(data,name,index)

    def nullEntry(self,name,index):
        return self.mapNullEntry(name,index)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_PythonInfoMapOfMaps._instance is None):
            com_sdtk_table_PythonInfoMapOfMaps._instance = com_sdtk_table_PythonInfoMapOfMaps()
        return com_sdtk_table_PythonInfoMapOfMaps._instance


class com_sdtk_table_RAWInfo:

    def __init__(self):
        pass

    def fileStart(self):
        return ""

    def fileEnd(self):
        return ""

    def delimiter(self):
        return ""

    def rowDelimiter(self):
        return "\n"

    def boolStart(self):
        return ""

    def boolEnd(self):
        return ""

    def stringStart(self):
        return ""

    def stringEnd(self):
        return ""

    def intStart(self):
        return ""

    def intEnd(self):
        return ""

    def floatStart(self):
        return ""

    def floatEnd(self):
        return ""

    def replacements(self):
        return []

    def replacementIndicator(self):
        return None

    def widthMinimum(self):
        return 1

    def widthMaximum(self):
        return 1
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_RAWInfo._instance is None):
            com_sdtk_table_RAWInfo._instance = com_sdtk_table_RAWInfo()
        return com_sdtk_table_RAWInfo._instance


class com_sdtk_table_RowFilterDataTableReader(com_sdtk_table_DataTableReader):

    def __init__(self,dtrReader,fFilter):
        self._buffer2 = None
        self._bufferReaderPrevious = None
        self._bufferReader = None
        self._buffer = None
        self._reader = None
        self._filter = None
        self._switch = 0
        super().__init__()
        self._filter = fFilter
        self._reader = dtrReader
        self._buffer = list()
        self._buffer2 = list()

    def startI(self):
        self._reader.start()
        self.check(True)

    def check(self,reuse):
        rowReader = self._reader.next()
        if (rowReader is not None):
            self._bufferReader = None
            while ((rowReader is not None) and ((self._bufferReader is None))):
                rowReader.start()
                row = rowReader.next()
                if (self._filter.filter(row) is not None):
                    buffer = None
                    if (self._switch == 0):
                        buffer = self._buffer
                    else:
                        buffer = self._buffer2
                    while (len(buffer) > 0):
                        if (len(buffer) != 0):
                            buffer.pop()
                    buffer.append(row)
                    while rowReader.hasNext():
                        x = rowReader.next()
                        buffer.append(x)
                    if (reuse or ((self._bufferReaderPrevious is None))):
                        self._bufferReader = com_sdtk_table_ArrayRowReader.readWholeArrayReuse(buffer,self._bufferReaderPrevious)
                    else:
                        self._bufferReader = com_sdtk_table_ArrayRowReader.readWholeArray(buffer)
                else:
                    while rowReader.hasNext():
                        rowReader.next()
                    rowReader = self._reader.next()
        else:
            self._bufferReader = None
            self.dispose()

    def dispose(self):
        if (self._reader is not None):
            super().dispose()
            self._filter = None
            self._reader = None
            self._buffer = None
            self._bufferReader = None
            self._bufferReaderPrevious = None

    def hasNext(self):
        return (self._buffer is not None)

    def nextI(self,reuse):
        current = self._bufferReader
        if (self._switch == 0):
            self._switch = 122
        else:
            self._switch = 0
        self.incrementTo(self._reader.name(),current,self._reader.rawIndex())
        self.check(reuse)
        self._bufferReaderPrevious = current
        return current

    def nextReuse(self,rowReader):
        return self.nextI(True)

    def next(self):
        return self.nextI(False)

    def isAutoNamed(self):
        return self._reader.isAutoNamed()

    def isNameIndex(self):
        return self._reader.isNameIndex()

    def headerRowNotIncluded(self):
        return self._reader.headerRowNotIncluded()

    def reset(self):
        self._reader.reset()


class com_sdtk_table_SQLSelectInfo:

    def __init__(self):
        self._nameQuote = "\""
        self._appendEnd = ""
        self._appendBeginning = ""

    def start(self):
        return self._appendBeginning

    def end(self):
        return self._appendEnd

    def rowStart(self,name,index):
        return "SELECT "

    def betweenRows(self):
        return "\nUNION ALL\n"

    def rowEnd(self):
        return "\nFROM dual"

    def intEntry(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return ((((Std.string(data) + " AS ") + HxOverrides.stringOrNull(self._nameQuote)) + ("null" if name is None else name)) + HxOverrides.stringOrNull(self._nameQuote))
        else:
            return Std.string(data)

    def boolEntry(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return ((((Std.string(data) + " AS ") + HxOverrides.stringOrNull(self._nameQuote)) + ("null" if name is None else name)) + HxOverrides.stringOrNull(self._nameQuote))
        else:
            return Std.string(data)

    def floatEntry(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return ((((Std.string(data) + " AS ") + HxOverrides.stringOrNull(self._nameQuote)) + ("null" if name is None else name)) + HxOverrides.stringOrNull(self._nameQuote))
        else:
            return Std.string(data)

    def otherEntry(self,data,name,index):
        if ((name is not None) and ((name != ""))):
            return ((((("'" + ("null" if data is None else data)) + "' AS ") + HxOverrides.stringOrNull(self._nameQuote)) + ("null" if name is None else name)) + HxOverrides.stringOrNull(self._nameQuote))
        else:
            return (("'" + ("null" if data is None else data)) + "'")

    def nullEntry(self,name,index):
        if ((name is not None) and ((name != ""))):
            return (("null AS \"" + ("null" if name is None else name)) + "\"")
        else:
            return "null"

    def betweenEntries(self):
        return ","

    def replacements(self):
        return ["''", "'"]

    def namesUseSingleQuote(self,value):
        nameQuote = ("'" if value else "\"")
        if (self._nameQuote == nameQuote):
            return self
        else:
            info = com_sdtk_table_SQLSelectInfo()
            info._appendBeginning = self._appendBeginning
            info._appendEnd = self._appendEnd
            info._nameQuote = nameQuote
            return info
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_SQLSelectInfo._instance is None):
            com_sdtk_table_SQLSelectInfo._instance = com_sdtk_table_SQLSelectInfo()
        return com_sdtk_table_SQLSelectInfo._instance

    @staticmethod
    def createTable(name):
        info = com_sdtk_table_SQLSelectInfo()
        info._appendBeginning = (("CREATE TABLE " + ("null" if name is None else name)) + " AS\n")
        info._appendEnd = ";"
        return info

    @staticmethod
    def createOrReplaceTable(name):
        info = com_sdtk_table_SQLSelectInfo()
        info._appendBeginning = (("CREATE OR REPLACE TABLE " + ("null" if name is None else name)) + " AS\n")
        info._appendEnd = ";"
        return info

    @staticmethod
    def insertIntoTable(name):
        info = com_sdtk_table_SQLSelectInfo()
        info._appendBeginning = (("INSERT INTO " + ("null" if name is None else name)) + "\n")
        info._appendEnd = ";"
        return info


class com_sdtk_table_SplunkHandler:

    def __init__(self):
        pass

    def favorReadAll(self):
        return True

    def oneRowPerFile(self):
        return False

    def read(self,rReader):
        i = 0
        rReader = rReader.switchToLineReader()
        mMap = haxe_ds_StringMap()
        _this = rReader.next()
        sLine = _this.split(" ")
        _g = 0
        while (_g < len(sLine)):
            sPart = (sLine[_g] if _g >= 0 and _g < len(sLine) else None)
            _g = (_g + 1)
            startIndex = None
            iIndex = (sPart.find("=") if ((startIndex is None)) else HxString.indexOfImpl(sPart,"=",startIndex))
            if (iIndex > 0):
                sKey = HxString.substr(sPart,0,iIndex)
                sValue = HxString.substr(sPart,(iIndex + 1),None)
                mMap.h[sKey] = sValue
            else:
                key = Std.string(i)
                mMap.h[key] = sPart
        return mMap

    def write(self,wWriter,mMap,name,index):
        sbStart_b = python_lib_io_StringIO()
        sbBuffer = StringBuf()
        wWriter = wWriter.switchToLineWriter()
        key = mMap.keys()
        while key.hasNext():
            key1 = key.next()
            value = mMap.h.get(key1,None)
            if (Std.parseInt(key1) is not None):
                sbStart_b.write(Std.string(value))
                sbStart_b.write(" ")
            else:
                s = Std.string(key1)
                sbBuffer.b.write(s)
                sbBuffer.b.write("=")
                s1 = Std.string(com_sdtk_table_SplunkHandler.convertTo(Std.string(value)))
                sbBuffer.b.write(s1)
                sbBuffer.b.write(" ")
        sbStart_b.write(Std.string(sbBuffer))
        sbStart_b.write("\n")
        wWriter.write(sbStart_b.getvalue())

    def writeEnd(self,wWriter,lastName,lastIndex):
        pass

    def readAll(self,rReader,aMaps,aNames):
        rReader = rReader.switchToLineReader()
        while rReader.hasNext():
            x = self.read(rReader)
            aMaps.append(x)
            aNames.append("")

    def writeAll(self,wWriter,aMaps,aNames):
        i = 0
        wWriter = wWriter.switchToLineWriter()
        while (i < len(aMaps)):
            aMaps1 = i
            i = (i + 1)
            self.write(wWriter,(aMaps[aMaps1] if aMaps1 >= 0 and aMaps1 < len(aMaps) else None),None,0)
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_SplunkHandler._instance is None):
            com_sdtk_table_SplunkHandler._instance = com_sdtk_table_SplunkHandler()
        return com_sdtk_table_SplunkHandler._instance

    @staticmethod
    def convertTo(sValue):
        sValue = StringTools.replace(sValue," ","")
        sValue = StringTools.replace(sValue,"\t","")
        sValue = StringTools.replace(sValue,"\n","")
        sValue = StringTools.replace(sValue,"\r","")
        return sValue


class com_sdtk_table_TableInfo:
    pass


class com_sdtk_table_StandardTableInfo:

    def __init__(self):
        pass

    def Tag(self):
        return ["table"]

    def HeaderRow(self):
        return ["tr"]

    def HeaderCell(self):
        return ["th", "td"]

    def Row(self):
        return ["tr"]

    def Cell(self):
        return ["td"]

    def RowNumber(self,i,e):
        pass

    def RowName(self,i,e):
        pass

    def ColumnNumber(self,i,e):
        pass

    def ColumnName(self,i,e):
        pass

    def setData(self,data,e):
        pass

    def FormatTableStart(self,writer):
        writer.write("<")
        writer.write(python_internal_ArrayImpl._get(self.Tag(), 0))
        writer.write(">")

    def FormatTableEnd(self,writer):
        writer.write("</")
        writer.write(python_internal_ArrayImpl._get(self.Tag(), 0))
        writer.write(">")

    def FormatRowStart(self,writer,header,i,n,rowCache,globalCache):
        writer.write("<")
        writer.write((python_internal_ArrayImpl._get(self.HeaderRow(), 0) if header else python_internal_ArrayImpl._get(self.Row(), 0)))
        writer.write(" RowNumber=")
        writer.write(Std.string(i))
        writer.write(" RowName=\"")
        writer.write(self.replacementName(n,rowCache))
        writer.write("\">")

    def FormatRowEnd(self,writer,header):
        writer.write("</")
        writer.write((python_internal_ArrayImpl._get(self.HeaderRow(), 0) if header else python_internal_ArrayImpl._get(self.Row(), 0)))
        writer.write(">")

    def FormatCell(self,writer,header,c,cn,r,rn,data,rowCache,globalCache):
        writer.write("<")
        writer.write((python_internal_ArrayImpl._get(self.HeaderCell(), 0) if header else python_internal_ArrayImpl._get(self.Cell(), 0)))
        writer.write(" ColumnNumber=")
        writer.write(Std.string(c))
        writer.write(" ColumnName=\"")
        writer.write(self.replacementName(cn,globalCache))
        writer.write("\" RowNumber=")
        writer.write(Std.string(r))
        writer.write(" RowName=\"")
        writer.write(self.replacementName(rn,rowCache))
        writer.write("\">")
        writer.write(self.replacementData(Std.string(data)))
        writer.write("</")
        writer.write((python_internal_ArrayImpl._get(self.HeaderCell(), 0) if header else python_internal_ArrayImpl._get(self.Cell(), 0)))
        writer.write(">")

    def replacementsName(self):
        return ["&amp;", "&", "&lt;", "<", "&quot;", "\""]

    def replacementsData(self):
        return ["&amp;", "&", "&lt;", "<"]

    def replacementName(self,data,cache):
        if (data is None):
            return None
        result = cache.h.get(data,None)
        if (result is None):
            result = data
            replacements = self.replacementsName()
            if (((replacements is not None) and ((len(replacements) > 0))) and ((result is not None))):
                replaceI = 1
                while (replaceI < len(replacements)):
                    result = StringTools.replace(result,(replacements[replaceI] if replaceI >= 0 and replaceI < len(replacements) else None),python_internal_ArrayImpl._get(replacements, (replaceI - 1)))
                    replaceI = (replaceI + 2)
            cache.h[data] = result
        return result

    def replacementData(self,data):
        replacements = self.replacementsData()
        if (((replacements is not None) and ((len(replacements) > 0))) and ((data is not None))):
            replaceI = 1
            while (replaceI < len(replacements)):
                data = StringTools.replace(data,(replacements[replaceI] if replaceI >= 0 and replaceI < len(replacements) else None),python_internal_ArrayImpl._get(replacements, (replaceI - 1)))
                replaceI = (replaceI + 2)
        return data
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_StandardTableInfo._instance is None):
            com_sdtk_table_StandardTableInfo._instance = com_sdtk_table_StandardTableInfo()
        return com_sdtk_table_StandardTableInfo._instance


class com_sdtk_table_TSVInfo:

    def __init__(self):
        pass

    def fileStart(self):
        return ""

    def fileEnd(self):
        return ""

    def delimiter(self):
        return "\t"

    def rowDelimiter(self):
        return "\n"

    def boolStart(self):
        return ""

    def boolEnd(self):
        return ""

    def stringStart(self):
        return "\""

    def stringEnd(self):
        return "\""

    def intStart(self):
        return ""

    def intEnd(self):
        return ""

    def floatStart(self):
        return ""

    def floatEnd(self):
        return ""

    def replacements(self):
        return ["\\\\", "\\", "\\\n", "\n", "\\\t", "\t", "\\\r", "\r"]

    def replacementIndicator(self):
        return "\\"

    def widthMinimum(self):
        return -1

    def widthMaximum(self):
        return -1
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_TSVInfo._instance is None):
            com_sdtk_table_TSVInfo._instance = com_sdtk_table_TSVInfo()
        return com_sdtk_table_TSVInfo._instance


class com_sdtk_table_TableRowReaderI:
    pass


class com_sdtk_table_TableDataRowReaderI(com_sdtk_table_AbstractTableReader):

    def __init__(self,tdInfo,oElement):
        super().__init__(tdInfo,oElement)

    def elementCheck(self,oElement):
        return False

    def getValue(self,oElement):
        return None


class com_sdtk_table_TableFirstRowWriter(com_sdtk_table_AbstractTableRowWriter):

    def __init__(self,tdInfo,writer,sHeader):
        super().__init__(tdInfo,writer,sHeader)

    def write(self,data,name,index):
        _this = self._header
        _this.append(data)
        self._writer.writeCell(False,data,name,index)


class com_sdtk_table_TableHeaderRowReaderI(com_sdtk_table_AbstractTableReader):

    def __init__(self,tdInfo,oElement):
        super().__init__(tdInfo,oElement)

    def elementCheck(self,oElement):
        return False

    def getValue(self,oElement):
        return None


class com_sdtk_table_TableHeaderRowWriter(com_sdtk_table_AbstractTableRowWriter):

    def __init__(self,tdInfo,oElement,sHeader):
        super().__init__(tdInfo,oElement,sHeader)

    def write(self,data,name,index):
        self._writer.writeCell(True,data,name,index)


class com_sdtk_table_TableReader(com_sdtk_table_DataTableReader):

    def __init__(self,tdInfo,oElement):
        self._header = None
        self._reader = None
        super().__init__()
        self._reader = com_sdtk_table_TableReaderI(tdInfo,oElement)
        self._index = -1
        self._header = list()

    def hasNext(self):
        return self._reader.hasNext()

    def nextReuse(self,rowReader):
        if self._reader.hasNext():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0._index
            _hx_local_0._index = (_hx_local_1 + 1)
            _hx_local_1
            self._name = self._reader.peek()
            if (rowReader is None):
                rowReader = com_sdtk_table_TableRowReader(self._reader.next(),self._header)
            else:
                rr = rowReader
                rr.reuse(self._reader.next(),self._header)
            self._value = rowReader
        else:
            self._value = None
            return None
        return rowReader

    def next(self):
        return self.nextReuse(None)

    def dispose(self):
        self._reader = None
        self._header = None

    def reset(self):
        pass

    @staticmethod
    def createStandardTableReader(oElement):
        return com_sdtk_table_TableReader(com_sdtk_table_StandardTableInfo.instance(),oElement)


class com_sdtk_table_TableReaderI(com_sdtk_table_AbstractTableReader):

    def __init__(self,tdInfo,oElement):
        super().__init__(tdInfo,oElement)

    def elementCheck(self,oElement):
        return False

    def getValue(self,oElement):
        bHasHeader = False
        if bHasHeader:
            return com_sdtk_table_TableHeaderRowReaderI(self._info,oElement)
        else:
            return com_sdtk_table_TableDataRowReaderI(self._info,oElement)


class com_sdtk_table_TableRowReader(com_sdtk_table_DataTableRowReader):

    def __init__(self,trReader,aHeader):
        self._header = None
        self._isHeader = None
        self._reader = None
        super().__init__()
        self.reuse(trReader,aHeader)

    def reuse(self,trReader,aHeader):
        self._isHeader = (Type.getClass(trReader) == com_sdtk_table_TableHeaderRowReaderI)
        self._header = aHeader
        self._reader = trReader
        self._index = -1
        self._started = False
        self._value = None

    def hasNext(self):
        return self._reader.hasNext()

    def next(self):
        if self._reader.hasNext():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0._index
            _hx_local_0._index = (_hx_local_1 + 1)
            _hx_local_1
            if self._isHeader:
                self._name = self._reader.peek()
                _this = self._header
                x = self._name
                _this.append(x)
            else:
                self._name = python_internal_ArrayImpl._get(self._header, self._index)
            return self._reader.next()
        else:
            return None

    def dispose(self):
        self._reader = None
        self._header = None


class com_sdtk_table_TableRowWriter(com_sdtk_table_AbstractTableRowWriter):

    def __init__(self,tdInfo,writer,sHeader):
        super().__init__(tdInfo,writer,sHeader)

    def write(self,data,name,index):
        self._writer.writeCell(False,data,name,index)


class com_sdtk_table_TableWriter(com_sdtk_table_DataTableWriter):

    def __init__(self,tdInfo,oElement = None):
        self._rowName = None
        self._row = None
        self._info = None
        self._rowCache = haxe_ds_StringMap()
        self._globalCache = haxe_ds_StringMap()
        self._done = False
        self._header = list()
        super().__init__()
        self._info = tdInfo
        self._header = list()
        self._row = -1
        self._rowName = None

    def start(self):
        self.tableStart()

    def tableStart(self):
        pass

    def tableEnd(self):
        pass

    def tableRowStart(self,header,index,name):
        pass

    def tableRowEndI(self,header):
        pass

    def writeCell(self,header,data,name,index):
        pass

    def tableRowEnd(self):
        if (self._row > 1):
            self.tableRowEndI(False)
        elif (self._row == 0):
            self.tableRowEndI(True)

    def writeStartI(self,name,index,rowWriter):
        if (not self._done):
            self.tableRowEnd()
            self.tableRowStart((index == 0),index,name)
            self._row = index
            self._rowName = name
            index1 = index
            if (index1 == 0):
                rowWriter = com_sdtk_table_TableHeaderRowWriter(self._info,self,self._header)
            elif (index1 == 1):
                rowWriter = com_sdtk_table_TableFirstRowWriter(self._info,self,self._header)
            elif (index1 == 2):
                rowWriter = com_sdtk_table_TableRowWriter(self._info,self,self._header)
            elif (rowWriter is None):
                rowWriter = com_sdtk_table_TableRowWriter(self._info,self,self._header)
            else:
                rw = rowWriter
                rw.reuse(self._info,self,self._header)
            return rowWriter
        else:
            return None

    def disposeI(self):
        pass

    def dispose(self):
        if (not self._done):
            self.tableRowEnd()
            self.tableEnd()
            self.disposeI()
            self._header = None
            self._info = None
            self._row = -1
            self._rowName = None
            self._globalCache = None
            self._rowCache = None
            self._done = True

    @staticmethod
    def createStandardTableWriterForElement(oElement):
        return com_sdtk_table_TableWriterElement(com_sdtk_table_StandardTableInfo.instance(),oElement)

    @staticmethod
    def createStandardTableWriterForWriter(wWriter):
        return com_sdtk_table_TableWriterString(com_sdtk_table_StandardTableInfo.instance(),wWriter)


class com_sdtk_table_TableWriterString(com_sdtk_table_TableWriter):

    def __init__(self,tdInfo,writer):
        self._writer = None
        super().__init__(tdInfo)
        self._writer = writer

    def tableStart(self):
        if (not self._done):
            self._info.FormatTableStart(self._writer)

    def tableEnd(self):
        if (not self._done):
            self._info.FormatTableEnd(self._writer)

    def tableRowStart(self,header,index,name):
        if (not self._done):
            self._info.FormatRowStart(self._writer,header,index,name,self._rowCache,self._globalCache)

    def tableRowEndI(self,header):
        if (not self._done):
            self._info.FormatRowEnd(self._writer,header)
            self._rowCache = haxe_ds_StringMap()

    def disposeI(self):
        self._writer.dispose()
        self._writer = None

    def writeCell(self,header,data,name,index):
        if (not self._done):
            self._info.FormatCell(self._writer,header,index,name,self._row,self._rowName,data,self._rowCache,self._globalCache)

    def writeHeaderFirst(self):
        return True


class com_sdtk_table_TableWriterElement(com_sdtk_table_TableWriter):

    def __init__(self,tdInfo,oElement = None):
        self._tableElement = None
        self._element = None
        super().__init__(tdInfo)
        self._element = oElement

    def tableStart(self):
        pass

    def tableRowStart(self,header,index,name):
        oRow = None

    def writeHeader(self):
        self.tableRowStart(True,0,"")
        return com_sdtk_table_TableHeaderRowWriter(self._info,self,self._header)

    def disposeI(self):
        if (len(self._header) > 0):
            dtrwWriter = self.writeHeader()
            try:
                i = 0
                _g = 0
                _g1 = self._header
                while (_g < len(_g1)):
                    cell = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    tmp = i
                    i = (i + 1)
                    dtrwWriter.write(cell,cell,tmp)
            except BaseException as _g:
                None
            dtrwWriter.dispose()
        self._element = None

    def writeCell(self,header,data,name,index):
        pass


class com_sdtk_table_TallyInfo:

    def __init__(self):
        self._entries = 0
        self._size = 0
        self._count = 0

    def add(self,iCount,iSize):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._count
        _hx_local_0._count = (_hx_local_1 + iCount)
        _hx_local_0._count
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._size
        _hx_local_2._size = (_hx_local_3 + iSize)
        _hx_local_2._size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._entries
        _hx_local_4._entries = (_hx_local_5 + 1)
        _hx_local_5

    def getNumberOfEntries(self):
        return self._entries

    def getFileSize(self):
        return self._size

    def getFileCount(self):
        return self._count

    def getFreeSpace(self):
        return -1


class com_sdtk_table_TeXInfo:

    def __init__(self):
        pass

    def fileStart(self):
        return "\\begin{tabular}"

    def fileEnd(self):
        return "\\end{tabular}"

    def delimiter(self):
        return "&"

    def rowDelimiter(self):
        return "\\\\\\hline"

    def boolStart(self):
        return ""

    def boolEnd(self):
        return ""

    def stringStart(self):
        return "\\makecell{"

    def stringEnd(self):
        return "}"

    def intStart(self):
        return ""

    def intEnd(self):
        return ""

    def floatStart(self):
        return ""

    def floatEnd(self):
        return ""

    def replacements(self):
        return ["\\\\", "\\", "\\\n", "\n", "\\\t", "\t", "\\\r", "\r"]

    def replacementIndicator(self):
        return "\\"

    def widthMinimum(self):
        return -1

    def widthMaximum(self):
        return -1
    _instance = None

    @staticmethod
    def instance():
        if (com_sdtk_table_TeXInfo._instance is None):
            com_sdtk_table_TeXInfo._instance = com_sdtk_table_TeXInfo()
        return com_sdtk_table_TeXInfo._instance


class com_sdtk_table_Tests:

    @staticmethod
    def runTests(recordPass,verbose):
        results = ""
        results = com_sdtk_table_Tests.addResult(results,com_sdtk_table_Tests.testCSVToPSV(recordPass,verbose))
        results = com_sdtk_table_Tests.addResult(results,com_sdtk_table_Tests.testExcludeColumns(recordPass,verbose))
        results = com_sdtk_table_Tests.addResult(results,com_sdtk_table_Tests.testExcludeRows(recordPass,verbose))
        results = com_sdtk_table_Tests.addResult(results,com_sdtk_table_Tests.testIncludeColumns(recordPass,verbose))
        results = com_sdtk_table_Tests.addResult(results,com_sdtk_table_Tests.testIncludeRows(recordPass,verbose))
        results = com_sdtk_table_Tests.addResult(results,com_sdtk_table_Tests.testOrderBy(recordPass,verbose))
        return results

    @staticmethod
    def addResult(sum,test):
        if (test is None):
            return sum
        else:
            return ((("null" if sum is None else sum) + ("null" if test is None else test)) + "\n")

    @staticmethod
    def compareResults(recordPass,verbose,sTest,sExpected,sGot):
        sGot = StringTools.trim(sGot)
        sExpected = StringTools.trim(sExpected)
        if (sGot != sExpected):
            if verbose:
                return ((((((((((("null" if sTest is None else sTest) + ": ") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sFAILED)) + "\n") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sEXPECTED)) + ":\n") + ("null" if sExpected is None else sExpected)) + "\n") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sGOT)) + ":\n") + ("null" if sGot is None else sGot))
            else:
                return ((("null" if sTest is None else sTest) + ": ") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sFAILED))
        elif recordPass:
            if verbose:
                return ((((((((((("null" if sTest is None else sTest) + ": ") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sPASSED)) + "\n") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sEXPECTED)) + ":\n") + ("null" if sExpected is None else sExpected)) + "\n") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sGOT)) + ":\n") + ("null" if sGot is None else sGot))
            else:
                return ((("null" if sTest is None else sTest) + ": ") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sPASSED))
        else:
            return None

    @staticmethod
    def testCSVToPSV(recordPass,verbose):
        sTest = "testCSVToPSV"
        sPSV = StringTools.replace(com_sdtk_table_Tests.sCSV,",","|")
        sbBuffer = StringBuf()
        try:
            com_sdtk_table_Converter.convertWithOptions(com_sdtk_table_Tests.sCSV,com_sdtk_table_Format.CSV,sbBuffer,com_sdtk_table_Format.PSV,None,None,None,None,None,False,False,None,None)
            return com_sdtk_table_Tests.compareResults(recordPass,verbose,sTest,sPSV,StringTools.replace(sbBuffer.b.getvalue(),"\"",""))
        except BaseException as _g:
            None
            msg = haxe_Exception.caught(_g).unwrap()
            if verbose:
                return ((((((("null" if sTest is None else sTest) + ": ") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sFAILED)) + "\n") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sEXCEPTION)) + ":\n") + Std.string(msg))
            else:
                return ((("null" if sTest is None else sTest) + ": ") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sFAILED))

    @staticmethod
    def testExcludeColumns(recordPass,verbose):
        sTest = "testExcludeColumns"
        sExcluded = "A,C\n5,7\n1,3\n8,5"
        sbBuffer = StringBuf()
        try:
            com_sdtk_table_Converter.convertWithOptions(com_sdtk_table_Tests.sCSV,com_sdtk_table_Format.CSV,sbBuffer,com_sdtk_table_Format.CSV,"B",None,None,None,None,False,False,None,None)
            return com_sdtk_table_Tests.compareResults(recordPass,verbose,sTest,sExcluded,StringTools.replace(sbBuffer.b.getvalue(),"\"",""))
        except BaseException as _g:
            None
            msg = haxe_Exception.caught(_g).unwrap()
            if verbose:
                return ((((((("null" if sTest is None else sTest) + ": ") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sFAILED)) + "\n") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sEXCEPTION)) + ":\n") + Std.string(msg))
            else:
                return ((("null" if sTest is None else sTest) + ": ") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sFAILED))

    @staticmethod
    def testExcludeRows(recordPass,verbose):
        sTest = "testExcludeRows"
        sExcluded = "A,B,C\n1,2,3\n8,1,5"
        sbBuffer = StringBuf()
        try:
            com_sdtk_table_Converter.convertWithOptions(com_sdtk_table_Tests.sCSV,com_sdtk_table_Format.CSV,sbBuffer,com_sdtk_table_Format.CSV,None,None,"#2",None,None,False,False,None,None)
            return com_sdtk_table_Tests.compareResults(recordPass,verbose,sTest,sExcluded,StringTools.replace(sbBuffer.b.getvalue(),"\"",""))
        except BaseException as _g:
            None
            msg = haxe_Exception.caught(_g).unwrap()
            if verbose:
                return ((((((("null" if sTest is None else sTest) + ": ") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sFAILED)) + "\n") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sEXCEPTION)) + ":\n") + Std.string(msg))
            else:
                return ((("null" if sTest is None else sTest) + ": ") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sFAILED))

    @staticmethod
    def testIncludeColumns(recordPass,verbose):
        sTest = "testIncludeColumns"
        sIncluded = "B\n6\n2\n1"
        sbBuffer = StringBuf()
        try:
            com_sdtk_table_Converter.convertWithOptions(com_sdtk_table_Tests.sCSV,com_sdtk_table_Format.CSV,sbBuffer,com_sdtk_table_Format.CSV,None,"B",None,None,None,False,False,None,None)
            return com_sdtk_table_Tests.compareResults(recordPass,verbose,sTest,sIncluded,StringTools.replace(sbBuffer.b.getvalue(),"\"",""))
        except BaseException as _g:
            None
            msg = haxe_Exception.caught(_g).unwrap()
            if verbose:
                return ((((((("null" if sTest is None else sTest) + ": ") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sFAILED)) + "\n") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sEXCEPTION)) + ":\n") + Std.string(msg))
            else:
                return ((("null" if sTest is None else sTest) + ": ") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sFAILED))

    @staticmethod
    def testIncludeRows(recordPass,verbose):
        sTest = "testIncludeRows"
        sExcluded = "5,6,7"
        sbBuffer = StringBuf()
        try:
            com_sdtk_table_Converter.convertWithOptions(com_sdtk_table_Tests.sCSV,com_sdtk_table_Format.CSV,sbBuffer,com_sdtk_table_Format.CSV,None,None,None,"#2",None,False,False,None,None)
            return com_sdtk_table_Tests.compareResults(recordPass,verbose,sTest,sExcluded,StringTools.replace(sbBuffer.b.getvalue(),"\"",""))
        except BaseException as _g:
            None
            msg = haxe_Exception.caught(_g).unwrap()
            if verbose:
                return ((((((("null" if sTest is None else sTest) + ": ") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sFAILED)) + "\n") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sEXCEPTION)) + ":\n") + Std.string(msg))
            else:
                return ((("null" if sTest is None else sTest) + ": ") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sFAILED))

    @staticmethod
    def testOrderBy(recordPass,verbose):
        sTest = "testOrderBy"
        sOrdered = "A,B,C\n1,2,3\n8,1,5\n5,6,7"
        sbBuffer = StringBuf()
        try:
            com_sdtk_table_Converter.convertWithOptions(com_sdtk_table_Tests.sCSV,com_sdtk_table_Format.CSV,sbBuffer,com_sdtk_table_Format.CSV,None,None,None,None,"C",False,False,None,None)
            return com_sdtk_table_Tests.compareResults(recordPass,verbose,sTest,sOrdered,StringTools.replace(sbBuffer.b.getvalue(),"\"",""))
        except BaseException as _g:
            None
            msg = haxe_Exception.caught(_g).unwrap()
            if verbose:
                return ((((((("null" if sTest is None else sTest) + ": ") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sFAILED)) + "\n") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sEXCEPTION)) + ":\n") + Std.string(msg))
            else:
                return ((("null" if sTest is None else sTest) + ": ") + HxOverrides.stringOrNull(com_sdtk_table_Tests.sFAILED))


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    __slots__ = ()
haxe_IMap._hx_class = haxe_IMap


class haxe_Exception(Exception):
    _hx_class_name = "haxe.Exception"
    __slots__ = ("_hx___nativeStack", "_hx___skipStack", "_hx___nativeException", "_hx___previousException")
    _hx_fields = ["__nativeStack", "__skipStack", "__nativeException", "__previousException"]
    _hx_methods = ["unwrap", "toString", "get_message", "get_native"]
    _hx_statics = ["caught", "thrown"]
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,message,previous = None,native = None):
        self._hx___previousException = None
        self._hx___nativeException = None
        self._hx___nativeStack = None
        self._hx___skipStack = 0
        super().__init__(message)
        self._hx___previousException = previous
        if ((native is not None) and Std.isOfType(native,BaseException)):
            self._hx___nativeException = native
            self._hx___nativeStack = haxe_NativeStackTrace.exceptionStack()
        else:
            self._hx___nativeException = self
            infos = python_lib_Traceback.extract_stack()
            if (len(infos) != 0):
                infos.pop()
            infos.reverse()
            self._hx___nativeStack = infos

    def unwrap(self):
        return self._hx___nativeException

    def toString(self):
        return self.get_message()

    def get_message(self):
        return str(self)

    def get_native(self):
        return self._hx___nativeException

    @staticmethod
    def caught(value):
        if Std.isOfType(value,haxe_Exception):
            return value
        elif Std.isOfType(value,BaseException):
            return haxe_Exception(str(value),None,value)
        else:
            return haxe_ValueException(value,None,value)

    @staticmethod
    def thrown(value):
        if Std.isOfType(value,haxe_Exception):
            return value.get_native()
        elif Std.isOfType(value,BaseException):
            return value
        else:
            e = haxe_ValueException(value)
            e._hx___skipStack = (e._hx___skipStack + 1)
            return e

haxe_Exception._hx_class = haxe_Exception


class haxe_NativeStackTrace:
    _hx_class_name = "haxe.NativeStackTrace"
    __slots__ = ()
    _hx_statics = ["saveStack", "exceptionStack"]

    @staticmethod
    def saveStack(exception):
        pass

    @staticmethod
    def exceptionStack():
        exc = python_lib_Sys.exc_info()
        if (exc[2] is not None):
            infos = python_lib_Traceback.extract_tb(exc[2])
            infos.reverse()
            return infos
        else:
            return []
haxe_NativeStackTrace._hx_class = haxe_NativeStackTrace


class haxe_ValueException(haxe_Exception):
    _hx_class_name = "haxe.ValueException"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["unwrap"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,value,previous = None,native = None):
        self.value = None
        super().__init__(("null" if ((value is None)) else Std.string(value)),previous,native)
        self.value = value

    def unwrap(self):
        return self.value

haxe_ValueException._hx_class = haxe_ValueException


class haxe_ds_IntMap:
    _hx_class_name = "haxe.ds.IntMap"
    __slots__ = ()
    _hx_interfaces = [haxe_IMap]
haxe_ds_IntMap._hx_class = haxe_ds_IntMap


class haxe_ds_ObjectMap:
    _hx_class_name = "haxe.ds.ObjectMap"
    __slots__ = ()
    _hx_interfaces = [haxe_IMap]
haxe_ds_ObjectMap._hx_class = haxe_ds_ObjectMap


class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["keys", "iterator"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def iterator(self):
        return python_HaxeIterator(iter(self.h.values()))

haxe_ds_StringMap._hx_class = haxe_ds_StringMap


class haxe_ds_WeakMap:
    _hx_class_name = "haxe.ds.WeakMap"
    __slots__ = ()
    _hx_interfaces = [haxe_IMap]
haxe_ds_WeakMap._hx_class = haxe_ds_WeakMap


class haxe_exceptions_PosException(haxe_Exception):
    _hx_class_name = "haxe.exceptions.PosException"
    __slots__ = ("posInfos",)
    _hx_fields = ["posInfos"]
    _hx_methods = ["toString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,message,previous = None,pos = None):
        self.posInfos = None
        super().__init__(message,previous)
        if (pos is None):
            self.posInfos = _hx_AnonObject({'fileName': "(unknown)", 'lineNumber': 0, 'className': "(unknown)", 'methodName': "(unknown)"})
        else:
            self.posInfos = pos

    def toString(self):
        return ((((((((("" + HxOverrides.stringOrNull(super().toString())) + " in ") + HxOverrides.stringOrNull(self.posInfos.className)) + ".") + HxOverrides.stringOrNull(self.posInfos.methodName)) + " at ") + HxOverrides.stringOrNull(self.posInfos.fileName)) + ":") + Std.string(self.posInfos.lineNumber))

haxe_exceptions_PosException._hx_class = haxe_exceptions_PosException


class haxe_exceptions_NotImplementedException(haxe_exceptions_PosException):
    _hx_class_name = "haxe.exceptions.NotImplementedException"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_exceptions_PosException


    def __init__(self,message = None,previous = None,pos = None):
        if (message is None):
            message = "Not implemented"
        super().__init__(message,previous,pos)
haxe_exceptions_NotImplementedException._hx_class = haxe_exceptions_NotImplementedException


class haxe_format_JsonPrinter:
    _hx_class_name = "haxe.format.JsonPrinter"
    __slots__ = ("buf", "replacer", "indent", "pretty", "nind")
    _hx_fields = ["buf", "replacer", "indent", "pretty", "nind"]
    _hx_methods = ["write", "classString", "fieldsString", "quote"]
    _hx_statics = ["print"]

    def __init__(self,replacer,space):
        self.replacer = replacer
        self.indent = space
        self.pretty = (space is not None)
        self.nind = 0
        self.buf = StringBuf()

    def write(self,k,v):
        if (self.replacer is not None):
            v = self.replacer(k,v)
        _g = Type.typeof(v)
        tmp = _g.index
        if (tmp == 0):
            self.buf.b.write("null")
        elif (tmp == 1):
            _this = self.buf
            s = Std.string(v)
            _this.b.write(s)
        elif (tmp == 2):
            f = v
            v1 = (Std.string(v) if ((((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))) else "null")
            _this = self.buf
            s = Std.string(v1)
            _this.b.write(s)
        elif (tmp == 3):
            _this = self.buf
            s = Std.string(v)
            _this.b.write(s)
        elif (tmp == 4):
            self.fieldsString(v,python_Boot.fields(v))
        elif (tmp == 5):
            self.buf.b.write("\"<fun>\"")
        elif (tmp == 6):
            c = _g.params[0]
            if (c == str):
                self.quote(v)
            elif (c == list):
                v1 = v
                _this = self.buf
                s = "".join(map(chr,[91]))
                _this.b.write(s)
                _hx_len = len(v1)
                last = (_hx_len - 1)
                _g1 = 0
                _g2 = _hx_len
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    if (i > 0):
                        _this = self.buf
                        s = "".join(map(chr,[44]))
                        _this.b.write(s)
                    else:
                        _hx_local_0 = self
                        _hx_local_1 = _hx_local_0.nind
                        _hx_local_0.nind = (_hx_local_1 + 1)
                        _hx_local_1
                    if self.pretty:
                        _this1 = self.buf
                        s1 = "".join(map(chr,[10]))
                        _this1.b.write(s1)
                    if self.pretty:
                        v2 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                        _this2 = self.buf
                        s2 = Std.string(v2)
                        _this2.b.write(s2)
                    self.write(i,(v1[i] if i >= 0 and i < len(v1) else None))
                    if (i == last):
                        _hx_local_2 = self
                        _hx_local_3 = _hx_local_2.nind
                        _hx_local_2.nind = (_hx_local_3 - 1)
                        _hx_local_3
                        if self.pretty:
                            _this3 = self.buf
                            s3 = "".join(map(chr,[10]))
                            _this3.b.write(s3)
                        if self.pretty:
                            v3 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                            _this4 = self.buf
                            s4 = Std.string(v3)
                            _this4.b.write(s4)
                _this = self.buf
                s = "".join(map(chr,[93]))
                _this.b.write(s)
            elif (c == haxe_ds_StringMap):
                v1 = v
                o = _hx_AnonObject({})
                k = v1.keys()
                while k.hasNext():
                    k1 = k.next()
                    value = v1.h.get(k1,None)
                    setattr(o,(("_hx_" + k1) if ((k1 in python_Boot.keywords)) else (("_hx_" + k1) if (((((len(k1) > 2) and ((ord(k1[0]) == 95))) and ((ord(k1[1]) == 95))) and ((ord(k1[(len(k1) - 1)]) != 95)))) else k1)),value)
                v1 = o
                self.fieldsString(v1,python_Boot.fields(v1))
            elif (c == Date):
                v1 = v
                self.quote(v1.toString())
            else:
                self.classString(v)
        elif (tmp == 7):
            _g1 = _g.params[0]
            i = v.index
            v = Std.string(i)
            _this = self.buf
            s = Std.string(v)
            _this.b.write(s)
        elif (tmp == 8):
            self.buf.b.write("\"???\"")
        else:
            pass

    def classString(self,v):
        self.fieldsString(v,python_Boot.getInstanceFields(Type.getClass(v)))

    def fieldsString(self,v,fields):
        _this = self.buf
        s = "".join(map(chr,[123]))
        _this.b.write(s)
        _hx_len = len(fields)
        last = (_hx_len - 1)
        first = True
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            f = (fields[i] if i >= 0 and i < len(fields) else None)
            value = Reflect.field(v,f)
            if Reflect.isFunction(value):
                continue
            if first:
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.nind
                _hx_local_0.nind = (_hx_local_1 + 1)
                _hx_local_1
                first = False
            else:
                _this = self.buf
                s = "".join(map(chr,[44]))
                _this.b.write(s)
            if self.pretty:
                _this1 = self.buf
                s1 = "".join(map(chr,[10]))
                _this1.b.write(s1)
            if self.pretty:
                v1 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                _this2 = self.buf
                s2 = Std.string(v1)
                _this2.b.write(s2)
            self.quote(f)
            _this3 = self.buf
            s3 = "".join(map(chr,[58]))
            _this3.b.write(s3)
            if self.pretty:
                _this4 = self.buf
                s4 = "".join(map(chr,[32]))
                _this4.b.write(s4)
            self.write(f,value)
            if (i == last):
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.nind
                _hx_local_2.nind = (_hx_local_3 - 1)
                _hx_local_3
                if self.pretty:
                    _this5 = self.buf
                    s5 = "".join(map(chr,[10]))
                    _this5.b.write(s5)
                if self.pretty:
                    v2 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                    _this6 = self.buf
                    s6 = Std.string(v2)
                    _this6.b.write(s6)
        _this = self.buf
        s = "".join(map(chr,[125]))
        _this.b.write(s)

    def quote(self,s):
        _this = self.buf
        s1 = "".join(map(chr,[34]))
        _this.b.write(s1)
        i = 0
        length = len(s)
        while (i < length):
            index = i
            i = (i + 1)
            c = ord(s[index])
            c1 = c
            if (c1 == 8):
                self.buf.b.write("\\b")
            elif (c1 == 9):
                self.buf.b.write("\\t")
            elif (c1 == 10):
                self.buf.b.write("\\n")
            elif (c1 == 12):
                self.buf.b.write("\\f")
            elif (c1 == 13):
                self.buf.b.write("\\r")
            elif (c1 == 34):
                self.buf.b.write("\\\"")
            elif (c1 == 92):
                self.buf.b.write("\\\\")
            else:
                _this = self.buf
                s1 = "".join(map(chr,[c]))
                _this.b.write(s1)
        _this = self.buf
        s = "".join(map(chr,[34]))
        _this.b.write(s)

    @staticmethod
    def print(o,replacer = None,space = None):
        printer = haxe_format_JsonPrinter(replacer,space)
        printer.write("",o)
        return printer.buf.b.getvalue()

haxe_format_JsonPrinter._hx_class = haxe_format_JsonPrinter


class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["blit", "getString", "toString"]
    _hx_statics = ["alloc", "ofString", "ofData"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    def blit(self,pos,src,srcpos,_hx_len):
        if (((((pos < 0) or ((srcpos < 0))) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))) or (((srcpos + _hx_len) > src.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        self.b[pos:pos+_hx_len] = src.b[srcpos:srcpos+_hx_len]

    def getString(self,pos,_hx_len,encoding = None):
        tmp = (encoding is None)
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        return self.b[pos:pos+_hx_len].decode('UTF-8','replace')

    def toString(self):
        return self.getString(0,self.length)

    @staticmethod
    def alloc(length):
        return haxe_io_Bytes(length,bytearray(length))

    @staticmethod
    def ofString(s,encoding = None):
        b = bytearray(s,"UTF-8")
        return haxe_io_Bytes(len(b),b)

    @staticmethod
    def ofData(b):
        return haxe_io_Bytes(len(b),b)

haxe_io_Bytes._hx_class = haxe_io_Bytes


class haxe_io_BytesBuffer:
    _hx_class_name = "haxe.io.BytesBuffer"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["getBytes"]

    def __init__(self):
        self.b = bytearray()

    def getBytes(self):
        _hx_bytes = haxe_io_Bytes(len(self.b),self.b)
        self.b = None
        return _hx_bytes

haxe_io_BytesBuffer._hx_class = haxe_io_BytesBuffer


class haxe_io_Output:
    _hx_class_name = "haxe.io.Output"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["writeByte", "writeBytes", "flush", "close", "set_bigEndian", "writeFullBytes", "writeString"]

    def writeByte(self,c):
        raise haxe_exceptions_NotImplementedException(None,None,_hx_AnonObject({'fileName': "haxe/io/Output.hx", 'lineNumber': 47, 'className': "haxe.io.Output", 'methodName': "writeByte"}))

    def writeBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        b = s.b
        k = _hx_len
        while (k > 0):
            self.writeByte(b[pos])
            pos = (pos + 1)
            k = (k - 1)
        return _hx_len

    def flush(self):
        pass

    def close(self):
        pass

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def writeFullBytes(self,s,pos,_hx_len):
        while (_hx_len > 0):
            k = self.writeBytes(s,pos,_hx_len)
            pos = (pos + k)
            _hx_len = (_hx_len - k)

    def writeString(self,s,encoding = None):
        b = haxe_io_Bytes.ofString(s,encoding)
        self.writeFullBytes(b,0,b.length)

haxe_io_Output._hx_class = haxe_io_Output

class haxe_io_Encoding(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Encoding"
    _hx_constructs = ["UTF8", "RawNative"]
haxe_io_Encoding.UTF8 = haxe_io_Encoding("UTF8", 0, ())
haxe_io_Encoding.RawNative = haxe_io_Encoding("RawNative", 1, ())
haxe_io_Encoding._hx_class = haxe_io_Encoding


class haxe_io_Eof:
    _hx_class_name = "haxe.io.Eof"
    __slots__ = ()
    _hx_methods = ["toString"]

    def __init__(self):
        pass

    def toString(self):
        return "Eof"

haxe_io_Eof._hx_class = haxe_io_Eof

class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"
    _hx_constructs = ["Blocked", "Overflow", "OutsideBounds", "Custom"]

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, (e,))
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, ())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, ())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, ())
haxe_io_Error._hx_class = haxe_io_Error


class haxe_io_Input:
    _hx_class_name = "haxe.io.Input"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["readByte", "readBytes", "close", "set_bigEndian", "readAll", "readFullBytes", "readLine", "readString"]

    def readByte(self):
        raise haxe_exceptions_NotImplementedException(None,None,_hx_AnonObject({'fileName': "haxe/io/Input.hx", 'lineNumber': 53, 'className': "haxe.io.Input", 'methodName': "readByte"}))

    def readBytes(self,s,pos,_hx_len):
        k = _hx_len
        b = s.b
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        try:
            while (k > 0):
                b[pos] = self.readByte()
                pos = (pos + 1)
                k = (k - 1)
        except BaseException as _g:
            None
            if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof)):
                raise _g
        return (_hx_len - k)

    def close(self):
        pass

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def readAll(self,bufsize = None):
        if (bufsize is None):
            bufsize = 16384
        buf = haxe_io_Bytes.alloc(bufsize)
        total = haxe_io_BytesBuffer()
        try:
            while True:
                _hx_len = self.readBytes(buf,0,bufsize)
                if (_hx_len == 0):
                    raise haxe_Exception.thrown(haxe_io_Error.Blocked)
                if ((_hx_len < 0) or ((_hx_len > buf.length))):
                    raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
                total.b.extend(buf.b[0:_hx_len])
        except BaseException as _g:
            None
            if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof)):
                raise _g
        return total.getBytes()

    def readFullBytes(self,s,pos,_hx_len):
        while (_hx_len > 0):
            k = self.readBytes(s,pos,_hx_len)
            if (k == 0):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            pos = (pos + k)
            _hx_len = (_hx_len - k)

    def readLine(self):
        buf = haxe_io_BytesBuffer()
        last = None
        s = None
        try:
            while True:
                last = self.readByte()
                if (not ((last != 10))):
                    break
                buf.b.append(last)
            s = buf.getBytes().toString()
            if (HxString.charCodeAt(s,(len(s) - 1)) == 13):
                s = HxString.substr(s,0,-1)
        except BaseException as _g:
            None
            _g1 = haxe_Exception.caught(_g).unwrap()
            if Std.isOfType(_g1,haxe_io_Eof):
                e = _g1
                s = buf.getBytes().toString()
                if (len(s) == 0):
                    raise haxe_Exception.thrown(e)
            else:
                raise _g
        return s

    def readString(self,_hx_len,encoding = None):
        b = haxe_io_Bytes.alloc(_hx_len)
        self.readFullBytes(b,0,_hx_len)
        return b.getString(0,_hx_len,encoding)

haxe_io_Input._hx_class = haxe_io_Input


class haxe_io_Path:
    _hx_class_name = "haxe.io.Path"
    __slots__ = ("dir", "file", "ext", "backslash")
    _hx_fields = ["dir", "file", "ext", "backslash"]
    _hx_methods = ["toString"]
    _hx_statics = ["addTrailingSlash"]

    def __init__(self,path):
        self.backslash = None
        self.ext = None
        self.file = None
        self.dir = None
        path1 = path
        _hx_local_0 = len(path1)
        if (_hx_local_0 == 1):
            if (path1 == "."):
                self.dir = path
                self.file = ""
                return
        elif (_hx_local_0 == 2):
            if (path1 == ".."):
                self.dir = path
                self.file = ""
                return
        else:
            pass
        startIndex = None
        c1 = None
        if (startIndex is None):
            c1 = path.rfind("/", 0, len(path))
        else:
            i = path.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = path.find("/", startLeft, len(path))
            c1 = (check if (((check > i) and ((check <= startIndex)))) else i)
        startIndex = None
        c2 = None
        if (startIndex is None):
            c2 = path.rfind("\\", 0, len(path))
        else:
            i = path.rfind("\\", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("\\"))) if ((i == -1)) else (i + 1))
            check = path.find("\\", startLeft, len(path))
            c2 = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (c1 < c2):
            self.dir = HxString.substr(path,0,c2)
            path = HxString.substr(path,(c2 + 1),None)
            self.backslash = True
        elif (c2 < c1):
            self.dir = HxString.substr(path,0,c1)
            path = HxString.substr(path,(c1 + 1),None)
        else:
            self.dir = None
        startIndex = None
        cp = None
        if (startIndex is None):
            cp = path.rfind(".", 0, len(path))
        else:
            i = path.rfind(".", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("."))) if ((i == -1)) else (i + 1))
            check = path.find(".", startLeft, len(path))
            cp = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (cp != -1):
            self.ext = HxString.substr(path,(cp + 1),None)
            self.file = HxString.substr(path,0,cp)
        else:
            self.ext = None
            self.file = path

    def toString(self):
        return ((HxOverrides.stringOrNull((("" if ((self.dir is None)) else (HxOverrides.stringOrNull(self.dir) + HxOverrides.stringOrNull((("\\" if (self.backslash) else "/"))))))) + HxOverrides.stringOrNull(self.file)) + HxOverrides.stringOrNull((("" if ((self.ext is None)) else ("." + HxOverrides.stringOrNull(self.ext))))))

    @staticmethod
    def addTrailingSlash(path):
        if (len(path) == 0):
            return "/"
        startIndex = None
        c1 = None
        if (startIndex is None):
            c1 = path.rfind("/", 0, len(path))
        else:
            i = path.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = path.find("/", startLeft, len(path))
            c1 = (check if (((check > i) and ((check <= startIndex)))) else i)
        startIndex = None
        c2 = None
        if (startIndex is None):
            c2 = path.rfind("\\", 0, len(path))
        else:
            i = path.rfind("\\", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("\\"))) if ((i == -1)) else (i + 1))
            check = path.find("\\", startLeft, len(path))
            c2 = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (c1 < c2):
            if (c2 != ((len(path) - 1))):
                return (("null" if path is None else path) + "\\")
            else:
                return path
        elif (c1 != ((len(path) - 1))):
            return (("null" if path is None else path) + "/")
        else:
            return path

haxe_io_Path._hx_class = haxe_io_Path


class haxe_iterators_ArrayIterator:
    _hx_class_name = "haxe.iterators.ArrayIterator"
    __slots__ = ("array", "current")
    _hx_fields = ["array", "current"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.array, _hx_local_2())
        return _hx_local_3()

haxe_iterators_ArrayIterator._hx_class = haxe_iterators_ArrayIterator


class haxe_iterators_ArrayKeyValueIterator:
    _hx_class_name = "haxe.iterators.ArrayKeyValueIterator"
    __slots__ = ("current", "array")
    _hx_fields = ["current", "array"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return _hx_AnonObject({'value': python_internal_ArrayImpl._get(self.array, self.current), 'key': _hx_local_2()})
        return _hx_local_3()

haxe_iterators_ArrayKeyValueIterator._hx_class = haxe_iterators_ArrayKeyValueIterator


class haxe_xml_XmlParserException:
    _hx_class_name = "haxe.xml.XmlParserException"
    __slots__ = ("message", "lineNumber", "positionAtLine", "position", "xml")
    _hx_fields = ["message", "lineNumber", "positionAtLine", "position", "xml"]
    _hx_methods = ["toString"]

    def __init__(self,message,xml,position):
        self.xml = xml
        self.message = message
        self.position = position
        self.lineNumber = 1
        self.positionAtLine = 0
        _g = 0
        _g1 = position
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = (-1 if ((i >= len(xml))) else ord(xml[i]))
            if (c == 10):
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.lineNumber
                _hx_local_0.lineNumber = (_hx_local_1 + 1)
                _hx_local_1
                self.positionAtLine = 0
            elif (c != 13):
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.positionAtLine
                _hx_local_2.positionAtLine = (_hx_local_3 + 1)
                _hx_local_3

    def toString(self):
        return ((((((HxOverrides.stringOrNull(Type.getClassName(Type.getClass(self))) + ": ") + HxOverrides.stringOrNull(self.message)) + " at line ") + Std.string(self.lineNumber)) + " char ") + Std.string(self.positionAtLine))

haxe_xml_XmlParserException._hx_class = haxe_xml_XmlParserException


class haxe_xml_Parser:
    _hx_class_name = "haxe.xml.Parser"
    __slots__ = ()
    _hx_statics = ["escapes", "parse", "doParse"]

    @staticmethod
    def parse(_hx_str,strict = None):
        if (strict is None):
            strict = False
        doc = Xml.createDocument()
        haxe_xml_Parser.doParse(_hx_str,strict,0,doc)
        return doc

    @staticmethod
    def doParse(_hx_str,strict,p = None,parent = None):
        if (p is None):
            p = 0
        xml = None
        state = 1
        next = 1
        aname = None
        start = 0
        nsubs = 0
        nbrackets = 0
        buf = StringBuf()
        escapeNext = 1
        attrValQuote = -1
        while (p < len(_hx_str)):
            c = ord(_hx_str[p])
            state1 = state
            if (state1 == 0):
                c1 = c
                if ((((c1 == 32) or ((c1 == 13))) or ((c1 == 10))) or ((c1 == 9))):
                    pass
                else:
                    state = next
                    continue
            elif (state1 == 1):
                if (c == 60):
                    state = 0
                    next = 2
                else:
                    start = p
                    state = 13
                    continue
            elif (state1 == 2):
                c2 = c
                if (c2 == 33):
                    index = (p + 1)
                    if (((-1 if ((index >= len(_hx_str))) else ord(_hx_str[index]))) == 91):
                        p = (p + 2)
                        if (HxString.substr(_hx_str,p,6).upper() != "CDATA["):
                            raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected <![CDATA[",_hx_str,p))
                        p = (p + 5)
                        state = 17
                        start = (p + 1)
                    else:
                        tmp = None
                        index1 = (p + 1)
                        if (((-1 if ((index1 >= len(_hx_str))) else ord(_hx_str[index1]))) != 68):
                            index2 = (p + 1)
                            tmp = (((-1 if ((index2 >= len(_hx_str))) else ord(_hx_str[index2]))) == 100)
                        else:
                            tmp = True
                        if tmp:
                            if (HxString.substr(_hx_str,(p + 2),6).upper() != "OCTYPE"):
                                raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected <!DOCTYPE",_hx_str,p))
                            p = (p + 8)
                            state = 16
                            start = (p + 1)
                        else:
                            tmp1 = None
                            index3 = (p + 1)
                            if (((-1 if ((index3 >= len(_hx_str))) else ord(_hx_str[index3]))) == 45):
                                index4 = (p + 2)
                                tmp1 = (((-1 if ((index4 >= len(_hx_str))) else ord(_hx_str[index4]))) != 45)
                            else:
                                tmp1 = True
                            if tmp1:
                                raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected <!--",_hx_str,p))
                            else:
                                p = (p + 2)
                                state = 15
                                start = (p + 1)
                elif (c2 == 47):
                    if (parent is None):
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected node name",_hx_str,p))
                    start = (p + 1)
                    state = 0
                    next = 10
                elif (c2 == 63):
                    state = 14
                    start = p
                else:
                    state = 3
                    start = p
                    continue
            elif (state1 == 3):
                if (not (((((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 58))) or ((c == 46))) or ((c == 95))) or ((c == 45))))):
                    if (p == start):
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected node name",_hx_str,p))
                    xml = Xml.createElement(HxString.substr(_hx_str,start,(p - start)))
                    parent.addChild(xml)
                    nsubs = (nsubs + 1)
                    state = 0
                    next = 4
                    continue
            elif (state1 == 4):
                c3 = c
                if (c3 == 47):
                    state = 11
                elif (c3 == 62):
                    state = 9
                else:
                    state = 5
                    start = p
                    continue
            elif (state1 == 5):
                if (not (((((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 58))) or ((c == 46))) or ((c == 95))) or ((c == 45))))):
                    if (start == p):
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected attribute name",_hx_str,p))
                    tmp2 = HxString.substr(_hx_str,start,(p - start))
                    aname = tmp2
                    if xml.exists(aname):
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException((("Duplicate attribute [" + ("null" if aname is None else aname)) + "]"),_hx_str,p))
                    state = 0
                    next = 6
                    continue
            elif (state1 == 6):
                if (c == 61):
                    state = 0
                    next = 7
                else:
                    raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected =",_hx_str,p))
            elif (state1 == 7):
                c4 = c
                if ((c4 == 39) or ((c4 == 34))):
                    buf = StringBuf()
                    state = 8
                    start = (p + 1)
                    attrValQuote = c
                else:
                    raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected \"",_hx_str,p))
            elif (state1 == 8):
                c5 = c
                if (c5 == 38):
                    _hx_len = (p - start)
                    s = (HxString.substr(_hx_str,start,None) if ((_hx_len is None)) else HxString.substr(_hx_str,start,_hx_len))
                    buf.b.write(s)
                    state = 18
                    escapeNext = 8
                    start = (p + 1)
                elif ((c5 == 62) or ((c5 == 60))):
                    if strict:
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException((("Invalid unescaped " + HxOverrides.stringOrNull("".join(map(chr,[c])))) + " in attribute value"),_hx_str,p))
                    elif (c == attrValQuote):
                        len1 = (p - start)
                        s1 = (HxString.substr(_hx_str,start,None) if ((len1 is None)) else HxString.substr(_hx_str,start,len1))
                        buf.b.write(s1)
                        val = buf.b.getvalue()
                        buf = StringBuf()
                        xml.set(aname,val)
                        state = 0
                        next = 4
                elif (c == attrValQuote):
                    len2 = (p - start)
                    s2 = (HxString.substr(_hx_str,start,None) if ((len2 is None)) else HxString.substr(_hx_str,start,len2))
                    buf.b.write(s2)
                    val1 = buf.b.getvalue()
                    buf = StringBuf()
                    xml.set(aname,val1)
                    state = 0
                    next = 4
            elif (state1 == 9):
                p = haxe_xml_Parser.doParse(_hx_str,strict,p,xml)
                start = p
                state = 1
            elif (state1 == 10):
                if (not (((((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 58))) or ((c == 46))) or ((c == 95))) or ((c == 45))))):
                    if (start == p):
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected node name",_hx_str,p))
                    v = HxString.substr(_hx_str,start,(p - start))
                    if ((parent is None) or ((parent.nodeType != 0))):
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException((("Unexpected </" + ("null" if v is None else v)) + ">, tag is not open"),_hx_str,p))
                    if (parent.nodeType != Xml.Element):
                        raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((parent.nodeType is None)) else _Xml_XmlType_Impl_.toString(parent.nodeType))))))
                    if (v != parent.nodeName):
                        if (parent.nodeType != Xml.Element):
                            raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((parent.nodeType is None)) else _Xml_XmlType_Impl_.toString(parent.nodeType))))))
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException((("Expected </" + HxOverrides.stringOrNull(parent.nodeName)) + ">"),_hx_str,p))
                    state = 0
                    next = 12
                    continue
            elif (state1 == 11):
                if (c == 62):
                    state = 1
                else:
                    raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected >",_hx_str,p))
            elif (state1 == 12):
                if (c == 62):
                    if (nsubs == 0):
                        parent.addChild(Xml.createPCData(""))
                    return p
                else:
                    raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected >",_hx_str,p))
            elif (state1 == 13):
                if (c == 60):
                    len3 = (p - start)
                    s3 = (HxString.substr(_hx_str,start,None) if ((len3 is None)) else HxString.substr(_hx_str,start,len3))
                    buf.b.write(s3)
                    child = Xml.createPCData(buf.b.getvalue())
                    buf = StringBuf()
                    parent.addChild(child)
                    nsubs = (nsubs + 1)
                    state = 0
                    next = 2
                elif (c == 38):
                    len4 = (p - start)
                    s4 = (HxString.substr(_hx_str,start,None) if ((len4 is None)) else HxString.substr(_hx_str,start,len4))
                    buf.b.write(s4)
                    state = 18
                    escapeNext = 13
                    start = (p + 1)
            elif (state1 == 14):
                tmp3 = None
                if (c == 63):
                    index5 = (p + 1)
                    tmp3 = (((-1 if ((index5 >= len(_hx_str))) else ord(_hx_str[index5]))) == 62)
                else:
                    tmp3 = False
                if tmp3:
                    p = (p + 1)
                    str1 = HxString.substr(_hx_str,(start + 1),((p - start) - 2))
                    parent.addChild(Xml.createProcessingInstruction(str1))
                    nsubs = (nsubs + 1)
                    state = 1
            elif (state1 == 15):
                tmp4 = None
                tmp5 = None
                if (c == 45):
                    index6 = (p + 1)
                    tmp5 = (((-1 if ((index6 >= len(_hx_str))) else ord(_hx_str[index6]))) == 45)
                else:
                    tmp5 = False
                if tmp5:
                    index7 = (p + 2)
                    tmp4 = (((-1 if ((index7 >= len(_hx_str))) else ord(_hx_str[index7]))) == 62)
                else:
                    tmp4 = False
                if tmp4:
                    parent.addChild(Xml.createComment(HxString.substr(_hx_str,start,(p - start))))
                    nsubs = (nsubs + 1)
                    p = (p + 2)
                    state = 1
            elif (state1 == 16):
                if (c == 91):
                    nbrackets = (nbrackets + 1)
                elif (c == 93):
                    nbrackets = (nbrackets - 1)
                elif ((c == 62) and ((nbrackets == 0))):
                    parent.addChild(Xml.createDocType(HxString.substr(_hx_str,start,(p - start))))
                    nsubs = (nsubs + 1)
                    state = 1
            elif (state1 == 17):
                tmp6 = None
                tmp7 = None
                if (c == 93):
                    index8 = (p + 1)
                    tmp7 = (((-1 if ((index8 >= len(_hx_str))) else ord(_hx_str[index8]))) == 93)
                else:
                    tmp7 = False
                if tmp7:
                    index9 = (p + 2)
                    tmp6 = (((-1 if ((index9 >= len(_hx_str))) else ord(_hx_str[index9]))) == 62)
                else:
                    tmp6 = False
                if tmp6:
                    child1 = Xml.createCData(HxString.substr(_hx_str,start,(p - start)))
                    parent.addChild(child1)
                    nsubs = (nsubs + 1)
                    p = (p + 2)
                    state = 1
            elif (state1 == 18):
                if (c == 59):
                    s5 = HxString.substr(_hx_str,start,(p - start))
                    if (((-1 if ((0 >= len(s5))) else ord(s5[0]))) == 35):
                        c6 = (Std.parseInt(("0" + HxOverrides.stringOrNull(HxString.substr(s5,1,(len(s5) - 1))))) if ((((-1 if ((1 >= len(s5))) else ord(s5[1]))) == 120)) else Std.parseInt(HxString.substr(s5,1,(len(s5) - 1))))
                        s6 = "".join(map(chr,[c6]))
                        buf.b.write(s6)
                    elif (not (s5 in haxe_xml_Parser.escapes.h)):
                        if strict:
                            raise haxe_Exception.thrown(haxe_xml_XmlParserException(("Undefined entity: " + ("null" if s5 is None else s5)),_hx_str,p))
                        s7 = Std.string((("&" + ("null" if s5 is None else s5)) + ";"))
                        buf.b.write(s7)
                    else:
                        s8 = Std.string(haxe_xml_Parser.escapes.h.get(s5,None))
                        buf.b.write(s8)
                    start = (p + 1)
                    state = escapeNext
                elif ((not (((((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 58))) or ((c == 46))) or ((c == 95))) or ((c == 45))))) and ((c != 35))):
                    if strict:
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException(("Invalid character in entity: " + HxOverrides.stringOrNull("".join(map(chr,[c])))),_hx_str,p))
                    s9 = "".join(map(chr,[38]))
                    buf.b.write(s9)
                    len5 = (p - start)
                    s10 = (HxString.substr(_hx_str,start,None) if ((len5 is None)) else HxString.substr(_hx_str,start,len5))
                    buf.b.write(s10)
                    p = (p - 1)
                    start = (p + 1)
                    state = escapeNext
            else:
                pass
            p = (p + 1)
        if (state == 1):
            start = p
            state = 13
        if (state == 13):
            if (parent.nodeType == 0):
                if (parent.nodeType != Xml.Element):
                    raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((parent.nodeType is None)) else _Xml_XmlType_Impl_.toString(parent.nodeType))))))
                raise haxe_Exception.thrown(haxe_xml_XmlParserException((("Unclosed node <" + HxOverrides.stringOrNull(parent.nodeName)) + ">"),_hx_str,p))
            if ((p != start) or ((nsubs == 0))):
                _hx_len = (p - start)
                s = (HxString.substr(_hx_str,start,None) if ((_hx_len is None)) else HxString.substr(_hx_str,start,_hx_len))
                buf.b.write(s)
                parent.addChild(Xml.createPCData(buf.b.getvalue()))
                nsubs = (nsubs + 1)
            return p
        if (((not strict) and ((state == 18))) and ((escapeNext == 13))):
            s = "".join(map(chr,[38]))
            buf.b.write(s)
            _hx_len = (p - start)
            s = (HxString.substr(_hx_str,start,None) if ((_hx_len is None)) else HxString.substr(_hx_str,start,_hx_len))
            buf.b.write(s)
            parent.addChild(Xml.createPCData(buf.b.getvalue()))
            nsubs = (nsubs + 1)
            return p
        raise haxe_Exception.thrown(haxe_xml_XmlParserException("Unexpected end",_hx_str,p))
haxe_xml_Parser._hx_class = haxe_xml_Parser


class haxe_xml_Printer:
    _hx_class_name = "haxe.xml.Printer"
    __slots__ = ("output", "pretty")
    _hx_fields = ["output", "pretty"]
    _hx_methods = ["writeNode", "hasChildren"]
    _hx_statics = ["print"]

    def __init__(self,pretty):
        self.output = StringBuf()
        self.pretty = pretty

    def writeNode(self,value,tabs):
        _g = value.nodeType
        if (_g == 0):
            _this = self.output
            s = Std.string((("null" if tabs is None else tabs) + "<"))
            _this.b.write(s)
            if (value.nodeType != Xml.Element):
                raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
            _this = self.output
            s = Std.string(value.nodeName)
            _this.b.write(s)
            attribute = value.attributes()
            while attribute.hasNext():
                attribute1 = attribute.next()
                _this = self.output
                s = Std.string(((" " + ("null" if attribute1 is None else attribute1)) + "=\""))
                _this.b.write(s)
                input = StringTools.htmlEscape(value.get(attribute1),True)
                _this1 = self.output
                s1 = Std.string(input)
                _this1.b.write(s1)
                self.output.b.write("\"")
            if self.hasChildren(value):
                self.output.b.write(">")
                if self.pretty:
                    self.output.b.write("\n")
                if ((value.nodeType != Xml.Document) and ((value.nodeType != Xml.Element))):
                    raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
                _g_current = 0
                _g_array = value.children
                while (_g_current < len(_g_array)):
                    child = _g_current
                    _g_current = (_g_current + 1)
                    child1 = (_g_array[child] if child >= 0 and child < len(_g_array) else None)
                    self.writeNode(child1,((("null" if tabs is None else tabs) + "\t") if (self.pretty) else tabs))
                _this = self.output
                s = Std.string((("null" if tabs is None else tabs) + "</"))
                _this.b.write(s)
                if (value.nodeType != Xml.Element):
                    raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
                _this = self.output
                s = Std.string(value.nodeName)
                _this.b.write(s)
                self.output.b.write(">")
                if self.pretty:
                    self.output.b.write("\n")
            else:
                self.output.b.write("/>")
                if self.pretty:
                    self.output.b.write("\n")
        elif (_g == 1):
            if ((value.nodeType == Xml.Document) or ((value.nodeType == Xml.Element))):
                raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
            nodeValue = value.nodeValue
            if (len(nodeValue) != 0):
                input = (("null" if tabs is None else tabs) + HxOverrides.stringOrNull(StringTools.htmlEscape(nodeValue)))
                _this = self.output
                s = Std.string(input)
                _this.b.write(s)
                if self.pretty:
                    self.output.b.write("\n")
        elif (_g == 2):
            _this = self.output
            s = Std.string((("null" if tabs is None else tabs) + "<![CDATA["))
            _this.b.write(s)
            if ((value.nodeType == Xml.Document) or ((value.nodeType == Xml.Element))):
                raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
            _this = self.output
            s = Std.string(value.nodeValue)
            _this.b.write(s)
            self.output.b.write("]]>")
            if self.pretty:
                self.output.b.write("\n")
        elif (_g == 3):
            if ((value.nodeType == Xml.Document) or ((value.nodeType == Xml.Element))):
                raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
            commentContent = value.nodeValue
            commentContent = EReg("[\n\r\t]+","g").replace(commentContent,"")
            commentContent = (("<!--" + ("null" if commentContent is None else commentContent)) + "-->")
            _this = self.output
            s = Std.string(tabs)
            _this.b.write(s)
            input = StringTools.trim(commentContent)
            _this = self.output
            s = Std.string(input)
            _this.b.write(s)
            if self.pretty:
                self.output.b.write("\n")
        elif (_g == 4):
            if ((value.nodeType == Xml.Document) or ((value.nodeType == Xml.Element))):
                raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
            _this = self.output
            s = Std.string((("<!DOCTYPE " + HxOverrides.stringOrNull(value.nodeValue)) + ">"))
            _this.b.write(s)
            if self.pretty:
                self.output.b.write("\n")
        elif (_g == 5):
            if ((value.nodeType == Xml.Document) or ((value.nodeType == Xml.Element))):
                raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
            _this = self.output
            s = Std.string((("<?" + HxOverrides.stringOrNull(value.nodeValue)) + "?>"))
            _this.b.write(s)
            if self.pretty:
                self.output.b.write("\n")
        elif (_g == 6):
            if ((value.nodeType != Xml.Document) and ((value.nodeType != Xml.Element))):
                raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
            _g_current = 0
            _g_array = value.children
            while (_g_current < len(_g_array)):
                child = _g_current
                _g_current = (_g_current + 1)
                child1 = (_g_array[child] if child >= 0 and child < len(_g_array) else None)
                self.writeNode(child1,tabs)
        else:
            pass

    def hasChildren(self,value):
        if ((value.nodeType != Xml.Document) and ((value.nodeType != Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
        _g_current = 0
        _g_array = value.children
        while (_g_current < len(_g_array)):
            child = _g_current
            _g_current = (_g_current + 1)
            child1 = (_g_array[child] if child >= 0 and child < len(_g_array) else None)
            _g = child1.nodeType
            if ((_g == 1) or ((_g == 0))):
                return True
            elif ((_g == 3) or ((_g == 2))):
                if ((child1.nodeType == Xml.Document) or ((child1.nodeType == Xml.Element))):
                    raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((child1.nodeType is None)) else _Xml_XmlType_Impl_.toString(child1.nodeType))))))
                if (len(StringTools.ltrim(child1.nodeValue)) != 0):
                    return True
            else:
                pass
        return False

    @staticmethod
    def print(xml,pretty = None):
        if (pretty is None):
            pretty = False
        printer = haxe_xml_Printer(pretty)
        printer.writeNode(xml,"")
        return printer.output.b.getvalue()

haxe_xml_Printer._hx_class = haxe_xml_Printer


class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "_add_dynamic", "toString1", "fields", "simpleField", "hasField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def _add_dynamic(a,b):
        if (isinstance(a,str) and isinstance(b,str)):
            return (a + b)
        if (isinstance(a,str) or isinstance(b,str)):
            return (python_Boot.toString1(a,"") + python_Boot.toString1(b,""))
        return (a + b)

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except BaseException as _g:
                None
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except BaseException as _g:
            None
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except BaseException as _g:
                    None
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o1 = o
                l = len(o1.params)
                hasParams = (l > 0)
                if hasParams:
                    paramsStr = ""
                    _g = 0
                    _g1 = l
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        prefix = ""
                        if (i > 0):
                            prefix = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1(o1.params[i],s))))))
                    return (((HxOverrides.stringOrNull(o1.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o1.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields = python_Boot.getInstanceFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
                else:
                    fields = python_Boot.getClassFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
            if ((type(o) == type) and (o == str)):
                return "#String"
            if ((type(o) == type) and (o == list)):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except BaseException as _g:
                None
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                if (fields is not None):
                    return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    if (k != '_hx_disable_getattr'):
                        a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d = o.__dict__
                keys1 = d.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def hasField(o,field):
        if isinstance(o,_hx_AnonObject):
            return o._hx_hasattr(field)
        return hasattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)))

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,str):
            field1 = field
            _hx_local_0 = len(field1)
            if (_hx_local_0 == 10):
                if (field1 == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field1 == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field1 == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 9):
                if (field1 == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 5):
                if (field1 == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 8):
                if (field1 == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 6):
                if (field1 == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field1) if (hasattr(o,field1)) else None)
        elif isinstance(o,list):
            field1 = field
            _hx_local_1 = len(field1)
            if (_hx_local_1 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 4):
                if (field1 == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field1 == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field1 == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field1 == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 5):
                if (field1 == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field1 == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field1 == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field1 == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 3):
                if (field1 == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field1 == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 8):
                if (field1 == "contains"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.contains)
                elif (field1 == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field1 == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 16):
                if (field1 == "keyValueIterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.keyValueIterator)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 6):
                if (field1 == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field1 == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field1 == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field1 == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field1) if (hasattr(o,field1)) else None)
        else:
            field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            return (getattr(o,field1) if (hasattr(o,field1)) else None)

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except BaseException as _g:
            None
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name
python_Boot._hx_class = python_Boot


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except BaseException as _g:
                None
                if Std.isOfType(haxe_Exception.caught(_g).unwrap(),StopIteration):
                    self.has = False
                    self.x = None
                else:
                    raise _g
            self.checked = True
        return self.has

python_HaxeIterator._hx_class = python_HaxeIterator


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    __slots__ = ()
    _hx_statics = ["fromT"]

    @staticmethod
    def fromT(d):
        return python_Lib.anonAsDict(d)
python__KwArgs_KwArgs_Impl_._hx_class = python__KwArgs_KwArgs_Impl_


class python_Lib:
    _hx_class_name = "python.Lib"
    __slots__ = ()
    _hx_statics = ["lineEnd", "printString", "anonToDict", "anonAsDict"]

    @staticmethod
    def printString(_hx_str):
        encoding = "utf-8"
        if (encoding is None):
            encoding = "utf-8"
        python_lib_Sys.stdout.buffer.write(_hx_str.encode(encoding, "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def anonToDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None
python_Lib._hx_class = python_Lib


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["get_length", "concat", "copy", "iterator", "keyValueIterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "contains", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def get_length(x):
        return len(x)

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def keyValueIterator(x):
        return haxe_iterators_ArrayKeyValueIterator(x)

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except BaseException as _g:
            None
            return False

    @staticmethod
    def contains(x,e):
        return (e in x)

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v
python_internal_ArrayImpl._hx_class = python_internal_ArrayImpl


class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["iterator", "eq", "stringOrNull", "length", "modf", "mod", "arrayGet", "arraySet", "mapKwArgs"]

    @staticmethod
    def iterator(x):
        if isinstance(x,list):
            return haxe_iterators_ArrayIterator(x)
        return x.iterator()

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def length(x):
        if isinstance(x,str):
            return len(x)
        elif isinstance(x,list):
            return len(x)
        return x.length

    @staticmethod
    def modf(a,b):
        if (b == 0.0):
            return float('nan')
        elif (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mod(a,b):
        if (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def arrayGet(a,i):
        if isinstance(a,list):
            x = a
            if ((i > -1) and ((i < len(x)))):
                return x[i]
            else:
                return None
        else:
            return a[i]

    @staticmethod
    def arraySet(a,i,v):
        if isinstance(a,list):
            x = a
            v1 = v
            l = len(x)
            while (l < i):
                x.append(None)
                l = (l + 1)
            if (l == i):
                x.append(v1)
            else:
                x[i] = v1
            return v1
        else:
            a[i] = v
            return v

    @staticmethod
    def mapKwArgs(a,v):
        a1 = _hx_AnonObject(python_Lib.anonToDict(a))
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            val = v.get(k1)
            if a1._hx_hasattr(k1):
                x = getattr(a1,k1)
                setattr(a1,val,x)
                delattr(a1,k1)
        return a1
HxOverrides._hx_class = HxOverrides


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)

python_internal_MethodClosure._hx_class = python_internal_MethodClosure


class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "indexOfImpl", "toString", "get_length", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        elif (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return HxString.indexOfImpl(s,_hx_str,startIndex)

    @staticmethod
    def indexOfImpl(s,_hx_str,startIndex):
        if (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def get_length(s):
        return len(s)

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]
HxString._hx_class = HxString


class python_io_NativeInput(haxe_io_Input):
    _hx_class_name = "python.io.NativeInput"
    __slots__ = ("stream", "wasEof")
    _hx_fields = ["stream", "wasEof"]
    _hx_methods = ["close", "throwEof", "readinto", "readBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        self.wasEof = None
        self.stream = s
        self.set_bigEndian(False)
        self.wasEof = False
        if (not self.stream.readable()):
            raise haxe_Exception.thrown("Write-only stream")

    def close(self):
        self.stream.close()

    def throwEof(self):
        self.wasEof = True
        raise haxe_Exception.thrown(haxe_io_Eof())

    def readinto(self,b):
        raise haxe_Exception.thrown("abstract method, should be overridden")

    def readBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        ba = bytearray(_hx_len)
        ret = self.readinto(ba)
        if (ret == 0):
            self.throwEof()
        s.blit(pos,haxe_io_Bytes.ofData(ba),0,_hx_len)
        return ret

python_io_NativeInput._hx_class = python_io_NativeInput


class python_io_IInput:
    _hx_class_name = "python.io.IInput"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian", "readByte", "readBytes", "close", "readAll", "readFullBytes", "readLine", "readString"]
python_io_IInput._hx_class = python_io_IInput


class python_io_IFileInput:
    _hx_class_name = "python.io.IFileInput"
    __slots__ = ()
    _hx_interfaces = [python_io_IInput]
python_io_IFileInput._hx_class = python_io_IFileInput


class python_io_NativeOutput(haxe_io_Output):
    _hx_class_name = "python.io.NativeOutput"
    __slots__ = ("stream",)
    _hx_fields = ["stream"]
    _hx_methods = ["close", "flush"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,stream):
        self.stream = None
        self.set_bigEndian(False)
        self.stream = stream
        if (not stream.writable()):
            raise haxe_Exception.thrown("Read only stream")

    def close(self):
        self.stream.close()

    def flush(self):
        self.stream.flush()

python_io_NativeOutput._hx_class = python_io_NativeOutput


class python_io_NativeBytesOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeBytesOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["writeByte", "writeBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)

    def writeByte(self,c):
        self.stream.write(bytearray([c]))

    def writeBytes(self,s,pos,_hx_len):
        return self.stream.write(s.b[pos:(pos + _hx_len)])

python_io_NativeBytesOutput._hx_class = python_io_NativeBytesOutput


class python_io_IOutput:
    _hx_class_name = "python.io.IOutput"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "flush", "close", "writeFullBytes", "writeString"]
python_io_IOutput._hx_class = python_io_IOutput


class python_io_IFileOutput:
    _hx_class_name = "python.io.IFileOutput"
    __slots__ = ()
    _hx_interfaces = [python_io_IOutput]
python_io_IFileOutput._hx_class = python_io_IFileOutput


class python_io_FileBytesOutput(python_io_NativeBytesOutput):
    _hx_class_name = "python.io.FileBytesOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileOutput]
    _hx_super = python_io_NativeBytesOutput


    def __init__(self,stream):
        super().__init__(stream)
python_io_FileBytesOutput._hx_class = python_io_FileBytesOutput


class python_io_NativeTextInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readByte", "readinto"]
    _hx_statics = []
    _hx_interfaces = [python_io_IInput]
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readByte(self):
        ret = self.stream.buffer.read(1)
        if (len(ret) == 0):
            self.throwEof()
        return ret[0]

    def readinto(self,b):
        return self.stream.buffer.readinto(b)

python_io_NativeTextInput._hx_class = python_io_NativeTextInput


class python_io_FileTextInput(python_io_NativeTextInput):
    _hx_class_name = "python.io.FileTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileInput]
    _hx_super = python_io_NativeTextInput


    def __init__(self,stream):
        super().__init__(stream)
python_io_FileTextInput._hx_class = python_io_FileTextInput


class python_io_NativeTextOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["writeBytes", "writeByte"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)
        if (not stream.writable()):
            raise haxe_Exception.thrown("Read only stream")

    def writeBytes(self,s,pos,_hx_len):
        return self.stream.buffer.write(s.b[pos:(pos + _hx_len)])

    def writeByte(self,c):
        self.stream.write("".join(map(chr,[c])))

python_io_NativeTextOutput._hx_class = python_io_NativeTextOutput


class python_io_FileTextOutput(python_io_NativeTextOutput):
    _hx_class_name = "python.io.FileTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileOutput]
    _hx_super = python_io_NativeTextOutput


    def __init__(self,stream):
        super().__init__(stream)
python_io_FileTextOutput._hx_class = python_io_FileTextOutput


class python_io_IoTools:
    _hx_class_name = "python.io.IoTools"
    __slots__ = ()
    _hx_statics = ["createFileInputFromText", "createFileOutputFromText", "createFileOutputFromBytes"]

    @staticmethod
    def createFileInputFromText(t):
        return sys_io_FileInput(python_io_FileTextInput(t))

    @staticmethod
    def createFileOutputFromText(t):
        return sys_io_FileOutput(python_io_FileTextOutput(t))

    @staticmethod
    def createFileOutputFromBytes(t):
        return sys_io_FileOutput(python_io_FileBytesOutput(t))
python_io_IoTools._hx_class = python_io_IoTools


class sys_net_Socket:
    _hx_class_name = "sys.net.Socket"
    __slots__ = ("_hx___s", "input", "output")
    _hx_fields = ["__s", "input", "output"]
    _hx_methods = ["__initSocket", "fileno"]

    def __init__(self):
        self.output = None
        self.input = None
        self._hx___s = None
        self._hx___initSocket()
        self.input = sys_net__Socket_SocketInput(self._hx___s)
        self.output = sys_net__Socket_SocketOutput(self._hx___s)

    def _hx___initSocket(self):
        self._hx___s = python_lib_socket_Socket()

    def fileno(self):
        return self._hx___s.fileno()

sys_net_Socket._hx_class = sys_net_Socket


class python_net_SslSocket(sys_net_Socket):
    _hx_class_name = "python.net.SslSocket"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = sys_net_Socket


    def __init__(self):
        super().__init__()
python_net_SslSocket._hx_class = python_net_SslSocket


class sys_io_File:
    _hx_class_name = "sys.io.File"
    __slots__ = ()
    _hx_statics = ["append"]

    @staticmethod
    def append(path,binary = None):
        if (binary is None):
            binary = True
        mode = ("ab" if binary else "a")
        f = python_lib_Builtins.open(path,mode,-1,None,None,(None if binary else ""))
        if binary:
            return python_io_IoTools.createFileOutputFromBytes(f)
        else:
            return python_io_IoTools.createFileOutputFromText(f)
sys_io_File._hx_class = sys_io_File


class sys_io_FileInput(haxe_io_Input):
    _hx_class_name = "sys.io.FileInput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "readByte", "readBytes", "close", "readAll", "readFullBytes", "readLine", "readString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def readByte(self):
        return self.impl.readByte()

    def readBytes(self,s,pos,_hx_len):
        return self.impl.readBytes(s,pos,_hx_len)

    def close(self):
        self.impl.close()

    def readAll(self,bufsize = None):
        return self.impl.readAll(bufsize)

    def readFullBytes(self,s,pos,_hx_len):
        self.impl.readFullBytes(s,pos,_hx_len)

    def readLine(self):
        return self.impl.readLine()

    def readString(self,_hx_len,encoding = None):
        return self.impl.readString(_hx_len)

sys_io_FileInput._hx_class = sys_io_FileInput


class sys_io_FileOutput(haxe_io_Output):
    _hx_class_name = "sys.io.FileOutput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "flush", "close", "writeFullBytes", "writeString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def writeByte(self,c):
        self.impl.writeByte(c)

    def writeBytes(self,s,pos,_hx_len):
        return self.impl.writeBytes(s,pos,_hx_len)

    def flush(self):
        self.impl.flush()

    def close(self):
        self.impl.close()

    def writeFullBytes(self,s,pos,_hx_len):
        self.impl.writeFullBytes(s,pos,_hx_len)

    def writeString(self,s,encoding = None):
        self.impl.writeString(s)

sys_io_FileOutput._hx_class = sys_io_FileOutput


class sys_io_Process:
    _hx_class_name = "sys.io.Process"
    __slots__ = ("stdout", "stderr", "stdin", "p")
    _hx_fields = ["stdout", "stderr", "stdin", "p"]
    _hx_methods = ["close"]

    def __init__(self,cmd,args = None,detached = None):
        self.stdin = None
        self.stderr = None
        self.stdout = None
        if detached:
            raise haxe_Exception.thrown("Detached process is not supported on this platform")
        args1 = (cmd if ((args is None)) else ([cmd] + args))
        o = _hx_AnonObject({'shell': (args is None), 'stdin': python_lib_Subprocess.PIPE, 'stdout': python_lib_Subprocess.PIPE, 'stderr': python_lib_Subprocess.PIPE})
        Reflect.setField(o,"bufsize",(Reflect.field(o,"bufsize") if (python_Boot.hasField(o,"bufsize")) else 0))
        Reflect.setField(o,"executable",(Reflect.field(o,"executable") if (python_Boot.hasField(o,"executable")) else None))
        Reflect.setField(o,"stdin",(Reflect.field(o,"stdin") if (python_Boot.hasField(o,"stdin")) else None))
        Reflect.setField(o,"stdout",(Reflect.field(o,"stdout") if (python_Boot.hasField(o,"stdout")) else None))
        Reflect.setField(o,"stderr",(Reflect.field(o,"stderr") if (python_Boot.hasField(o,"stderr")) else None))
        Reflect.setField(o,"preexec_fn",(Reflect.field(o,"preexec_fn") if (python_Boot.hasField(o,"preexec_fn")) else None))
        Reflect.setField(o,"close_fds",(Reflect.field(o,"close_fds") if (python_Boot.hasField(o,"close_fds")) else None))
        Reflect.setField(o,"shell",(Reflect.field(o,"shell") if (python_Boot.hasField(o,"shell")) else None))
        Reflect.setField(o,"cwd",(Reflect.field(o,"cwd") if (python_Boot.hasField(o,"cwd")) else None))
        Reflect.setField(o,"env",(Reflect.field(o,"env") if (python_Boot.hasField(o,"env")) else None))
        Reflect.setField(o,"universal_newlines",(Reflect.field(o,"universal_newlines") if (python_Boot.hasField(o,"universal_newlines")) else None))
        Reflect.setField(o,"startupinfo",(Reflect.field(o,"startupinfo") if (python_Boot.hasField(o,"startupinfo")) else None))
        Reflect.setField(o,"creationflags",(Reflect.field(o,"creationflags") if (python_Boot.hasField(o,"creationflags")) else 0))
        self.p = (python_lib_subprocess_Popen(args1,Reflect.field(o,"bufsize"),Reflect.field(o,"executable"),Reflect.field(o,"stdin"),Reflect.field(o,"stdout"),Reflect.field(o,"stderr"),Reflect.field(o,"preexec_fn"),Reflect.field(o,"close_fds"),Reflect.field(o,"shell"),Reflect.field(o,"cwd"),Reflect.field(o,"env"),Reflect.field(o,"universal_newlines"),Reflect.field(o,"startupinfo"),Reflect.field(o,"creationflags")) if ((Sys.systemName() == "Windows")) else python_lib_subprocess_Popen(args1,Reflect.field(o,"bufsize"),Reflect.field(o,"executable"),Reflect.field(o,"stdin"),Reflect.field(o,"stdout"),Reflect.field(o,"stderr"),Reflect.field(o,"preexec_fn"),Reflect.field(o,"close_fds"),Reflect.field(o,"shell"),Reflect.field(o,"cwd"),Reflect.field(o,"env"),Reflect.field(o,"universal_newlines"),Reflect.field(o,"startupinfo")))
        self.stdout = python_io_IoTools.createFileInputFromText(python_lib_io_TextIOWrapper(python_lib_io_BufferedReader(self.p.stdout)))
        self.stderr = python_io_IoTools.createFileInputFromText(python_lib_io_TextIOWrapper(python_lib_io_BufferedReader(self.p.stderr)))
        self.stdin = python_io_IoTools.createFileOutputFromText(python_lib_io_TextIOWrapper(python_lib_io_BufferedWriter(self.p.stdin)))

    def close(self):
        ver = python_lib_Sys.version_info
        if ((ver[0] > 3) or (((ver[0] == 3) and ((ver[1] >= 3))))):
            try:
                self.p.terminate()
            except BaseException as _g:
                None
                if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),ProcessLookupError)):
                    raise _g
        else:
            try:
                self.p.terminate()
            except BaseException as _g:
                None
                if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),OSError)):
                    raise _g

sys_io_Process._hx_class = sys_io_Process


class sys_net__Socket_SocketInput(haxe_io_Input):
    _hx_class_name = "sys.net._Socket.SocketInput"
    __slots__ = ("_hx___s",)
    _hx_fields = ["__s"]
    _hx_methods = ["readByte", "readBytes", "close"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        self._hx___s = s

    def readByte(self):
        r = None
        try:
            r = self._hx___s.recv(1,0)
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),BlockingIOError):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            else:
                raise _g
        if (len(r) == 0):
            raise haxe_Exception.thrown(haxe_io_Eof())
        return r[0]

    def readBytes(self,buf,pos,_hx_len):
        r = None
        data = buf.b
        try:
            r = self._hx___s.recv(_hx_len,0)
            _g = pos
            _g1 = (pos + len(r))
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                data.__setitem__(i,r[(i - pos)])
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),BlockingIOError):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            else:
                raise _g
        if (len(r) == 0):
            raise haxe_Exception.thrown(haxe_io_Eof())
        return len(r)

    def close(self):
        super().close()
        if (self._hx___s is not None):
            self._hx___s.close()

sys_net__Socket_SocketInput._hx_class = sys_net__Socket_SocketInput


class sys_net__Socket_SocketOutput(haxe_io_Output):
    _hx_class_name = "sys.net._Socket.SocketOutput"
    __slots__ = ("_hx___s",)
    _hx_fields = ["__s"]
    _hx_methods = ["writeByte", "writeBytes", "close"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,s):
        self._hx___s = s

    def writeByte(self,c):
        try:
            self._hx___s.send(bytes([c]),0)
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),BlockingIOError):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            else:
                raise _g

    def writeBytes(self,buf,pos,_hx_len):
        try:
            data = buf.b
            payload = data[pos:pos+_hx_len]
            r = self._hx___s.send(payload,0)
            return r
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),BlockingIOError):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            else:
                raise _g

    def close(self):
        super().close()
        if (self._hx___s is not None):
            self._hx___s.close()

sys_net__Socket_SocketOutput._hx_class = sys_net__Socket_SocketOutput

Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

DateTools.DAY_SHORT_NAMES = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
DateTools.DAY_NAMES = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
DateTools.MONTH_SHORT_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
DateTools.MONTH_NAMES = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
Xml.Element = 0
Xml.PCData = 1
Xml.CData = 2
Xml.Comment = 3
Xml.DocType = 4
Xml.ProcessingInstruction = 5
Xml.Document = 6
com_sdtk_api_ACMAPI._acmRoot = "www.acm.org"
com_sdtk_api_ACMAPI._eventsAPI = "/conferences/conference-events"
com_sdtk_api_APIList._executors = None
com_sdtk_api_APIList._executorsByName = None
com_sdtk_api_APIList._apis = None
com_sdtk_api_APIList._inputs = None
com_sdtk_api_APIList._apisByName = None
com_sdtk_api_APIList._inputsByName = None
com_sdtk_api_APIList._writers = None
com_sdtk_api_APIList._writersByName = None
com_sdtk_api_BTCAPI._btcRoot = "chain.api.btc.com/v3/"
com_sdtk_api_BTCAPI._blockAPI = "block/"
com_sdtk_api_BTCAPI._addressAPI = "address/"
com_sdtk_api_BTCAPI._latest = "latest/"
com_sdtk_api_BTCAPI._transactions = "/tx"
com_sdtk_api_BTCAPI._pagesize = "?pagesize=50"
com_sdtk_api_BTCAPI._maxLimit = 50
com_sdtk_api_BTCAPI._maxMultiple = 20
com_sdtk_api_BitTorrentAPI._bttRoot = "scanapi.bt.io/api"
com_sdtk_api_BitTorrentAPI._statusAPI = "system/status"
com_sdtk_api_BitTorrentAPI._transactionAPI = "transaction"
com_sdtk_api_BitTorrentAPI._transfersAPI = "token_trc20/transfers"
com_sdtk_api_BitTorrentAPI._priceAPI = "price"
com_sdtk_api_BitTorrentAPI._maxLimit = 50
com_sdtk_api_BitTorrentAPI._maxMultiple = 20
com_sdtk_api_ChatGPTAPI._apiKey = "<CHATGPT_API_KEY>"
com_sdtk_api_ChatGPTAPI._chatGPTRoot = "api.openai.com"
com_sdtk_api_ChatGPTAPI._completions = "v1/chat/completions"
com_sdtk_api_ChatGPTAPI._model = "<CHATGPT_MODEL>"
com_sdtk_api_EtherscanAPI._etherscanRoot = "api.etherscan.io/api"
com_sdtk_api_EtherscanAPI._transactionAPI = "?module=account&action=txlist"
com_sdtk_api_EtherscanAPI._maxLimit = 50
com_sdtk_api_EtherscanAPI._maxMultiple = 20
com_sdtk_api_GitAPI._gitRoot = "api.github.com"
com_sdtk_api_GitAPI._reposAPI = "repos"
com_sdtk_api_GitAPI._usersAPI = "users"
com_sdtk_api_GitAPI._apiKey = None
com_sdtk_api_GitAPI._user = None
com_sdtk_api_GoogleAPI._clientId = "<GOOGLE_CLIENT_ID>"
com_sdtk_api_GoogleAPI._apiKey = "<GOOGLE_API_KEY>"
com_sdtk_api_GoogleAPI._appScope = "https://www.googleapis.com/auth/userinfo.email"
com_sdtk_api_GoogleAPI._dataScope = "https://www.googleapis.com/auth/drive"
com_sdtk_api_GoogleAPI._idScope = "https://www.googleapis.com/auth/userinfo.email"
com_sdtk_api_GoogleAPI._sendEmailScope = "https://www.googleapis.com/auth/gmail.compose"
com_sdtk_api_GoogleAPI._readEmailScope = "https://www.googleapis.com/auth/gmail.readonly"
com_sdtk_api_GoogleAPI._pickerScope = ""
com_sdtk_api_GoogleAPI._discovery = "https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"
com_sdtk_api_GoogleAPI._fileAPI = "drive/v3/files"
com_sdtk_api_GoogleAPI._uploadAPI = "upload/drive/v3/files"
com_sdtk_api_GoogleAPI._changesAPI = "drive/v3/changes"
com_sdtk_api_GoogleAPI._permissionsAPI = "drive/v3/files/{fileId}/permissions"
com_sdtk_api_GoogleAPI._gmailSendAPI = "v1/users/me/messages/send"
com_sdtk_api_GoogleAPI._gmailListAPI = "v1/users/me/messages"
com_sdtk_api_GoogleAPI._gmailGetAPI = "v1/users/me/messages"
com_sdtk_api_GoogleAPI._gmailAttachmentAPI = "gmail/v1/users/me"
com_sdtk_api_GoogleAPI._mainRoot = "www.googleapis.com"
com_sdtk_api_GoogleAPI._contentRoot = "content.googleapis.com"
com_sdtk_api_GoogleAPI._gmailRoot = "gmail.googleapis.com"
com_sdtk_api_IEEEAPI._ieeeRoot = "events.vtools.ieee.org/RST"
com_sdtk_api_IEEEAPI._eventsAPI = "/events/api/public/v4/events"
com_sdtk_api_IEEEAPI._maxLimit = 10000
com_sdtk_api_OrtingoAPI._ortingoRoot = "ortingo.com"
com_sdtk_api_OrtingoAPI._postsAPI = "users/"
com_sdtk_api_SSRSAPI._ssrsRoot1 = "https://"
com_sdtk_api_SSRSAPI._ssrsRoot2 = "/ReportServer/"
com_sdtk_api_SSRSAPI._viewAPI = "ReportExecution2005.asmx"
com_sdtk_api_TableauAPI._tableauRoot = "10ay.online.tableau.com/api/3.5/sites"
com_sdtk_api_TableauAPI._tableauSigninRoot = "10ay.online.tableau.com/api/3.5"
com_sdtk_api_TableauAPI._viewAPI = "/views/"
com_sdtk_api_TableauAPI._dataAPI = "/data"
com_sdtk_api_TableauAPI._signinAPI = "/auth/signin"
com_sdtk_std_Parameters._enableLogin = False
com_sdtk_std_Parameters._ldapHost = None
com_sdtk_std_Parameters._ldapPort = 389
com_sdtk_std_Parameters._ldapBaseDN = None
com_sdtk_std_Parameters._ldapUsersDN = None
com_sdtk_std_Parameters._builtInUsers = None
com_sdtk_std_Parameters._loginPageTemplate = "<html><body><form method=\"post\"><table><tr><td><label for=\"user\">User: </label></td><td><input type=\"text\" id=\"user\" name=\"user\"></td></tr><tr><td><label for=\"password\">Password: </label></td><td><input type=\"password\" id=\"password\" name=\"password\"></td></tr><tr><td colspan=\"2\"><input type=\"submit\" value=\"Login\"></td></tr></table></form></body></html>"
com_sdtk_std_Parameters._loginCommandLineTemplate = ["Enter user name: ", "Enter password: ", "Invalid login"]
com_sdtk_std_Parameters._loginVariable = "REMOTE_USER"
com_sdtk_std_Parameters._loginPath = "/"
com_sdtk_graphs_Grapher._defaultGraphColor = "black"
com_sdtk_graphs_Grapher._validGraphColors = ["Aquamarine", "Black", "Blue", "BlueViolet", "Brown", "CadetBlue", "CornflowerBlue", "Cyan", "DarkOrchid", "ForestGreen", "Fuchsia", "Goldenrod", "Gray", "Green", "GreenYellow", "Lavender", "LimeGreen", "Magenta", "Maroon", "MidnightBlue", "Orange", "OrangeRed", "Orchid", "Plum", "Purple", "Red", "RoyalBlue", "RoyalPurple", "Salmon", "SeaGreen", "SkyBlue", "SpringGreen", "Tan", "Thistle", "Turquoise", "Violet", "White", "Yellow", "YellowGreen"]
com_sdtk_graphs_Grapher._defaultGraphColors = ["Red", "Green", "Blue", "Orange", "Purple", "Cyan", "Pink"]
com_sdtk_graphs_GrapherHTMLExporter._instance = com_sdtk_graphs_GrapherHTMLExporter()
com_sdtk_graphs_GrapherSVGExporter._instance = com_sdtk_graphs_GrapherSVGExporter()
com_sdtk_graphs_GrapherTEXExporter._instance = com_sdtk_graphs_GrapherTEXExporter()
com_sdtk_proxy_Proxy.checkForLogin = True
com_sdtk_proxy_Proxy.verifyLogin = True
com_sdtk_puller_Parameters.GET_EXECUTE = -1
com_sdtk_puller_Parameters.GET_EXTRACT = -2
com_sdtk_puller_Parameters.GET_GIT_HTTP = 0
com_sdtk_puller_Parameters.GET_GIT_CLIENT = 1
com_sdtk_puller_Parameters.GET_HTTP = 2
com_sdtk_puller_Parameters.GET_CUSTOM_WEB_API = 3
com_sdtk_puller_Parameters.GET_CUSTOM_WEB_API_FILE = 4
com_sdtk_puller_Parameters.GET_TORRENT = 5
com_sdtk_puller_Parameters.GET_BLOB = 6
com_sdtk_std_Version._code = "0.2.3"
com_sdtk_table_Stopwatch._watches = haxe_ds_StringMap()
com_sdtk_table_Stopwatch._defaultActual = False
com_sdtk_table_Stopwatch._null = None
com_sdtk_table_DataTableRowReader._watch = com_sdtk_table_Stopwatch.getStopwatch("fromStringToType")
com_sdtk_table_CMDDirHandler.OPTION_BARE = 1
com_sdtk_table_CMDDirHandler.OPTION_FULL_PATH = 2
com_sdtk_table_CMDDirHandler.OPTION_SHORT_NAME = 4
com_sdtk_table_CMDDirHandler.OPTION_OWNER_NAME = 8
com_sdtk_table_CMDDirHandler.OPTION_TRUE_NAME = 16
com_sdtk_table_CMDDirHandler.OPTION_COMMAS = 32
com_sdtk_table_CMDDirHandler.OPTION_LOWER_CASE_NAMES = 64
com_sdtk_table_CodeRowWriter._watch = com_sdtk_table_Stopwatch.getStopwatch("CodeRowWriter")
com_sdtk_table_Converter._watch = com_sdtk_table_Stopwatch.getStopwatch("Converter")
com_sdtk_table_ConverterStageSort._watch = com_sdtk_table_Stopwatch.getStopwatch("ConverterStageSort")
com_sdtk_table_DelimitedRowReader._watch = com_sdtk_table_Stopwatch.getStopwatch("DelimitedRowReader")
com_sdtk_table_DelimitedRowWriter._watch = com_sdtk_table_Stopwatch.getStopwatch("DelimitedRowWriter")
com_sdtk_table_FileInfo.IS_DIRECTORY = 1
com_sdtk_table_FileInfo.IS_JUNCTION = 2
com_sdtk_table_FileSystemRowReader._fields = ["Drive", "Label", "Serial", "Directory", "Owner", "File", "Short", "True", "Modified", "Size", "Type"]
com_sdtk_table_Tests.sCSV = "A,B,C\n5,6,7\n1,2,3\n8,1,5"
com_sdtk_table_Tests.sPASSED = "Passed"
com_sdtk_table_Tests.sFAILED = "Failed"
com_sdtk_table_Tests.sEXPECTED = "Expected"
com_sdtk_table_Tests.sGOT = "Got"
com_sdtk_table_Tests.sEXCEPTION = "Exception"
def _hx_init_haxe_xml_Parser_escapes():
    def _hx_local_0():
        h = haxe_ds_StringMap()
        h.h["lt"] = "<"
        h.h["gt"] = ">"
        h.h["amp"] = "&"
        h.h["quot"] = "\""
        h.h["apos"] = "'"
        return h
    return _hx_local_0()
haxe_xml_Parser.escapes = _hx_init_haxe_xml_Parser_escapes()
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
python_Lib.lineEnd = ("\r\n" if ((Sys.systemName() == "Windows")) else "\n")