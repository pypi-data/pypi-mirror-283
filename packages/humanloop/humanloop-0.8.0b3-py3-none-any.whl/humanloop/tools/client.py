# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pagination import AsyncPager, SyncPager
from ..core.request_options import RequestOptions
from ..core.unchecked_base_model import construct_type
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.create_tool_log_response import CreateToolLogResponse
from ..types.evaluator_activation_deactivation_request_evaluators_to_activate_item import (
    EvaluatorActivationDeactivationRequestEvaluatorsToActivateItem,
)
from ..types.evaluator_activation_deactivation_request_evaluators_to_deactivate_item import (
    EvaluatorActivationDeactivationRequestEvaluatorsToDeactivateItem,
)
from ..types.file_environment_response import FileEnvironmentResponse
from ..types.files_tool_type import FilesToolType
from ..types.http_validation_error import HttpValidationError
from ..types.list_tools import ListTools
from ..types.project_sort_by import ProjectSortBy
from ..types.sort_order import SortOrder
from ..types.tool_function import ToolFunction
from ..types.tool_kernel_request import ToolKernelRequest
from ..types.tool_response import ToolResponse
from ..types.version_status import VersionStatus

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ToolsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        page: typing.Optional[int] = None,
        size: typing.Optional[int] = None,
        name: typing.Optional[str] = None,
        user_filter: typing.Optional[str] = None,
        sort_by: typing.Optional[ProjectSortBy] = None,
        order: typing.Optional[SortOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPager[ToolResponse]:
        """
        Get a list of Tools.

        Parameters
        ----------
        page : typing.Optional[int]
            Page offset for pagination.

        size : typing.Optional[int]
            Page size for pagination. Number of Tools to fetch.

        name : typing.Optional[str]
            Case-insensitive filter for Tool name.

        user_filter : typing.Optional[str]
            Case-insensitive filter for users in the Tool. This filter matches against both email address and name of users.

        sort_by : typing.Optional[ProjectSortBy]
            Field to sort Tools by

        order : typing.Optional[SortOrder]
            Direction to sort by.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPager[ToolResponse]
            Successful Response

        Examples
        --------
        from humanloop.client import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        response = client.tools.list()
        for item in response:
            yield item
        # alternatively, you can paginate page-by-page
        for page in response.iter_pages():
            yield page
        """
        page = page or 1
        _response = self._client_wrapper.httpx_client.request(
            "tools",
            method="GET",
            params={
                "page": page,
                "size": size,
                "name": name,
                "user_filter": user_filter,
                "sort_by": sort_by,
                "order": order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(ListTools, construct_type(type_=ListTools, object_=_response.json()))  # type: ignore
                _has_next = True
                _get_next = lambda: self.list(
                    page=page + 1,
                    size=size,
                    name=name,
                    user_filter=user_filter,
                    sort_by=sort_by,
                    order=order,
                    request_options=request_options,
                )
                _items = _parsed_response.records
                return SyncPager(has_next=_has_next, items=_items, get_next=_get_next)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def upsert(
        self,
        *,
        path: typing.Optional[str] = OMIT,
        id: typing.Optional[str] = OMIT,
        function: typing.Optional[ToolFunction] = OMIT,
        source_code: typing.Optional[str] = OMIT,
        setup_values: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        tool_type: typing.Optional[FilesToolType] = OMIT,
        commit_message: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolResponse:
        """
        Create a Tool or update it with a new version if it already exists.

        Tools are identified by the `ID` or their `path`. The name, description and parameters determine the versions of the Tool.

        If you provide a commit message, then the new version will be committed;
        otherwise it will be uncommitted. If you try to commit an already committed version,
        an exception will be raised.

        Parameters
        ----------
        path : typing.Optional[str]
            Path of the Tool, including the name, which is used as a unique identifier.

        id : typing.Optional[str]
            ID for an existing Tool to update.

        function : typing.Optional[ToolFunction]
            Callable function specification of the Tool shown to the model for tool calling.

        source_code : typing.Optional[str]
            Code source of the Tool.

        setup_values : typing.Optional[typing.Dict[str, typing.Any]]
            Values needed to setup the Tool, defined in JSON Schema format: https://json-schema.org/

        tool_type : typing.Optional[FilesToolType]
            Type of Tool.

        commit_message : typing.Optional[str]
            Message describing the changes made.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        from humanloop.client import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.upsert()
        """
        _response = self._client_wrapper.httpx_client.request(
            "tools",
            method="POST",
            json={
                "path": path,
                "id": id,
                "function": function,
                "source_code": source_code,
                "setup_values": setup_values,
                "tool_type": tool_type,
                "commit_message": commit_message,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ToolResponse, construct_type(type_=ToolResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(
        self,
        id: str,
        *,
        version_id: typing.Optional[str] = None,
        environment: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolResponse:
        """
        Retrieve the Tool with the given ID.

        By default, the deployed version of the Tool is returned. Use the query parameters
        `version_id` or `environment` to target a specific version of the Tool.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        version_id : typing.Optional[str]
            A specific Version ID of the Tool to retrieve.

        environment : typing.Optional[str]
            Name of the Environment to retrieve a deployed Version from.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        from humanloop.client import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.get(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}",
            method="GET",
            params={"version_id": version_id, "environment": environment},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ToolResponse, construct_type(type_=ToolResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Delete the Tool with the given ID.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from humanloop.client import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}", method="DELETE", request_options=request_options
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def move(
        self,
        id: str,
        *,
        path: typing.Optional[str] = OMIT,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolResponse:
        """
        Move the Tool to a different path or change the name.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        path : typing.Optional[str]
            Path of the Tool including the Tool name, which is used as a unique identifier.

        name : typing.Optional[str]
            Name of the Tool, which is used as a unique identifier.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        from humanloop.client import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.move(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}",
            method="PATCH",
            json={"path": path, "name": name},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ToolResponse, construct_type(type_=ToolResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_versions(
        self,
        id: str,
        *,
        status: typing.Optional[VersionStatus] = None,
        environment: typing.Optional[str] = None,
        evaluator_aggregates: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListTools:
        """
        Get a list of all the versions of a Tool.

        Parameters
        ----------
        id : str
            Unique identifier for the Tool.

        status : typing.Optional[VersionStatus]
            Filter versions by status: 'uncommitted', 'committed'. If no status is provided, all versions are returned.

        environment : typing.Optional[str]
            Name of the environment to filter versions by. If no environment is provided, all versions are returned.

        evaluator_aggregates : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListTools
            Successful Response

        Examples
        --------
        from humanloop.client import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.list_versions(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}/versions",
            method="GET",
            params={"status": status, "environment": environment, "evaluator_aggregates": evaluator_aggregates},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ListTools, construct_type(type_=ListTools, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def commit(
        self, id: str, version_id: str, *, commit_message: str, request_options: typing.Optional[RequestOptions] = None
    ) -> ToolResponse:
        """
        Commit the Tool Version with the given ID.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        version_id : str
            Unique identifier for the specific version of the Tool.

        commit_message : str
            Message describing the changes made.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        from humanloop.client import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.commit(
            id="id",
            version_id="version_id",
            commit_message="commit_message",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}/versions/{jsonable_encoder(version_id)}/commit",
            method="POST",
            json={"commit_message": commit_message},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ToolResponse, construct_type(type_=ToolResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def log(
        self,
        *,
        version_id: typing.Optional[str] = None,
        environment: typing.Optional[str] = None,
        path: typing.Optional[str] = OMIT,
        id: typing.Optional[str] = OMIT,
        output: typing.Optional[str] = OMIT,
        raw_output: typing.Optional[str] = OMIT,
        created_at: typing.Optional[dt.datetime] = OMIT,
        error: typing.Optional[str] = OMIT,
        provider_latency: typing.Optional[float] = OMIT,
        provider_request: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        provider_response: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        session_id: typing.Optional[str] = OMIT,
        parent_id: typing.Optional[str] = OMIT,
        inputs: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        source: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        save: typing.Optional[bool] = OMIT,
        source_datapoint_id: typing.Optional[str] = OMIT,
        batches: typing.Optional[typing.Sequence[str]] = OMIT,
        user: typing.Optional[str] = OMIT,
        tool_log_request_environment: typing.Optional[str] = OMIT,
        tool: typing.Optional[ToolKernelRequest] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateToolLogResponse:
        """
        Log to a Tool.

        You can use query parameters version_id, or environment, to target
        an existing version of the Tool. Otherwise the default deployed version will be chosen.

        Instead of targeting an existing version explicitly, you can instead pass in
        Tool details in the request body. In this case, we will check if the details correspond
        to an existing version of the Tool, if not we will create a new version. This is helpful
        in the case where you are storing or deriving your Tool details in code.

        Parameters
        ----------
        version_id : typing.Optional[str]
            A specific Version ID of the Tool to log to.

        environment : typing.Optional[str]
            Name of the Environment identifying a deployed version to log to.

        path : typing.Optional[str]
            Path of the Tool, including the name, which is used as a unique identifier.

        id : typing.Optional[str]
            ID for an existing Tool to update.

        output : typing.Optional[str]
            Generated output from your model for the provided inputs. Can be `None` if logging an error, or if creating a parent Log with the intention to populate it later.

        raw_output : typing.Optional[str]
            Raw output from the provider.

        created_at : typing.Optional[dt.datetime]
            User defined timestamp for when the log was created.

        error : typing.Optional[str]
            Error message if the log is an error.

        provider_latency : typing.Optional[float]
            Duration of the logged event in seconds.

        provider_request : typing.Optional[typing.Dict[str, typing.Any]]
            Raw request sent to provider.

        provider_response : typing.Optional[typing.Dict[str, typing.Any]]
            Raw response received the provider.

        session_id : typing.Optional[str]
            Unique identifier for the Session to associate the Log to. Allows you to record multiple Logs to a Session (using an ID kept by your internal systems) by passing the same `session_id` in subsequent log requests.

        parent_id : typing.Optional[str]
            Unique identifier for the parent Log in a Session. Should only be provided if `session_id` is provided. If provided, the Log will be nested under the parent Log within the Session.

        inputs : typing.Optional[typing.Dict[str, typing.Any]]
            The inputs passed to the prompt template.

        source : typing.Optional[str]
            Identifies where the model was called from.

        metadata : typing.Optional[typing.Dict[str, typing.Any]]
            Any additional metadata to record.

        save : typing.Optional[bool]
            Whether the request/response payloads will be stored on Humanloop.

        source_datapoint_id : typing.Optional[str]
            Unique identifier for the Datapoint that this Log is derived from. This can be used by Humanloop to associate Logs to Evaluations. If provided, Humanloop will automatically associate this Log to Evaluations that require a Log for this Datapoint-Version pair.

        batches : typing.Optional[typing.Sequence[str]]
            Array of Batch Ids that this log is part of. Batches are used to group Logs together for offline Evaluations

        user : typing.Optional[str]
            End-user ID related to the Log.

        tool_log_request_environment : typing.Optional[str]
            The name of the Environment the Log is associated to.

        tool : typing.Optional[ToolKernelRequest]
            Details of your Tool. A new Tool version will be created if the provided details are new.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateToolLogResponse
            Successful Response

        Examples
        --------
        from humanloop.client import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.log()
        """
        _response = self._client_wrapper.httpx_client.request(
            "tools/log",
            method="POST",
            params={"version_id": version_id, "environment": environment},
            json={
                "path": path,
                "id": id,
                "output": output,
                "raw_output": raw_output,
                "created_at": created_at,
                "error": error,
                "provider_latency": provider_latency,
                "provider_request": provider_request,
                "provider_response": provider_response,
                "session_id": session_id,
                "parent_id": parent_id,
                "inputs": inputs,
                "source": source,
                "metadata": metadata,
                "save": save,
                "source_datapoint_id": source_datapoint_id,
                "batches": batches,
                "user": user,
                "environment": tool_log_request_environment,
                "tool": tool,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(CreateToolLogResponse, construct_type(type_=CreateToolLogResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_evaluators(
        self,
        id: str,
        *,
        evaluators_to_activate: typing.Optional[
            typing.Sequence[EvaluatorActivationDeactivationRequestEvaluatorsToActivateItem]
        ] = OMIT,
        evaluators_to_deactivate: typing.Optional[
            typing.Sequence[EvaluatorActivationDeactivationRequestEvaluatorsToDeactivateItem]
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolResponse:
        """
        Activate and deactivate Evaluators for the Tool.

        An activated Evaluator will automatically be run on all new Logs
        within the Tool for monitoring purposes.

        Parameters
        ----------
        id : str

        evaluators_to_activate : typing.Optional[typing.Sequence[EvaluatorActivationDeactivationRequestEvaluatorsToActivateItem]]
            Monitoring Evaluators to activate. These will be automatically run on new Logs.

        evaluators_to_deactivate : typing.Optional[typing.Sequence[EvaluatorActivationDeactivationRequestEvaluatorsToDeactivateItem]]
            Evaluators to deactivate. These will not be run on new Logs.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        from humanloop.client import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.update_evaluators(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}/evaluators",
            method="POST",
            json={
                "evaluators_to_activate": evaluators_to_activate,
                "evaluators_to_deactivate": evaluators_to_deactivate,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ToolResponse, construct_type(type_=ToolResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def deploy(
        self, id: str, environment_id: str, *, version_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> ToolResponse:
        """
        Deploy Tool to Environment.

        Set the deployed Version for the specified Environment. This Tool Version
        will be used for calls made to the Tool in this Environment.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        environment_id : str
            Unique identifier for the Environment to deploy the Version to.

        version_id : str
            Unique identifier for the specific version of the Tool.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        from humanloop.client import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.deploy(
            id="id",
            environment_id="environment_id",
            version_id="version_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}/environments/{jsonable_encoder(environment_id)}",
            method="POST",
            params={"version_id": version_id},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ToolResponse, construct_type(type_=ToolResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def remove_deployment(
        self, id: str, environment_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Remove deployment of Tool from Environment.

        Remove the deployed Version for the specified Environment. This Tool Version
        will no longer be used for calls made to the Tool in this Environment.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        environment_id : str
            Unique identifier for the Environment to remove the deployment from.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from humanloop.client import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.remove_deployment(
            id="id",
            environment_id="environment_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}/environments/{jsonable_encoder(environment_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_environments(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[FileEnvironmentResponse]:
        """
        List all Environments and their deployed versions for the Tool.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[FileEnvironmentResponse]
            Successful Response

        Examples
        --------
        from humanloop.client import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.list_environments(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}/environments", method="GET", request_options=request_options
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(typing.List[FileEnvironmentResponse], construct_type(type_=typing.List[FileEnvironmentResponse], object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncToolsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        page: typing.Optional[int] = None,
        size: typing.Optional[int] = None,
        name: typing.Optional[str] = None,
        user_filter: typing.Optional[str] = None,
        sort_by: typing.Optional[ProjectSortBy] = None,
        order: typing.Optional[SortOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPager[ToolResponse]:
        """
        Get a list of Tools.

        Parameters
        ----------
        page : typing.Optional[int]
            Page offset for pagination.

        size : typing.Optional[int]
            Page size for pagination. Number of Tools to fetch.

        name : typing.Optional[str]
            Case-insensitive filter for Tool name.

        user_filter : typing.Optional[str]
            Case-insensitive filter for users in the Tool. This filter matches against both email address and name of users.

        sort_by : typing.Optional[ProjectSortBy]
            Field to sort Tools by

        order : typing.Optional[SortOrder]
            Direction to sort by.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPager[ToolResponse]
            Successful Response

        Examples
        --------
        from humanloop.client import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )
        response = await client.tools.list()
        async for item in response:
            yield item
        # alternatively, you can paginate page-by-page
        async for page in response.iter_pages():
            yield page
        """
        page = page or 1
        _response = await self._client_wrapper.httpx_client.request(
            "tools",
            method="GET",
            params={
                "page": page,
                "size": size,
                "name": name,
                "user_filter": user_filter,
                "sort_by": sort_by,
                "order": order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(ListTools, construct_type(type_=ListTools, object_=_response.json()))  # type: ignore
                _has_next = True
                _get_next = lambda: self.list(
                    page=page + 1,
                    size=size,
                    name=name,
                    user_filter=user_filter,
                    sort_by=sort_by,
                    order=order,
                    request_options=request_options,
                )
                _items = _parsed_response.records
                return AsyncPager(has_next=_has_next, items=_items, get_next=_get_next)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def upsert(
        self,
        *,
        path: typing.Optional[str] = OMIT,
        id: typing.Optional[str] = OMIT,
        function: typing.Optional[ToolFunction] = OMIT,
        source_code: typing.Optional[str] = OMIT,
        setup_values: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        tool_type: typing.Optional[FilesToolType] = OMIT,
        commit_message: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolResponse:
        """
        Create a Tool or update it with a new version if it already exists.

        Tools are identified by the `ID` or their `path`. The name, description and parameters determine the versions of the Tool.

        If you provide a commit message, then the new version will be committed;
        otherwise it will be uncommitted. If you try to commit an already committed version,
        an exception will be raised.

        Parameters
        ----------
        path : typing.Optional[str]
            Path of the Tool, including the name, which is used as a unique identifier.

        id : typing.Optional[str]
            ID for an existing Tool to update.

        function : typing.Optional[ToolFunction]
            Callable function specification of the Tool shown to the model for tool calling.

        source_code : typing.Optional[str]
            Code source of the Tool.

        setup_values : typing.Optional[typing.Dict[str, typing.Any]]
            Values needed to setup the Tool, defined in JSON Schema format: https://json-schema.org/

        tool_type : typing.Optional[FilesToolType]
            Type of Tool.

        commit_message : typing.Optional[str]
            Message describing the changes made.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        from humanloop.client import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )
        await client.tools.upsert()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "tools",
            method="POST",
            json={
                "path": path,
                "id": id,
                "function": function,
                "source_code": source_code,
                "setup_values": setup_values,
                "tool_type": tool_type,
                "commit_message": commit_message,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ToolResponse, construct_type(type_=ToolResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(
        self,
        id: str,
        *,
        version_id: typing.Optional[str] = None,
        environment: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolResponse:
        """
        Retrieve the Tool with the given ID.

        By default, the deployed version of the Tool is returned. Use the query parameters
        `version_id` or `environment` to target a specific version of the Tool.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        version_id : typing.Optional[str]
            A specific Version ID of the Tool to retrieve.

        environment : typing.Optional[str]
            Name of the Environment to retrieve a deployed Version from.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        from humanloop.client import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )
        await client.tools.get(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}",
            method="GET",
            params={"version_id": version_id, "environment": environment},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ToolResponse, construct_type(type_=ToolResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Delete the Tool with the given ID.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from humanloop.client import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )
        await client.tools.delete(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}", method="DELETE", request_options=request_options
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def move(
        self,
        id: str,
        *,
        path: typing.Optional[str] = OMIT,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolResponse:
        """
        Move the Tool to a different path or change the name.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        path : typing.Optional[str]
            Path of the Tool including the Tool name, which is used as a unique identifier.

        name : typing.Optional[str]
            Name of the Tool, which is used as a unique identifier.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        from humanloop.client import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )
        await client.tools.move(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}",
            method="PATCH",
            json={"path": path, "name": name},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ToolResponse, construct_type(type_=ToolResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_versions(
        self,
        id: str,
        *,
        status: typing.Optional[VersionStatus] = None,
        environment: typing.Optional[str] = None,
        evaluator_aggregates: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListTools:
        """
        Get a list of all the versions of a Tool.

        Parameters
        ----------
        id : str
            Unique identifier for the Tool.

        status : typing.Optional[VersionStatus]
            Filter versions by status: 'uncommitted', 'committed'. If no status is provided, all versions are returned.

        environment : typing.Optional[str]
            Name of the environment to filter versions by. If no environment is provided, all versions are returned.

        evaluator_aggregates : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListTools
            Successful Response

        Examples
        --------
        from humanloop.client import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )
        await client.tools.list_versions(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}/versions",
            method="GET",
            params={"status": status, "environment": environment, "evaluator_aggregates": evaluator_aggregates},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ListTools, construct_type(type_=ListTools, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def commit(
        self, id: str, version_id: str, *, commit_message: str, request_options: typing.Optional[RequestOptions] = None
    ) -> ToolResponse:
        """
        Commit the Tool Version with the given ID.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        version_id : str
            Unique identifier for the specific version of the Tool.

        commit_message : str
            Message describing the changes made.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        from humanloop.client import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )
        await client.tools.commit(
            id="id",
            version_id="version_id",
            commit_message="commit_message",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}/versions/{jsonable_encoder(version_id)}/commit",
            method="POST",
            json={"commit_message": commit_message},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ToolResponse, construct_type(type_=ToolResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def log(
        self,
        *,
        version_id: typing.Optional[str] = None,
        environment: typing.Optional[str] = None,
        path: typing.Optional[str] = OMIT,
        id: typing.Optional[str] = OMIT,
        output: typing.Optional[str] = OMIT,
        raw_output: typing.Optional[str] = OMIT,
        created_at: typing.Optional[dt.datetime] = OMIT,
        error: typing.Optional[str] = OMIT,
        provider_latency: typing.Optional[float] = OMIT,
        provider_request: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        provider_response: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        session_id: typing.Optional[str] = OMIT,
        parent_id: typing.Optional[str] = OMIT,
        inputs: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        source: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        save: typing.Optional[bool] = OMIT,
        source_datapoint_id: typing.Optional[str] = OMIT,
        batches: typing.Optional[typing.Sequence[str]] = OMIT,
        user: typing.Optional[str] = OMIT,
        tool_log_request_environment: typing.Optional[str] = OMIT,
        tool: typing.Optional[ToolKernelRequest] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateToolLogResponse:
        """
        Log to a Tool.

        You can use query parameters version_id, or environment, to target
        an existing version of the Tool. Otherwise the default deployed version will be chosen.

        Instead of targeting an existing version explicitly, you can instead pass in
        Tool details in the request body. In this case, we will check if the details correspond
        to an existing version of the Tool, if not we will create a new version. This is helpful
        in the case where you are storing or deriving your Tool details in code.

        Parameters
        ----------
        version_id : typing.Optional[str]
            A specific Version ID of the Tool to log to.

        environment : typing.Optional[str]
            Name of the Environment identifying a deployed version to log to.

        path : typing.Optional[str]
            Path of the Tool, including the name, which is used as a unique identifier.

        id : typing.Optional[str]
            ID for an existing Tool to update.

        output : typing.Optional[str]
            Generated output from your model for the provided inputs. Can be `None` if logging an error, or if creating a parent Log with the intention to populate it later.

        raw_output : typing.Optional[str]
            Raw output from the provider.

        created_at : typing.Optional[dt.datetime]
            User defined timestamp for when the log was created.

        error : typing.Optional[str]
            Error message if the log is an error.

        provider_latency : typing.Optional[float]
            Duration of the logged event in seconds.

        provider_request : typing.Optional[typing.Dict[str, typing.Any]]
            Raw request sent to provider.

        provider_response : typing.Optional[typing.Dict[str, typing.Any]]
            Raw response received the provider.

        session_id : typing.Optional[str]
            Unique identifier for the Session to associate the Log to. Allows you to record multiple Logs to a Session (using an ID kept by your internal systems) by passing the same `session_id` in subsequent log requests.

        parent_id : typing.Optional[str]
            Unique identifier for the parent Log in a Session. Should only be provided if `session_id` is provided. If provided, the Log will be nested under the parent Log within the Session.

        inputs : typing.Optional[typing.Dict[str, typing.Any]]
            The inputs passed to the prompt template.

        source : typing.Optional[str]
            Identifies where the model was called from.

        metadata : typing.Optional[typing.Dict[str, typing.Any]]
            Any additional metadata to record.

        save : typing.Optional[bool]
            Whether the request/response payloads will be stored on Humanloop.

        source_datapoint_id : typing.Optional[str]
            Unique identifier for the Datapoint that this Log is derived from. This can be used by Humanloop to associate Logs to Evaluations. If provided, Humanloop will automatically associate this Log to Evaluations that require a Log for this Datapoint-Version pair.

        batches : typing.Optional[typing.Sequence[str]]
            Array of Batch Ids that this log is part of. Batches are used to group Logs together for offline Evaluations

        user : typing.Optional[str]
            End-user ID related to the Log.

        tool_log_request_environment : typing.Optional[str]
            The name of the Environment the Log is associated to.

        tool : typing.Optional[ToolKernelRequest]
            Details of your Tool. A new Tool version will be created if the provided details are new.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateToolLogResponse
            Successful Response

        Examples
        --------
        from humanloop.client import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )
        await client.tools.log()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "tools/log",
            method="POST",
            params={"version_id": version_id, "environment": environment},
            json={
                "path": path,
                "id": id,
                "output": output,
                "raw_output": raw_output,
                "created_at": created_at,
                "error": error,
                "provider_latency": provider_latency,
                "provider_request": provider_request,
                "provider_response": provider_response,
                "session_id": session_id,
                "parent_id": parent_id,
                "inputs": inputs,
                "source": source,
                "metadata": metadata,
                "save": save,
                "source_datapoint_id": source_datapoint_id,
                "batches": batches,
                "user": user,
                "environment": tool_log_request_environment,
                "tool": tool,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(CreateToolLogResponse, construct_type(type_=CreateToolLogResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_evaluators(
        self,
        id: str,
        *,
        evaluators_to_activate: typing.Optional[
            typing.Sequence[EvaluatorActivationDeactivationRequestEvaluatorsToActivateItem]
        ] = OMIT,
        evaluators_to_deactivate: typing.Optional[
            typing.Sequence[EvaluatorActivationDeactivationRequestEvaluatorsToDeactivateItem]
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolResponse:
        """
        Activate and deactivate Evaluators for the Tool.

        An activated Evaluator will automatically be run on all new Logs
        within the Tool for monitoring purposes.

        Parameters
        ----------
        id : str

        evaluators_to_activate : typing.Optional[typing.Sequence[EvaluatorActivationDeactivationRequestEvaluatorsToActivateItem]]
            Monitoring Evaluators to activate. These will be automatically run on new Logs.

        evaluators_to_deactivate : typing.Optional[typing.Sequence[EvaluatorActivationDeactivationRequestEvaluatorsToDeactivateItem]]
            Evaluators to deactivate. These will not be run on new Logs.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        from humanloop.client import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )
        await client.tools.update_evaluators(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}/evaluators",
            method="POST",
            json={
                "evaluators_to_activate": evaluators_to_activate,
                "evaluators_to_deactivate": evaluators_to_deactivate,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ToolResponse, construct_type(type_=ToolResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def deploy(
        self, id: str, environment_id: str, *, version_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> ToolResponse:
        """
        Deploy Tool to Environment.

        Set the deployed Version for the specified Environment. This Tool Version
        will be used for calls made to the Tool in this Environment.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        environment_id : str
            Unique identifier for the Environment to deploy the Version to.

        version_id : str
            Unique identifier for the specific version of the Tool.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        from humanloop.client import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )
        await client.tools.deploy(
            id="id",
            environment_id="environment_id",
            version_id="version_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}/environments/{jsonable_encoder(environment_id)}",
            method="POST",
            params={"version_id": version_id},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ToolResponse, construct_type(type_=ToolResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def remove_deployment(
        self, id: str, environment_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Remove deployment of Tool from Environment.

        Remove the deployed Version for the specified Environment. This Tool Version
        will no longer be used for calls made to the Tool in this Environment.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        environment_id : str
            Unique identifier for the Environment to remove the deployment from.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from humanloop.client import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )
        await client.tools.remove_deployment(
            id="id",
            environment_id="environment_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}/environments/{jsonable_encoder(environment_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_environments(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[FileEnvironmentResponse]:
        """
        List all Environments and their deployed versions for the Tool.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[FileEnvironmentResponse]
            Successful Response

        Examples
        --------
        from humanloop.client import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )
        await client.tools.list_environments(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}/environments", method="GET", request_options=request_options
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(typing.List[FileEnvironmentResponse], construct_type(type_=typing.List[FileEnvironmentResponse], object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
