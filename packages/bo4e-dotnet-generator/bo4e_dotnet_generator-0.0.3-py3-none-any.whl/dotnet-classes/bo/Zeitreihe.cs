// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using BO4EDotNet;
//
//    var zeitreihe = Zeitreihe.FromJson(jsonString);

namespace BO4EDotNet
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    /// <summary>
    /// Abbildung einer allgemeinen Zeitreihe mit einem Wertvektor.
    /// Die Werte können mit wahlfreier zeitlicher Distanz im Vektor abgelegt sein.
    ///
    /// .. raw:: html
    ///
    /// <object data="../_static/images/bo4e/bo/Zeitreihe.svg" type="image/svg+xml"></object>
    ///
    /// .. HINT::
    /// `Zeitreihe JSON Schema
    /// <https://json-schema.app/view/%23?url=https://raw.githubusercontent.com/BO4E/BO4E-Schemas/v202401.2.1/src/bo4e_schemas/bo/Zeitreihe.json>`_
    /// </summary>
    public partial class Zeitreihe
    {
        /// <summary>
        /// Hier können IDs anderer Systeme hinterlegt werden (z.B. eine SAP-GP-Nummer oder eine GUID)
        /// </summary>
        [JsonProperty("_id")]
        public string Id { get; set; }

        /// <summary>
        /// Bezeichnung für die Zeitreihe
        /// </summary>
        [JsonProperty("_typ")]
        public Typ? Typ { get; set; }

        /// <summary>
        /// Beschreibt die Verwendung der Zeitreihe
        /// </summary>
        [JsonProperty("beschreibung")]
        public string Beschreibung { get; set; }

        /// <summary>
        /// Bezeichnung für die Zeitreihe
        /// </summary>
        [JsonProperty("bezeichnung")]
        public string Bezeichnung { get; set; }

        /// <summary>
        /// Alle Werte in der Tabelle haben die Einheit, die hier angegeben ist
        /// </summary>
        [JsonProperty("einheit")]
        public Mengeneinheit? Einheit { get; set; }

        /// <summary>
        /// Medium, das gemessen wurde (z.B. Wasser, Dampf, Strom, Gas)
        /// </summary>
        [JsonProperty("medium")]
        public Medium? Medium { get; set; }

        /// <summary>
        /// Beschreibt die Art der Messung (z.B. aktueller Wert, mittlerer Wert, maximaler Wert)
        /// </summary>
        [JsonProperty("messart")]
        public Messart? Messart { get; set; }

        /// <summary>
        /// Beschreibt, was gemessen wurde (z.B. Strom, Spannung, Wirkleistung, Scheinleistung)
        /// </summary>
        [JsonProperty("messgroesse")]
        public Messgroesse? Messgroesse { get; set; }

        /// <summary>
        /// Version der Zeitreihe
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }

        /// <summary>
        /// Hier liegen jeweils die Werte
        /// </summary>
        [JsonProperty("werte")]
        public Zeitreihenwert[] Werte { get; set; }

        /// <summary>
        /// Kennzeichnung, wie die Werte entstanden sind, z.B. durch Messung
        /// </summary>
        [JsonProperty("wertherkunft")]
        public Wertermittlungsverfahren? Wertherkunft { get; set; }

        [JsonProperty("zusatzAttribute")]
        public ZusatzAttribut[] ZusatzAttribute { get; set; }
    }



    /// <summary>
    /// Viele Datenobjekte weisen in unterschiedlichen Systemen eine eindeutige ID (Kundennummer,
    /// GP-Nummer etc.) auf.
    /// Beim Austausch von Datenobjekten zwischen verschiedenen Systemen ist es daher hilfreich,
    /// sich die eindeutigen IDs der anzubindenden Systeme zu merken.
    ///
    /// .. raw:: html
    ///
    /// <object data="../_static/images/bo4e/com/ZusatzAttribut.svg"
    /// type="image/svg+xml"></object>
    ///
    /// .. HINT::
    /// `ZusatzAttribut JSON Schema
    /// <https://json-schema.app/view/%23?url=https://raw.githubusercontent.com/BO4E/BO4E-Schemas/v202401.2.1/src/bo4e_schemas/ZusatzAttribut.json>`_
    /// </summary>
    public partial class ZusatzAttribut
    {
        /// <summary>
        /// Bezeichnung der externen Referenz (z.B. "microservice xyz" oder "SAP CRM GP-Nummer")
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }

        /// <summary>
        /// Bezeichnung der externen Referenz (z.B. "microservice xyz" oder "SAP CRM GP-Nummer")
        /// </summary>
        [JsonProperty("wert")]
        public object Wert { get; set; }
    }

    /// <summary>
    /// Einheit: Messgrößen, die per Messung oder Vorgabe ermittelt werden können.
    /// </summary>
    public enum Mengeneinheit { Halbjahr, Jahr, Kubikmeter, Kvar, Kvarh, Kw, Kwh, Kwhk, Minute, Monat, Mw, Mwh, Prozent, Quartal, Sekunde, Stueck, Stunde, Tag, Var, Varh, ViertelStunde, W, Wh, Woche };

    /// <summary>
    /// Gibt ein physikalisches Medium an.
    /// </summary>
    public enum Medium { Dampf, Gas, Strom, Wasser };

    /// <summary>
    /// Gibt an, auf welche Art gemessen wurde.
    /// </summary>
    public enum Messart { Aktuellerwert, Maximalwert, Mittelwert };

    /// <summary>
    /// Gibt die physikalische Größe an, die gemessen wurde.
    /// </summary>
    public enum Messgroesse { Blindleistung, Brennwert, Druck, Gradtzagszahlen, Lastgang, Lastprofil, Preise, Spannung, Strom, Temperatur, Volumenstrom, Wirkleistung, Zzahl };

    /// <summary>
    /// Auflistung sämtlicher existierender Geschäftsobjekte.
    /// </summary>
    public enum Typ { Angebot, Ausschreibung, Buendelvertrag, Energiemenge, Fremdkosten, Geraet, Geschaeftsobjekt, Geschaeftspartner, Kosten, Lastgang, Marktlokation, Marktteilnehmer, Messlokation, Netznutzungsrechnung, Person, Preisblatt, Preisblattdienstleistung, Preisblatthardware, Preisblattkonzessionsabgabe, Preisblattmessung, Preisblattnetznutzung, Preisblattumlagen, Rechnung, Region, Regionaltarif, Standorteigenschaften, Tarif, Tarifinfo, Tarifkosten, Tarifpreisblatt, Vertrag, Zaehler, Zeitreihe };

    /// <summary>
    /// Der Status eines Zählerstandes
    /// </summary>
    public enum Messwertstatus { Abgelesen, AngabeFuerLieferschein, Energiemengesummiert, Ersatzwert, Fehlt, NichtVerwendbar, Prognosewert, Vorlaeufigerwert, Vorschlagswert };

    /// <summary>
    /// Aufzählung von zusätzlichen Informationen zum Status, beispielsweise in Lastgängen oder
    /// Zählwerkständen.
    /// </summary>
    public enum Messwertstatuszusatz { Z74Keinzugang, Z75Kommunikationsstoerung, Z76Netzausfall, Z77Spannungsausfall, Z78Geraetewechsel, Z79Kalibrierung, Z80Geraetarbeitetausserhalbderbetriebsbedingungen, Z81MesseinrichtunggestoertDefekt, Z82Unsicherheitmessung, Z84Leerstand, Z85Realerzaehlerueberlaufgeprueft, Z86Plausibelwgkontrollablesung, Z87Plausibelwgkundenhinweis, Z88VergleichsmessungGeeicht, Z89VergleichsmessungNichtgeeicht, Z90Messwertnachbildungausgeeichtenwerten, Z91Messwertnachbildungausnichtgeeichtenwerten, Z92Interpolation, Z93Haltewert, Z94Bilanzierungnetzabschnitt, Z95Historischemesswerte, Z98Beruecksichtigungstoermengenzaehlwerk, Z99Mengenumwertungunvollstaendig, Za0UhrzeitgestelltSynchronisation, Za1Messwertunplausibel, Za3Falscherwandlerfaktor, Za4Fehlerhafteablesung, Za5Aenderungderberechnung, Za6Umbaudermesslokation, Za7Datenbearbeitungsfehler, Za8Brennwertkorrektur, Za9ZZahlKorrektur, Zb0StoerungDefektmesseinrichtung, Zb9Aenderungtarifschaltzeiten, Zc2Tarifschaltgeraetdefekt, Zc3Austauschdesersatzwertes, Zc4Impulswertigkeitnichtausreichend, Zg3Umstellunggasqualitaet, Zj2Statistischemethode };

    /// <summary>
    /// Gibt an, ob es sich um eine Prognose oder eine Messung handelt, beispielsweise bei der
    /// Abbildung eines Verbrauchs.
    /// </summary>
    public enum Wertermittlungsverfahren { Messung, Prognose };

    public partial class Zeitreihe
    {
        public static Zeitreihe FromJson(string json) => JsonConvert.DeserializeObject<Zeitreihe>(json, BO4EDotNet.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Zeitreihe self) => JsonConvert.SerializeObject(self, BO4EDotNet.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                TypConverter.Singleton,
                MengeneinheitConverter.Singleton,
                MediumConverter.Singleton,
                MessartConverter.Singleton,
                MessgroesseConverter.Singleton,
                MesswertstatusConverter.Singleton,
                MesswertstatuszusatzConverter.Singleton,
                WertermittlungsverfahrenConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class TypConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Typ) || t == typeof(Typ?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ANGEBOT":
                    return Typ.Angebot;
                case "AUSSCHREIBUNG":
                    return Typ.Ausschreibung;
                case "BUENDELVERTRAG":
                    return Typ.Buendelvertrag;
                case "ENERGIEMENGE":
                    return Typ.Energiemenge;
                case "FREMDKOSTEN":
                    return Typ.Fremdkosten;
                case "GERAET":
                    return Typ.Geraet;
                case "GESCHAEFTSOBJEKT":
                    return Typ.Geschaeftsobjekt;
                case "GESCHAEFTSPARTNER":
                    return Typ.Geschaeftspartner;
                case "KOSTEN":
                    return Typ.Kosten;
                case "LASTGANG":
                    return Typ.Lastgang;
                case "MARKTLOKATION":
                    return Typ.Marktlokation;
                case "MARKTTEILNEHMER":
                    return Typ.Marktteilnehmer;
                case "MESSLOKATION":
                    return Typ.Messlokation;
                case "NETZNUTZUNGSRECHNUNG":
                    return Typ.Netznutzungsrechnung;
                case "PERSON":
                    return Typ.Person;
                case "PREISBLATT":
                    return Typ.Preisblatt;
                case "PREISBLATTDIENSTLEISTUNG":
                    return Typ.Preisblattdienstleistung;
                case "PREISBLATTHARDWARE":
                    return Typ.Preisblatthardware;
                case "PREISBLATTKONZESSIONSABGABE":
                    return Typ.Preisblattkonzessionsabgabe;
                case "PREISBLATTMESSUNG":
                    return Typ.Preisblattmessung;
                case "PREISBLATTNETZNUTZUNG":
                    return Typ.Preisblattnetznutzung;
                case "PREISBLATTUMLAGEN":
                    return Typ.Preisblattumlagen;
                case "RECHNUNG":
                    return Typ.Rechnung;
                case "REGION":
                    return Typ.Region;
                case "REGIONALTARIF":
                    return Typ.Regionaltarif;
                case "STANDORTEIGENSCHAFTEN":
                    return Typ.Standorteigenschaften;
                case "TARIF":
                    return Typ.Tarif;
                case "TARIFINFO":
                    return Typ.Tarifinfo;
                case "TARIFKOSTEN":
                    return Typ.Tarifkosten;
                case "TARIFPREISBLATT":
                    return Typ.Tarifpreisblatt;
                case "VERTRAG":
                    return Typ.Vertrag;
                case "ZAEHLER":
                    return Typ.Zaehler;
                case "ZEITREIHE":
                    return Typ.Zeitreihe;
            }
            throw new Exception("Cannot unmarshal type Typ");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Typ)untypedValue;
            switch (value)
            {
                case Typ.Angebot:
                    serializer.Serialize(writer, "ANGEBOT");
                    return;
                case Typ.Ausschreibung:
                    serializer.Serialize(writer, "AUSSCHREIBUNG");
                    return;
                case Typ.Buendelvertrag:
                    serializer.Serialize(writer, "BUENDELVERTRAG");
                    return;
                case Typ.Energiemenge:
                    serializer.Serialize(writer, "ENERGIEMENGE");
                    return;
                case Typ.Fremdkosten:
                    serializer.Serialize(writer, "FREMDKOSTEN");
                    return;
                case Typ.Geraet:
                    serializer.Serialize(writer, "GERAET");
                    return;
                case Typ.Geschaeftsobjekt:
                    serializer.Serialize(writer, "GESCHAEFTSOBJEKT");
                    return;
                case Typ.Geschaeftspartner:
                    serializer.Serialize(writer, "GESCHAEFTSPARTNER");
                    return;
                case Typ.Kosten:
                    serializer.Serialize(writer, "KOSTEN");
                    return;
                case Typ.Lastgang:
                    serializer.Serialize(writer, "LASTGANG");
                    return;
                case Typ.Marktlokation:
                    serializer.Serialize(writer, "MARKTLOKATION");
                    return;
                case Typ.Marktteilnehmer:
                    serializer.Serialize(writer, "MARKTTEILNEHMER");
                    return;
                case Typ.Messlokation:
                    serializer.Serialize(writer, "MESSLOKATION");
                    return;
                case Typ.Netznutzungsrechnung:
                    serializer.Serialize(writer, "NETZNUTZUNGSRECHNUNG");
                    return;
                case Typ.Person:
                    serializer.Serialize(writer, "PERSON");
                    return;
                case Typ.Preisblatt:
                    serializer.Serialize(writer, "PREISBLATT");
                    return;
                case Typ.Preisblattdienstleistung:
                    serializer.Serialize(writer, "PREISBLATTDIENSTLEISTUNG");
                    return;
                case Typ.Preisblatthardware:
                    serializer.Serialize(writer, "PREISBLATTHARDWARE");
                    return;
                case Typ.Preisblattkonzessionsabgabe:
                    serializer.Serialize(writer, "PREISBLATTKONZESSIONSABGABE");
                    return;
                case Typ.Preisblattmessung:
                    serializer.Serialize(writer, "PREISBLATTMESSUNG");
                    return;
                case Typ.Preisblattnetznutzung:
                    serializer.Serialize(writer, "PREISBLATTNETZNUTZUNG");
                    return;
                case Typ.Preisblattumlagen:
                    serializer.Serialize(writer, "PREISBLATTUMLAGEN");
                    return;
                case Typ.Rechnung:
                    serializer.Serialize(writer, "RECHNUNG");
                    return;
                case Typ.Region:
                    serializer.Serialize(writer, "REGION");
                    return;
                case Typ.Regionaltarif:
                    serializer.Serialize(writer, "REGIONALTARIF");
                    return;
                case Typ.Standorteigenschaften:
                    serializer.Serialize(writer, "STANDORTEIGENSCHAFTEN");
                    return;
                case Typ.Tarif:
                    serializer.Serialize(writer, "TARIF");
                    return;
                case Typ.Tarifinfo:
                    serializer.Serialize(writer, "TARIFINFO");
                    return;
                case Typ.Tarifkosten:
                    serializer.Serialize(writer, "TARIFKOSTEN");
                    return;
                case Typ.Tarifpreisblatt:
                    serializer.Serialize(writer, "TARIFPREISBLATT");
                    return;
                case Typ.Vertrag:
                    serializer.Serialize(writer, "VERTRAG");
                    return;
                case Typ.Zaehler:
                    serializer.Serialize(writer, "ZAEHLER");
                    return;
                case Typ.Zeitreihe:
                    serializer.Serialize(writer, "ZEITREIHE");
                    return;
            }
            throw new Exception("Cannot marshal type Typ");
        }

        public static readonly TypConverter Singleton = new TypConverter();
    }

    internal class MengeneinheitConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Mengeneinheit) || t == typeof(Mengeneinheit?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "HALBJAHR":
                    return Mengeneinheit.Halbjahr;
                case "JAHR":
                    return Mengeneinheit.Jahr;
                case "KUBIKMETER":
                    return Mengeneinheit.Kubikmeter;
                case "KVAR":
                    return Mengeneinheit.Kvar;
                case "KVARH":
                    return Mengeneinheit.Kvarh;
                case "KW":
                    return Mengeneinheit.Kw;
                case "KWH":
                    return Mengeneinheit.Kwh;
                case "KWHK":
                    return Mengeneinheit.Kwhk;
                case "MINUTE":
                    return Mengeneinheit.Minute;
                case "MONAT":
                    return Mengeneinheit.Monat;
                case "MW":
                    return Mengeneinheit.Mw;
                case "MWH":
                    return Mengeneinheit.Mwh;
                case "PROZENT":
                    return Mengeneinheit.Prozent;
                case "QUARTAL":
                    return Mengeneinheit.Quartal;
                case "SEKUNDE":
                    return Mengeneinheit.Sekunde;
                case "STUECK":
                    return Mengeneinheit.Stueck;
                case "STUNDE":
                    return Mengeneinheit.Stunde;
                case "TAG":
                    return Mengeneinheit.Tag;
                case "VAR":
                    return Mengeneinheit.Var;
                case "VARH":
                    return Mengeneinheit.Varh;
                case "VIERTEL_STUNDE":
                    return Mengeneinheit.ViertelStunde;
                case "W":
                    return Mengeneinheit.W;
                case "WH":
                    return Mengeneinheit.Wh;
                case "WOCHE":
                    return Mengeneinheit.Woche;
            }
            throw new Exception("Cannot unmarshal type Mengeneinheit");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Mengeneinheit)untypedValue;
            switch (value)
            {
                case Mengeneinheit.Halbjahr:
                    serializer.Serialize(writer, "HALBJAHR");
                    return;
                case Mengeneinheit.Jahr:
                    serializer.Serialize(writer, "JAHR");
                    return;
                case Mengeneinheit.Kubikmeter:
                    serializer.Serialize(writer, "KUBIKMETER");
                    return;
                case Mengeneinheit.Kvar:
                    serializer.Serialize(writer, "KVAR");
                    return;
                case Mengeneinheit.Kvarh:
                    serializer.Serialize(writer, "KVARH");
                    return;
                case Mengeneinheit.Kw:
                    serializer.Serialize(writer, "KW");
                    return;
                case Mengeneinheit.Kwh:
                    serializer.Serialize(writer, "KWH");
                    return;
                case Mengeneinheit.Kwhk:
                    serializer.Serialize(writer, "KWHK");
                    return;
                case Mengeneinheit.Minute:
                    serializer.Serialize(writer, "MINUTE");
                    return;
                case Mengeneinheit.Monat:
                    serializer.Serialize(writer, "MONAT");
                    return;
                case Mengeneinheit.Mw:
                    serializer.Serialize(writer, "MW");
                    return;
                case Mengeneinheit.Mwh:
                    serializer.Serialize(writer, "MWH");
                    return;
                case Mengeneinheit.Prozent:
                    serializer.Serialize(writer, "PROZENT");
                    return;
                case Mengeneinheit.Quartal:
                    serializer.Serialize(writer, "QUARTAL");
                    return;
                case Mengeneinheit.Sekunde:
                    serializer.Serialize(writer, "SEKUNDE");
                    return;
                case Mengeneinheit.Stueck:
                    serializer.Serialize(writer, "STUECK");
                    return;
                case Mengeneinheit.Stunde:
                    serializer.Serialize(writer, "STUNDE");
                    return;
                case Mengeneinheit.Tag:
                    serializer.Serialize(writer, "TAG");
                    return;
                case Mengeneinheit.Var:
                    serializer.Serialize(writer, "VAR");
                    return;
                case Mengeneinheit.Varh:
                    serializer.Serialize(writer, "VARH");
                    return;
                case Mengeneinheit.ViertelStunde:
                    serializer.Serialize(writer, "VIERTEL_STUNDE");
                    return;
                case Mengeneinheit.W:
                    serializer.Serialize(writer, "W");
                    return;
                case Mengeneinheit.Wh:
                    serializer.Serialize(writer, "WH");
                    return;
                case Mengeneinheit.Woche:
                    serializer.Serialize(writer, "WOCHE");
                    return;
            }
            throw new Exception("Cannot marshal type Mengeneinheit");
        }

        public static readonly MengeneinheitConverter Singleton = new MengeneinheitConverter();
    }

    internal class MediumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Medium) || t == typeof(Medium?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "DAMPF":
                    return Medium.Dampf;
                case "GAS":
                    return Medium.Gas;
                case "STROM":
                    return Medium.Strom;
                case "WASSER":
                    return Medium.Wasser;
            }
            throw new Exception("Cannot unmarshal type Medium");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Medium)untypedValue;
            switch (value)
            {
                case Medium.Dampf:
                    serializer.Serialize(writer, "DAMPF");
                    return;
                case Medium.Gas:
                    serializer.Serialize(writer, "GAS");
                    return;
                case Medium.Strom:
                    serializer.Serialize(writer, "STROM");
                    return;
                case Medium.Wasser:
                    serializer.Serialize(writer, "WASSER");
                    return;
            }
            throw new Exception("Cannot marshal type Medium");
        }

        public static readonly MediumConverter Singleton = new MediumConverter();
    }

    internal class MessartConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Messart) || t == typeof(Messart?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "AKTUELLERWERT":
                    return Messart.Aktuellerwert;
                case "MAXIMALWERT":
                    return Messart.Maximalwert;
                case "MITTELWERT":
                    return Messart.Mittelwert;
            }
            throw new Exception("Cannot unmarshal type Messart");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Messart)untypedValue;
            switch (value)
            {
                case Messart.Aktuellerwert:
                    serializer.Serialize(writer, "AKTUELLERWERT");
                    return;
                case Messart.Maximalwert:
                    serializer.Serialize(writer, "MAXIMALWERT");
                    return;
                case Messart.Mittelwert:
                    serializer.Serialize(writer, "MITTELWERT");
                    return;
            }
            throw new Exception("Cannot marshal type Messart");
        }

        public static readonly MessartConverter Singleton = new MessartConverter();
    }

    internal class MessgroesseConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Messgroesse) || t == typeof(Messgroesse?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "BLINDLEISTUNG":
                    return Messgroesse.Blindleistung;
                case "BRENNWERT":
                    return Messgroesse.Brennwert;
                case "DRUCK":
                    return Messgroesse.Druck;
                case "GRADTZAGSZAHLEN":
                    return Messgroesse.Gradtzagszahlen;
                case "LASTGANG":
                    return Messgroesse.Lastgang;
                case "LASTPROFIL":
                    return Messgroesse.Lastprofil;
                case "PREISE":
                    return Messgroesse.Preise;
                case "SPANNUNG":
                    return Messgroesse.Spannung;
                case "STROM":
                    return Messgroesse.Strom;
                case "TEMPERATUR":
                    return Messgroesse.Temperatur;
                case "VOLUMENSTROM":
                    return Messgroesse.Volumenstrom;
                case "WIRKLEISTUNG":
                    return Messgroesse.Wirkleistung;
                case "ZZAHL":
                    return Messgroesse.Zzahl;
            }
            throw new Exception("Cannot unmarshal type Messgroesse");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Messgroesse)untypedValue;
            switch (value)
            {
                case Messgroesse.Blindleistung:
                    serializer.Serialize(writer, "BLINDLEISTUNG");
                    return;
                case Messgroesse.Brennwert:
                    serializer.Serialize(writer, "BRENNWERT");
                    return;
                case Messgroesse.Druck:
                    serializer.Serialize(writer, "DRUCK");
                    return;
                case Messgroesse.Gradtzagszahlen:
                    serializer.Serialize(writer, "GRADTZAGSZAHLEN");
                    return;
                case Messgroesse.Lastgang:
                    serializer.Serialize(writer, "LASTGANG");
                    return;
                case Messgroesse.Lastprofil:
                    serializer.Serialize(writer, "LASTPROFIL");
                    return;
                case Messgroesse.Preise:
                    serializer.Serialize(writer, "PREISE");
                    return;
                case Messgroesse.Spannung:
                    serializer.Serialize(writer, "SPANNUNG");
                    return;
                case Messgroesse.Strom:
                    serializer.Serialize(writer, "STROM");
                    return;
                case Messgroesse.Temperatur:
                    serializer.Serialize(writer, "TEMPERATUR");
                    return;
                case Messgroesse.Volumenstrom:
                    serializer.Serialize(writer, "VOLUMENSTROM");
                    return;
                case Messgroesse.Wirkleistung:
                    serializer.Serialize(writer, "WIRKLEISTUNG");
                    return;
                case Messgroesse.Zzahl:
                    serializer.Serialize(writer, "ZZAHL");
                    return;
            }
            throw new Exception("Cannot marshal type Messgroesse");
        }

        public static readonly MessgroesseConverter Singleton = new MessgroesseConverter();
    }

    internal class MesswertstatusConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Messwertstatus) || t == typeof(Messwertstatus?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ABGELESEN":
                    return Messwertstatus.Abgelesen;
                case "ANGABE_FUER_LIEFERSCHEIN":
                    return Messwertstatus.AngabeFuerLieferschein;
                case "ENERGIEMENGESUMMIERT":
                    return Messwertstatus.Energiemengesummiert;
                case "ERSATZWERT":
                    return Messwertstatus.Ersatzwert;
                case "FEHLT":
                    return Messwertstatus.Fehlt;
                case "NICHT_VERWENDBAR":
                    return Messwertstatus.NichtVerwendbar;
                case "PROGNOSEWERT":
                    return Messwertstatus.Prognosewert;
                case "VORLAEUFIGERWERT":
                    return Messwertstatus.Vorlaeufigerwert;
                case "VORSCHLAGSWERT":
                    return Messwertstatus.Vorschlagswert;
            }
            throw new Exception("Cannot unmarshal type Messwertstatus");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Messwertstatus)untypedValue;
            switch (value)
            {
                case Messwertstatus.Abgelesen:
                    serializer.Serialize(writer, "ABGELESEN");
                    return;
                case Messwertstatus.AngabeFuerLieferschein:
                    serializer.Serialize(writer, "ANGABE_FUER_LIEFERSCHEIN");
                    return;
                case Messwertstatus.Energiemengesummiert:
                    serializer.Serialize(writer, "ENERGIEMENGESUMMIERT");
                    return;
                case Messwertstatus.Ersatzwert:
                    serializer.Serialize(writer, "ERSATZWERT");
                    return;
                case Messwertstatus.Fehlt:
                    serializer.Serialize(writer, "FEHLT");
                    return;
                case Messwertstatus.NichtVerwendbar:
                    serializer.Serialize(writer, "NICHT_VERWENDBAR");
                    return;
                case Messwertstatus.Prognosewert:
                    serializer.Serialize(writer, "PROGNOSEWERT");
                    return;
                case Messwertstatus.Vorlaeufigerwert:
                    serializer.Serialize(writer, "VORLAEUFIGERWERT");
                    return;
                case Messwertstatus.Vorschlagswert:
                    serializer.Serialize(writer, "VORSCHLAGSWERT");
                    return;
            }
            throw new Exception("Cannot marshal type Messwertstatus");
        }

        public static readonly MesswertstatusConverter Singleton = new MesswertstatusConverter();
    }

    internal class MesswertstatuszusatzConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Messwertstatuszusatz) || t == typeof(Messwertstatuszusatz?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Z74_KEINZUGANG":
                    return Messwertstatuszusatz.Z74Keinzugang;
                case "Z75_KOMMUNIKATIONSSTOERUNG":
                    return Messwertstatuszusatz.Z75Kommunikationsstoerung;
                case "Z76_NETZAUSFALL":
                    return Messwertstatuszusatz.Z76Netzausfall;
                case "Z77_SPANNUNGSAUSFALL":
                    return Messwertstatuszusatz.Z77Spannungsausfall;
                case "Z78_GERAETEWECHSEL":
                    return Messwertstatuszusatz.Z78Geraetewechsel;
                case "Z79_KALIBRIERUNG":
                    return Messwertstatuszusatz.Z79Kalibrierung;
                case "Z80_GERAETARBEITETAUSSERHALBDERBETRIEBSBEDINGUNGEN":
                    return Messwertstatuszusatz.Z80Geraetarbeitetausserhalbderbetriebsbedingungen;
                case "Z81_MESSEINRICHTUNGGESTOERT_DEFEKT":
                    return Messwertstatuszusatz.Z81MesseinrichtunggestoertDefekt;
                case "Z82_UNSICHERHEITMESSUNG":
                    return Messwertstatuszusatz.Z82Unsicherheitmessung;
                case "Z84_LEERSTAND":
                    return Messwertstatuszusatz.Z84Leerstand;
                case "Z85_REALERZAEHLERUEBERLAUFGEPRUEFT":
                    return Messwertstatuszusatz.Z85Realerzaehlerueberlaufgeprueft;
                case "Z86_PLAUSIBELWGKONTROLLABLESUNG":
                    return Messwertstatuszusatz.Z86Plausibelwgkontrollablesung;
                case "Z87_PLAUSIBELWGKUNDENHINWEIS":
                    return Messwertstatuszusatz.Z87Plausibelwgkundenhinweis;
                case "Z88_VERGLEICHSMESSUNG(GEEICHT)":
                    return Messwertstatuszusatz.Z88VergleichsmessungGeeicht;
                case "Z89_VERGLEICHSMESSUNG(NICHTGEEICHT)":
                    return Messwertstatuszusatz.Z89VergleichsmessungNichtgeeicht;
                case "Z90_MESSWERTNACHBILDUNGAUSGEEICHTENWERTEN":
                    return Messwertstatuszusatz.Z90Messwertnachbildungausgeeichtenwerten;
                case "Z91_MESSWERTNACHBILDUNGAUSNICHTGEEICHTENWERTEN":
                    return Messwertstatuszusatz.Z91Messwertnachbildungausnichtgeeichtenwerten;
                case "Z92_INTERPOLATION":
                    return Messwertstatuszusatz.Z92Interpolation;
                case "Z93_HALTEWERT":
                    return Messwertstatuszusatz.Z93Haltewert;
                case "Z94_BILANZIERUNGNETZABSCHNITT":
                    return Messwertstatuszusatz.Z94Bilanzierungnetzabschnitt;
                case "Z95_HISTORISCHEMESSWERTE":
                    return Messwertstatuszusatz.Z95Historischemesswerte;
                case "Z98_BERUECKSICHTIGUNGSTOERMENGENZAEHLWERK":
                    return Messwertstatuszusatz.Z98Beruecksichtigungstoermengenzaehlwerk;
                case "Z99_MENGENUMWERTUNGUNVOLLSTAENDIG":
                    return Messwertstatuszusatz.Z99Mengenumwertungunvollstaendig;
                case "ZA0_UHRZEITGESTELLT_SYNCHRONISATION":
                    return Messwertstatuszusatz.Za0UhrzeitgestelltSynchronisation;
                case "ZA1_MESSWERTUNPLAUSIBEL":
                    return Messwertstatuszusatz.Za1Messwertunplausibel;
                case "ZA3_FALSCHERWANDLERFAKTOR":
                    return Messwertstatuszusatz.Za3Falscherwandlerfaktor;
                case "ZA4_FEHLERHAFTEABLESUNG":
                    return Messwertstatuszusatz.Za4Fehlerhafteablesung;
                case "ZA5_AENDERUNGDERBERECHNUNG":
                    return Messwertstatuszusatz.Za5Aenderungderberechnung;
                case "ZA6_UMBAUDERMESSLOKATION":
                    return Messwertstatuszusatz.Za6Umbaudermesslokation;
                case "ZA7_DATENBEARBEITUNGSFEHLER":
                    return Messwertstatuszusatz.Za7Datenbearbeitungsfehler;
                case "ZA8_BRENNWERTKORREKTUR":
                    return Messwertstatuszusatz.Za8Brennwertkorrektur;
                case "ZA9_Z-ZAHL-KORREKTUR":
                    return Messwertstatuszusatz.Za9ZZahlKorrektur;
                case "ZB0_STOERUNG_DEFEKTMESSEINRICHTUNG":
                    return Messwertstatuszusatz.Zb0StoerungDefektmesseinrichtung;
                case "ZB9_AENDERUNGTARIFSCHALTZEITEN":
                    return Messwertstatuszusatz.Zb9Aenderungtarifschaltzeiten;
                case "ZC2_TARIFSCHALTGERAETDEFEKT":
                    return Messwertstatuszusatz.Zc2Tarifschaltgeraetdefekt;
                case "ZC3_AUSTAUSCHDESERSATZWERTES":
                    return Messwertstatuszusatz.Zc3Austauschdesersatzwertes;
                case "ZC4_IMPULSWERTIGKEITNICHTAUSREICHEND":
                    return Messwertstatuszusatz.Zc4Impulswertigkeitnichtausreichend;
                case "ZG3_UMSTELLUNGGASQUALITAET":
                    return Messwertstatuszusatz.Zg3Umstellunggasqualitaet;
                case "ZJ2_STATISTISCHEMETHODE":
                    return Messwertstatuszusatz.Zj2Statistischemethode;
            }
            throw new Exception("Cannot unmarshal type Messwertstatuszusatz");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Messwertstatuszusatz)untypedValue;
            switch (value)
            {
                case Messwertstatuszusatz.Z74Keinzugang:
                    serializer.Serialize(writer, "Z74_KEINZUGANG");
                    return;
                case Messwertstatuszusatz.Z75Kommunikationsstoerung:
                    serializer.Serialize(writer, "Z75_KOMMUNIKATIONSSTOERUNG");
                    return;
                case Messwertstatuszusatz.Z76Netzausfall:
                    serializer.Serialize(writer, "Z76_NETZAUSFALL");
                    return;
                case Messwertstatuszusatz.Z77Spannungsausfall:
                    serializer.Serialize(writer, "Z77_SPANNUNGSAUSFALL");
                    return;
                case Messwertstatuszusatz.Z78Geraetewechsel:
                    serializer.Serialize(writer, "Z78_GERAETEWECHSEL");
                    return;
                case Messwertstatuszusatz.Z79Kalibrierung:
                    serializer.Serialize(writer, "Z79_KALIBRIERUNG");
                    return;
                case Messwertstatuszusatz.Z80Geraetarbeitetausserhalbderbetriebsbedingungen:
                    serializer.Serialize(writer, "Z80_GERAETARBEITETAUSSERHALBDERBETRIEBSBEDINGUNGEN");
                    return;
                case Messwertstatuszusatz.Z81MesseinrichtunggestoertDefekt:
                    serializer.Serialize(writer, "Z81_MESSEINRICHTUNGGESTOERT_DEFEKT");
                    return;
                case Messwertstatuszusatz.Z82Unsicherheitmessung:
                    serializer.Serialize(writer, "Z82_UNSICHERHEITMESSUNG");
                    return;
                case Messwertstatuszusatz.Z84Leerstand:
                    serializer.Serialize(writer, "Z84_LEERSTAND");
                    return;
                case Messwertstatuszusatz.Z85Realerzaehlerueberlaufgeprueft:
                    serializer.Serialize(writer, "Z85_REALERZAEHLERUEBERLAUFGEPRUEFT");
                    return;
                case Messwertstatuszusatz.Z86Plausibelwgkontrollablesung:
                    serializer.Serialize(writer, "Z86_PLAUSIBELWGKONTROLLABLESUNG");
                    return;
                case Messwertstatuszusatz.Z87Plausibelwgkundenhinweis:
                    serializer.Serialize(writer, "Z87_PLAUSIBELWGKUNDENHINWEIS");
                    return;
                case Messwertstatuszusatz.Z88VergleichsmessungGeeicht:
                    serializer.Serialize(writer, "Z88_VERGLEICHSMESSUNG(GEEICHT)");
                    return;
                case Messwertstatuszusatz.Z89VergleichsmessungNichtgeeicht:
                    serializer.Serialize(writer, "Z89_VERGLEICHSMESSUNG(NICHTGEEICHT)");
                    return;
                case Messwertstatuszusatz.Z90Messwertnachbildungausgeeichtenwerten:
                    serializer.Serialize(writer, "Z90_MESSWERTNACHBILDUNGAUSGEEICHTENWERTEN");
                    return;
                case Messwertstatuszusatz.Z91Messwertnachbildungausnichtgeeichtenwerten:
                    serializer.Serialize(writer, "Z91_MESSWERTNACHBILDUNGAUSNICHTGEEICHTENWERTEN");
                    return;
                case Messwertstatuszusatz.Z92Interpolation:
                    serializer.Serialize(writer, "Z92_INTERPOLATION");
                    return;
                case Messwertstatuszusatz.Z93Haltewert:
                    serializer.Serialize(writer, "Z93_HALTEWERT");
                    return;
                case Messwertstatuszusatz.Z94Bilanzierungnetzabschnitt:
                    serializer.Serialize(writer, "Z94_BILANZIERUNGNETZABSCHNITT");
                    return;
                case Messwertstatuszusatz.Z95Historischemesswerte:
                    serializer.Serialize(writer, "Z95_HISTORISCHEMESSWERTE");
                    return;
                case Messwertstatuszusatz.Z98Beruecksichtigungstoermengenzaehlwerk:
                    serializer.Serialize(writer, "Z98_BERUECKSICHTIGUNGSTOERMENGENZAEHLWERK");
                    return;
                case Messwertstatuszusatz.Z99Mengenumwertungunvollstaendig:
                    serializer.Serialize(writer, "Z99_MENGENUMWERTUNGUNVOLLSTAENDIG");
                    return;
                case Messwertstatuszusatz.Za0UhrzeitgestelltSynchronisation:
                    serializer.Serialize(writer, "ZA0_UHRZEITGESTELLT_SYNCHRONISATION");
                    return;
                case Messwertstatuszusatz.Za1Messwertunplausibel:
                    serializer.Serialize(writer, "ZA1_MESSWERTUNPLAUSIBEL");
                    return;
                case Messwertstatuszusatz.Za3Falscherwandlerfaktor:
                    serializer.Serialize(writer, "ZA3_FALSCHERWANDLERFAKTOR");
                    return;
                case Messwertstatuszusatz.Za4Fehlerhafteablesung:
                    serializer.Serialize(writer, "ZA4_FEHLERHAFTEABLESUNG");
                    return;
                case Messwertstatuszusatz.Za5Aenderungderberechnung:
                    serializer.Serialize(writer, "ZA5_AENDERUNGDERBERECHNUNG");
                    return;
                case Messwertstatuszusatz.Za6Umbaudermesslokation:
                    serializer.Serialize(writer, "ZA6_UMBAUDERMESSLOKATION");
                    return;
                case Messwertstatuszusatz.Za7Datenbearbeitungsfehler:
                    serializer.Serialize(writer, "ZA7_DATENBEARBEITUNGSFEHLER");
                    return;
                case Messwertstatuszusatz.Za8Brennwertkorrektur:
                    serializer.Serialize(writer, "ZA8_BRENNWERTKORREKTUR");
                    return;
                case Messwertstatuszusatz.Za9ZZahlKorrektur:
                    serializer.Serialize(writer, "ZA9_Z-ZAHL-KORREKTUR");
                    return;
                case Messwertstatuszusatz.Zb0StoerungDefektmesseinrichtung:
                    serializer.Serialize(writer, "ZB0_STOERUNG_DEFEKTMESSEINRICHTUNG");
                    return;
                case Messwertstatuszusatz.Zb9Aenderungtarifschaltzeiten:
                    serializer.Serialize(writer, "ZB9_AENDERUNGTARIFSCHALTZEITEN");
                    return;
                case Messwertstatuszusatz.Zc2Tarifschaltgeraetdefekt:
                    serializer.Serialize(writer, "ZC2_TARIFSCHALTGERAETDEFEKT");
                    return;
                case Messwertstatuszusatz.Zc3Austauschdesersatzwertes:
                    serializer.Serialize(writer, "ZC3_AUSTAUSCHDESERSATZWERTES");
                    return;
                case Messwertstatuszusatz.Zc4Impulswertigkeitnichtausreichend:
                    serializer.Serialize(writer, "ZC4_IMPULSWERTIGKEITNICHTAUSREICHEND");
                    return;
                case Messwertstatuszusatz.Zg3Umstellunggasqualitaet:
                    serializer.Serialize(writer, "ZG3_UMSTELLUNGGASQUALITAET");
                    return;
                case Messwertstatuszusatz.Zj2Statistischemethode:
                    serializer.Serialize(writer, "ZJ2_STATISTISCHEMETHODE");
                    return;
            }
            throw new Exception("Cannot marshal type Messwertstatuszusatz");
        }

        public static readonly MesswertstatuszusatzConverter Singleton = new MesswertstatuszusatzConverter();
    }

    internal class WertermittlungsverfahrenConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Wertermittlungsverfahren) || t == typeof(Wertermittlungsverfahren?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "MESSUNG":
                    return Wertermittlungsverfahren.Messung;
                case "PROGNOSE":
                    return Wertermittlungsverfahren.Prognose;
            }
            throw new Exception("Cannot unmarshal type Wertermittlungsverfahren");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Wertermittlungsverfahren)untypedValue;
            switch (value)
            {
                case Wertermittlungsverfahren.Messung:
                    serializer.Serialize(writer, "MESSUNG");
                    return;
                case Wertermittlungsverfahren.Prognose:
                    serializer.Serialize(writer, "PROGNOSE");
                    return;
            }
            throw new Exception("Cannot marshal type Wertermittlungsverfahren");
        }

        public static readonly WertermittlungsverfahrenConverter Singleton = new WertermittlungsverfahrenConverter();
    }
}
