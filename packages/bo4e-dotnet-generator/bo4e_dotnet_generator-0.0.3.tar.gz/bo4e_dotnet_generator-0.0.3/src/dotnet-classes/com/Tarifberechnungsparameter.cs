// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using BO4EDotNet;
//
//    var tarifberechnungsparameter = Tarifberechnungsparameter.FromJson(jsonString);

namespace BO4EDotNet
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    /// <summary>
    /// In dieser Komponente sind die Berechnungsparameter für die Ermittlung der Tarifkosten
    /// zusammengefasst.
    /// .. raw:: html
    ///
    /// <object data="../_static/images/bo4e/com/Tarifberechnungsparameter.svg"
    /// type="image/svg+xml"></object>
    ///
    /// .. HINT::
    /// `Tarifberechnungsparameter JSON Schema
    /// <https://json-schema.app/view/%23?url=https://raw.githubusercontent.com/BO4E/BO4E-Schemas/v202401.2.1/src/bo4e_schemas/com/Tarifberechnungsparameter.json>`_
    /// </summary>
    public partial class Tarifberechnungsparameter
    {
        /// <summary>
        /// zusatz_attribute: Optional[list["ZusatzAttribut"]] = None
        ///
        /// # pylint: disable=duplicate-code
        /// model_config = ConfigDict(
        /// alias_generator=camelize,
        /// populate_by_name=True,
        /// extra="allow",
        /// # json_encoders is deprecated, but there is no easy-to-use alternative. The best way
        /// would be to create
        /// # an annotated version of Decimal, but you would have to use it everywhere in the
        /// pydantic models.
        /// # See this issue for more info: https://github.com/pydantic/pydantic/issues/6375
        /// json_encoders={Decimal: str},
        /// )
        /// </summary>
        [JsonProperty("_id")]
        public string Id { get; set; }

        /// <summary>
        /// Version der BO-Struktur aka "fachliche Versionierung"
        /// </summary>
        [JsonProperty("_version")]
        public string Version { get; set; }

        /// <summary>
        /// Gibt an, wie die Einzelpreise des Tarifes zu verarbeiten sind
        /// </summary>
        [JsonProperty("berechnungsmethode")]
        public Tarifkalkulationsmethode? Berechnungsmethode { get; set; }

        /// <summary>
        /// Höchstpreis für den Durchschnitts-Arbeitspreis HT
        /// </summary>
        [JsonProperty("hoechstpreisHT")]
        public Preis HoechstpreisHt { get; set; }

        /// <summary>
        /// Höchstpreis für den Durchschnitts-Arbeitspreis NT
        /// </summary>
        [JsonProperty("hoechstpreisNT")]
        public Preis HoechstpreisNt { get; set; }

        /// <summary>
        /// True, falls der Messpreis im Grundpreis (GP) enthalten ist
        /// </summary>
        [JsonProperty("istMesspreisInGrundpreisEnthalten")]
        public bool? IstMesspreisInGrundpreisEnthalten { get; set; }

        /// <summary>
        /// Typ des Messpreises
        /// </summary>
        [JsonProperty("istMesspreisZuBeruecksichtigen")]
        public bool? IstMesspreisZuBeruecksichtigen { get; set; }

        /// <summary>
        /// Im Preis bereits eingeschlossene Leistung (für Gas)
        /// </summary>
        [JsonProperty("kwInklusive")]
        public double? KwInklusive { get; set; }

        /// <summary>
        /// Intervall, indem die über "kwInklusive" hinaus abgenommene Leistung kostenpflichtig wird
        /// (z.B. je 5 kW 20 EURO)
        /// </summary>
        [JsonProperty("kwWeitereMengen")]
        public double? KwWeitereMengen { get; set; }

        /// <summary>
        /// Typ des Messpreises
        /// </summary>
        [JsonProperty("messpreistyp")]
        public Messpreistyp? Messpreistyp { get; set; }

        /// <summary>
        /// Mindestpreis für den Durchschnitts-Arbeitspreis
        /// </summary>
        [JsonProperty("mindestpreis")]
        public Preis Mindestpreis { get; set; }

        [JsonProperty("zusatzAttribute")]
        public ZusatzAttribut[] ZusatzAttribute { get; set; }

        /// <summary>
        /// Liste mit zusätzlichen Preisen, beispielsweise Messpreise und/oder Leistungspreise
        /// </summary>
        [JsonProperty("zusatzpreise")]
        public Tarifpreis[] Zusatzpreise { get; set; }
    }


    /// <summary>
    /// Viele Datenobjekte weisen in unterschiedlichen Systemen eine eindeutige ID (Kundennummer,
    /// GP-Nummer etc.) auf.
    /// Beim Austausch von Datenobjekten zwischen verschiedenen Systemen ist es daher hilfreich,
    /// sich die eindeutigen IDs der anzubindenden Systeme zu merken.
    ///
    /// .. raw:: html
    ///
    /// <object data="../_static/images/bo4e/com/ZusatzAttribut.svg"
    /// type="image/svg+xml"></object>
    ///
    /// .. HINT::
    /// `ZusatzAttribut JSON Schema
    /// <https://json-schema.app/view/%23?url=https://raw.githubusercontent.com/BO4E/BO4E-Schemas/v202401.2.1/src/bo4e_schemas/ZusatzAttribut.json>`_
    /// </summary>
    public partial class ZusatzAttribut
    {
        /// <summary>
        /// Bezeichnung der externen Referenz (z.B. "microservice xyz" oder "SAP CRM GP-Nummer")
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }

        /// <summary>
        /// Bezeichnung der externen Referenz (z.B. "microservice xyz" oder "SAP CRM GP-Nummer")
        /// </summary>
        [JsonProperty("wert")]
        public object Wert { get; set; }
    }


    /// <summary>
    /// Auflistung der verschiedenen Berechnungsmethoden für ein Preisblatt.
    /// </summary>
    public enum Tarifkalkulationsmethode { BestabrechnungStaffel, Keine, Paketpreis, Staffeln, Zonen };

    /// <summary>
    /// Einheit: Messgrößen, die per Messung oder Vorgabe ermittelt werden können.
    /// </summary>
    public enum Mengeneinheit { Halbjahr, Jahr, Kubikmeter, Kvar, Kvarh, Kw, Kwh, Kwhk, Minute, Monat, Mw, Mwh, Prozent, Quartal, Sekunde, Stueck, Stunde, Tag, Var, Varh, ViertelStunde, W, Wh, Woche };

    /// <summary>
    /// In diesem Enum werden die Währungen und ihre Untereinheiten definiert, beispielsweise für
    /// die Verwendung in Preisen.
    /// </summary>
    public enum Waehrungseinheit { Ct, Eur };

    /// <summary>
    /// Statusinformation für Preise
    /// </summary>
    public enum Preisstatus { Endgueltig, Vorlaeufig };

    /// <summary>
    /// Festlegung, welcher Typ von Messung mit einem Preis belegt wird
    /// </summary>
    public enum Messpreistyp { AufschlagTarifschaltung, AufschlagWandler, ElektronischerAufsatz, MesspreisG10, MesspreisG16, MesspreisG25, MesspreisG4, MesspreisG40, MesspreisG6, MesspreistypMesspreisG25, MesspreistypSmartMeterMesspreisG25, SmartMeterMesspreisG10, SmartMeterMesspreisG16, SmartMeterMesspreisG25, SmartMeterMesspreisG4, SmartMeterMesspreisG40, SmartMeterMesspreisG6, VerrechnungspreisEtDreh, VerrechnungspreisEtWechsel, VerrechnungspreisLEt, VerrechnungspreisLZt, VerrechnungspreisSm, VerrechnungspreisZtDreh, VerrechnungspreisZtWechsel };

    /// <summary>
    /// Aufschlüsselung der Preistypen in Tarifen.
    /// </summary>
    public enum Preistyp { ArbeitspreisEintarif, ArbeitspreisHt, ArbeitspreisNt, EntgeltAblesung, EntgeltAbrechnung, EntgeltMsb, Grundpreis, Leistungspreis, Messpreis, Provision };

    public partial class Tarifberechnungsparameter
    {
        public static Tarifberechnungsparameter FromJson(string json) => JsonConvert.DeserializeObject<Tarifberechnungsparameter>(json, BO4EDotNet.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Tarifberechnungsparameter self) => JsonConvert.SerializeObject(self, BO4EDotNet.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                TarifkalkulationsmethodeConverter.Singleton,
                MengeneinheitConverter.Singleton,
                WaehrungseinheitConverter.Singleton,
                PreisstatusConverter.Singleton,
                MesspreistypConverter.Singleton,
                PreistypConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class TarifkalkulationsmethodeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Tarifkalkulationsmethode) || t == typeof(Tarifkalkulationsmethode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "BESTABRECHNUNG_STAFFEL":
                    return Tarifkalkulationsmethode.BestabrechnungStaffel;
                case "KEINE":
                    return Tarifkalkulationsmethode.Keine;
                case "PAKETPREIS":
                    return Tarifkalkulationsmethode.Paketpreis;
                case "STAFFELN":
                    return Tarifkalkulationsmethode.Staffeln;
                case "ZONEN":
                    return Tarifkalkulationsmethode.Zonen;
            }
            throw new Exception("Cannot unmarshal type Tarifkalkulationsmethode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Tarifkalkulationsmethode)untypedValue;
            switch (value)
            {
                case Tarifkalkulationsmethode.BestabrechnungStaffel:
                    serializer.Serialize(writer, "BESTABRECHNUNG_STAFFEL");
                    return;
                case Tarifkalkulationsmethode.Keine:
                    serializer.Serialize(writer, "KEINE");
                    return;
                case Tarifkalkulationsmethode.Paketpreis:
                    serializer.Serialize(writer, "PAKETPREIS");
                    return;
                case Tarifkalkulationsmethode.Staffeln:
                    serializer.Serialize(writer, "STAFFELN");
                    return;
                case Tarifkalkulationsmethode.Zonen:
                    serializer.Serialize(writer, "ZONEN");
                    return;
            }
            throw new Exception("Cannot marshal type Tarifkalkulationsmethode");
        }

        public static readonly TarifkalkulationsmethodeConverter Singleton = new TarifkalkulationsmethodeConverter();
    }

    internal class MengeneinheitConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Mengeneinheit) || t == typeof(Mengeneinheit?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "HALBJAHR":
                    return Mengeneinheit.Halbjahr;
                case "JAHR":
                    return Mengeneinheit.Jahr;
                case "KUBIKMETER":
                    return Mengeneinheit.Kubikmeter;
                case "KVAR":
                    return Mengeneinheit.Kvar;
                case "KVARH":
                    return Mengeneinheit.Kvarh;
                case "KW":
                    return Mengeneinheit.Kw;
                case "KWH":
                    return Mengeneinheit.Kwh;
                case "KWHK":
                    return Mengeneinheit.Kwhk;
                case "MINUTE":
                    return Mengeneinheit.Minute;
                case "MONAT":
                    return Mengeneinheit.Monat;
                case "MW":
                    return Mengeneinheit.Mw;
                case "MWH":
                    return Mengeneinheit.Mwh;
                case "PROZENT":
                    return Mengeneinheit.Prozent;
                case "QUARTAL":
                    return Mengeneinheit.Quartal;
                case "SEKUNDE":
                    return Mengeneinheit.Sekunde;
                case "STUECK":
                    return Mengeneinheit.Stueck;
                case "STUNDE":
                    return Mengeneinheit.Stunde;
                case "TAG":
                    return Mengeneinheit.Tag;
                case "VAR":
                    return Mengeneinheit.Var;
                case "VARH":
                    return Mengeneinheit.Varh;
                case "VIERTEL_STUNDE":
                    return Mengeneinheit.ViertelStunde;
                case "W":
                    return Mengeneinheit.W;
                case "WH":
                    return Mengeneinheit.Wh;
                case "WOCHE":
                    return Mengeneinheit.Woche;
            }
            throw new Exception("Cannot unmarshal type Mengeneinheit");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Mengeneinheit)untypedValue;
            switch (value)
            {
                case Mengeneinheit.Halbjahr:
                    serializer.Serialize(writer, "HALBJAHR");
                    return;
                case Mengeneinheit.Jahr:
                    serializer.Serialize(writer, "JAHR");
                    return;
                case Mengeneinheit.Kubikmeter:
                    serializer.Serialize(writer, "KUBIKMETER");
                    return;
                case Mengeneinheit.Kvar:
                    serializer.Serialize(writer, "KVAR");
                    return;
                case Mengeneinheit.Kvarh:
                    serializer.Serialize(writer, "KVARH");
                    return;
                case Mengeneinheit.Kw:
                    serializer.Serialize(writer, "KW");
                    return;
                case Mengeneinheit.Kwh:
                    serializer.Serialize(writer, "KWH");
                    return;
                case Mengeneinheit.Kwhk:
                    serializer.Serialize(writer, "KWHK");
                    return;
                case Mengeneinheit.Minute:
                    serializer.Serialize(writer, "MINUTE");
                    return;
                case Mengeneinheit.Monat:
                    serializer.Serialize(writer, "MONAT");
                    return;
                case Mengeneinheit.Mw:
                    serializer.Serialize(writer, "MW");
                    return;
                case Mengeneinheit.Mwh:
                    serializer.Serialize(writer, "MWH");
                    return;
                case Mengeneinheit.Prozent:
                    serializer.Serialize(writer, "PROZENT");
                    return;
                case Mengeneinheit.Quartal:
                    serializer.Serialize(writer, "QUARTAL");
                    return;
                case Mengeneinheit.Sekunde:
                    serializer.Serialize(writer, "SEKUNDE");
                    return;
                case Mengeneinheit.Stueck:
                    serializer.Serialize(writer, "STUECK");
                    return;
                case Mengeneinheit.Stunde:
                    serializer.Serialize(writer, "STUNDE");
                    return;
                case Mengeneinheit.Tag:
                    serializer.Serialize(writer, "TAG");
                    return;
                case Mengeneinheit.Var:
                    serializer.Serialize(writer, "VAR");
                    return;
                case Mengeneinheit.Varh:
                    serializer.Serialize(writer, "VARH");
                    return;
                case Mengeneinheit.ViertelStunde:
                    serializer.Serialize(writer, "VIERTEL_STUNDE");
                    return;
                case Mengeneinheit.W:
                    serializer.Serialize(writer, "W");
                    return;
                case Mengeneinheit.Wh:
                    serializer.Serialize(writer, "WH");
                    return;
                case Mengeneinheit.Woche:
                    serializer.Serialize(writer, "WOCHE");
                    return;
            }
            throw new Exception("Cannot marshal type Mengeneinheit");
        }

        public static readonly MengeneinheitConverter Singleton = new MengeneinheitConverter();
    }

    internal class WaehrungseinheitConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Waehrungseinheit) || t == typeof(Waehrungseinheit?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CT":
                    return Waehrungseinheit.Ct;
                case "EUR":
                    return Waehrungseinheit.Eur;
            }
            throw new Exception("Cannot unmarshal type Waehrungseinheit");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Waehrungseinheit)untypedValue;
            switch (value)
            {
                case Waehrungseinheit.Ct:
                    serializer.Serialize(writer, "CT");
                    return;
                case Waehrungseinheit.Eur:
                    serializer.Serialize(writer, "EUR");
                    return;
            }
            throw new Exception("Cannot marshal type Waehrungseinheit");
        }

        public static readonly WaehrungseinheitConverter Singleton = new WaehrungseinheitConverter();
    }

    internal class PreisstatusConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Preisstatus) || t == typeof(Preisstatus?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ENDGUELTIG":
                    return Preisstatus.Endgueltig;
                case "VORLAEUFIG":
                    return Preisstatus.Vorlaeufig;
            }
            throw new Exception("Cannot unmarshal type Preisstatus");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Preisstatus)untypedValue;
            switch (value)
            {
                case Preisstatus.Endgueltig:
                    serializer.Serialize(writer, "ENDGUELTIG");
                    return;
                case Preisstatus.Vorlaeufig:
                    serializer.Serialize(writer, "VORLAEUFIG");
                    return;
            }
            throw new Exception("Cannot marshal type Preisstatus");
        }

        public static readonly PreisstatusConverter Singleton = new PreisstatusConverter();
    }

    internal class MesspreistypConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Messpreistyp) || t == typeof(Messpreistyp?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "AUFSCHLAG_TARIFSCHALTUNG":
                    return Messpreistyp.AufschlagTarifschaltung;
                case "AUFSCHLAG_WANDLER":
                    return Messpreistyp.AufschlagWandler;
                case "ELEKTRONISCHER_AUFSATZ":
                    return Messpreistyp.ElektronischerAufsatz;
                case "MESSPREIS_G10":
                    return Messpreistyp.MesspreisG10;
                case "MESSPREIS_G16":
                    return Messpreistyp.MesspreisG16;
                case "MESSPREIS_G25":
                    return Messpreistyp.MesspreistypMesspreisG25;
                case "MESSPREIS_G2_5":
                    return Messpreistyp.MesspreisG25;
                case "MESSPREIS_G4":
                    return Messpreistyp.MesspreisG4;
                case "MESSPREIS_G40":
                    return Messpreistyp.MesspreisG40;
                case "MESSPREIS_G6":
                    return Messpreistyp.MesspreisG6;
                case "SMART_METER_MESSPREIS_G10":
                    return Messpreistyp.SmartMeterMesspreisG10;
                case "SMART_METER_MESSPREIS_G16":
                    return Messpreistyp.SmartMeterMesspreisG16;
                case "SMART_METER_MESSPREIS_G25":
                    return Messpreistyp.MesspreistypSmartMeterMesspreisG25;
                case "SMART_METER_MESSPREIS_G2_5":
                    return Messpreistyp.SmartMeterMesspreisG25;
                case "SMART_METER_MESSPREIS_G4":
                    return Messpreistyp.SmartMeterMesspreisG4;
                case "SMART_METER_MESSPREIS_G40":
                    return Messpreistyp.SmartMeterMesspreisG40;
                case "SMART_METER_MESSPREIS_G6":
                    return Messpreistyp.SmartMeterMesspreisG6;
                case "VERRECHNUNGSPREIS_ET_DREH":
                    return Messpreistyp.VerrechnungspreisEtDreh;
                case "VERRECHNUNGSPREIS_ET_WECHSEL":
                    return Messpreistyp.VerrechnungspreisEtWechsel;
                case "VERRECHNUNGSPREIS_L_ET":
                    return Messpreistyp.VerrechnungspreisLEt;
                case "VERRECHNUNGSPREIS_L_ZT":
                    return Messpreistyp.VerrechnungspreisLZt;
                case "VERRECHNUNGSPREIS_SM":
                    return Messpreistyp.VerrechnungspreisSm;
                case "VERRECHNUNGSPREIS_ZT_DREH":
                    return Messpreistyp.VerrechnungspreisZtDreh;
                case "VERRECHNUNGSPREIS_ZT_WECHSEL":
                    return Messpreistyp.VerrechnungspreisZtWechsel;
            }
            throw new Exception("Cannot unmarshal type Messpreistyp");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Messpreistyp)untypedValue;
            switch (value)
            {
                case Messpreistyp.AufschlagTarifschaltung:
                    serializer.Serialize(writer, "AUFSCHLAG_TARIFSCHALTUNG");
                    return;
                case Messpreistyp.AufschlagWandler:
                    serializer.Serialize(writer, "AUFSCHLAG_WANDLER");
                    return;
                case Messpreistyp.ElektronischerAufsatz:
                    serializer.Serialize(writer, "ELEKTRONISCHER_AUFSATZ");
                    return;
                case Messpreistyp.MesspreisG10:
                    serializer.Serialize(writer, "MESSPREIS_G10");
                    return;
                case Messpreistyp.MesspreisG16:
                    serializer.Serialize(writer, "MESSPREIS_G16");
                    return;
                case Messpreistyp.MesspreistypMesspreisG25:
                    serializer.Serialize(writer, "MESSPREIS_G25");
                    return;
                case Messpreistyp.MesspreisG25:
                    serializer.Serialize(writer, "MESSPREIS_G2_5");
                    return;
                case Messpreistyp.MesspreisG4:
                    serializer.Serialize(writer, "MESSPREIS_G4");
                    return;
                case Messpreistyp.MesspreisG40:
                    serializer.Serialize(writer, "MESSPREIS_G40");
                    return;
                case Messpreistyp.MesspreisG6:
                    serializer.Serialize(writer, "MESSPREIS_G6");
                    return;
                case Messpreistyp.SmartMeterMesspreisG10:
                    serializer.Serialize(writer, "SMART_METER_MESSPREIS_G10");
                    return;
                case Messpreistyp.SmartMeterMesspreisG16:
                    serializer.Serialize(writer, "SMART_METER_MESSPREIS_G16");
                    return;
                case Messpreistyp.MesspreistypSmartMeterMesspreisG25:
                    serializer.Serialize(writer, "SMART_METER_MESSPREIS_G25");
                    return;
                case Messpreistyp.SmartMeterMesspreisG25:
                    serializer.Serialize(writer, "SMART_METER_MESSPREIS_G2_5");
                    return;
                case Messpreistyp.SmartMeterMesspreisG4:
                    serializer.Serialize(writer, "SMART_METER_MESSPREIS_G4");
                    return;
                case Messpreistyp.SmartMeterMesspreisG40:
                    serializer.Serialize(writer, "SMART_METER_MESSPREIS_G40");
                    return;
                case Messpreistyp.SmartMeterMesspreisG6:
                    serializer.Serialize(writer, "SMART_METER_MESSPREIS_G6");
                    return;
                case Messpreistyp.VerrechnungspreisEtDreh:
                    serializer.Serialize(writer, "VERRECHNUNGSPREIS_ET_DREH");
                    return;
                case Messpreistyp.VerrechnungspreisEtWechsel:
                    serializer.Serialize(writer, "VERRECHNUNGSPREIS_ET_WECHSEL");
                    return;
                case Messpreistyp.VerrechnungspreisLEt:
                    serializer.Serialize(writer, "VERRECHNUNGSPREIS_L_ET");
                    return;
                case Messpreistyp.VerrechnungspreisLZt:
                    serializer.Serialize(writer, "VERRECHNUNGSPREIS_L_ZT");
                    return;
                case Messpreistyp.VerrechnungspreisSm:
                    serializer.Serialize(writer, "VERRECHNUNGSPREIS_SM");
                    return;
                case Messpreistyp.VerrechnungspreisZtDreh:
                    serializer.Serialize(writer, "VERRECHNUNGSPREIS_ZT_DREH");
                    return;
                case Messpreistyp.VerrechnungspreisZtWechsel:
                    serializer.Serialize(writer, "VERRECHNUNGSPREIS_ZT_WECHSEL");
                    return;
            }
            throw new Exception("Cannot marshal type Messpreistyp");
        }

        public static readonly MesspreistypConverter Singleton = new MesspreistypConverter();
    }

    internal class PreistypConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Preistyp) || t == typeof(Preistyp?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ARBEITSPREIS_EINTARIF":
                    return Preistyp.ArbeitspreisEintarif;
                case "ARBEITSPREIS_HT":
                    return Preistyp.ArbeitspreisHt;
                case "ARBEITSPREIS_NT":
                    return Preistyp.ArbeitspreisNt;
                case "ENTGELT_ABLESUNG":
                    return Preistyp.EntgeltAblesung;
                case "ENTGELT_ABRECHNUNG":
                    return Preistyp.EntgeltAbrechnung;
                case "ENTGELT_MSB":
                    return Preistyp.EntgeltMsb;
                case "GRUNDPREIS":
                    return Preistyp.Grundpreis;
                case "LEISTUNGSPREIS":
                    return Preistyp.Leistungspreis;
                case "MESSPREIS":
                    return Preistyp.Messpreis;
                case "PROVISION":
                    return Preistyp.Provision;
            }
            throw new Exception("Cannot unmarshal type Preistyp");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Preistyp)untypedValue;
            switch (value)
            {
                case Preistyp.ArbeitspreisEintarif:
                    serializer.Serialize(writer, "ARBEITSPREIS_EINTARIF");
                    return;
                case Preistyp.ArbeitspreisHt:
                    serializer.Serialize(writer, "ARBEITSPREIS_HT");
                    return;
                case Preistyp.ArbeitspreisNt:
                    serializer.Serialize(writer, "ARBEITSPREIS_NT");
                    return;
                case Preistyp.EntgeltAblesung:
                    serializer.Serialize(writer, "ENTGELT_ABLESUNG");
                    return;
                case Preistyp.EntgeltAbrechnung:
                    serializer.Serialize(writer, "ENTGELT_ABRECHNUNG");
                    return;
                case Preistyp.EntgeltMsb:
                    serializer.Serialize(writer, "ENTGELT_MSB");
                    return;
                case Preistyp.Grundpreis:
                    serializer.Serialize(writer, "GRUNDPREIS");
                    return;
                case Preistyp.Leistungspreis:
                    serializer.Serialize(writer, "LEISTUNGSPREIS");
                    return;
                case Preistyp.Messpreis:
                    serializer.Serialize(writer, "MESSPREIS");
                    return;
                case Preistyp.Provision:
                    serializer.Serialize(writer, "PROVISION");
                    return;
            }
            throw new Exception("Cannot marshal type Preistyp");
        }

        public static readonly PreistypConverter Singleton = new PreistypConverter();
    }
}
