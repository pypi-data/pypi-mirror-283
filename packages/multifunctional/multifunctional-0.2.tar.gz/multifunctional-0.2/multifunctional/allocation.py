from copy import deepcopy
from functools import partial
from typing import Callable, List, Optional
from uuid import uuid4

from bw2data import get_node
from bw2data.errors import UnknownObject
from bw2io.utils import rescale_exchange
from loguru import logger

from .node_classes import (
    MaybeMultifunctionalProcess,
    ReadOnlyProcessWithReferenceProduct,
)


def generic_allocation(
    act: MaybeMultifunctionalProcess,
    func: Callable,
    strategy_label: Optional[str] = None,
) -> List[dict]:
    """Allocation by single allocation factor generated by `func`.

    Allocation amount is edge amount times function(edge_data, act) divided by sum of all edge
    amounts times function(edge_data, act).

    Skips functional edges with zero allocation values."""
    if isinstance(act, ReadOnlyProcessWithReferenceProduct):
        return []
    elif not act.has_multiple_functional_edges:
        return []

    total = 0
    for exc in act.functional_edges():
        total += func(exc._data, act)

    new_processes = []
    for exc in act.functional_edges():
        factor = func(exc._data, act) / total
        if not factor:
            continue

        logger.debug(
            "Using allocation factor {f} for functional edge {e} on activity {a}",
            f=factor,
            e=repr(exc),
            a=repr(act),
        )

        # Case 1: Edge points to nothing
        # Case 2: Edge points to an allocated readonly process
        # Case 3: Edge points to an existing product node

        change = False

        # Remove artificial code added by `add_exchange_input_if_missing`
        if exc.get("mf_artificial_code") and "code" in exc:
            del exc["code"]

        try:
            if "desired_code" in exc:
                process_code = exc["desired_code"]
            else:
                process_code = exc["mf_allocated_process_code"]
        except KeyError:
            process_code = exc["mf_allocated_process_code"] = uuid4().hex
            change = True
        try:
            exc["code"]
        except KeyError:
            exc["code"] = process_code
            change = True

        if change:
            exc.save()
            logger.debug(
                "Creating new product code {c} for functional edge {e} on activity {a}",
                c=process_code,
                e=repr(exc),
                a=repr(act),
            )

        try:
            assert not exc.get("mf_artificial_code")
            product = get_node(database=exc["input"][0], code=exc["input"][1])
        except (KeyError, UnknownObject, AssertionError):
            product = None

        allocated_process = deepcopy(act._data)
        if "id" in allocated_process:
            del allocated_process["id"]
        if strategy_label:
            allocated_process["mf_strategy_label"] = strategy_label
        allocated_process["code"] = process_code
        allocated_process["multifunctional_parent_id"] = act.id
        allocated_process["type"] = "readonly_process"

        if "name" in exc:
            allocated_process["reference product"] = exc["name"]
        elif product:
            allocated_process["reference product"] = product.get(
                "name", "(unnamed product)"
            )
        else:
            allocated_process["reference product"] = "(unnamed)"

        if "unit" in exc:
            allocated_process["unit"] = exc["unit"]
        elif product:
            allocated_process["unit"] = product.get("unit")

        new_functional_exchange = deepcopy(exc._data)

        # Change input from artificial one added by `add_exchange_input_if_missing`
        # to the actual code needed
        if (
            new_functional_exchange.get("mf_artificial_code")
            and "input" in new_functional_exchange
        ):
            new_functional_exchange["input"] = (act["database"], process_code)

        allocated_process["exchanges"] = [new_functional_exchange]

        for other in act.nonfunctional_edges():
            allocated_process["exchanges"].append(
                rescale_exchange(deepcopy(other._data), factor)
            )

        new_processes.append(allocated_process)

    return new_processes


def get_allocation_factor_from_property(
    edge_data: dict, node: MaybeMultifunctionalProcess, property_label: str
) -> float:
    if "properties" not in edge_data:
        raise KeyError(
            f"Edge {edge_data} from process {node} (id {node.id}) doesn't have properties"
        )
    try:
        return edge_data["amount"] * edge_data["properties"][property_label]
    except KeyError as err:
        raise KeyError(
            f"Edge {edge_data} from process {node} (id {node.id}) missing property {property_label}"
        ) from err


def property_allocation(property_label: str) -> Callable:
    return partial(
        generic_allocation,
        func=partial(
            get_allocation_factor_from_property, property_label=property_label
        ),
        strategy_label=f"property allocation by '{property_label}'"
    )


allocation_strategies = {
    "price": property_allocation("price"),
    "manual": property_allocation("manual"),
    "mass": property_allocation("mass"),
    "equal": partial(generic_allocation, func=lambda x, y: 1.0),
}
