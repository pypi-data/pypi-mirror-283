"""
Python bindings for the Mimir planning library.
"""
from __future__ import annotations
import pybind11_stubgen.typing_ext
import typing
__all__ = ['ACTION_COSTS', 'ADL', 'ASSIGN', 'AStarAlgorithm', 'AbstractTransition', 'Abstraction', 'Action', 'AssignOperatorEnum', 'Axiom', 'BinaryOperatorEnum', 'BlindHeuristic', 'BrFSAlgorithm', 'CLOSED', 'CONDITIONAL_EFFECTS', 'CONSTRAINTS', 'Certificate', 'ConditionalEffect', 'DEAD_END', 'DECREASE', 'DERIVED_PREDICATES', 'DISJUNCTIVE_PRECONDITIONS', 'DIV', 'DURATIVE_ACTIONS', 'DebugBrFSAlgorithmEventHandler', 'DebugGroundedAAGEventHandler', 'DebugLiftedAAGEventHandler', 'DefaultBrFSAlgorithmEventHandler', 'DefaultGroundedAAGEventHandler', 'DefaultIWAlgorithmEventHandler', 'DefaultLiftedAAGEventHandler', 'DefaultSIWAlgorithmEventHandler', 'DenseNautyGraph', 'DenseNautyGraphFactory', 'DerivedAtom', 'DerivedGroundAtom', 'DerivedGroundLiteral', 'DerivedLiteral', 'DerivedPredicate', 'Digraph', 'DigraphEdge', 'Domain', 'EQUALITY', 'EXHAUSTED', 'EXISTENTIAL_PRECONDITIONS', 'FAILED', 'FLUENTS', 'FaithfulAbstractState', 'FaithfulAbstraction', 'FluentAndDerivedMapper', 'FluentAtom', 'FluentGroundAtom', 'FluentGroundLiteral', 'FluentLiteral', 'FluentPredicate', 'Function', 'FunctionExpression', 'FunctionExpressionBinaryOperator', 'FunctionExpressionFunction', 'FunctionExpressionMinus', 'FunctionExpressionMultiOperator', 'FunctionExpressionNumber', 'FunctionSkeleton', 'GlobalFaithfulAbstractState', 'GlobalFaithfulAbstraction', 'GroundAction', 'GroundFunction', 'GroundFunctionExpression', 'GroundFunctionExpressionBinaryOperator', 'GroundFunctionExpressionFunction', 'GroundFunctionExpressionMinus', 'GroundFunctionExpressionMultiOperator', 'GroundFunctionExpressionNumber', 'GroundedAAG', 'IAAG', 'IAlgorithm', 'IBrFSAlgorithmEventHandler', 'IGroundedAAGEventHandler', 'IHeuristic', 'IIWAlgorithmEventHandler', 'ILiftedAAGEventHandler', 'INCREASE', 'IN_PROGRESS', 'ISIWAlgorithmEventHandler', 'IWAlgorithm', 'LiftedAAG', 'MAXIMIZE', 'MINIMIZE', 'MINUS', 'MUL', 'MultiOperatorEnum', 'NEGATIVE_PRECONDITIONS', 'NEW', 'NUMERIC_FLUENTS', 'NumericFluent', 'OBJECT_FLUENTS', 'OPEN', 'OUT_OF_MEMORY', 'OUT_OF_TIME', 'Object', 'ObjectGraph', 'ObjectGraphFactory', 'OptimizationMetric', 'OptimizationMetricEnum', 'PDDLFactories', 'PDDLParser', 'PLUS', 'PREFERENCES', 'Partitioning', 'Problem', 'ProblemColorFunction', 'QUANTIFIED_PRECONDITIONS', 'RequirementEnum', 'Requirements', 'SCALE_DOWN', 'SCALE_UP', 'SIWAlgorithm', 'SOLVED', 'STRIPS', 'SearchNodeStatus', 'SearchStatus', 'SimpleEffect', 'SparseNautyGraph', 'SparseNautyGraphFactory', 'State', 'StateSpace', 'StaticAtom', 'StaticGroundAtom', 'StaticGroundLiteral', 'StaticLiteral', 'StaticPredicate', 'SuccessorStateGenerator', 'TIMED_INITIAL_LITERALS', 'TYPING', 'Term', 'TermObject', 'TermVariable', 'Transition', 'TupleGraph', 'TupleGraphFactory', 'TupleGraphVertex', 'TupleIndexMapper', 'UNIVERSAL_PRECONDITIONS', 'UniversalEffect', 'Variable']
class AStarAlgorithm(IAlgorithm):
    @typing.overload
    def __init__(self, arg0: IAAG, arg1: IHeuristic) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: IAAG, arg1: SuccessorStateGenerator, arg2: IHeuristic) -> None:
        ...
class AbstractTransition:
    def __eq__(self, arg0: AbstractTransition) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def get_actions(self) -> list[GroundAction]:
        ...
    def get_cost(self) -> float:
        ...
    def get_index(self) -> int:
        ...
    def get_representative_action(self) -> GroundAction:
        ...
    def get_source_state(self) -> int:
        ...
    def get_target_state(self) -> int:
        ...
class Abstraction:
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    def get_aag(self) -> IAAG:
        ...
    def get_abstract_state_index(self, arg0: State) -> int:
        ...
    def get_backward_transition_indices(self: StateSpace, arg0: int) -> typing.Iterator:
        ...
    def get_backward_transitions(self: StateSpace, arg0: int) -> typing.Iterator:
        ...
    def get_deadend_states(self) -> set[int]:
        ...
    def get_forward_transition_indices(self: StateSpace, arg0: int) -> typing.Iterator:
        ...
    def get_forward_transitions(self: StateSpace, arg0: int) -> typing.Iterator:
        ...
    def get_goal_distances(self) -> list[float]:
        ...
    def get_goal_states(self) -> set[int]:
        ...
    def get_initial_state(self) -> int:
        ...
    def get_num_deadend_states(self) -> int:
        ...
    def get_num_goal_states(self) -> int:
        ...
    def get_num_states(self) -> int:
        ...
    def get_num_transitions(self) -> int:
        ...
    def get_pddl_parser(self) -> PDDLParser:
        ...
    def get_source_states(self, arg0: int) -> typing.Iterator:
        ...
    def get_ssg(self) -> SuccessorStateGenerator:
        ...
    def get_target_states(self, arg0: int) -> typing.Iterator:
        ...
    def get_transition_cost(self, arg0: int) -> float:
        ...
    def is_alive_state(self, arg0: int) -> bool:
        ...
    def is_deadend_state(self, arg0: int) -> bool:
        ...
    def is_goal_state(self, arg0: int) -> bool:
        ...
class Action:
    def __str__(self) -> str:
        ...
    def get_arity(self) -> int:
        ...
    def get_conditional_effects(self) -> list[ConditionalEffect]:
        ...
    def get_derived_conditions(self) -> list[DerivedLiteral]:
        ...
    def get_fluent_conditions(self) -> list[FluentLiteral]:
        ...
    def get_identifier(self) -> int:
        ...
    def get_name(self) -> str:
        ...
    def get_parameters(self) -> list[Variable]:
        ...
    def get_simple_effects(self) -> list[SimpleEffect]:
        ...
    def get_static_conditions(self) -> list[StaticLiteral]:
        ...
    def get_universal_effects(self) -> list[UniversalEffect]:
        ...
class AssignOperatorEnum:
    """
    Members:
    
      ASSIGN
    
      SCALE_UP
    
      SCALE_DOWN
    
      INCREASE
    
      DECREASE
    """
    ASSIGN: typing.ClassVar[AssignOperatorEnum]  # value = <AssignOperatorEnum.ASSIGN: 0>
    DECREASE: typing.ClassVar[AssignOperatorEnum]  # value = <AssignOperatorEnum.DECREASE: 4>
    INCREASE: typing.ClassVar[AssignOperatorEnum]  # value = <AssignOperatorEnum.INCREASE: 3>
    SCALE_DOWN: typing.ClassVar[AssignOperatorEnum]  # value = <AssignOperatorEnum.SCALE_DOWN: 2>
    SCALE_UP: typing.ClassVar[AssignOperatorEnum]  # value = <AssignOperatorEnum.SCALE_UP: 1>
    __members__: typing.ClassVar[dict[str, AssignOperatorEnum]]  # value = {'ASSIGN': <AssignOperatorEnum.ASSIGN: 0>, 'SCALE_UP': <AssignOperatorEnum.SCALE_UP: 1>, 'SCALE_DOWN': <AssignOperatorEnum.SCALE_DOWN: 2>, 'INCREASE': <AssignOperatorEnum.INCREASE: 3>, 'DECREASE': <AssignOperatorEnum.DECREASE: 4>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Axiom:
    def __str__(self) -> str:
        ...
    def get_arity(self) -> int:
        ...
    def get_derived_conditions(self) -> list[DerivedLiteral]:
        ...
    def get_fluent_conditions(self) -> list[FluentLiteral]:
        ...
    def get_identifier(self) -> int:
        ...
    def get_literal(self) -> DerivedLiteral:
        ...
    def get_static_conditions(self) -> list[StaticLiteral]:
        ...
class BinaryOperatorEnum:
    """
    Members:
    
      MUL
    
      PLUS
    
      MINUS
    
      DIV
    """
    DIV: typing.ClassVar[BinaryOperatorEnum]  # value = <BinaryOperatorEnum.DIV: 3>
    MINUS: typing.ClassVar[BinaryOperatorEnum]  # value = <BinaryOperatorEnum.MINUS: 2>
    MUL: typing.ClassVar[BinaryOperatorEnum]  # value = <BinaryOperatorEnum.MUL: 0>
    PLUS: typing.ClassVar[BinaryOperatorEnum]  # value = <BinaryOperatorEnum.PLUS: 1>
    __members__: typing.ClassVar[dict[str, BinaryOperatorEnum]]  # value = {'MUL': <BinaryOperatorEnum.MUL: 0>, 'PLUS': <BinaryOperatorEnum.PLUS: 1>, 'MINUS': <BinaryOperatorEnum.MINUS: 2>, 'DIV': <BinaryOperatorEnum.DIV: 3>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class BlindHeuristic(IHeuristic):
    def __init__(self) -> None:
        ...
class BrFSAlgorithm(IAlgorithm):
    @typing.overload
    def __init__(self, arg0: IAAG) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: IAAG, arg1: SuccessorStateGenerator, arg2: IBrFSAlgorithmEventHandler) -> None:
        ...
class Certificate:
    def __eq__(self, arg0: Certificate) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __init__(self, arg0: str, arg1: list[int]) -> None:
        ...
    def get_canonical_initial_coloring(self) -> list[int]:
        ...
    def get_nauty_certificate(self) -> str:
        ...
class ConditionalEffect:
    def __str__(self) -> str:
        ...
    def get_derived_conditions(self) -> list[DerivedLiteral]:
        ...
    def get_effect(self) -> FluentLiteral:
        ...
    def get_fluent_conditions(self) -> list[FluentLiteral]:
        ...
    def get_identifier(self) -> int:
        ...
    def get_static_conditions(self) -> list[StaticLiteral]:
        ...
class DebugBrFSAlgorithmEventHandler(IBrFSAlgorithmEventHandler):
    def __init__(self) -> None:
        ...
class DebugGroundedAAGEventHandler(IGroundedAAGEventHandler):
    def __init__(self) -> None:
        ...
class DebugLiftedAAGEventHandler(ILiftedAAGEventHandler):
    def __init__(self) -> None:
        ...
class DefaultBrFSAlgorithmEventHandler(IBrFSAlgorithmEventHandler):
    def __init__(self) -> None:
        ...
class DefaultGroundedAAGEventHandler(IGroundedAAGEventHandler):
    def __init__(self) -> None:
        ...
class DefaultIWAlgorithmEventHandler(IIWAlgorithmEventHandler):
    def __init__(self) -> None:
        ...
class DefaultLiftedAAGEventHandler(ILiftedAAGEventHandler):
    def __init__(self) -> None:
        ...
class DefaultSIWAlgorithmEventHandler(ISIWAlgorithmEventHandler):
    def __init__(self) -> None:
        ...
class DenseNautyGraph:
    @typing.overload
    def __init__(self, is_directed: bool = False) -> None:
        ...
    @typing.overload
    def __init__(self, num_vertices: int, is_directed: bool = False) -> None:
        ...
    def add_edge(self, arg0: int, arg1: int) -> None:
        ...
    def compute_certificate(self, arg0: Partitioning) -> str:
        ...
    def reset(self, arg0: int, arg1: bool) -> None:
        ...
class DenseNautyGraphFactory:
    def __init__(self) -> None:
        ...
    def create_from_digraph(self, arg0: ...) -> DenseNautyGraph:
        ...
class DerivedAtom:
    def __str__(self) -> str:
        ...
    def get_identifier(self) -> int:
        ...
    def get_predicate(self) -> DerivedPredicate:
        ...
    def get_terms(self) -> list[Term]:
        ...
class DerivedGroundAtom:
    def __str__(self) -> str:
        ...
    def get_arity(self) -> int:
        ...
    def get_identifier(self) -> int:
        ...
    def get_objects(self) -> list[Object]:
        ...
    def get_predicate(self) -> DerivedPredicate:
        ...
class DerivedGroundLiteral:
    def __str__(self) -> str:
        ...
    def get_atom(self) -> DerivedGroundAtom:
        ...
    def get_identifier(self) -> int:
        ...
    def is_negated(self) -> bool:
        ...
class DerivedLiteral:
    def __str__(self) -> str:
        ...
    def get_atom(self) -> DerivedAtom:
        ...
    def get_identifier(self) -> int:
        ...
    def is_negated(self) -> bool:
        ...
class DerivedPredicate:
    def __str__(self) -> str:
        ...
    def get_arity(self) -> int:
        ...
    def get_identifier(self) -> int:
        ...
    def get_name(self) -> str:
        ...
    def get_parameters(self) -> list[Variable]:
        ...
class Digraph:
    @typing.overload
    def __init__(self, is_directed: bool = False) -> None:
        ...
    @typing.overload
    def __init__(self, num_vertices: int, is_directed: bool = False) -> None:
        ...
    def add_edge(self, source: int, target: int, weight: float = 1.0) -> int:
        ...
    def get_backward_edge_indices(self, arg0: int) -> typing.Iterator:
        ...
    def get_backward_edges(self, arg0: int) -> typing.Iterator:
        ...
    def get_edges(self) -> list[DigraphEdge]:
        ...
    def get_forward_edge_indices(self, arg0: int) -> typing.Iterator:
        ...
    def get_forward_edges(self, arg0: int) -> typing.Iterator:
        ...
    def get_num_edges(self) -> int:
        ...
    def get_num_vertices(self) -> int:
        ...
    def get_sources(self, arg0: int) -> typing.Iterator:
        ...
    def get_targets(self, arg0: int) -> typing.Iterator:
        ...
    def reset(self, num_vertices: int, is_directed: bool = False) -> None:
        ...
class DigraphEdge:
    def __eq__(self, arg0: DigraphEdge) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def get_index(self) -> int:
        ...
    def get_source(self) -> int:
        ...
    def get_target(self) -> int:
        ...
    def get_weight(self) -> float:
        ...
class Domain:
    def __str__(self) -> str:
        ...
    def get_actions(self) -> list[Action]:
        ...
    def get_constants(self) -> list[Object]:
        ...
    def get_derived_predicates(self) -> list[DerivedPredicate]:
        ...
    def get_fluent_predicates(self) -> list[FluentPredicate]:
        ...
    def get_functions(self) -> list[FunctionSkeleton]:
        ...
    def get_identifier(self) -> int:
        ...
    def get_name(self) -> str:
        ...
    def get_name_to_derived_predicate(self) -> dict[str, DerivedPredicate]:
        ...
    def get_name_to_fluent_predicate(self) -> dict[str, FluentPredicate]:
        ...
    def get_name_to_static_predicate(self) -> dict[str, StaticPredicate]:
        ...
    def get_requirements(self) -> Requirements:
        ...
    def get_static_predicates(self) -> list[StaticPredicate]:
        ...
class FaithfulAbstractState:
    def get_certificate(self) -> Certificate:
        ...
    def get_index(self) -> int:
        ...
    def get_representative_state(self) -> State:
        ...
    def get_states(self) -> list[State]:
        ...
class FaithfulAbstraction:
    @staticmethod
    @typing.overload
    def create(domain_filepath: str, problem_filepath: str, mark_true_goal_literals: bool = False, use_unit_cost_one: bool = True, remove_if_unsolvable: bool = True, compute_complete_abstraction_mapping: bool = False, max_num_states: int = 4294967295, timeout_ms: int = 4294967295) -> FaithfulAbstraction | None:
        ...
    @staticmethod
    @typing.overload
    def create(parser: PDDLParser, aag: IAAG, ssg: SuccessorStateGenerator, mark_true_goal_literals: bool = False, use_unit_cost_one: bool = True, remove_if_unsolvable: bool = True, compute_complete_abstraction_mapping: bool = False, max_num_states: int = 4294967295, timeout_ms: int = 4294967295) -> FaithfulAbstraction | None:
        ...
    @staticmethod
    @typing.overload
    def create(domain_filepath: str, problem_filepaths: list[str], mark_true_goal_literals: bool = False, use_unit_cost_one: bool = True, remove_if_unsolvable: bool = True, compute_complete_abstraction_mapping: bool = False, sort_ascending_by_num_states: bool = True, max_num_states: int = 4294967295, timeout_ms: int = 4294967295, num_threads: int = 4) -> list[FaithfulAbstraction]:
        ...
    @staticmethod
    @typing.overload
    def create(memories: list[tuple[PDDLParser, IAAG, SuccessorStateGenerator]], mark_true_goal_literals: bool = False, use_unit_cost_one: bool = True, remove_if_unsolvable: bool = True, compute_complete_abstraction_mapping: bool = False, sort_ascending_by_num_states: bool = True, max_num_states: int = 4294967295, timeout_ms: int = 4294967295, num_threads: int = 4) -> list[FaithfulAbstraction]:
        ...
    def compute_shortest_distances_from_states(self, arg0: list[int], arg1: bool) -> list[float]:
        ...
    def get_aag(self) -> IAAG:
        ...
    def get_abstract_state_index(self, arg0: State) -> int:
        ...
    def get_backward_transition_indices(self, arg0: int) -> typing.Iterator:
        ...
    def get_backward_transitions(self, arg0: int) -> typing.Iterator:
        ...
    def get_deadend_states(self) -> set[int]:
        ...
    def get_forward_transition_indices(self, arg0: int) -> typing.Iterator:
        ...
    def get_forward_transitions(self, arg0: int) -> typing.Iterator:
        ...
    def get_goal_distances(self) -> list[float]:
        ...
    def get_goal_states(self) -> set[int]:
        ...
    def get_initial_state(self) -> int:
        ...
    def get_num_deadend_states(self) -> int:
        ...
    def get_num_goal_states(self) -> int:
        ...
    def get_num_states(self) -> int:
        ...
    def get_num_transitions(self) -> int:
        ...
    def get_pddl_parser(self) -> PDDLParser:
        ...
    def get_source_states(self, arg0: int) -> typing.Iterator:
        ...
    def get_ssg(self) -> SuccessorStateGenerator:
        ...
    def get_states(self) -> list[FaithfulAbstractState]:
        ...
    def get_target_states(self, arg0: int) -> typing.Iterator:
        ...
    def get_transition_cost(self, arg0: int) -> float:
        ...
    def get_transitions(self) -> list[AbstractTransition]:
        ...
    def is_alive_state(self, arg0: int) -> bool:
        ...
    def is_deadend_state(self, arg0: int) -> bool:
        ...
    def is_goal_state(self, arg0: int) -> bool:
        ...
class FluentAndDerivedMapper:
    @typing.overload
    def combine_and_sort(self, arg0: State) -> list[int]:
        ...
    @typing.overload
    def combine_and_sort(self, arg0: State, arg1: State) -> tuple[list[int], list[int]]:
        ...
    def get_derived_remap(self) -> list[int]:
        ...
    def get_fluent_remap(self) -> list[int]:
        ...
    def get_inverse_remap(self) -> list[int]:
        ...
    def get_is_remapped_fluent(self) -> list[bool]:
        ...
    def inverse_remap_and_separate(self, arg0: list[int]) -> tuple[list[int], list[int]]:
        ...
class FluentAtom:
    def __str__(self) -> str:
        ...
    def get_identifier(self) -> int:
        ...
    def get_predicate(self) -> FluentPredicate:
        ...
    def get_terms(self) -> list[Term]:
        ...
class FluentGroundAtom:
    def __str__(self) -> str:
        ...
    def get_arity(self) -> int:
        ...
    def get_identifier(self) -> int:
        ...
    def get_objects(self) -> list[Object]:
        ...
    def get_predicate(self) -> FluentPredicate:
        ...
class FluentGroundLiteral:
    def __str__(self) -> str:
        ...
    def get_atom(self) -> FluentGroundAtom:
        ...
    def get_identifier(self) -> int:
        ...
    def is_negated(self) -> bool:
        ...
class FluentLiteral:
    def __str__(self) -> str:
        ...
    def get_atom(self) -> FluentAtom:
        ...
    def get_identifier(self) -> int:
        ...
    def is_negated(self) -> bool:
        ...
class FluentPredicate:
    def __str__(self) -> str:
        ...
    def get_arity(self) -> int:
        ...
    def get_identifier(self) -> int:
        ...
    def get_name(self) -> str:
        ...
    def get_parameters(self) -> list[Variable]:
        ...
class Function:
    def __str__(self) -> str:
        ...
    def get_function_skeleton(self) -> FunctionSkeleton:
        ...
    def get_identifier(self) -> int:
        ...
    def get_terms(self) -> list[Term]:
        ...
class FunctionExpression:
    def get(self) -> typing.Any:
        ...
class FunctionExpressionBinaryOperator:
    def __str__(self) -> str:
        ...
    def get_binary_operator(self) -> BinaryOperatorEnum:
        ...
    def get_identifier(self) -> int:
        ...
    def get_left_function_expression(self) -> FunctionExpression:
        ...
    def get_right_function_expression(self) -> FunctionExpression:
        ...
class FunctionExpressionFunction:
    def __str__(self) -> str:
        ...
    def get_function(self) -> Function:
        ...
    def get_identifier(self) -> int:
        ...
class FunctionExpressionMinus:
    def __str__(self) -> str:
        ...
    def get_function_expression(self) -> FunctionExpression:
        ...
    def get_identifier(self) -> int:
        ...
class FunctionExpressionMultiOperator:
    def __str__(self) -> str:
        ...
    def get_function_expressions(self) -> list[FunctionExpression]:
        ...
    def get_identifier(self) -> int:
        ...
    def get_multi_operator(self) -> MultiOperatorEnum:
        ...
class FunctionExpressionNumber:
    def __str__(self) -> str:
        ...
    def get_identifier(self) -> int:
        ...
    def get_number(self) -> float:
        ...
class FunctionSkeleton:
    def __str__(self) -> str:
        ...
    def get_identifier(self) -> int:
        ...
    def get_name(self) -> str:
        ...
    def get_parameters(self) -> list[Variable]:
        ...
class GlobalFaithfulAbstractState:
    def __eq__(self, arg0: GlobalFaithfulAbstractState) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def get_faithful_abstract_state_index(self) -> int:
        ...
    def get_faithful_abstraction_index(self) -> int:
        ...
    def get_global_index(self) -> int:
        ...
    def get_index(self) -> int:
        ...
class GlobalFaithfulAbstraction:
    @staticmethod
    @typing.overload
    def create(domain_filepath: str, problem_filepaths: list[str], mark_true_goal_literals: bool = False, use_unit_cost_one: bool = True, remove_if_unsolvable: bool = True, compute_complete_abstraction_mapping: bool = False, sort_ascending_by_num_states: bool = True, max_num_states: int = 4294967295, timeout_ms: int = 4294967295, num_threads: int = 4) -> list[GlobalFaithfulAbstraction]:
        ...
    @staticmethod
    @typing.overload
    def create(memories: list[tuple[PDDLParser, IAAG, SuccessorStateGenerator]], mark_true_goal_literals: bool = False, use_unit_cost_one: bool = True, remove_if_unsolvable: bool = True, compute_complete_abstraction_mapping: bool = False, sort_ascending_by_num_states: bool = True, max_num_states: int = 4294967295, timeout_ms: int = 4294967295, num_threads: int = 4) -> list[GlobalFaithfulAbstraction]:
        ...
    def get_aag(self) -> IAAG:
        ...
    def get_abstract_state_index(self, arg0: State) -> int:
        ...
    def get_abstractions(self) -> list[FaithfulAbstraction]:
        ...
    def get_backward_transition_indices(self, arg0: int) -> typing.Iterator:
        ...
    def get_backward_transitions(self, arg0: int) -> typing.Iterator:
        ...
    def get_deadend_states(self) -> set[int]:
        ...
    def get_forward_transition_indices(self, arg0: int) -> typing.Iterator:
        ...
    def get_forward_transitions(self, arg0: int) -> typing.Iterator:
        ...
    def get_goal_distances(self) -> list[float]:
        ...
    def get_goal_states(self) -> set[int]:
        ...
    def get_index(self) -> int:
        ...
    def get_initial_state(self) -> int:
        ...
    def get_num_deadend_states(self) -> int:
        ...
    def get_num_goal_states(self) -> int:
        ...
    def get_num_isomorphic_states(self) -> int:
        ...
    def get_num_non_isomorphic_states(self) -> int:
        ...
    def get_num_states(self) -> int:
        ...
    def get_num_transitions(self) -> int:
        ...
    def get_pddl_parser(self) -> PDDLParser:
        ...
    def get_source_states(self, arg0: int) -> typing.Iterator:
        ...
    def get_ssg(self) -> SuccessorStateGenerator:
        ...
    def get_states(self) -> list[GlobalFaithfulAbstractState]:
        ...
    def get_target_states(self, arg0: int) -> typing.Iterator:
        ...
    def get_transition_cost(self, arg0: int) -> float:
        ...
    def get_transitions(self) -> list[AbstractTransition]:
        ...
    def is_alive_state(self, arg0: int) -> bool:
        ...
    def is_deadend_state(self, arg0: int) -> bool:
        ...
    def is_goal_state(self, arg0: int) -> bool:
        ...
class GroundAction:
    def __eq__(self, arg0: GroundAction) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def get_id(self) -> int:
        ...
    def get_name(self) -> str:
        ...
    def get_terms(self) -> list[Object]:
        ...
    def to_string(self, arg0: PDDLFactories) -> str:
        ...
class GroundFunction:
    def __str__(self) -> str:
        ...
    def get_function_skeleton(self) -> FunctionSkeleton:
        ...
    def get_identifier(self) -> int:
        ...
    def get_objects(self) -> list[Object]:
        ...
class GroundFunctionExpression:
    def get(self) -> typing.Any:
        ...
class GroundFunctionExpressionBinaryOperator:
    def __str__(self) -> str:
        ...
    def get_binary_operator(self) -> BinaryOperatorEnum:
        ...
    def get_identifier(self) -> int:
        ...
    def get_left_function_expression(self) -> GroundFunctionExpression:
        ...
    def get_right_function_expression(self) -> GroundFunctionExpression:
        ...
class GroundFunctionExpressionFunction:
    def __str__(self) -> str:
        ...
    def get_function(self) -> GroundFunction:
        ...
    def get_identifier(self) -> int:
        ...
class GroundFunctionExpressionMinus:
    def __str__(self) -> str:
        ...
    def get_function_expression(self) -> GroundFunctionExpression:
        ...
    def get_identifier(self) -> int:
        ...
class GroundFunctionExpressionMultiOperator:
    def __str__(self) -> str:
        ...
    def get_function_expressions(self) -> list[GroundFunctionExpression]:
        ...
    def get_identifier(self) -> int:
        ...
    def get_multi_operator(self) -> MultiOperatorEnum:
        ...
class GroundFunctionExpressionNumber:
    def __str__(self) -> str:
        ...
    def get_identifier(self) -> int:
        ...
    def get_number(self) -> float:
        ...
class GroundedAAG(IAAG):
    @typing.overload
    def __init__(self, arg0: Problem, arg1: PDDLFactories) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Problem, arg1: PDDLFactories, arg2: IGroundedAAGEventHandler) -> None:
        ...
class IAAG:
    def compute_applicable_actions(self, arg0: State) -> list[GroundAction]:
        ...
    def get_action(self, arg0: int) -> GroundAction:
        ...
    def get_pddl_factories(self) -> PDDLFactories:
        ...
    def get_problem(self) -> Problem:
        ...
class IAlgorithm:
    def find_solution(self) -> tuple[SearchStatus, list[GroundAction]]:
        ...
class IBrFSAlgorithmEventHandler:
    pass
class IGroundedAAGEventHandler:
    pass
class IHeuristic:
    pass
class IIWAlgorithmEventHandler:
    pass
class ILiftedAAGEventHandler:
    pass
class ISIWAlgorithmEventHandler:
    pass
class IWAlgorithm(IAlgorithm):
    @typing.overload
    def __init__(self, arg0: IAAG, arg1: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: IAAG, arg1: int, arg2: SuccessorStateGenerator, arg3: IBrFSAlgorithmEventHandler, arg4: IIWAlgorithmEventHandler) -> None:
        ...
class LiftedAAG(IAAG):
    @typing.overload
    def __init__(self, arg0: Problem, arg1: PDDLFactories) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Problem, arg1: PDDLFactories, arg2: ILiftedAAGEventHandler) -> None:
        ...
class MultiOperatorEnum:
    """
    Members:
    
      MUL
    
      PLUS
    """
    MUL: typing.ClassVar[MultiOperatorEnum]  # value = <MultiOperatorEnum.MUL: 0>
    PLUS: typing.ClassVar[MultiOperatorEnum]  # value = <MultiOperatorEnum.PLUS: 1>
    __members__: typing.ClassVar[dict[str, MultiOperatorEnum]]  # value = {'MUL': <MultiOperatorEnum.MUL: 0>, 'PLUS': <MultiOperatorEnum.PLUS: 1>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class NumericFluent:
    def __str__(self) -> str:
        ...
    def get_function(self) -> GroundFunction:
        ...
    def get_identifier(self) -> int:
        ...
    def get_number(self) -> float:
        ...
class Object:
    def __str__(self) -> str:
        ...
    def get_identifier(self) -> int:
        ...
    def get_name(self) -> str:
        ...
class ObjectGraph:
    def __init__(self, arg0: ProblemColorFunction) -> None:
        ...
    def __str__(self) -> str:
        ...
    def get_coloring_function(self) -> ProblemColorFunction:
        ...
    def get_digraph(self) -> Digraph:
        ...
    def get_partitioning(self) -> Partitioning:
        ...
    def get_sorted_vertex_colors(self) -> list[int]:
        ...
    def get_vertex_colors(self) -> list[int]:
        ...
class ObjectGraphFactory:
    def __init__(self, problem: Problem, pddl_factories: PDDLFactories, mark_true_goal_literals: bool = False) -> None:
        ...
    def create(self, arg0: State) -> ObjectGraph:
        ...
    def get_coloring_function(self) -> ProblemColorFunction:
        ...
class OptimizationMetric:
    def __str__(self) -> str:
        ...
    def get_function_expression(self) -> GroundFunctionExpression:
        ...
    def get_identifier(self) -> int:
        ...
    def get_optimization_metric(self) -> OptimizationMetricEnum:
        ...
class OptimizationMetricEnum:
    """
    Members:
    
      MINIMIZE
    
      MAXIMIZE
    """
    MAXIMIZE: typing.ClassVar[OptimizationMetricEnum]  # value = <OptimizationMetricEnum.MAXIMIZE: 1>
    MINIMIZE: typing.ClassVar[OptimizationMetricEnum]  # value = <OptimizationMetricEnum.MINIMIZE: 0>
    __members__: typing.ClassVar[dict[str, OptimizationMetricEnum]]  # value = {'MINIMIZE': <OptimizationMetricEnum.MINIMIZE: 0>, 'MAXIMIZE': <OptimizationMetricEnum.MAXIMIZE: 1>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class PDDLFactories:
    def get_derived_ground_atom(self, arg0: int) -> DerivedGroundAtom:
        ...
    def get_derived_ground_atoms_from_ids(self, arg0: list[int]) -> list[DerivedGroundAtom]:
        ...
    def get_fluent_ground_atom(self, arg0: int) -> FluentGroundAtom:
        ...
    def get_fluent_ground_atoms_from_ids(self, arg0: list[int]) -> list[FluentGroundAtom]:
        ...
    def get_object(self, arg0: int) -> Object:
        ...
    def get_objects_from_ids(self, arg0: list[int]) -> list[Object]:
        ...
    def get_static_ground_atom(self, arg0: int) -> StaticGroundAtom:
        ...
    def get_static_ground_atoms_from_ids(self, arg0: list[int]) -> list[StaticGroundAtom]:
        ...
class PDDLParser:
    def __init__(self, arg0: str, arg1: str) -> None:
        ...
    def get_domain(self) -> Domain:
        ...
    def get_domain_filepath(self) -> str:
        ...
    def get_factories(self) -> PDDLFactories:
        ...
    def get_problem(self) -> Problem:
        ...
    def get_problem_filepath(self) -> str:
        ...
class Partitioning:
    def get_partition(self, arg0: int) -> ...:
        ...
    def get_partitioning(self) -> list[int]:
        ...
    def get_vertex_index_permutation(self) -> list[int]:
        ...
class Problem:
    def __str__(self) -> str:
        ...
    def get_derived_goal_condition(self) -> list[DerivedGroundLiteral]:
        ...
    def get_domain(self) -> Domain:
        ...
    def get_fluent_goal_condition(self) -> list[FluentGroundLiteral]:
        ...
    def get_fluent_initial_literals(self) -> list[FluentGroundLiteral]:
        ...
    def get_identifier(self) -> int:
        ...
    def get_name(self) -> str:
        ...
    def get_numeric_fluents(self) -> list[NumericFluent]:
        ...
    def get_objects(self) -> list[Object]:
        ...
    def get_optimization_metric(self) -> OptimizationMetric | None:
        ...
    def get_requirements(self) -> Requirements:
        ...
    def get_static_goal_condition(self) -> list[StaticGroundLiteral]:
        ...
    def get_static_initial_literals(self) -> list[StaticGroundLiteral]:
        ...
class ProblemColorFunction:
    def __init__(self, problem: Problem) -> None:
        ...
    @typing.overload
    def get_color(self, arg0: Object) -> int:
        ...
    @typing.overload
    def get_color(self, arg0: StaticGroundAtom, arg1: int) -> int:
        ...
    @typing.overload
    def get_color(self, arg0: FluentGroundAtom, arg1: int) -> int:
        ...
    @typing.overload
    def get_color(self, arg0: DerivedGroundAtom, arg1: int) -> int:
        ...
    @typing.overload
    def get_color(self, arg0: State, arg1: StaticGroundLiteral, arg2: int, arg3: bool) -> int:
        ...
    @typing.overload
    def get_color(self, arg0: State, arg1: FluentGroundLiteral, arg2: int, arg3: bool) -> int:
        ...
    @typing.overload
    def get_color(self, arg0: State, arg1: DerivedGroundLiteral, arg2: int, arg3: bool) -> int:
        ...
    def get_color_name(self, arg0: int) -> str:
        ...
    def get_color_to_name(self) -> dict[int, str]:
        ...
    def get_name_to_color(self) -> dict[str, int]:
        ...
    def get_problem(self) -> Problem:
        ...
class RequirementEnum:
    """
    Members:
    
      STRIPS
    
      TYPING
    
      NEGATIVE_PRECONDITIONS
    
      DISJUNCTIVE_PRECONDITIONS
    
      EQUALITY
    
      EXISTENTIAL_PRECONDITIONS
    
      UNIVERSAL_PRECONDITIONS
    
      QUANTIFIED_PRECONDITIONS
    
      CONDITIONAL_EFFECTS
    
      FLUENTS
    
      OBJECT_FLUENTS
    
      NUMERIC_FLUENTS
    
      ADL
    
      DURATIVE_ACTIONS
    
      DERIVED_PREDICATES
    
      TIMED_INITIAL_LITERALS
    
      PREFERENCES
    
      CONSTRAINTS
    
      ACTION_COSTS
    """
    ACTION_COSTS: typing.ClassVar[RequirementEnum]  # value = <RequirementEnum.ACTION_COSTS: 18>
    ADL: typing.ClassVar[RequirementEnum]  # value = <RequirementEnum.ADL: 12>
    CONDITIONAL_EFFECTS: typing.ClassVar[RequirementEnum]  # value = <RequirementEnum.CONDITIONAL_EFFECTS: 8>
    CONSTRAINTS: typing.ClassVar[RequirementEnum]  # value = <RequirementEnum.CONSTRAINTS: 17>
    DERIVED_PREDICATES: typing.ClassVar[RequirementEnum]  # value = <RequirementEnum.DERIVED_PREDICATES: 14>
    DISJUNCTIVE_PRECONDITIONS: typing.ClassVar[RequirementEnum]  # value = <RequirementEnum.DISJUNCTIVE_PRECONDITIONS: 3>
    DURATIVE_ACTIONS: typing.ClassVar[RequirementEnum]  # value = <RequirementEnum.DURATIVE_ACTIONS: 13>
    EQUALITY: typing.ClassVar[RequirementEnum]  # value = <RequirementEnum.EQUALITY: 4>
    EXISTENTIAL_PRECONDITIONS: typing.ClassVar[RequirementEnum]  # value = <RequirementEnum.EXISTENTIAL_PRECONDITIONS: 5>
    FLUENTS: typing.ClassVar[RequirementEnum]  # value = <RequirementEnum.FLUENTS: 9>
    NEGATIVE_PRECONDITIONS: typing.ClassVar[RequirementEnum]  # value = <RequirementEnum.NEGATIVE_PRECONDITIONS: 2>
    NUMERIC_FLUENTS: typing.ClassVar[RequirementEnum]  # value = <RequirementEnum.NUMERIC_FLUENTS: 11>
    OBJECT_FLUENTS: typing.ClassVar[RequirementEnum]  # value = <RequirementEnum.OBJECT_FLUENTS: 10>
    PREFERENCES: typing.ClassVar[RequirementEnum]  # value = <RequirementEnum.PREFERENCES: 16>
    QUANTIFIED_PRECONDITIONS: typing.ClassVar[RequirementEnum]  # value = <RequirementEnum.QUANTIFIED_PRECONDITIONS: 7>
    STRIPS: typing.ClassVar[RequirementEnum]  # value = <RequirementEnum.STRIPS: 0>
    TIMED_INITIAL_LITERALS: typing.ClassVar[RequirementEnum]  # value = <RequirementEnum.TIMED_INITIAL_LITERALS: 15>
    TYPING: typing.ClassVar[RequirementEnum]  # value = <RequirementEnum.TYPING: 1>
    UNIVERSAL_PRECONDITIONS: typing.ClassVar[RequirementEnum]  # value = <RequirementEnum.UNIVERSAL_PRECONDITIONS: 6>
    __members__: typing.ClassVar[dict[str, RequirementEnum]]  # value = {'STRIPS': <RequirementEnum.STRIPS: 0>, 'TYPING': <RequirementEnum.TYPING: 1>, 'NEGATIVE_PRECONDITIONS': <RequirementEnum.NEGATIVE_PRECONDITIONS: 2>, 'DISJUNCTIVE_PRECONDITIONS': <RequirementEnum.DISJUNCTIVE_PRECONDITIONS: 3>, 'EQUALITY': <RequirementEnum.EQUALITY: 4>, 'EXISTENTIAL_PRECONDITIONS': <RequirementEnum.EXISTENTIAL_PRECONDITIONS: 5>, 'UNIVERSAL_PRECONDITIONS': <RequirementEnum.UNIVERSAL_PRECONDITIONS: 6>, 'QUANTIFIED_PRECONDITIONS': <RequirementEnum.QUANTIFIED_PRECONDITIONS: 7>, 'CONDITIONAL_EFFECTS': <RequirementEnum.CONDITIONAL_EFFECTS: 8>, 'FLUENTS': <RequirementEnum.FLUENTS: 9>, 'OBJECT_FLUENTS': <RequirementEnum.OBJECT_FLUENTS: 10>, 'NUMERIC_FLUENTS': <RequirementEnum.NUMERIC_FLUENTS: 11>, 'ADL': <RequirementEnum.ADL: 12>, 'DURATIVE_ACTIONS': <RequirementEnum.DURATIVE_ACTIONS: 13>, 'DERIVED_PREDICATES': <RequirementEnum.DERIVED_PREDICATES: 14>, 'TIMED_INITIAL_LITERALS': <RequirementEnum.TIMED_INITIAL_LITERALS: 15>, 'PREFERENCES': <RequirementEnum.PREFERENCES: 16>, 'CONSTRAINTS': <RequirementEnum.CONSTRAINTS: 17>, 'ACTION_COSTS': <RequirementEnum.ACTION_COSTS: 18>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Requirements:
    def __str__(self) -> str:
        ...
    def get_identifier(self) -> int:
        ...
    def get_requirements(self) -> set[RequirementEnum]:
        ...
class SIWAlgorithm(IAlgorithm):
    @typing.overload
    def __init__(self, arg0: IAAG, arg1: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: IAAG, arg1: int, arg2: SuccessorStateGenerator, arg3: IBrFSAlgorithmEventHandler, arg4: IIWAlgorithmEventHandler, arg5: ISIWAlgorithmEventHandler) -> None:
        ...
class SearchNodeStatus:
    """
    Members:
    
      NEW
    
      OPEN
    
      CLOSED
    
      DEAD_END
    """
    CLOSED: typing.ClassVar[SearchNodeStatus]  # value = <SearchNodeStatus.CLOSED: 2>
    DEAD_END: typing.ClassVar[SearchNodeStatus]  # value = <SearchNodeStatus.DEAD_END: 3>
    NEW: typing.ClassVar[SearchNodeStatus]  # value = <SearchNodeStatus.NEW: 0>
    OPEN: typing.ClassVar[SearchNodeStatus]  # value = <SearchNodeStatus.OPEN: 1>
    __members__: typing.ClassVar[dict[str, SearchNodeStatus]]  # value = {'NEW': <SearchNodeStatus.NEW: 0>, 'OPEN': <SearchNodeStatus.OPEN: 1>, 'CLOSED': <SearchNodeStatus.CLOSED: 2>, 'DEAD_END': <SearchNodeStatus.DEAD_END: 3>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class SearchStatus:
    """
    Members:
    
      IN_PROGRESS
    
      OUT_OF_TIME
    
      OUT_OF_MEMORY
    
      FAILED
    
      EXHAUSTED
    
      SOLVED
    """
    EXHAUSTED: typing.ClassVar[SearchStatus]  # value = <SearchStatus.EXHAUSTED: 4>
    FAILED: typing.ClassVar[SearchStatus]  # value = <SearchStatus.FAILED: 3>
    IN_PROGRESS: typing.ClassVar[SearchStatus]  # value = <SearchStatus.IN_PROGRESS: 0>
    OUT_OF_MEMORY: typing.ClassVar[SearchStatus]  # value = <SearchStatus.OUT_OF_MEMORY: 2>
    OUT_OF_TIME: typing.ClassVar[SearchStatus]  # value = <SearchStatus.OUT_OF_TIME: 1>
    SOLVED: typing.ClassVar[SearchStatus]  # value = <SearchStatus.SOLVED: 5>
    __members__: typing.ClassVar[dict[str, SearchStatus]]  # value = {'IN_PROGRESS': <SearchStatus.IN_PROGRESS: 0>, 'OUT_OF_TIME': <SearchStatus.OUT_OF_TIME: 1>, 'OUT_OF_MEMORY': <SearchStatus.OUT_OF_MEMORY: 2>, 'FAILED': <SearchStatus.FAILED: 3>, 'EXHAUSTED': <SearchStatus.EXHAUSTED: 4>, 'SOLVED': <SearchStatus.SOLVED: 5>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class SimpleEffect:
    def __str__(self) -> str:
        ...
    def get_effect(self) -> FluentLiteral:
        ...
    def get_identifier(self) -> int:
        ...
class SparseNautyGraph:
    @typing.overload
    def __init__(self, is_directed: bool = False) -> None:
        ...
    @typing.overload
    def __init__(self, num_vertices: int, is_directed: bool = False) -> None:
        ...
    def add_edge(self, arg0: int, arg1: int) -> None:
        ...
    def compute_certificate(self, arg0: Partitioning) -> str:
        ...
    def reset(self, arg0: int, arg1: bool) -> None:
        ...
class SparseNautyGraphFactory:
    def __init__(self) -> None:
        ...
    def create_from_digraph(self, arg0: ...) -> SparseNautyGraph:
        ...
class State:
    def __eq__(self, arg0: State) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    @typing.overload
    def contains(self, arg0: FluentGroundAtom) -> bool:
        ...
    @typing.overload
    def contains(self, arg0: DerivedGroundAtom) -> bool:
        ...
    def get_derived_atoms(self) -> list[int]:
        ...
    def get_fluent_atoms(self) -> list[int]:
        ...
    def get_id(self) -> int:
        ...
    @typing.overload
    def literal_holds(self, arg0: FluentGroundLiteral) -> bool:
        ...
    @typing.overload
    def literal_holds(self, arg0: DerivedGroundLiteral) -> bool:
        ...
    @typing.overload
    def literals_hold(self, arg0: list[FluentGroundLiteral]) -> bool:
        ...
    @typing.overload
    def literals_hold(self, arg0: list[DerivedGroundLiteral]) -> bool:
        ...
    @typing.overload
    def superset_of(self, arg0: list[FluentGroundAtom]) -> bool:
        ...
    @typing.overload
    def superset_of(self, arg0: list[DerivedGroundAtom]) -> bool:
        ...
    def to_string(self, arg0: Problem, arg1: PDDLFactories) -> str:
        ...
class StateSpace:
    @staticmethod
    @typing.overload
    def create(domain_filepath: str, problem_filepaths: str, use_unit_cost_one: bool = True, remove_if_unsolvable: bool = True, max_num_states: int = 4294967295, timeout_ms: int = 4294967295) -> StateSpace | None:
        ...
    @staticmethod
    @typing.overload
    def create(parser: PDDLParser, aag: IAAG, ssg: SuccessorStateGenerator, use_unit_cost_one: bool = True, remove_if_unsolvable: bool = True, max_num_states: int = 4294967295, timeout_ms: int = 4294967295) -> StateSpace | None:
        ...
    @staticmethod
    @typing.overload
    def create(domain_filepath: str, problem_filepaths: list[str], use_unit_cost_one: bool = True, remove_if_unsolvable: bool = True, sort_ascending_by_num_states: bool = True, max_num_states: int = 4294967295, timeout_ms: int = 4294967295, num_threads: int = 4) -> list[StateSpace]:
        ...
    @staticmethod
    @typing.overload
    def create(memories: list[tuple[PDDLParser, IAAG, SuccessorStateGenerator]], use_unit_cost_one: bool = True, remove_if_unsolvable: bool = True, sort_ascending_by_num_states: bool = True, max_num_states: int = 4294967295, timeout_ms: int = 4294967295, num_threads: int = 4) -> list[StateSpace]:
        ...
    def compute_pairwise_shortest_state_distances(self, forward: bool = True) -> list[list[float]]:
        ...
    def compute_shortest_distances_from_states(self, states: list[int], forward: bool = True) -> list[float]:
        ...
    def get_aag(self) -> IAAG:
        ...
    def get_backward_transition_indices(self, arg0: int) -> typing.Iterator:
        ...
    def get_backward_transitions(self, arg0: int) -> typing.Iterator:
        ...
    def get_deadend_states(self) -> set[int]:
        ...
    def get_forward_transition_indices(self, arg0: int) -> typing.Iterator:
        ...
    def get_forward_transitions(self, arg0: int) -> typing.Iterator:
        ...
    def get_goal_distance(self, arg0: State) -> float:
        ...
    def get_goal_distances(self) -> list[float]:
        ...
    def get_goal_states(self) -> set[int]:
        ...
    def get_initial_state(self) -> int:
        ...
    def get_max_goal_distance(self) -> float:
        ...
    def get_num_deadend_states(self) -> int:
        ...
    def get_num_goal_states(self) -> int:
        ...
    def get_num_states(self) -> int:
        ...
    def get_num_transitions(self) -> int:
        ...
    def get_pddl_parser(self) -> PDDLParser:
        ...
    def get_source_states(self, arg0: int) -> typing.Iterator:
        ...
    def get_ssg(self) -> SuccessorStateGenerator:
        ...
    def get_state_index(self, arg0: State) -> int:
        ...
    def get_states(self) -> list[State]:
        ...
    def get_target_states(self, arg0: int) -> typing.Iterator:
        ...
    def get_transition_cost(self, arg0: int) -> float:
        ...
    def get_transitions(self) -> list[Transition]:
        ...
    def is_alive_state(self, arg0: int) -> bool:
        ...
    def is_deadend_state(self, arg0: int) -> bool:
        ...
    def is_goal_state(self, arg0: int) -> bool:
        ...
    def sample_state_with_goal_distance(self, arg0: float) -> int:
        ...
class StaticAtom:
    def __str__(self) -> str:
        ...
    def get_identifier(self) -> int:
        ...
    def get_predicate(self) -> StaticPredicate:
        ...
    def get_terms(self) -> list[Term]:
        ...
class StaticGroundAtom:
    def __str__(self) -> str:
        ...
    def get_arity(self) -> int:
        ...
    def get_identifier(self) -> int:
        ...
    def get_objects(self) -> list[Object]:
        ...
    def get_predicate(self) -> StaticPredicate:
        ...
class StaticGroundLiteral:
    def __str__(self) -> str:
        ...
    def get_atom(self) -> StaticGroundAtom:
        ...
    def get_identifier(self) -> int:
        ...
    def is_negated(self) -> bool:
        ...
class StaticLiteral:
    def __str__(self) -> str:
        ...
    def get_atom(self) -> StaticAtom:
        ...
    def get_identifier(self) -> int:
        ...
    def is_negated(self) -> bool:
        ...
class StaticPredicate:
    def __str__(self) -> str:
        ...
    def get_arity(self) -> int:
        ...
    def get_identifier(self) -> int:
        ...
    def get_name(self) -> str:
        ...
    def get_parameters(self) -> list[Variable]:
        ...
class SuccessorStateGenerator:
    def __init__(self, arg0: IAAG) -> None:
        ...
    def get_or_create_initial_state(self) -> State:
        ...
    def get_or_create_state(self, arg0: list[FluentGroundAtom]) -> State:
        ...
    def get_or_create_successor_state(self, arg0: State, arg1: GroundAction) -> State:
        ...
    def get_reached_derived_ground_atoms(self) -> list[int]:
        ...
    def get_reached_fluent_ground_atoms(self) -> list[int]:
        ...
    def get_state_count(self) -> int:
        ...
class Term:
    def get(self) -> typing.Any:
        ...
class TermObject:
    def __str__(self) -> str:
        ...
    def get_identifier(self) -> int:
        ...
    def get_object(self) -> Object:
        ...
class TermVariable:
    def __str__(self) -> str:
        ...
    def get_identifier(self) -> int:
        ...
    def get_variable(self) -> Variable:
        ...
class Transition:
    def __eq__(self, arg0: Transition) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def get_cost(self) -> float:
        ...
    def get_creating_action(self) -> GroundAction:
        ...
    def get_index(self) -> int:
        ...
    def get_source_state(self) -> int:
        ...
    def get_target_state(self) -> int:
        ...
class TupleGraph:
    def __str__(self) -> str:
        ...
    @typing.overload
    def compute_admissible_chain(self, arg0: list[FluentGroundAtom], arg1: list[DerivedGroundAtom]) -> list[int] | None:
        ...
    @typing.overload
    def compute_admissible_chain(self, arg0: list[State]) -> list[int] | None:
        ...
    def get_atom_index_mapper(self) -> FluentAndDerivedMapper:
        ...
    def get_backward_successors(self) -> list[list[int]]:
        ...
    def get_forward_successors(self) -> list[list[int]]:
        ...
    def get_root_state(self) -> State:
        ...
    def get_state_space(self) -> ...:
        ...
    def get_states_by_distance(self) -> list[list[State]]:
        ...
    def get_tuple_index_mapper(self) -> TupleIndexMapper:
        ...
    def get_vertex_indices_by_distances(self) -> list[list[int]]:
        ...
    def get_vertices(self) -> list[TupleGraphVertex]:
        ...
class TupleGraphFactory:
    def __init__(self, state_space: ..., arity: int, prune_dominated_tuples: bool = False) -> None:
        ...
    def create(self, arg0: State) -> TupleGraph:
        ...
    def get_atom_index_mapper(self) -> FluentAndDerivedMapper:
        ...
    def get_state_space(self) -> ...:
        ...
    def get_tuple_index_mapper(self) -> TupleIndexMapper:
        ...
class TupleGraphVertex:
    def get_identifier(self) -> int:
        ...
    def get_states(self) -> list[State]:
        ...
    def get_tuple_index(self) -> int:
        ...
class TupleIndexMapper:
    def get_arity(self) -> int:
        ...
    def get_empty_tuple_index(self) -> int:
        ...
    def get_factors(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(6)]:
        ...
    def get_max_tuple_index(self) -> int:
        ...
    def get_num_atoms(self) -> int:
        ...
    def to_atom_indices(self, arg0: int) -> list[int]:
        ...
    def to_tuple_index(self, arg0: list[int]) -> int:
        ...
    def tuple_index_to_string(self, arg0: int) -> str:
        ...
class UniversalEffect:
    def __str__(self) -> str:
        ...
    def get_derived_conditions(self) -> list[DerivedLiteral]:
        ...
    def get_effect(self) -> FluentLiteral:
        ...
    def get_fluent_conditions(self) -> list[FluentLiteral]:
        ...
    def get_identifier(self) -> int:
        ...
    def get_parameters(self) -> list[Variable]:
        ...
    def get_static_conditions(self) -> list[StaticLiteral]:
        ...
class Variable:
    def __str__(self) -> str:
        ...
    def get_identifier(self) -> int:
        ...
    def get_name(self) -> str:
        ...
ACTION_COSTS: RequirementEnum  # value = <RequirementEnum.ACTION_COSTS: 18>
ADL: RequirementEnum  # value = <RequirementEnum.ADL: 12>
ASSIGN: AssignOperatorEnum  # value = <AssignOperatorEnum.ASSIGN: 0>
CLOSED: SearchNodeStatus  # value = <SearchNodeStatus.CLOSED: 2>
CONDITIONAL_EFFECTS: RequirementEnum  # value = <RequirementEnum.CONDITIONAL_EFFECTS: 8>
CONSTRAINTS: RequirementEnum  # value = <RequirementEnum.CONSTRAINTS: 17>
DEAD_END: SearchNodeStatus  # value = <SearchNodeStatus.DEAD_END: 3>
DECREASE: AssignOperatorEnum  # value = <AssignOperatorEnum.DECREASE: 4>
DERIVED_PREDICATES: RequirementEnum  # value = <RequirementEnum.DERIVED_PREDICATES: 14>
DISJUNCTIVE_PRECONDITIONS: RequirementEnum  # value = <RequirementEnum.DISJUNCTIVE_PRECONDITIONS: 3>
DIV: BinaryOperatorEnum  # value = <BinaryOperatorEnum.DIV: 3>
DURATIVE_ACTIONS: RequirementEnum  # value = <RequirementEnum.DURATIVE_ACTIONS: 13>
EQUALITY: RequirementEnum  # value = <RequirementEnum.EQUALITY: 4>
EXHAUSTED: SearchStatus  # value = <SearchStatus.EXHAUSTED: 4>
EXISTENTIAL_PRECONDITIONS: RequirementEnum  # value = <RequirementEnum.EXISTENTIAL_PRECONDITIONS: 5>
FAILED: SearchStatus  # value = <SearchStatus.FAILED: 3>
FLUENTS: RequirementEnum  # value = <RequirementEnum.FLUENTS: 9>
INCREASE: AssignOperatorEnum  # value = <AssignOperatorEnum.INCREASE: 3>
IN_PROGRESS: SearchStatus  # value = <SearchStatus.IN_PROGRESS: 0>
MAXIMIZE: OptimizationMetricEnum  # value = <OptimizationMetricEnum.MAXIMIZE: 1>
MINIMIZE: OptimizationMetricEnum  # value = <OptimizationMetricEnum.MINIMIZE: 0>
MINUS: BinaryOperatorEnum  # value = <BinaryOperatorEnum.MINUS: 2>
MUL: MultiOperatorEnum  # value = <MultiOperatorEnum.MUL: 0>
NEGATIVE_PRECONDITIONS: RequirementEnum  # value = <RequirementEnum.NEGATIVE_PRECONDITIONS: 2>
NEW: SearchNodeStatus  # value = <SearchNodeStatus.NEW: 0>
NUMERIC_FLUENTS: RequirementEnum  # value = <RequirementEnum.NUMERIC_FLUENTS: 11>
OBJECT_FLUENTS: RequirementEnum  # value = <RequirementEnum.OBJECT_FLUENTS: 10>
OPEN: SearchNodeStatus  # value = <SearchNodeStatus.OPEN: 1>
OUT_OF_MEMORY: SearchStatus  # value = <SearchStatus.OUT_OF_MEMORY: 2>
OUT_OF_TIME: SearchStatus  # value = <SearchStatus.OUT_OF_TIME: 1>
PLUS: MultiOperatorEnum  # value = <MultiOperatorEnum.PLUS: 1>
PREFERENCES: RequirementEnum  # value = <RequirementEnum.PREFERENCES: 16>
QUANTIFIED_PRECONDITIONS: RequirementEnum  # value = <RequirementEnum.QUANTIFIED_PRECONDITIONS: 7>
SCALE_DOWN: AssignOperatorEnum  # value = <AssignOperatorEnum.SCALE_DOWN: 2>
SCALE_UP: AssignOperatorEnum  # value = <AssignOperatorEnum.SCALE_UP: 1>
SOLVED: SearchStatus  # value = <SearchStatus.SOLVED: 5>
STRIPS: RequirementEnum  # value = <RequirementEnum.STRIPS: 0>
TIMED_INITIAL_LITERALS: RequirementEnum  # value = <RequirementEnum.TIMED_INITIAL_LITERALS: 15>
TYPING: RequirementEnum  # value = <RequirementEnum.TYPING: 1>
UNIVERSAL_PRECONDITIONS: RequirementEnum  # value = <RequirementEnum.UNIVERSAL_PRECONDITIONS: 6>
__version__: str = 'dev'
