"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from .basesdk import BaseSDK
from clerk_dev import models
from clerk_dev._hooks import HookContext
from clerk_dev.types import Nullable
import clerk_dev.utils as utils
from typing import List, Optional

class InstanceSettingsSDK(BaseSDK):
    
    
    def update(
        self, *,
        allowed_origins: Optional[List[str]] = None,
        clerk_js_version: Optional[Nullable[str]] = None,
        cookieless_dev: Optional[bool] = None,
        development_origin: Optional[Nullable[str]] = None,
        enhanced_email_deliverability: Optional[Nullable[bool]] = None,
        hibp: Optional[Nullable[bool]] = None,
        support_email: Optional[Nullable[str]] = None,
        test_mode: Optional[Nullable[bool]] = None,
        url_based_session_syncing: Optional[bool] = None,
        server_url: Optional[str] = None,
    ):
        r"""Update instance settings

        Updates the settings of an instance

        :param allowed_origins: For browser-like stacks such as browser extensions, Electron, or Capacitor.js the instance allowed origins need to be updated with the request origin value. For Chrome extensions popup, background, or service worker pages the origin is chrome-extension://extension_uiid. For Electron apps the default origin is http://localhost:3000. For Capacitor, the origin is capacitor://localhost.
        :param clerk_js_version: 
        :param cookieless_dev: Whether the instance should operate in cookieless development mode (i.e. without third-party cookies). Deprecated: Please use `url_based_session_syncing` instead.
        :param development_origin: 
        :param enhanced_email_deliverability: The \"enhanced_email_deliverability\" feature will send emails from \"verifications@clerk.dev\" instead of your domain. This can be helpful if you do not have a high domain reputation.
        :param hibp: Whether the instance should be using the HIBP service to check passwords for breaches
        :param support_email: 
        :param test_mode: Toggles test mode for this instance, allowing the use of test email addresses and phone numbers. Defaults to true for development instances.
        :param url_based_session_syncing: Whether the instance should use URL-based session syncing in development mode (i.e. without third-party cookies).
        :param server_url: Override the default server URL for this method
        """
        base_url = None
        url_variables = None
        if server_url is not None:
            base_url = server_url
        
        request = models.UpdateInstanceRequestBody(
            allowed_origins=allowed_origins,
            clerk_js_version=clerk_js_version,
            cookieless_dev=cookieless_dev,
            development_origin=development_origin,
            enhanced_email_deliverability=enhanced_email_deliverability,
            hibp=hibp,
            support_email=support_email,
            test_mode=test_mode,
            url_based_session_syncing=url_based_session_syncing,
        )
        
        req = self.build_request(
            method="PATCH",
            path="/instance",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(request, False, True, "json", Optional[models.UpdateInstanceRequestBody]),
        )
        
        http_res = self.do_request(
            hook_ctx=HookContext(operation_id="UpdateInstance", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["422","4XX","5XX"],
        )
        
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 422:
            # pylint: disable=no-else-return
            if utils.match_content_type(http_res.headers.get("Content-Type") or "", "application/json"):                
                data = utils.unmarshal_json(http_res.text, models.ClerkErrorsData)
                out = models.ClerkErrors(data=data)
                  
                raise out
            
            content_type = http_res.headers.get("Content-Type")
            raise models.SDKError(f"unknown content-type received: {content_type}", http_res.status_code, http_res.text, http_res)
        elif http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise models.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        else:
            raise models.SDKError("unknown status code received", http_res.status_code, http_res.text, http_res)
    
    
    async def update_async(
        self, *,
        allowed_origins: Optional[List[str]] = None,
        clerk_js_version: Optional[Nullable[str]] = None,
        cookieless_dev: Optional[bool] = None,
        development_origin: Optional[Nullable[str]] = None,
        enhanced_email_deliverability: Optional[Nullable[bool]] = None,
        hibp: Optional[Nullable[bool]] = None,
        support_email: Optional[Nullable[str]] = None,
        test_mode: Optional[Nullable[bool]] = None,
        url_based_session_syncing: Optional[bool] = None,
        server_url: Optional[str] = None,
    ):
        r"""Update instance settings

        Updates the settings of an instance

        :param allowed_origins: For browser-like stacks such as browser extensions, Electron, or Capacitor.js the instance allowed origins need to be updated with the request origin value. For Chrome extensions popup, background, or service worker pages the origin is chrome-extension://extension_uiid. For Electron apps the default origin is http://localhost:3000. For Capacitor, the origin is capacitor://localhost.
        :param clerk_js_version: 
        :param cookieless_dev: Whether the instance should operate in cookieless development mode (i.e. without third-party cookies). Deprecated: Please use `url_based_session_syncing` instead.
        :param development_origin: 
        :param enhanced_email_deliverability: The \"enhanced_email_deliverability\" feature will send emails from \"verifications@clerk.dev\" instead of your domain. This can be helpful if you do not have a high domain reputation.
        :param hibp: Whether the instance should be using the HIBP service to check passwords for breaches
        :param support_email: 
        :param test_mode: Toggles test mode for this instance, allowing the use of test email addresses and phone numbers. Defaults to true for development instances.
        :param url_based_session_syncing: Whether the instance should use URL-based session syncing in development mode (i.e. without third-party cookies).
        :param server_url: Override the default server URL for this method
        """
        base_url = None
        url_variables = None
        if server_url is not None:
            base_url = server_url
        
        request = models.UpdateInstanceRequestBody(
            allowed_origins=allowed_origins,
            clerk_js_version=clerk_js_version,
            cookieless_dev=cookieless_dev,
            development_origin=development_origin,
            enhanced_email_deliverability=enhanced_email_deliverability,
            hibp=hibp,
            support_email=support_email,
            test_mode=test_mode,
            url_based_session_syncing=url_based_session_syncing,
        )
        
        req = self.build_request(
            method="PATCH",
            path="/instance",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(request, False, True, "json", Optional[models.UpdateInstanceRequestBody]),
        )
        
        http_res = await self.do_request_async(
            hook_ctx=HookContext(operation_id="UpdateInstance", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["422","4XX","5XX"],
        )
        
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 422:
            # pylint: disable=no-else-return
            if utils.match_content_type(http_res.headers.get("Content-Type") or "", "application/json"):                
                data = utils.unmarshal_json(http_res.text, models.ClerkErrorsData)
                out = models.ClerkErrors(data=data)
                  
                raise out
            
            content_type = http_res.headers.get("Content-Type")
            raise models.SDKError(f"unknown content-type received: {content_type}", http_res.status_code, http_res.text, http_res)
        elif http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise models.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        else:
            raise models.SDKError("unknown status code received", http_res.status_code, http_res.text, http_res)
    
    
    def update_organization_settings(
        self, *,
        admin_delete_enabled: Optional[Nullable[bool]] = None,
        creator_role_id: Optional[str] = None,
        domains_default_role_id: Optional[str] = None,
        domains_enabled: Optional[Nullable[bool]] = None,
        domains_enrollment_modes: Optional[List[str]] = None,
        enabled: Optional[Nullable[bool]] = None,
        max_allowed_memberships: Optional[Nullable[int]] = None,
        server_url: Optional[str] = None,
    ) -> models.OrganizationSettings:
        r"""Update instance organization settings

        Updates the organization settings of the instance

        :param admin_delete_enabled: 
        :param creator_role_id: Specify what the default organization role is for an organization creator.
        :param domains_default_role_id: Specify what the default organization role is for the organization domains.
        :param domains_enabled: 
        :param domains_enrollment_modes: Specify which enrollment modes to enable for your Organization Domains. Supported modes are 'automatic_invitation' & 'automatic_suggestion'.
        :param enabled: 
        :param max_allowed_memberships: 
        :param server_url: Override the default server URL for this method
        """
        base_url = None
        url_variables = None
        if server_url is not None:
            base_url = server_url
        
        request = models.UpdateInstanceOrganizationSettingsRequestBody(
            admin_delete_enabled=admin_delete_enabled,
            creator_role_id=creator_role_id,
            domains_default_role_id=domains_default_role_id,
            domains_enabled=domains_enabled,
            domains_enrollment_modes=domains_enrollment_modes,
            enabled=enabled,
            max_allowed_memberships=max_allowed_memberships,
        )
        
        req = self.build_request(
            method="PATCH",
            path="/instance/organization_settings",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(request, False, True, "json", Optional[models.UpdateInstanceOrganizationSettingsRequestBody]),
        )
        
        http_res = self.do_request(
            hook_ctx=HookContext(operation_id="UpdateInstanceOrganizationSettings", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["402","404","422","4XX","5XX"],
        )
        
        
        if http_res.status_code == 200:
            # pylint: disable=no-else-return
            if utils.match_content_type(http_res.headers.get("Content-Type") or "", "application/json"):                
                out = utils.unmarshal_json(http_res.text, Optional[models.OrganizationSettings])
                return out
            
            content_type = http_res.headers.get("Content-Type")
            raise models.SDKError(f"unknown content-type received: {content_type}", http_res.status_code, http_res.text, http_res)
        elif http_res.status_code in [402, 404, 422]:
            # pylint: disable=no-else-return
            if utils.match_content_type(http_res.headers.get("Content-Type") or "", "application/json"):                
                data = utils.unmarshal_json(http_res.text, models.ClerkErrorsData)
                out = models.ClerkErrors(data=data)
                  
                raise out
            
            content_type = http_res.headers.get("Content-Type")
            raise models.SDKError(f"unknown content-type received: {content_type}", http_res.status_code, http_res.text, http_res)
        elif http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise models.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        else:
            raise models.SDKError("unknown status code received", http_res.status_code, http_res.text, http_res)
    
    
    async def update_organization_settings_async(
        self, *,
        admin_delete_enabled: Optional[Nullable[bool]] = None,
        creator_role_id: Optional[str] = None,
        domains_default_role_id: Optional[str] = None,
        domains_enabled: Optional[Nullable[bool]] = None,
        domains_enrollment_modes: Optional[List[str]] = None,
        enabled: Optional[Nullable[bool]] = None,
        max_allowed_memberships: Optional[Nullable[int]] = None,
        server_url: Optional[str] = None,
    ) -> models.OrganizationSettings:
        r"""Update instance organization settings

        Updates the organization settings of the instance

        :param admin_delete_enabled: 
        :param creator_role_id: Specify what the default organization role is for an organization creator.
        :param domains_default_role_id: Specify what the default organization role is for the organization domains.
        :param domains_enabled: 
        :param domains_enrollment_modes: Specify which enrollment modes to enable for your Organization Domains. Supported modes are 'automatic_invitation' & 'automatic_suggestion'.
        :param enabled: 
        :param max_allowed_memberships: 
        :param server_url: Override the default server URL for this method
        """
        base_url = None
        url_variables = None
        if server_url is not None:
            base_url = server_url
        
        request = models.UpdateInstanceOrganizationSettingsRequestBody(
            admin_delete_enabled=admin_delete_enabled,
            creator_role_id=creator_role_id,
            domains_default_role_id=domains_default_role_id,
            domains_enabled=domains_enabled,
            domains_enrollment_modes=domains_enrollment_modes,
            enabled=enabled,
            max_allowed_memberships=max_allowed_memberships,
        )
        
        req = self.build_request(
            method="PATCH",
            path="/instance/organization_settings",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(request, False, True, "json", Optional[models.UpdateInstanceOrganizationSettingsRequestBody]),
        )
        
        http_res = await self.do_request_async(
            hook_ctx=HookContext(operation_id="UpdateInstanceOrganizationSettings", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["402","404","422","4XX","5XX"],
        )
        
        
        if http_res.status_code == 200:
            # pylint: disable=no-else-return
            if utils.match_content_type(http_res.headers.get("Content-Type") or "", "application/json"):                
                out = utils.unmarshal_json(http_res.text, Optional[models.OrganizationSettings])
                return out
            
            content_type = http_res.headers.get("Content-Type")
            raise models.SDKError(f"unknown content-type received: {content_type}", http_res.status_code, http_res.text, http_res)
        elif http_res.status_code in [402, 404, 422]:
            # pylint: disable=no-else-return
            if utils.match_content_type(http_res.headers.get("Content-Type") or "", "application/json"):                
                data = utils.unmarshal_json(http_res.text, models.ClerkErrorsData)
                out = models.ClerkErrors(data=data)
                  
                raise out
            
            content_type = http_res.headers.get("Content-Type")
            raise models.SDKError(f"unknown content-type received: {content_type}", http_res.status_code, http_res.text, http_res)
        elif http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise models.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        else:
            raise models.SDKError("unknown status code received", http_res.status_code, http_res.text, http_res)
    
    
    def update_restrictions(
        self, *,
        allowlist: Optional[Nullable[bool]] = None,
        block_disposable_email_domains: Optional[Nullable[bool]] = None,
        block_email_subaddresses: Optional[Nullable[bool]] = None,
        blocklist: Optional[Nullable[bool]] = None,
        ignore_dots_for_gmail_addresses: Optional[Nullable[bool]] = None,
        server_url: Optional[str] = None,
    ) -> models.InstanceRestrictions:
        r"""Update instance restrictions

        Updates the restriction settings of an instance

        :param allowlist: 
        :param block_disposable_email_domains: 
        :param block_email_subaddresses: 
        :param blocklist: 
        :param ignore_dots_for_gmail_addresses: 
        :param server_url: Override the default server URL for this method
        """
        base_url = None
        url_variables = None
        if server_url is not None:
            base_url = server_url
        
        request = models.UpdateInstanceRestrictionsRequestBody(
            allowlist=allowlist,
            block_disposable_email_domains=block_disposable_email_domains,
            block_email_subaddresses=block_email_subaddresses,
            blocklist=blocklist,
            ignore_dots_for_gmail_addresses=ignore_dots_for_gmail_addresses,
        )
        
        req = self.build_request(
            method="PATCH",
            path="/instance/restrictions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(request, False, True, "json", Optional[models.UpdateInstanceRestrictionsRequestBody]),
        )
        
        http_res = self.do_request(
            hook_ctx=HookContext(operation_id="UpdateInstanceRestrictions", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["402","422","4XX","5XX"],
        )
        
        
        if http_res.status_code == 200:
            # pylint: disable=no-else-return
            if utils.match_content_type(http_res.headers.get("Content-Type") or "", "application/json"):                
                out = utils.unmarshal_json(http_res.text, Optional[models.InstanceRestrictions])
                return out
            
            content_type = http_res.headers.get("Content-Type")
            raise models.SDKError(f"unknown content-type received: {content_type}", http_res.status_code, http_res.text, http_res)
        elif http_res.status_code in [402, 422]:
            # pylint: disable=no-else-return
            if utils.match_content_type(http_res.headers.get("Content-Type") or "", "application/json"):                
                data = utils.unmarshal_json(http_res.text, models.ClerkErrorsData)
                out = models.ClerkErrors(data=data)
                  
                raise out
            
            content_type = http_res.headers.get("Content-Type")
            raise models.SDKError(f"unknown content-type received: {content_type}", http_res.status_code, http_res.text, http_res)
        elif http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise models.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        else:
            raise models.SDKError("unknown status code received", http_res.status_code, http_res.text, http_res)
    
    
    async def update_restrictions_async(
        self, *,
        allowlist: Optional[Nullable[bool]] = None,
        block_disposable_email_domains: Optional[Nullable[bool]] = None,
        block_email_subaddresses: Optional[Nullable[bool]] = None,
        blocklist: Optional[Nullable[bool]] = None,
        ignore_dots_for_gmail_addresses: Optional[Nullable[bool]] = None,
        server_url: Optional[str] = None,
    ) -> models.InstanceRestrictions:
        r"""Update instance restrictions

        Updates the restriction settings of an instance

        :param allowlist: 
        :param block_disposable_email_domains: 
        :param block_email_subaddresses: 
        :param blocklist: 
        :param ignore_dots_for_gmail_addresses: 
        :param server_url: Override the default server URL for this method
        """
        base_url = None
        url_variables = None
        if server_url is not None:
            base_url = server_url
        
        request = models.UpdateInstanceRestrictionsRequestBody(
            allowlist=allowlist,
            block_disposable_email_domains=block_disposable_email_domains,
            block_email_subaddresses=block_email_subaddresses,
            blocklist=blocklist,
            ignore_dots_for_gmail_addresses=ignore_dots_for_gmail_addresses,
        )
        
        req = self.build_request(
            method="PATCH",
            path="/instance/restrictions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(request, False, True, "json", Optional[models.UpdateInstanceRestrictionsRequestBody]),
        )
        
        http_res = await self.do_request_async(
            hook_ctx=HookContext(operation_id="UpdateInstanceRestrictions", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["402","422","4XX","5XX"],
        )
        
        
        if http_res.status_code == 200:
            # pylint: disable=no-else-return
            if utils.match_content_type(http_res.headers.get("Content-Type") or "", "application/json"):                
                out = utils.unmarshal_json(http_res.text, Optional[models.InstanceRestrictions])
                return out
            
            content_type = http_res.headers.get("Content-Type")
            raise models.SDKError(f"unknown content-type received: {content_type}", http_res.status_code, http_res.text, http_res)
        elif http_res.status_code in [402, 422]:
            # pylint: disable=no-else-return
            if utils.match_content_type(http_res.headers.get("Content-Type") or "", "application/json"):                
                data = utils.unmarshal_json(http_res.text, models.ClerkErrorsData)
                out = models.ClerkErrors(data=data)
                  
                raise out
            
            content_type = http_res.headers.get("Content-Type")
            raise models.SDKError(f"unknown content-type received: {content_type}", http_res.status_code, http_res.text, http_res)
        elif http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise models.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        else:
            raise models.SDKError("unknown status code received", http_res.status_code, http_res.text, http_res)
    
