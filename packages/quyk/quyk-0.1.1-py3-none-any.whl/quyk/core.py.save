import sys
import os
import ast
import shutil
from .cli_test import registered_functions

# Get the data directory path based on XDG Base Directory Specification
def get_data_dir():
    xdg_data_home = os.getenv('XDG_DATA_HOME', os.path.join(os.path.expanduser("~"), '.local', 'share'))
    data_dir = os.path.join(xdg_data_home, 'quyk')
    os.makedirs(data_dir, exist_ok=True)
    return data_dir

def get_test_script_dir(dir_path):
    data_dir = get_data_dir()
    script_dir = os.path.join(data_dir, os.path.basename(os.path.abspath(dir_path)))
    os.makedirs(script_dir, exist_ok=True)
    return script_dir

def extract_decorated_functions(file_path):
    with open(file_path, "r") as source:
        tree = ast.parse(source.read(), filename=file_path)
    functions = []
    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef):
            for decorator in node.decorator_list:
                if isinstance(decorator, ast.Call) and decorator.func.id == 'cli_test':
                    print(f"decorator: {str(decorator.keyword)}")
                    print(f"decorator args: {decorator.args}")
                    print(f"decorator kwargs: {decorator.kwargs}")
                    test_args = [ast.literal_eval(*decorator.kwargs.get("test_args"))]
                    functions.append((node.name, test_args))
    return functions

def scan_directory(dir_path):
    global registered_functions
    registered_functions.clear()

    excluded_dirs = {'build', 'dist', '__pycache__'}

    for root, dirs, files in os.walk(dir_path):
        dirs[:] = [d for d in dirs if d not in excluded_dirs]
        for file in files:
            if file.endswith(".py"):
                file_path = os.path.join(root, file)
                functions = extract_decorated_functions(file_path)
                for func_name, test_args in functions:
                    registered_functions[func_name] = (file_path, test_args)

    script_dir = get_test_script_dir(dir_path)
    for func_name, (file_path, test_args) in registered_functions.items():
        script_path = os.path.join(script_dir, f"quyk_test_{func_name}.py")
        with open(script_path, 'w') as f:
            f.write(f"from {os.path.splitext(os.path.basename(file_path))[0]} import {func_name}\n")
            f.write(f"{func_name}(*{test_args})\n")

def test_function(func_name):
    script_dir = get_test_script_dir(".")
    script_path = os.path.join(script_dir, f"quyk_test_{func_name}.py")
    if not os.path.exists(script_path):
        print(f"Test script for function {func_name} not found. Run `quyk check` first.")
        return

    # Create a temporary copy of the test script in the same directory as the original function
    with open(script_path, 'r') as src_file:
        content = src_file.read()

    temp_script_path = f".temp.{os.path.basename(script_path)}"
    with open(temp_script_path, 'w') as temp_file:
        temp_file.write(content)

    try:
        os.system(f"python {temp_script_path}")
    finally:
        os.remove(temp_script_path)

def list_registered_functions():
    script_dir = get_test_script_dir(".")
    if not os.path.exists(script_dir) or not os.listdir(script_dir):
        print("No functions registered. Run `quyk check` first.")
        return
    print("Registered functions:")
    for file in os.listdir(script_dir):
        if file.startswith("quyk_test_") and file.endswith(".py"):
            func_name = file[len("quyk_test_"):-len(".py")]
            print(f" - {func_name}")

def main():
    if len(sys.argv) < 2:
        print("Usage: quyk <command> [args]")
        return
    command = sys.argv[1]
    if command == "check":
        dir_path = sys.argv[2] if len(sys.argv) > 2 else "."
        scan_directory(dir_path)
    elif command == "test":
        if len(sys.argv) > 2:
            func_name = sys.argv[2]
            test_function(func_name)
        else:
            list_registered_functions()
    else:
        print(f"Unknown command: {command}")
